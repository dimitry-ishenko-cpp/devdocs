<h1>futex(2) — Linux manual page</h1>   <pre>
<span class="headline"><i>futex</i>(2)                   System Calls Manual                  <i>futex</i>(2)</span>
</pre> <h2>
NAME </h2>
<pre>
       futex - fast user-space locking
</pre> <h2>
LIBRARY </h2>
<pre>
       Standard C library (<i>libc</i>, <i>-lc</i>)
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;linux/futex.h&gt;      </b>/* Definition of <b>FUTEX_* </b>constants */
       <b>#include &lt;sys/syscall.h&gt;      </b>/* Definition of <b>SYS_* </b>constants */
       <b>#include &lt;unistd.h&gt;</b>

       <b>long syscall(SYS_futex, uint32_t *</b><i>uaddr</i><b>, int </b><i>futex_op</i><b>, uint32_t </b><i>val</i><b>,</b>
                    <b>const struct timespec *</b><i>timeout</i><b>,   </b>/* or: <b>uint32_t </b><i>val2</i> <b>*/</b>
                    <b>uint32_t *</b><i>uaddr2</i><b>, uint32_t </b><i>val3</i><b>);</b>

       <i>Note</i>: glibc provides no wrapper for <b>futex</b>(), necessitating the
       use of <a href="syscall.2.html">syscall(2)</a>.
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <b>futex</b>() system call provides a method for waiting until a
       certain condition becomes true.  It is typically used as a
       blocking construct in the context of shared-memory
       synchronization.  When using futexes, the majority of the
       synchronization operations are performed in user space.  A user-
       space program employs the <b>futex</b>() system call only when it is
       likely that the program has to block for a longer time until the
       condition becomes true.  Other <b>futex</b>() operations can be used to
       wake any processes or threads waiting for a particular condition.

       A futex is a 32-bit value—referred to below as a <i>futex word</i>—whose
       address is supplied to the <b>futex</b>() system call.  (Futexes are 32
       bits in size on all platforms, including 64-bit systems.)  All
       futex operations are governed by this value.  In order to share a
       futex between processes, the futex is placed in a region of
       shared memory, created using (for example) <a href="mmap.2.html">mmap(2)</a> or <a href="shmat.2.html">shmat(2)</a>.
       (Thus, the futex word may have different virtual addresses in
       different processes, but these addresses all refer to the same
       location in physical memory.)  In a multithreaded program, it is
       sufficient to place the futex word in a global variable shared by
       all threads.

       When executing a futex operation that requests to block a thread,
       the kernel will block only if the futex word has the value that
       the calling thread supplied (as one of the arguments of the
       <b>futex</b>() call) as the expected value of the futex word.  The
       loading of the futex word's value, the comparison of that value
       with the expected value, and the actual blocking will happen
       atomically and will be totally ordered with respect to concurrent
       operations performed by other threads on the same futex word.
       Thus, the futex word is used to connect the synchronization in
       user space with the implementation of blocking by the kernel.
       Analogously to an atomic compare-and-exchange operation that
       potentially changes shared memory, blocking via a futex is an
       atomic compare-and-block operation.

       One use of futexes is for implementing locks.  The state of the
       lock (i.e., acquired or not acquired) can be represented as an
       atomically accessed flag in shared memory.  In the uncontended
       case, a thread can access or modify the lock state with atomic
       instructions, for example atomically changing it from not
       acquired to acquired using an atomic compare-and-exchange
       instruction.  (Such instructions are performed entirely in user
       mode, and the kernel maintains no information about the lock
       state.)  On the other hand, a thread may be unable to acquire a
       lock because it is already acquired by another thread.  It then
       may pass the lock's flag as a futex word and the value
       representing the acquired state as the expected value to a
       <b>futex</b>() wait operation.  This <b>futex</b>() operation will block if and
       only if the lock is still acquired (i.e., the value in the futex
       word still matches the "acquired state").  When releasing the
       lock, a thread has to first reset the lock state to not acquired
       and then execute a futex operation that wakes threads blocked on
       the lock flag used as a futex word (this can be further optimized
       to avoid unnecessary wake-ups).  See <a href="../man7/futex.7.html">futex(7)</a> for more detail on
       how to use futexes.

       Besides the basic wait and wake-up futex functionality, there are
       further futex operations aimed at supporting more complex use
       cases.

       Note that no explicit initialization or destruction is necessary
       to use futexes; the kernel maintains a futex (i.e., the kernel-
       internal implementation artifact) only while operations such as
       <b>FUTEX_WAIT</b>, described below, are being performed on a particular
       futex word.

   <b>Arguments</b>
       The <i>uaddr</i> argument points to the futex word.  On all platforms,
       futexes are four-byte integers that must be aligned on a four-
       byte boundary.  The operation to perform on the futex is
       specified in the <i>futex_op</i> argument; <i>val</i> is a value whose meaning
       and purpose depends on <i>futex_op</i>.

       The remaining arguments (<i>timeout</i>, <i>uaddr2</i>, and <i>val3</i>) are required
       only for certain of the futex operations described below.  Where
       one of these arguments is not required, it is ignored.

       For several blocking operations, the <i>timeout</i> argument is a
       pointer to a <i>timespec</i> structure that specifies a timeout for the
       operation.  However,  notwithstanding the prototype shown above,
       for some operations, the least significant four bytes of this
       argument are instead used as an integer whose meaning is
       determined by the operation.  For these operations, the kernel
       casts the <i>timeout</i> value first to <i>unsigned long</i>, then to <i>uint32_t</i>,
       and in the remainder of this page, this argument is referred to
       as <i>val2</i> when interpreted in this fashion.

       Where it is required, the <i>uaddr2</i> argument is a pointer to a
       second futex word that is employed by the operation.

       The interpretation of the final integer argument, <i>val3</i>, depends
       on the operation.

   <b>Futex operations</b>
       The <i>futex_op</i> argument consists of two parts: a command that
       specifies the operation to be performed, bitwise ORed with zero
       or more options that modify the behaviour of the operation.  The
       options that may be included in <i>futex_op</i> are as follows:

       <b>FUTEX_PRIVATE_FLAG </b>(since Linux 2.6.22)
              This option bit can be employed with all futex operations.
              It tells the kernel that the futex is process-private and
              not shared with another process (i.e., it is being used
              for synchronization only between threads of the same
              process).  This allows the kernel to make some additional
              performance optimizations.

              As a convenience, <i>&lt;linux/futex.h&gt;</i> defines a set of
              constants with the suffix <b>_PRIVATE </b>that are equivalents of
              all of the operations listed below, but with the
              <b>FUTEX_PRIVATE_FLAG </b>ORed into the constant value.  Thus,
              there are <b>FUTEX_WAIT_PRIVATE</b>, <b>FUTEX_WAKE_PRIVATE</b>, and so
              on.

       <b>FUTEX_CLOCK_REALTIME </b>(since Linux 2.6.28)
              This option bit can be employed only with the
              <b>FUTEX_WAIT_BITSET</b>, <b>FUTEX_WAIT_REQUEUE_PI</b>, (since Linux
              4.5) <b>FUTEX_WAIT</b>, and (since Linux 5.14) <b>FUTEX_LOCK_PI2</b>
              operations.

              If this option is set, the kernel measures the <i>timeout</i>
              against the <b>CLOCK_REALTIME </b>clock.

              If this option is not set, the kernel measures the <i>timeout</i>
              against the <b>CLOCK_MONOTONIC </b>clock.

       The operation specified in <i>futex_op</i> is one of the following:

       <b>FUTEX_WAIT </b>(since Linux 2.6.0)
              This operation tests that the value at the futex word
              pointed to by the address <i>uaddr</i> still contains the
              expected value <i>val</i>, and if so, then sleeps waiting for a
              <b>FUTEX_WAKE </b>operation on the futex word.  The load of the
              value of the futex word is an atomic memory access (i.e.,
              using atomic machine instructions of the respective
              architecture).  This load, the comparison with the
              expected value, and starting to sleep are performed
              atomically and totally ordered with respect to other futex
              operations on the same futex word.  If the thread starts
              to sleep, it is considered a waiter on this futex word.
              If the futex value does not match <i>val</i>, then the call fails
              immediately with the error <b>EAGAIN</b>.

              The purpose of the comparison with the expected value is
              to prevent lost wake-ups.  If another thread changed the
              value of the futex word after the calling thread decided
              to block based on the prior value, and if the other thread
              executed a <b>FUTEX_WAKE </b>operation (or similar wake-up) after
              the value change and before this <b>FUTEX_WAIT </b>operation,
              then the calling thread will observe the value change and
              will not start to sleep.

              If the <i>timeout</i> is not NULL, the structure it points to
              specifies a timeout for the wait.  (This interval will be
              rounded up to the system clock granularity, and is
              guaranteed not to expire early.)  The timeout is by
              default measured according to the <b>CLOCK_MONOTONIC </b>clock,
              but, since Linux 4.5, the <b>CLOCK_REALTIME </b>clock can be
              selected by specifying <b>FUTEX_CLOCK_REALTIME </b>in <i>futex_op</i>.
              If <i>timeout</i> is NULL, the call blocks indefinitely.

              <i>Note</i>: for <b>FUTEX_WAIT</b>, <i>timeout</i> is interpreted as a <i>relative</i>
              value.  This differs from other futex operations, where
              <i>timeout</i> is interpreted as an absolute value.  To obtain
              the equivalent of <b>FUTEX_WAIT </b>with an absolute timeout,
              employ <b>FUTEX_WAIT_BITSET </b>with <i>val3</i> specified as
              <b>FUTEX_BITSET_MATCH_ANY</b>.

              The arguments <i>uaddr2</i> and <i>val3</i> are ignored.

       <b>FUTEX_WAKE </b>(since Linux 2.6.0)
              This operation wakes at most <i>val</i> of the waiters that are
              waiting (e.g., inside <b>FUTEX_WAIT</b>) on the futex word at the
              address <i>uaddr</i>.  Most commonly, <i>val</i> is specified as either
              1 (wake up a single waiter) or <b>INT_MAX </b>(wake up all
              waiters).  No guarantee is provided about which waiters
              are awoken (e.g., a waiter with a higher scheduling
              priority is not guaranteed to be awoken in preference to a
              waiter with a lower priority).

              The arguments <i>timeout</i>, <i>uaddr2</i>, and <i>val3</i> are ignored.

       <b>FUTEX_FD </b>(from Linux 2.6.0 up to and including Linux 2.6.25)
              This operation creates a file descriptor that is
              associated with the futex at <i>uaddr</i>.  The caller must close
              the returned file descriptor after use.  When another
              process or thread performs a <b>FUTEX_WAKE </b>on the futex word,
              the file descriptor indicates as being readable with
              <a href="select.2.html">select(2)</a>, <a href="poll.2.html">poll(2)</a>, and <a href="../man7/epoll.7.html">epoll(7)</a>

              The file descriptor can be used to obtain asynchronous
              notifications: if <i>val</i> is nonzero, then, when another
              process or thread executes a <b>FUTEX_WAKE</b>, the caller will
              receive the signal number that was passed in <i>val</i>.

              The arguments <i>timeout</i>, <i>uaddr2</i>, and <i>val3</i> are ignored.

              Because it was inherently racy, <b>FUTEX_FD </b>has been removed
              from Linux 2.6.26 onward.

       <b>FUTEX_REQUEUE </b>(since Linux 2.6.0)
              This operation performs the same task as <b>FUTEX_CMP_REQUEUE</b>
              (see below), except that no check is made using the value
              in <i>val3</i>.  (The argument <i>val3</i> is ignored.)

       <b>FUTEX_CMP_REQUEUE </b>(since Linux 2.6.7)
              This operation first checks whether the location <i>uaddr</i>
              still contains the value <i>val3</i>.  If not, the operation
              fails with the error <b>EAGAIN</b>.  Otherwise, the operation
              wakes up a maximum of <i>val</i> waiters that are waiting on the
              futex at <i>uaddr</i>.  If there are more than <i>val</i> waiters, then
              the remaining waiters are removed from the wait queue of
              the source futex at <i>uaddr</i> and added to the wait queue of
              the target futex at <i>uaddr2</i>.  The <i>val2</i> argument specifies
              an upper limit on the number of waiters that are requeued
              to the futex at <i>uaddr2</i>.

              The load from <i>uaddr</i> is an atomic memory access (i.e.,
              using atomic machine instructions of the respective
              architecture).  This load, the comparison with <i>val3</i>, and
              the requeueing of any waiters are performed atomically and
              totally ordered with respect to other operations on the
              same futex word.

              Typical values to specify for <i>val</i> are 0 or 1.  (Specifying
              <b>INT_MAX </b>is not useful, because it would make the
              <b>FUTEX_CMP_REQUEUE </b>operation equivalent to <b>FUTEX_WAKE</b>.)
              The limit value specified via <i>val2</i> is typically either 1
              or <b>INT_MAX</b>.  (Specifying the argument as 0 is not useful,
              because it would make the <b>FUTEX_CMP_REQUEUE </b>operation
              equivalent to <b>FUTEX_WAIT</b>.)

              The <b>FUTEX_CMP_REQUEUE </b>operation was added as a replacement
              for the earlier <b>FUTEX_REQUEUE</b>.  The difference is that the
              check of the value at <i>uaddr</i> can be used to ensure that
              requeueing happens only under certain conditions, which
              allows race conditions to be avoided in certain use cases.

              Both <b>FUTEX_REQUEUE </b>and <b>FUTEX_CMP_REQUEUE </b>can be used to
              avoid "thundering herd" wake-ups that could occur when
              using <b>FUTEX_WAKE </b>in cases where all of the waiters that
              are woken need to acquire another futex.  Consider the
              following scenario, where multiple waiter threads are
              waiting on B, a wait queue implemented using a futex:

                  lock(A)
                  while (!check_value(V)) {
                      unlock(A);
                      block_on(B);
                      lock(A);
                  };
                  unlock(A);

              If a waker thread used <b>FUTEX_WAKE</b>, then all waiters
              waiting on B would be woken up, and they would all try to
              acquire lock A.  However, waking all of the threads in
              this manner would be pointless because all except one of
              the threads would immediately block on lock A again.  By
              contrast, a requeue operation wakes just one waiter and
              moves the other waiters to lock A, and when the woken
              waiter unlocks A then the next waiter can proceed.

       <b>FUTEX_WAKE_OP </b>(since Linux 2.6.14)
              This operation was added to support some user-space use
              cases where more than one futex must be handled at the
              same time.  The most notable example is the implementation
              of <a href="../man3/pthread_cond_signal.3.html">pthread_cond_signal(3)</a>, which requires operations on
              two futexes, the one used to implement the mutex and the
              one used in the implementation of the wait queue
              associated with the condition variable.  <b>FUTEX_WAKE_OP</b>
              allows such cases to be implemented without leading to
              high rates of contention and context switching.

              The <b>FUTEX_WAKE_OP </b>operation is equivalent to executing the
              following code atomically and totally ordered with respect
              to other futex operations on any of the two supplied futex
              words:

                  uint32_t oldval = *(uint32_t *) uaddr2;
                  *(uint32_t *) uaddr2 = oldval <i>op oparg</i>;
                  futex(uaddr, FUTEX_WAKE, val, 0, 0, 0);
                  if (oldval <i>cmp cmparg</i>)
                      futex(uaddr2, FUTEX_WAKE, val2, 0, 0, 0);

              In other words, <b>FUTEX_WAKE_OP </b>does the following:

              •  saves the original value of the futex word at <i>uaddr2</i>
                 and performs an operation to modify the value of the
                 futex at <i>uaddr2</i>; this is an atomic read-modify-write
                 memory access (i.e., using atomic machine instructions
                 of the respective architecture)

              •  wakes up a maximum of <i>val</i> waiters on the futex for the
                 futex word at <i>uaddr</i>; and

              •  dependent on the results of a test of the original
                 value of the futex word at <i>uaddr2</i>, wakes up a maximum
                 of <i>val2</i> waiters on the futex for the futex word at
                 <i>uaddr2</i>.

              The operation and comparison that are to be performed are
              encoded in the bits of the argument <i>val3</i>.  Pictorially,
              the encoding is:

                  +---+---+-----------+-----------+
                  |op |cmp|   oparg   |  cmparg   |
                  +---+---+-----------+-----------+
                    4   4       12          12    &lt;== # of bits

              Expressed in code, the encoding is:

                  #define FUTEX_OP(op, oparg, cmp, cmparg) \
                                  (((op &amp; 0xf) &lt;&lt; 28) | \
                                  ((cmp &amp; 0xf) &lt;&lt; 24) | \
                                  ((oparg &amp; 0xfff) &lt;&lt; 12) | \
                                  (cmparg &amp; 0xfff))

              In the above, <i>op</i> and <i>cmp</i> are each one of the codes listed
              below.  The <i>oparg</i> and <i>cmparg</i> components are literal
              numeric values, except as noted below.

              The <i>op</i> component has one of the following values:

                  FUTEX_OP_SET        0  /* uaddr2 = oparg; */
                  FUTEX_OP_ADD        1  /* uaddr2 += oparg; */
                  FUTEX_OP_OR         2  /* uaddr2 |= oparg; */
                  FUTEX_OP_ANDN       3  /* uaddr2 &amp;= ~oparg; */
                  FUTEX_OP_XOR        4  /* uaddr2 ^= oparg; */

              In addition, bitwise ORing the following value into <i>op</i>
              causes <i>(1 &lt;&lt; oparg)</i> to be used as the operand:

                  FUTEX_OP_ARG_SHIFT  8  /* Use (1 &lt;&lt; oparg) as operand */

              The <i>cmp</i> field is one of the following:

                  FUTEX_OP_CMP_EQ     0  /* if (oldval == cmparg) wake */
                  FUTEX_OP_CMP_NE     1  /* if (oldval != cmparg) wake */
                  FUTEX_OP_CMP_LT     2  /* if (oldval &lt; cmparg) wake */
                  FUTEX_OP_CMP_LE     3  /* if (oldval &lt;= cmparg) wake */
                  FUTEX_OP_CMP_GT     4  /* if (oldval &gt; cmparg) wake */
                  FUTEX_OP_CMP_GE     5  /* if (oldval &gt;= cmparg) wake */

              The return value of <b>FUTEX_WAKE_OP </b>is the sum of the number
              of waiters woken on the futex <i>uaddr</i> plus the number of
              waiters woken on the futex <i>uaddr2</i>.

       <b>FUTEX_WAIT_BITSET </b>(since Linux 2.6.25)
              This operation is like <b>FUTEX_WAIT </b>except that <i>val3</i> is used
              to provide a 32-bit bit mask to the kernel.  This bit
              mask, in which at least one bit must be set, is stored in
              the kernel-internal state of the waiter.  See the
              description of <b>FUTEX_WAKE_BITSET </b>for further details.

              If <i>timeout</i> is not NULL, the structure it points to
              specifies an absolute timeout for the wait operation.  If
              <i>timeout</i> is NULL, the operation can block indefinitely.

              The <i>uaddr2</i> argument is ignored.

       <b>FUTEX_WAKE_BITSET </b>(since Linux 2.6.25)
              This operation is the same as <b>FUTEX_WAKE </b>except that the
              <i>val3</i> argument is used to provide a 32-bit bit mask to the
              kernel.  This bit mask, in which at least one bit must be
              set, is used to select which waiters should be woken up.
              The selection is done by a bitwise AND of the "wake" bit
              mask (i.e., the value in <i>val3</i>) and the bit mask which is
              stored in the kernel-internal state of the waiter (the
              "wait" bit mask that is set using <b>FUTEX_WAIT_BITSET</b>).  All
              of the waiters for which the result of the AND is nonzero
              are woken up; the remaining waiters are left sleeping.

              The effect of <b>FUTEX_WAIT_BITSET </b>and <b>FUTEX_WAKE_BITSET </b>is
              to allow selective wake-ups among multiple waiters that
              are blocked on the same futex.  However, note that,
              depending on the use case, employing this bit-mask
              multiplexing feature on a futex can be less efficient than
              simply using multiple futexes, because employing bit-mask
              multiplexing requires the kernel to check all waiters on a
              futex, including those that are not interested in being
              woken up (i.e., they do not have the relevant bit set in
              their "wait" bit mask).

              The constant <b>FUTEX_BITSET_MATCH_ANY</b>, which corresponds to
              all 32 bits set in the bit mask, can be used as the <i>val3</i>
              argument for <b>FUTEX_WAIT_BITSET </b>and <b>FUTEX_WAKE_BITSET</b>.
              Other than differences in the handling of the <i>timeout</i>
              argument, the <b>FUTEX_WAIT </b>operation is equivalent to
              <b>FUTEX_WAIT_BITSET </b>with <i>val3</i> specified as
              <b>FUTEX_BITSET_MATCH_ANY</b>; that is, allow a wake-up by any
              waker.  The <b>FUTEX_WAKE </b>operation is equivalent to
              <b>FUTEX_WAKE_BITSET </b>with <i>val3</i> specified as
              <b>FUTEX_BITSET_MATCH_ANY</b>; that is, wake up any waiter(s).

              The <i>uaddr2</i> and <i>timeout</i> arguments are ignored.

   <b>Priority-inheritance futexes</b>
       Linux supports priority-inheritance (PI) futexes in order to
       handle priority-inversion problems that can be encountered with
       normal futex locks.  Priority inversion is the problem that
       occurs when a high-priority task is blocked waiting to acquire a
       lock held by a low-priority task, while tasks at an intermediate
       priority continuously preempt the low-priority task from the CPU.
       Consequently, the low-priority task makes no progress toward
       releasing the lock, and the high-priority task remains blocked.

       Priority inheritance is a mechanism for dealing with the
       priority-inversion problem.  With this mechanism, when a high-
       priority task becomes blocked by a lock held by a low-priority
       task, the priority of the low-priority task is temporarily raised
       to that of the high-priority task, so that it is not preempted by
       any intermediate level tasks, and can thus make progress toward
       releasing the lock.  To be effective, priority inheritance must
       be transitive, meaning that if a high-priority task blocks on a
       lock held by a lower-priority task that is itself blocked by a
       lock held by another intermediate-priority task (and so on, for
       chains of arbitrary length), then both of those tasks (or more
       generally, all of the tasks in a lock chain) have their
       priorities raised to be the same as the high-priority task.

       From a user-space perspective, what makes a futex PI-aware is a
       policy agreement (described below) between user space and the
       kernel about the value of the futex word, coupled with the use of
       the PI-futex operations described below.  (Unlike the other futex
       operations described above, the PI-futex operations are designed
       for the implementation of very specific IPC mechanisms.)

       The PI-futex operations described below differ from the other
       futex operations in that they impose policy on the use of the
       value of the futex word:

       •  If the lock is not acquired, the futex word's value shall be
          0.

       •  If the lock is acquired, the futex word's value shall be the
          thread ID (TID; see <a href="gettid.2.html">gettid(2)</a>) of the owning thread.

       •  If the lock is owned and there are threads contending for the
          lock, then the <b>FUTEX_WAITERS </b>bit shall be set in the futex
          word's value; in other words, this value is:

              FUTEX_WAITERS | TID

          (Note that is invalid for a PI futex word to have no owner and
          <b>FUTEX_WAITERS </b>set.)

       With this policy in place, a user-space application can acquire
       an unacquired lock or release a lock using atomic instructions
       executed in user mode (e.g., a compare-and-swap operation such as
       <i>cmpxchg</i> on the x86 architecture).  Acquiring a lock simply
       consists of using compare-and-swap to atomically set the futex
       word's value to the caller's TID if its previous value was 0.
       Releasing a lock requires using compare-and-swap to set the futex
       word's value to 0 if the previous value was the expected TID.

       If a futex is already acquired (i.e., has a nonzero value),
       waiters must employ the <b>FUTEX_LOCK_PI </b>or <b>FUTEX_LOCK_PI2</b>
       operations to acquire the lock.  If other threads are waiting for
       the lock, then the <b>FUTEX_WAITERS </b>bit is set in the futex value;
       in this case, the lock owner must employ the <b>FUTEX_UNLOCK_PI</b>
       operation to release the lock.

       In the cases where callers are forced into the kernel (i.e.,
       required to perform a <b>futex</b>() call), they then deal directly with
       a so-called RT-mutex, a kernel locking mechanism which implements
       the required priority-inheritance semantics.  After the RT-mutex
       is acquired, the futex value is updated accordingly, before the
       calling thread returns to user space.

       It is important to note that the kernel will update the futex
       word's value prior to returning to user space.  (This prevents
       the possibility of the futex word's value ending up in an invalid
       state, such as having an owner but the value being 0, or having
       waiters but not having the <b>FUTEX_WAITERS </b>bit set.)

       If a futex has an associated RT-mutex in the kernel (i.e., there
       are blocked waiters) and the owner of the futex/RT-mutex dies
       unexpectedly, then the kernel cleans up the RT-mutex and hands it
       over to the next waiter.  This in turn requires that the user-
       space value is updated accordingly.  To indicate that this is
       required, the kernel sets the <b>FUTEX_OWNER_DIED </b>bit in the futex
       word along with the thread ID of the new owner.  User space can
       detect this situation via the presence of the <b>FUTEX_OWNER_DIED</b>
       bit and is then responsible for cleaning up the stale state left
       over by the dead owner.

       PI futexes are operated on by specifying one of the values listed
       below in <i>futex_op</i>.  Note that the PI futex operations must be
       used as paired operations and are subject to some additional
       requirements:

       •  <b>FUTEX_LOCK_PI</b>, <b>FUTEX_LOCK_PI2</b>, and <b>FUTEX_TRYLOCK_PI </b>pair with
          <b>FUTEX_UNLOCK_PI</b>.  <b>FUTEX_UNLOCK_PI </b>must be called only on a
          futex owned by the calling thread, as defined by the value
          policy, otherwise the error <b>EPERM </b>results.

       •  <b>FUTEX_WAIT_REQUEUE_PI </b>pairs with <b>FUTEX_CMP_REQUEUE_PI</b>.  This
          must be performed from a non-PI futex to a distinct PI futex
          (or the error <b>EINVAL </b>results).  Additionally, <i>val</i> (the number
          of waiters to be woken) must be 1 (or the error <b>EINVAL</b>
          results).

       The PI futex operations are as follows:

       <b>FUTEX_LOCK_PI </b>(since Linux 2.6.18)
              This operation is used after an attempt to acquire the
              lock via an atomic user-mode instruction failed because
              the futex word has a nonzero value—specifically, because
              it contained the (PID-namespace-specific) TID of the lock
              owner.

              The operation checks the value of the futex word at the
              address <i>uaddr</i>.  If the value is 0, then the kernel tries
              to atomically set the futex value to the caller's TID.  If
              the futex word's value is nonzero, the kernel atomically
              sets the <b>FUTEX_WAITERS </b>bit, which signals the futex owner
              that it cannot unlock the futex in user space atomically
              by setting the futex value to 0.  After that, the kernel:

              (1)  Tries to find the thread which is associated with the
                   owner TID.

              (2)  Creates or reuses kernel state on behalf of the
                   owner.  (If this is the first waiter, there is no
                   kernel state for this futex, so kernel state is
                   created by locking the RT-mutex and the futex owner
                   is made the owner of the RT-mutex.  If there are
                   existing waiters, then the existing state is reused.)

              (3)  Attaches the waiter to the futex (i.e., the waiter is
                   enqueued on the RT-mutex waiter list).

              If more than one waiter exists, the enqueueing of the
              waiter is in descending priority order.  (For information
              on priority ordering, see the discussion of the
              <b>SCHED_DEADLINE</b>, <b>SCHED_FIFO</b>, and <b>SCHED_RR </b>scheduling
              policies in <a href="../man7/sched.7.html">sched(7)</a>.)  The owner inherits either the
              waiter's CPU bandwidth (if the waiter is scheduled under
              the <b>SCHED_DEADLINE </b>policy) or the waiter's priority (if
              the waiter is scheduled under the <b>SCHED_RR </b>or <b>SCHED_FIFO</b>
              policy).  This inheritance follows the lock chain in the
              case of nested locking and performs deadlock detection.

              The <i>timeout</i> argument provides a timeout for the lock
              attempt.  If <i>timeout</i> is not NULL, the structure it points
              to specifies an absolute timeout, measured against the
              <b>CLOCK_REALTIME </b>clock.  If <i>timeout</i> is NULL, the operation
              will block indefinitely.

              The <i>uaddr2</i>, <i>val</i>, and <i>val3</i> arguments are ignored.

       <b>FUTEX_LOCK_PI2 </b>(since Linux 5.14)
              This operation is the same as <b>FUTEX_LOCK_PI</b>, except that
              the clock against which <i>timeout</i> is measured is selectable.
              By default, the (absolute) timeout specified in <i>timeout</i> is
              measured against the <b>CLOCK_MONOTONIC </b>clock, but if the
              <b>FUTEX_CLOCK_REALTIME </b>flag is specified in <i>futex_op</i>, then
              the timeout is measured against the <b>CLOCK_REALTIME </b>clock.

       <b>FUTEX_TRYLOCK_PI </b>(since Linux 2.6.18)
              This operation tries to acquire the lock at <i>uaddr</i>.  It is
              invoked when a user-space atomic acquire did not succeed
              because the futex word was not 0.

              Because the kernel has access to more state information
              than user space, acquisition of the lock might succeed if
              performed by the kernel in cases where the futex word
              (i.e., the state information accessible to use-space)
              contains stale state (<b>FUTEX_WAITERS </b>and/or
              <b>FUTEX_OWNER_DIED</b>).  This can happen when the owner of the
              futex died.  User space cannot handle this condition in a
              race-free manner, but the kernel can fix this up and
              acquire the futex.

              The <i>uaddr2</i>, <i>val</i>, <i>timeout</i>, and <i>val3</i> arguments are ignored.

       <b>FUTEX_UNLOCK_PI </b>(since Linux 2.6.18)
              This operation wakes the top priority waiter that is
              waiting in <b>FUTEX_LOCK_PI </b>or <b>FUTEX_LOCK_PI2 </b>on the futex
              address provided by the <i>uaddr</i> argument.

              This is called when the user-space value at <i>uaddr</i> cannot
              be changed atomically from a TID (of the owner) to 0.

              The <i>uaddr2</i>, <i>val</i>, <i>timeout</i>, and <i>val3</i> arguments are ignored.

       <b>FUTEX_CMP_REQUEUE_PI </b>(since Linux 2.6.31)
              This operation is a PI-aware variant of <b>FUTEX_CMP_REQUEUE</b>.
              It requeues waiters that are blocked via
              <b>FUTEX_WAIT_REQUEUE_PI </b>on <i>uaddr</i> from a non-PI source futex
              (<i>uaddr</i>) to a PI target futex (<i>uaddr2</i>).

              As with <b>FUTEX_CMP_REQUEUE</b>, this operation wakes up a
              maximum of <i>val</i> waiters that are waiting on the futex at
              <i>uaddr</i>.  However, for <b>FUTEX_CMP_REQUEUE_PI</b>, <i>val</i> is required
              to be 1 (since the main point is to avoid a thundering
              herd).  The remaining waiters are removed from the wait
              queue of the source futex at <i>uaddr</i> and added to the wait
              queue of the target futex at <i>uaddr2</i>.

              The <i>val2</i> and <i>val3</i> arguments serve the same purposes as for
              <b>FUTEX_CMP_REQUEUE</b>.

       <b>FUTEX_WAIT_REQUEUE_PI </b>(since Linux 2.6.31)
              Wait on a non-PI futex at <i>uaddr</i> and potentially be
              requeued (via a <b>FUTEX_CMP_REQUEUE_PI </b>operation in another
              task) onto a PI futex at <i>uaddr2</i>.  The wait operation on
              <i>uaddr</i> is the same as for <b>FUTEX_WAIT</b>.

              The waiter can be removed from the wait on <i>uaddr</i> without
              requeueing on <i>uaddr2</i> via a <b>FUTEX_WAKE </b>operation in another
              task.  In this case, the <b>FUTEX_WAIT_REQUEUE_PI </b>operation
              fails with the error <b>EAGAIN</b>.

              If <i>timeout</i> is not NULL, the structure it points to
              specifies an absolute timeout for the wait operation.  If
              <i>timeout</i> is NULL, the operation can block indefinitely.

              The <i>val3</i> argument is ignored.

              The <b>FUTEX_WAIT_REQUEUE_PI </b>and <b>FUTEX_CMP_REQUEUE_PI </b>were
              added to support a fairly specific use case: support for
              priority-inheritance-aware POSIX threads condition
              variables.  The idea is that these operations should
              always be paired, in order to ensure that user space and
              the kernel remain in sync.  Thus, in the
              <b>FUTEX_WAIT_REQUEUE_PI </b>operation, the user-space
              application pre-specifies the target of the requeue that
              takes place in the <b>FUTEX_CMP_REQUEUE_PI </b>operation.
</pre> <h2>
RETURN VALUE </h2>
<pre>
       In the event of an error (and assuming that <b>futex</b>() was invoked
       via <a href="syscall.2.html">syscall(2)</a>), all operations return -1 and set <i><a href="../man3/errno.3.html">errno</a></i> to
       indicate the error.

       The return value on success depends on the operation, as
       described in the following list:

       <b>FUTEX_WAIT</b>
              Returns 0 if the caller was woken up.  Note that a wake-up
              can also be caused by common futex usage patterns in
              unrelated code that happened to have previously used the
              futex word's memory location (e.g., typical futex-based
              implementations of Pthreads mutexes can cause this under
              some conditions).  Therefore, callers should always
              conservatively assume that a return value of 0 can mean a
              spurious wake-up, and use the futex word's value (i.e.,
              the user-space synchronization scheme) to decide whether
              to continue to block or not.

       <b>FUTEX_WAKE</b>
              Returns the number of waiters that were woken up.

       <b>FUTEX_FD</b>
              Returns the new file descriptor associated with the futex.

       <b>FUTEX_REQUEUE</b>
              Returns the number of waiters that were woken up.

       <b>FUTEX_CMP_REQUEUE</b>
              Returns the total number of waiters that were woken up or
              requeued to the futex for the futex word at <i>uaddr2</i>.  If
              this value is greater than <i>val</i>, then the difference is the
              number of waiters requeued to the futex for the futex word
              at <i>uaddr2</i>.

       <b>FUTEX_WAKE_OP</b>
              Returns the total number of waiters that were woken up.
              This is the sum of the woken waiters on the two futexes
              for the futex words at <i>uaddr</i> and <i>uaddr2</i>.

       <b>FUTEX_WAIT_BITSET</b>
              Returns 0 if the caller was woken up.  See <b>FUTEX_WAIT </b>for
              how to interpret this correctly in practice.

       <b>FUTEX_WAKE_BITSET</b>
              Returns the number of waiters that were woken up.

       <b>FUTEX_LOCK_PI</b>
              Returns 0 if the futex was successfully locked.

       <b>FUTEX_LOCK_PI2</b>
              Returns 0 if the futex was successfully locked.

       <b>FUTEX_TRYLOCK_PI</b>
              Returns 0 if the futex was successfully locked.

       <b>FUTEX_UNLOCK_PI</b>
              Returns 0 if the futex was successfully unlocked.

       <b>FUTEX_CMP_REQUEUE_PI</b>
              Returns the total number of waiters that were woken up or
              requeued to the futex for the futex word at <i>uaddr2</i>.  If
              this value is greater than <i>val</i>, then difference is the
              number of waiters requeued to the futex for the futex word
              at <i>uaddr2</i>.

       <b>FUTEX_WAIT_REQUEUE_PI</b>
              Returns 0 if the caller was successfully requeued to the
              futex for the futex word at <i>uaddr2</i>.
</pre> <h2>
ERRORS </h2>
<pre>
       <b>EACCES </b>No read access to the memory of a futex word.

       <b>EAGAIN </b>(<b>FUTEX_WAIT</b>, <b>FUTEX_WAIT_BITSET</b>, <b>FUTEX_WAIT_REQUEUE_PI</b>) The
              value pointed to by <i>uaddr</i> was not equal to the expected
              value <i>val</i> at the time of the call.

              <b>Note</b>: on Linux, the symbolic names <b>EAGAIN </b>and <b>EWOULDBLOCK</b>
              (both of which appear in different parts of the kernel
              futex code) have the same value.

       <b>EAGAIN </b>(<b>FUTEX_CMP_REQUEUE</b>, <b>FUTEX_CMP_REQUEUE_PI</b>) The value
              pointed to by <i>uaddr</i> is not equal to the expected value
              <i>val3</i>.

       <b>EAGAIN </b>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_LOCK_PI2</b>, <b>FUTEX_TRYLOCK_PI</b>,
              <b>FUTEX_CMP_REQUEUE_PI</b>) The futex owner thread ID of <i>uaddr</i>
              (for <b>FUTEX_CMP_REQUEUE_PI</b>: <i>uaddr2</i>) is about to exit, but
              has not yet handled the internal state cleanup.  Try
              again.

       <b>EDEADLK</b>
              (<b>FUTEX_LOCK_PI</b>, <b>FUTEX_LOCK_PI2</b>, <b>FUTEX_TRYLOCK_PI</b>,
              <b>FUTEX_CMP_REQUEUE_PI</b>) The futex word at <i>uaddr</i> is already
              locked by the caller.

       <b>EDEADLK</b>
              (<b>FUTEX_CMP_REQUEUE_PI</b>) While requeueing a waiter to the PI
              futex for the futex word at <i>uaddr2</i>, the kernel detected a
              deadlock.

       <b>EFAULT </b>A required pointer argument (i.e., <i>uaddr</i>, <i>uaddr2</i>, or
              <i>timeout</i>) did not point to a valid user-space address.

       <b>EINTR  </b>A <b>FUTEX_WAIT </b>or <b>FUTEX_WAIT_BITSET </b>operation was
              interrupted by a signal (see <a href="../man7/signal.7.html">signal(7)</a>).  Before Linux
              2.6.22, this error could also be returned for a spurious
              wakeup; since Linux 2.6.22, this no longer happens.

       <b>EINVAL </b>The operation in <i>futex_op</i> is one of those that employs a
              timeout, but the supplied <i>timeout</i> argument was invalid
              (<i>tv_sec</i> was less than zero, or <i>tv_nsec</i> was not less than
              1,000,000,000).

       <b>EINVAL </b>The operation specified in <i>futex_op</i> employs one or both of
              the pointers <i>uaddr</i> and <i>uaddr2</i>, but one of these does not
              point to a valid object—that is, the address is not four-
              byte-aligned.

       <b>EINVAL </b>(<b>FUTEX_WAIT_BITSET</b>, <b>FUTEX_WAKE_BITSET</b>) The bit mask
              supplied in <i>val3</i> is zero.

       <b>EINVAL </b>(<b>FUTEX_CMP_REQUEUE_PI</b>) <i>uaddr</i> equals <i>uaddr2</i> (i.e., an
              attempt was made to requeue to the same futex).

       <b>EINVAL </b>(<b>FUTEX_FD</b>) The signal number supplied in <i>val</i> is invalid.

       <b>EINVAL </b>(<b>FUTEX_WAKE</b>, <b>FUTEX_WAKE_OP</b>, <b>FUTEX_WAKE_BITSET</b>,
              <b>FUTEX_REQUEUE</b>, <b>FUTEX_CMP_REQUEUE</b>) The kernel detected an
              inconsistency between the user-space state at <i>uaddr</i> and
              the kernel state—that is, it detected a waiter which waits
              in <b>FUTEX_LOCK_PI </b>or <b>FUTEX_LOCK_PI2 </b>on <i>uaddr</i>.

       <b>EINVAL </b>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_LOCK_PI2</b>, <b>FUTEX_TRYLOCK_PI</b>,
              <b>FUTEX_UNLOCK_PI</b>) The kernel detected an inconsistency
              between the user-space state at <i>uaddr</i> and the kernel
              state.  This indicates either state corruption or that the
              kernel found a waiter on <i>uaddr</i> which is waiting via
              <b>FUTEX_WAIT </b>or <b>FUTEX_WAIT_BITSET</b>.

       <b>EINVAL </b>(<b>FUTEX_CMP_REQUEUE_PI</b>) The kernel detected an
              inconsistency between the user-space state at <i>uaddr2</i> and
              the kernel state; that is, the kernel detected a waiter
              which waits via <b>FUTEX_WAIT </b>or <b>FUTEX_WAIT_BITSET </b>on <i>uaddr2</i>.

       <b>EINVAL </b>(<b>FUTEX_CMP_REQUEUE_PI</b>) The kernel detected an
              inconsistency between the user-space state at <i>uaddr</i> and
              the kernel state; that is, the kernel detected a waiter
              which waits via <b>FUTEX_WAIT </b>or <b>FUTEX_WAIT_BITSET </b>on <i>uaddr</i>.

       <b>EINVAL </b>(<b>FUTEX_CMP_REQUEUE_PI</b>) The kernel detected an
              inconsistency between the user-space state at <i>uaddr</i> and
              the kernel state; that is, the kernel detected a waiter
              which waits on <i>uaddr</i> via <b>FUTEX_LOCK_PI </b>or <b>FUTEX_LOCK_PI2</b>
              (instead of <b>FUTEX_WAIT_REQUEUE_PI</b>).

       <b>EINVAL </b>(<b>FUTEX_CMP_REQUEUE_PI</b>) An attempt was made to requeue a
              waiter to a futex other than that specified by the
              matching <b>FUTEX_WAIT_REQUEUE_PI </b>call for that waiter.

       <b>EINVAL </b>(<b>FUTEX_CMP_REQUEUE_PI</b>) The <i>val</i> argument is not 1.

       <b>EINVAL </b>Invalid argument.

       <b>ENFILE </b>(<b>FUTEX_FD</b>) The system-wide limit on the total number of
              open files has been reached.

       <b>ENOMEM </b>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_LOCK_PI2</b>, <b>FUTEX_TRYLOCK_PI</b>,
              <b>FUTEX_CMP_REQUEUE_PI</b>) The kernel could not allocate memory
              to hold state information.

       <b>ENOSYS </b>Invalid operation specified in <i>futex_op</i>.

       <b>ENOSYS </b>The <b>FUTEX_CLOCK_REALTIME </b>option was specified in <i>futex_op</i>,
              but the accompanying operation was neither <b>FUTEX_WAIT</b>,
              <b>FUTEX_WAIT_BITSET</b>, <b>FUTEX_WAIT_REQUEUE_PI</b>, nor
              <b>FUTEX_LOCK_PI2</b>.

       <b>ENOSYS </b>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_LOCK_PI2</b>, <b>FUTEX_TRYLOCK_PI</b>,
              <b>FUTEX_UNLOCK_PI</b>, <b>FUTEX_CMP_REQUEUE_PI</b>,
              <b>FUTEX_WAIT_REQUEUE_PI</b>) A run-time check determined that
              the operation is not available.  The PI-futex operations
              are not implemented on all architectures and are not
              supported on some CPU variants.

       <b>EPERM  </b>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_LOCK_PI2</b>, <b>FUTEX_TRYLOCK_PI</b>,
              <b>FUTEX_CMP_REQUEUE_PI</b>) The caller is not allowed to attach
              itself to the futex at <i>uaddr</i> (for <b>FUTEX_CMP_REQUEUE_PI</b>:
              the futex at <i>uaddr2</i>).  (This may be caused by a state
              corruption in user space.)

       <b>EPERM  </b>(<b>FUTEX_UNLOCK_PI</b>) The caller does not own the lock
              represented by the futex word.

       <b>ESRCH  </b>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_LOCK_PI2</b>, <b>FUTEX_TRYLOCK_PI</b>,
              <b>FUTEX_CMP_REQUEUE_PI</b>) The thread ID in the futex word at
              <i>uaddr</i> does not exist.

       <b>ESRCH  </b>(<b>FUTEX_CMP_REQUEUE_PI</b>) The thread ID in the futex word at
              <i>uaddr2</i> does not exist.

       <b>ETIMEDOUT</b>
              The operation in <i>futex_op</i> employed the timeout specified
              in <i>timeout</i>, and the timeout expired before the operation
              completed.
</pre> <h2>
STANDARDS </h2>
<pre>
       Linux.
</pre> <h2>
HISTORY </h2>
<pre>
       Linux 2.6.0.

       Initial futex support was merged in Linux 2.5.7 but with
       different semantics from what was described above.  A four-
       argument system call with the semantics described in this page
       was introduced in Linux 2.5.40.  A fifth argument was added in
       Linux 2.5.70, and a sixth argument was added in Linux 2.6.7.
</pre> <h2>
EXAMPLES </h2>
<pre>
       The program below demonstrates use of futexes in a program where
       a parent process and a child process use a pair of futexes
       located inside a shared anonymous mapping to synchronize access
       to a shared resource: the terminal.  The two processes each write
       <i>nloops</i> (a command-line argument that defaults to 5 if omitted)
       messages to the terminal and employ a synchronization protocol
       that ensures that they alternate in writing messages.  Upon
       running this program we see output such as the following:

           $ <b>./futex_demo</b>
           Parent (18534) 0
           Child  (18535) 0
           Parent (18534) 1
           Child  (18535) 1
           Parent (18534) 2
           Child  (18535) 2
           Parent (18534) 3
           Child  (18535) 3
           Parent (18534) 4
           Child  (18535) 4

   <b>Program source</b>

       /* futex_demo.c

          Usage: futex_demo [nloops]
                           (Default: 5)

          Demonstrate the use of futexes in a program where parent and child
          use a pair of futexes located inside a shared anonymous mapping to
          synchronize access to a shared resource: the terminal. The two
          processes each write 'num-loops' messages to the terminal and employ
          a synchronization protocol that ensures that they alternate in
          writing messages.
       */
       #define _GNU_SOURCE
       #include &lt;err.h&gt;
       #include &lt;errno.h&gt;
       #include &lt;linux/futex.h&gt;
       #include &lt;stdatomic.h&gt;
       #include &lt;stdint.h&gt;
       #include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;sys/mman.h&gt;
       #include &lt;sys/syscall.h&gt;
       #include &lt;sys/time.h&gt;
       #include &lt;sys/wait.h&gt;
       #include &lt;unistd.h&gt;

       static uint32_t *futex1, *futex2, *iaddr;

       static int
       futex(uint32_t *uaddr, int futex_op, uint32_t val,
             const struct timespec *timeout, uint32_t *uaddr2, uint32_t val3)
       {
           return syscall(SYS_futex, uaddr, futex_op, val,
                          timeout, uaddr2, val3);
       }

       /* Acquire the futex pointed to by 'futexp': wait for its value to
          become 1, and then set the value to 0. */

       static void
       fwait(uint32_t *futexp)
       {
           long            s;
           const uint32_t  one = 1;

           /* atomic_compare_exchange_strong(ptr, oldval, newval)
              atomically performs the equivalent of:

                  if (*ptr == *oldval)
                      *ptr = newval;

              It returns true if the test yielded true and *ptr was updated. */

           while (1) {

               /* Is the futex available? */
               if (atomic_compare_exchange_strong(futexp, &amp;one, 0))
                   break;      /* Yes */

               /* Futex is not available; wait. */

               s = futex(futexp, FUTEX_WAIT, 0, NULL, NULL, 0);
               if (s == -1 &amp;&amp; errno != EAGAIN)
                   err(EXIT_FAILURE, "futex-FUTEX_WAIT");
           }
       }

       /* Release the futex pointed to by 'futexp': if the futex currently
          has the value 0, set its value to 1 and then wake any futex waiters,
          so that if the peer is blocked in fwait(), it can proceed. */

       static void
       fpost(uint32_t *futexp)
       {
           long            s;
           const uint32_t  zero = 0;

           /* atomic_compare_exchange_strong() was described
              in comments above. */

           if (atomic_compare_exchange_strong(futexp, &amp;zero, 1)) {
               s = futex(futexp, FUTEX_WAKE, 1, NULL, NULL, 0);
               if (s  == -1)
                   err(EXIT_FAILURE, "futex-FUTEX_WAKE");
           }
       }

       int
       main(int argc, char *argv[])
       {
           pid_t         childPid;
           unsigned int  nloops;

           setbuf(stdout, NULL);

           nloops = (argc &gt; 1) ? atoi(argv[1]) : 5;

           /* Create a shared anonymous mapping that will hold the futexes.
              Since the futexes are being shared between processes, we
              subsequently use the "shared" futex operations (i.e., not the
              ones suffixed "_PRIVATE"). */

           iaddr = mmap(NULL, sizeof(*iaddr) * 2, PROT_READ | PROT_WRITE,
                        MAP_ANONYMOUS | MAP_SHARED, -1, 0);
           if (iaddr == MAP_FAILED)
               err(EXIT_FAILURE, "mmap");

           futex1 = &amp;iaddr[0];
           futex2 = &amp;iaddr[1];

           *futex1 = 0;        /* State: unavailable */
           *futex2 = 1;        /* State: available */

           /* Create a child process that inherits the shared anonymous
              mapping. */

           childPid = fork();
           if (childPid == -1)
               err(EXIT_FAILURE, "fork");

           if (childPid == 0) {        /* Child */
               for (unsigned int j = 0; j &lt; nloops; j++) {
                   fwait(futex1);
                   printf("Child  (%jd) %u\n", (intmax_t) getpid(), j);
                   fpost(futex2);
               }

               exit(EXIT_SUCCESS);
           }

           /* Parent falls through to here. */

           for (unsigned int j = 0; j &lt; nloops; j++) {
               fwait(futex2);
               printf("Parent (%jd) %u\n", (intmax_t) getpid(), j);
               fpost(futex1);
           }

           wait(NULL);

           exit(EXIT_SUCCESS);
       }
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="get_robust_list.2.html">get_robust_list(2)</a>, <a href="restart_syscall.2.html">restart_syscall(2)</a>,
       <b>pthread_mutexattr_getprotocol</b>(3), <a href="../man7/futex.7.html">futex(7)</a>, <a href="../man7/sched.7.html">sched(7)</a>

       The following kernel source files:

       •  <i>Documentation/pi-futex.txt</i>

       •  <i>Documentation/futex-requeue-pi.txt</i>

       •  <i>Documentation/locking/rt-mutex.txt</i>

       •  <i>Documentation/locking/rt-mutex-design.txt</i>

       •  <i>Documentation/robust-futex-ABI.txt</i>

       Franke, H., Russell, R., and Kirwood, M., 2002.  <i>Fuss, Futexes</i>
       <i>and Furwocks: Fast Userlevel Locking in Linux</i> (from proceedings
       of the Ottawa Linux Symposium 2002),
       ⟨<a href="http://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf">http://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf</a>⟩

       Hart, D., 2009. <i>A futex overview and update</i>, 
       ⟨<a href="http://lwn.net/Articles/360699/">http://lwn.net/Articles/360699/</a>⟩

       Hart, D. and Guniguntala, D., 2009.  <i>Requeue-PI: Making glibc</i>
       <i>Condvars PI-Aware</i> (from proceedings of the 2009 Real-Time Linux
       Workshop), 
       ⟨<a href="http://lwn.net/images/conf/rtlws11/papers/proc/p10.pdf">http://lwn.net/images/conf/rtlws11/papers/proc/p10.pdf</a>⟩

       Drepper, U., 2011. <i>Futexes Are Tricky</i>, 
       ⟨<a href="http://www.akkadia.org/drepper/futex.pdf">http://www.akkadia.org/drepper/futex.pdf</a>⟩

       Futex example library, futex-*.tar.bz2 at
       ⟨<a href="https://mirrors.kernel.org/pub/linux/kernel/people/rusty/">https://mirrors.kernel.org/pub/linux/kernel/people/rusty/</a>⟩
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       ⟨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>⟩.  If you have a bug report
       for this manual page, see
       ⟨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>⟩.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       ⟨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>⟩ on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-06-15                       <i>futex</i>(2)</span>
</pre>  <p>Pages that refer to this page: <a href="clone.2.html">clone(2)</a>, <a href="eventfd.2.html">eventfd(2)</a>, <a href="get_robust_list.2.html">get_robust_list(2)</a>, <a href="mprotect.2.html">mprotect(2)</a>, <a href="pr_set_timerslack.2const.html">PR_SET_TIMERSLACK(2const)</a>, <a href="restart_syscall.2.html">restart_syscall(2)</a>, <a href="set_tid_address.2.html">set_tid_address(2)</a>, <a href="syscalls.2.html">syscalls(2)</a>, <a href="../man3/io_uring_prep_futex_wait.3.html">io_uring_prep_futex_wait(3)</a>, <a href="../man3/io_uring_prep_futex_waitv.3.html">io_uring_prep_futex_waitv(3)</a>, <a href="../man3/io_uring_prep_futex_wake.3.html">io_uring_prep_futex_wake(3)</a>, <a href="../man7/futex.7.html">futex(7)</a>, <a href="../man7/pthreads.7.html">pthreads(7)</a>, <a href="../man7/signal.7.html">signal(7)</a> </p> <hr> <p class="page-copyright"><a href="futex.2.license.html">Copyright and license for this manual page</a></p>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man2/futex.2.html" class="_attribution-link">https://man7.org/linux/man-pages/man2/futex.2.html</a>
  </p>
</div>
