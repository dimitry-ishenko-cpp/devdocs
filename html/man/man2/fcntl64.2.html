<h1>fcntl(2) — Linux manual page</h1>   <pre>
<span class="headline"><i>fcntl</i>(2)                   System Calls Manual                  <i>fcntl</i>(2)</span>
</pre> <h2>
NAME </h2>
<pre>
       fcntl - manipulate file descriptor
</pre> <h2>
LIBRARY </h2>
<pre>
       Standard C library (<i>libc</i>, <i>-lc</i>)
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;fcntl.h&gt;</b>

       <b>int fcntl(int </b><i>fd</i><b>, int </b><i>op</i><b>, ... /* </b><i>arg</i> <b>*/ );</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       <b>fcntl</b>() performs one of the operations described below on the
       open file descriptor <i>fd</i>.  The operation is determined by <i>op</i>.

       <b>fcntl</b>() can take an optional third argument.  Whether or not this
       argument is required is determined by <i>op</i>.  The required argument
       type is indicated in parentheses after each <i>op</i> name (in most
       cases, the required type is <i>int</i>, and we identify the argument
       using the name <i>arg</i>), or <i>void</i> is specified if the argument is not
       required.

       Certain of the operations below are supported only since a
       particular Linux kernel version.  The preferred method of
       checking whether the host kernel supports a particular operation
       is to invoke <b>fcntl</b>() with the desired <i>op</i> value and then test
       whether the call failed with <b>EINVAL</b>, indicating that the kernel
       does not recognize this value.

   <b>Duplicating a file descriptor</b>
       <b>F_DUPFD </b>(<i>int</i>)
              Duplicate the file descriptor <i>fd</i> using the lowest-numbered
              available file descriptor greater than or equal to <i>arg</i>.
              This is different from <a href="dup2.2.html">dup2(2)</a>, which uses exactly the
              file descriptor specified.

              On success, the new file descriptor is returned.

              See <a href="dup.2.html">dup(2)</a> for further details.

       <b>F_DUPFD_CLOEXEC </b>(<i>int</i>; since Linux 2.6.24)
              As for <b>F_DUPFD</b>, but additionally set the close-on-exec
              flag for the duplicate file descriptor.  Specifying this
              flag permits a program to avoid an additional <b>fcntl</b>()
              <b>F_SETFD </b>operation to set the <b>FD_CLOEXEC </b>flag.  For an
              explanation of why this flag is useful, see the
              description of <b>O_CLOEXEC </b>in <a href="open.2.html">open(2)</a>.

   <b>File descriptor flags</b>
       The following operations manipulate the flags associated with a
       file descriptor.  Currently, only one such flag is defined:
       <b>FD_CLOEXEC</b>, the close-on-exec flag.  If the <b>FD_CLOEXEC </b>bit is
       set, the file descriptor will automatically be closed during a
       successful <a href="execve.2.html">execve(2)</a>.  (If the <a href="execve.2.html">execve(2)</a> fails, the file
       descriptor is left open.)  If the <b>FD_CLOEXEC </b>bit is not set, the
       file descriptor will remain open across an <a href="execve.2.html">execve(2)</a>.

       <b>F_GETFD </b>(<i>void</i>)
              Return (as the function result) the file descriptor flags;
              <i>arg</i> is ignored.

       <b>F_SETFD </b>(<i>int</i>)
              Set the file descriptor flags to the value specified by
              <i>arg</i>.

       In multithreaded programs, using <b>fcntl</b>() <b>F_SETFD </b>to set the
       close-on-exec flag at the same time as another thread performs a
       <a href="fork.2.html">fork(2)</a> plus <a href="execve.2.html">execve(2)</a> is vulnerable to a race condition that may
       unintentionally leak the file descriptor to the program executed
       in the child process.  See the discussion of the <b>O_CLOEXEC </b>flag
       in <a href="open.2.html">open(2)</a> for details and a remedy to the problem.

   <b>File status flags</b>
       Each open file description has certain associated status flags,
       initialized by <a href="open.2.html">open(2)</a> and possibly modified by <b>fcntl</b>().
       Duplicated file descriptors (made with <a href="dup.2.html">dup(2)</a>, <b>fcntl</b>(F_DUPFD),
       <a href="fork.2.html">fork(2)</a>, etc.) refer to the same open file description, and thus
       share the same file status flags.

       The file status flags and their semantics are described in
       <a href="open.2.html">open(2)</a>.

       <b>F_GETFL </b>(<i>void</i>)
              Return (as the function result) the file access mode and
              the file status flags; <i>arg</i> is ignored.

       <b>F_SETFL </b>(<i>int</i>)
              Set the file status flags to the value specified by <i>arg</i>.
              File access mode (<b>O_RDONLY</b>, <b>O_WRONLY</b>, <b>O_RDWR</b>) and file
              creation flags (i.e., <b>O_CREAT</b>, <b>O_EXCL</b>, <b>O_NOCTTY</b>, <b>O_TRUNC</b>)
              in <i>arg</i> are ignored.  On Linux, this operation can change
              only the <b>O_APPEND</b>, <b>O_ASYNC</b>, <b>O_DIRECT</b>, <b>O_NOATIME</b>, and
              <b>O_NONBLOCK </b>flags.  It is not possible to change the
              <b>O_DSYNC </b>and <b>O_SYNC </b>flags; see BUGS, below.

   <b>Advisory record locking</b>
       Linux implements traditional ("process-associated") UNIX record
       locks, as standardized by POSIX.  For a Linux-specific
       alternative with better semantics, see the discussion of open
       file description locks below.

       <b>F_SETLK</b>, <b>F_SETLKW</b>, and <b>F_GETLK </b>are used to acquire, release, and
       test for the existence of record locks (also known as byte-range,
       file-segment, or file-region locks).  The third argument, <i>lock</i>,
       is a pointer to a structure that has at least the following
       fields (in unspecified order).

           struct flock {
               ...
               short l_type;    /* Type of lock: F_RDLCK,
                                   F_WRLCK, F_UNLCK */
               short l_whence;  /* How to interpret l_start:
                                   SEEK_SET, SEEK_CUR, SEEK_END */
               off_t l_start;   /* Starting offset for lock */
               off_t l_len;     /* Number of bytes to lock */
               pid_t l_pid;     /* PID of process blocking our lock
                                   (set by F_GETLK and F_OFD_GETLK) */
               ...
           };

       The <i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of this structure specify
       the range of bytes we wish to lock.  Bytes past the end of the
       file may be locked, but not bytes before the start of the file.

       <i>l_start</i> is the starting offset for the lock, and is interpreted
       relative to either: the start of the file (if <i>l_whence</i> is
       <b>SEEK_SET</b>); the current file offset (if <i>l_whence</i> is <b>SEEK_CUR</b>); or
       the end of the file (if <i>l_whence</i> is <b>SEEK_END</b>).  In the final two
       cases, <i>l_start</i> can be a negative number provided the offset does
       not lie before the start of the file.

       <i>l_len</i> specifies the number of bytes to be locked.  If <i>l_len</i> is
       positive, then the range to be locked covers bytes <i>l_start</i> up to
       and including <i>l_start</i>+<i>l_len</i>-1.  Specifying 0 for <i>l_len</i> has the
       special meaning: lock all bytes starting at the location
       specified by <i>l_whence</i> and <i>l_start</i> through to the end of file, no
       matter how large the file grows.

       POSIX.1-2001 allows (but does not require) an implementation to
       support a negative <i>l_len</i> value; if <i>l_len</i> is negative, the
       interval described by <i>lock</i> covers bytes <i>l_start</i>+<i>l_len</i> up to and
       including <i>l_start</i>-1.  This is supported since Linux 2.4.21 and
       Linux 2.5.49.

       The <i>l_type</i> field can be used to place a read (<b>F_RDLCK</b>) or a write
       (<b>F_WRLCK</b>) lock on a file.  Any number of processes may hold a
       read lock (shared lock) on a file region, but only one process
       may hold a write lock (exclusive lock).  An exclusive lock
       excludes all other locks, both shared and exclusive.  A single
       process can hold only one type of lock on a file region; if a new
       lock is applied to an already-locked region, then the existing
       lock is converted to the new lock type.  (Such conversions may
       involve splitting, shrinking, or coalescing with an existing lock
       if the byte range specified by the new lock does not precisely
       coincide with the range of the existing lock.)

       <b>F_SETLK </b>(<i>struct flock *</i>)
              Acquire a lock (when <i>l_type</i> is <b>F_RDLCK </b>or <b>F_WRLCK</b>) or
              release a lock (when <i>l_type</i> is <b>F_UNLCK</b>) on the bytes
              specified by the <i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of
              <i>lock</i>.  If a conflicting lock is held by another process,
              this call returns -1 and sets <i><a href="../man3/errno.3.html">errno</a></i> to <b>EACCES </b>or <b>EAGAIN</b>.
              (The error returned in this case differs across
              implementations, so POSIX requires a portable application
              to check for both errors.)

       <b>F_SETLKW </b>(<i>struct flock *</i>)
              As for <b>F_SETLK</b>, but if a conflicting lock is held on the
              file, then wait for that lock to be released.  If a signal
              is caught while waiting, then the call is interrupted and
              (after the signal handler has returned) returns
              immediately (with return value -1 and <i><a href="../man3/errno.3.html">errno</a></i> set to <b>EINTR</b>;
              see <a href="../man7/signal.7.html">signal(7)</a>).

       <b>F_GETLK </b>(<i>struct flock *</i>)
              On input to this call, <i>lock</i> describes a lock we would like
              to place on the file.  If the lock could be placed,
              <b>fcntl</b>() does not actually place it, but returns <b>F_UNLCK </b>in
              the <i>l_type</i> field of <i>lock</i> and leaves the other fields of
              the structure unchanged.

              If one or more incompatible locks would prevent this lock
              being placed, then <b>fcntl</b>() returns details about one of
              those locks in the <i>l_type</i>, <i>l_whence</i>, <i>l_start</i>, and <i>l_len</i>
              fields of <i>lock</i>.  If the conflicting lock is a traditional
              (process-associated) record lock, then the <i>l_pid</i> field is
              set to the PID of the process holding that lock.  If the
              conflicting lock is an open file description lock, then
              <i>l_pid</i> is set to -1.  Note that the returned information
              may already be out of date by the time the caller inspects
              it.

       In order to place a read lock, <i>fd</i> must be open for reading.  In
       order to place a write lock, <i>fd</i> must be open for writing.  To
       place both types of lock, open a file read-write.

       When placing locks with <b>F_SETLKW</b>, the kernel detects <i>deadlocks</i>,
       whereby two or more processes have their lock requests mutually
       blocked by locks held by the other processes.  For example,
       suppose process A holds a write lock on byte 100 of a file, and
       process B holds a write lock on byte 200.  If each process then
       attempts to lock the byte already locked by the other process
       using <b>F_SETLKW</b>, then, without deadlock detection, both processes
       would remain blocked indefinitely.  When the kernel detects such
       deadlocks, it causes one of the blocking lock requests to
       immediately fail with the error <b>EDEADLK</b>; an application that
       encounters such an error should release some of its locks to
       allow other applications to proceed before attempting regain the
       locks that it requires.  Circular deadlocks involving more than
       two processes are also detected.  Note, however, that there are
       limitations to the kernel's deadlock-detection algorithm; see
       BUGS.

       As well as being removed by an explicit <b>F_UNLCK</b>, record locks are
       automatically released when the process terminates.

       Record locks are not inherited by a child created via <a href="fork.2.html">fork(2)</a>,
       but are preserved across an <a href="execve.2.html">execve(2)</a>.

       Because of the buffering performed by the <a href="../man3/stdio.3.html">stdio(3)</a> library, the
       use of record locking with routines in that package should be
       avoided; use <a href="read.2.html">read(2)</a> and <a href="write.2.html">write(2)</a> instead.

       The record locks described above are associated with the process
       (unlike the open file description locks described below).  This
       has some unfortunate consequences:

       •  If a process closes <i>any</i> file descriptor referring to a file,
          then all of the process's locks on that file are released,
          regardless of the file descriptor(s) on which the locks were
          obtained.  This is bad: it means that a process can lose its
          locks on a file such as <i>/etc/passwd</i> or <i>/etc/mtab</i> when for some
          reason a library function decides to open, read, and close the
          same file.

       •  The threads in a process share locks.  In other words, a
          multithreaded program can't use record locking to ensure that
          threads don't simultaneously access the same region of a file.

       Open file description locks solve both of these problems.

   <b>Open file description locks (non-POSIX)</b>
       Open file description locks are advisory byte-range locks whose
       operation is in most respects identical to the traditional record
       locks described above.  This lock type is Linux-specific, and
       available since Linux 3.15.  (There is a proposal with the Austin
       Group to include this lock type in the next revision of POSIX.1.)
       For an explanation of open file descriptions, see <a href="open.2.html">open(2)</a>.

       The principal difference between the two lock types is that
       whereas traditional record locks are associated with a process,
       open file description locks are associated with the open file
       description on which they are acquired, much like locks acquired
       with <a href="flock.2.html">flock(2)</a>.  Consequently (and unlike traditional advisory
       record locks), open file description locks are inherited across
       <a href="fork.2.html">fork(2)</a> (and <a href="clone.2.html">clone(2)</a> with <b>CLONE_FILES</b>), and are only
       automatically released on the last close of the open file
       description, instead of being released on any close of the file.

       Conflicting lock combinations (i.e., a read lock and a write lock
       or two write locks) where one lock is an open file description
       lock and the other is a traditional record lock conflict even
       when they are acquired by the same process on the same file
       descriptor.

       Open file description locks placed via the same open file
       description (i.e., via the same file descriptor, or via a
       duplicate of the file descriptor created by <a href="fork.2.html">fork(2)</a>, <a href="dup.2.html">dup(2)</a>,
       <b>fcntl</b>() <b>F_DUPFD</b>, and so on) are always compatible: if a new lock
       is placed on an already locked region, then the existing lock is
       converted to the new lock type.  (Such conversions may result in
       splitting, shrinking, or coalescing with an existing lock as
       discussed above.)

       On the other hand, open file description locks may conflict with
       each other when they are acquired via different open file
       descriptions.  Thus, the threads in a multithreaded program can
       use open file description locks to synchronize access to a file
       region by having each thread perform its own <a href="open.2.html">open(2)</a> on the file
       and applying locks via the resulting file descriptor.

       As with traditional advisory locks, the third argument to
       <b>fcntl</b>(), <i>lock</i>, is a pointer to an <i>flock</i> structure.  By contrast
       with traditional record locks, the <i>l_pid</i> field of that structure
       must be set to zero when using the operations described below.

       The operations for working with open file description locks are
       analogous to those used with traditional locks:

       <b>F_OFD_SETLK </b>(<i>struct flock *</i>)
              Acquire an open file description lock (when <i>l_type</i> is
              <b>F_RDLCK </b>or <b>F_WRLCK</b>) or release an open file description
              lock (when <i>l_type</i> is <b>F_UNLCK</b>) on the bytes specified by
              the <i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of <i>lock</i>.  If a
              conflicting lock is held by another process, this call
              returns -1 and sets <i><a href="../man3/errno.3.html">errno</a></i> to <b>EAGAIN</b>.

       <b>F_OFD_SETLKW </b>(<i>struct flock *</i>)
              As for <b>F_OFD_SETLK</b>, but if a conflicting lock is held on
              the file, then wait for that lock to be released.  If a
              signal is caught while waiting, then the call is
              interrupted and (after the signal handler has returned)
              returns immediately (with return value -1 and <i><a href="../man3/errno.3.html">errno</a></i> set to
              <b>EINTR</b>; see <a href="../man7/signal.7.html">signal(7)</a>).

       <b>F_OFD_GETLK </b>(<i>struct flock *</i>)
              On input to this call, <i>lock</i> describes an open file
              description lock we would like to place on the file.  If
              the lock could be placed, <b>fcntl</b>() does not actually place
              it, but returns <b>F_UNLCK </b>in the <i>l_type</i> field of <i>lock</i> and
              leaves the other fields of the structure unchanged.  If
              one or more incompatible locks would prevent this lock
              being placed, then details about one of these locks are
              returned via <i>lock</i>, as described above for <b>F_GETLK</b>.

       In the current implementation, no deadlock detection is performed
       for open file description locks.  (This contrasts with process-
       associated record locks, for which the kernel does perform
       deadlock detection.)

   <b>Mandatory locking</b>
       <i>Warning</i>: the Linux implementation of mandatory locking is
       unreliable.  See BUGS below.  Because of these bugs, and the fact
       that the feature is believed to be little used, since Linux 4.5,
       mandatory locking has been made an optional feature, governed by
       a configuration option (<b>CONFIG_MANDATORY_FILE_LOCKING</b>).  This
       feature is no longer supported at all in Linux 5.15 and above.

       By default, both traditional (process-associated) and open file
       description record locks are advisory.  Advisory locks are not
       enforced and are useful only between cooperating processes.

       Both lock types can also be mandatory.  Mandatory locks are
       enforced for all processes.  If a process tries to perform an
       incompatible access (e.g., <a href="read.2.html">read(2)</a> or <a href="write.2.html">write(2)</a>) on a file region
       that has an incompatible mandatory lock, then the result depends
       upon whether the <b>O_NONBLOCK </b>flag is enabled for its open file
       description.  If the <b>O_NONBLOCK </b>flag is not enabled, then the
       system call is blocked until the lock is removed or converted to
       a mode that is compatible with the access.  If the <b>O_NONBLOCK</b>
       flag is enabled, then the system call fails with the error
       <b>EAGAIN</b>.

       To make use of mandatory locks, mandatory locking must be enabled
       both on the filesystem that contains the file to be locked, and
       on the file itself.  Mandatory locking is enabled on a filesystem
       using the "-o mand" option to <a href="../man8/mount.8.html">mount(8)</a>, or the <b>MS_MANDLOCK </b>flag
       for <a href="mount.2.html">mount(2)</a>.  Mandatory locking is enabled on a file by
       disabling group execute permission on the file and enabling the
       set-group-ID permission bit (see <a href="../man1/chmod.1.html">chmod(1)</a> and <a href="chmod.2.html">chmod(2)</a>).

       Mandatory locking is not specified by POSIX.  Some other systems
       also support mandatory locking, although the details of how to
       enable it vary across systems.

   <b>Lost locks</b>
       When an advisory lock is obtained on a networked filesystem such
       as NFS it is possible that the lock might get lost.  This may
       happen due to administrative action on the server, or due to a
       network partition (i.e., loss of network connectivity with the
       server) which lasts long enough for the server to assume that the
       client is no longer functioning.

       When the filesystem determines that a lock has been lost, future
       <a href="read.2.html">read(2)</a> or <a href="write.2.html">write(2)</a> requests may fail with the error <b>EIO</b>.  This
       error will persist until the lock is removed or the file
       descriptor is closed.  Since Linux 3.12, this happens at least
       for NFSv4 (including all minor versions).

       Some versions of UNIX send a signal (<b>SIGLOST</b>) in this
       circumstance.  Linux does not define this signal, and does not
       provide any asynchronous notification of lost locks.

   <b>Managing signals</b>
       <b>F_GETOWN</b>, <b>F_SETOWN</b>, <b>F_GETOWN_EX</b>, <b>F_SETOWN_EX</b>, <b>F_GETSIG</b>, and
       <b>F_SETSIG </b>are used to manage I/O availability signals:

       <b>F_GETOWN </b>(<i>void</i>)
              Return (as the function result) the process ID or process
              group ID currently receiving <b>SIGIO </b>and <b>SIGURG </b>signals for
              events on file descriptor <i>fd</i>.  Process IDs are returned as
              positive values; process group IDs are returned as
              negative values (but see BUGS below).  <i>arg</i> is ignored.

       <b>F_SETOWN </b>(<i>int</i>)
              Set the process ID or process group ID that will receive
              <b>SIGIO </b>and <b>SIGURG </b>signals for events on the file descriptor
              <i>fd</i>.  The target process or process group ID is specified
              in <i>arg</i>.  A process ID is specified as a positive value; a
              process group ID is specified as a negative value.  Most
              commonly, the calling process specifies itself as the
              owner (that is, <i>arg</i> is specified as <a href="getpid.2.html">getpid(2)</a>).

              As well as setting the file descriptor owner, one must
              also enable generation of signals on the file descriptor.
              This is done by using the <b>fcntl</b>() <b>F_SETFL </b>operation to set
              the <b>O_ASYNC </b>file status flag on the file descriptor.
              Subsequently, a <b>SIGIO </b>signal is sent whenever input or
              output becomes possible on the file descriptor.  The
              <b>fcntl</b>() <b>F_SETSIG </b>operation can be used to obtain delivery
              of a signal other than <b>SIGIO</b>.

              Sending a signal to the owner process (group) specified by
              <b>F_SETOWN </b>is subject to the same permissions checks as are
              described for <a href="kill.2.html">kill(2)</a>, where the sending process is the
              one that employs <b>F_SETOWN </b>(but see BUGS below).  If this
              permission check fails, then the signal is silently
              discarded.  <i>Note</i>: The <b>F_SETOWN </b>operation records the
              caller's credentials at the time of the <b>fcntl</b>() call, and
              it is these saved credentials that are used for the
              permission checks.

              If the file descriptor <i>fd</i> refers to a socket, <b>F_SETOWN</b>
              also selects the recipient of <b>SIGURG </b>signals that are
              delivered when out-of-band data arrives on that socket.
              (<b>SIGURG </b>is sent in any situation where <a href="select.2.html">select(2)</a> would
              report the socket as having an "exceptional condition".)

              The following was true in Linux 2.6.x up to and including
              Linux 2.6.11:

                     If a nonzero value is given to <b>F_SETSIG </b>in a
                     multithreaded process running with a threading
                     library that supports thread groups (e.g., NPTL),
                     then a positive value given to <b>F_SETOWN </b>has a
                     different meaning: instead of being a process ID
                     identifying a whole process, it is a thread ID
                     identifying a specific thread within a process.
                     Consequently, it may be necessary to pass <b>F_SETOWN</b>
                     the result of <a href="gettid.2.html">gettid(2)</a> instead of <a href="getpid.2.html">getpid(2)</a> to get
                     sensible results when <b>F_SETSIG </b>is used.  (In
                     current Linux threading implementations, a main
                     thread's thread ID is the same as its process ID.
                     This means that a single-threaded program can
                     equally use <a href="gettid.2.html">gettid(2)</a> or <a href="getpid.2.html">getpid(2)</a> in this
                     scenario.)  Note, however, that the statements in
                     this paragraph do not apply to the <b>SIGURG </b>signal
                     generated for out-of-band data on a socket: this
                     signal is always sent to either a process or a
                     process group, depending on the value given to
                     <b>F_SETOWN</b>.

              The above behavior was accidentally dropped in Linux
              2.6.12, and won't be restored.  From Linux 2.6.32 onward,
              use <b>F_SETOWN_EX </b>to target <b>SIGIO </b>and <b>SIGURG </b>signals at a
              particular thread.

       <b>F_GETOWN_EX </b>(<i>struct f_owner_ex *</i>) (since Linux 2.6.32)
              Return the current file descriptor owner settings as
              defined by a previous <b>F_SETOWN_EX </b>operation.  The
              information is returned in the structure pointed to by
              <i>arg</i>, which has the following form:

                  struct f_owner_ex {
                      int   type;
                      pid_t pid;
                  };

              The <i>type</i> field will have one of the values <b>F_OWNER_TID</b>,
              <b>F_OWNER_PID</b>, or <b>F_OWNER_PGRP</b>.  The <i>pid</i> field is a positive
              integer representing a thread ID, process ID, or process
              group ID.  See <b>F_SETOWN_EX </b>for more details.

       <b>F_SETOWN_EX </b>(<i>struct f_owner_ex *</i>) (since Linux 2.6.32)
              This operation performs a similar task to <b>F_SETOWN</b>.  It
              allows the caller to direct I/O availability signals to a
              specific thread, process, or process group.  The caller
              specifies the target of signals via <i>arg</i>, which is a
              pointer to a <i>f_owner_ex</i> structure.  The <i>type</i> field has one
              of the following values, which define how <i>pid</i> is
              interpreted:

              <b>F_OWNER_TID</b>
                     Send the signal to the thread whose thread ID (the
                     value returned by a call to <a href="clone.2.html">clone(2)</a> or <a href="gettid.2.html">gettid(2)</a>)
                     is specified in <i>pid</i>.

              <b>F_OWNER_PID</b>
                     Send the signal to the process whose ID is
                     specified in <i>pid</i>.

              <b>F_OWNER_PGRP</b>
                     Send the signal to the process group whose ID is
                     specified in <i>pid</i>.  (Note that, unlike with
                     <b>F_SETOWN</b>, a process group ID is specified as a
                     positive value here.)

       <b>F_GETSIG </b>(<i>void</i>)
              Return (as the function result) the signal sent when input
              or output becomes possible.  A value of zero means <b>SIGIO</b>
              is sent.  Any other value (including <b>SIGIO</b>) is the signal
              sent instead, and in this case additional info is
              available to the signal handler if installed with
              <b>SA_SIGINFO</b>.  <i>arg</i> is ignored.

       <b>F_SETSIG </b>(<i>int</i>)
              Set the signal sent when input or output becomes possible
              to the value given in <i>arg</i>.  A value of zero means to send
              the default <b>SIGIO </b>signal.  Any other value (including
              <b>SIGIO</b>) is the signal to send instead, and in this case
              additional info is available to the signal handler if
              installed with <b>SA_SIGINFO</b>.

              By using <b>F_SETSIG </b>with a nonzero value, and setting
              <b>SA_SIGINFO </b>for the signal handler (see <a href="sigaction.2.html">sigaction(2)</a>),
              extra information about I/O events is passed to the
              handler in a <i>siginfo_t</i> structure.  If the <i>si_code</i> field
              indicates the source is <b>SI_SIGIO</b>, the <i>si_fd</i> field gives
              the file descriptor associated with the event.  Otherwise,
              there is no indication which file descriptors are pending,
              and you should use the usual mechanisms (<a href="select.2.html">select(2)</a>,
              <a href="poll.2.html">poll(2)</a>, <a href="read.2.html">read(2)</a> with <b>O_NONBLOCK </b>set etc.) to determine
              which file descriptors are available for I/O.

              Note that the file descriptor provided in <i>si_fd</i> is the one
              that was specified during the <b>F_SETSIG </b>operation.  This
              can lead to an unusual corner case.  If the file
              descriptor is duplicated (<a href="dup.2.html">dup(2)</a> or similar), and the
              original file descriptor is closed, then I/O events will
              continue to be generated, but the <i>si_fd</i> field will contain
              the number of the now closed file descriptor.

              By selecting a real time signal (value &gt;= <b>SIGRTMIN</b>),
              multiple I/O events may be queued using the same signal
              numbers.  (Queuing is dependent on available memory.)
              Extra information is available if <b>SA_SIGINFO </b>is set for
              the signal handler, as above.

              Note that Linux imposes a limit on the number of real-time
              signals that may be queued to a process (see <a href="getrlimit.2.html">getrlimit(2)</a>
              and <a href="../man7/signal.7.html">signal(7)</a>) and if this limit is reached, then the
              kernel reverts to delivering <b>SIGIO</b>, and this signal is
              delivered to the entire process rather than to a specific
              thread.

       Using these mechanisms, a program can implement fully
       asynchronous I/O without using <a href="select.2.html">select(2)</a> or <a href="poll.2.html">poll(2)</a> most of the
       time.

       The use of <b>O_ASYNC </b>is specific to BSD and Linux.  The only use of
       <b>F_GETOWN </b>and <b>F_SETOWN </b>specified in POSIX.1 is in conjunction with
       the use of the <b>SIGURG </b>signal on sockets.  (POSIX does not specify
       the <b>SIGIO </b>signal.)  <b>F_GETOWN_EX</b>, <b>F_SETOWN_EX</b>, <b>F_GETSIG</b>, and
       <b>F_SETSIG </b>are Linux-specific.  POSIX has asynchronous I/O and the
       <i>aio_sigevent</i> structure to achieve similar things; these are also
       available in Linux as part of the GNU C Library (glibc).

   <b>Leases</b>
       <b>F_SETLEASE </b>and <b>F_GETLEASE </b>(Linux 2.4 onward) are used to
       establish a new lease, and retrieve the current lease, on the
       open file description referred to by the file descriptor <i>fd</i>.  A
       file lease provides a mechanism whereby the process holding the
       lease (the "lease holder") is notified (via delivery of a signal)
       when a process (the "lease breaker") tries to <a href="open.2.html">open(2)</a> or
       <a href="truncate.2.html">truncate(2)</a> the file referred to by that file descriptor.

       <b>F_SETLEASE </b>(<i>int</i>)
              Set or remove a file lease according to which of the
              following values is specified in the integer <i>arg</i>:

              <b>F_RDLCK</b>
                     Take out a read lease.  This will cause the calling
                     process to be notified when the file is opened for
                     writing or is truncated.  A read lease can be
                     placed only on a file descriptor that is opened
                     read-only.

              <b>F_WRLCK</b>
                     Take out a write lease.  This will cause the caller
                     to be notified when the file is opened for reading
                     or writing or is truncated.  A write lease may be
                     placed on a file only if there are no other open
                     file descriptors for the file.

              <b>F_UNLCK</b>
                     Remove our lease from the file.

       Leases are associated with an open file description (see
       <a href="open.2.html">open(2)</a>).  This means that duplicate file descriptors (created
       by, for example, <a href="fork.2.html">fork(2)</a> or <a href="dup.2.html">dup(2)</a>) refer to the same lease, and
       this lease may be modified or released using any of these
       descriptors.  Furthermore, the lease is released by either an
       explicit <b>F_UNLCK </b>operation on any of these duplicate file
       descriptors, or when all such file descriptors have been closed.

       Leases may be taken out only on regular files.  An unprivileged
       process may take out a lease only on a file whose UID (owner)
       matches the filesystem UID of the process.  A process with the
       <b>CAP_LEASE </b>capability may take out leases on arbitrary files.

       <b>F_GETLEASE </b>(<i>void</i>)
              Indicates what type of lease is associated with the file
              descriptor <i>fd</i> by returning either <b>F_RDLCK</b>, <b>F_WRLCK</b>, or
              <b>F_UNLCK</b>, indicating, respectively, a read lease , a write
              lease, or no lease.  <i>arg</i> is ignored.

       When a process (the "lease breaker") performs an <a href="open.2.html">open(2)</a> or
       <a href="truncate.2.html">truncate(2)</a> that conflicts with a lease established via
       <b>F_SETLEASE</b>, the system call is blocked by the kernel and the
       kernel notifies the lease holder by sending it a signal (<b>SIGIO </b>by
       default).  The lease holder should respond to receipt of this
       signal by doing whatever cleanup is required in preparation for
       the file to be accessed by another process (e.g., flushing cached
       buffers) and then either remove or downgrade its lease.  A lease
       is removed by performing an <b>F_SETLEASE </b>operation specifying <i>arg</i>
       as <b>F_UNLCK</b>.  If the lease holder currently holds a write lease on
       the file, and the lease breaker is opening the file for reading,
       then it is sufficient for the lease holder to downgrade the lease
       to a read lease.  This is done by performing an <b>F_SETLEASE</b>
       operation specifying <i>arg</i> as <b>F_RDLCK</b>.

       If the lease holder fails to downgrade or remove the lease within
       the number of seconds specified in <i>/proc/sys/fs/lease-break-time</i>,
       then the kernel forcibly removes or downgrades the lease holder's
       lease.

       Once a lease break has been initiated, <b>F_GETLEASE </b>returns the
       target lease type (either <b>F_RDLCK </b>or <b>F_UNLCK</b>, depending on what
       would be compatible with the lease breaker) until the lease
       holder voluntarily downgrades or removes the lease or the kernel
       forcibly does so after the lease break timer expires.

       Once the lease has been voluntarily or forcibly removed or
       downgraded, and assuming the lease breaker has not unblocked its
       system call, the kernel permits the lease breaker's system call
       to proceed.

       If the lease breaker's blocked <a href="open.2.html">open(2)</a> or <a href="truncate.2.html">truncate(2)</a> is
       interrupted by a signal handler, then the system call fails with
       the error <b>EINTR</b>, but the other steps still occur as described
       above.  If the lease breaker is killed by a signal while blocked
       in <a href="open.2.html">open(2)</a> or <a href="truncate.2.html">truncate(2)</a>, then the other steps still occur as
       described above.  If the lease breaker specifies the <b>O_NONBLOCK</b>
       flag when calling <a href="open.2.html">open(2)</a>, then the call immediately fails with
       the error <b>EWOULDBLOCK</b>, but the other steps still occur as
       described above.

       The default signal used to notify the lease holder is <b>SIGIO</b>, but
       this can be changed using the <b>F_SETSIG </b>operation to <b>fcntl</b>().  If
       a <b>F_SETSIG </b>operation is performed (even one specifying <b>SIGIO</b>),
       and the signal handler is established using <b>SA_SIGINFO</b>, then the
       handler will receive a <i>siginfo_t</i> structure as its second
       argument, and the <i>si_fd</i> field of this argument will hold the file
       descriptor of the leased file that has been accessed by another
       process.  (This is useful if the caller holds leases against
       multiple files.)

   <b>File and directory change notification (dnotify)</b>
       <b>F_NOTIFY </b>(<i>int</i>)
              (Linux 2.4 onward) Provide notification when the directory
              referred to by <i>fd</i> or any of the files that it contains is
              changed.  The events to be notified are specified in <i>arg</i>,
              which is a bit mask specified by ORing together zero or
              more of the following bits:

              <b>DN_ACCESS</b>
                     A file was accessed (<a href="read.2.html">read(2)</a>, <a href="pread.2.html">pread(2)</a>, <a href="readv.2.html">readv(2)</a>,
                     and similar)
              <b>DN_MODIFY</b>
                     A file was modified (<a href="write.2.html">write(2)</a>, <a href="pwrite.2.html">pwrite(2)</a>,
                     <a href="writev.2.html">writev(2)</a>, <a href="truncate.2.html">truncate(2)</a>, <a href="ftruncate.2.html">ftruncate(2)</a>, and similar).
              <b>DN_CREATE</b>
                     A file was created (<a href="open.2.html">open(2)</a>, <a href="creat.2.html">creat(2)</a>, <a href="mknod.2.html">mknod(2)</a>,
                     <a href="mkdir.2.html">mkdir(2)</a>, <a href="link.2.html">link(2)</a>, <a href="symlink.2.html">symlink(2)</a>, <a href="rename.2.html">rename(2)</a> into this
                     directory).
              <b>DN_DELETE</b>
                     A file was unlinked (<a href="unlink.2.html">unlink(2)</a>, <a href="rename.2.html">rename(2)</a> to
                     another directory, <a href="rmdir.2.html">rmdir(2)</a>).
              <b>DN_RENAME</b>
                     A file was renamed within this directory
                     (<a href="rename.2.html">rename(2)</a>).
              <b>DN_ATTRIB</b>
                     The attributes of a file were changed (<a href="chown.2.html">chown(2)</a>,
                     <a href="chmod.2.html">chmod(2)</a>, <a href="utime.2.html">utime(2)</a>, <a href="utimensat.2.html">utimensat(2)</a>, and similar).

              (In order to obtain these definitions, the <b>_GNU_SOURCE</b>
              feature test macro must be defined before including <i>any</i>
              header files.)

              Directory notifications are normally "one-shot", and the
              application must reregister to receive further
              notifications.  Alternatively, if <b>DN_MULTISHOT </b>is included
              in <i>arg</i>, then notification will remain in effect until
              explicitly removed.

              A series of <b>F_NOTIFY </b>requests is cumulative, with the
              events in <i>arg</i> being added to the set already monitored.
              To disable notification of all events, make an <b>F_NOTIFY</b>
              call specifying <i>arg</i> as 0.

              Notification occurs via delivery of a signal.  The default
              signal is <b>SIGIO</b>, but this can be changed using the
              <b>F_SETSIG </b>operation to <b>fcntl</b>().  (Note that <b>SIGIO </b>is one of
              the nonqueuing standard signals; switching to the use of a
              real-time signal means that multiple notifications can be
              queued to the process.)  In the latter case, the signal
              handler receives a <i>siginfo_t</i> structure as its second
              argument (if the handler was established using <b>SA_SIGINFO</b>)
              and the <i>si_fd</i> field of this structure contains the file
              descriptor which generated the notification (useful when
              establishing notification on multiple directories).

              Especially when using <b>DN_MULTISHOT</b>, a real time signal
              should be used for notification, so that multiple
              notifications can be queued.

              <b>NOTE: </b>New applications should use the <i>inotify</i> interface
              (available since Linux 2.6.13), which provides a much
              superior interface for obtaining notifications of
              filesystem events.  See <a href="../man7/inotify.7.html">inotify(7)</a>.

   <b>Changing the capacity of a pipe</b>
       <b>F_SETPIPE_SZ </b>(<i>int</i>; since Linux 2.6.35)
              Change the capacity of the pipe referred to by <i>fd</i> to be at
              least <i>arg</i> bytes.  An unprivileged process can adjust the
              pipe capacity to any value between the system page size
              and the limit defined in <i>/proc/sys/fs/pipe-max-size</i> (see
              <a href="../man5/proc.5.html">proc(5)</a>).  Attempts to set the pipe capacity below the
              page size are silently rounded up to the page size.
              Attempts by an unprivileged process to set the pipe
              capacity above the limit in <i>/proc/sys/fs/pipe-max-size</i>
              yield the error <b>EPERM</b>; a privileged process
              (<b>CAP_SYS_RESOURCE</b>) can override the limit.

              When allocating the buffer for the pipe, the kernel may
              use a capacity larger than <i>arg</i>, if that is convenient for
              the implementation.  (In the current implementation, the
              allocation is the next higher power-of-two page-size
              multiple of the requested size.)  The actual capacity (in
              bytes) that is set is returned as the function result.

              Attempting to set the pipe capacity smaller than the
              amount of buffer space currently used to store data
              produces the error <b>EBUSY</b>.

              Note that because of the way the pages of the pipe buffer
              are employed when data is written to the pipe, the number
              of bytes that can be written may be less than the nominal
              size, depending on the size of the writes.

       <b>F_GETPIPE_SZ </b>(<i>void</i>; since Linux 2.6.35)
              Return (as the function result) the capacity of the pipe
              referred to by <i>fd</i>.

   <b>File Sealing</b>
       File seals limit the set of allowed operations on a given file.
       For each seal that is set on a file, a specific set of operations
       will fail with <b>EPERM </b>on this file from now on.  The file is said
       to be sealed.  The default set of seals depends on the type of
       the underlying file and filesystem.  For an overview of file
       sealing, a discussion of its purpose, and some code examples, see
       <a href="memfd_create.2.html">memfd_create(2)</a>.

       Currently, file seals can be applied only to a file descriptor
       returned by <a href="memfd_create.2.html">memfd_create(2)</a> (if the <b>MFD_ALLOW_SEALING </b>was
       employed).  On other filesystems, all <b>fcntl</b>() operations that
       operate on seals will return <b>EINVAL</b>.

       Seals are a property of an inode.  Thus, all open file
       descriptors referring to the same inode share the same set of
       seals.  Furthermore, seals can never be removed, only added.

       <b>F_ADD_SEALS </b>(<i>int</i>; since Linux 3.17)
              Add the seals given in the bit-mask argument <i>arg</i> to the
              set of seals of the inode referred to by the file
              descriptor <i>fd</i>.  Seals cannot be removed again.  Once this
              call succeeds, the seals are enforced by the kernel
              immediately.  If the current set of seals includes
              <b>F_SEAL_SEAL </b>(see below), then this call will be rejected
              with <b>EPERM</b>.  Adding a seal that is already set is a no-op,
              in case <b>F_SEAL_SEAL </b>is not set already.  In order to place
              a seal, the file descriptor <i>fd</i> must be writable.

       <b>F_GET_SEALS </b>(<i>void</i>; since Linux 3.17)
              Return (as the function result) the current set of seals
              of the inode referred to by <i>fd</i>.  If no seals are set, 0 is
              returned.  If the file does not support sealing, -1 is
              returned and <i><a href="../man3/errno.3.html">errno</a></i> is set to <b>EINVAL</b>.

       The following seals are available:

       <b>F_SEAL_SEAL</b>
              If this seal is set, any further call to <b>fcntl</b>() with
              <b>F_ADD_SEALS </b>fails with the error <b>EPERM</b>.  Therefore, this
              seal prevents any modifications to the set of seals
              itself.  If the initial set of seals of a file includes
              <b>F_SEAL_SEAL</b>, then this effectively causes the set of seals
              to be constant and locked.

       <b>F_SEAL_SHRINK</b>
              If this seal is set, the file in question cannot be
              reduced in size.  This affects <a href="open.2.html">open(2)</a> with the <b>O_TRUNC</b>
              flag as well as <a href="truncate.2.html">truncate(2)</a> and <a href="ftruncate.2.html">ftruncate(2)</a>.  Those calls
              fail with <b>EPERM </b>if you try to shrink the file in question.
              Increasing the file size is still possible.

       <b>F_SEAL_GROW</b>
              If this seal is set, the size of the file in question
              cannot be increased.  This affects <a href="write.2.html">write(2)</a> beyond the end
              of the file, <a href="truncate.2.html">truncate(2)</a>, <a href="ftruncate.2.html">ftruncate(2)</a>, and <a href="fallocate.2.html">fallocate(2)</a>.
              These calls fail with <b>EPERM </b>if you use them to increase
              the file size.  If you keep the size or shrink it, those
              calls still work as expected.

       <b>F_SEAL_WRITE</b>
              If this seal is set, you cannot modify the contents of the
              file.  Note that shrinking or growing the size of the file
              is still possible and allowed.  Thus, this seal is
              normally used in combination with one of the other seals.
              This seal affects <a href="write.2.html">write(2)</a> and <a href="fallocate.2.html">fallocate(2)</a> (only in
              combination with the <b>FALLOC_FL_PUNCH_HOLE </b>flag).  Those
              calls fail with <b>EPERM </b>if this seal is set.  Furthermore,
              trying to create new shared, writable memory-mappings via
              <a href="mmap.2.html">mmap(2)</a> will also fail with <b>EPERM</b>.

              Using the <b>F_ADD_SEALS </b>operation to set the <b>F_SEAL_WRITE</b>
              seal fails with <b>EBUSY </b>if any writable, shared mapping
              exists.  Such mappings must be unmapped before you can add
              this seal.  Furthermore, if there are any asynchronous I/O
              operations (<a href="io_submit.2.html">io_submit(2)</a>) pending on the file, all
              outstanding writes will be discarded.

       <b>F_SEAL_FUTURE_WRITE </b>(since Linux 5.1)
              The effect of this seal is similar to <b>F_SEAL_WRITE</b>, but
              the contents of the file can still be modified via shared
              writable mappings that were created prior to the seal
              being set.  Any attempt to create a new writable mapping
              on the file via <a href="mmap.2.html">mmap(2)</a> will fail with <b>EPERM</b>.  Likewise,
              an attempt to write to the file via <a href="write.2.html">write(2)</a> will fail
              with <b>EPERM</b>.

              Using this seal, one process can create a memory buffer
              that it can continue to modify while sharing that buffer
              on a "read-only" basis with other processes.

   <b>File read/write hints</b>
       Write lifetime hints can be used to inform the kernel about the
       relative expected lifetime of writes on a given inode or via a
       particular open file description.  (See <a href="open.2.html">open(2)</a> for an
       explanation of open file descriptions.)  In this context, the
       term "write lifetime" means the expected time the data will live
       on media, before being overwritten or erased.

       An application may use the different hint values specified below
       to separate writes into different write classes, so that multiple
       users or applications running on a single storage back-end can
       aggregate their I/O patterns in a consistent manner.  However,
       there are no functional semantics implied by these flags, and
       different I/O classes can use the write lifetime hints in
       arbitrary ways, so long as the hints are used consistently.

       The following operations can be applied to the file descriptor,
       <i>fd</i>:

       <b>F_GET_RW_HINT </b>(<i>uint64_t *</i>; since Linux 4.13)
              Returns the value of the read/write hint associated with
              the underlying inode referred to by <i>fd</i>.

       <b>F_SET_RW_HINT </b>(<i>uint64_t *</i>; since Linux 4.13)
              Sets the read/write hint value associated with the
              underlying inode referred to by <i>fd</i>.  This hint persists
              until either it is explicitly modified or the underlying
              filesystem is unmounted.

       <b>F_GET_FILE_RW_HINT </b>(<i>uint64_t *</i>; since Linux 4.13)
              Returns the value of the read/write hint associated with
              the open file description referred to by <i>fd</i>.

       <b>F_SET_FILE_RW_HINT </b>(<i>uint64_t *</i>; since Linux 4.13)
              Sets the read/write hint value associated with the open
              file description referred to by <i>fd</i>.

       If an open file description has not been assigned a read/write
       hint, then it shall use the value assigned to the inode, if any.

       The following read/write hints are valid since Linux 4.13:

       <b>RWH_WRITE_LIFE_NOT_SET</b>
              No specific hint has been set.  This is the default value.

       <b>RWH_WRITE_LIFE_NONE</b>
              No specific write lifetime is associated with this file or
              inode.

       <b>RWH_WRITE_LIFE_SHORT</b>
              Data written to this inode or via this open file
              description is expected to have a short lifetime.

       <b>RWH_WRITE_LIFE_MEDIUM</b>
              Data written to this inode or via this open file
              description is expected to have a lifetime longer than
              data written with <b>RWH_WRITE_LIFE_SHORT</b>.

       <b>RWH_WRITE_LIFE_LONG</b>
              Data written to this inode or via this open file
              description is expected to have a lifetime longer than
              data written with <b>RWH_WRITE_LIFE_MEDIUM</b>.

       <b>RWH_WRITE_LIFE_EXTREME</b>
              Data written to this inode or via this open file
              description is expected to have a lifetime longer than
              data written with <b>RWH_WRITE_LIFE_LONG</b>.

       All the write-specific hints are relative to each other, and no
       individual absolute meaning should be attributed to them.
</pre> <h2>
RETURN VALUE </h2>
<pre>
       For a successful call, the return value depends on the operation:

       <b>F_DUPFD</b>
              The new file descriptor.

       <b>F_GETFD</b>
              Value of file descriptor flags.

       <b>F_GETFL</b>
              Value of file status flags.

       <b>F_GETLEASE</b>
              Type of lease held on file descriptor.

       <b>F_GETOWN</b>
              Value of file descriptor owner.

       <b>F_GETSIG</b>
              Value of signal sent when read or write becomes possible,
              or zero for traditional <b>SIGIO </b>behavior.

       <b>F_GETPIPE_SZ</b>
       <b>F_SETPIPE_SZ</b>
              The pipe capacity.

       <b>F_GET_SEALS</b>
              A bit mask identifying the seals that have been set for
              the inode referred to by <i>fd</i>.

       All other operations
              Zero.

       On error, -1 is returned, and <i><a href="../man3/errno.3.html">errno</a></i> is set to indicate the error.
</pre> <h2>
ERRORS </h2>
<pre>
       <b>EACCES </b>or <b>EAGAIN</b>
              Operation is prohibited by locks held by other processes.

       <b>EAGAIN </b>The operation is prohibited because the file has been
              memory-mapped by another process.

       <b>EBADF  </b><i>fd</i> is not an open file descriptor

       <b>EBADF  </b><i>op</i> is <b>F_SETLK </b>or <b>F_SETLKW </b>and the file descriptor open
              mode doesn't match with the type of lock requested.

       <b>EBUSY  </b><i>op</i> is <b>F_SETPIPE_SZ </b>and the new pipe capacity specified in
              <i>arg</i> is smaller than the amount of buffer space currently
              used to store data in the pipe.

       <b>EBUSY  </b><i>op</i> is <b>F_ADD_SEALS</b>, <i>arg</i> includes <b>F_SEAL_WRITE</b>, and there
              exists a writable, shared mapping on the file referred to
              by <i>fd</i>.

       <b>EDEADLK</b>
              It was detected that the specified <b>F_SETLKW </b>operation
              would cause a deadlock.

       <b>EFAULT </b><i>lock</i> is outside your accessible address space.

       <b>EINTR  </b><i>op</i> is <b>F_SETLKW </b>or <b>F_OFD_SETLKW </b>and the operation was
              interrupted by a signal; see <a href="../man7/signal.7.html">signal(7)</a>.

       <b>EINTR  </b><i>op</i> is <b>F_GETLK</b>, <b>F_SETLK</b>, <b>F_OFD_GETLK</b>, or <b>F_OFD_SETLK</b>, and
              the operation was interrupted by a signal before the lock
              was checked or acquired.  Most likely when locking a
              remote file (e.g., locking over NFS), but can sometimes
              happen locally.

       <b>EINVAL </b>The value specified in <i>op</i> is not recognized by this
              kernel.

       <b>EINVAL </b><i>op</i> is <b>F_ADD_SEALS </b>and <i>arg</i> includes an unrecognized sealing
              bit.

       <b>EINVAL </b><i>op</i> is <b>F_ADD_SEALS </b>or <b>F_GET_SEALS </b>and the filesystem
              containing the inode referred to by <i>fd</i> does not support
              sealing.

       <b>EINVAL </b><i>op</i> is <b>F_DUPFD </b>and <i>arg</i> is negative or is greater than the
              maximum allowable value (see the discussion of
              <b>RLIMIT_NOFILE </b>in <a href="getrlimit.2.html">getrlimit(2)</a>).

       <b>EINVAL </b><i>op</i> is <b>F_SETSIG </b>and <i>arg</i> is not an allowable signal number.

       <b>EINVAL </b><i>op</i> is <b>F_OFD_SETLK</b>, <b>F_OFD_SETLKW</b>, or <b>F_OFD_GETLK</b>, and <i>l_pid</i>
              was not specified as zero.

       <b>EMFILE </b><i>op</i> is <b>F_DUPFD </b>and the per-process limit on the number of
              open file descriptors has been reached.

       <b>ENOLCK </b>Too many segment locks open, lock table is full, or a
              remote locking protocol failed (e.g., locking over NFS).

       <b>ENOTDIR</b>
              <b>F_NOTIFY </b>was specified in <i>op</i>, but <i>fd</i> does not refer to a
              directory.

       <b>EPERM  </b><i>op</i> is <b>F_SETPIPE_SZ </b>and the soft or hard user pipe limit
              has been reached; see <a href="../man7/pipe.7.html">pipe(7)</a>.

       <b>EPERM  </b>Attempted to clear the <b>O_APPEND </b>flag on a file that has
              the append-only attribute set.

       <b>EPERM  </b><i>op</i> was <b>F_ADD_SEALS</b>, but <i>fd</i> was not open for writing or the
              current set of seals on the file already includes
              <b>F_SEAL_SEAL</b>.
</pre> <h2>
STANDARDS </h2>
<pre>
       POSIX.1-2008.

       <b>F_GETOWN_EX</b>, <b>F_SETOWN_EX</b>, <b>F_SETPIPE_SZ</b>, <b>F_GETPIPE_SZ</b>, <b>F_GETSIG</b>,
       <b>F_SETSIG</b>, <b>F_NOTIFY</b>, <b>F_GETLEASE</b>, and <b>F_SETLEASE </b>are Linux-
       specific.  (Define the <b>_GNU_SOURCE </b>macro to obtain these
       definitions.)

       <b>F_OFD_SETLK</b>, <b>F_OFD_SETLKW</b>, and <b>F_OFD_GETLK </b>are Linux-specific
       (and one must define <b>_GNU_SOURCE </b>to obtain their definitions),
       but work is being done to have them included in the next version
       of POSIX.1.

       <b>F_ADD_SEALS </b>and <b>F_GET_SEALS </b>are Linux-specific.
</pre> <h2>
HISTORY </h2>
<pre>
       SVr4, 4.3BSD, POSIX.1-2001.

       Only the operations <b>F_DUPFD</b>, <b>F_GETFD</b>, <b>F_SETFD</b>, <b>F_GETFL</b>, <b>F_SETFL</b>,
       <b>F_GETLK</b>, <b>F_SETLK</b>, and <b>F_SETLKW </b>are specified in POSIX.1-2001.

       <b>F_GETOWN </b>and <b>F_SETOWN </b>are specified in POSIX.1-2001.  (To get
       their definitions, define either <b>_XOPEN_SOURCE </b>with the value 500
       or greater, or <b>_POSIX_C_SOURCE </b>with the value 200809L or
       greater.)

       <b>F_DUPFD_CLOEXEC </b>is specified in POSIX.1-2008.  (To get this
       definition, define <b>_POSIX_C_SOURCE </b>with the value 200809L or
       greater, or <b>_XOPEN_SOURCE </b>with the value 700 or greater.)
</pre> <h2>
NOTES </h2>
<pre>
       The errors returned by <a href="dup2.2.html">dup2(2)</a> are different from those returned
       by <b>F_DUPFD</b>.

   <b>File locking</b>
       The original Linux <b>fcntl</b>() system call was not designed to handle
       large file offsets (in the <i>flock</i> structure).  Consequently, an
       <b>fcntl64</b>() system call was added in Linux 2.4.  The newer system
       call employs a different structure for file locking, <i>flock64</i>, and
       corresponding operations, <b>F_GETLK64</b>, <b>F_SETLK64</b>, and <b>F_SETLKW64</b>.
       However, these details can be ignored by applications using
       glibc, whose <b>fcntl</b>() wrapper function transparently employs the
       more recent system call where it is available.

   <b>Record locks</b>
       Since Linux 2.0, there is no interaction between the types of
       lock placed by <a href="flock.2.html">flock(2)</a> and <b>fcntl</b>().

       Several systems have more fields in <i>struct flock</i> such as, for
       example, <i>l_sysid</i> (to identify the machine where the lock is
       held).  Clearly, <i>l_pid</i> alone is not going to be very useful if
       the process holding the lock may live on a different machine; on
       Linux, while present on some architectures (such as MIPS32), this
       field is not used.

       The original Linux <b>fcntl</b>() system call was not designed to handle
       large file offsets (in the <i>flock</i> structure).  Consequently, an
       <b>fcntl64</b>() system call was added in Linux 2.4.  The newer system
       call employs a different structure for file locking, <i>flock64</i>, and
       corresponding operations, <b>F_GETLK64</b>, <b>F_SETLK64</b>, and <b>F_SETLKW64</b>.
       However, these details can be ignored by applications using
       glibc, whose <b>fcntl</b>() wrapper function transparently employs the
       more recent system call where it is available.

   <b>Record locking and NFS</b>
       Before Linux 3.12, if an NFSv4 client loses contact with the
       server for a period of time (defined as more than 90 seconds with
       no communication), it might lose and regain a lock without ever
       being aware of the fact.  (The period of time after which contact
       is assumed lost is known as the NFSv4 leasetime.  On a Linux NFS
       server, this can be determined by looking at
       <i>/proc/fs/nfsd/nfsv4leasetime</i>, which expresses the period in
       seconds.  The default value for this file is 90.)  This scenario
       potentially risks data corruption, since another process might
       acquire a lock in the intervening period and perform file I/O.

       Since Linux 3.12, if an NFSv4 client loses contact with the
       server, any I/O to the file by a process which "thinks" it holds
       a lock will fail until that process closes and reopens the file.
       A kernel parameter, <i>nfs.recover_lost_locks</i>, can be set to 1 to
       obtain the pre-3.12 behavior, whereby the client will attempt to
       recover lost locks when contact is reestablished with the server.
       Because of the attendant risk of data corruption, this parameter
       defaults to 0 (disabled).
</pre> <h2>
BUGS </h2>
<pre>
   <b>F_SETFL</b>
       It is not possible to use <b>F_SETFL </b>to change the state of the
       <b>O_DSYNC </b>and <b>O_SYNC </b>flags.  Attempts to change the state of these
       flags are silently ignored.

   <b>F_GETOWN</b>
       A limitation of the Linux system call conventions on some
       architectures (notably i386) means that if a (negative) process
       group ID to be returned by <b>F_GETOWN </b>falls in the range -1 to
       -4095, then the return value is wrongly interpreted by glibc as
       an error in the system call; that is, the return value of <b>fcntl</b>()
       will be -1, and <i><a href="../man3/errno.3.html">errno</a></i> will contain the (positive) process group
       ID.  The Linux-specific <b>F_GETOWN_EX </b>operation avoids this
       problem.  Since glibc 2.11, glibc makes the kernel <b>F_GETOWN</b>
       problem invisible by implementing <b>F_GETOWN </b>using <b>F_GETOWN_EX</b>.

   <b>F_SETOWN</b>
       In Linux 2.4 and earlier, there is bug that can occur when an
       unprivileged process uses <b>F_SETOWN </b>to specify the owner of a
       socket file descriptor as a process (group) other than the
       caller.  In this case, <b>fcntl</b>() can return -1 with <i><a href="../man3/errno.3.html">errno</a></i> set to
       <b>EPERM</b>, even when the owner process (group) is one that the caller
       has permission to send signals to.  Despite this error return,
       the file descriptor owner is set, and signals will be sent to the
       owner.

   <b>Deadlock detection</b>
       The deadlock-detection algorithm employed by the kernel when
       dealing with <b>F_SETLKW </b>requests can yield both false negatives
       (failures to detect deadlocks, leaving a set of deadlocked
       processes blocked indefinitely) and false positives (<b>EDEADLK</b>
       errors when there is no deadlock).  For example, the kernel
       limits the lock depth of its dependency search to 10 steps,
       meaning that circular deadlock chains that exceed that size will
       not be detected.  In addition, the kernel may falsely indicate a
       deadlock when two or more processes created using the <a href="clone.2.html">clone(2)</a>
       <b>CLONE_FILES </b>flag place locks that appear (to the kernel) to
       conflict.

   <b>Mandatory locking</b>
       The Linux implementation of mandatory locking is subject to race
       conditions which render it unreliable: a <a href="write.2.html">write(2)</a> call that
       overlaps with a lock may modify data after the mandatory lock is
       acquired; a <a href="read.2.html">read(2)</a> call that overlaps with a lock may detect
       changes to data that were made only after a write lock was
       acquired.  Similar races exist between mandatory locks and
       <a href="mmap.2.html">mmap(2)</a>.  It is therefore inadvisable to rely on mandatory
       locking.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="dup2.2.html">dup2(2)</a>, <a href="flock.2.html">flock(2)</a>, <a href="open.2.html">open(2)</a>, <a href="socket.2.html">socket(2)</a>, <a href="../man3/lockf.3.html">lockf(3)</a>, <a href="../man7/capabilities.7.html">capabilities(7)</a>,
       <a href="../man7/feature_test_macros.7.html">feature_test_macros(7)</a>, <a href="../man8/lslocks.8.html">lslocks(8)</a>

       <i>locks.txt</i>, <i>mandatory-locking.txt</i>, and <i>dnotify.txt</i> in the Linux
       kernel source directory <i>Documentation/filesystems/</i> (on older
       kernels, these files are directly under the <i>Documentation/</i>
       directory, and <i>mandatory-locking.txt</i> is called <i>mandatory.txt</i>)
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       ⟨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>⟩.  If you have a bug report
       for this manual page, see
       ⟨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>⟩.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       ⟨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>⟩ on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-05-02                       <i>fcntl</i>(2)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/flock.1.html">flock(1)</a>, <a href="../man1/pipesz.1.html">pipesz(1)</a>, <a href="accept.2.html">accept(2)</a>, <a href="bpf.2.html">bpf(2)</a>, <a href="chmod.2.html">chmod(2)</a>, <a href="clone.2.html">clone(2)</a>, <a href="close.2.html">close(2)</a>, <a href="dup.2.html">dup(2)</a>, <a href="eventfd.2.html">eventfd(2)</a>, <a href="execve.2.html">execve(2)</a>, <a href="fallocate.2.html">fallocate(2)</a>, <a href="flock.2.html">flock(2)</a>, <a href="fork.2.html">fork(2)</a>, <a href="getrlimit.2.html">getrlimit(2)</a>, <a href="gettid.2.html">gettid(2)</a>, <a href="inotify_init.2.html">inotify_init(2)</a>, <a href="ioctl.2.html">ioctl(2)</a>, <a href="ioctl_console.2.html">ioctl_console(2)</a>, <a href="memfd_create.2.html">memfd_create(2)</a>, <a href="memfd_secret.2.html">memfd_secret(2)</a>, <a href="mknod.2.html">mknod(2)</a>, <a href="mmap.2.html">mmap(2)</a>, <a href="mount.2.html">mount(2)</a>, <a href="ns_get_userns.2const.html">NS_GET_USERNS(2const)</a>, <a href="open.2.html">open(2)</a>, <a href="perf_event_open.2.html">perf_event_open(2)</a>, <a href="pidfd_getfd.2.html">pidfd_getfd(2)</a>, <a href="pipe.2.html">pipe(2)</a>, <a href="read.2.html">read(2)</a>, <a href="recv.2.html">recv(2)</a>, <a href="select_tut.2.html">select_tut(2)</a>, <a href="send.2.html">send(2)</a>, <a href="sigaction.2.html">sigaction(2)</a>, <a href="signalfd.2.html">signalfd(2)</a>, <a href="socket.2.html">socket(2)</a>, <a href="statfs.2.html">statfs(2)</a>, <a href="syscalls.2.html">syscalls(2)</a>, <a href="timerfd_create.2.html">timerfd_create(2)</a>, <a href="truncate.2.html">truncate(2)</a>, <a href="userfaultfd.2.html">userfaultfd(2)</a>, <a href="write.2.html">write(2)</a>, <a href="../man3/audit_open.3.html">audit_open(3)</a>, <a href="../man3/dbopen.3.html">dbopen(3)</a>, <a href="../man3/fopen.3.html">fopen(3)</a>, <a href="../man3/lockf.3.html">lockf(3)</a>, <a href="../man3/sd_event_add_io.3.html">sd_event_add_io(3)</a>, <a href="../man3/shm_open.3.html">shm_open(3)</a>, <a href="../man3/sockatmark.3.html">sockatmark(3)</a>, <a href="../man3/statvfs.3.html">statvfs(3)</a>, <a href="../man5/nfs.5.html">nfs(5)</a>, <a href="../man5/proc_locks.5.html">proc_locks(5)</a>, <a href="../man5/proc_sys_fs.5.html">proc_sys_fs(5)</a>, <a href="../man5/systemd.socket.5.html">systemd.socket(5)</a>, <a href="../man7/capabilities.7.html">capabilities(7)</a>, <a href="../man7/credentials.7.html">credentials(7)</a>, <a href="../man7/epoll.7.html">epoll(7)</a>, <a href="../man7/inotify.7.html">inotify(7)</a>, <a href="../man7/landlock.7.html">landlock(7)</a>, <a href="../man7/man-pages.7.html">man-pages(7)</a>, <a href="../man7/pipe.7.html">pipe(7)</a>, <a href="../man7/pthreads.7.html">pthreads(7)</a>, <a href="../man7/signal.7.html">signal(7)</a>, <a href="../man7/signal-safety.7.html">signal-safety(7)</a>, <a href="../man7/socket.7.html">socket(7)</a>, <a href="../man7/tcp.7.html">tcp(7)</a>, <a href="../man8/lslocks.8.html">lslocks(8)</a>, <a href="../man8/mount.8.html">mount(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man2/fcntl64.2.html" class="_attribution-link">https://man7.org/linux/man-pages/man2/fcntl64.2.html</a>
  </p>
</div>
