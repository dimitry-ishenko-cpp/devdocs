<h1>io_uring_enter2(2) â€” Linux manual page</h1>   <pre>
<span class="headline"><i>io_uring_enter</i>(2)       Linux Programmer's Manual      <i>io_uring_enter</i>(2)</span>
</pre> <h2>
NAME </h2>
<pre>
       io_uring_enter - initiate and/or complete asynchronous I/O
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;liburing.h&gt;</b>

       <b>int io_uring_enter(unsigned int </b><i>fd</i><b>, unsigned int </b><i>to_submit</i><b>,</b>
                          <b>unsigned int </b><i>min_complete</i><b>, unsigned int </b><i>flags</i><b>,</b>
                          <b>sigset_t *</b><i>sig</i><b>);</b>

       <b>int io_uring_enter2(unsigned int </b><i>fd</i><b>, unsigned int </b><i>to_submit</i><b>,</b>
                           <b>unsigned int </b><i>min_complete</i><b>, unsigned int </b><i>flags</i><b>,</b>
                           <b>sigset_t *</b><i>sig</i><b>, size_t </b><i>sz</i><b>);</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       <a href="io_uring_enter.2.html">io_uring_enter(2)</a> is used to initiate and complete I/O using the
       shared submission and completion queues setup by a call to
       <a href="io_uring_setup.2.html">io_uring_setup(2)</a>.  A single call can both submit new I/O and
       wait for completions of I/O initiated by this call or previous
       calls to <a href="io_uring_enter.2.html">io_uring_enter(2)</a>.

       <i>fd</i> is the file descriptor returned by <a href="io_uring_setup.2.html">io_uring_setup(2)</a>.
       <i>to_submit</i> specifies the number of I/Os to submit from the
       submission queue.  <i>flags</i> is a bitmask of the following values:

       <b>IORING_ENTER_GETEVENTS</b>
              If this flag is set, then the system call will wait for
              the specified number of events in <i>min_complete</i> before
              returning. This flag can be set along with <i>to_submit</i> to
              both submit and complete events in a single system call.

       <b>IORING_ENTER_SQ_WAKEUP</b>
              If the ring has been created with <b>IORING_SETUP_SQPOLL,</b>
              then this flag asks the kernel to wakeup the SQ kernel
              thread to submit IO.

       <b>IORING_ENTER_SQ_WAIT</b>
              If the ring has been created with <b>IORING_SETUP_SQPOLL,</b>
              then the application has no real insight into when the SQ
              kernel thread has consumed entries from the SQ ring. This
              can lead to a situation where the application can no
              longer get a free SQE entry to submit, without knowing
              when it one becomes available as the SQ kernel thread
              consumes them. If the system call is used with this flag
              set, then it will wait until at least one entry is free in
              the SQ ring.

       <b>IORING_ENTER_EXT_ARG</b>
              Since kernel 5.11, the system calls arguments have been
              modified to look like the following:

              <b>int io_uring_enter2(unsigned int </b><i>fd</i><b>, unsigned int </b><i>to_submit</i><b>,</b>
                                  <b>unsigned int </b><i>min_complete</i><b>, unsigned int </b><i>flags</i><b>,</b>
                                  <b>const void *</b><i>arg</i><b>, size_t </b><i>argsz</i><b>);</b>

              which behaves just like the original definition by
              default. However, if <b>IORING_ENTER_EXT_ARG </b>is set, then
              instead of a <i>sigset_t</i> being passed in, a pointer to a
              <i>struct io_uring_getevents_arg</i> is used instead and <i>argsz</i>
              must be set to the size of this structure. The definition
              is as follows:

              <b>struct io_uring_getevents_arg {</b>
                      <b>__u64   sigmask;</b>
                      <b>__u32   sigmask_sz;</b>
                      <b>__u32   pad;</b>
                      <b>__u64   ts;</b>
              <b>};</b>

              which allows passing in both a signal mask as well as
              pointer to a <i>struct __kernel_timespec</i> timeout value. If <i>ts</i>
              is set to a valid pointer, then this time value indicates
              the timeout for waiting on events. If an application is
              waiting on events and wishes to stop waiting after a
              specified amount of time, then this can be accomplished
              directly in version 5.11 and newer by using this feature.

       <b>IORING_ENTER_REGISTERED_RING</b>
              If the ring file descriptor has been registered through
              use of <b>IORING_REGISTER_RING_FDS, </b>then setting this flag
              will tell the kernel that the <i>ring_fd</i> passed in is the
              registered ring offset rather than a normal file
              descriptor.

       If the io_uring instance was configured for polling, by
       specifying <b>IORING_SETUP_IOPOLL </b>in the call to <a href="io_uring_setup.2.html">io_uring_setup(2)</a>,
       then min_complete has a slightly different meaning.  Passing a
       value of 0 instructs the kernel to return any events which are
       already complete, without blocking.  If <i>min_complete</i> is a non-
       zero value, the kernel will still return immediately if any
       completion events are available.  If no event completions are
       available, then the call will poll either until one or more
       completions become available, or until the process has exceeded
       its scheduler time slice.

       Note that, for interrupt driven I/O (where <b>IORING_SETUP_IOPOLL</b>
       was not specified in the call to <a href="io_uring_setup.2.html">io_uring_setup(2)</a>), an
       application may check the completion queue for event completions
       without entering the kernel at all.

       When the system call returns that a certain amount of SQEs have
       been consumed and submitted, it's safe to reuse SQE entries in
       the ring. This is true even if the actual IO submission had to be
       punted to async context, which means that the SQE may in fact not
       have been submitted yet. If the kernel requires later use of a
       particular SQE entry, it will have made a private copy of it.

       <i>sig</i> is a pointer to a signal mask (see <a href="sigprocmask.2.html">sigprocmask(2)</a>); if <i>sig</i> is
       not NULL, <a href="io_uring_enter.2.html">io_uring_enter(2)</a> first replaces the current signal
       mask by the one pointed to by <i>sig</i>, then waits for events to
       become available in the completion queue, and then restores the
       original signal mask.  The following <a href="io_uring_enter.2.html">io_uring_enter(2)</a> call:

           ret = io_uring_enter(fd, 0, 1, IORING_ENTER_GETEVENTS, &amp;sig);

       is equivalent to <i>atomically</i> executing the following calls:

           pthread_sigmask(SIG_SETMASK, &amp;sig, &amp;orig);
           ret = io_uring_enter(fd, 0, 1, IORING_ENTER_GETEVENTS, NULL);
           pthread_sigmask(SIG_SETMASK, &amp;orig, NULL);

       See the description of <a href="pselect.2.html">pselect(2)</a> for an explanation of why the
       <i>sig</i> parameter is necessary.

       Submission queue entries are represented using the following data
       structure:

           /*
            * IO submission data structure (Submission Queue Entry)
            */
           struct io_uring_sqe {
               __u8    opcode;         /* type of operation for this sqe */
               __u8    flags;          /* IOSQE_ flags */
               __u16   ioprio;         /* ioprio for the request */
               __s32   fd;             /* file descriptor to do IO on */
               union {
                   __u64   off;            /* offset into file */
                   __u64   addr2;
               };
               union {
                   __u64   addr;       /* pointer to buffer or iovecs */
                   __u64   splice_off_in;
               }
               __u32   len;            /* buffer size or number of iovecs */
               union {
                   __kernel_rwf_t  rw_flags;
                   __u32    fsync_flags;
                   __u16    poll_events;   /* compatibility */
                   __u32    poll32_events; /* word-reversed for BE */
                   __u32    sync_range_flags;
                   __u32    msg_flags;
                   __u32    timeout_flags;
                   __u32    accept_flags;
                   __u32    cancel_flags;
                   __u32    open_flags;
                   __u32    statx_flags;
                   __u32    fadvise_advice;
                   __u32    splice_flags;
                   __u32    rename_flags;
                   __u32    unlink_flags;
                   __u32    hardlink_flags;
               };
               __u64    user_data;     /* data to be passed back at completion time */
               union {
               struct {
                   /* index into fixed buffers, if used */
                       union {
                           /* index into fixed buffers, if used */
                           __u16    buf_index;
                           /* for grouped buffer selection */
                           __u16    buf_group;
                       }
                   /* personality to use, if used */
                   __u16    personality;
                   union {
                       __s32    splice_fd_in;
                       __u32    file_index;
                };
               };
               __u64    __pad2[3];
               };
           };

       The <i>opcode</i> describes the operation to be performed.  It can be
       one of:

       <b>IORING_OP_NOP</b>
              Do not perform any I/O.  This is useful for testing the
              performance of the io_uring implementation itself.

       <b>IORING_OP_READV</b>

       <b>IORING_OP_WRITEV</b>
              Vectored read and write operations, similar to <a href="preadv2.2.html">preadv2(2)</a>
              and <a href="pwritev2.2.html">pwritev2(2)</a>.  If the file is not seekable, <i>off</i> must be
              set to zero or -1.

       <b>IORING_OP_READ_FIXED</b>

       <b>IORING_OP_WRITE_FIXED</b>
              Read from or write to pre-mapped buffers.  See
              <a href="io_uring_register.2.html">io_uring_register(2)</a> for details on how to setup a context
              for fixed reads and writes.

       <b>IORING_OP_FSYNC</b>
              File sync.  See also <a href="fsync.2.html">fsync(2)</a>.  Note that, while I/O is
              initiated in the order in which it appears in the
              submission queue, completions are unordered.  For example,
              an application which places a write I/O followed by an
              fsync in the submission queue cannot expect the fsync to
              apply to the write.  The two operations execute in
              parallel, so the fsync may complete before the write is
              issued to the storage.  The same is also true for
              previously issued writes that have not completed prior to
              the fsync.

       <b>IORING_OP_POLL_ADD</b>
              Poll the <i>fd</i> specified in the submission queue entry for
              the events specified in the <i>poll_events</i> field.  Unlike
              poll or epoll without <b>EPOLLONESHOT</b>, by default this
              interface always works in one shot mode.  That is, once
              the poll operation is completed, it will have to be
              resubmitted.

              If <b>IORING_POLL_ADD_MULTI </b>is set in the SQE <i>len</i> field, then
              the poll will work in multi shot mode instead. That means
              it'll repatedly trigger when the requested event becomes
              true, and hence multiple CQEs can be generated from this
              single SQE. The CQE <i>flags</i> field will have
              <b>IORING_CQE_F_MORE </b>set on completion if the application
              should expect further CQE entries from the original
              request. If this flag isn't set on completion, then the
              poll request has been terminated and no further events
              will be generated. This mode is available since 5.13.

              This command works like an async <a href="poll.2.html">poll(2)</a> and the
              completion event result is the returned mask of events.

       <b>IORING_OP_POLL_REMOVE</b>
              Remove or update an existing poll request.  If found, the
              <i>res</i> field of the <i>struct io_uring_cqe</i> will contain 0.  If
              not found, <i>res</i> will contain <b>-ENOENT, </b>or <b>-EALREADY </b>if the
              poll request was in the process of completing already.

              If <b>IORING_POLL_UPDATE_EVENTS </b>is set in the SQE <i>len</i> field,
              then the request will update an existing poll request with
              the mask of events passed in with this request. The lookup
              is based on the <i>user_data</i> field of the original SQE
              submitted, and this values is passed in the <i>addr</i> field of
              the SQE.  If <b>IORING_POLL_UPDATE_USER_DATA </b>is set in the
              SQE <i>len</i> field, then the request will update the <i>user_data</i>
              of an existing poll request based on the value passed in
              the <i>off</i> field. Updating an existing poll is available
              since 5.13.

       <b>IORING_OP_EPOLL_CTL</b>
              Add, remove or modify entries in the interest list of
              <a href="../man7/epoll.7.html">epoll(7)</a>.  See <a href="epoll_ctl.2.html">epoll_ctl(2)</a> for details of the system
              call.  <i>fd</i> holds the file descriptor that represents the
              epoll instance, <i>addr</i> holds the file descriptor to add,
              remove or modify, <i>len</i> holds the operation (EPOLL_CTL_ADD,
              EPOLL_CTL_DEL, EPOLL_CTL_MOD) to perform and, <i>off</i> holds a
              pointer to the <i>epoll_events</i> structure. Available since
              5.6.

       <b>IORING_OP_SYNC_FILE_RANGE</b>
              Issue the equivalent of a <b>sync_file_range </b>(2) on the file
              descriptor. The <i>fd</i> field is the file descriptor to sync,
              the <i>off</i> field holds the offset in bytes, the <i>len</i> field
              holds the length in bytes, and the <i>sync_range_flags</i> field
              holds the flags for the command. See also
              <a href="sync_file_range.2.html">sync_file_range(2)</a> for the general description of the
              related system call. Available since 5.2.

       <b>IORING_OP_SENDMSG</b>
              Issue the equivalent of a <a href="sendmsg.2.html">sendmsg(2)</a> system call.  <i>fd</i> must
              be set to the socket file descriptor, <i>addr</i> must contain a
              pointer to the msghdr structure, and <i>msg_flags</i> holds the
              flags associated with the system call. See also <a href="sendmsg.2.html">sendmsg(2)</a>
              for the general description of the related system call.
              Available since 5.3.

              This command also supports the following modifiers in
              <i>ioprio:</i>

                   <b>IORING_RECVSEND_POLL_FIRST </b>If set, io_uring will
                   assume the socket is currently full and attempting to
                   send data will be unsuccessful. For this case,
                   io_uring will arm internal poll and trigger a send of
                   the data when there is enough space available.  This
                   initial send attempt can be wasteful for the case
                   where the socket is expected to be full, setting this
                   flag will bypass the initial send attempt and go
                   straight to arming poll. If poll does indicate that
                   data can be sent, the operation will proceed.

       <b>IORING_OP_RECVMSG</b>
              Works just like IORING_OP_SENDMSG, except for <a href="recvmsg.2.html">recvmsg(2)</a>
              instead. See the description of IORING_OP_SENDMSG.
              Available since 5.3.

              This command also supports the following modifiers in
              <i>ioprio:</i>

                   <b>IORING_RECVSEND_POLL_FIRST </b>If set, io_uring will
                   assume the socket is currently empty and attempting
                   to receive data will be unsuccessful. For this case,
                   io_uring will arm internal poll and trigger a receive
                   of the data when the socket has data to be read.
                   This initial receive attempt can be wasteful for the
                   case where the socket is expected to be empty,
                   setting this flag will bypass the initial receive
                   attempt and go straight to arming poll. If poll does
                   indicate that data is ready to be received, the
                   operation will proceed.

       <b>IORING_OP_SEND</b>
              Issue the equivalent of a <a href="send.2.html">send(2)</a> system call.  <i>fd</i> must be
              set to the socket file descriptor, <i>addr</i> must contain a
              pointer to the buffer, <i>len</i> denotes the length of the
              buffer to send, and <i>msg_flags</i> holds the flags associated
              with the system call. See also <a href="send.2.html">send(2)</a> for the general
              description of the related system call. Available since
              5.6.

              This command also supports the following modifiers in
              <i>ioprio:</i>

                   <b>IORING_RECVSEND_POLL_FIRST </b>If set, io_uring will
                   assume the socket is currently full and attempting to
                   send data will be unsuccessful. For this case,
                   io_uring will arm internal poll and trigger a send of
                   the data when there is enough space available.  This
                   initial send attempt can be wasteful for the case
                   where the socket is expected to be full, setting this
                   flag will bypass the initial send attempt and go
                   straight to arming poll. If poll does indicate that
                   data can be sent, the operation will proceed.

       <b>IORING_OP_RECV</b>
              Works just like IORING_OP_SEND, except for <a href="recv.2.html">recv(2)</a>
              instead. See the description of IORING_OP_SEND. Available
              since 5.6.

              This command also supports the following modifiers in
              <i>ioprio:</i>

                   <b>IORING_RECVSEND_POLL_FIRST </b>If set, io_uring will
                   assume the socket is currently empty and attempting
                   to receive data will be unsuccessful. For this case,
                   io_uring will arm internal poll and trigger a receive
                   of the data when the socket has data to be read.
                   This initial receive attempt can be wasteful for the
                   case where the socket is expected to be empty,
                   setting this flag will bypass the initial receive
                   attempt and go straight to arming poll. If poll does
                   indicate that data is ready to be received, the
                   operation will proceed.

       <b>IORING_OP_TIMEOUT</b>
              This command will register a timeout operation. The <i>addr</i>
              field must contain a pointer to a struct __kernel_timespec
              structure, <i>len</i> must contain 1 to signify one
              __kernel_timespec structure, <i>timeout_flags</i> may contain
              IORING_TIMEOUT_ABS for an absolute timeout value, or 0 for
              a relative timeout.  <i>off</i> may contain a completion event
              count. A timeout will trigger a wakeup event on the
              completion ring for anyone waiting for events. A timeout
              condition is met when either the specified timeout
              expires, or the specified number of events have completed.
              Either condition will trigger the event. If set to 0,
              completed events are not counted, which effectively acts
              like a timer. io_uring timeouts use the <b>CLOCK_MONOTONIC</b>
              clock source. The request will complete with <i>-ETIME</i> if the
              timeout got completed through expiration of the timer, or
              <i>0</i> if the timeout got completed through requests completing
              on their own. If the timeout was canceled before it
              expired, the request will complete with <i>-ECANCELED.</i>
              Available since 5.4.

              Since 5.15, this command also supports the following
              modifiers in <i>timeout_flags:</i>

                   <b>IORING_TIMEOUT_BOOTTIME </b>If set, then the clocksource
                   used is <i>CLOCK_BOOTTIME</i> instead of <i>CLOCK_MONOTONIC.</i>
                   This clocksource differs in that it includes time
                   elapsed if the system was suspend while having a
                   timeout request in-flight.

                   <b>IORING_TIMEOUT_REALTIME </b>If set, then the clocksource
                   used is <i>CLOCK_REALTIME</i> instead of <i>CLOCK_MONOTONIC.</i>

       <b>IORING_OP_TIMEOUT_REMOVE</b>
              If <i>timeout_flags are zero, then it attempts to remove an</i>
              <i>existing timeout</i> operation.  <i>addr</i> must contain the
              <i>user_data</i> field of the previously issued timeout
              operation. If the specified timeout request is found and
              canceled successfully, this request will terminate with a
              result value of <i>0</i> If the timeout request was found but
              expiration was already in progress, this request will
              terminate with a result value of <i>-EBUSY</i> If the timeout
              request wasn't found, the request will terminate with a
              result value of <i>-ENOENT</i> Available since 5.5.

              If <i>timeout_flags</i> contain <i>IORING_TIMEOUT_UPDATE,</i> instead of
              removing an existing operation, it updates it.  <i>addr</i> and
              return values are same as before.  <i>addr2</i> field must
              contain a pointer to a struct __kernel_timespec structure.
              <i>timeout_flags</i> may also contain IORING_TIMEOUT_ABS, in
              which case the value given is an absolute one, not a
              relative one.  Available since 5.11.

       <b>IORING_OP_ACCEPT</b>
              Issue the equivalent of an <a href="accept4.2.html">accept4(2)</a> system call.  <i>fd</i>
              must be set to the socket file descriptor, <i>addr</i> must
              contain the pointer to the sockaddr structure, and <i>addr2</i>
              must contain a pointer to the socklen_t addrlen field.
              Flags can be passed using the <i>accept_flags</i> field. See also
              <a href="accept4.2.html">accept4(2)</a> for the general description of the related
              system call. Available since 5.5.

              If the <i>file_index</i> field is set to a positive number, the
              file won't be installed into the normal file table as
              usual but will be placed into the fixed file table at
              index <i>file_index - 1.</i>  In this case, instead of returning
              a file descriptor, the result will contain either 0 on
              success or an error. If the index points to a valid empty
              slot, the installation is guaranteed to not fail. If there
              is already a file in the slot, it will be replaced,
              similar to <b>IORING_OP_FILES_UPDATE.  </b>Please note that only
              io_uring has access to such files and no other syscall can
              use them. See <b>IOSQE_FIXED_FILE </b>and <b>IORING_REGISTER_FILES.</b>

              Available since 5.5.

       <b>IORING_OP_ASYNC_CANCEL</b>
              Attempt to cancel an already issued request.  <i>addr</i> must
              contain the <i>user_data</i> field of the request that should be
              canceled. The cancelation request will complete with one
              of the following results codes. If found, the <i>res</i> field of
              the cqe will contain 0. If not found, <i>res</i> will contain
              -ENOENT. If found and attempted canceled, the <i>res</i> field
              will contain -EALREADY. In this case, the request may or
              may not terminate. In general, requests that are
              interruptible (like socket IO) will get canceled, while
              disk IO requests cannot be canceled if already started.
              Available since 5.5.

       <b>IORING_OP_LINK_TIMEOUT</b>
              This request must be linked with another request through
              <i>IOSQE_IO_LINK</i> which is described below. Unlike
              <i>IORING_OP_TIMEOUT, IORING_OP_LINK_TIMEOUT</i> acts on the
              linked request, not the completion queue. The format of
              the command is otherwise like <i>IORING_OP_TIMEOUT,</i> except
              there's no completion event count as it's tied to a
              specific request.  If used, the timeout specified in the
              command will cancel the linked command, unless the linked
              command completes before the timeout. The timeout will
              complete with <i>-ETIME</i> if the timer expired and the linked
              request was attempted canceled, or <i>-ECANCELED</i> if the timer
              got canceled because of completion of the linked request.
              Like <b>IORING_OP_TIMEOUT </b>the clock source used is
              <b>CLOCK_MONOTONIC </b>Available since 5.5.

       <b>IORING_OP_CONNECT</b>
              Issue the equivalent of a <a href="connect.2.html">connect(2)</a> system call.  <i>fd</i> must
              be set to the socket file descriptor, <i>addr</i> must contain
              the const pointer to the sockaddr structure, and <i>off</i> must
              contain the socklen_t addrlen field. See also <a href="connect.2.html">connect(2)</a>
              for the general description of the related system call.
              Available since 5.5.

       <b>IORING_OP_FALLOCATE</b>
              Issue the equivalent of a <a href="fallocate.2.html">fallocate(2)</a> system call.  <i>fd</i>
              must be set to the file descriptor, <i>len</i> must contain the
              mode associated with the operation, <i>off</i> must contain the
              offset on which to operate, and <i>addr</i> must contain the
              length. See also <a href="fallocate.2.html">fallocate(2)</a> for the general description
              of the related system call. Available since 5.6.

       <b>IORING_OP_FADVISE</b>
              Issue the equivalent of a <a href="posix_fadvise.2.html">posix_fadvise(2)</a> system call.
              <i>fd</i> must be set to the file descriptor, <i>off</i> must contain
              the offset on which to operate, <i>len</i> must contain the
              length, and <i>fadvise_advice</i> must contain the advice
              associated with the operation. See also <a href="posix_fadvise.2.html">posix_fadvise(2)</a>
              for the general description of the related system call.
              Available since 5.6.

       <b>IORING_OP_MADVISE</b>
              Issue the equivalent of a <a href="madvise.2.html">madvise(2)</a> system call.  <i>addr</i>
              must contain the address to operate on, <i>len</i> must contain
              the length on which to operate, and <i>fadvise_advice</i> must
              contain the advice associated with the operation. See also
              <a href="madvise.2.html">madvise(2)</a> for the general description of the related
              system call. Available since 5.6.

       <b>IORING_OP_OPENAT</b>
              Issue the equivalent of a <a href="openat.2.html">openat(2)</a> system call.  <i>fd</i> is
              the <i>dirfd</i> argument, <i>addr</i> must contain a pointer to the
              <i>*pathname</i> argument, <i>open_flags</i> should contain any flags
              passed in, and <i>len</i> is access mode of the file. See also
              <a href="openat.2.html">openat(2)</a> for the general description of the related
              system call. Available since 5.6.

              If the <i>file_index</i> field is set to a positive number, the
              file won't be installed into the normal file table as
              usual but will be placed into the fixed file table at
              index <i>file_index - 1.</i>  In this case, instead of returning
              a file descriptor, the result will contain either 0 on
              success or an error. If the index points to a valid empty
              slot, the installation is guaranteed to not fail. If there
              is already a file in the slot, it will be replaced,
              similar to <b>IORING_OP_FILES_UPDATE.  </b>Please note that only
              io_uring has access to such files and no other syscall can
              use them. See <b>IOSQE_FIXED_FILE </b>and <b>IORING_REGISTER_FILES.</b>

              Available since 5.15.

       <b>IORING_OP_OPENAT2</b>
              Issue the equivalent of a <a href="openat2.2.html">openat2(2)</a> system call.  <i>fd</i> is
              the <i>dirfd</i> argument, <i>addr</i> must contain a pointer to the
              <i>*pathname</i> argument, <i>len</i> should contain the size of the
              open_how structure, and <i>off</i> should be set to the address
              of the open_how structure. See also <a href="openat2.2.html">openat2(2)</a> for the
              general description of the related system call. Available
              since 5.6.

              If the <i>file_index</i> field is set to a positive number, the
              file won't be installed into the normal file table as
              usual but will be placed into the fixed file table at
              index <i>file_index - 1.</i>  In this case, instead of returning
              a file descriptor, the result will contain either 0 on
              success or an error. If the index points to a valid empty
              slot, the installation is guaranteed to not fail. If there
              is already a file in the slot, it will be replaced,
              similar to <b>IORING_OP_FILES_UPDATE.  </b>Please note that only
              io_uring has access to such files and no other syscall can
              use them. See <b>IOSQE_FIXED_FILE </b>and <b>IORING_REGISTER_FILES.</b>

              Available since 5.15.

       <b>IORING_OP_CLOSE</b>
              Issue the equivalent of a <a href="close.2.html">close(2)</a> system call.  <i>fd</i> is the
              file descriptor to be closed. See also <a href="close.2.html">close(2)</a> for the
              general description of the related system call. Available
              since 5.6.  If the <i>file_index</i> field is set to a positive
              number, this command can be used to close files that were
              direct opened through <b>IORING_OP_OPENAT </b>, <b>IORING_OP_OPENAT2</b>
              , or <b>IORING_OP_ACCEPT </b>using the io_uring specific direct
              descriptors. Note that only one of the descriptor fields
              may be set. The direct close feature is available since
              the 5.15 kernel, where direct descriptors were introduced.

       <b>IORING_OP_STATX</b>
              Issue the equivalent of a <a href="statx.2.html">statx(2)</a> system call.  <i>fd</i> is the
              <i>dirfd</i> argument, <i>addr</i> must contain a pointer to the
              <i>*pathname</i> string, <i>statx_flags</i> is the <i>flags</i> argument, <i>len</i>
              should be the <i>mask</i> argument, and <i>off</i> must contain a
              pointer to the <i>statxbuf</i> to be filled in. See also <a href="statx.2.html">statx(2)</a>
              for the general description of the related system call.
              Available since 5.6.

       <b>IORING_OP_READ</b>

       <b>IORING_OP_WRITE</b>
              Issue the equivalent of a <a href="pread.2.html">pread(2)</a> or <a href="pwrite.2.html">pwrite(2)</a> system
              call.  <i>fd</i> is the file descriptor to be operated on, <i>addr</i>
              contains the buffer in question, <i>len</i> contains the length
              of the IO operation, and <i>offs</i> contains the read or write
              offset. If <i>fd</i> does not refer to a seekable file, <i>off</i> must
              be set to zero or -1. If <i>offs</i> is set to <b>-1 </b>, the offset
              will use (and advance) the file position, like the <a href="read.2.html">read(2)</a>
              and <a href="write.2.html">write(2)</a> system calls. These are non-vectored versions
              of the <b>IORING_OP_READV </b>and <b>IORING_OP_WRITEV </b>opcodes. See
              also <a href="read.2.html">read(2)</a> and <a href="write.2.html">write(2)</a> for the general description of
              the related system call. Available since 5.6.

       <b>IORING_OP_SPLICE</b>
              Issue the equivalent of a <a href="splice.2.html">splice(2)</a> system call.
              <i>splice_fd_in</i> is the file descriptor to read from,
              <i>splice_off_in</i> is an offset to read from, <i>fd</i> is the file
              descriptor to write to, <i>off</i> is an offset from which to
              start writing to. A sentinel value of <b>-1 </b>is used to pass
              the equivalent of a NULL for the offsets to <a href="splice.2.html">splice(2)</a>.
              <i>len</i> contains the number of bytes to copy.  <i>splice_flags</i>
              contains a bit mask for the flag field associated with the
              system call.  Please note that one of the file descriptors
              must refer to a pipe.  See also <a href="splice.2.html">splice(2)</a> for the general
              description of the related system call. Available since
              5.7.

       <b>IORING_OP_TEE</b>
              Issue the equivalent of a <a href="tee.2.html">tee(2)</a> system call.
              <i>splice_fd_in</i> is the file descriptor to read from, <i>fd</i> is
              the file descriptor to write to, <i>len</i> contains the number
              of bytes to copy, and <i>splice_flags</i> contains a bit mask for
              the flag field associated with the system call.  Please
              note that both of the file descriptors must refer to a
              pipe.  See also <a href="tee.2.html">tee(2)</a> for the general description of the
              related system call. Available since 5.8.

       <b>IORING_OP_FILES_UPDATE</b>
              This command is an alternative to using
              <b>IORING_REGISTER_FILES_UPDATE </b>which then works in an async
              fashion, like the rest of the io_uring commands.  The
              arguments passed in are the same.  <i>addr</i> must contain a
              pointer to the array of file descriptors, <i>len</i> must contain
              the length of the array, and <i>off</i> must contain the offset
              at which to operate. Note that the array of file
              descriptors pointed to in <i>addr</i> must remain valid until
              this operation has completed. Available since 5.6.

       <b>IORING_OP_PROVIDE_BUFFERS</b>
              This command allows an application to register a group of
              buffers to be used by commands that read/receive data.
              Using buffers in this manner can eliminate the need to
              separate the poll + read, which provides a convenient
              point in time to allocate a buffer for a given request.
              It's often infeasible to have as many buffers available as
              pending reads or receive. With this feature, the
              application can have its pool of buffers ready in the
              kernel, and when the file or socket is ready to
              read/receive data, a buffer can be selected for the
              operation.  <i>fd</i> must contain the number of buffers to
              provide, <i>addr</i> must contain the starting address to add
              buffers from, <i>len</i> must contain the length of each buffer
              to add from the range, <i>buf_group</i> must contain the group ID
              of this range of buffers, and <i>off</i> must contain the
              starting buffer ID of this range of buffers. With that
              set, the kernel adds buffers starting with the memory
              address in <i>addr,</i> each with a length of <i>len.</i>  Hence the
              application should provide <i>len * fd</i> worth of memory in
              <i>addr.</i>  Buffers are grouped by the group ID, and each
              buffer within this group will be identical in size
              according to the above arguments. This allows the
              application to provide different groups of buffers, and
              this is often used to have differently sized buffers
              available depending on what the expectations are of the
              individual request. When submitting a request that should
              use a provided buffer, the <b>IOSQE_BUFFER_SELECT </b>flag must
              be set, and <i>buf_group</i> must be set to the desired buffer
              group ID where the buffer should be selected from.
              Available since 5.7.

       <b>IORING_OP_REMOVE_BUFFERS</b>
              Remove buffers previously registered with
              <b>IORING_OP_PROVIDE_BUFFERS.  </b><i>fd</i> must contain the number of
              buffers to remove, and <i>buf_group</i> must contain the buffer
              group ID from which to remove the buffers. Available since
              5.7.

       <b>IORING_OP_SHUTDOWN</b>
              Issue the equivalent of a <a href="shutdown.2.html">shutdown(2)</a> system call.  <i>fd</i> is
              the file descriptor to the socket being shutdown, and <i>len</i>
              must be set to the <i>how</i> argument. No no other fields should
              be set. Available since 5.11.

       <b>IORING_OP_RENAMEAT</b>
              Issue the equivalent of a <a href="renameat2.2.html">renameat2(2)</a> system call.  <i>fd</i>
              should be set to the <i>olddirfd, addr</i> should be set to the
              <i>oldpath, len</i> should be set to the <i>newdirfd, addr</i> should be
              set to the <i>oldpath, addr2</i> should be set to the <i>newpath,</i>
              and finally <i>rename_flags</i> should be set to the <i>flags</i> passed
              in to <a href="renameat2.2.html">renameat2(2)</a>.  Available since 5.11.

       <b>IORING_OP_UNLINKAT</b>
              Issue the equivalent of a <b>unlinkat2</b>(2) system call.  <i>fd</i>
              should be set to the <i>dirfd, addr</i> should be set to the
              <i>pathname,</i> and <i>unlink_flags</i> should be set to the <i>flags</i>
              being passed in to <a href="unlinkat.2.html">unlinkat(2)</a>.  Available since 5.11.

       <b>IORING_OP_MKDIRAT</b>
              Issue the equivalent of a <b>mkdirat2</b>(2) system call.  <i>fd</i>
              should be set to the <i>dirfd, addr</i> should be set to the
              <i>pathname,</i> and <i>len</i> should be set to the <i>mode</i> being passed
              in to <a href="mkdirat.2.html">mkdirat(2)</a>.  Available since 5.15.

       <b>IORING_OP_SYMLINKAT</b>
              Issue the equivalent of a <b>symlinkat2</b>(2) system call.  <i>fd</i>
              should be set to the <i>newdirfd, addr</i> should be set to the
              <i>target</i> and <i>addr2</i> should be set to the <i>linkpath</i> being
              passed in to <a href="symlinkat.2.html">symlinkat(2)</a>.  Available since 5.15.

       <b>IORING_OP_LINKAT</b>
              Issue the equivalent of a <b>linkat2</b>(2) system call.  <i>fd</i>
              should be set to the <i>olddirfd, addr</i> should be set to the
              <i>oldpath, len</i> should be set to the <i>newdirfd, addr2</i> should
              be set to the <i>newpath,</i> and <i>hardlink_flags</i> should be set to
              the <i>flags</i> being passed in to <a href="linkat.2.html">linkat(2)</a>.  Available since
              5.15.

       <b>IORING_OP_MSG_RING</b>
              Send a message to an io_uring.  <i>fd</i> must be set to a file
              descriptor of a ring that the application has access to,
              <i>len</i> can be set to any 32-bit value that the application
              wishes to pass on, and <i>off</i> should be set any 64-bit value
              that the application wishes to send. On the target ring, a
              CQE will be posted with the <i>res</i> field matching the <i>len</i>
              set, and a <i>user_data</i> field matching the <i>off</i> value being
              passed in. This request type can be used to either just
              wake or interrupt anyone waiting for completions on the
              target ring, or it can be used to pass messages via the
              two fields. Available since 5.18.

       <b>IORING_OP_SOCKET</b>
              Issue the equivalent of a <a href="socket.2.html">socket(2)</a> system call.  <i>fd</i> must
              contain the communication domain, <i>off</i> must contain the
              communication type, <i>len</i> must contain the protocol, and
              <i>rw_flags</i> is currently unused and must be set to zero. See
              also <a href="socket.2.html">socket(2)</a> for the general description of the related
              system call. Available since 5.19.

              If the <i>file_index</i> field is set to a positive number, the
              file won't be installed into the normal file table as
              usual but will be placed into the fixed file table at
              index <i>file_index - 1.</i>  In this case, instead of returning
              a file descriptor, the result will contain either 0 on
              success or an error. If the index points to a valid empty
              slot, the installation is guaranteed to not fail. If there
              is already a file in the slot, it will be replaced,
              similar to <b>IORING_OP_FILES_UPDATE.  </b>Please note that only
              io_uring has access to such files and no other syscall can
              use them. See <b>IOSQE_FIXED_FILE </b>and <b>IORING_REGISTER_FILES.</b>

              Available since 5.19.

       <b>IORING_OP_SEND_ZC</b>
              Issue the zerocopy equivalent of a <a href="send.2.html">send(2)</a> system call.
              Similar to IORING_OP_SEND, but tries to avoid making
              intermediate copies of data. Zerocopy execution is not
              guaranteed and may fall back to copying. The request may
              also fail with <b>-EOPNOTSUPP , </b>when a protocol doesn't
              support zerocopy, in which case users are recommended to
              use copying sends instead.

              The <i>flags</i> field of the first <i>struct io_uring_cqe</i> may
              likely contain <b>IORING_CQE_F_MORE , </b>which means that there
              will be a second completion event / notification for the
              request, with the <i>user_data</i> field set to the same value.
              The user must not modify the data buffer until the
              notification is posted. The first cqe follows the usual
              rules and so its <i>res</i> field will contain the number of
              bytes sent or a negative error code. The notification's
              <i>res</i> field will be set to zero and the <i>flags</i> field will
              contain <b>IORING_CQE_F_NOTIF .  </b>The two step model is needed
              because the kernel may hold on to buffers for a long time,
              e.g. waiting for a TCP ACK, and having a separate cqe for
              request completions allows userspace to push more data
              without extra delays. Note, notifications are only
              responsible for controlling the lifetime of the buffers,
              and as such don't mean anything about whether the data has
              atually been sent out or received by the other end. Even
              errored requests may generate a notification, and the user
              must check for <b>IORING_CQE_F_MORE </b>rather than relying on
              the result.

              <i>fd</i> must be set to the socket file descriptor, <i>addr</i> must
              contain a pointer to the buffer, <i>len</i> denotes the length of
              the buffer to send, and <i>msg_flags</i> holds the flags
              associated with the system call. When <i>addr2</i> is non-zero it
              points to the address of the target with <i>addr_len</i>
              specifying its size, turning the request into a <a href="sendto.2.html">sendto(2)</a>
              system call equivalent.

              Available since 6.0.

              This command also supports the following modifiers in
              <i>ioprio:</i>

                   <b>IORING_RECVSEND_POLL_FIRST </b>If set, io_uring will
                   assume the socket is currently full and attempting to
                   send data will be unsuccessful. For this case,
                   io_uring will arm internal poll and trigger a send of
                   the data when there is enough space available.  This
                   initial send attempt can be wasteful for the case
                   where the socket is expected to be full, setting this
                   flag will bypass the initial send attempt and go
                   straight to arming poll. If poll does indicate that
                   data can be sent, the operation will proceed.

                   <b>IORING_RECVSEND_FIXED_BUF </b>If set, instructs io_uring
                   to use a pre-mapped buffer. The <i>buf_index</i> field
                   should contain an index into an array of fixed
                   buffers. See <a href="io_uring_register.2.html">io_uring_register(2)</a> for details on how
                   to setup a context for fixed buffer I/O.

       <b>IORING_OP_WAITID</b>
              Issue the equivalent of a <a href="waitid.2.html">waitid(2)</a> system call.  <i>len</i> must
              contain the idtype being queried/waited for and <i>fd</i> must
              contain the 'pid' (or id) being waited for.  <i>file_index</i> is
              the 'options' being set (the child state changes to wait
              for).  <i>addr2</i> is a pointer to siginfo_t, if any, being
              filled in. See also <a href="waitid.2.html">waitid(2)</a> for the general description
              of the related system call. Available since 6.5.

       The <i>flags</i> field is a bit mask. The supported flags are:

       <b>IOSQE_FIXED_FILE</b>
              When this flag is specified, <i>fd</i> is an index into the files
              array registered with the io_uring instance (see the
              <b>IORING_REGISTER_FILES </b>section of the <a href="io_uring_register.2.html">io_uring_register(2)</a>
              man page). Note that this isn't always available for all
              commands. If used on a command that doesn't support fixed
              files, the SQE will error with <b>-EBADF.  </b>Available since
              5.1.

       <b>IOSQE_IO_DRAIN</b>
              When this flag is specified, the SQE will not be started
              before previously submitted SQEs have completed, and new
              SQEs will not be started before this one completes.
              Available since 5.2.

       <b>IOSQE_IO_LINK</b>
              When this flag is specified, the SQE forms a link with the
              next SQE in the submission ring. That next SQE will not be
              started before the previous request completes. This, in
              effect, forms a chain of SQEs, which can be arbitrarily
              long. The tail of the chain is denoted by the first SQE
              that does not have this flag set. Chains are not supported
              across submission boundaries. Even if the last SQE in a
              submission has this flag set, it will still terminate the
              current chain. This flag has no effect on previous SQE
              submissions, nor does it impact SQEs that are outside of
              the chain tail. This means that multiple chains can be
              executing in parallel, or chains and individual SQEs. Only
              members inside the chain are serialized. A chain of SQEs
              will be broken, if any request in that chain ends in
              error. io_uring considers any unexpected result an error.
              This means that, eg, a short read will also terminate the
              remainder of the chain.  If a chain of SQE links is
              broken, the remaining unstarted part of the chain will be
              terminated and completed with <b>-ECANCELED </b>as the error
              code. Available since 5.3.

       <b>IOSQE_IO_HARDLINK</b>
              Like IOSQE_IO_LINK, but it doesn't sever regardless of the
              completion result.  Note that the link will still sever if
              we fail submitting the parent request, hard links are only
              resilient in the presence of completion results for
              requests that did submit correctly. IOSQE_IO_HARDLINK
              implies IOSQE_IO_LINK.  Available since 5.5.

       <b>IOSQE_ASYNC</b>
              Normal operation for io_uring is to try and issue an sqe
              as non-blocking first, and if that fails, execute it in an
              async manner. To support more efficient overlapped
              operation of requests that the application knows/assumes
              will always (or most of the time) block, the application
              can ask for an sqe to be issued async from the start.
              Available since 5.6.

       <b>IOSQE_BUFFER_SELECT</b>
              Used in conjunction with the <b>IORING_OP_PROVIDE_BUFFERS</b>
              command, which registers a pool of buffers to be used by
              commands that read or receive data. When buffers are
              registered for this use case, and this flag is set in the
              command, io_uring will grab a buffer from this pool when
              the request is ready to receive or read data. If
              successful, the resulting CQE will have
              <b>IORING_CQE_F_BUFFER </b>set in the flags part of the struct,
              and the upper <b>IORING_CQE_BUFFER_SHIFT </b>bits will contain
              the ID of the selected buffers. This allows the
              application to know exactly which buffer was selected for
              the operation. If no buffers are available and this flag
              is set, then the request will fail with <b>-ENOBUFS </b>as the
              error code. Once a buffer has been used, it is no longer
              available in the kernel pool. The application must re-
              register the given buffer again when it is ready to
              recycle it (eg has completed using it). Available since
              5.7.

       <b>IOSQE_CQE_SKIP_SUCCESS</b>
              Don't generate a CQE if the request completes
              successfully. If the request fails, an appropriate CQE
              will be posted as usual and if there is no
              <b>IOSQE_IO_HARDLINK, </b>CQEs for all linked requests will be
              omitted. The notion of failure/success is opcode specific
              and is the same as with breaking chains of <b>IOSQE_IO_LINK.</b>
              One special case is when the request has a linked timeout,
              then the CQE generation for the linked timeout is decided
              solely by whether it has <b>IOSQE_CQE_SKIP_SUCCESS </b>set,
              regardless whether it timed out or was canceled. In other
              words, if a linked timeout has the flag set, it's
              guaranteed to not post a CQE.

              The semantics are chosen to accommodate several use cases.
              First, when all but the last request of a normal link
              without linked timeouts are marked with the flag, only one
              CQE per link is posted. Additionally, it enables
              suppression of CQEs in cases where the side effects of a
              successfully executed operation is enough for userspace to
              know the state of the system. One such example would be
              writing to a synchronisation file.

              This flag is incompatible with <b>IOSQE_IO_DRAIN.  </b>Using both
              of them in a single ring is undefined behavior, even when
              they are not used together in a single request. Currently,
              after the first request with <b>IOSQE_CQE_SKIP_SUCCESS, </b>all
              subsequent requests marked with drain will be failed at
              submission time.  Note that the error reporting is best
              effort only, and restrictions may change in the future.

              Available since 5.17.

       <i>ioprio</i> specifies the I/O priority.  See <a href="ioprio_get.2.html">ioprio_get(2)</a> for a
       description of Linux I/O priorities.

       <i>fd</i> specifies the file descriptor against which the operation will
       be performed, with the exception noted above.

       If the operation is one of <b>IORING_OP_READ_FIXED </b>or
       <b>IORING_OP_WRITE_FIXED</b>, <i>addr</i> and <i>len</i> must fall within the buffer
       located at <i>buf_index</i> in the fixed buffer array.  If the operation
       is either <b>IORING_OP_READV </b>or <b>IORING_OP_WRITEV</b>, then <i>addr</i> points
       to an iovec array of <i>len</i> entries.

       <i>rw_flags</i>, specified for read and write operations, contains a
       bitwise OR of per-I/O flags, as described in the <a href="preadv2.2.html">preadv2(2)</a> man
       page.

       The <i>fsync_flags</i> bit mask may contain either 0, for a normal file
       integrity sync, or <b>IORING_FSYNC_DATASYNC </b>to provide data sync
       only semantics.  See the descriptions of <b>O_SYNC </b>and <b>O_DSYNC </b>in
       the <a href="open.2.html">open(2)</a> manual page for more information.

       The bits that may be set in <i>poll_events</i> are defined in <i>&lt;poll.h&gt;</i>,
       and documented in <a href="poll.2.html">poll(2)</a>.

       <i>user_data</i> is an application-supplied value that will be copied
       into the completion queue entry (see below).  <i>buf_index</i> is an
       index into an array of fixed buffers, and is only valid if fixed
       buffers were registered.  <i>personality</i> is the credentials id to
       use for this operation. See <a href="io_uring_register.2.html">io_uring_register(2)</a> for how to
       register personalities with io_uring. If set to 0, the current
       personality of the submitting task is used.

       Once the submission queue entry is initialized, I/O is submitted
       by placing the index of the submission queue entry into the tail
       of the submission queue.  After one or more indexes are added to
       the queue, and the queue tail is advanced, the <a href="io_uring_enter.2.html">io_uring_enter(2)</a>
       system call can be invoked to initiate the I/O.

       Completions use the following data structure:

           /*
            * IO completion data structure (Completion Queue Entry)
            */
           struct io_uring_cqe {
               __u64    user_data; /* sqe-&gt;data submission passed back */
               __s32    res;       /* result code for this event */
               __u32    flags;
           };

       <i>user_data</i> is copied from the field of the same name in the
       submission queue entry.  The primary use case is to store data
       that the application will need to access upon completion of this
       particular I/O.  The <i>flags</i> is used for certain commands, like
       <b>IORING_OP_POLL_ADD </b>or in conjunction with <b>IOSQE_BUFFER_SELECT </b>or
       <b>IORING_OP_MSG_RING, </b>, see those entries for details.  <i>res</i> is the
       operation-specific result, but io_uring-specific errors (e.g.
       flags or opcode invalid) are returned through this field.  They
       are described in section <b>CQE ERRORS.</b>

       For read and write opcodes, the return values match <i><a href="../man3/errno.3.html">errno</a></i> values
       documented in the <a href="preadv2.2.html">preadv2(2)</a> and <a href="pwritev2.2.html">pwritev2(2)</a> man pages, with <i>res</i>
       holding the equivalent of <i>-errno</i> for error cases, or the
       transferred number of bytes in case the operation is successful.
       Hence both error and success return can be found in that field in
       the CQE. For other request types, the return values are
       documented in the matching man page for that type, or in the
       opcodes section above for io_uring-specific opcodes.
</pre> <h2>
RETURN VALUE </h2>
<pre>
       <a href="io_uring_enter.2.html">io_uring_enter(2)</a> returns the number of I/Os successfully
       consumed.  This can be zero if <i>to_submit</i> was zero or if the
       submission queue was empty. Note that if the ring was created
       with <b>IORING_SETUP_SQPOLL </b>specified, then the return value will
       generally be the same as <i>to_submit</i> as submission happens outside
       the context of the system call.

       The errors related to a submission queue entry will be returned
       through a completion queue entry (see section <b>CQE ERRORS), </b>rather
       than through the system call itself.

       Errors that occur not on behalf of a submission queue entry are
       returned via the system call directly. On such an error, a
       negative error code is returned. The caller should not rely on
       <i><a href="../man3/errno.3.html">errno</a></i> variable.
</pre> <h2>
ERRORS </h2>
<pre>
       These are the errors returned by <a href="io_uring_enter.2.html">io_uring_enter(2)</a> system call.

       <b>EAGAIN </b>The kernel was unable to allocate memory for the request,
              or otherwise ran out of resources to handle it. The
              application should wait for some completions and try
              again.

       <b>EBADF  </b><i>fd</i> is not a valid file descriptor.

       <b>EBADFD </b><i>fd</i> is a valid file descriptor, but the io_uring ring is
              not in the right state (enabled). See <a href="io_uring_register.2.html">io_uring_register(2)</a>
              for details on how to enable the ring.

       <b>EBADR  </b>At least one CQE was dropped even with the
              <b>IORING_FEAT_NODROP </b>feature, and there are no otherwise
              available CQEs. This clears the error state and so with no
              other changes the next call to <a href="io_uring_enter.2.html">io_uring_enter(2)</a> will not
              have this error. This error should be extremely rare and
              indicates the machine is running critically low on memory.
              It may be reasonable for the application to terminate
              running unless it is able to safely handle any CQE being
              lost.

       <b>EBUSY  </b>If the <b>IORING_FEAT_NODROP </b>feature flag is set, then <b>EBUSY</b>
              will be returned if there were overflow entries,
              <b>IORING_ENTER_GETEVENTS </b>flag is set and not all of the
              overflow entries were able to be flushed to the CQ ring.

              Without <b>IORING_FEAT_NODROP </b>the application is attempting
              to overcommit the number of requests it can have pending.
              The application should wait for some completions and try
              again. May occur if the application tries to queue more
              requests than we have room for in the CQ ring, or if the
              application attempts to wait for more events without
              having reaped the ones already present in the CQ ring.

       <b>EEXIST </b>The thread submitting the work is invalid.

       <b>EINVAL </b>Some bits in the <i>flags</i> argument are invalid.

       <b>EFAULT </b>An invalid user space address was specified for the <i>sig</i>
              argument.

       <b>ENXIO  </b>The io_uring instance is in the process of being torn
              down.

       <b>EOPNOTSUPP</b>
              <i>fd</i> does not refer to an io_uring instance.

       <b>EINTR  </b>The operation was interrupted by a delivery of a signal
              before it could complete; see <a href="../man7/signal.7.html">signal(7)</a>.  Can happen while
              waiting for events with <b>IORING_ENTER_GETEVENTS.</b>
</pre> <h2>
CQE ERRORS </h2>
<pre>
       These io_uring-specific errors are returned as a negative value
       in the <i>res</i> field of the completion queue entry.

       <b>EACCES </b>The <i>flags</i> field or <i>opcode</i> in a submission queue entry is
              not allowed due to registered restrictions.  See
              <a href="io_uring_register.2.html">io_uring_register(2)</a> for details on how restrictions work.

       <b>EBADF  </b>The <i>fd</i> field in the submission queue entry is invalid, or
              the <b>IOSQE_FIXED_FILE </b>flag was set in the submission queue
              entry, but no files were registered with the io_uring
              instance.

       <b>EFAULT </b>buffer is outside of the process' accessible address space

       <b>EFAULT IORING_OP_READ_FIXED </b>or <b>IORING_OP_WRITE_FIXED </b>was
              specified in the <i>opcode</i> field of the submission queue
              entry, but either buffers were not registered for this
              io_uring instance, or the address range described by <i>addr</i>
              and <i>len</i> does not fit within the buffer registered at
              <i>buf_index</i>.

       <b>EINVAL </b>The <i>flags</i> field or <i>opcode</i> in a submission queue entry is
              invalid.

       <b>EINVAL </b>The <i>buf_index</i> member of the submission queue entry is
              invalid.

       <b>EINVAL </b>The <i>personality</i> field in a submission queue entry is
              invalid.

       <b>EINVAL IORING_OP_NOP </b>was specified in the submission queue entry,
              but the io_uring context was setup for polling
              (<b>IORING_SETUP_IOPOLL </b>was specified in the call to
              io_uring_setup).

       <b>EINVAL IORING_OP_READV </b>or <b>IORING_OP_WRITEV </b>was specified in the
              submission queue entry, but the io_uring instance has
              fixed buffers registered.

       <b>EINVAL IORING_OP_READ_FIXED </b>or <b>IORING_OP_WRITE_FIXED </b>was
              specified in the submission queue entry, and the <i>buf_index</i>
              is invalid.

       <b>EINVAL IORING_OP_READV</b>, <b>IORING_OP_WRITEV</b>, <b>IORING_OP_READ_FIXED</b>,
              <b>IORING_OP_WRITE_FIXED </b>or <b>IORING_OP_FSYNC </b>was specified in
              the submission queue entry, but the io_uring instance was
              configured for IOPOLLing, or any of <i>addr</i>, <i>ioprio</i>, <i>off</i>,
              <i>len</i>, or <i>buf_index</i> was set in the submission queue entry.

       <b>EINVAL IORING_OP_POLL_ADD </b>or <b>IORING_OP_POLL_REMOVE </b>was specified
              in the <i>opcode</i> field of the submission queue entry, but the
              io_uring instance was configured for busy-wait polling
              (<b>IORING_SETUP_IOPOLL</b>), or any of <i>ioprio</i>, <i>off</i>, <i>len</i>, or
              <i>buf_index</i> was non-zero in the submission queue entry.

       <b>EINVAL IORING_OP_POLL_ADD </b>was specified in the <i>opcode</i> field of
              the submission queue entry, and the <i>addr</i> field was non-
              zero.

       <b>EOPNOTSUPP</b>
              <i>opcode</i> is valid, but not supported by this kernel.

       <b>EOPNOTSUPP</b>
              <b>IOSQE_BUFFER_SELECT </b>was set in the <i>flags</i> field of the
              submission queue entry, but the <i>opcode</i> doesn't support
              buffer selection.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>liburing</i> (A library for io_uring)
       project.  Information about the project can be found at 
       âŸ¨<a href="https://github.com/axboe/liburing">https://github.com/axboe/liburing</a>âŸ©.  If you have a bug report for
       this manual page, send it to io-uring@vger.kernel.org.  This page
       was obtained from the project's upstream Git repository
       âŸ¨<a href="https://github.com/axboe/liburing">https://github.com/axboe/liburing</a>âŸ© on 2024-06-14.  (At that
       time, the date of the most recent commit that was found in the
       repository was 2024-06-03.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux                          2019-01-22              <i>io_uring_enter</i>(2)</span>
</pre>          <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man2/io_uring_enter2.2.html" class="_attribution-link">https://man7.org/linux/man-pages/man2/io_uring_enter2.2.html</a>
  </p>
</div>
