<h1>seccomp(2) â€” Linux manual page</h1>   <pre>
<span class="headline"><i>seccomp</i>(2)                 System Calls Manual                <i>seccomp</i>(2)</span>
</pre> <h2>
NAME </h2>
<pre>
       seccomp - operate on Secure Computing state of the process
</pre> <h2>
LIBRARY </h2>
<pre>
       Standard C library (<i>libc</i>, <i>-lc</i>)
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;linux/seccomp.h&gt;  </b>/* Definition of <b>SECCOMP_* </b>constants */
       <b>#include &lt;linux/filter.h&gt;   </b>/* Definition of <b>struct sock_fprog </b>*/
       <b>#include &lt;linux/audit.h&gt;    </b>/* Definition of <b>AUDIT_* </b>constants */
       <b>#include &lt;linux/signal.h&gt;   </b>/* Definition of <b>SIG* </b>constants */
       <b>#include &lt;sys/ptrace.h&gt;     </b>/* Definition of <b>PTRACE_* </b>constants */
       <b>#include &lt;sys/syscall.h&gt;    </b>/* Definition of <b>SYS_* </b>constants */
       <b>#include &lt;unistd.h&gt;</b>

       <b>int syscall(SYS_seccomp, unsigned int </b><i>operation</i><b>, unsigned int </b><i>flags</i><b>,</b>
                   <b>void *</b><i>args</i><b>);</b>

       <i>Note</i>: glibc provides no wrapper for <b>seccomp</b>(), necessitating the
       use of <a href="syscall.2.html">syscall(2)</a>.
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <b>seccomp</b>() system call operates on the Secure Computing
       (seccomp) state of the calling process.

       Currently, Linux supports the following <i>operation</i> values:

       <b>SECCOMP_SET_MODE_STRICT</b>
              The only system calls that the calling thread is permitted
              to make are <a href="read.2.html">read(2)</a>, <a href="write.2.html">write(2)</a>, <a href="_exit.2.html">_exit(2)</a> (but not
              <a href="exit_group.2.html">exit_group(2)</a>), and <a href="sigreturn.2.html">sigreturn(2)</a>.  Other system calls
              result in the termination of the calling thread, or
              termination of the entire process with the <b>SIGKILL </b>signal
              when there is only one thread.  Strict secure computing
              mode is useful for number-crunching applications that may
              need to execute untrusted byte code, perhaps obtained by
              reading from a pipe or socket.

              Note that although the calling thread can no longer call
              <a href="sigprocmask.2.html">sigprocmask(2)</a>, it can use <a href="sigreturn.2.html">sigreturn(2)</a> to block all
              signals apart from <b>SIGKILL </b>and <b>SIGSTOP</b>.  This means that
              <a href="alarm.2.html">alarm(2)</a> (for example) is not sufficient for restricting
              the process's execution time.  Instead, to reliably
              terminate the process, <b>SIGKILL </b>must be used.  This can be
              done by using <a href="timer_create.2.html">timer_create(2)</a> with <b>SIGEV_SIGNAL </b>and
              <i>sigev_signo</i> set to <b>SIGKILL</b>, or by using <a href="setrlimit.2.html">setrlimit(2)</a> to
              set the hard limit for <b>RLIMIT_CPU</b>.

              This operation is available only if the kernel is
              configured with <b>CONFIG_SECCOMP </b>enabled.

              The value of <i>flags</i> must be 0, and <i>args</i> must be NULL.

              This operation is functionally identical to the call:

                  prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);

       <b>SECCOMP_SET_MODE_FILTER</b>
              The system calls allowed are defined by a pointer to a
              Berkeley Packet Filter (BPF) passed via <i>args</i>.  This
              argument is a pointer to a <i>struct sock_fprog</i>; it can be
              designed to filter arbitrary system calls and system call
              arguments.  If the filter is invalid, <b>seccomp</b>() fails,
              returning <b>EINVAL </b>in <i><a href="../man3/errno.3.html">errno</a></i>.

              If <a href="fork.2.html">fork(2)</a> or <a href="clone.2.html">clone(2)</a> is allowed by the filter, any child
              processes will be constrained to the same system call
              filters as the parent.  If <a href="execve.2.html">execve(2)</a> is allowed, the
              existing filters will be preserved across a call to
              <a href="execve.2.html">execve(2)</a>.

              In order to use the <b>SECCOMP_SET_MODE_FILTER </b>operation,
              either the calling thread must have the <b>CAP_SYS_ADMIN</b>
              capability in its user namespace, or the thread must
              already have the <i>no_new_privs</i> bit set.  If that bit was
              not already set by an ancestor of this thread, the thread
              must make the following call:

                  prctl(PR_SET_NO_NEW_PRIVS, 1);

              Otherwise, the <b>SECCOMP_SET_MODE_FILTER </b>operation fails and
              returns <b>EACCES </b>in <i><a href="../man3/errno.3.html">errno</a></i>.  This requirement ensures that an
              unprivileged process cannot apply a malicious filter and
              then invoke a set-user-ID or other privileged program
              using <a href="execve.2.html">execve(2)</a>, thus potentially compromising that
              program.  (Such a malicious filter might, for example,
              cause an attempt to use <a href="setuid.2.html">setuid(2)</a> to set the caller's user
              IDs to nonzero values to instead return 0 without actually
              making the system call.  Thus, the program might be
              tricked into retaining superuser privileges in
              circumstances where it is possible to influence it to do
              dangerous things because it did not actually drop
              privileges.)

              If <a href="prctl.2.html">prctl(2)</a> or <b>seccomp</b>() is allowed by the attached
              filter, further filters may be added.  This will increase
              evaluation time, but allows for further reduction of the
              attack surface during execution of a thread.

              The <b>SECCOMP_SET_MODE_FILTER </b>operation is available only if
              the kernel is configured with <b>CONFIG_SECCOMP_FILTER</b>
              enabled.

              When <i>flags</i> is 0, this operation is functionally identical
              to the call:

                  prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);

              The recognized <i>flags</i> are:

              <b>SECCOMP_FILTER_FLAG_LOG </b>(since Linux 4.14)
                     All filter return actions except <b>SECCOMP_RET_ALLOW</b>
                     should be logged.  An administrator may override
                     this filter flag by preventing specific actions
                     from being logged via the
                     <i>/proc/sys/kernel/seccomp/actions_logged</i> file.

              <b>SECCOMP_FILTER_FLAG_NEW_LISTENER </b>(since Linux 5.0)
                     After successfully installing the filter program,
                     return a new user-space notification file
                     descriptor.  (The close-on-exec flag is set for the
                     file descriptor.)  When the filter returns
                     <b>SECCOMP_RET_USER_NOTIF </b>a notification will be sent
                     to this file descriptor.

                     At most one seccomp filter using the
                     <b>SECCOMP_FILTER_FLAG_NEW_LISTENER </b>flag can be
                     installed for a thread.

                     See <a href="seccomp_unotify.2.html">seccomp_unotify(2)</a> for further details.

              <b>SECCOMP_FILTER_FLAG_SPEC_ALLOW </b>(since Linux 4.17)
                     Disable Speculative Store Bypass mitigation.

              <b>SECCOMP_FILTER_FLAG_TSYNC</b>
                     When adding a new filter, synchronize all other
                     threads of the calling process to the same seccomp
                     filter tree.  A "filter tree" is the ordered list
                     of filters attached to a thread.  (Attaching
                     identical filters in separate <b>seccomp</b>() calls
                     results in different filters from this
                     perspective.)

                     If any thread cannot synchronize to the same filter
                     tree, the call will not attach the new seccomp
                     filter, and will fail, returning the first thread
                     ID found that cannot synchronize.  Synchronization
                     will fail if another thread in the same process is
                     in <b>SECCOMP_MODE_STRICT </b>or if it has attached new
                     seccomp filters to itself, diverging from the
                     calling thread's filter tree.

       <b>SECCOMP_GET_ACTION_AVAIL </b>(since Linux 4.14)
              Test to see if an action is supported by the kernel.  This
              operation is helpful to confirm that the kernel knows of a
              more recently added filter return action since the kernel
              treats all unknown actions as <b>SECCOMP_RET_KILL_PROCESS</b>.

              The value of <i>flags</i> must be 0, and <i>args</i> must be a pointer
              to an unsigned 32-bit filter return action.

       <b>SECCOMP_GET_NOTIF_SIZES </b>(since Linux 5.0)
              Get the sizes of the seccomp user-space notification
              structures.  Since these structures may evolve and grow
              over time, this command can be used to determine how much
              memory to allocate for sending and receiving
              notifications.

              The value of <i>flags</i> must be 0, and <i>args</i> must be a pointer
              to a <i>struct seccomp_notif_sizes</i>, which has the following
              form:

              struct seccomp_notif_sizes
                  __u16 seccomp_notif;      /* Size of notification structure */
                  __u16 seccomp_notif_resp; /* Size of response structure */
                  __u16 seccomp_data;       /* Size of 'struct seccomp_data' */
              };

              See <a href="seccomp_unotify.2.html">seccomp_unotify(2)</a> for further details.

   <b>Filters</b>
       When adding filters via <b>SECCOMP_SET_MODE_FILTER</b>, <i>args</i> points to a
       filter program:

           struct sock_fprog {
               unsigned short      len;    /* Number of BPF instructions */
               struct sock_filter *filter; /* Pointer to array of
                                              BPF instructions */
           };

       Each program must contain one or more BPF instructions:

           struct sock_filter {            /* Filter block */
               __u16 code;                 /* Actual filter code */
               __u8  jt;                   /* Jump true */
               __u8  jf;                   /* Jump false */
               __u32 k;                    /* Generic multiuse field */
           };

       When executing the instructions, the BPF program operates on the
       system call information made available (i.e., use the <b>BPF_ABS</b>
       addressing mode) as a (read-only) buffer of the following form:

           struct seccomp_data {
               int   nr;                   /* System call number */
               __u32 arch;                 /* AUDIT_ARCH_* value
                                              (see &lt;linux/audit.h&gt;) */
               __u64 instruction_pointer;  /* CPU instruction pointer */
               __u64 args[6];              /* Up to 6 system call arguments */
           };

       Because numbering of system calls varies between architectures
       and some architectures (e.g., x86-64) allow user-space code to
       use the calling conventions of multiple architectures (and the
       convention being used may vary over the life of a process that
       uses <a href="execve.2.html">execve(2)</a> to execute binaries that employ the different
       conventions), it is usually necessary to verify the value of the
       <i>arch</i> field.

       It is strongly recommended to use an allow-list approach whenever
       possible because such an approach is more robust and simple.  A
       deny-list will have to be updated whenever a potentially
       dangerous system call is added (or a dangerous flag or option if
       those are deny-listed), and it is often possible to alter the
       representation of a value without altering its meaning, leading
       to a deny-list bypass.  See also <i>Caveats</i> below.

       The <i>arch</i> field is not unique for all calling conventions.  The
       x86-64 ABI and the x32 ABI both use <b>AUDIT_ARCH_X86_64 </b>as <i>arch</i>,
       and they run on the same processors.  Instead, the mask
       <b>__X32_SYSCALL_BIT </b>is used on the system call number to tell the
       two ABIs apart.

       This means that a policy must either deny all syscalls with
       <b>__X32_SYSCALL_BIT </b>or it must recognize syscalls with and without
       <b>__X32_SYSCALL_BIT </b>set.  A list of system calls to be denied based
       on <i>nr</i> that does not also contain <i>nr</i> values with <b>__X32_SYSCALL_BIT</b>
       set can be bypassed by a malicious program that sets
       <b>__X32_SYSCALL_BIT</b>.

       Additionally, kernels prior to Linux 5.4 incorrectly permitted <i>nr</i>
       in the ranges 512-547 as well as the corresponding non-x32
       syscalls ORed with <b>__X32_SYSCALL_BIT</b>.  For example, <i>nr</i> == 521 and
       <i>nr</i> == (101 | <b>__X32_SYSCALL_BIT</b>) would result in invocations of
       <a href="ptrace.2.html">ptrace(2)</a> with potentially confused x32-vs-x86_64 semantics in
       the kernel.  Policies intended to work on kernels before Linux
       5.4 must ensure that they deny or otherwise correctly handle
       these system calls.  On Linux 5.4 and newer, such system calls
       will fail with the error <b>ENOSYS</b>, without doing anything.

       The <i>instruction_pointer</i> field provides the address of the
       machine-language instruction that performed the system call.
       This might be useful in conjunction with the use of
       <i>/proc/</i>pid<i>/maps</i> to perform checks based on which region (mapping)
       of the program made the system call.  (Probably, it is wise to
       lock down the <a href="mmap.2.html">mmap(2)</a> and <a href="mprotect.2.html">mprotect(2)</a> system calls to prevent the
       program from subverting such checks.)

       When checking values from <i>args</i>, keep in mind that arguments are
       often silently truncated before being processed, but after the
       seccomp check.  For example, this happens if the i386 ABI is used
       on an x86-64 kernel: although the kernel will normally not look
       beyond the 32 lowest bits of the arguments, the values of the
       full 64-bit registers will be present in the seccomp data.  A
       less surprising example is that if the x86-64 ABI is used to
       perform a system call that takes an argument of type <i>int</i>, the
       more-significant half of the argument register is ignored by the
       system call, but visible in the seccomp data.

       A seccomp filter returns a 32-bit value consisting of two parts:
       the most significant 16 bits (corresponding to the mask defined
       by the constant <b>SECCOMP_RET_ACTION_FULL</b>) contain one of the
       "action" values listed below; the least significant 16-bits
       (defined by the constant <b>SECCOMP_RET_DATA</b>) are "data" to be
       associated with this return value.

       If multiple filters exist, they are <i>all</i> executed, in reverse
       order of their addition to the filter treeâ€”that is, the most
       recently installed filter is executed first.  (Note that all
       filters will be called even if one of the earlier filters returns
       <b>SECCOMP_RET_KILL</b>.  This is done to simplify the kernel code and
       to provide a tiny speed-up in the execution of sets of filters by
       avoiding a check for this uncommon case.)  The return value for
       the evaluation of a given system call is the first-seen action
       value of highest precedence (along with its accompanying data)
       returned by execution of all of the filters.

       In decreasing order of precedence, the action values that may be
       returned by a seccomp filter are:

       <b>SECCOMP_RET_KILL_PROCESS </b>(since Linux 4.14)
              This value results in immediate termination of the
              process, with a core dump.  The system call is not
              executed.  By contrast with <b>SECCOMP_RET_KILL_THREAD </b>below,
              all threads in the thread group are terminated.  (For a
              discussion of thread groups, see the description of the
              <b>CLONE_THREAD </b>flag in <a href="clone.2.html">clone(2)</a>.)

              The process terminates <i>as though</i> killed by a <b>SIGSYS</b>
              signal.  Even if a signal handler has been registered for
              <b>SIGSYS</b>, the handler will be ignored in this case and the
              process always terminates.  To a parent process that is
              waiting on this process (using <a href="waitpid.2.html">waitpid(2)</a> or similar), the
              returned <i>wstatus</i> will indicate that its child was
              terminated as though by a <b>SIGSYS </b>signal.

       <b>SECCOMP_RET_KILL_THREAD </b>(or <b>SECCOMP_RET_KILL</b>)
              This value results in immediate termination of the thread
              that made the system call.  The system call is not
              executed.  Other threads in the same thread group will
              continue to execute.

              The thread terminates <i>as though</i> killed by a <b>SIGSYS </b>signal.
              See <b>SECCOMP_RET_KILL_PROCESS </b>above.

              Before Linux 4.11, any process terminated in this way
              would not trigger a coredump (even though <b>SIGSYS </b>is
              documented in <a href="../man7/signal.7.html">signal(7)</a> as having a default action of
              termination with a core dump).  Since Linux 4.11, a
              single-threaded process will dump core if terminated in
              this way.

              With the addition of <b>SECCOMP_RET_KILL_PROCESS </b>in Linux
              4.14, <b>SECCOMP_RET_KILL_THREAD </b>was added as a synonym for
              <b>SECCOMP_RET_KILL</b>, in order to more clearly distinguish the
              two actions.

              <b>Note</b>: the use of <b>SECCOMP_RET_KILL_THREAD </b>to kill a single
              thread in a multithreaded process is likely to leave the
              process in a permanently inconsistent and possibly corrupt
              state.

       <b>SECCOMP_RET_TRAP</b>
              This value results in the kernel sending a thread-directed
              <b>SIGSYS </b>signal to the triggering thread.  (The system call
              is not executed.)  Various fields will be set in the
              <i>siginfo_t</i> structure (see <a href="sigaction.2.html">sigaction(2)</a>) associated with
              signal:

              â€¢  <i>si_signo</i> will contain <b>SIGSYS</b>.

              â€¢  <i>si_call_addr</i> will show the address of the system call
                 instruction.

              â€¢  <i>si_syscall</i> and <i>si_arch</i> will indicate which system call
                 was attempted.

              â€¢  <i>si_code</i> will contain <b>SYS_SECCOMP</b>.

              â€¢  <i>si_errno</i> will contain the <b>SECCOMP_RET_DATA </b>portion of
                 the filter return value.

              The program counter will be as though the system call
              happened (i.e., the program counter will not point to the
              system call instruction).  The return value register will
              contain an architecture-dependent value; if resuming
              execution, set it to something appropriate for the system
              call.  (The architecture dependency is because replacing
              it with <b>ENOSYS </b>could overwrite some useful information.)

       <b>SECCOMP_RET_ERRNO</b>
              This value results in the <b>SECCOMP_RET_DATA </b>portion of the
              filter's return value being passed to user space as the
              <i><a href="../man3/errno.3.html">errno</a></i> value without executing the system call.

       <b>SECCOMP_RET_USER_NOTIF </b>(since Linux 5.0)
              Forward the system call to an attached user-space
              supervisor process to allow that process to decide what to
              do with the system call.  If there is no attached
              supervisor (either because the filter was not installed
              with the <b>SECCOMP_FILTER_FLAG_NEW_LISTENER </b>flag or because
              the file descriptor was closed), the filter returns <b>ENOSYS</b>
              (similar to what happens when a filter returns
              <b>SECCOMP_RET_TRACE </b>and there is no tracer).  See
              <a href="seccomp_unotify.2.html">seccomp_unotify(2)</a> for further details.

              Note that the supervisor process will not be notified if
              another filter returns an action value with a precedence
              greater than <b>SECCOMP_RET_USER_NOTIF</b>.

       <b>SECCOMP_RET_TRACE</b>
              When returned, this value will cause the kernel to attempt
              to notify a <a href="ptrace.2.html">ptrace(2)</a>-based tracer prior to executing the
              system call.  If there is no tracer present, the system
              call is not executed and returns a failure status with
              <i><a href="../man3/errno.3.html">errno</a></i> set to <b>ENOSYS</b>.

              A tracer will be notified if it requests
              <b>PTRACE_O_TRACESECCOMP </b>using <i>ptrace(PTRACE_SETOPTIONS)</i>.
              The tracer will be notified of a <b>PTRACE_EVENT_SECCOMP </b>and
              the <b>SECCOMP_RET_DATA </b>portion of the filter's return value
              will be available to the tracer via <b>PTRACE_GETEVENTMSG</b>.

              The tracer can skip the system call by changing the system
              call number to -1.  Alternatively, the tracer can change
              the system call requested by changing the system call to a
              valid system call number.  If the tracer asks to skip the
              system call, then the system call will appear to return
              the value that the tracer puts in the return value
              register.

              Before Linux 4.8, the seccomp check will not be run again
              after the tracer is notified.  (This means that, on older
              kernels, seccomp-based sandboxes <b>must not </b>allow use of
              <a href="ptrace.2.html">ptrace(2)</a>â€”even of other sandboxed processesâ€”without
              extreme care; ptracers can use this mechanism to escape
              from the seccomp sandbox.)

              Note that a tracer process will not be notified if another
              filter returns an action value with a precedence greater
              than <b>SECCOMP_RET_TRACE</b>.

       <b>SECCOMP_RET_LOG </b>(since Linux 4.14)
              This value results in the system call being executed after
              the filter return action is logged.  An administrator may
              override the logging of this action via the
              <i>/proc/sys/kernel/seccomp/actions_logged</i> file.

       <b>SECCOMP_RET_ALLOW</b>
              This value results in the system call being executed.

       If an action value other than one of the above is specified, then
       the filter action is treated as either <b>SECCOMP_RET_KILL_PROCESS</b>
       (since Linux 4.14) or <b>SECCOMP_RET_KILL_THREAD </b>(in Linux 4.13 and
       earlier).

   <b>/proc interfaces</b>
       The files in the directory <i>/proc/sys/kernel/seccomp</i> provide
       additional seccomp information and configuration:

       <i>actions_avail</i> (since Linux 4.14)
              A read-only ordered list of seccomp filter return actions
              in string form.  The ordering, from left-to-right, is in
              decreasing order of precedence.  The list represents the
              set of seccomp filter return actions supported by the
              kernel.

       <i>actions_logged</i> (since Linux 4.14)
              A read-write ordered list of seccomp filter return actions
              that are allowed to be logged.  Writes to the file do not
              need to be in ordered form but reads from the file will be
              ordered in the same way as the <i>actions_avail</i> file.

              It is important to note that the value of <i>actions_logged</i>
              does not prevent certain filter return actions from being
              logged when the audit subsystem is configured to audit a
              task.  If the action is not found in the <i>actions_logged</i>
              file, the final decision on whether to audit the action
              for that task is ultimately left up to the audit subsystem
              to decide for all filter return actions other than
              <b>SECCOMP_RET_ALLOW</b>.

              The "allow" string is not accepted in the <i>actions_logged</i>
              file as it is not possible to log <b>SECCOMP_RET_ALLOW</b>
              actions.  Attempting to write "allow" to the file will
              fail with the error <b>EINVAL</b>.

   <b>Audit logging of seccomp actions</b>
       Since Linux 4.14, the kernel provides the facility to log the
       actions returned by seccomp filters in the audit log.  The kernel
       makes the decision to log an action based on the action type,
       whether or not the action is present in the <i>actions_logged</i> file,
       and whether kernel auditing is enabled (e.g., via the kernel boot
       option <i>audit=1</i>).  The rules are as follows:

       â€¢  If the action is <b>SECCOMP_RET_ALLOW</b>, the action is not logged.

       â€¢  Otherwise, if the action is either <b>SECCOMP_RET_KILL_PROCESS </b>or
          <b>SECCOMP_RET_KILL_THREAD</b>, and that action appears in the
          <i>actions_logged</i> file, the action is logged.

       â€¢  Otherwise, if the filter has requested logging (the
          <b>SECCOMP_FILTER_FLAG_LOG </b>flag) and the action appears in the
          <i>actions_logged</i> file, the action is logged.

       â€¢  Otherwise, if kernel auditing is enabled and the process is
          being audited (<b>autrace</b>(8)), the action is logged.

       â€¢  Otherwise, the action is not logged.
</pre> <h2>
RETURN VALUE </h2>
<pre>
       On success, <b>seccomp</b>() returns 0.  On error, if
       <b>SECCOMP_FILTER_FLAG_TSYNC </b>was used, the return value is the ID of
       the thread that caused the synchronization failure.  (This ID is
       a kernel thread ID of the type returned by <a href="clone.2.html">clone(2)</a> and
       <a href="gettid.2.html">gettid(2)</a>.)  On other errors, -1 is returned, and <i><a href="../man3/errno.3.html">errno</a></i> is set to
       indicate the error.
</pre> <h2>
ERRORS </h2>
<pre>
       <b>seccomp</b>() can fail for the following reasons:

       <b>EACCES </b>The caller did not have the <b>CAP_SYS_ADMIN </b>capability in
              its user namespace, or had not set <i>no_new_privs</i> before
              using <b>SECCOMP_SET_MODE_FILTER</b>.

       <b>EBUSY  </b>While installing a new filter, the
              <b>SECCOMP_FILTER_FLAG_NEW_LISTENER </b>flag was specified, but a
              previous filter had already been installed with that flag.

       <b>EFAULT </b><i>args</i> was not a valid address.

       <b>EINVAL </b><i>operation</i> is unknown or is not supported by this kernel
              version or configuration.

       <b>EINVAL </b>The specified <i>flags</i> are invalid for the given <i>operation</i>.

       <b>EINVAL </b><i>operation</i> included <b>BPF_ABS</b>, but the specified offset was
              not aligned to a 32-bit boundary or exceeded
              <i>sizeof(struct seccomp_data)</i>.

       <b>EINVAL </b>A secure computing mode has already been set, and
              <i>operation</i> differs from the existing setting.

       <b>EINVAL </b><i>operation</i> specified <b>SECCOMP_SET_MODE_FILTER</b>, but the
              filter program pointed to by <i>args</i> was not valid or the
              length of the filter program was zero or exceeded
              <b>BPF_MAXINSNS </b>(4096) instructions.

       <b>ENOMEM </b>Out of memory.

       <b>ENOMEM </b>The total length of all filter programs attached to the
              calling thread would exceed <b>MAX_INSNS_PER_PATH </b>(32768)
              instructions.  Note that for the purposes of calculating
              this limit, each already existing filter program incurs an
              overhead penalty of 4 instructions.

       <b>EOPNOTSUPP</b>
              <i>operation</i> specified <b>SECCOMP_GET_ACTION_AVAIL</b>, but the
              kernel does not support the filter return action specified
              by <i>args</i>.

       <b>ESRCH  </b>Another thread caused a failure during thread sync, but
              its ID could not be determined.
</pre> <h2>
STANDARDS </h2>
<pre>
       Linux.
</pre> <h2>
HISTORY </h2>
<pre>
       Linux 3.17.
</pre> <h2>
NOTES </h2>
<pre>
       Rather than hand-coding seccomp filters as shown in the example
       below, you may prefer to employ the <i>libseccomp</i> library, which
       provides a front-end for generating seccomp filters.

       The <i>Seccomp</i> field of the <i>/proc/</i>pid<i>/status</i> file provides a method
       of viewing the seccomp mode of a process; see <a href="../man5/proc.5.html">proc(5)</a>.

       <b>seccomp</b>() provides a superset of the functionality provided by
       the <a href="prctl.2.html">prctl(2)</a> <b>PR_SET_SECCOMP </b>operation (which does not support
       <i>flags</i>).

       Since Linux 4.4, the <a href="ptrace.2.html">ptrace(2)</a> <b>PTRACE_SECCOMP_GET_FILTER</b>
       operation can be used to dump a process's seccomp filters.

   <b>Architecture support for seccomp BPF</b>
       Architecture support for seccomp BPF filtering is available on
       the following architectures:

       â€¢  x86-64, i386, x32 (since Linux 3.5)
       â€¢  ARM (since Linux 3.8)
       â€¢  s390 (since Linux 3.8)
       â€¢  MIPS (since Linux 3.16)
       â€¢  ARM-64 (since Linux 3.19)
       â€¢  PowerPC (since Linux 4.3)
       â€¢  Tile (since Linux 4.3)
       â€¢  PA-RISC (since Linux 4.6)

   <b>Caveats</b>
       There are various subtleties to consider when applying seccomp
       filters to a program, including the following:

       â€¢  Some traditional system calls have user-space implementations
          in the <a href="../man7/vdso.7.html">vdso(7)</a> on many architectures.  Notable examples
          include <a href="clock_gettime.2.html">clock_gettime(2)</a>, <a href="gettimeofday.2.html">gettimeofday(2)</a>, and <a href="time.2.html">time(2)</a>.  On
          such architectures, seccomp filtering for these system calls
          will have no effect.  (However, there are cases where the
          <a href="../man7/vdso.7.html">vdso(7)</a> implementations may fall back to invoking the true
          system call, in which case seccomp filters would see the
          system call.)

       â€¢  Seccomp filtering is based on system call numbers.  However,
          applications typically do not directly invoke system calls,
          but instead call wrapper functions in the C library which in
          turn invoke the system calls.  Consequently, one must be aware
          of the following:

          â€¢  The glibc wrappers for some traditional system calls may
             actually employ system calls with different names in the
             kernel.  For example, the <a href="exit.2.html">exit(2)</a> wrapper function actually
             employs the <a href="exit_group.2.html">exit_group(2)</a> system call, and the <a href="fork.2.html">fork(2)</a>
             wrapper function actually calls <a href="clone.2.html">clone(2)</a>.

          â€¢  The behavior of wrapper functions may vary across
             architectures, according to the range of system calls
             provided on those architectures.  In other words, the same
             wrapper function may invoke different system calls on
             different architectures.

          â€¢  Finally, the behavior of wrapper functions can change
             across glibc versions.  For example, in older versions, the
             glibc wrapper function for <a href="open.2.html">open(2)</a> invoked the system call
             of the same name, but starting in glibc 2.26, the
             implementation switched to calling <a href="openat.2.html">openat(2)</a> on all
             architectures.

       The consequence of the above points is that it may be necessary
       to filter for a system call other than might be expected.
       Various manual pages in Section 2 provide helpful details about
       the differences between wrapper functions and the underlying
       system calls in subsections entitled <i>C library/kernel</i>
       <i>differences</i>.

       Furthermore, note that the application of seccomp filters even
       risks causing bugs in an application, when the filters cause
       unexpected failures for legitimate operations that the
       application might need to perform.  Such bugs may not easily be
       discovered when testing the seccomp filters if the bugs occur in
       rarely used application code paths.

   <b>Seccomp-specific BPF details</b>
       Note the following BPF details specific to seccomp filters:

       â€¢  The <b>BPF_H </b>and <b>BPF_B </b>size modifiers are not supported: all
          operations must load and store (4-byte) words (<b>BPF_W</b>).

       â€¢  To access the contents of the <i>seccomp_data</i> buffer, use the
          <b>BPF_ABS </b>addressing mode modifier.

       â€¢  The <b>BPF_LEN </b>addressing mode modifier yields an immediate mode
          operand whose value is the size of the <i>seccomp_data</i> buffer.
</pre> <h2>
EXAMPLES </h2>
<pre>
       The program below accepts four or more arguments.  The first
       three arguments are a system call number, a numeric architecture
       identifier, and an error number.  The program uses these values
       to construct a BPF filter that is used at run time to perform the
       following checks:

       â€¢  If the program is not running on the specified architecture,
          the BPF filter causes system calls to fail with the error
          <b>ENOSYS</b>.

       â€¢  If the program attempts to execute the system call with the
          specified number, the BPF filter causes the system call to
          fail, with <i><a href="../man3/errno.3.html">errno</a></i> being set to the specified error number.

       The remaining command-line arguments specify the pathname and
       additional arguments of a program that the example program should
       attempt to execute using <a href="../man3/execv.3.html">execv(3)</a> (a library function that
       employs the <a href="execve.2.html">execve(2)</a> system call).  Some example runs of the
       program are shown below.

       First, we display the architecture that we are running on
       (x86-64) and then construct a shell function that looks up system
       call numbers on this architecture:

           $ <b>uname -m</b>
           x86_64
           $ <b>syscall_nr() {</b>
               <b>cat /usr/src/linux/arch/x86/syscalls/syscall_64.tbl | \</b>
               <b>awk '$2 != "x32" &amp;&amp; $3 == "'$1'" { print $1 }'</b>
           <b>}</b>

       When the BPF filter rejects a system call (case [2] above), it
       causes the system call to fail with the error number specified on
       the command line.  In the experiments shown here, we'll use error
       number 99:

           $ <b>errno 99</b>
           EADDRNOTAVAIL 99 Cannot assign requested address

       In the following example, we attempt to run the command
       <a href="../man1/whoami.1.html">whoami(1)</a>, but the BPF filter rejects the <a href="execve.2.html">execve(2)</a> system call,
       so that the command is not even executed:

           $ <b>syscall_nr execve</b>
           59
           $ <b>./a.out</b>
           Usage: ./a.out &lt;syscall_nr&gt; &lt;arch&gt; &lt;errno&gt; &lt;prog&gt; [&lt;args&gt;]
           Hint for &lt;arch&gt;: AUDIT_ARCH_I386: 0x40000003
                            AUDIT_ARCH_X86_64: 0xC000003E
           $ <b>./a.out 59 0xC000003E 99 /bin/whoami</b>
           execv: Cannot assign requested address

       In the next example, the BPF filter rejects the <a href="write.2.html">write(2)</a> system
       call, so that, although it is successfully started, the <a href="../man1/whoami.1.html">whoami(1)</a>
       command is not able to write output:

           $ <b>syscall_nr write</b>
           1
           $ <b>./a.out 1 0xC000003E 99 /bin/whoami</b>

       In the final example, the BPF filter rejects a system call that
       is not used by the <a href="../man1/whoami.1.html">whoami(1)</a> command, so it is able to
       successfully execute and produce output:

           $ <b>syscall_nr preadv</b>
           295
           $ <b>./a.out 295 0xC000003E 99 /bin/whoami</b>
           cecilia

   <b>Program source</b>
       #include &lt;linux/audit.h&gt;
       #include &lt;linux/filter.h&gt;
       #include &lt;linux/seccomp.h&gt;
       #include &lt;stddef.h&gt;
       #include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;sys/prctl.h&gt;
       #include &lt;sys/syscall.h&gt;
       #include &lt;unistd.h&gt;

       #define X32_SYSCALL_BIT 0x40000000
       #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

       static int
       install_filter(int syscall_nr, unsigned int t_arch, int f_errno)
       {
           unsigned int upper_nr_limit = 0xffffffff;

           /* Assume that AUDIT_ARCH_X86_64 means the normal x86-64 ABI
              (in the x32 ABI, all system calls have bit 30 set in the
              'nr' field, meaning the numbers are &gt;= X32_SYSCALL_BIT). */
           if (t_arch == AUDIT_ARCH_X86_64)
               upper_nr_limit = X32_SYSCALL_BIT - 1;

           struct sock_filter filter[] = {
               /* [0] Load architecture from 'seccomp_data' buffer into
                      accumulator. */
               BPF_STMT(BPF_LD | BPF_W | BPF_ABS,
                        (offsetof(struct seccomp_data, arch))),

               /* [1] Jump forward 5 instructions if architecture does not
                      match 't_arch'. */
               BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, 0, 5),

               /* [2] Load system call number from 'seccomp_data' buffer into
                      accumulator. */
               BPF_STMT(BPF_LD | BPF_W | BPF_ABS,
                        (offsetof(struct seccomp_data, nr))),

               /* [3] Check ABI - only needed for x86-64 in deny-list use
                      cases.  Use BPF_JGT instead of checking against the bit
                      mask to avoid having to reload the syscall number. */
               BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3, 0),

               /* [4] Jump forward 1 instruction if system call number
                      does not match 'syscall_nr'. */
               BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, 0, 1),

               /* [5] Matching architecture and system call: don't execute
                  the system call, and return 'f_errno' in 'errno'. */
               BPF_STMT(BPF_RET | BPF_K,
                        SECCOMP_RET_ERRNO | (f_errno &amp; SECCOMP_RET_DATA)),

               /* [6] Destination of system call number mismatch: allow other
                      system calls. */
               BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),

               /* [7] Destination of architecture mismatch: kill process. */
               BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),
           };

           struct sock_fprog prog = {
               .len = ARRAY_SIZE(filter),
               .filter = filter,
           };

           if (syscall(SYS_seccomp, SECCOMP_SET_MODE_FILTER, 0, &amp;prog)) {
               perror("seccomp");
               return 1;
           }

           return 0;
       }

       int
       main(int argc, char *argv[])
       {
           if (argc &lt; 5) {
               fprintf(stderr, "Usage: "
                       "%s &lt;syscall_nr&gt; &lt;arch&gt; &lt;errno&gt; &lt;prog&gt; [&lt;args&gt;]\n"
                       "Hint for &lt;arch&gt;: AUDIT_ARCH_I386: 0x%X\n"
                       "                 AUDIT_ARCH_X86_64: 0x%X\n"
                       "\n", argv[0], AUDIT_ARCH_I386, AUDIT_ARCH_X86_64);
               exit(EXIT_FAILURE);
           }

           if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
               perror("prctl");
               exit(EXIT_FAILURE);
           }

           if (install_filter(strtol(argv[1], NULL, 0),
                              strtoul(argv[2], NULL, 0),
                              strtol(argv[3], NULL, 0)))
               exit(EXIT_FAILURE);

           execv(argv[4], &amp;argv[4]);
           perror("execv");
           exit(EXIT_FAILURE);
       }
</pre> <h2>
SEE ALSO </h2>
<pre>
       <b>bpfc</b>(1), <a href="../man1/strace.1.html">strace(1)</a>, <a href="bpf.2.html">bpf(2)</a>, <a href="prctl.2.html">prctl(2)</a>, <a href="ptrace.2.html">ptrace(2)</a>,
       <a href="seccomp_unotify.2.html">seccomp_unotify(2)</a>, <a href="sigaction.2.html">sigaction(2)</a>, <a href="../man5/proc.5.html">proc(5)</a>, <a href="../man7/signal.7.html">signal(7)</a>, <a href="../man7/socket.7.html">socket(7)</a>

       Various pages from the <i>libseccomp</i> library, including:
       <a href="../man1/scmp_sys_resolver.1.html">scmp_sys_resolver(1)</a>, <a href="../man3/seccomp_export_bpf.3.html">seccomp_export_bpf(3)</a>, <a href="../man3/seccomp_init.3.html">seccomp_init(3)</a>,
       <a href="../man3/seccomp_load.3.html">seccomp_load(3)</a>, and <a href="../man3/seccomp_rule_add.3.html">seccomp_rule_add(3)</a>.

       The kernel source files <i>Documentation/networking/filter.txt</i> and
       <i>Documentation/userspace-api/seccomp_filter.rst</i> (or
       <i>Documentation/prctl/seccomp_filter.txt</i> before Linux 4.13).

       McCanne, S. and Jacobson, V. (1992) <i>The BSD Packet Filter: A New</i>
       <i>Architecture for User-level Packet Capture</i>, Proceedings of the
       USENIX Winter 1993 Conference 
       âŸ¨<a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf">http://www.tcpdump.org/papers/bpf-usenix93.pdf</a>âŸ©
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       âŸ¨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>âŸ©.  If you have a bug report
       for this manual page, see
       âŸ¨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>âŸ©.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       âŸ¨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>âŸ© on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-06-15                     <i>seccomp</i>(2)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/man.1.html">man(1)</a>, <a href="../man1/strace.1.html">strace(1)</a>, <a href="bpf.2.html">bpf(2)</a>, <a href="close_range.2.html">close_range(2)</a>, <a href="landlock_restrict_self.2.html">landlock_restrict_self(2)</a>, <a href="pr_get_seccomp.2const.html">PR_GET_SECCOMP(2const)</a>, <a href="pr_set_no_new_privs.2const.html">PR_SET_NO_NEW_PRIVS(2const)</a>, <a href="pr_set_seccomp.2const.html">PR_SET_SECCOMP(2const)</a>, <a href="ptrace.2.html">ptrace(2)</a>, <a href="seccomp_unotify.2.html">seccomp_unotify(2)</a>, <a href="sigaction.2.html">sigaction(2)</a>, <a href="socketcall.2.html">socketcall(2)</a>, <a href="syscalls.2.html">syscalls(2)</a>, <a href="../man3/seccomp_api_get.3.html">seccomp_api_get(3)</a>, <a href="../man3/seccomp_attr_set.3.html">seccomp_attr_set(3)</a>, <a href="../man5/proc_pid_seccomp.5.html">proc_pid_seccomp(5)</a>, <a href="../man5/proc_pid_status.5.html">proc_pid_status(5)</a>, <a href="../man5/proc_sys_kernel.5.html">proc_sys_kernel(5)</a>, <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>, <a href="../man7/capabilities.7.html">capabilities(7)</a>, <a href="../man7/landlock.7.html">landlock(7)</a>, <a href="../man7/signal.7.html">signal(7)</a>, <a href="../man7/vdso.7.html">vdso(7)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man2/seccomp.2.html" class="_attribution-link">https://man7.org/linux/man-pages/man2/seccomp.2.html</a>
  </p>
</div>
