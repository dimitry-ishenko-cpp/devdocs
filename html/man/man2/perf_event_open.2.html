<h1>perf_event_open(2) — Linux manual page</h1>   <pre>
<span class="headline"><i>perf_event_open</i>(2)         System Calls Manual        <i>perf_event_open</i>(2)</span>
</pre> <h2>
NAME </h2>
<pre>
       perf_event_open - set up performance monitoring
</pre> <h2>
LIBRARY </h2>
<pre>
       Standard C library (<i>libc</i>, <i>-lc</i>)
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;linux/perf_event.h&gt;    </b>/* Definition of <b>PERF_* </b>constants */
       <b>#include &lt;linux/hw_breakpoint.h&gt; </b>/* Definition of <b>HW_* </b>constants */
       <b>#include &lt;sys/syscall.h&gt;         </b>/* Definition of <b>SYS_* </b>constants */
       <b>#include &lt;unistd.h&gt;</b>

       <b>int syscall(SYS_perf_event_open, struct perf_event_attr *</b><i>attr</i><b>,</b>
                   <b>pid_t </b><i>pid</i><b>, int </b><i>cpu</i><b>, int </b><i>group_fd</i><b>, unsigned long </b><i>flags</i><b>);</b>

       <i>Note</i>: glibc provides no wrapper for <b>perf_event_open</b>(),
       necessitating the use of <a href="syscall.2.html">syscall(2)</a>.
</pre> <h2>
DESCRIPTION </h2>
<pre>
       Given a list of parameters, <b>perf_event_open</b>() returns a file
       descriptor, for use in subsequent system calls (<a href="read.2.html">read(2)</a>, <a href="mmap.2.html">mmap(2)</a>,
       <a href="prctl.2.html">prctl(2)</a>, <a href="fcntl.2.html">fcntl(2)</a>, etc.).

       A call to <b>perf_event_open</b>() creates a file descriptor that allows
       measuring performance information.  Each file descriptor
       corresponds to one event that is measured; these can be grouped
       together to measure multiple events simultaneously.

       Events can be enabled and disabled in two ways: via <a href="ioctl.2.html">ioctl(2)</a> and
       via <a href="prctl.2.html">prctl(2)</a>.  When an event is disabled it does not count or
       generate overflows but does continue to exist and maintain its
       count value.

       Events come in two flavors: counting and sampled.  A <i>counting</i>
       event is one that is used for counting the aggregate number of
       events that occur.  In general, counting event results are
       gathered with a <a href="read.2.html">read(2)</a> call.  A <i>sampling</i> event periodically
       writes measurements to a buffer that can then be accessed via
       <a href="mmap.2.html">mmap(2)</a>.

   <b>Arguments</b>
       The <i>pid</i> and <i>cpu</i> arguments allow specifying which process and CPU
       to monitor:

       <b>pid == 0 </b>and <b>cpu == -1</b>
              This measures the calling process/thread on any CPU.

       <b>pid == 0 </b>and <b>cpu &gt;= 0</b>
              This measures the calling process/thread only when running
              on the specified CPU.

       <b>pid &gt; 0 </b>and <b>cpu == -1</b>
              This measures the specified process/thread on any CPU.

       <b>pid &gt; 0 </b>and <b>cpu &gt;= 0</b>
              This measures the specified process/thread only when
              running on the specified CPU.

       <b>pid == -1 </b>and <b>cpu &gt;= 0</b>
              This measures all processes/threads on the specified CPU.
              This requires <b>CAP_PERFMON </b>(since Linux 5.8) or
              <b>CAP_SYS_ADMIN </b>capability or a
              <i>/proc/sys/kernel/perf_event_paranoid</i> value of less than 1.

       <b>pid == -1 </b>and <b>cpu == -1</b>
              This setting is invalid and will return an error.

       When <i>pid</i> is greater than zero, permission to perform this system
       call is governed by <b>CAP_PERFMON </b>(since Linux 5.9) and a ptrace
       access mode <b>PTRACE_MODE_READ_REALCREDS </b>check on older Linux
       versions; see <a href="ptrace.2.html">ptrace(2)</a>.

       The <i>group_fd</i> argument allows event groups to be created.  An
       event group has one event which is the group leader.  The leader
       is created first, with <i>group_fd</i> = -1.  The rest of the group
       members are created with subsequent <b>perf_event_open</b>() calls with
       <i>group_fd</i> being set to the file descriptor of the group leader.
       (A single event on its own is created with <i>group_fd</i> = -1 and is
       considered to be a group with only 1 member.)  An event group is
       scheduled onto the CPU as a unit: it will be put onto the CPU
       only if all of the events in the group can be put onto the CPU.
       This means that the values of the member events can be
       meaningfully compared —added, divided (to get ratios), and so on—
       with each other, since they have counted events for the same set
       of executed instructions.

       The <i>flags</i> argument is formed by ORing together zero or more of
       the following values:

       <b>PERF_FLAG_FD_CLOEXEC </b>(since Linux 3.14)
              This flag enables the close-on-exec flag for the created
              event file descriptor, so that the file descriptor is
              automatically closed on <a href="execve.2.html">execve(2)</a>.  Setting the close-on-
              exec flags at creation time, rather than later with
              <a href="fcntl.2.html">fcntl(2)</a>, avoids potential race conditions where the
              calling thread invokes <b>perf_event_open</b>() and <a href="fcntl.2.html">fcntl(2)</a> at
              the same time as another thread calls <a href="fork.2.html">fork(2)</a> then
              <a href="execve.2.html">execve(2)</a>.

       <b>PERF_FLAG_FD_NO_GROUP</b>
              This flag tells the event to ignore the <i>group_fd</i> parameter
              except for the purpose of setting up output redirection
              using the <b>PERF_FLAG_FD_OUTPUT </b>flag.

       <b>PERF_FLAG_FD_OUTPUT </b>(broken since Linux 2.6.35)
              This flag re-routes the event's sampled output to instead
              be included in the mmap buffer of the event specified by
              <i>group_fd</i>.

       <b>PERF_FLAG_PID_CGROUP </b>(since Linux 2.6.39)
              This flag activates per-container system-wide monitoring.
              A container is an abstraction that isolates a set of
              resources for finer-grained control (CPUs, memory, etc.).
              In this mode, the event is measured only if the thread
              running on the monitored CPU belongs to the designated
              container (cgroup).  The cgroup is identified by passing a
              file descriptor opened on its directory in the cgroupfs
              filesystem.  For instance, if the cgroup to monitor is
              called <i>test</i>, then a file descriptor opened on
              <i>/dev/cgroup/test</i> (assuming cgroupfs is mounted on
              <i>/dev/cgroup</i>) must be passed as the <i>pid</i> parameter.  cgroup
              monitoring is available only for system-wide events and
              may therefore require extra permissions.

       The <i>perf_event_attr</i> structure provides detailed configuration
       information for the event being created.

           struct perf_event_attr {
               __u32 type;                 /* Type of event */
               __u32 size;                 /* Size of attribute structure */
               __u64 config;               /* Type-specific configuration */

               union {
                   __u64 sample_period;    /* Period of sampling */
                   __u64 sample_freq;      /* Frequency of sampling */
               };

               __u64 sample_type;  /* Specifies values included in sample */
               __u64 read_format;  /* Specifies values returned in read */

               __u64 disabled       : 1,   /* off by default */
                     inherit        : 1,   /* children inherit it */
                     pinned         : 1,   /* must always be on PMU */
                     exclusive      : 1,   /* only group on PMU */
                     exclude_user   : 1,   /* don't count user */
                     exclude_kernel : 1,   /* don't count kernel */
                     exclude_hv     : 1,   /* don't count hypervisor */
                     exclude_idle   : 1,   /* don't count when idle */
                     mmap           : 1,   /* include mmap data */
                     comm           : 1,   /* include comm data */
                     freq           : 1,   /* use freq, not period */
                     inherit_stat   : 1,   /* per task counts */
                     enable_on_exec : 1,   /* next exec enables */
                     task           : 1,   /* trace fork/exit */
                     watermark      : 1,   /* wakeup_watermark */
                     precise_ip     : 2,   /* skid constraint */
                     mmap_data      : 1,   /* non-exec mmap data */
                     sample_id_all  : 1,   /* sample_type all events */
                     exclude_host   : 1,   /* don't count in host */
                     exclude_guest  : 1,   /* don't count in guest */
                     exclude_callchain_kernel : 1,
                                           /* exclude kernel callchains */
                     exclude_callchain_user   : 1,
                                           /* exclude user callchains */
                     mmap2          :  1,  /* include mmap with inode data */
                     comm_exec      :  1,  /* flag comm events that are
                                              due to exec */
                     use_clockid    :  1,  /* use clockid for time fields */
                     context_switch :  1,  /* context switch data */
                     write_backward :  1,  /* Write ring buffer from end
                                              to beginning */
                     namespaces     :  1,  /* include namespaces data */
                     ksymbol        :  1,  /* include ksymbol events */
                     bpf_event      :  1,  /* include bpf events */
                     aux_output     :  1,  /* generate AUX records
                                              instead of events */
                     cgroup         :  1,  /* include cgroup events */
                     text_poke      :  1,  /* include text poke events */
                     build_id       :  1,  /* use build id in mmap2 events */
                     inherit_thread :  1,  /* children only inherit */
                                           /* if cloned with CLONE_THREAD */
                     remove_on_exec :  1,  /* event is removed from task
                                              on exec */
                     sigtrap        :  1,  /* send synchronous SIGTRAP
                                              on event */

                     __reserved_1   : 26;

               union {
                   __u32 wakeup_events;    /* wakeup every n events */
                   __u32 wakeup_watermark; /* bytes before wakeup */
               };

               __u32     bp_type;          /* breakpoint type */

               union {
                   __u64 bp_addr;          /* breakpoint address */
                   __u64 kprobe_func;      /* for perf_kprobe */
                   __u64 uprobe_path;      /* for perf_uprobe */
                   __u64 config1;          /* extension of config */
               };

               union {
                   __u64 bp_len;           /* breakpoint length */
                   __u64 kprobe_addr;      /* with kprobe_func == NULL */
                   __u64 probe_offset;     /* for perf_[k,u]probe */
                   __u64 config2;          /* extension of config1 */
               };
               __u64 branch_sample_type;   /* enum perf_branch_sample_type */
               __u64 sample_regs_user;     /* user regs to dump on samples */
               __u32 sample_stack_user;    /* size of stack to dump on
                                              samples */
               __s32 clockid;              /* clock to use for time fields */
               __u64 sample_regs_intr;     /* regs to dump on samples */
               __u32 aux_watermark;        /* aux bytes before wakeup */
               __u16 sample_max_stack;     /* max frames in callchain */
               __u16 __reserved_2;         /* align to u64 */
               __u32 aux_sample_size;      /* max aux sample size */
               __u32 __reserved_3;         /* align to u64 */
               __u64 sig_data;             /* user data for sigtrap */

           };

       The fields of the <i>perf_event_attr</i> structure are described in more
       detail below:

       <i>type</i>   This field specifies the overall event type.  It has one
              of the following values:

              <b>PERF_TYPE_HARDWARE</b>
                     This indicates one of the "generalized" hardware
                     events provided by the kernel.  See the <i>config</i>
                     field definition for more details.

              <b>PERF_TYPE_SOFTWARE</b>
                     This indicates one of the software-defined events
                     provided by the kernel (even if no hardware support
                     is available).

              <b>PERF_TYPE_TRACEPOINT</b>
                     This indicates a tracepoint provided by the kernel
                     tracepoint infrastructure.

              <b>PERF_TYPE_HW_CACHE</b>
                     This indicates a hardware cache event.  This has a
                     special encoding, described in the <i>config</i> field
                     definition.

              <b>PERF_TYPE_RAW</b>
                     This indicates a "raw" implementation-specific
                     event in the <i>config</i> field.

              <b>PERF_TYPE_BREAKPOINT </b>(since Linux 2.6.33)
                     This indicates a hardware breakpoint as provided by
                     the CPU.  Breakpoints can be read/write accesses to
                     an address as well as execution of an instruction
                     address.

              dynamic PMU
                     Since Linux 2.6.38, <b>perf_event_open</b>() can support
                     multiple PMUs.  To enable this, a value exported by
                     the kernel can be used in the <i>type</i> field to
                     indicate which PMU to use.  The value to use can be
                     found in the sysfs filesystem: there is a
                     subdirectory per PMU instance under
                     <i>/sys/bus/event_source/devices</i>.  In each
                     subdirectory there is a <i>type</i> file whose content is
                     an integer that can be used in the <i>type</i> field.  For
                     instance, <i>/sys/bus/event_source/devices/cpu/type</i>
                     contains the value for the core CPU PMU, which is
                     usually 4.

              <b>kprobe </b>and <b>uprobe </b>(since Linux 4.17)
                     These two dynamic PMUs create a kprobe/uprobe and
                     attach it to the file descriptor generated by
                     perf_event_open.  The kprobe/uprobe will be
                     destroyed on the destruction of the file
                     descriptor.  See fields <i>kprobe_func</i>, <i>uprobe_path</i>,
                     <i>kprobe_addr</i>, and <i>probe_offset</i> for more details.

       <i>size</i>   The size of the <i>perf_event_attr</i> structure for
              forward/backward compatibility.  Set this using
              <i>sizeof(struct perf_event_attr)</i> to allow the kernel to see
              the struct size at the time of compilation.

              The related define <b>PERF_ATTR_SIZE_VER0 </b>is set to 64; this
              was the size of the first published struct.
              <b>PERF_ATTR_SIZE_VER1 </b>is 72, corresponding to the addition
              of breakpoints in Linux 2.6.33.  <b>PERF_ATTR_SIZE_VER2 </b>is 80
              corresponding to the addition of branch sampling in Linux
              3.4.  <b>PERF_ATTR_SIZE_VER3 </b>is 96 corresponding to the
              addition of <i>sample_regs_user</i> and <i>sample_stack_user</i> in
              Linux 3.7.  <b>PERF_ATTR_SIZE_VER4 </b>is 104 corresponding to
              the addition of <i>sample_regs_intr</i> in Linux 3.19.
              <b>PERF_ATTR_SIZE_VER5 </b>is 112 corresponding to the addition
              of <i>aux_watermark</i> in Linux 4.1.

       <i>config</i> This specifies which event you want, in conjunction with
              the <i>type</i> field.  The <i>config1</i> and <i>config2</i> fields are also
              taken into account in cases where 64 bits is not enough to
              fully specify the event.  The encoding of these fields are
              event dependent.

              There are various ways to set the <i>config</i> field that are
              dependent on the value of the previously described <i>type</i>
              field.  What follows are various possible settings for
              <i>config</i> separated out by <i>type</i>.

              If <i>type</i> is <b>PERF_TYPE_HARDWARE</b>, we are measuring one of the
              generalized hardware CPU events.  Not all of these are
              available on all platforms.  Set <i>config</i> to one of the
              following:

                   <b>PERF_COUNT_HW_CPU_CYCLES</b>
                          Total cycles.  Be wary of what happens during
                          CPU frequency scaling.

                   <b>PERF_COUNT_HW_INSTRUCTIONS</b>
                          Retired instructions.  Be careful, these can
                          be affected by various issues, most notably
                          hardware interrupt counts.

                   <b>PERF_COUNT_HW_CACHE_REFERENCES</b>
                          Cache accesses.  Usually this indicates Last
                          Level Cache accesses but this may vary
                          depending on your CPU.  This may include
                          prefetches and coherency messages; again this
                          depends on the design of your CPU.

                   <b>PERF_COUNT_HW_CACHE_MISSES</b>
                          Cache misses.  Usually this indicates Last
                          Level Cache misses; this is intended to be
                          used in conjunction with the
                          <b>PERF_COUNT_HW_CACHE_REFERENCES </b>event to
                          calculate cache miss rates.

                   <b>PERF_COUNT_HW_BRANCH_INSTRUCTIONS</b>
                          Retired branch instructions.  Prior to Linux
                          2.6.35, this used the wrong event on AMD
                          processors.

                   <b>PERF_COUNT_HW_BRANCH_MISSES</b>
                          Mispredicted branch instructions.

                   <b>PERF_COUNT_HW_BUS_CYCLES</b>
                          Bus cycles, which can be different from total
                          cycles.

                   <b>PERF_COUNT_HW_STALLED_CYCLES_FRONTEND </b>(since Linux
                   3.0)
                          Stalled cycles during issue.

                   <b>PERF_COUNT_HW_STALLED_CYCLES_BACKEND </b>(since Linux
                   3.0)
                          Stalled cycles during retirement.

                   <b>PERF_COUNT_HW_REF_CPU_CYCLES </b>(since Linux 3.3)
                          Total cycles; not affected by CPU frequency
                          scaling.

              If <i>type</i> is <b>PERF_TYPE_SOFTWARE</b>, we are measuring software
              events provided by the kernel.  Set <i>config</i> to one of the
              following:

                   <b>PERF_COUNT_SW_CPU_CLOCK</b>
                          This reports the CPU clock, a high-resolution
                          per-CPU timer.

                   <b>PERF_COUNT_SW_TASK_CLOCK</b>
                          This reports a clock count specific to the
                          task that is running.

                   <b>PERF_COUNT_SW_PAGE_FAULTS</b>
                          This reports the number of page faults.

                   <b>PERF_COUNT_SW_CONTEXT_SWITCHES</b>
                          This counts context switches.  Until Linux
                          2.6.34, these were all reported as user-space
                          events, after that they are reported as
                          happening in the kernel.

                   <b>PERF_COUNT_SW_CPU_MIGRATIONS</b>
                          This reports the number of times the process
                          has migrated to a new CPU.

                   <b>PERF_COUNT_SW_PAGE_FAULTS_MIN</b>
                          This counts the number of minor page faults.
                          These did not require disk I/O to handle.

                   <b>PERF_COUNT_SW_PAGE_FAULTS_MAJ</b>
                          This counts the number of major page faults.
                          These required disk I/O to handle.

                   <b>PERF_COUNT_SW_ALIGNMENT_FAULTS </b>(since Linux 2.6.33)
                          This counts the number of alignment faults.
                          These happen when unaligned memory accesses
                          happen; the kernel can handle these but it
                          reduces performance.  This happens only on
                          some architectures (never on x86).

                   <b>PERF_COUNT_SW_EMULATION_FAULTS </b>(since Linux 2.6.33)
                          This counts the number of emulation faults.
                          The kernel sometimes traps on unimplemented
                          instructions and emulates them for user space.
                          This can negatively impact performance.

                   <b>PERF_COUNT_SW_DUMMY </b>(since Linux 3.12)
                          This is a placeholder event that counts
                          nothing.  Informational sample record types
                          such as mmap or comm must be associated with
                          an active event.  This dummy event allows
                          gathering such records without requiring a
                          counting event.

                   <b>PERF_COUNT_SW_BPF_OUTPUT </b>(since Linux 4.4)
                          This is used to generate raw sample data from
                          BPF.  BPF programs can write to this event
                          using <b>bpf_perf_event_output </b>helper.

                   <b>PERF_COUNT_SW_CGROUP_SWITCHES </b>(since Linux 5.13)
                          This counts context switches to a task in a
                          different cgroup.  In other words, if the next
                          task is in the same cgroup, it won't count the
                          switch.

              If <i>type</i> is <b>PERF_TYPE_TRACEPOINT</b>, then we are measuring
              kernel tracepoints.  The value to use in <i>config</i> can be
              obtained from under debugfs <i>tracing/events/*/*/id</i> if
              ftrace is enabled in the kernel.

              If <i>type</i> is <b>PERF_TYPE_HW_CACHE</b>, then we are measuring a
              hardware CPU cache event.  To calculate the appropriate
              <i>config</i> value, use the following equation:

                      config = (perf_hw_cache_id) |
                               (perf_hw_cache_op_id &lt;&lt; 8) |
                               (perf_hw_cache_op_result_id &lt;&lt; 16);

                  where <i>perf_hw_cache_id</i> is one of:

                      <b>PERF_COUNT_HW_CACHE_L1D</b>
                             for measuring Level 1 Data Cache

                      <b>PERF_COUNT_HW_CACHE_L1I</b>
                             for measuring Level 1 Instruction Cache

                      <b>PERF_COUNT_HW_CACHE_LL</b>
                             for measuring Last-Level Cache

                      <b>PERF_COUNT_HW_CACHE_DTLB</b>
                             for measuring the Data TLB

                      <b>PERF_COUNT_HW_CACHE_ITLB</b>
                             for measuring the Instruction TLB

                      <b>PERF_COUNT_HW_CACHE_BPU</b>
                             for measuring the branch prediction unit

                      <b>PERF_COUNT_HW_CACHE_NODE </b>(since Linux 3.1)
                             for measuring local memory accesses

                  and <i>perf_hw_cache_op_id</i> is one of:

                      <b>PERF_COUNT_HW_CACHE_OP_READ</b>
                             for read accesses

                      <b>PERF_COUNT_HW_CACHE_OP_WRITE</b>
                             for write accesses

                      <b>PERF_COUNT_HW_CACHE_OP_PREFETCH</b>
                             for prefetch accesses

                  and <i>perf_hw_cache_op_result_id</i> is one of:

                      <b>PERF_COUNT_HW_CACHE_RESULT_ACCESS</b>
                             to measure accesses

                      <b>PERF_COUNT_HW_CACHE_RESULT_MISS</b>
                             to measure misses

              If <i>type</i> is <b>PERF_TYPE_RAW</b>, then a custom "raw" <i>config</i> value
              is needed.  Most CPUs support events that are not covered
              by the "generalized" events.  These are implementation
              defined; see your CPU manual (for example the Intel Volume
              3B documentation or the AMD BIOS and Kernel Developer
              Guide).  The libpfm4 library can be used to translate from
              the name in the architectural manuals to the raw hex value
              <b>perf_event_open</b>() expects in this field.

              If <i>type</i> is <b>PERF_TYPE_BREAKPOINT</b>, then leave <i>config</i> set to
              zero.  Its parameters are set in other places.

              If <i>type</i> is <b>kprobe </b>or <b>uprobe</b>, set <i>retprobe</i> (bit 0 of
              <i>config</i>, see
              <i>/sys/bus/event_source/devices/[k,u]probe/format/retprobe</i>)
              for kretprobe/uretprobe.  See fields <i>kprobe_func</i>,
              <i>uprobe_path</i>, <i>kprobe_addr</i>, and <i>probe_offset</i> for more
              details.

       <i>kprobe_func</i>
       <i>uprobe_path</i>
       <i>kprobe_addr</i>
       <i>probe_offset</i>
              These fields describe the kprobe/uprobe for dynamic PMUs
              <b>kprobe </b>and <b>uprobe</b>.  For <b>kprobe</b>: use <i>kprobe_func</i> and
              <i>probe_offset</i>, or use <i>kprobe_addr</i> and leave <i>kprobe_func</i> as
              NULL.  For <b>uprobe</b>: use <i>uprobe_path</i> and <i>probe_offset</i>.

       <i>sample_period</i>
       <i>sample_freq</i>
              A "sampling" event is one that generates an overflow
              notification every N events, where N is given by
              <i>sample_period</i>.  A sampling event has <i>sample_period</i> &gt; 0.
              When an overflow occurs, requested data is recorded in the
              mmap buffer.  The <i>sample_type</i> field controls what data is
              recorded on each overflow.

              <i>sample_freq</i> can be used if you wish to use frequency
              rather than period.  In this case, you set the <i>freq</i> flag.
              The kernel will adjust the sampling period to try and
              achieve the desired rate.  The rate of adjustment is a
              timer tick.

       <i>sample_type</i>
              The various bits in this field specify which values to
              include in the sample.  They will be recorded in a ring-
              buffer, which is available to user space using <a href="mmap.2.html">mmap(2)</a>.
              The order in which the values are saved in the sample are
              documented in the MMAP Layout subsection below; it is not
              the <i>enum perf_event_sample_format</i> order.

              <b>PERF_SAMPLE_IP</b>
                     Records instruction pointer.

              <b>PERF_SAMPLE_TID</b>
                     Records the process and thread IDs.

              <b>PERF_SAMPLE_TIME</b>
                     Records a timestamp.

              <b>PERF_SAMPLE_ADDR</b>
                     Records an address, if applicable.

              <b>PERF_SAMPLE_READ</b>
                     Record counter values for all events in a group,
                     not just the group leader.

              <b>PERF_SAMPLE_CALLCHAIN</b>
                     Records the callchain (stack backtrace).

              <b>PERF_SAMPLE_ID</b>
                     Records a unique ID for the opened event's group
                     leader.

              <b>PERF_SAMPLE_CPU</b>
                     Records CPU number.

              <b>PERF_SAMPLE_PERIOD</b>
                     Records the current sampling period.

              <b>PERF_SAMPLE_STREAM_ID</b>
                     Records a unique ID for the opened event.  Unlike
                     <b>PERF_SAMPLE_ID </b>the actual ID is returned, not the
                     group leader.  This ID is the same as the one
                     returned by <b>PERF_FORMAT_ID</b>.

              <b>PERF_SAMPLE_RAW</b>
                     Records additional data, if applicable.  Usually
                     returned by tracepoint events.

              <b>PERF_SAMPLE_BRANCH_STACK </b>(since Linux 3.4)
                     This provides a record of recent branches, as
                     provided by CPU branch sampling hardware (such as
                     Intel Last Branch Record).  Not all hardware
                     supports this feature.

                     See the <i>branch_sample_type</i> field for how to filter
                     which branches are reported.

              <b>PERF_SAMPLE_REGS_USER </b>(since Linux 3.7)
                     Records the current user-level CPU register state
                     (the values in the process before the kernel was
                     called).

              <b>PERF_SAMPLE_STACK_USER </b>(since Linux 3.7)
                     Records the user level stack, allowing stack
                     unwinding.

              <b>PERF_SAMPLE_WEIGHT </b>(since Linux 3.10)
                     Records a hardware provided weight value that
                     expresses how costly the sampled event was.  This
                     allows the hardware to highlight expensive events
                     in a profile.

              <b>PERF_SAMPLE_DATA_SRC </b>(since Linux 3.10)
                     Records the data source: where in the memory
                     hierarchy the data associated with the sampled
                     instruction came from.  This is available only if
                     the underlying hardware supports this feature.

              <b>PERF_SAMPLE_IDENTIFIER </b>(since Linux 3.12)
                     Places the <b>SAMPLE_ID </b>value in a fixed position in
                     the record, either at the beginning (for sample
                     events) or at the end (if a non-sample event).

                     This was necessary because a sample stream may have
                     records from various different event sources with
                     different <i>sample_type</i> settings.  Parsing the event
                     stream properly was not possible because the format
                     of the record was needed to find <b>SAMPLE_ID</b>, but the
                     format could not be found without knowing what
                     event the sample belonged to (causing a circular
                     dependency).

                     The <b>PERF_SAMPLE_IDENTIFIER </b>setting makes the event
                     stream always parsable by putting <b>SAMPLE_ID </b>in a
                     fixed location, even though it means having
                     duplicate <b>SAMPLE_ID </b>values in records.

              <b>PERF_SAMPLE_TRANSACTION </b>(since Linux 3.13)
                     Records reasons for transactional memory abort
                     events (for example, from Intel TSX transactional
                     memory support).

                     The <i>precise_ip</i> setting must be greater than 0 and a
                     transactional memory abort event must be measured
                     or no values will be recorded.  Also note that some
                     perf_event measurements, such as sampled cycle
                     counting, may cause extraneous aborts (by causing
                     an interrupt during a transaction).

              <b>PERF_SAMPLE_REGS_INTR </b>(since Linux 3.19)
                     Records a subset of the current CPU register state
                     as specified by <i>sample_regs_intr</i>.  Unlike
                     <b>PERF_SAMPLE_REGS_USER </b>the register values will
                     return kernel register state if the overflow
                     happened while kernel code is running.  If the CPU
                     supports hardware sampling of register state (i.e.,
                     PEBS on Intel x86) and <i>precise_ip</i> is set higher
                     than zero then the register values returned are
                     those captured by hardware at the time of the
                     sampled instruction's retirement.

              <b>PERF_SAMPLE_PHYS_ADDR </b>(since Linux 4.13)
                     Records physical address of data like in
                     <b>PERF_SAMPLE_ADDR</b>.

              <b>PERF_SAMPLE_CGROUP </b>(since Linux 5.7)
                     Records (perf_event) cgroup ID of the process.
                     This corresponds to the <i>id</i> field in the
                     <b>PERF_RECORD_CGROUP </b>event.

              <b>PERF_SAMPLE_DATA_PAGE_SIZE </b>(since Linux 5.11)
                     Records page size of data like in <b>PERF_SAMPLE_ADDR</b>.

              <b>PERF_SAMPLE_CODE_PAGE_SIZE </b>(since Linux 5.11)
                     Records page size of ip like in <b>PERF_SAMPLE_IP</b>.

              <b>PERF_SAMPLE_WEIGHT_STRUCT </b>(since Linux 5.12)
                     Records hardware provided weight values like in
                     <b>PERF_SAMPLE_WEIGHT</b>, but it can represent multiple
                     values in a struct.  This shares the same space as
                     <b>PERF_SAMPLE_WEIGHT</b>, so users can apply either of
                     those, not both.  It has the following format and
                     the meaning of each field is dependent on the
                     hardware implementation.

                  union perf_sample_weight {
                      u64  full;           /* PERF_SAMPLE_WEIGHT */
                      struct {             /* PERF_SAMPLE_WEIGHT_STRUCT */
                          u32  var1_dw;
                          u16  var2_w;
                          u16  var3_w;
                      };
                  };

       <i>read_format</i>
              This field specifies the format of the data returned by
              <a href="read.2.html">read(2)</a> on a <b>perf_event_open</b>() file descriptor.

              <b>PERF_FORMAT_TOTAL_TIME_ENABLED</b>
                     Adds the 64-bit <i>time_enabled</i> field.  This can be
                     used to calculate estimated totals if the PMU is
                     overcommitted and multiplexing is happening.

              <b>PERF_FORMAT_TOTAL_TIME_RUNNING</b>
                     Adds the 64-bit <i>time_running</i> field.  This can be
                     used to calculate estimated totals if the PMU is
                     overcommitted and multiplexing is happening.

              <b>PERF_FORMAT_ID</b>
                     Adds a 64-bit unique value that corresponds to the
                     event group.

              <b>PERF_FORMAT_GROUP</b>
                     Allows all counter values in an event group to be
                     read with one read.

              <b>PERF_FORMAT_LOST  (since Linux 6.0)</b>
                     Adds a 64-bit value that is the number of lost
                     samples for this event.  This would be only
                     meaningful when <i>sample_period</i> or <i>sample_freq</i> is
                     set.

       <i>disabled</i>
              The <i>disabled</i> bit specifies whether the counter starts out
              disabled or enabled.  If disabled, the event can later be
              enabled by <a href="ioctl.2.html">ioctl(2)</a>, <a href="prctl.2.html">prctl(2)</a>, or <i>enable_on_exec</i>.

              When creating an event group, typically the group leader
              is initialized with <i>disabled</i> set to 1 and any child events
              are initialized with <i>disabled</i> set to 0.  Despite <i>disabled</i>
              being 0, the child events will not start until the group
              leader is enabled.

       <i>inherit</i>
              The <i>inherit</i> bit specifies that this counter should count
              events of child tasks as well as the task specified.  This
              applies only to new children, not to any existing children
              at the time the counter is created (nor to any new
              children of existing children).

              Inherit does not work for some combinations of <i>read_format</i>
              values, such as <b>PERF_FORMAT_GROUP</b>.

       <i>pinned</i> The <i>pinned</i> bit specifies that the counter should always be
              on the CPU if at all possible.  It applies only to
              hardware counters and only to group leaders.  If a pinned
              counter cannot be put onto the CPU (e.g., because there
              are not enough hardware counters or because of a conflict
              with some other event), then the counter goes into an
              'error' state, where reads return end-of-file (i.e.,
              <a href="read.2.html">read(2)</a> returns 0) until the counter is subsequently
              enabled or disabled.

       <i>exclusive</i>
              The <i>exclusive</i> bit specifies that when this counter's group
              is on the CPU, it should be the only group using the CPU's
              counters.  In the future this may allow monitoring
              programs to support PMU features that need to run alone so
              that they do not disrupt other hardware counters.

              Note that many unexpected situations may prevent events
              with the <i>exclusive</i> bit set from ever running.  This
              includes any users running a system-wide measurement as
              well as any kernel use of the performance counters
              (including the commonly enabled NMI Watchdog Timer
              interface).

       <i>exclude_user</i>
              If this bit is set, the count excludes events that happen
              in user space.

       <i>exclude_kernel</i>
              If this bit is set, the count excludes events that happen
              in kernel space.

       <i>exclude_hv</i>
              If this bit is set, the count excludes events that happen
              in the hypervisor.  This is mainly for PMUs that have
              built-in support for handling this (such as POWER).  Extra
              support is needed for handling hypervisor measurements on
              most machines.

       <i>exclude_idle</i>
              If set, don't count when the CPU is running the idle task.
              While you can currently enable this for any event type, it
              is ignored for all but software events.

       <i>mmap</i>   The <i>mmap</i> bit enables generation of <b>PERF_RECORD_MMAP</b>
              samples for every <a href="mmap.2.html">mmap(2)</a> call that has <b>PROT_EXEC </b>set.
              This allows tools to notice new executable code being
              mapped into a program (dynamic shared libraries for
              example) so that addresses can be mapped back to the
              original code.

       <i>comm</i>   The <i>comm</i> bit enables tracking of process command name as
              modified by the <a href="execve.2.html">execve(2)</a> and <b>prctl</b>(PR_SET_NAME) system
              calls as well as writing to <i>/proc/self/comm</i>.  If the
              <i>comm_exec</i> flag is also successfully set (possible since
              Linux 3.16), then the misc flag <b>PERF_RECORD_MISC_COMM_EXEC</b>
              can be used to differentiate the <a href="execve.2.html">execve(2)</a> case from the
              others.

       <i>freq</i>   If this bit is set, then <i>sample_frequency</i> not
              <i>sample_period</i> is used when setting up the sampling
              interval.

       <i>inherit_stat</i>
              This bit enables saving of event counts on context switch
              for inherited tasks.  This is meaningful only if the
              <i>inherit</i> field is set.

       <i>enable_on_exec</i>
              If this bit is set, a counter is automatically enabled
              after a call to <a href="execve.2.html">execve(2)</a>.

       <i>task</i>   If this bit is set, then fork/exit notifications are
              included in the ring buffer.

       <i>watermark</i>
              If set, have an overflow notification happen when we cross
              the <i>wakeup_watermark</i> boundary.  Otherwise, overflow
              notifications happen after <i>wakeup_events</i> samples.

       <i>precise_ip</i> (since Linux 2.6.35)
              This controls the amount of skid.  Skid is how many
              instructions execute between an event of interest
              happening and the kernel being able to stop and record the
              event.  Smaller skid is better and allows more accurate
              reporting of which events correspond to which
              instructions, but hardware is often limited with how small
              this can be.

              The possible values of this field are the following:

              <b>0      SAMPLE_IP </b>can have arbitrary skid.

              <b>1      SAMPLE_IP </b>must have constant skid.

              <b>2      SAMPLE_IP </b>requested to have 0 skid.

              <b>3      SAMPLE_IP </b>must have 0 skid.  See also the
                     description of <b>PERF_RECORD_MISC_EXACT_IP</b>.

       <i>mmap_data</i> (since Linux 2.6.36)
              This is the counterpart of the <i>mmap</i> field.  This enables
              generation of <b>PERF_RECORD_MMAP </b>samples for <a href="mmap.2.html">mmap(2)</a> calls
              that do not have <b>PROT_EXEC </b>set (for example data and SysV
              shared memory).

       <i>sample_id_all</i> (since Linux 2.6.38)
              If set, then TID, TIME, ID, STREAM_ID, and CPU can
              additionally be included in non-<b>PERF_RECORD_SAMPLE</b>s if the
              corresponding <i>sample_type</i> is selected.

              If <b>PERF_SAMPLE_IDENTIFIER </b>is specified, then an additional
              ID value is included as the last value to ease parsing the
              record stream.  This may lead to the <i>id</i> value appearing
              twice.

              The layout is described by this pseudo-structure:

                  struct sample_id {
                      { u32 pid, tid; }   /* if PERF_SAMPLE_TID set */
                      { u64 time;     }   /* if PERF_SAMPLE_TIME set */
                      { u64 id;       }   /* if PERF_SAMPLE_ID set */
                      { u64 stream_id;}   /* if PERF_SAMPLE_STREAM_ID set  */
                      { u32 cpu, res; }   /* if PERF_SAMPLE_CPU set */
                      { u64 id;       }   /* if PERF_SAMPLE_IDENTIFIER set */
                  };

       <i>exclude_host</i> (since Linux 3.2)
              When conducting measurements that include processes
              running VM instances (i.e., have executed a <b>KVM_RUN</b>
              <a href="ioctl.2.html">ioctl(2)</a>), only measure events happening inside a guest
              instance.  This is only meaningful outside the guests;
              this setting does not change counts gathered inside of a
              guest.  Currently, this functionality is x86 only.

       <i>exclude_guest</i> (since Linux 3.2)
              When conducting measurements that include processes
              running VM instances (i.e., have executed a <b>KVM_RUN</b>
              <a href="ioctl.2.html">ioctl(2)</a>), do not measure events happening inside guest
              instances.  This is only meaningful outside the guests;
              this setting does not change counts gathered inside of a
              guest.  Currently, this functionality is x86 only.

       <i>exclude_callchain_kernel</i> (since Linux 3.7)
              Do not include kernel callchains.

       <i>exclude_callchain_user</i> (since Linux 3.7)
              Do not include user callchains.

       <i>mmap2</i> (since Linux 3.16)
              Generate an extended executable mmap record that contains
              enough additional information to uniquely identify shared
              mappings.  The <i>mmap</i> flag must also be set for this to
              work.

       <i>comm_exec</i> (since Linux 3.16)
              This is purely a feature-detection flag, it does not
              change kernel behavior.  If this flag can successfully be
              set, then, when <i>comm</i> is enabled, the
              <b>PERF_RECORD_MISC_COMM_EXEC </b>flag will be set in the <i>misc</i>
              field of a comm record header if the rename event being
              reported was caused by a call to <a href="execve.2.html">execve(2)</a>.  This allows
              tools to distinguish between the various types of process
              renaming.

       <i>use_clockid</i> (since Linux 4.1)
              This allows selecting which internal Linux clock to use
              when generating timestamps via the <i>clockid</i> field.  This
              can make it easier to correlate perf sample times with
              timestamps generated by other tools.

       <i>context_switch</i> (since Linux 4.3)
              This enables the generation of <b>PERF_RECORD_SWITCH </b>records
              when a context switch occurs.  It also enables the
              generation of <b>PERF_RECORD_SWITCH_CPU_WIDE </b>records when
              sampling in CPU-wide mode.  This functionality is in
              addition to existing tracepoint and software events for
              measuring context switches.  The advantage of this method
              is that it will give full information even with strict
              <i>perf_event_paranoid</i> settings.

       <i>write_backward</i> (since Linux 4.6)
              This causes the ring buffer to be written from the end to
              the beginning.  This is to support reading from
              overwritable ring buffer.

       <i>namespaces</i> (since Linux 4.11)
              This enables the generation of <b>PERF_RECORD_NAMESPACES</b>
              records when a task enters a new namespace.  Each
              namespace has a combination of device and inode numbers.

       <i>ksymbol</i> (since Linux 5.0)
              This enables the generation of <b>PERF_RECORD_KSYMBOL </b>records
              when new kernel symbols are registered or unregistered.
              This is analyzing dynamic kernel functions like eBPF.

       <i>bpf_event</i> (since Linux 5.0)
              This enables the generation of <b>PERF_RECORD_BPF_EVENT</b>
              records when an eBPF program is loaded or unloaded.

       <i>aux_output</i> (since Linux 5.4)
              This allows normal (non-AUX) events to generate data for
              AUX events if the hardware supports it.

       <i>cgroup</i> (since Linux 5.7)
              This enables the generation of <b>PERF_RECORD_CGROUP </b>records
              when a new cgroup is created (and activated).

       <i>text_poke</i> (since Linux 5.8)
              This enables the generation of <b>PERF_RECORD_TEXT_POKE</b>
              records when there's a change to the kernel text (i.e.,
              self-modifying code).

       <i>build_id</i> (since Linux 5.12)
              This changes the contents in the <b>PERF_RECORD_MMAP2 </b>to have
              a build-id instead of device and inode numbers.

       <i>inherit_thread</i> (since Linux 5.13)
              This disables the inheritance of the event to a child
              process.  Only new threads in the same process (which is
              cloned with <b>CLONE_THREAD</b>) will inherit the event.

       <i>remove_on_exec</i> (since Linux 5.13)
              This closes the event when it starts a new process image
              by <a href="execve.2.html">execve(2)</a>.

       <i>sigtrap</i> (since Linux 5.13)
              This enables synchronous signal delivery of <b>SIGTRAP </b>on
              event overflow.

       <i>wakeup_events</i>
       <i>wakeup_watermark</i>
              This union sets how many samples (<i>wakeup_events</i>) or bytes
              (<i>wakeup_watermark</i>) happen before an overflow notification
              happens.  Which one is used is selected by the <i>watermark</i>
              bit flag.

              <i>wakeup_events</i> counts only <b>PERF_RECORD_SAMPLE </b>record types.
              To receive overflow notification for all <b>PERF_RECORD </b>types
              choose watermark and set <i>wakeup_watermark</i> to 1.

              Prior to Linux 3.0, setting <i>wakeup_events</i> to 0 resulted in
              no overflow notifications; more recent kernels treat 0 the
              same as 1.

       <i>bp_type</i> (since Linux 2.6.33)
              This chooses the breakpoint type.  It is one of:

              <b>HW_BREAKPOINT_EMPTY</b>
                     No breakpoint.

              <b>HW_BREAKPOINT_R</b>
                     Count when we read the memory location.

              <b>HW_BREAKPOINT_W</b>
                     Count when we write the memory location.

              <b>HW_BREAKPOINT_RW</b>
                     Count when we read or write the memory location.

              <b>HW_BREAKPOINT_X</b>
                     Count when we execute code at the memory location.

              The values can be combined via a bitwise or, but the
              combination of <b>HW_BREAKPOINT_R </b>or <b>HW_BREAKPOINT_W </b>with
              <b>HW_BREAKPOINT_X </b>is not allowed.

       <i>bp_addr</i> (since Linux 2.6.33)
              This is the address of the breakpoint.  For execution
              breakpoints, this is the memory address of the instruction
              of interest; for read and write breakpoints, it is the
              memory address of the memory location of interest.

       <i>config1</i> (since Linux 2.6.39)
              <i>config1</i> is used for setting events that need an extra
              register or otherwise do not fit in the regular config
              field.  Raw OFFCORE_EVENTS on Nehalem/Westmere/SandyBridge
              use this field on Linux 3.3 and later kernels.

       <i>bp_len</i> (since Linux 2.6.33)
              <i>bp_len</i> is the length of the breakpoint being measured if
              <i>type</i> is <b>PERF_TYPE_BREAKPOINT</b>.  Options are
              <b>HW_BREAKPOINT_LEN_1</b>, <b>HW_BREAKPOINT_LEN_2</b>,
              <b>HW_BREAKPOINT_LEN_4</b>, and <b>HW_BREAKPOINT_LEN_8</b>.  For an
              execution breakpoint, set this to <i>sizeof(long)</i>.

       <i>config2</i> (since Linux 2.6.39)
              <i>config2</i> is a further extension of the <i>config1</i> field.

       <i>branch_sample_type</i> (since Linux 3.4)
              If <b>PERF_SAMPLE_BRANCH_STACK </b>is enabled, then this
              specifies what branches to include in the branch record.

              The first part of the value is the privilege level, which
              is a combination of one of the values listed below.  If
              the user does not set privilege level explicitly, the
              kernel will use the event's privilege level.  Event and
              branch privilege levels do not have to match.

              <b>PERF_SAMPLE_BRANCH_USER</b>
                     Branch target is in user space.

              <b>PERF_SAMPLE_BRANCH_KERNEL</b>
                     Branch target is in kernel space.

              <b>PERF_SAMPLE_BRANCH_HV</b>
                     Branch target is in hypervisor.

              <b>PERF_SAMPLE_BRANCH_PLM_ALL</b>
                     A convenience value that is the three preceding
                     values ORed together.

              In addition to the privilege value, at least one or more
              of the following bits must be set.

              <b>PERF_SAMPLE_BRANCH_ANY</b>
                     Any branch type.

              <b>PERF_SAMPLE_BRANCH_ANY_CALL</b>
                     Any call branch (includes direct calls, indirect
                     calls, and far jumps).

              <b>PERF_SAMPLE_BRANCH_IND_CALL</b>
                     Indirect calls.

              <b>PERF_SAMPLE_BRANCH_CALL </b>(since Linux 4.4)
                     Direct calls.

              <b>PERF_SAMPLE_BRANCH_ANY_RETURN</b>
                     Any return branch.

              <b>PERF_SAMPLE_BRANCH_IND_JUMP </b>(since Linux 4.2)
                     Indirect jumps.

              <b>PERF_SAMPLE_BRANCH_COND </b>(since Linux 3.16)
                     Conditional branches.

              <b>PERF_SAMPLE_BRANCH_ABORT_TX </b>(since Linux 3.11)
                     Transactional memory aborts.

              <b>PERF_SAMPLE_BRANCH_IN_TX </b>(since Linux 3.11)
                     Branch in transactional memory transaction.

              <b>PERF_SAMPLE_BRANCH_NO_TX </b>(since Linux 3.11)
                     Branch not in transactional memory transaction.
                     <b>PERF_SAMPLE_BRANCH_CALL_STACK </b>(since Linux 4.1)
                     Branch is part of a hardware-generated call stack.
                     This requires hardware support, currently only
                     found on Intel x86 Haswell or newer.

       <i>sample_regs_user</i> (since Linux 3.7)
              This bit mask defines the set of user CPU registers to
              dump on samples.  The layout of the register mask is
              architecture-specific and is described in the kernel
              header file <i>arch/ARCH/include/uapi/asm/perf_regs.h</i>.

       <i>sample_stack_user</i> (since Linux 3.7)
              This defines the size of the user stack to dump if
              <b>PERF_SAMPLE_STACK_USER </b>is specified.

       <i>clockid</i> (since Linux 4.1)
              If <i>use_clockid</i> is set, then this field selects which
              internal Linux timer to use for timestamps.  The available
              timers are defined in <i>linux/time.h</i>, with <b>CLOCK_MONOTONIC</b>,
              <b>CLOCK_MONOTONIC_RAW</b>, <b>CLOCK_REALTIME</b>, <b>CLOCK_BOOTTIME</b>, and
              <b>CLOCK_TAI </b>currently supported.

       <i>aux_watermark</i> (since Linux 4.1)
              This specifies how much data is required to trigger a
              <b>PERF_RECORD_AUX </b>sample.

       <i>sample_max_stack</i> (since Linux 4.8)
              When <i>sample_type</i> includes <b>PERF_SAMPLE_CALLCHAIN</b>, this
              field specifies how many stack frames to report when
              generating the callchain.

       <i>aux_sample_size</i> (since Linux 5.5)
              When <b>PERF_SAMPLE_AUX </b>flag is set, specify the desired size
              of AUX data.  Note that it can get smaller data than the
              specified size.

       <i>sig_data</i> (since Linux 5.13)
              This data will be copied to user's signal handler (through
              <i>si_perf</i> in the <i>siginfo_t</i>) to disambiguate which event
              triggered the signal.

   <b>Reading results</b>
       Once a <b>perf_event_open</b>() file descriptor has been opened, the
       values of the events can be read from the file descriptor.  The
       values that are there are specified by the <i>read_format</i> field in
       the <i>attr</i> structure at open time.

       If you attempt to read into a buffer that is not big enough to
       hold the data, the error <b>ENOSPC </b>results.

       Here is the layout of the data returned by a read:

       •  If <b>PERF_FORMAT_GROUP </b>was specified to allow reading all events
          in a group at once:

              struct read_format {
                  u64 nr;            /* The number of events */
                  u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */
                  u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */
                  struct {
                      u64 value;     /* The value of the event */
                      u64 id;        /* if PERF_FORMAT_ID */
                      u64 lost;      /* if PERF_FORMAT_LOST */
                  } values[nr];
              };

       •  If <b>PERF_FORMAT_GROUP </b>was <i>not</i> specified:

              struct read_format {
                  u64 value;         /* The value of the event */
                  u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */
                  u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */
                  u64 id;            /* if PERF_FORMAT_ID */
                  u64 lost;          /* if PERF_FORMAT_LOST */
              };

       The values read are as follows:

       <i>nr</i>     The number of events in this file descriptor.  Available
              only if <b>PERF_FORMAT_GROUP </b>was specified.

       <i>time_enabled</i>
       <i>time_running</i>
              Total time the event was enabled and running.  Normally
              these values are the same.  Multiplexing happens if the
              number of events is more than the number of available PMU
              counter slots.  In that case the events run only part of
              the time and the <i>time_enabled</i> and <i>time running</i> values can
              be used to scale an estimated value for the count.

       <i>value</i>  An unsigned 64-bit value containing the counter result.

       <i>id</i>     A globally unique value for this particular event; only
              present if <b>PERF_FORMAT_ID </b>was specified in <i>read_format</i>.

       <i>lost</i>   The number of lost samples of this event; only present if
              <b>PERF_FORMAT_LOST </b>was specified in <i>read_format</i>.

   <b>MMAP layout</b>
       When using <b>perf_event_open</b>() in sampled mode, asynchronous events
       (like counter overflow or <b>PROT_EXEC </b>mmap tracking) are logged
       into a ring-buffer.  This ring-buffer is created and accessed
       through <a href="mmap.2.html">mmap(2)</a>.

       The mmap size should be 1+2^n pages, where the first page is a
       metadata page (<i>struct perf_event_mmap_page</i>) that contains various
       bits of information such as where the ring-buffer head is.

       Before Linux 2.6.39, there is a bug that means you must allocate
       an mmap ring buffer when sampling even if you do not plan to
       access it.

       The structure of the first metadata mmap page is as follows:

           struct perf_event_mmap_page {
               __u32 version;        /* version number of this structure */
               __u32 compat_version; /* lowest version this is compat with */
               __u32 lock;           /* seqlock for synchronization */
               __u32 index;          /* hardware counter identifier */
               __s64 offset;         /* add to hardware counter value */
               __u64 time_enabled;   /* time event active */
               __u64 time_running;   /* time event on CPU */
               union {
                   __u64   capabilities;
                   struct {
                       __u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1,
                             cap_bit0_is_deprecated : 1,
                             cap_user_rdpmc         : 1,
                             cap_user_time          : 1,
                             cap_user_time_zero     : 1,
                   };
               };
               __u16 pmc_width;
               __u16 time_shift;
               __u32 time_mult;
               __u64 time_offset;
               __u64 __reserved[120];   /* Pad to 1 k */
               __u64 data_head;         /* head in the data section */
               __u64 data_tail;         /* user-space written tail */
               __u64 data_offset;       /* where the buffer starts */
               __u64 data_size;         /* data buffer size */
               __u64 aux_head;
               __u64 aux_tail;
               __u64 aux_offset;
               __u64 aux_size;

           }

       The following list describes the fields in the
       <i>perf_event_mmap_page</i> structure in more detail:

       <i>version</i>
              Version number of this structure.

       <i>compat_version</i>
              The lowest version this is compatible with.

       <i>lock</i>   A seqlock for synchronization.

       <i>index</i>  A unique hardware counter identifier.

       <i>offset</i> When using rdpmc for reads this offset value must be added
              to the one returned by rdpmc to get the current total
              event count.

       <i>time_enabled</i>
              Time the event was active.

       <i>time_running</i>
              Time the event was running.

       <i>cap_usr_time</i> / <i>cap_usr_rdpmc</i> / <i>cap_bit0</i> (since Linux 3.4)
              There was a bug in the definition of <i>cap_usr_time</i> and
              <i>cap_usr_rdpmc</i> from Linux 3.4 until Linux 3.11.  Both bits
              were defined to point to the same location, so it was
              impossible to know if <i>cap_usr_time</i> or <i>cap_usr_rdpmc</i> were
              actually set.

              Starting with Linux 3.12, these are renamed to <i>cap_bit0</i>
              and you should use the <i>cap_user_time</i> and <i>cap_user_rdpmc</i>
              fields instead.

       <i>cap_bit0_is_deprecated</i> (since Linux 3.12)
              If set, this bit indicates that the kernel supports the
              properly separated <i>cap_user_time</i> and <i>cap_user_rdpmc</i> bits.

              If not-set, it indicates an older kernel where
              <i>cap_usr_time</i> and <i>cap_usr_rdpmc</i> map to the same bit and
              thus both features should be used with caution.

       <i>cap_user_rdpmc</i> (since Linux 3.12)
              If the hardware supports user-space read of performance
              counters without syscall (this is the "rdpmc" instruction
              on x86), then the following code can be used to do a read:

                  u32 seq, time_mult, time_shift, idx, width;
                  u64 count, enabled, running;
                  u64 cyc, time_offset;

                  do {
                      seq = pc-&gt;lock;
                      barrier();
                      enabled = pc-&gt;time_enabled;
                      running = pc-&gt;time_running;

                      if (pc-&gt;cap_usr_time &amp;&amp; enabled != running) {
                          cyc = rdtsc();
                          time_offset = pc-&gt;time_offset;
                          time_mult   = pc-&gt;time_mult;
                          time_shift  = pc-&gt;time_shift;
                      }

                      idx = pc-&gt;index;
                      count = pc-&gt;offset;

                      if (pc-&gt;cap_usr_rdpmc &amp;&amp; idx) {
                          width = pc-&gt;pmc_width;
                          count += rdpmc(idx - 1);
                      }

                      barrier();
                  } while (pc-&gt;lock != seq);

       <i>cap_user_time</i> (since Linux 3.12)
              This bit indicates the hardware has a constant, nonstop
              timestamp counter (TSC on x86).

       <i>cap_user_time_zero</i> (since Linux 3.12)
              Indicates the presence of <i>time_zero</i> which allows mapping
              timestamp values to the hardware clock.

       <i>pmc_width</i>
              If <i>cap_usr_rdpmc</i>, this field provides the bit-width of the
              value read using the rdpmc or equivalent instruction.
              This can be used to sign extend the result like:

                  pmc &lt;&lt;= 64 - pmc_width;
                  pmc &gt;&gt;= 64 - pmc_width; // signed shift right
                  count += pmc;

       <i>time_shift</i>
       <i>time_mult</i>
       <i>time_offset</i>

              If <i>cap_usr_time</i>, these fields can be used to compute the
              time delta since <i>time_enabled</i> (in nanoseconds) using rdtsc
              or similar.

                  u64 quot, rem;
                  u64 delta;

                  quot  = cyc &gt;&gt; time_shift;
                  rem   = cyc &amp; (((u64)1 &lt;&lt; time_shift) - 1);
                  delta = time_offset + quot * time_mult +
                          ((rem * time_mult) &gt;&gt; time_shift);

              Where <i>time_offset</i>, <i>time_mult</i>, <i>time_shift</i>, and <i>cyc</i> are read
              in the seqcount loop described above.  This delta can then
              be added to enabled and possible running (if idx),
              improving the scaling:

                  enabled += delta;
                  if (idx)
                      running += delta;
                  quot  = count / running;
                  rem   = count % running;
                  count = quot * enabled + (rem * enabled) / running;

       <i>time_zero</i> (since Linux 3.12)

              If <i>cap_usr_time_zero</i> is set, then the hardware clock (the
              TSC timestamp counter on x86) can be calculated from the
              <i>time_zero</i>, <i>time_mult</i>, and <i>time_shift</i> values:

                  time = timestamp - time_zero;
                  quot = time / time_mult;
                  rem  = time % time_mult;
                  cyc  = (quot &lt;&lt; time_shift) + (rem &lt;&lt; time_shift) / time_mult;

              And vice versa:

                  quot = cyc &gt;&gt; time_shift;
                  rem  = cyc &amp; (((u64)1 &lt;&lt; time_shift) - 1);
                  timestamp = time_zero + quot * time_mult +
                              ((rem * time_mult) &gt;&gt; time_shift);

       <i>data_head</i>
              This points to the head of the data section.  The value
              continuously increases, it does not wrap.  The value needs
              to be manually wrapped by the size of the mmap buffer
              before accessing the samples.

              On SMP-capable platforms, after reading the <i>data_head</i>
              value, user space should issue an rmb().

       <i>data_tail</i>
              When the mapping is <b>PROT_WRITE</b>, the <i>data_tail</i> value should
              be written by user space to reflect the last read data.
              In this case, the kernel will not overwrite unread data.

       <i>data_offset</i> (since Linux 4.1)
              Contains the offset of the location in the mmap buffer
              where perf sample data begins.

       <i>data_size</i> (since Linux 4.1)
              Contains the size of the perf sample region within the
              mmap buffer.

       <i>aux_head</i>
       <i>aux_tail</i>
       <i>aux_offset</i>
       <i>aux_size</i>  <i>(since Linux 4.1)</i>
              The AUX region allows <a href="mmap.2.html">mmap(2)</a>-ing a separate sample buffer
              for high-bandwidth data streams (separate from the main
              perf sample buffer).  An example of a high-bandwidth
              stream is instruction tracing support, as is found in
              newer Intel processors.

              To set up an AUX area, first <i>aux_offset</i> needs to be set
              with an offset greater than <i>data_offset</i>+<i>data_size</i> and
              <i>aux_size</i> needs to be set to the desired buffer size.  The
              desired offset and size must be page aligned, and the size
              must be a power of two.  These values are then passed to
              mmap in order to map the AUX buffer.  Pages in the AUX
              buffer are included as part of the <b>RLIMIT_MEMLOCK </b>resource
              limit (see <a href="setrlimit.2.html">setrlimit(2)</a>), and also as part of the
              <i>perf_event_mlock_kb</i> allowance.

              By default, the AUX buffer will be truncated if it will
              not fit in the available space in the ring buffer.  If the
              AUX buffer is mapped as a read only buffer, then it will
              operate in ring buffer mode where old data will be
              overwritten by new.  In overwrite mode, it might not be
              possible to infer where the new data began, and it is the
              consumer's job to disable measurement while reading to
              avoid possible data races.

              The <i>aux_head</i> and <i>aux_tail</i> ring buffer pointers have the
              same behavior and ordering rules as the previous described
              <i>data_head</i> and <i>data_tail</i>.

       The following 2^n ring-buffer pages have the layout described
       below.

       If <i>perf_event_attr.sample_id_all</i> is set, then all event types
       will have the sample_type selected fields related to where/when
       (identity) an event took place (TID, TIME, ID, CPU, STREAM_ID)
       described in <b>PERF_RECORD_SAMPLE </b>below, it will be stashed just
       after the <i>perf_event_header</i> and the fields already present for
       the existing fields, that is, at the end of the payload.  This
       allows a newer perf.data file to be supported by older perf
       tools, with the new optional fields being ignored.

       The mmap values start with a header:

           struct perf_event_header {
               __u32   type;
               __u16   misc;
               __u16   size;
           };

       Below, we describe the <i>perf_event_header</i> fields in more detail.
       For ease of reading, the fields with shorter descriptions are
       presented first.

       <i>size</i>   This indicates the size of the record.

       <i>misc</i>   The <i>misc</i> field contains additional information about the
              sample.

              The CPU mode can be determined from this value by masking
              with <b>PERF_RECORD_MISC_CPUMODE_MASK </b>and looking for one of
              the following (note these are not bit masks, only one can
              be set at a time):

              <b>PERF_RECORD_MISC_CPUMODE_UNKNOWN</b>
                     Unknown CPU mode.

              <b>PERF_RECORD_MISC_KERNEL</b>
                     Sample happened in the kernel.

              <b>PERF_RECORD_MISC_USER</b>
                     Sample happened in user code.

              <b>PERF_RECORD_MISC_HYPERVISOR</b>
                     Sample happened in the hypervisor.

              <b>PERF_RECORD_MISC_GUEST_KERNEL </b>(since Linux 2.6.35)
                     Sample happened in the guest kernel.

              <b>PERF_RECORD_MISC_GUEST_USER  (since Linux 2.6.35)</b>
                     Sample happened in guest user code.

              Since the following three statuses are generated by
              different record types, they alias to the same bit:

              <b>PERF_RECORD_MISC_MMAP_DATA </b>(since Linux 3.10)
                     This is set when the mapping is not executable;
                     otherwise the mapping is executable.

              <b>PERF_RECORD_MISC_COMM_EXEC </b>(since Linux 3.16)
                     This is set for a <b>PERF_RECORD_COMM </b>record on
                     kernels more recent than Linux 3.16 if a process
                     name change was caused by an <a href="execve.2.html">execve(2)</a> system call.

              <b>PERF_RECORD_MISC_SWITCH_OUT </b>(since Linux 4.3)
                     When a <b>PERF_RECORD_SWITCH </b>or
                     <b>PERF_RECORD_SWITCH_CPU_WIDE </b>record is generated,
                     this bit indicates that the context switch is away
                     from the current process (instead of into the
                     current process).

              In addition, the following bits can be set:

              <b>PERF_RECORD_MISC_EXACT_IP</b>
                     This indicates that the content of <b>PERF_SAMPLE_IP</b>
                     points to the actual instruction that triggered the
                     event.  See also <i>perf_event_attr.precise_ip</i>.

              <b>PERF_RECORD_MISC_SWITCH_OUT_PREEMPT </b>(since Linux 4.17)
                     When a <b>PERF_RECORD_SWITCH </b>or
                     <b>PERF_RECORD_SWITCH_CPU_WIDE </b>record is generated,
                     this indicates the context switch was a preemption.

              <b>PERF_RECORD_MISC_MMAP_BUILD_ID </b>(since Linux 5.12)
                     This indicates that the content of
                     <b>PERF_SAMPLE_MMAP2 </b>contains build-ID data instead of
                     device major and minor numbers as well as the inode
                     number.

              <b>PERF_RECORD_MISC_EXT_RESERVED </b>(since Linux 2.6.35)
                     This indicates there is extended data available
                     (currently not used).

              <b>PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT</b>
                     This bit is not set by the kernel.  It is reserved
                     for the user-space perf utility to indicate that
                     <i>/proc/</i>pid<i>/maps</i> parsing was taking too long and was
                     stopped, and thus the mmap records may be
                     truncated.

       <i>type</i>   The <i>type</i> value is one of the below.  The values in the
              corresponding record (that follows the header) depend on
              the <i>type</i> selected as shown.

              <b>PERF_RECORD_MMAP</b>
                  The MMAP events record the <b>PROT_EXEC </b>mappings so that
                  we can correlate user-space IPs to code.  They have
                  the following structure:

                      struct {
                          struct perf_event_header header;
                          u32    pid, tid;
                          u64    addr;
                          u64    len;
                          u64    pgoff;
                          char   filename[];
                      };

                  <i>pid</i>    is the process ID.

                  <i>tid</i>    is the thread ID.

                  <i>addr</i>   is the address of the allocated memory.  <i>len</i> is
                         the length of the allocated memory.  <i>pgoff</i> is
                         the page offset of the allocated memory.
                         <i>filename</i> is a string describing the backing of
                         the allocated memory.

              <b>PERF_RECORD_LOST</b>
                  This record indicates when events are lost.

                      struct {
                          struct perf_event_header header;
                          u64    id;
                          u64    lost;
                          struct sample_id sample_id;
                      };

                  <i>id</i>     is the unique event ID for the samples that
                         were lost.

                  <i>lost</i>   is the number of events that were lost.

              <b>PERF_RECORD_COMM</b>
                  This record indicates a change in the process name.

                      struct {
                          struct perf_event_header header;
                          u32    pid;
                          u32    tid;
                          char   comm[];
                          struct sample_id sample_id;
                      };

                  <i>pid</i>    is the process ID.

                  <i>tid</i>    is the thread ID.

                  <i>comm</i>   is a string containing the new name of the
                         process.

              <b>PERF_RECORD_EXIT</b>
                  This record indicates a process exit event.

                      struct {
                          struct perf_event_header header;
                          u32    pid, ppid;
                          u32    tid, ptid;
                          u64    time;
                          struct sample_id sample_id;
                      };

              <b>PERF_RECORD_THROTTLE</b>
              <b>PERF_RECORD_UNTHROTTLE</b>
                  This record indicates a throttle/unthrottle event.

                      struct {
                          struct perf_event_header header;
                          u64    time;
                          u64    id;
                          u64    stream_id;
                          struct sample_id sample_id;
                      };

              <b>PERF_RECORD_FORK</b>
                  This record indicates a fork event.

                      struct {
                          struct perf_event_header header;
                          u32    pid, ppid;
                          u32    tid, ptid;
                          u64    time;
                          struct sample_id sample_id;
                      };

              <b>PERF_RECORD_READ</b>
                  This record indicates a read event.

                      struct {
                          struct perf_event_header header;
                          u32    pid, tid;
                          struct read_format values;
                          struct sample_id sample_id;
                      };

              <b>PERF_RECORD_SAMPLE</b>
                  This record indicates a sample.

                      struct {
                          struct perf_event_header header;
                          u64    sample_id;   /* if PERF_SAMPLE_IDENTIFIER */
                          u64    ip;          /* if PERF_SAMPLE_IP */
                          u32    pid, tid;    /* if PERF_SAMPLE_TID */
                          u64    time;        /* if PERF_SAMPLE_TIME */
                          u64    addr;        /* if PERF_SAMPLE_ADDR */
                          u64    id;          /* if PERF_SAMPLE_ID */
                          u64    stream_id;   /* if PERF_SAMPLE_STREAM_ID */
                          u32    cpu, res;    /* if PERF_SAMPLE_CPU */
                          u64    period;      /* if PERF_SAMPLE_PERIOD */
                          struct read_format v;
                                              /* if PERF_SAMPLE_READ */
                          u64    nr;          /* if PERF_SAMPLE_CALLCHAIN */
                          u64    ips[nr];     /* if PERF_SAMPLE_CALLCHAIN */
                          u32    size;        /* if PERF_SAMPLE_RAW */
                          char   data[size];  /* if PERF_SAMPLE_RAW */
                          u64    bnr;         /* if PERF_SAMPLE_BRANCH_STACK */
                          struct perf_branch_entry lbr[bnr];
                                              /* if PERF_SAMPLE_BRANCH_STACK */
                          u64    abi;         /* if PERF_SAMPLE_REGS_USER */
                          u64    regs[weight(mask)];
                                              /* if PERF_SAMPLE_REGS_USER */
                          u64    size;        /* if PERF_SAMPLE_STACK_USER */
                          char   data[size];  /* if PERF_SAMPLE_STACK_USER */
                          u64    dyn_size;    /* if PERF_SAMPLE_STACK_USER &amp;&amp;
                                                 size != 0 */
                          union perf_sample_weight weight;
                                              /* if PERF_SAMPLE_WEIGHT */
                                              /* || PERF_SAMPLE_WEIGHT_STRUCT */
                          u64    data_src;    /* if PERF_SAMPLE_DATA_SRC */
                          u64    transaction; /* if PERF_SAMPLE_TRANSACTION */
                          u64    abi;         /* if PERF_SAMPLE_REGS_INTR */
                          u64    regs[weight(mask)];
                                              /* if PERF_SAMPLE_REGS_INTR */
                          u64    phys_addr;   /* if PERF_SAMPLE_PHYS_ADDR */
                          u64    cgroup;      /* if PERF_SAMPLE_CGROUP */
                          u64    data_page_size;
                                            /* if PERF_SAMPLE_DATA_PAGE_SIZE */
                          u64    code_page_size;
                                            /* if PERF_SAMPLE_CODE_PAGE_SIZE */
                          u64    size;        /* if PERF_SAMPLE_AUX */
                          char   data[size];  /* if PERF_SAMPLE_AUX */
                      };

                  <i>sample_id</i>
                      If <b>PERF_SAMPLE_IDENTIFIER </b>is enabled, a 64-bit
                      unique ID is included.  This is a duplication of
                      the <b>PERF_SAMPLE_ID </b><i>id</i> value, but included at the
                      beginning of the sample so parsers can easily
                      obtain the value.

                  <i>ip</i>  If <b>PERF_SAMPLE_IP </b>is enabled, then a 64-bit
                      instruction pointer value is included.

                  <i>pid</i>
                  <i>tid</i> If <b>PERF_SAMPLE_TID </b>is enabled, then a 32-bit
                      process ID and 32-bit thread ID are included.

                  <i>time</i>
                      If <b>PERF_SAMPLE_TIME </b>is enabled, then a 64-bit
                      timestamp is included.  This is obtained via
                      local_clock() which is a hardware timestamp if
                      available and the jiffies value if not.

                  <i>addr</i>
                      If <b>PERF_SAMPLE_ADDR </b>is enabled, then a 64-bit
                      address is included.  This is usually the address
                      of a tracepoint, breakpoint, or software event;
                      otherwise the value is 0.

                  <i>id</i>  If <b>PERF_SAMPLE_ID </b>is enabled, a 64-bit unique ID
                      is included.  If the event is a member of an event
                      group, the group leader ID is returned.  This ID
                      is the same as the one returned by <b>PERF_FORMAT_ID</b>.

                  <i>stream_id</i>
                      If <b>PERF_SAMPLE_STREAM_ID </b>is enabled, a 64-bit
                      unique ID is included.  Unlike <b>PERF_SAMPLE_ID </b>the
                      actual ID is returned, not the group leader.  This
                      ID is the same as the one returned by
                      <b>PERF_FORMAT_ID</b>.

                  <i>cpu</i>
                  <i>res</i> If <b>PERF_SAMPLE_CPU </b>is enabled, this is a 32-bit
                      value indicating which CPU was being used, in
                      addition to a reserved (unused) 32-bit value.

                  <i>period</i>
                      If <b>PERF_SAMPLE_PERIOD </b>is enabled, a 64-bit value
                      indicating the current sampling period is written.

                  <i>v</i>   If <b>PERF_SAMPLE_READ </b>is enabled, a structure of
                      type read_format is included which has values for
                      all events in the event group.  The values
                      included depend on the <i>read_format</i> value used at
                      <b>perf_event_open</b>() time.

                  <i>nr</i>
                  <i>ips[nr]</i>
                      If <b>PERF_SAMPLE_CALLCHAIN </b>is enabled, then a 64-bit
                      number is included which indicates how many
                      following 64-bit instruction pointers will follow.
                      This is the current callchain.

                  <i>size</i>
                  <i>data[size]</i>
                      If <b>PERF_SAMPLE_RAW </b>is enabled, then a 32-bit value
                      indicating size is included followed by an array
                      of 8-bit values of length size.  The values are
                      padded with 0 to have 64-bit alignment.

                      This RAW record data is opaque with respect to the
                      ABI.  The ABI doesn't make any promises with
                      respect to the stability of its content, it may
                      vary depending on event, hardware, and kernel
                      version.

                  <i>bnr</i>
                  <i>lbr[bnr]</i>
                      If <b>PERF_SAMPLE_BRANCH_STACK </b>is enabled, then a
                      64-bit value indicating the number of records is
                      included, followed by <i>bnr perf_branch_entry</i>
                      structures which each include the fields:

                      <i>from</i>   This indicates the source instruction (may
                             not be a branch).

                      <i>to</i>     The branch target.

                      <i>mispred</i>
                             The branch target was mispredicted.

                      <i>predicted</i>
                             The branch target was predicted.

                      <i>in_tx</i> (since Linux 3.11)
                             The branch was in a transactional memory
                             transaction.

                      <i>abort</i> (since Linux 3.11)
                             The branch was in an aborted transactional
                             memory transaction.

                      <i>cycles</i> (since Linux 4.3)
                             This reports the number of cycles elapsed
                             since the previous branch stack update.

                      The entries are from most to least recent, so the
                      first entry has the most recent branch.

                      Support for <i>mispred</i>, <i>predicted</i>, and <i>cycles</i> is
                      optional; if not supported, those values will be
                      0.

                      The type of branches recorded is specified by the
                      <i>branch_sample_type</i> field.

                  <i>abi</i>
                  <i>regs[weight(mask)]</i>
                      If <b>PERF_SAMPLE_REGS_USER </b>is enabled, then the user
                      CPU registers are recorded.

                      The <i>abi</i> field is one of <b>PERF_SAMPLE_REGS_ABI_NONE</b>,
                      <b>PERF_SAMPLE_REGS_ABI_32</b>, or
                      <b>PERF_SAMPLE_REGS_ABI_64</b>.

                      The <i>regs</i> field is an array of the CPU registers
                      that were specified by the <i>sample_regs_user</i> attr
                      field.  The number of values is the number of bits
                      set in the <i>sample_regs_user</i> bit mask.

                  <i>size</i>
                  <i>data[size]</i>
                  <i>dyn_size</i>
                      If <b>PERF_SAMPLE_STACK_USER </b>is enabled, then the
                      user stack is recorded.  This can be used to
                      generate stack backtraces.  <i>size</i> is the size
                      requested by the user in <i>sample_stack_user</i> or else
                      the maximum record size.  <i>data</i> is the stack data
                      (a raw dump of the memory pointed to by the stack
                      pointer at the time of sampling).  <i>dyn_size</i> is the
                      amount of data actually dumped (can be less than
                      <i>size</i>).  Note that <i>dyn_size</i> is omitted if <i>size</i> is
                      0.

                  <i>weight</i>
                      If <b>PERF_SAMPLE_WEIGHT </b>or <b>PERF_SAMPLE_WEIGHT_STRUCT</b>
                      is enabled, then a 64-bit value provided by the
                      hardware is recorded that indicates how costly the
                      event was.  This allows expensive events to stand
                      out more clearly in profiles.

                  <i>data_src</i>
                      If <b>PERF_SAMPLE_DATA_SRC </b>is enabled, then a 64-bit
                      value is recorded that is made up of the following
                      fields:

                      <i>mem_op</i>
                          Type of opcode, a bitwise combination of:

                          <b>PERF_MEM_OP_NA</b>
                                 Not available
                          <b>PERF_MEM_OP_LOAD</b>
                                 Load instruction
                          <b>PERF_MEM_OP_STORE</b>
                                 Store instruction
                          <b>PERF_MEM_OP_PFETCH</b>
                                 Prefetch
                          <b>PERF_MEM_OP_EXEC</b>
                                 Executable code

                      <i>mem_lvl</i>
                          Memory hierarchy level hit or miss, a bitwise
                          combination of the following, shifted left by
                          <b>PERF_MEM_LVL_SHIFT</b>:

                          <b>PERF_MEM_LVL_NA</b>
                                 Not available
                          <b>PERF_MEM_LVL_HIT</b>
                                 Hit
                          <b>PERF_MEM_LVL_MISS</b>
                                 Miss
                          <b>PERF_MEM_LVL_L1</b>
                                 Level 1 cache
                          <b>PERF_MEM_LVL_LFB</b>
                                 Line fill buffer
                          <b>PERF_MEM_LVL_L2</b>
                                 Level 2 cache
                          <b>PERF_MEM_LVL_L3</b>
                                 Level 3 cache
                          <b>PERF_MEM_LVL_LOC_RAM</b>
                                 Local DRAM
                          <b>PERF_MEM_LVL_REM_RAM1</b>
                                 Remote DRAM 1 hop
                          <b>PERF_MEM_LVL_REM_RAM2</b>
                                 Remote DRAM 2 hops
                          <b>PERF_MEM_LVL_REM_CCE1</b>
                                 Remote cache 1 hop
                          <b>PERF_MEM_LVL_REM_CCE2</b>
                                 Remote cache 2 hops
                          <b>PERF_MEM_LVL_IO</b>
                                 I/O memory
                          <b>PERF_MEM_LVL_UNC</b>
                                 Uncached memory

                      <i>mem_snoop</i>
                          Snoop mode, a bitwise combination of the
                          following, shifted left by
                          <b>PERF_MEM_SNOOP_SHIFT</b>:

                          <b>PERF_MEM_SNOOP_NA</b>
                                 Not available
                          <b>PERF_MEM_SNOOP_NONE</b>
                                 No snoop
                          <b>PERF_MEM_SNOOP_HIT</b>
                                 Snoop hit
                          <b>PERF_MEM_SNOOP_MISS</b>
                                 Snoop miss
                          <b>PERF_MEM_SNOOP_HITM</b>
                                 Snoop hit modified

                      <i>mem_lock</i>
                          Lock instruction, a bitwise combination of the
                          following, shifted left by
                          <b>PERF_MEM_LOCK_SHIFT</b>:

                          <b>PERF_MEM_LOCK_NA</b>
                                 Not available
                          <b>PERF_MEM_LOCK_LOCKED</b>
                                 Locked transaction

                      <i>mem_dtlb</i>
                          TLB access hit or miss, a bitwise combination
                          of the following, shifted left by
                          <b>PERF_MEM_TLB_SHIFT</b>:

                          <b>PERF_MEM_TLB_NA</b>
                                 Not available
                          <b>PERF_MEM_TLB_HIT</b>
                                 Hit
                          <b>PERF_MEM_TLB_MISS</b>
                                 Miss
                          <b>PERF_MEM_TLB_L1</b>
                                 Level 1 TLB
                          <b>PERF_MEM_TLB_L2</b>
                                 Level 2 TLB
                          <b>PERF_MEM_TLB_WK</b>
                                 Hardware walker
                          <b>PERF_MEM_TLB_OS</b>
                                 OS fault handler

                  <i>transaction</i>
                      If the <b>PERF_SAMPLE_TRANSACTION </b>flag is set, then a
                      64-bit field is recorded describing the sources of
                      any transactional memory aborts.

                      The field is a bitwise combination of the
                      following values:

                      <b>PERF_TXN_ELISION</b>
                             Abort from an elision type transaction
                             (Intel-CPU-specific).

                      <b>PERF_TXN_TRANSACTION</b>
                             Abort from a generic transaction.

                      <b>PERF_TXN_SYNC</b>
                             Synchronous abort (related to the reported
                             instruction).

                      <b>PERF_TXN_ASYNC</b>
                             Asynchronous abort (not related to the
                             reported instruction).

                      <b>PERF_TXN_RETRY</b>
                             Retryable abort (retrying the transaction
                             may have succeeded).

                      <b>PERF_TXN_CONFLICT</b>
                             Abort due to memory conflicts with other
                             threads.

                      <b>PERF_TXN_CAPACITY_WRITE</b>
                             Abort due to write capacity overflow.

                      <b>PERF_TXN_CAPACITY_READ</b>
                             Abort due to read capacity overflow.

                      In addition, a user-specified abort code can be
                      obtained from the high 32 bits of the field by
                      shifting right by <b>PERF_TXN_ABORT_SHIFT </b>and masking
                      with the value <b>PERF_TXN_ABORT_MASK</b>.

                  <i>abi</i>
                  <i>regs[weight(mask)]</i>
                      If <b>PERF_SAMPLE_REGS_INTR </b>is enabled, then the user
                      CPU registers are recorded.

                      The <i>abi</i> field is one of <b>PERF_SAMPLE_REGS_ABI_NONE</b>,
                      <b>PERF_SAMPLE_REGS_ABI_32</b>, or
                      <b>PERF_SAMPLE_REGS_ABI_64</b>.

                      The <i>regs</i> field is an array of the CPU registers
                      that were specified by the <i>sample_regs_intr</i> attr
                      field.  The number of values is the number of bits
                      set in the <i>sample_regs_intr</i> bit mask.

                  <i>phys_addr</i>
                      If the <b>PERF_SAMPLE_PHYS_ADDR </b>flag is set, then the
                      64-bit physical address is recorded.

                  <i>cgroup</i>
                      If the <b>PERF_SAMPLE_CGROUP </b>flag is set, then the
                      64-bit cgroup ID (for the perf_event subsystem) is
                      recorded.  To get the pathname of the cgroup, the
                      ID should match to one in a <b>PERF_RECORD_CGROUP</b>.

                  <i>data_page_size</i>
                      If the <b>PERF_SAMPLE_DATA_PAGE_SIZE </b>flag is set,
                      then the 64-bit page size value of the <b>data</b>
                      address is recorded.

                  <i>code_page_size</i>
                      If the <b>PERF_SAMPLE_CODE_PAGE_SIZE </b>flag is set,
                      then the 64-bit page size value of the <b>ip </b>address
                      is recorded.

                  <i>size</i>
                  <i>data</i>[<i>size</i>]
                      If <b>PERF_SAMPLE_AUX </b>is enabled, a snapshot of the
                      aux buffer is recorded.

              <b>PERF_RECORD_MMAP2</b>
                  This record includes extended information on <a href="mmap.2.html">mmap(2)</a>
                  calls returning executable mappings.  The format is
                  similar to that of the <b>PERF_RECORD_MMAP </b>record, but
                  includes extra values that allow uniquely identifying
                  shared mappings.  Depending on the
                  <b>PERF_RECORD_MISC_MMAP_BUILD_ID </b>bit in the header, the
                  extra values have different layout and meanings.

                      struct {
                          struct perf_event_header header;
                          u32    pid;
                          u32    tid;
                          u64    addr;
                          u64    len;
                          u64    pgoff;
                          union {
                              struct {
                                  u32    maj;
                                  u32    min;
                                  u64    ino;
                                  u64    ino_generation;
                              };
                              struct {   /* if PERF_RECORD_MISC_MMAP_BUILD_ID */
                                  u8     build_id_size;
                                  u8     __reserved_1;
                                  u16    __reserved_2;
                                  u8     build_id[20];
                              };
                          };
                          u32    prot;
                          u32    flags;
                          char   filename[];
                          struct sample_id sample_id;
                      };

                  <i>pid</i>    is the process ID.

                  <i>tid</i>    is the thread ID.

                  <i>addr</i>   is the address of the allocated memory.

                  <i>len</i>    is the length of the allocated memory.

                  <i>pgoff</i>  is the page offset of the allocated memory.

                  <i>maj</i>    is the major ID of the underlying device.

                  <i>min</i>    is the minor ID of the underlying device.

                  <i>ino</i>    is the inode number.

                  <i>ino_generation</i>
                         is the inode generation.

                  <i>build_id_size</i>
                         is the actual size of <i>build_id</i> field (up to
                         20).

                  <i>build_id</i>
                         is a raw data to identify a binary.

                  <i>prot</i>   is the protection information.

                  <i>flags</i>  is the flags information.

                  <i>filename</i>
                         is a string describing the backing of the
                         allocated memory.

              <b>PERF_RECORD_AUX </b>(since Linux 4.1)
                  This record reports that new data is available in the
                  separate AUX buffer region.

                      struct {
                          struct perf_event_header header;
                          u64    aux_offset;
                          u64    aux_size;
                          u64    flags;
                          struct sample_id sample_id;
                      };

                  <i>aux_offset</i>
                         offset in the AUX mmap region where the new
                         data begins.

                  <i>aux_size</i>
                         size of the data made available.

                  <i>flags</i>  describes the AUX update.

                         <b>PERF_AUX_FLAG_TRUNCATED</b>
                                if set, then the data returned was
                                truncated to fit the available buffer
                                size.

                         <b>PERF_AUX_FLAG_OVERWRITE</b>
                                if set, then the data returned has
                                overwritten previous data.

              <b>PERF_RECORD_ITRACE_START </b>(since Linux 4.1)
                  This record indicates which process has initiated an
                  instruction trace event, allowing tools to properly
                  correlate the instruction addresses in the AUX buffer
                  with the proper executable.

                      struct {
                          struct perf_event_header header;
                          u32    pid;
                          u32    tid;
                      };

                  <i>pid</i>    process ID of the thread starting an
                         instruction trace.

                  <i>tid</i>    thread ID of the thread starting an instruction
                         trace.

              <b>PERF_RECORD_LOST_SAMPLES </b>(since Linux 4.2)
                  When using hardware sampling (such as Intel PEBS) this
                  record indicates some number of samples that may have
                  been lost.

                      struct {
                          struct perf_event_header header;
                          u64    lost;
                          struct sample_id sample_id;
                      };

                  <i>lost</i>   the number of potentially lost samples.

              <b>PERF_RECORD_SWITCH </b>(since Linux 4.3)
                  This record indicates a context switch has happened.
                  The <b>PERF_RECORD_MISC_SWITCH_OUT </b>bit in the <i>misc</i> field
                  indicates whether it was a context switch into or away
                  from the current process.

                      struct {
                          struct perf_event_header header;
                          struct sample_id sample_id;
                      };

              <b>PERF_RECORD_SWITCH_CPU_WIDE </b>(since Linux 4.3)
                  As with <b>PERF_RECORD_SWITCH </b>this record indicates a
                  context switch has happened, but it only occurs when
                  sampling in CPU-wide mode and provides additional
                  information on the process being switched to/from.
                  The <b>PERF_RECORD_MISC_SWITCH_OUT </b>bit in the <i>misc</i> field
                  indicates whether it was a context switch into or away
                  from the current process.

                      struct {
                          struct perf_event_header header;
                          u32 next_prev_pid;
                          u32 next_prev_tid;
                          struct sample_id sample_id;
                      };

                  <i>next_prev_pid</i>
                         The process ID of the previous (if switching
                         in) or next (if switching out) process on the
                         CPU.

                  <i>next_prev_tid</i>
                         The thread ID of the previous (if switching in)
                         or next (if switching out) thread on the CPU.

              <b>PERF_RECORD_NAMESPACES </b>(since Linux 4.11)
                  This record includes various namespace information of
                  a process.

                      struct {
                          struct perf_event_header header;
                          u32    pid;
                          u32    tid;
                          u64    nr_namespaces;
                          struct { u64 dev, inode } [nr_namespaces];
                          struct sample_id sample_id;
                      };

                  <i>pid</i>    is the process ID

                  <i>tid</i>    is the thread ID

                  <i>nr_namespace</i>
                         is the number of namespaces in this record

                  Each namespace has <i>dev</i> and <i>inode</i> fields and is
                  recorded in the fixed position like below:

                  <b>NET_NS_INDEX</b>=<b>0</b>
                         Network namespace

                  <b>UTS_NS_INDEX</b>=<b>1</b>
                         UTS namespace

                  <b>IPC_NS_INDEX</b>=<b>2</b>
                         IPC namespace

                  <b>PID_NS_INDEX</b>=<b>3</b>
                         PID namespace

                  <b>USER_NS_INDEX</b>=<b>4</b>
                         User namespace

                  <b>MNT_NS_INDEX</b>=<b>5</b>
                         Mount namespace

                  <b>CGROUP_NS_INDEX</b>=<b>6</b>
                         Cgroup namespace

              <b>PERF_RECORD_KSYMBOL </b>(since Linux 5.0)
                  This record indicates kernel symbol
                  register/unregister events.

                      struct {
                          struct perf_event_header header;
                          u64    addr;
                          u32    len;
                          u16    ksym_type;
                          u16    flags;
                          char   name[];
                          struct sample_id sample_id;
                      };

                  <i>addr</i>   is the address of the kernel symbol.

                  <i>len</i>    is the length of the kernel symbol.

                  <i>ksym_type</i>
                         is the type of the kernel symbol.  Currently
                         the following types are available:

                         <b>PERF_RECORD_KSYMBOL_TYPE_BPF</b>
                                The kernel symbol is a BPF function.

                  <i>flags</i>  If the <b>PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER </b>is
                         set, then this event is for unregistering the
                         kernel symbol.

              <b>PERF_RECORD_BPF_EVENT </b>(since Linux 5.0)
                  This record indicates BPF program is loaded or
                  unloaded.

                      struct {
                          struct perf_event_header header;
                          u16 type;
                          u16 flags;
                          u32 id;
                          u8 tag[BPF_TAG_SIZE];
                          struct sample_id sample_id;
                      };

                  <i>type</i>   is one of the following values:

                         <b>PERF_BPF_EVENT_PROG_LOAD</b>
                                A BPF program is loaded

                         <b>PERF_BPF_EVENT_PROG_UNLOAD</b>
                                A BPF program is unloaded

                  <i>id</i>     is the ID of the BPF program.

                  <i>tag</i>    is the tag of the BPF program.  Currently,
                         <b>BPF_TAG_SIZE </b>is defined as 8.

              <b>PERF_RECORD_CGROUP </b>(since Linux 5.7)
                  This record indicates a new cgroup is created and
                  activated.

                      struct {
                          struct perf_event_header header;
                          u64    id;
                          char   path[];
                          struct sample_id sample_id;
                      };

                  <i>id</i>     is the cgroup identifier.  This can be also
                         retrieved by <a href="name_to_handle_at.2.html">name_to_handle_at(2)</a> on the cgroup
                         path (as a file handle).

                  <i>path</i>   is the path of the cgroup from the root.

              <b>PERF_RECORD_TEXT_POKE </b>(since Linux 5.8)
                  This record indicates a change in the kernel text.
                  This includes addition and removal of the text and the
                  corresponding length is zero in this case.

                      struct {
                          struct perf_event_header header;
                          u64    addr;
                          u16    old_len;
                          u16    new_len;
                          u8     bytes[];
                          struct sample_id sample_id;
                      };

                  <i>addr</i>   is the address of the change

                  <i>old_len</i>
                         is the old length

                  <i>new_len</i>
                         is the new length

                  <i>bytes</i>  contains old bytes immediately followed by new
                         bytes.

   <b>Overflow handling</b>
       Events can be set to notify when a threshold is crossed,
       indicating an overflow.  Overflow conditions can be captured by
       monitoring the event file descriptor with <a href="poll.2.html">poll(2)</a>, <a href="select.2.html">select(2)</a>, or
       <a href="../man7/epoll.7.html">epoll(7)</a>.  Alternatively, the overflow events can be captured via
       sa signal handler, by enabling I/O signaling on the file
       descriptor; see the discussion of the <b>F_SETOWN </b>and <b>F_SETSIG</b>
       operations in <a href="fcntl.2.html">fcntl(2)</a>.

       Overflows are generated only by sampling events (<i>sample_period</i>
       must have a nonzero value).

       There are two ways to generate overflow notifications.

       The first is to set a <i>wakeup_events</i> or <i>wakeup_watermark</i> value
       that will trigger if a certain number of samples or bytes have
       been written to the mmap ring buffer.  In this case, <b>POLL_IN </b>is
       indicated.

       The other way is by use of the <b>PERF_EVENT_IOC_REFRESH </b>ioctl.
       This ioctl adds to a counter that decrements each time the event
       overflows.  When nonzero, <b>POLL_IN </b>is indicated, but once the
       counter reaches 0 <b>POLL_HUP </b>is indicated and the underlying event
       is disabled.

       Refreshing an event group leader refreshes all siblings and
       refreshing with a parameter of 0 currently enables infinite
       refreshes; these behaviors are unsupported and should not be
       relied on.

       Starting with Linux 3.18, <b>POLL_HUP </b>is indicated if the event
       being monitored is attached to a different process and that
       process exits.

   <b>rdpmc instruction</b>
       Starting with Linux 3.4 on x86, you can use the <i>rdpmc</i> instruction
       to get low-latency reads without having to enter the kernel.
       Note that using <i>rdpmc</i> is not necessarily faster than other
       methods for reading event values.

       Support for this can be detected with the <i>cap_usr_rdpmc</i> field in
       the mmap page; documentation on how to calculate event values can
       be found in that section.

       Originally, when rdpmc support was enabled, any process (not just
       ones with an active perf event) could use the rdpmc instruction
       to access the counters.  Starting with Linux 4.0, rdpmc support
       is only allowed if an event is currently enabled in a process's
       context.  To restore the old behavior, write the value 2 to
       <i>/sys/devices/cpu/rdpmc</i>.

   <b>perf_event ioctl calls</b>
       Various ioctls act on <b>perf_event_open</b>() file descriptors:

       <b>PERF_EVENT_IOC_ENABLE</b>
              This enables the individual event or event group specified
              by the file descriptor argument.

              If the <b>PERF_IOC_FLAG_GROUP </b>bit is set in the ioctl
              argument, then all events in a group are enabled, even if
              the event specified is not the group leader (but see
              BUGS).

       <b>PERF_EVENT_IOC_DISABLE</b>
              This disables the individual counter or event group
              specified by the file descriptor argument.

              Enabling or disabling the leader of a group enables or
              disables the entire group; that is, while the group leader
              is disabled, none of the counters in the group will count.
              Enabling or disabling a member of a group other than the
              leader affects only that counter; disabling a non-leader
              stops that counter from counting but doesn't affect any
              other counter.

              If the <b>PERF_IOC_FLAG_GROUP </b>bit is set in the ioctl
              argument, then all events in a group are disabled, even if
              the event specified is not the group leader (but see
              BUGS).

       <b>PERF_EVENT_IOC_REFRESH</b>
              Non-inherited overflow counters can use this to enable a
              counter for a number of overflows specified by the
              argument, after which it is disabled.  Subsequent calls of
              this ioctl add the argument value to the current count.
              An overflow notification with <b>POLL_IN </b>set will happen on
              each overflow until the count reaches 0; when that happens
              a notification with <b>POLL_HUP </b>set is sent and the event is
              disabled.  Using an argument of 0 is considered undefined
              behavior.

       <b>PERF_EVENT_IOC_RESET</b>
              Reset the event count specified by the file descriptor
              argument to zero.  This resets only the counts; there is
              no way to reset the multiplexing <i>time_enabled</i> or
              <i>time_running</i> values.

              If the <b>PERF_IOC_FLAG_GROUP </b>bit is set in the ioctl
              argument, then all events in a group are reset, even if
              the event specified is not the group leader (but see
              BUGS).

       <b>PERF_EVENT_IOC_PERIOD</b>
              This updates the overflow period for the event.

              Since Linux 3.7 (on ARM) and Linux 3.14 (all other
              architectures), the new period takes effect immediately.
              On older kernels, the new period did not take effect until
              after the next overflow.

              The argument is a pointer to a 64-bit value containing the
              desired new period.

              Prior to Linux 2.6.36, this ioctl always failed due to a
              bug in the kernel.

       <b>PERF_EVENT_IOC_SET_OUTPUT</b>
              This tells the kernel to report event notifications to the
              specified file descriptor rather than the default one.
              The file descriptors must all be on the same CPU.

              The argument specifies the desired file descriptor, or -1
              if output should be ignored.

       <b>PERF_EVENT_IOC_SET_FILTER </b>(since Linux 2.6.33)
              This adds an ftrace filter to this event.

              The argument is a pointer to the desired ftrace filter.

       <b>PERF_EVENT_IOC_ID </b>(since Linux 3.12)
              This returns the event ID value for the given event file
              descriptor.

              The argument is a pointer to a 64-bit unsigned integer to
              hold the result.

       <b>PERF_EVENT_IOC_SET_BPF </b>(since Linux 4.1)
              This allows attaching a Berkeley Packet Filter (BPF)
              program to an existing kprobe tracepoint event.  You need
              <b>CAP_PERFMON </b>(since Linux 5.8) or <b>CAP_SYS_ADMIN </b>privileges
              to use this ioctl.

              The argument is a BPF program file descriptor that was
              created by a previous <a href="bpf.2.html">bpf(2)</a> system call.

       <b>PERF_EVENT_IOC_PAUSE_OUTPUT </b>(since Linux 4.7)
              This allows pausing and resuming the event's ring-buffer.
              A paused ring-buffer does not prevent generation of
              samples, but simply discards them.  The discarded samples
              are considered lost, and cause a <b>PERF_RECORD_LOST </b>sample
              to be generated when possible.  An overflow signal may
              still be triggered by the discarded sample even though the
              ring-buffer remains empty.

              The argument is an unsigned 32-bit integer.  A nonzero
              value pauses the ring-buffer, while a zero value resumes
              the ring-buffer.

       <b>PERF_EVENT_MODIFY_ATTRIBUTES </b>(since Linux 4.17)
              This allows modifying an existing event without the
              overhead of closing and reopening a new event.  Currently
              this is supported only for breakpoint events.

              The argument is a pointer to a <i>perf_event_attr</i> structure
              containing the updated event settings.

       <b>PERF_EVENT_IOC_QUERY_BPF </b>(since Linux 4.16)
              This allows querying which Berkeley Packet Filter (BPF)
              programs are attached to an existing kprobe tracepoint.
              You can only attach one BPF program per event, but you can
              have multiple events attached to a tracepoint.  Querying
              this value on one tracepoint event returns the ID of all
              BPF programs in all events attached to the tracepoint.
              You need <b>CAP_PERFMON </b>(since Linux 5.8) or <b>CAP_SYS_ADMIN</b>
              privileges to use this ioctl.

              The argument is a pointer to a structure
                  struct perf_event_query_bpf {
                      __u32    ids_len;
                      __u32    prog_cnt;
                      __u32    ids[0];
                  };

              The <i>ids_len</i> field indicates the number of ids that can fit
              in the provided <i>ids</i> array.  The <i>prog_cnt</i> value is filled
              in by the kernel with the number of attached BPF programs.
              The <i>ids</i> array is filled with the ID of each attached BPF
              program.  If there are more programs than will fit in the
              array, then the kernel will return <b>ENOSPC </b>and <i>ids_len</i> will
              indicate the number of program IDs that were successfully
              copied.

   <b>Using prctl(2)</b>
       A process can enable or disable all currently open event groups
       using the <a href="prctl.2.html">prctl(2)</a> <b>PR_TASK_PERF_EVENTS_ENABLE </b>and
       <b>PR_TASK_PERF_EVENTS_DISABLE </b>operations.  This applies only to
       events created locally by the calling process.  This does not
       apply to events created by other processes attached to the
       calling process or inherited events from a parent process.  Only
       group leaders are enabled and disabled, not any other members of
       the groups.

   <b>perf_event related configuration files</b>
       Files in <i>/proc/sys/kernel/</i>

           <i>/proc/sys/kernel/perf_event_paranoid</i>
                  The <i>perf_event_paranoid</i> file can be set to restrict
                  access to the performance counters.

                  <b>2      </b>allow only user-space measurements (default
                         since Linux 4.6).
                  <b>1      </b>allow both kernel and user measurements
                         (default before Linux 4.6).
                  <b>0      </b>allow access to CPU-specific data but not raw
                         tracepoint samples.
                  <b>-1     </b>no restrictions.

                  The existence of the <i>perf_event_paranoid</i> file is the
                  official method for determining if a kernel supports
                  <b>perf_event_open</b>().

           <i>/proc/sys/kernel/perf_event_max_sample_rate</i>
                  This sets the maximum sample rate.  Setting this too
                  high can allow users to sample at a rate that impacts
                  overall machine performance and potentially lock up
                  the machine.  The default value is 100000 (samples per
                  second).

           <i>/proc/sys/kernel/perf_event_max_stack</i>
                  This file sets the maximum depth of stack frame
                  entries reported when generating a call trace.

           <i>/proc/sys/kernel/perf_event_mlock_kb</i>
                  Maximum number of pages an unprivileged user can
                  <a href="mlock.2.html">mlock(2)</a>.  The default is 516 (kB).

       Files in <i>/sys/bus/event_source/devices/</i>

           Since Linux 2.6.34, the kernel supports having multiple PMUs
           available for monitoring.  Information on how to program
           these PMUs can be found under <i>/sys/bus/event_source/devices/</i>.
           Each subdirectory corresponds to a different PMU.

           <i>/sys/bus/event_source/devices/*/type</i> (since Linux 2.6.38)
                  This contains an integer that can be used in the <i>type</i>
                  field of <i>perf_event_attr</i> to indicate that you wish to
                  use this PMU.

           <i>/sys/bus/event_source/devices/cpu/rdpmc</i> (since Linux 3.4)
                  If this file is 1, then direct user-space access to
                  the performance counter registers is allowed via the
                  rdpmc instruction.  This can be disabled by echoing 0
                  to the file.

                  As of Linux 4.0 the behavior has changed, so that 1
                  now means only allow access to processes with active
                  perf events, with 2 indicating the old allow-anyone-
                  access behavior.

           <i>/sys/bus/event_source/devices/*/format/</i> (since Linux 3.4)
                  This subdirectory contains information on the
                  architecture-specific subfields available for
                  programming the various <i>config</i> fields in the
                  <i>perf_event_attr</i> struct.

                  The content of each file is the name of the config
                  field, followed by a colon, followed by a series of
                  integer bit ranges separated by commas.  For example,
                  the file <i>event</i> may contain the value <i>config1:1,6-10,44</i>
                  which indicates that event is an attribute that
                  occupies bits 1,6–10, and 44 of
                  <i>perf_event_attr::config1</i>.

           <i>/sys/bus/event_source/devices/*/events/</i> (since Linux 3.4)
                  This subdirectory contains files with predefined
                  events.  The contents are strings describing the event
                  settings expressed in terms of the fields found in the
                  previously mentioned <i>./format/</i> directory.  These are
                  not necessarily complete lists of all events supported
                  by a PMU, but usually a subset of events deemed useful
                  or interesting.

                  The content of each file is a list of attribute names
                  separated by commas.  Each entry has an optional value
                  (either hex or decimal).  If no value is specified,
                  then it is assumed to be a single-bit field with a
                  value of 1.  An example entry may look like this:
                  <i>event=0x2,inv,ldlat=3</i>.

           <i>/sys/bus/event_source/devices/*/uevent</i>
                  This file is the standard kernel device interface for
                  injecting hotplug events.

           <i>/sys/bus/event_source/devices/*/cpumask</i> (since Linux 3.7)
                  The <i>cpumask</i> file contains a comma-separated list of
                  integers that indicate a representative CPU number for
                  each socket (package) on the motherboard.  This is
                  needed when setting up uncore or northbridge events,
                  as those PMUs present socket-wide events.
</pre> <h2>
RETURN VALUE </h2>
<pre>
       On success, <b>perf_event_open</b>() returns the new file descriptor.
       On error, -1 is returned and <i><a href="../man3/errno.3.html">errno</a></i> is set to indicate the error.
</pre> <h2>
ERRORS </h2>
<pre>
       The errors returned by <b>perf_event_open</b>() can be inconsistent, and
       may vary across processor architectures and performance
       monitoring units.

       <b>E2BIG  </b>Returned if the <i>perf_event_attr size</i> value is too small
              (smaller than <b>PERF_ATTR_SIZE_VER0</b>), too big (larger than
              the page size), or larger than the kernel supports and the
              extra bytes are not zero.  When <b>E2BIG </b>is returned, the
              <i>perf_event_attr size</i> field is overwritten by the kernel to
              be the size of the structure it was expecting.

       <b>EACCES </b>Returned when the requested event requires <b>CAP_PERFMON</b>
              (since Linux 5.8) or <b>CAP_SYS_ADMIN </b>permissions (or a more
              permissive perf_event paranoid setting).  Some common
              cases where an unprivileged process may encounter this
              error: attaching to a process owned by a different user;
              monitoring all processes on a given CPU (i.e., specifying
              the <i>pid</i> argument as -1); and not setting <i>exclude_kernel</i>
              when the paranoid setting requires it.

       <b>EBADF  </b>Returned if the <i>group_fd</i> file descriptor is not valid, or,
              if <b>PERF_FLAG_PID_CGROUP </b>is set, the cgroup file descriptor
              in <i>pid</i> is not valid.

       <b>EBUSY </b>(since Linux 4.1)
              Returned if another event already has exclusive access to
              the PMU.

       <b>EFAULT </b>Returned if the <i>attr</i> pointer points at an invalid memory
              address.

       <b>EINTR  </b>Returned when trying to mix perf and ftrace handling for a
              uprobe.

       <b>EINVAL </b>Returned if the specified event is invalid.  There are
              many possible reasons for this.  A not-exhaustive list:
              <i>sample_freq</i> is higher than the maximum setting; the <i>cpu</i> to
              monitor does not exist; <i>read_format</i> is out of range;
              <i>sample_type</i> is out of range; the <i>flags</i> value is out of
              range; <i>exclusive</i> or <i>pinned</i> set and the event is not a
              group leader; the event <i>config</i> values are out of range or
              set reserved bits; the generic event selected is not
              supported; or there is not enough room to add the selected
              event.

       <b>EMFILE </b>Each opened event uses one file descriptor.  If a large
              number of events are opened, the per-process limit on the
              number of open file descriptors will be reached, and no
              more events can be created.

       <b>ENODEV </b>Returned when the event involves a feature not supported
              by the current CPU.

       <b>ENOENT </b>Returned if the <i>type</i> setting is not valid.  This error is
              also returned for some unsupported generic events.

       <b>ENOSPC </b>Prior to Linux 3.3, if there was not enough room for the
              event, <b>ENOSPC </b>was returned.  In Linux 3.3, this was
              changed to <b>EINVAL</b>.  <b>ENOSPC </b>is still returned if you try to
              add more breakpoint events than supported by the hardware.

       <b>ENOSYS </b>Returned if <b>PERF_SAMPLE_STACK_USER </b>is set in <i>sample_type</i>
              and it is not supported by hardware.

       <b>EOPNOTSUPP</b>
              Returned if an event requiring a specific hardware feature
              is requested but there is no hardware support.  This
              includes requesting low-skid events if not supported,
              branch tracing if it is not available, sampling if no PMU
              interrupt is available, and branch stacks for software
              events.

       <b>EOVERFLOW </b>(since Linux 4.8)
              Returned if <b>PERF_SAMPLE_CALLCHAIN </b>is requested and
              <i>sample_max_stack</i> is larger than the maximum specified in
              <i>/proc/sys/kernel/perf_event_max_stack</i>.

       <b>EPERM  </b>Returned on many (but not all) architectures when an
              unsupported <i>exclude_hv</i>, <i>exclude_idle</i>, <i>exclude_user</i>, or
              <i>exclude_kernel</i> setting is specified.

              It can also happen, as with <b>EACCES</b>, when the requested
              event requires <b>CAP_PERFMON </b>(since Linux 5.8) or
              <b>CAP_SYS_ADMIN </b>permissions (or a more permissive perf_event
              paranoid setting).  This includes setting a breakpoint on
              a kernel address, and (since Linux 3.13) setting a kernel
              function-trace tracepoint.

       <b>ESRCH  </b>Returned if attempting to attach to a process that does
              not exist.
</pre> <h2>
STANDARDS </h2>
<pre>
       Linux.
</pre> <h2>
HISTORY </h2>
<pre>
       <b>perf_event_open</b>() was introduced in Linux 2.6.31 but was called
       <b>perf_counter_open</b>().  It was renamed in Linux 2.6.32.
</pre> <h2>
NOTES </h2>
<pre>
       The official way of knowing if <b>perf_event_open</b>() support is
       enabled is checking for the existence of the file
       <i>/proc/sys/kernel/perf_event_paranoid</i>.

       <b>CAP_PERFMON </b>capability (since Linux 5.8) provides secure approach
       to performance monitoring and observability operations in a
       system according to the principal of least privilege (POSIX IEEE
       1003.1e).  Accessing system performance monitoring and
       observability operations using <b>CAP_PERFMON </b>rather than the much
       more powerful <b>CAP_SYS_ADMIN </b>excludes chances to misuse
       credentials and makes operations more secure.  <b>CAP_SYS_ADMIN</b>
       usage for secure system performance monitoring and observability
       is discouraged in favor of the <b>CAP_PERFMON </b>capability.
</pre> <h2>
BUGS </h2>
<pre>
       The <b>F_SETOWN_EX </b>option to <a href="fcntl.2.html">fcntl(2)</a> is needed to properly get
       overflow signals in threads.  This was introduced in Linux
       2.6.32.

       Prior to Linux 2.6.33 (at least for x86), the kernel did not
       check if events could be scheduled together until read time.  The
       same happens on all known kernels if the NMI watchdog is enabled.
       This means to see if a given set of events works you have to
       <b>perf_event_open</b>(), start, then read before you know for sure you
       can get valid measurements.

       Prior to Linux 2.6.34, event constraints were not enforced by the
       kernel.  In that case, some events would silently return "0" if
       the kernel scheduled them in an improper counter slot.

       Prior to Linux 2.6.34, there was a bug when multiplexing where
       the wrong results could be returned.

       Kernels from Linux 2.6.35 to Linux 2.6.39 can quickly crash the
       kernel if "inherit" is enabled and many threads are started.

       Prior to Linux 2.6.35, <b>PERF_FORMAT_GROUP </b>did not work with
       attached processes.

       There is a bug in the kernel code between Linux 2.6.36 and Linux
       3.0 that ignores the "watermark" field and acts as if a
       wakeup_event was chosen if the union has a nonzero value in it.

       From Linux 2.6.31 to Linux 3.4, the <b>PERF_IOC_FLAG_GROUP </b>ioctl
       argument was broken and would repeatedly operate on the event
       specified rather than iterating across all sibling events in a
       group.

       From Linux 3.4 to Linux 3.11, the mmap <i>cap_usr_rdpmc</i> and
       <i>cap_usr_time</i> bits mapped to the same location.  Code should
       migrate to the new <i>cap_user_rdpmc</i> and <i>cap_user_time</i> fields
       instead.

       Always double-check your results!  Various generalized events
       have had wrong values.  For example, retired branches measured
       the wrong thing on AMD machines until Linux 2.6.35.
</pre> <h2>
EXAMPLES </h2>
<pre>
       The following is a short example that measures the total
       instruction count of a call to <a href="../man3/printf.3.html">printf(3)</a>.

       #include &lt;linux/perf_event.h&gt;
       #include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;string.h&gt;
       #include &lt;sys/ioctl.h&gt;
       #include &lt;sys/syscall.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;unistd.h&gt;

       static long
       perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
                       int cpu, int group_fd, unsigned long flags)
       {
           int ret;

           ret = syscall(SYS_perf_event_open, hw_event, pid, cpu,
                         group_fd, flags);
           return ret;
       }

       int
       main(void)
       {
           int                     fd;
           long long               count;
           struct perf_event_attr  pe;

           memset(&amp;pe, 0, sizeof(pe));
           pe.type = PERF_TYPE_HARDWARE;
           pe.size = sizeof(pe);
           pe.config = PERF_COUNT_HW_INSTRUCTIONS;
           pe.disabled = 1;
           pe.exclude_kernel = 1;
           pe.exclude_hv = 1;

           fd = perf_event_open(&amp;pe, 0, -1, -1, 0);
           if (fd == -1) {
              fprintf(stderr, "Error opening leader %llx\n", pe.config);
              exit(EXIT_FAILURE);
           }

           ioctl(fd, PERF_EVENT_IOC_RESET, 0);
           ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);

           printf("Measuring instruction count for this printf\n");

           ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);
           read(fd, &amp;count, sizeof(count));

           printf("Used %lld instructions\n", count);

           close(fd);
       }
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man1/perf.1.html">perf(1)</a>, <a href="fcntl.2.html">fcntl(2)</a>, <a href="mmap.2.html">mmap(2)</a>, <a href="open.2.html">open(2)</a>, <a href="prctl.2.html">prctl(2)</a>, <a href="read.2.html">read(2)</a>

       <i>Documentation/admin-guide/perf-security.rst</i> in the kernel source
       tree
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       ⟨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>⟩.  If you have a bug report
       for this manual page, see
       ⟨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>⟩.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       ⟨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>⟩ on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-06-15             <i>perf_event_open</i>(2)</span>
</pre>  <p>Pages that refer to this page: <a href="bpf.2.html">bpf(2)</a>, <a href="gettid.2.html">gettid(2)</a>, <a href="mount_setattr.2.html">mount_setattr(2)</a>, <a href="openat2.2.html">openat2(2)</a>, <a href="syscalls.2.html">syscalls(2)</a>, <a href="../man3/stapprobes.3stap.html">stapprobes(3stap)</a>, <a href="../man5/proc_pid_fd.5.html">proc_pid_fd(5)</a>, <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>, <a href="../man7/bpf-helpers.7.html">bpf-helpers(7)</a>, <a href="../man7/capabilities.7.html">capabilities(7)</a>, <a href="../man7/cgroups.7.html">cgroups(7)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man2/perf_event_open.2.html" class="_attribution-link">https://man7.org/linux/man-pages/man2/perf_event_open.2.html</a>
  </p>
</div>
