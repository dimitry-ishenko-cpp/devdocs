<h1>seccomp_unotify(2) — Linux manual page</h1>   <pre>
<span class="headline"><i>seccomp_unotify</i>(2)         System Calls Manual        <i>seccomp_unotify</i>(2)</span>
</pre> <h2>
NAME </h2>
<pre>
       seccomp_unotify - Seccomp user-space notification mechanism
</pre> <h2>
LIBRARY </h2>
<pre>
       Standard C library (<i>libc</i>, <i>-lc</i>)
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;linux/seccomp.h&gt;</b>
       <b>#include &lt;linux/filter.h&gt;</b>
       <b>#include &lt;linux/audit.h&gt;</b>

       <b>int seccomp(unsigned int </b><i>operation</i><b>, unsigned int </b><i>flags</i><b>, void *</b><i>args</i><b>);</b>

       <b>#include &lt;sys/ioctl.h&gt;</b>

       <b>int ioctl(int </b><i>fd</i><b>, SECCOMP_IOCTL_NOTIF_RECV,</b>
                 <b>struct seccomp_notif *</b><i>req</i><b>);</b>
       <b>int ioctl(int </b><i>fd</i><b>, SECCOMP_IOCTL_NOTIF_SEND,</b>
                 <b>struct seccomp_notif_resp *</b><i>resp</i><b>);</b>
       <b>int ioctl(int </b><i>fd</i><b>, SECCOMP_IOCTL_NOTIF_ID_VALID, __u64 *</b><i>id</i><b>);</b>
       <b>int ioctl(int </b><i>fd</i><b>, SECCOMP_IOCTL_NOTIF_ADDFD,</b>
                 <b>struct seccomp_notif_addfd *</b><i>addfd</i><b>);</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       This page describes the user-space notification mechanism
       provided by the Secure Computing (seccomp) facility.  As well as
       the use of the <b>SECCOMP_FILTER_FLAG_NEW_LISTENER </b>flag, the
       <b>SECCOMP_RET_USER_NOTIF </b>action value, and the
       <b>SECCOMP_GET_NOTIF_SIZES </b>operation described in <a href="seccomp.2.html">seccomp(2)</a>, this
       mechanism involves the use of a number of related <a href="ioctl.2.html">ioctl(2)</a>
       operations (described below).

   <b>Overview</b>
       In conventional usage of a seccomp filter, the decision about how
       to treat a system call is made by the filter itself.  By
       contrast, the user-space notification mechanism allows the
       seccomp filter to delegate the handling of the system call to
       another user-space process.  Note that this mechanism is
       explicitly <b>not </b>intended as a method implementing security policy;
       see NOTES.

       In the discussion that follows, the thread(s) on which the
       seccomp filter is installed is (are) referred to as the <i>target</i>,
       and the process that is notified by the user-space notification
       mechanism is referred to as the <i>supervisor</i>.

       A suitably privileged supervisor can use the user-space
       notification mechanism to perform actions on behalf of the
       target.  The advantage of the user-space notification mechanism
       is that the supervisor will usually be able to retrieve
       information about the target and the performed system call that
       the seccomp filter itself cannot.  (A seccomp filter is limited
       in the information it can obtain and the actions that it can
       perform because it is running on a virtual machine inside the
       kernel.)

       An overview of the steps performed by the target and the
       supervisor is as follows:

       (1)  The target establishes a seccomp filter in the usual manner,
            but with two differences:

            •  The <a href="seccomp.2.html">seccomp(2)</a> <i>flags</i> argument includes the flag
               <b>SECCOMP_FILTER_FLAG_NEW_LISTENER</b>.  Consequently, the
               return value of the (successful) <a href="seccomp.2.html">seccomp(2)</a> call is a new
               "listening" file descriptor that can be used to receive
               notifications.  Only one "listening" seccomp filter can
               be installed for a thread.

            •  In cases where it is appropriate, the seccomp filter
               returns the action value <b>SECCOMP_RET_USER_NOTIF</b>.  This
               return value will trigger a notification event.

       (2)  In order that the supervisor can obtain notifications using
            the listening file descriptor, (a duplicate of) that file
            descriptor must be passed from the target to the supervisor.
            One way in which this could be done is by passing the file
            descriptor over a UNIX domain socket connection between the
            target and the supervisor (using the <b>SCM_RIGHTS </b>ancillary
            message type described in <a href="../man7/unix.7.html">unix(7)</a>).  Another way to do this
            is through the use of <a href="pidfd_getfd.2.html">pidfd_getfd(2)</a>.

       (3)  The supervisor will receive notification events on the
            listening file descriptor.  These events are returned as
            structures of type <i>seccomp_notif</i>.  Because this structure
            and its size may evolve over kernel versions, the supervisor
            must first determine the size of this structure using the
            <a href="seccomp.2.html">seccomp(2)</a> <b>SECCOMP_GET_NOTIF_SIZES </b>operation, which returns
            a structure of type <i>seccomp_notif_sizes</i>.  The supervisor
            allocates a buffer of size <i>seccomp_notif_sizes.seccomp_notif</i>
            bytes to receive notification events.  In addition,the
            supervisor allocates another buffer of size
            <i>seccomp_notif_sizes.seccomp_notif_resp</i> bytes for the
            response (a <i>struct seccomp_notif_resp</i> structure) that it
            will provide to the kernel (and thus the target).

       (4)  The target then performs its workload, which includes system
            calls that will be controlled by the seccomp filter.
            Whenever one of these system calls causes the filter to
            return the <b>SECCOMP_RET_USER_NOTIF </b>action value, the kernel
            does <i>not</i> (yet) execute the system call; instead, execution
            of the target is temporarily blocked inside the kernel (in a
            sleep state that is interruptible by signals) and a
            notification event is generated on the listening file
            descriptor.

       (5)  The supervisor can now repeatedly monitor the listening file
            descriptor for <b>SECCOMP_RET_USER_NOTIF</b>-triggered events.  To
            do this, the supervisor uses the <b>SECCOMP_IOCTL_NOTIF_RECV</b>
            <a href="ioctl.2.html">ioctl(2)</a> operation to read information about a notification
            event; this operation blocks until an event is available.
            The operation returns a <i>seccomp_notif</i> structure containing
            information about the system call that is being attempted by
            the target.  (As described in NOTES, the file descriptor can
            also be monitored with <a href="select.2.html">select(2)</a>, <a href="poll.2.html">poll(2)</a>, or <a href="../man7/epoll.7.html">epoll(7)</a>.)

       (6)  The <i>seccomp_notif</i> structure returned by the
            <b>SECCOMP_IOCTL_NOTIF_RECV </b>operation includes the same
            information (a <i>seccomp_data</i> structure) that was passed to
            the seccomp filter.  This information allows the supervisor
            to discover the system call number and the arguments for the
            target's system call.  In addition, the notification event
            contains the ID of the thread that triggered the
            notification and a unique cookie value that is used in
            subsequent <b>SECCOMP_IOCTL_NOTIF_ID_VALID </b>and
            <b>SECCOMP_IOCTL_NOTIF_SEND </b>operations.

            The information in the notification can be used to discover
            the values of pointer arguments for the target's system
            call.  (This is something that can't be done from within a
            seccomp filter.)  One way in which the supervisor can do
            this is to open the corresponding <i>/proc/</i>tid<i>/mem</i> file (see
            <a href="../man5/proc.5.html">proc(5)</a>) and read bytes from the location that corresponds
            to one of the pointer arguments whose value is supplied in
            the notification event.  (The supervisor must be careful to
            avoid a race condition that can occur when doing this; see
            the description of the <b>SECCOMP_IOCTL_NOTIF_ID_VALID ioctl</b>(2)
            operation below.)  In addition, the supervisor can access
            other system information that is visible in user space but
            which is not accessible from a seccomp filter.

       (7)  Having obtained information as per the previous step, the
            supervisor may then choose to perform an action in response
            to the target's system call (which, as noted above, is not
            executed when the seccomp filter returns the
            <b>SECCOMP_RET_USER_NOTIF </b>action value).

            One example use case here relates to containers.  The target
            may be located inside a container where it does not have
            sufficient capabilities to mount a filesystem in the
            container's mount namespace.  However, the supervisor may be
            a more privileged process that does have sufficient
            capabilities to perform the mount operation.

       (8)  The supervisor then sends a response to the notification.
            The information in this response is used by the kernel to
            construct a return value for the target's system call and
            provide a value that will be assigned to the <i><a href="../man3/errno.3.html">errno</a></i> variable
            of the target.

            The response is sent using the <b>SECCOMP_IOCTL_NOTIF_SEND</b>
            <a href="ioctl.2.html">ioctl(2)</a> operation, which is used to transmit a
            <i>seccomp_notif_resp</i> structure to the kernel.  This structure
            includes a cookie value that the supervisor obtained in the
            <i>seccomp_notif</i> structure returned by the
            <b>SECCOMP_IOCTL_NOTIF_RECV </b>operation.  This cookie value
            allows the kernel to associate the response with the target.
            This structure must include the cookie value that the
            supervisor obtained in the <i>seccomp_notif</i> structure returned
            by the <b>SECCOMP_IOCTL_NOTIF_RECV </b>operation; the cookie allows
            the kernel to associate the response with the target.

       (9)  Once the notification has been sent, the system call in the
            target thread unblocks, returning the information that was
            provided by the supervisor in the notification response.

       As a variation on the last two steps, the supervisor can send a
       response that tells the kernel that it should execute the target
       thread's system call; see the discussion of
       <b>SECCOMP_USER_NOTIF_FLAG_CONTINUE</b>, below.
</pre> <h2>
IOCTL OPERATIONS </h2>
<pre>
       The following <a href="ioctl.2.html">ioctl(2)</a> operations are supported by the seccomp
       user-space notification file descriptor.  For each of these
       operations, the first (file descriptor) argument of <a href="ioctl.2.html">ioctl(2)</a> is
       the listening file descriptor returned by a call to <a href="seccomp.2.html">seccomp(2)</a>
       with the <b>SECCOMP_FILTER_FLAG_NEW_LISTENER </b>flag.

   <b>SECCOMP_IOCTL_NOTIF_RECV</b>
       The <b>SECCOMP_IOCTL_NOTIF_RECV </b>operation (available since Linux
       5.0) is used to obtain a user-space notification event.  If no
       such event is currently pending, the operation blocks until an
       event occurs.  The third <a href="ioctl.2.html">ioctl(2)</a> argument is a pointer to a
       structure of the following form which contains information about
       the event.  This structure must be zeroed out before the call.

           struct seccomp_notif {
               __u64  id;              /* Cookie */
               __u32  pid;             /* TID of target thread */
               __u32  flags;           /* Currently unused (0) */
               struct seccomp_data data;   /* See seccomp(2) */
           };

       The fields in this structure are as follows:

       <i>id</i>     This is a cookie for the notification.  Each such cookie
              is guaranteed to be unique for the corresponding seccomp
              filter.

              •  The cookie can be used with the
                 <b>SECCOMP_IOCTL_NOTIF_ID_VALID ioctl</b>(2) operation
                 described below.

              •  When returning a notification response to the kernel,
                 the supervisor must include the cookie value in the
                 <i>seccomp_notif_resp</i> structure that is specified as the
                 argument of the <b>SECCOMP_IOCTL_NOTIF_SEND </b>operation.

       <i>pid</i>    This is the thread ID of the target thread that triggered
              the notification event.

       <i>flags</i>  This is a bit mask of flags providing further information
              on the event.  In the current implementation, this field
              is always zero.

       <i>data</i>   This is a <i>seccomp_data</i> structure containing information
              about the system call that triggered the notification.
              This is the same structure that is passed to the seccomp
              filter.  See <a href="seccomp.2.html">seccomp(2)</a> for details of this structure.

       On success, this operation returns 0; on failure, -1 is returned,
       and <i><a href="../man3/errno.3.html">errno</a></i> is set to indicate the cause of the error.  This
       operation can fail with the following errors:

       <b>EINVAL </b>(since Linux 5.5)
              The <i>seccomp_notif</i> structure that was passed to the call
              contained nonzero fields.

       <b>ENOENT </b>The target thread was killed by a signal as the
              notification information was being generated, or the
              target's (blocked) system call was interrupted by a signal
              handler.

   <b>SECCOMP_IOCTL_NOTIF_ID_VALID</b>
       The <b>SECCOMP_IOCTL_NOTIF_ID_VALID </b>operation (available since Linux
       5.0) is used to check that a notification ID returned by an
       earlier <b>SECCOMP_IOCTL_NOTIF_RECV </b>operation is still valid (i.e.,
       that the target still exists and its system call is still blocked
       waiting for a response).

       The third <a href="ioctl.2.html">ioctl(2)</a> argument is a pointer to the cookie (<i>id</i>)
       returned by the <b>SECCOMP_IOCTL_NOTIF_RECV </b>operation.

       This operation is necessary to avoid race conditions that can
       occur when the <i>pid</i> returned by the <b>SECCOMP_IOCTL_NOTIF_RECV</b>
       operation terminates, and that process ID is reused by another
       process.  An example of this kind of race is the following

       (1)  A notification is generated on the listening file
            descriptor.  The returned <i>seccomp_notif</i> contains the TID of
            the target thread (in the <i>pid</i> field of the structure).

       (2)  The target terminates.

       (3)  Another thread or process is created on the system that by
            chance reuses the TID that was freed when the target
            terminated.

       (4)  The supervisor <a href="open.2.html">open(2)</a>s the <i>/proc/</i>tid<i>/mem</i> file for the TID
            obtained in step 1, with the intention of (say) inspecting
            the memory location(s) that containing the argument(s) of
            the system call that triggered the notification in step 1.

       In the above scenario, the risk is that the supervisor may try to
       access the memory of a process other than the target.  This race
       can be avoided by following the call to <a href="open.2.html">open(2)</a> with a
       <b>SECCOMP_IOCTL_NOTIF_ID_VALID </b>operation to verify that the process
       that generated the notification is still alive.  (Note that if
       the target terminates after the latter step, a subsequent <a href="read.2.html">read(2)</a>
       from the file descriptor may return 0, indicating end of file.)

       See NOTES for a discussion of other cases where
       <b>SECCOMP_IOCTL_NOTIF_ID_VALID </b>checks must be performed.

       On success (i.e., the notification ID is still valid), this
       operation returns 0.  On failure (i.e., the notification ID is no
       longer valid), -1 is returned, and <i><a href="../man3/errno.3.html">errno</a></i> is set to <b>ENOENT</b>.

   <b>SECCOMP_IOCTL_NOTIF_SEND</b>
       The <b>SECCOMP_IOCTL_NOTIF_SEND </b>operation (available since Linux
       5.0) is used to send a notification response back to the kernel.
       The third <a href="ioctl.2.html">ioctl(2)</a> argument of this structure is a pointer to a
       structure of the following form:

           struct seccomp_notif_resp {
               __u64 id;           /* Cookie value */
               __s64 val;          /* Success return value */
               __s32 error;        /* 0 (success) or negative error number */
               __u32 flags;        /* See below */
           };

       The fields of this structure are as follows:

       <i>id</i>     This is the cookie value that was obtained using the
              <b>SECCOMP_IOCTL_NOTIF_RECV </b>operation.  This cookie value
              allows the kernel to correctly associate this response
              with the system call that triggered the user-space
              notification.

       <i>val</i>    This is the value that will be used for a spoofed success
              return for the target's system call; see below.

       <i>error</i>  This is the value that will be used as the error number
              (<i><a href="../man3/errno.3.html">errno</a></i>) for a spoofed error return for the target's system
              call; see below.

       <i>flags</i>  This is a bit mask that includes zero or more of the
              following flags:

              <b>SECCOMP_USER_NOTIF_FLAG_CONTINUE </b>(since Linux 5.5)
                     Tell the kernel to execute the target's system
                     call.

       Two kinds of response are possible:

       •  A response to the kernel telling it to execute the target's
          system call.  In this case, the <i>flags</i> field includes
          <b>SECCOMP_USER_NOTIF_FLAG_CONTINUE </b>and the <i>error</i> and <i>val</i> fields
          must be zero.

          This kind of response can be useful in cases where the
          supervisor needs to do deeper analysis of the target's system
          call than is possible from a seccomp filter (e.g., examining
          the values of pointer arguments), and, having decided that the
          system call does not require emulation by the supervisor, the
          supervisor wants the system call to be executed normally in
          the target.

          The <b>SECCOMP_USER_NOTIF_FLAG_CONTINUE </b>flag should be used with
          caution; see NOTES.

       •  A spoofed return value for the target's system call.  In this
          case, the kernel does not execute the target's system call,
          instead causing the system call to return a spoofed value as
          specified by fields of the <i>seccomp_notif_resp</i> structure.  The
          supervisor should set the fields of this structure as follows:

          •  <i>flags</i> does not contain <b>SECCOMP_USER_NOTIF_FLAG_CONTINUE</b>.

          •  <i>error</i> is set either to 0 for a spoofed "success" return or
             to a negative error number for a spoofed "failure" return.
             In the former case, the kernel causes the target's system
             call to return the value specified in the <i>val</i> field.  In
             the latter case, the kernel causes the target's system call
             to return -1, and <i><a href="../man3/errno.3.html">errno</a></i> is assigned the negated <i>error</i>
             value.

          •  <i>val</i> is set to a value that will be used as the return value
             for a spoofed "success" return for the target's system
             call.  The value in this field is ignored if the <i>error</i>
             field contains a nonzero value.

       On success, this operation returns 0; on failure, -1 is returned,
       and <i><a href="../man3/errno.3.html">errno</a></i> is set to indicate the cause of the error.  This
       operation can fail with the following errors:

       <b>EINPROGRESS</b>
              A response to this notification has already been sent.

       <b>EINVAL </b>An invalid value was specified in the <i>flags field.</i>

       <b>EINVAL </b>The <i>flags</i> field contained
              <b>SECCOMP_USER_NOTIF_FLAG_CONTINUE</b>, and the <i>error</i> or <i>val</i>
              field was not zero.

       <b>ENOENT </b>The blocked system call in the target has been interrupted
              by a signal handler or the target has terminated.

   <b>SECCOMP_IOCTL_NOTIF_ADDFD</b>
       The <b>SECCOMP_IOCTL_NOTIF_ADDFD </b>operation (available since Linux
       5.9) allows the supervisor to install a file descriptor into the
       target's file descriptor table.  Much like the use of <b>SCM_RIGHTS</b>
       messages described in <a href="../man7/unix.7.html">unix(7)</a>, this operation is semantically
       equivalent to duplicating a file descriptor from the supervisor's
       file descriptor table into the target's file descriptor table.

       The <b>SECCOMP_IOCTL_NOTIF_ADDFD </b>operation permits the supervisor to
       emulate a target system call (such as <a href="socket.2.html">socket(2)</a> or <a href="openat.2.html">openat(2)</a>)
       that generates a file descriptor.  The supervisor can perform the
       system call that generates the file descriptor (and associated
       open file description) and then use this operation to allocate a
       file descriptor that refers to the same open file description in
       the target.  (For an explanation of open file descriptions, see
       <a href="open.2.html">open(2)</a>.)

       Once this operation has been performed, the supervisor can close
       its copy of the file descriptor.

       In the target, the received file descriptor is subject to the
       same Linux Security Module (LSM) checks as are applied to a file
       descriptor that is received in an <b>SCM_RIGHTS </b>ancillary message.
       If the file descriptor refers to a socket, it inherits the cgroup
       version 1 network controller settings (<i>classid</i> and <i>netprioidx</i>) of
       the target.

       The third <a href="ioctl.2.html">ioctl(2)</a> argument is a pointer to a structure of the
       following form:

           struct seccomp_notif_addfd {
               __u64 id;           /* Cookie value */
               __u32 flags;        /* Flags */
               __u32 srcfd;        /* Local file descriptor number */
               __u32 newfd;        /* 0 or desired file descriptor
                                      number in target */
               __u32 newfd_flags;  /* Flags to set on target file
                                      descriptor */
           };

       The fields in this structure are as follows:

       <i>id</i>     This field should be set to the notification ID (cookie
              value) that was obtained via <b>SECCOMP_IOCTL_NOTIF_RECV</b>.

       <i>flags</i>  This field is a bit mask of flags that modify the behavior
              of the operation.  Currently, only one flag is supported:

              <b>SECCOMP_ADDFD_FLAG_SETFD</b>
                     When allocating the file descriptor in the target,
                     use the file descriptor number specified in the
                     <i>newfd</i> field.

              <b>SECCOMP_ADDFD_FLAG_SEND </b>(since Linux 5.14)
                     Perform the equivalent of <b>SECCOMP_IOCTL_NOTIF_ADDFD</b>
                     plus <b>SECCOMP_IOCTL_NOTIF_SEND </b>as an atomic
                     operation.  On successful invocation, the target
                     process's <i><a href="../man3/errno.3.html">errno</a></i> will be 0 and the return value will
                     be the file descriptor number that was allocated in
                     the target.  If allocating the file descriptor in
                     the target fails, the target's system call
                     continues to be blocked until a successful response
                     is sent.

       <i>srcfd</i>  This field should be set to the number of the file
              descriptor in the supervisor that is to be duplicated.

       <i>newfd</i>  This field determines which file descriptor number is
              allocated in the target.  If the <b>SECCOMP_ADDFD_FLAG_SETFD</b>
              flag is set, then this field specifies which file
              descriptor number should be allocated.  If this file
              descriptor number is already open in the target, it is
              atomically closed and reused.  If the descriptor
              duplication fails due to an LSM check, or if <i>srcfd</i> is not
              a valid file descriptor, the file descriptor <i>newfd</i> will
              not be closed in the target process.

              If the <b>SECCOMP_ADDFD_FLAG_SETFD </b>flag it not set, then this
              field must be 0, and the kernel allocates the lowest
              unused file descriptor number in the target.

       <i>newfd_flags</i>
              This field is a bit mask specifying flags that should be
              set on the file descriptor that is received in the target
              process.  Currently, only the following flag is
              implemented:

              <b>O_CLOEXEC</b>
                     Set the close-on-exec flag on the received file
                     descriptor.

       On success, this <a href="ioctl.2.html">ioctl(2)</a> call returns the number of the file
       descriptor that was allocated in the target.  Assuming that the
       emulated system call is one that returns a file descriptor as its
       function result (e.g., <a href="socket.2.html">socket(2)</a>), this value can be used as the
       return value (<i>resp.val</i>) that is supplied in the response that is
       subsequently sent with the <b>SECCOMP_IOCTL_NOTIF_SEND </b>operation.

       On error, -1 is returned and <i><a href="../man3/errno.3.html">errno</a></i> is set to indicate the cause
       of the error.

       This operation can fail with the following errors:

       <b>EBADF  </b>Allocating the file descriptor in the target would cause
              the target's <b>RLIMIT_NOFILE </b>limit to be exceeded (see
              <a href="getrlimit.2.html">getrlimit(2)</a>).

       <b>EBUSY  </b>If the flag <b>SECCOMP_IOCTL_NOTIF_SEND </b>is used, this means
              the operation can't proceed until other
              <b>SECCOMP_IOCTL_NOTIF_ADDFD </b>requests are processed.

       <b>EINPROGRESS</b>
              The user-space notification specified in the <i>id</i> field
              exists but has not yet been fetched (by a
              <b>SECCOMP_IOCTL_NOTIF_RECV</b>) or has already been responded to
              (by a <b>SECCOMP_IOCTL_NOTIF_SEND</b>).

       <b>EINVAL </b>An invalid flag was specified in the <i>flags</i> or <i>newfd_flags</i>
              field, or the <i>newfd</i> field is nonzero and the
              <b>SECCOMP_ADDFD_FLAG_SETFD </b>flag was not specified in the
              <i>flags</i> field.

       <b>EMFILE </b>The file descriptor number specified in <i>newfd</i> exceeds the
              limit specified in <i>/proc/sys/fs/nr_open</i>.

       <b>ENOENT </b>The blocked system call in the target has been interrupted
              by a signal handler or the target has terminated.

       Here is some sample code (with error handling omitted) that uses
       the <b>SECCOMP_ADDFD_FLAG_SETFD </b>operation (here, to emulate a call
       to <a href="openat.2.html">openat(2)</a>):

           int fd, removeFd;

           fd = openat(req-&gt;data.args[0], path, req-&gt;data.args[2],
                           req-&gt;data.args[3]);

           struct seccomp_notif_addfd addfd;
           addfd.id = req-&gt;id; /* Cookie from SECCOMP_IOCTL_NOTIF_RECV */
           addfd.srcfd = fd;
           addfd.newfd = 0;
           addfd.flags = 0;
           addfd.newfd_flags = O_CLOEXEC;

           targetFd = ioctl(notifyFd, SECCOMP_IOCTL_NOTIF_ADDFD, &amp;addfd);

           close(fd);          /* No longer needed in supervisor */

           struct seccomp_notif_resp *resp;
               /* Code to allocate 'resp' omitted */
           resp-&gt;id = req-&gt;id;
           resp-&gt;error = 0;        /* "Success" */
           resp-&gt;val = targetFd;
           resp-&gt;flags = 0;
           ioctl(notifyFd, SECCOMP_IOCTL_NOTIF_SEND, resp);
</pre> <h2>
NOTES </h2>
<pre>
       One example use case for the user-space notification mechanism is
       to allow a container manager (a process which is typically
       running with more privilege than the processes inside the
       container) to mount block devices or create device nodes for the
       container.  The mount use case provides an example of where the
       <b>SECCOMP_USER_NOTIF_FLAG_CONTINUE ioctl</b>(2) operation is useful.
       Upon receiving a notification for the <a href="mount.2.html">mount(2)</a> system call, the
       container manager (the "supervisor") can distinguish a request to
       mount a block filesystem (which would not be possible for a
       "target" process inside the container) and mount that file
       system.  If, on the other hand, the container manager detects
       that the operation could be performed by the process inside the
       container (e.g., a mount of a <a href="../man5/tmpfs.5.html">tmpfs(5)</a> filesystem), it can notify
       the kernel that the target process's <a href="mount.2.html">mount(2)</a> system call can
       continue.

   <b>select()/poll()/epoll semantics</b>
       The file descriptor returned when <a href="seccomp.2.html">seccomp(2)</a> is employed with the
       <b>SECCOMP_FILTER_FLAG_NEW_LISTENER </b>flag can be monitored using
       <a href="poll.2.html">poll(2)</a>, <a href="../man7/epoll.7.html">epoll(7)</a>, and <a href="select.2.html">select(2)</a>.  These interfaces indicate that
       the file descriptor is ready as follows:

       •  When a notification is pending, these interfaces indicate that
          the file descriptor is readable.  Following such an
          indication, a subsequent <b>SECCOMP_IOCTL_NOTIF_RECV ioctl</b>(2)
          will not block, returning either information about a
          notification or else failing with the error <b>EINTR </b>if the
          target has been killed by a signal or its system call has been
          interrupted by a signal handler.

       •  After the notification has been received (i.e., by the
          <b>SECCOMP_IOCTL_NOTIF_RECV ioctl</b>(2) operation), these interfaces
          indicate that the file descriptor is writable, meaning that a
          notification response can be sent using the
          <b>SECCOMP_IOCTL_NOTIF_SEND ioctl</b>(2) operation.

       •  After the last thread using the filter has terminated and been
          reaped using <a href="waitpid.2.html">waitpid(2)</a> (or similar), the file descriptor
          indicates an end-of-file condition (readable in <a href="select.2.html">select(2)</a>;
          <b>POLLHUP</b>/<b>EPOLLHUP </b>in <a href="poll.2.html">poll(2)</a>/ <a href="epoll_wait.2.html">epoll_wait(2)</a>).

   <b>Design goals; use of SECCOMP_USER_NOTIF_FLAG_CONTINUE</b>
       The intent of the user-space notification feature is to allow
       system calls to be performed on behalf of the target.  The
       target's system call should either be handled by the supervisor
       or allowed to continue normally in the kernel (where standard
       security policies will be applied).

       <b>Note well</b>: this mechanism must not be used to make security
       policy decisions about the system call, which would be inherently
       race-prone for reasons described next.

       The <b>SECCOMP_USER_NOTIF_FLAG_CONTINUE </b>flag must be used with
       caution.  If set by the supervisor, the target's system call will
       continue.  However, there is a time-of-check, time-of-use race
       here, since an attacker could exploit the interval of time where
       the target is blocked waiting on the "continue" response to do
       things such as rewriting the system call arguments.

       Note furthermore that a user-space notifier can be bypassed if
       the existing filters allow the use of <a href="seccomp.2.html">seccomp(2)</a> or <a href="prctl.2.html">prctl(2)</a> to
       install a filter that returns an action value with a higher
       precedence than <b>SECCOMP_RET_USER_NOTIF </b>(see <a href="seccomp.2.html">seccomp(2)</a>).

       It should thus be absolutely clear that the seccomp user-space
       notification mechanism <b>can not </b>be used to implement a security
       policy!  It should only ever be used in scenarios where a more
       privileged process supervises the system calls of a lesser
       privileged target to get around kernel-enforced security
       restrictions when the supervisor deems this safe.  In other
       words, in order to continue a system call, the supervisor should
       be sure that another security mechanism or the kernel itself will
       sufficiently block the system call if its arguments are rewritten
       to something unsafe.

   [1mCaveats regarding the use of <i>/proc/</i>tid<i>/mem</i>
       The discussion above noted the need to use the
       <b>SECCOMP_IOCTL_NOTIF_ID_VALID ioctl</b>(2) when opening the
       <i>/proc/</i>tid<i>/mem</i> file of the target to avoid the possibility of
       accessing the memory of the wrong process in the event that the
       target terminates and its ID is recycled by another (unrelated)
       thread.  However, the use of this <a href="ioctl.2.html">ioctl(2)</a> operation is also
       necessary in other situations, as explained in the following
       paragraphs.

       Consider the following scenario, where the supervisor tries to
       read the pathname argument of a target's blocked <a href="mount.2.html">mount(2)</a> system
       call:

       (1)  From one of its functions (<i>func()</i>), the target calls
            <a href="mount.2.html">mount(2)</a>, which triggers a user-space notification and
            causes the target to block.

       (2)  The supervisor receives the notification, opens
            <i>/proc/</i>tid<i>/mem</i>, and (successfully) performs the
            <b>SECCOMP_IOCTL_NOTIF_ID_VALID </b>check.

       (3)  The target receives a signal, which causes the <a href="mount.2.html">mount(2)</a> to
            abort.

       (4)  The signal handler executes in the target, and returns.

       (5)  Upon return from the handler, the execution of <i>func()</i>
            resumes, and it returns (and perhaps other functions are
            called, overwriting the memory that had been used for the
            stack frame of <i>func()</i>).

       (6)  Using the address provided in the notification information,
            the supervisor reads from the target's memory location that
            used to contain the pathname.

       (7)  The supervisor now calls <a href="mount.2.html">mount(2)</a> with some arbitrary bytes
            obtained in the previous step.

       The conclusion from the above scenario is this: since the
       target's blocked system call may be interrupted by a signal
       handler, the supervisor must be written to expect that the target
       may abandon its system call at <b>any </b>time; in such an event, any
       information that the supervisor obtained from the target's memory
       must be considered invalid.

       To prevent such scenarios, every read from the target's memory
       must be separated from use of the bytes so obtained by a
       <b>SECCOMP_IOCTL_NOTIF_ID_VALID </b>check.  In the above example, the
       check would be placed between the two final steps.  An example of
       such a check is shown in EXAMPLES.

       Following on from the above, it should be clear that a write by
       the supervisor into the target's memory can <b>never </b>be considered
       safe.

   <b>Caveats regarding blocking system calls</b>
       Suppose that the target performs a blocking system call (e.g.,
       <a href="accept.2.html">accept(2)</a>) that the supervisor should handle.  The supervisor
       might then in turn execute the same blocking system call.

       In this scenario, it is important to note that if the target's
       system call is now interrupted by a signal, the supervisor is <i>not</i>
       informed of this.  If the supervisor does not take suitable steps
       to actively discover that the target's system call has been
       canceled, various difficulties can occur.  Taking the example of
       <a href="accept.2.html">accept(2)</a>, the supervisor might remain blocked in its <a href="accept.2.html">accept(2)</a>
       holding a port number that the target (which, after the
       interruption by the signal handler, perhaps closed  its listening
       socket) might expect to be able to reuse in a <a href="bind.2.html">bind(2)</a> call.

       Therefore, when the supervisor wishes to emulate a blocking
       system call, it must do so in such a way that it gets informed if
       the target's system call is interrupted by a signal handler.  For
       example, if the supervisor itself executes the same blocking
       system call, then it could employ a separate thread that uses the
       <b>SECCOMP_IOCTL_NOTIF_ID_VALID </b>operation to check if the target is
       still blocked in its system call.  Alternatively, in the
       <a href="accept.2.html">accept(2)</a> example, the supervisor might use <a href="poll.2.html">poll(2)</a> to monitor
       both the notification file descriptor (so as to discover when the
       target's <a href="accept.2.html">accept(2)</a> call has been interrupted) and the listening
       file descriptor (so as to know when a connection is available).

       If the target's system call is interrupted, the supervisor must
       take care to release resources (e.g., file descriptors) that it
       acquired on behalf of the target.

   <b>Interaction with SA_RESTART signal handlers</b>
       Consider the following scenario:

       (1)  The target process has used <a href="sigaction.2.html">sigaction(2)</a> to install a signal
            handler with the <b>SA_RESTART </b>flag.

       (2)  The target has made a system call that triggered a seccomp
            user-space notification and the target is currently blocked
            until the supervisor sends a notification response.

       (3)  A signal is delivered to the target and the signal handler
            is executed.

       (4)  When (if) the supervisor attempts to send a notification
            response, the <b>SECCOMP_IOCTL_NOTIF_SEND ioctl</b>(2)) operation
            will fail with the <b>ENOENT </b>error.

       In this scenario, the kernel will restart the target's system
       call.  Consequently, the supervisor will receive another user-
       space notification.  Thus, depending on how many times the
       blocked system call is interrupted by a signal handler, the
       supervisor may receive multiple notifications for the same
       instance of a system call in the target.

       One oddity is that system call restarting as described in this
       scenario will occur even for the blocking system calls listed in
       <a href="../man7/signal.7.html">signal(7)</a> that would <b>never </b>normally be restarted by the
       <b>SA_RESTART </b>flag.

       Furthermore, if the supervisor response is a file descriptor
       added with <b>SECCOMP_IOCTL_NOTIF_ADDFD</b>, then the flag
       <b>SECCOMP_ADDFD_FLAG_SEND </b>can be used to atomically add the file
       descriptor and return that value, making sure no file descriptors
       are inadvertently leaked into the target.
</pre> <h2>
BUGS </h2>
<pre>
       If a <b>SECCOMP_IOCTL_NOTIF_RECV ioctl</b>(2) operation is performed
       after the target terminates, then the <a href="ioctl.2.html">ioctl(2)</a> call simply blocks
       (rather than returning an error to indicate that the target no
       longer exists).
</pre> <h2>
EXAMPLES </h2>
<pre>
       The (somewhat contrived) program shown below demonstrates the use
       of the interfaces described in this page.  The program creates a
       child process that serves as the "target" process.  The child
       process installs a seccomp filter that returns the
       <b>SECCOMP_RET_USER_NOTIF </b>action value if a call is made to
       <a href="mkdir.2.html">mkdir(2)</a>.  The child process then calls <a href="mkdir.2.html">mkdir(2)</a> once for each of
       the supplied command-line arguments, and reports the result
       returned by the call.  After processing all arguments, the child
       process terminates.

       The parent process acts as the supervisor, listening for the
       notifications that are generated when the target process calls
       <a href="mkdir.2.html">mkdir(2)</a>.  When such a notification occurs, the supervisor
       examines the memory of the target process (using <i>/proc/</i>pid<i>/mem</i>)
       to discover the pathname argument that was supplied to the
       <a href="mkdir.2.html">mkdir(2)</a> call, and performs one of the following actions:

       •  If the pathname begins with the prefix "/tmp/", then the
          supervisor attempts to create the specified directory, and
          then spoofs a return for the target process based on the
          return value of the supervisor's <a href="mkdir.2.html">mkdir(2)</a> call.  In the event
          that that call succeeds, the spoofed success return value is
          the length of the pathname.

       •  If the pathname begins with "./" (i.e., it is a relative
          pathname), the supervisor sends a
          <b>SECCOMP_USER_NOTIF_FLAG_CONTINUE </b>response to the kernel to say
          that the kernel should execute the target process's <a href="mkdir.2.html">mkdir(2)</a>
          call.

       •  If the pathname begins with some other prefix, the supervisor
          spoofs an error return for the target process, so that the
          target process's <a href="mkdir.2.html">mkdir(2)</a> call appears to fail with the error
          <b>EOPNOTSUPP </b>("Operation not supported").  Additionally, if the
          specified pathname is exactly "/bye", then the supervisor
          terminates.

       This program can be used to demonstrate various aspects of the
       behavior of the seccomp user-space notification mechanism.  To
       help aid such demonstrations, the program logs various messages
       to show the operation of the target process (lines prefixed "T:")
       and the supervisor (indented lines prefixed "S:").

       In the following example, the target attempts to create the
       directory <i>/tmp/x</i>.  Upon receiving the notification, the
       supervisor creates the directory on the target's behalf, and
       spoofs a success return to be received by the target process's
       <a href="mkdir.2.html">mkdir(2)</a> call.

           $ <b>./seccomp_unotify /tmp/x</b>
           T: PID = 23168

           T: about to mkdir("/tmp/x")
                   S: got notification (ID 0x17445c4a0f4e0e3c) for PID 23168
                   S: executing: mkdir("/tmp/x", 0700)
                   S: success! spoofed return = 6
                   S: sending response (flags = 0; val = 6; error = 0)
           T: SUCCESS: mkdir(2) returned 6

           T: terminating
                   S: target has terminated; bye

       In the above output, note that the spoofed return value seen by
       the target process is 6 (the length of the pathname <i>/tmp/x</i>),
       whereas a normal <a href="mkdir.2.html">mkdir(2)</a> call returns 0 on success.

       In the next example, the target attempts to create a directory
       using the relative pathname <i>./sub</i>.  Since this pathname starts
       with "./", the supervisor sends a
       <b>SECCOMP_USER_NOTIF_FLAG_CONTINUE </b>response to the kernel, and the
       kernel then (successfully) executes the target process's <a href="mkdir.2.html">mkdir(2)</a>
       call.

           $ <b>./seccomp_unotify ./sub</b>
           T: PID = 23204

           T: about to mkdir("./sub")
                   S: got notification (ID 0xddb16abe25b4c12) for PID 23204
                   S: target can execute system call
                   S: sending response (flags = 0x1; val = 0; error = 0)
           T: SUCCESS: mkdir(2) returned 0

           T: terminating
                   S: target has terminated; bye

       If the target process attempts to create a directory with a
       pathname that doesn't start with "." and doesn't begin with the
       prefix "/tmp/", then the supervisor spoofs an error return
       (<b>EOPNOTSUPP</b>, "Operation not  supported") for the target's
       <a href="mkdir.2.html">mkdir(2)</a> call (which is not executed):

           $ <b>./seccomp_unotify /xxx</b>
           T: PID = 23178

           T: about to mkdir("/xxx")
                   S: got notification (ID 0xe7dc095d1c524e80) for PID 23178
                   S: spoofing error response (Operation not supported)
                   S: sending response (flags = 0; val = 0; error = -95)
           T: ERROR: mkdir(2): Operation not supported

           T: terminating
                   S: target has terminated; bye

       In the next example, the target process attempts to create a
       directory with the pathname <b>/tmp/nosuchdir/b</b>.  Upon receiving the
       notification, the supervisor attempts to create that directory,
       but the <a href="mkdir.2.html">mkdir(2)</a> call fails because the directory <b>/tmp/nosuchdir</b>
       does not exist.  Consequently, the supervisor spoofs an error
       return that passes the error that it received back to the target
       process's <a href="mkdir.2.html">mkdir(2)</a> call.

           $ <b>./seccomp_unotify /tmp/nosuchdir/b</b>
           T: PID = 23199

           T: about to mkdir("/tmp/nosuchdir/b")
                   S: got notification (ID 0x8744454293506046) for PID 23199
                   S: executing: mkdir("/tmp/nosuchdir/b", 0700)
                   S: failure! (errno = 2; No such file or directory)
                   S: sending response (flags = 0; val = 0; error = -2)
           T: ERROR: mkdir(2): No such file or directory

           T: terminating
                   S: target has terminated; bye

       If the supervisor receives a notification and sees that the
       argument of the target's <a href="mkdir.2.html">mkdir(2)</a> is the string "/bye", then (as
       well as spoofing an <b>EOPNOTSUPP </b>error), the supervisor terminates.
       If the target process subsequently executes another <a href="mkdir.2.html">mkdir(2)</a> that
       triggers its seccomp filter to return the <b>SECCOMP_RET_USER_NOTIF</b>
       action value, then the kernel causes the target process's system
       call to fail with the error <b>ENOSYS </b>("Function not implemented").
       This is demonstrated by the following example:

           $ <b>./seccomp_unotify /bye /tmp/y</b>
           T: PID = 23185

           T: about to mkdir("/bye")
                   S: got notification (ID 0xa81236b1d2f7b0f4) for PID 23185
                   S: spoofing error response (Operation not supported)
                   S: sending response (flags = 0; val = 0; error = -95)
                   S: terminating **********
           T: ERROR: mkdir(2): Operation not supported

           T: about to mkdir("/tmp/y")
           T: ERROR: mkdir(2): Function not implemented

           T: terminating

   <b>Program source</b>
       #define _GNU_SOURCE
       #include &lt;err.h&gt;
       #include &lt;errno.h&gt;
       #include &lt;fcntl.h&gt;
       #include &lt;limits.h&gt;
       #include &lt;linux/audit.h&gt;
       #include &lt;linux/filter.h&gt;
       #include &lt;linux/seccomp.h&gt;
       #include &lt;signal.h&gt;
       #include &lt;stdbool.h&gt;
       #include &lt;stddef.h&gt;
       #include &lt;stdint.h&gt;
       #include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;string.h&gt;
       #include &lt;sys/ioctl.h&gt;
       #include &lt;sys/prctl.h&gt;
       #include &lt;sys/socket.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;sys/syscall.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;sys/un.h&gt;
       #include &lt;unistd.h&gt;

       #define ARRAY_SIZE(arr)  (sizeof(arr) / sizeof((arr)[0]))

       /* Send the file descriptor 'fd' over the connected UNIX domain socket
          'sockfd'. Returns 0 on success, or -1 on error. */

       static int
       sendfd(int sockfd, int fd)
       {
           int             data;
           struct iovec    iov;
           struct msghdr   msgh;
           struct cmsghdr  *cmsgp;

           /* Allocate a char array of suitable size to hold the ancillary data.
              However, since this buffer is in reality a 'struct cmsghdr', use a
              union to ensure that it is suitably aligned. */
           union {
               char   buf[CMSG_SPACE(sizeof(int))];
                               /* Space large enough to hold an 'int' */
               struct cmsghdr align;
           } controlMsg;

           /* The 'msg_name' field can be used to specify the address of the
              destination socket when sending a datagram. However, we do not
              need to use this field because 'sockfd' is a connected socket. */

           msgh.msg_name = NULL;
           msgh.msg_namelen = 0;

           /* On Linux, we must transmit at least one byte of real data in
              order to send ancillary data. We transmit an arbitrary integer
              whose value is ignored by recvfd(). */

           msgh.msg_iov = &amp;iov;
           msgh.msg_iovlen = 1;
           iov.iov_base = &amp;data;
           iov.iov_len = sizeof(int);
           data = 12345;

           /* Set 'msghdr' fields that describe ancillary data */

           msgh.msg_control = controlMsg.buf;
           msgh.msg_controllen = sizeof(controlMsg.buf);

           /* Set up ancillary data describing file descriptor to send */

           cmsgp = CMSG_FIRSTHDR(&amp;msgh);
           cmsgp-&gt;cmsg_level = SOL_SOCKET;
           cmsgp-&gt;cmsg_type = SCM_RIGHTS;
           cmsgp-&gt;cmsg_len = CMSG_LEN(sizeof(int));
           memcpy(CMSG_DATA(cmsgp), &amp;fd, sizeof(int));

           /* Send real plus ancillary data */

           if (sendmsg(sockfd, &amp;msgh, 0) == -1)
               return -1;

           return 0;
       }

       /* Receive a file descriptor on a connected UNIX domain socket. Returns
          the received file descriptor on success, or -1 on error. */

       static int
       recvfd(int sockfd)
       {
           int            data, fd;
           ssize_t        nr;
           struct iovec   iov;
           struct msghdr  msgh;

           /* Allocate a char buffer for the ancillary data. See the comments
              in sendfd() */
           union {
               char   buf[CMSG_SPACE(sizeof(int))];
               struct cmsghdr align;
           } controlMsg;
           struct cmsghdr *cmsgp;

           /* The 'msg_name' field can be used to obtain the address of the
              sending socket. However, we do not need this information. */

           msgh.msg_name = NULL;
           msgh.msg_namelen = 0;

           /* Specify buffer for receiving real data */

           msgh.msg_iov = &amp;iov;
           msgh.msg_iovlen = 1;
           iov.iov_base = &amp;data;       /* Real data is an 'int' */
           iov.iov_len = sizeof(int);

           /* Set 'msghdr' fields that describe ancillary data */

           msgh.msg_control = controlMsg.buf;
           msgh.msg_controllen = sizeof(controlMsg.buf);

           /* Receive real plus ancillary data; real data is ignored */

           nr = recvmsg(sockfd, &amp;msgh, 0);
           if (nr == -1)
               return -1;

           cmsgp = CMSG_FIRSTHDR(&amp;msgh);

           /* Check the validity of the 'cmsghdr' */

           if (cmsgp == NULL
               || cmsgp-&gt;cmsg_len != CMSG_LEN(sizeof(int))
               || cmsgp-&gt;cmsg_level != SOL_SOCKET
               || cmsgp-&gt;cmsg_type != SCM_RIGHTS)
           {
               errno = EINVAL;
               return -1;
           }

           /* Return the received file descriptor to our caller */

           memcpy(&amp;fd, CMSG_DATA(cmsgp), sizeof(int));
           return fd;
       }

       static void
       sigchldHandler(int sig)
       {
           char msg[] = "\tS: target has terminated; bye\n";

           write(STDOUT_FILENO, msg, sizeof(msg) - 1);
           _exit(EXIT_SUCCESS);
       }

       static int
       seccomp(unsigned int operation, unsigned int flags, void *args)
       {
           return syscall(SYS_seccomp, operation, flags, args);
       }

       /* The following is the x86-64-specific BPF boilerplate code for checking
          that the BPF program is running on the right architecture + ABI. At
          completion of these instructions, the accumulator contains the system
          call number. */

       /* For the x32 ABI, all system call numbers have bit 30 set */

       #define X32_SYSCALL_BIT         0x40000000

       #define X86_64_CHECK_ARCH_AND_LOAD_SYSCALL_NR \
               BPF_STMT(BPF_LD | BPF_W | BPF_ABS, \
                        (offsetof(struct seccomp_data, arch))), \
               BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, AUDIT_ARCH_X86_64, 0, 2), \
               BPF_STMT(BPF_LD | BPF_W | BPF_ABS, \
                        (offsetof(struct seccomp_data, nr))), \
               BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, X32_SYSCALL_BIT, 0, 1), \
               BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS)

       /* installNotifyFilter() installs a seccomp filter that generates
          user-space notifications (SECCOMP_RET_USER_NOTIF) when the process
          calls mkdir(2); the filter allows all other system calls.

          The function return value is a file descriptor from which the
          user-space notifications can be fetched. */

       static int
       installNotifyFilter(void)
       {
           int notifyFd;

           struct sock_filter filter[] = {
               X86_64_CHECK_ARCH_AND_LOAD_SYSCALL_NR,

               /* mkdir() triggers notification to user-space supervisor */

               BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, SYS_mkdir, 0, 1),
               BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_USER_NOTIF),

               /* Every other system call is allowed */

               BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
           };

           struct sock_fprog prog = {
               .len = ARRAY_SIZE(filter),
               .filter = filter,
           };

           /* Install the filter with the SECCOMP_FILTER_FLAG_NEW_LISTENER flag;
              as a result, seccomp() returns a notification file descriptor. */

           notifyFd = seccomp(SECCOMP_SET_MODE_FILTER,
                              SECCOMP_FILTER_FLAG_NEW_LISTENER, &amp;prog);
           if (notifyFd == -1)
               err(EXIT_FAILURE, "seccomp-install-notify-filter");

           return notifyFd;
       }

       /* Close a pair of sockets created by socketpair() */

       static void
       closeSocketPair(int sockPair[2])
       {
           if (close(sockPair[0]) == -1)
               err(EXIT_FAILURE, "closeSocketPair-close-0");
           if (close(sockPair[1]) == -1)
               err(EXIT_FAILURE, "closeSocketPair-close-1");
       }

       /* Implementation of the target process; create a child process that:

          (1) installs a seccomp filter with the
              SECCOMP_FILTER_FLAG_NEW_LISTENER flag;
          (2) writes the seccomp notification file descriptor returned from
              the previous step onto the UNIX domain socket, 'sockPair[0]';
          (3) calls mkdir(2) for each element of 'argv'.

          The function return value in the parent is the PID of the child
          process; the child does not return from this function. */

       static pid_t
       targetProcess(int sockPair[2], char *argv[])
       {
           int    notifyFd, s;
           pid_t  targetPid;

           targetPid = fork();

           if (targetPid == -1)
               err(EXIT_FAILURE, "fork");

           if (targetPid &gt; 0)          /* In parent, return PID of child */
               return targetPid;

           /* Child falls through to here */

           printf("T: PID = %ld\n", (long) getpid());

           /* Install seccomp filter(s) */

           if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0))
               err(EXIT_FAILURE, "prctl");

           notifyFd = installNotifyFilter();

           /* Pass the notification file descriptor to the tracing process over
              a UNIX domain socket */

           if (sendfd(sockPair[0], notifyFd) == -1)
               err(EXIT_FAILURE, "sendfd");

           /* Notification and socket FDs are no longer needed in target */

           if (close(notifyFd) == -1)
               err(EXIT_FAILURE, "close-target-notify-fd");

           closeSocketPair(sockPair);

           /* Perform a mkdir() call for each of the command-line arguments */

           for (char **ap = argv; *ap != NULL; ap++) {
               printf("\nT: about to mkdir(\"%s\")\n", *ap);

               s = mkdir(*ap, 0700);
               if (s == -1)
                   perror("T: ERROR: mkdir(2)");
               else
                   printf("T: SUCCESS: mkdir(2) returned %d\n", s);
           }

           printf("\nT: terminating\n");
           exit(EXIT_SUCCESS);
       }

       /* Check that the notification ID provided by a SECCOMP_IOCTL_NOTIF_RECV
          operation is still valid. It will no longer be valid if the target
          process has terminated or is no longer blocked in the system call that
          generated the notification (because it was interrupted by a signal).

          This operation can be used when doing such things as accessing
          /proc/PID files in the target process in order to avoid TOCTOU race
          conditions where the PID that is returned by SECCOMP_IOCTL_NOTIF_RECV
          terminates and is reused by another process. */

       static bool
       cookieIsValid(int notifyFd, uint64_t id)
       {
           return ioctl(notifyFd, SECCOMP_IOCTL_NOTIF_ID_VALID, &amp;id) == 0;
       }

       /* Access the memory of the target process in order to fetch the
          pathname referred to by the system call argument 'argNum' in
          'req-&gt;data.args[]'.  The pathname is returned in 'path',
          a buffer of 'len' bytes allocated by the caller.

          Returns true if the pathname is successfully fetched, and false
          otherwise. For possible causes of failure, see the comments below. */

       static bool
       getTargetPathname(struct seccomp_notif *req, int notifyFd,
                         int argNum, char *path, size_t len)
       {
           int      procMemFd;
           char     procMemPath[PATH_MAX];
           ssize_t  nread;

           snprintf(procMemPath, sizeof(procMemPath), "/proc/%d/mem", req-&gt;pid);

           procMemFd = open(procMemPath, O_RDONLY | O_CLOEXEC);
           if (procMemFd == -1)
               return false;

           /* Check that the process whose info we are accessing is still alive
              and blocked in the system call that caused the notification.
              If the SECCOMP_IOCTL_NOTIF_ID_VALID operation (performed in
              cookieIsValid()) succeeded, we know that the /proc/PID/mem file
              descriptor that we opened corresponded to the process for which we
              received a notification. If that process subsequently terminates,
              then read() on that file descriptor will return 0 (EOF). */

           if (!cookieIsValid(notifyFd, req-&gt;id)) {
               close(procMemFd);
               return false;
           }

           /* Read bytes at the location containing the pathname argument */

           nread = pread(procMemFd, path, len, req-&gt;data.args[argNum]);

           close(procMemFd);

           if (nread &lt;= 0)
               return false;

           /* Once again check that the notification ID is still valid. The
              case we are particularly concerned about here is that just
              before we fetched the pathname, the target's blocked system
              call was interrupted by a signal handler, and after the handler
              returned, the target carried on execution (past the interrupted
              system call). In that case, we have no guarantees about what we
              are reading, since the target's memory may have been arbitrarily
              changed by subsequent operations. */

           if (!cookieIsValid(notifyFd, req-&gt;id)) {
               perror("\tS: notification ID check failed!!!");
               return false;
           }

           /* Even if the target's system call was not interrupted by a signal,
              we have no guarantees about what was in the memory of the target
              process. (The memory may have been modified by another thread, or
              even by an external attacking process.) We therefore treat the
              buffer returned by pread() as untrusted input. The buffer should
              contain a terminating null byte; if not, then we will trigger an
              error for the target process. */

           if (strnlen(path, nread) &lt; nread)
               return true;

           return false;
       }

       /* Allocate buffers for the seccomp user-space notification request and
          response structures. It is the caller's responsibility to free the
          buffers returned via 'req' and 'resp'. */

       static void
       allocSeccompNotifBuffers(struct seccomp_notif **req,
                                struct seccomp_notif_resp **resp,
                                struct seccomp_notif_sizes *sizes)
       {
           size_t  resp_size;

           /* Discover the sizes of the structures that are used to receive
              notifications and send notification responses, and allocate
              buffers of those sizes. */

           if (seccomp(SECCOMP_GET_NOTIF_SIZES, 0, sizes) == -1)
               err(EXIT_FAILURE, "seccomp-SECCOMP_GET_NOTIF_SIZES");

           *req = malloc(sizes-&gt;seccomp_notif);
           if (*req == NULL)
               err(EXIT_FAILURE, "malloc-seccomp_notif");

           /* When allocating the response buffer, we must allow for the fact
              that the user-space binary may have been built with user-space
              headers where 'struct seccomp_notif_resp' is bigger than the
              response buffer expected by the (older) kernel. Therefore, we
              allocate a buffer that is the maximum of the two sizes. This
              ensures that if the supervisor places bytes into the response
              structure that are past the response size that the kernel expects,
              then the supervisor is not touching an invalid memory location. */

           resp_size = sizes-&gt;seccomp_notif_resp;
           if (sizeof(struct seccomp_notif_resp) &gt; resp_size)
               resp_size = sizeof(struct seccomp_notif_resp);

           *resp = malloc(resp_size);
           if (*resp == NULL)
               err(EXIT_FAILURE, "malloc-seccomp_notif_resp");

       }

       /* Handle notifications that arrive via the SECCOMP_RET_USER_NOTIF file
          descriptor, 'notifyFd'. */

       static void
       handleNotifications(int notifyFd)
       {
           bool                        pathOK;
           char                        path[PATH_MAX];
           struct seccomp_notif        *req;
           struct seccomp_notif_resp   *resp;
           struct seccomp_notif_sizes  sizes;

           allocSeccompNotifBuffers(&amp;req, &amp;resp, &amp;sizes);

           /* Loop handling notifications */

           for (;;) {

               /* Wait for next notification, returning info in '*req' */

               memset(req, 0, sizes.seccomp_notif);
               if (ioctl(notifyFd, SECCOMP_IOCTL_NOTIF_RECV, req) == -1) {
                   if (errno == EINTR)
                       continue;
                   err(EXIT_FAILURE, "\tS: ioctl-SECCOMP_IOCTL_NOTIF_RECV");
               }

               printf("\tS: got notification (ID %#llx) for PID %d\n",
                      req-&gt;id, req-&gt;pid);

               /* The only system call that can generate a notification event
                  is mkdir(2). Nevertheless, we check that the notified system
                  call is indeed mkdir() as kind of future-proofing of this
                  code in case the seccomp filter is later modified to
                  generate notifications for other system calls. */

               if (req-&gt;data.nr != SYS_mkdir) {
                   printf("\tS: notification contained unexpected "
                          "system call number; bye!!!\n");
                   exit(EXIT_FAILURE);
               }

               pathOK = getTargetPathname(req, notifyFd, 0, path, sizeof(path));

               /* Prepopulate some fields of the response */

               resp-&gt;id = req-&gt;id;     /* Response includes notification ID */
               resp-&gt;flags = 0;
               resp-&gt;val = 0;

               /* If getTargetPathname() failed, trigger an EINVAL error
                  response (sending this response may yield an error if the
                  failure occurred because the notification ID was no longer
                  valid); if the directory is in /tmp, then create it on behalf
                  of the supervisor; if the pathname starts with '.', tell the
                  kernel to let the target process execute the mkdir();
                  otherwise, give an error for a directory pathname in any other
                  location. */

               if (!pathOK) {
                   resp-&gt;error = -EINVAL;
                   printf("\tS: spoofing error for invalid pathname (%s)\n",
                          strerror(-resp-&gt;error));
               } else if (strncmp(path, "/tmp/", strlen("/tmp/")) == 0) {
                   printf("\tS: executing: mkdir(\"%s\", %#llo)\n",
                          path, req-&gt;data.args[1]);

                   if (mkdir(path, req-&gt;data.args[1]) == 0) {
                       resp-&gt;error = 0;            /* "Success" */
                       resp-&gt;val = strlen(path);   /* Used as return value of
                                                      mkdir() in target */
                       printf("\tS: success! spoofed return = %lld\n",
                              resp-&gt;val);
                   } else {

                       /* If mkdir() failed in the supervisor, pass the error
                          back to the target */

                       resp-&gt;error = -errno;
                       printf("\tS: failure! (errno = %d; %s)\n", errno,
                              strerror(errno));
                   }
               } else if (strncmp(path, "./", strlen("./")) == 0) {
                   resp-&gt;error = resp-&gt;val = 0;
                   resp-&gt;flags = SECCOMP_USER_NOTIF_FLAG_CONTINUE;
                   printf("\tS: target can execute system call\n");
               } else {
                   resp-&gt;error = -EOPNOTSUPP;
                   printf("\tS: spoofing error response (%s)\n",
                          strerror(-resp-&gt;error));
               }

               /* Send a response to the notification */

               printf("\tS: sending response "
                      "(flags = %#x; val = %lld; error = %d)\n",
                      resp-&gt;flags, resp-&gt;val, resp-&gt;error);

               if (ioctl(notifyFd, SECCOMP_IOCTL_NOTIF_SEND, resp) == -1) {
                   if (errno == ENOENT)
                       printf("\tS: response failed with ENOENT; "
                              "perhaps target process's syscall was "
                              "interrupted by a signal?\n");
                   else
                       perror("ioctl-SECCOMP_IOCTL_NOTIF_SEND");
               }

               /* If the pathname is just "/bye", then the supervisor breaks out
                  of the loop and terminates. This allows us to see what happens
                  if the target process makes further calls to mkdir(2). */

               if (strcmp(path, "/bye") == 0)
                   break;
           }

           free(req);
           free(resp);
           printf("\tS: terminating **********\n");
           exit(EXIT_FAILURE);
       }

       /* Implementation of the supervisor process:

          (1) obtains the notification file descriptor from 'sockPair[1]'
          (2) handles notifications that arrive on that file descriptor. */

       static void
       supervisor(int sockPair[2])
       {
           int notifyFd;

           notifyFd = recvfd(sockPair[1]);

           if (notifyFd == -1)
               err(EXIT_FAILURE, "recvfd");

           closeSocketPair(sockPair);  /* We no longer need the socket pair */

           handleNotifications(notifyFd);
       }

       int
       main(int argc, char *argv[])
       {
           int               sockPair[2];
           struct sigaction  sa;

           setbuf(stdout, NULL);

           if (argc &lt; 2) {
               fprintf(stderr, "At least one pathname argument is required\n");
               exit(EXIT_FAILURE);
           }

           /* Create a UNIX domain socket that is used to pass the seccomp
              notification file descriptor from the target process to the
              supervisor process. */

           if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockPair) == -1)
               err(EXIT_FAILURE, "socketpair");

           /* Create a child process--the "target"--that installs seccomp
              filtering. The target process writes the seccomp notification
              file descriptor onto 'sockPair[0]' and then calls mkdir(2) for
              each directory in the command-line arguments. */

           (void) targetProcess(sockPair, &amp;argv[optind]);

           /* Catch SIGCHLD when the target terminates, so that the
              supervisor can also terminate. */

           sa.sa_handler = sigchldHandler;
           sa.sa_flags = 0;
           sigemptyset(&amp;sa.sa_mask);
           if (sigaction(SIGCHLD, &amp;sa, NULL) == -1)
               err(EXIT_FAILURE, "sigaction");

           supervisor(sockPair);

           exit(EXIT_SUCCESS);
       }
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="ioctl.2.html">ioctl(2)</a>, <a href="pidfd_getfd.2.html">pidfd_getfd(2)</a>, <a href="pidfd_open.2.html">pidfd_open(2)</a>, <a href="seccomp.2.html">seccomp(2)</a>

       A further example program can be found in the kernel source file
       <i>samples/seccomp/user-trap.c</i>.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       ⟨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>⟩.  If you have a bug report
       for this manual page, see
       ⟨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>⟩.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       ⟨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>⟩ on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-06-15             <i>seccomp_unotify</i>(2)</span>
</pre>  <p>Pages that refer to this page: <a href="seccomp.2.html">seccomp(2)</a>, <a href="../man3/cmsg.3.html">cmsg(3)</a>, <a href="../man7/signal.7.html">signal(7)</a>, <a href="../man7/unix.7.html">unix(7)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man2/seccomp_unotify.2.html" class="_attribution-link">https://man7.org/linux/man-pages/man2/seccomp_unotify.2.html</a>
  </p>
</div>
