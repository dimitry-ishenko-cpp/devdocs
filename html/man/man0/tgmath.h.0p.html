<h1>tgmath.h(0p) — Linux manual page</h1>   <pre>
<span class="headline"><i>tgmath.h</i>(0P)            POSIX Programmer's Manual           <i>tgmath.h</i>(0P)</span>
</pre> <h2>
PROLOG </h2>
<pre>
       This manual page is part of the POSIX Programmer's Manual.  The
       Linux implementation of this interface may differ (consult the
       corresponding Linux manual page for details of Linux behavior),
       or the interface may not be implemented on Linux.
</pre> <h2>
NAME </h2>
<pre>
       tgmath.h — type-generic macros
</pre> <h2>
SYNOPSIS </h2>
<pre>
       #include &lt;tgmath.h&gt;
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The functionality described on this reference page is aligned
       with the ISO C standard. Any conflict between the requirements
       described here and the ISO C standard is unintentional. This
       volume of POSIX.1‐2017 defers to the ISO C standard.

       The <i>&lt;tgmath.h&gt;</i> header shall include the headers <i>&lt;math.h&gt;</i> and
       <i>&lt;complex.h&gt;</i> and shall define several type-generic macros.

       Of the functions contained within the <i>&lt;math.h&gt;</i> and <i>&lt;complex.h&gt;</i>
       headers without an <i>f</i> (<b>float</b>) or <i>l</i> (<b>long double</b>) suffix, several
       have one or more parameters whose corresponding real type is
       <b>double</b>.  For each such function, except <i>modf</i>(), <i>j0</i>(), <i>j1</i>(), <i>jn</i>(),
       <i>y0</i>(), <i>y1</i>(), and <i>yn</i>(), there shall be a corresponding type-generic
       macro. The parameters whose corresponding real type is <b>double </b>in
       the function synopsis are generic parameters. Use of the macro
       invokes a function whose corresponding real type and type domain
       are determined by the arguments for the generic parameters.

       Use of the macro invokes a function whose generic parameters have
       the corresponding real type determined as follows:

        *  First, if any argument for generic parameters has type <b>long</b>
           <b>double</b>, the type determined is <b>long double</b>.

        *  Otherwise, if any argument for generic parameters has type
           <b>double </b>or is of integer type, the type determined is <b>double</b>.

        *  Otherwise, the type determined is <b>float</b>.

       For each unsuffixed function in the <i>&lt;math.h&gt;</i> header for which
       there is a function in the <i>&lt;complex.h&gt;</i> header with the same name
       except for a <i>c</i> prefix, the corresponding type-generic macro (for
       both functions) has the same name as the function in the <i>&lt;math.h&gt;</i>
       header. The corresponding type-generic macro for <i>fabs</i>() and
       <i>cabs</i>() is <i>fabs</i>().
       ┌───────────────────┬──────────────────────┬────────────────────┐
       │ <b>&lt;math.h&gt; Function </b>│ <b>&lt;complex.h&gt; Function </b>│ <b>Type-Generic Macro </b>│
       ├───────────────────┼──────────────────────┼────────────────────┤
       │ <i>acos</i>()            │ <i>cacos</i>()              │ <i>acos</i>()             │
       │ <i>asin</i>()            │ <i>casin</i>()              │ <i>asin</i>()             │
       │ <i>atan</i>()            │ <i>catan</i>()              │ <i>atan</i>()             │
       │ <i>acosh</i>()           │ <i>cacosh</i>()             │ <i>acosh</i>()            │
       │ <i>asinh</i>()           │ <i>casinh</i>()             │ <i>asinh</i>()            │
       │ <i>atanh</i>()           │ <i>catanh</i>()             │ <i>atanh</i>()            │
       │ <i>cos</i>()             │ <i>ccos</i>()               │ <i>cos</i>()              │
       │ <i>sin</i>()             │ <i>csin</i>()               │ <i>sin</i>()              │
       │ <i>tan</i>()             │ <i>ctan</i>()               │ <i>tan</i>()              │
       │ <i>cosh</i>()            │ <i>ccosh</i>()              │ <i>cosh</i>()             │
       │ <i>sinh</i>()            │ <i>csinh</i>()              │ <i>sinh</i>()             │
       │ <i>tanh</i>()            │ <i>ctanh</i>()              │ <i>tanh</i>()             │
       │ <i>exp</i>()             │ <i>cexp</i>()               │ <i>exp</i>()              │
       │ <i>log</i>()             │ <i>clog</i>()               │ <i>log</i>()              │
       │ <i>pow</i>()             │ <i>cpow</i>()               │ <i>pow</i>()              │
       │ <i>sqrt</i>()            │ <i>csqrt</i>()              │ <i>sqrt</i>()             │
       │ <i>fabs</i>()            │ <i>cabs</i>()               │ <i>fabs</i>()             │
       └───────────────────┴──────────────────────┴────────────────────┘

       If at least one argument for a generic parameter is complex, then
       use of the macro invokes a complex function; otherwise, use of
       the macro invokes a real function.

       For each unsuffixed function in the <i>&lt;math.h&gt;</i> header without a <i>c</i>-
       prefixed counterpart in the <i>&lt;complex.h&gt;</i> header, except for
       <i>modf</i>(), <i>j0</i>(), <i>j1</i>(), <i>jn</i>(), <i>y0</i>(), <i>y1</i>(), and <i>yn</i>(), the corresponding
       type-generic macro has the same name as the function.  These
       type-generic macros are:

              <i>atan2</i>()      <i>fma</i>()      <i>llround</i>()      <i>remainder</i>()
              <i>cbrt</i>()       <i>fmax</i>()     <i>log10</i>()        <i>remquo</i>()
              <i>ceil</i>()       <i>fmin</i>()     <i>log1p</i>()        <i>rint</i>()
              <i>copysign</i>()   <i>fmod</i>()     <i>log2</i>()         <i>round</i>()
              <i>erf</i>()        <i>frexp</i>()    <i>logb</i>()         <i>scalbln</i>()
              <i>erfc</i>()       <i>hypot</i>()    <i>lrint</i>()        <i>scalbn</i>()
              <i>exp2</i>()       <i>ilogb</i>()    <i>lround</i>()       <i>tgamma</i>()
              <i>expm1</i>()      <i>ldexp</i>()    <i>nearbyint</i>()    <i>trunc</i>()
              <i>fdim</i>()       <i>lgamma</i>()   <i>nextafter</i>()
              <i>floor</i>()      <i>llrint</i>()   <i>nexttoward</i>()

       If all arguments for generic parameters are real, then use of the
       macro invokes a real function; otherwise, use of the macro
       results in undefined behavior.

       For each unsuffixed function in the <i>&lt;complex.h&gt;</i> header that is
       not a <i>c</i>-prefixed counterpart to a function in the <i>&lt;math.h&gt;</i>
       header, the corresponding type-generic macro has the same name as
       the function. These type-generic macros are:

              <i>carg</i>() <i>cimag</i>() <i>conj</i>() <i>cproj</i>() <i>creal</i>()

       Use of the macro with any real or complex argument invokes a
       complex function.

       <i>The following sections are informative.</i>
</pre> <h2>
APPLICATION USAGE </h2>
<pre>
       With the declarations:

           #include &lt;tgmath.h&gt;
           int n;
           float f;
           double d;
           long double ld;
           float complex fc;
           double complex dc;
           long double complex ldc;

       functions invoked by use of type-generic macros are shown in the
       following table:
             ┌──────────────────┬───────────────────────────────┐
             │      <b>Macro       </b>│          <b>Use Invokes          </b>│
             ├──────────────────┼───────────────────────────────┤
             │ <i>exp</i>(<i>n</i>)           │ <i>exp</i>(<i>n</i>), the function          │
             │ <i>acosh</i>(<i>f</i>)         │ <i>acoshf</i>(<i>f</i>)                     │
             │ <i>sin</i>(<i>d</i>)           │ <i>sin</i>(<i>d</i>), the function          │
             │ <i>atan</i>(<i>ld</i>)         │ <i>atanl</i>(<i>ld</i>)                     │
             │ <i>log</i>(<i>fc</i>)          │ <i>clogf</i>(<i>fc</i>)                     │
             │ <i>sqrt</i>(<i>dc</i>)         │ <i>csqrt</i>(<i>dc</i>)                     │
             │ <i>pow</i>(<i>ldc,f</i>)       │ <i>cpowl</i>(<i>ldc, f</i>)                 │
             │ <i>remainder</i>(<i>n,n</i>)   │ <i>remainder</i>(<i>n, n</i>), the function │
             │ <i>nextafter</i>(<i>d,f</i>)   │ <i>nextafter</i>(<i>d, f</i>), the function │
             │ <i>nexttoward</i>(<i>f,ld</i>) │ <i>nexttowardf</i>(<i>f, ld</i>)            │
             │ <i>copysign</i>(<i>n,ld</i>)   │ <i>copysignl</i>(<i>n, ld</i>)              │
             │ <i>ceil</i>(<i>fc</i>)         │ Undefined behavior            │
             │ <i>rint</i>(<i>dc</i>)         │ Undefined behavior            │
             │ <i>fmax</i>(<i>ldc,ld</i>)     │ Undefined behavior            │
             │ <i>carg</i>(<i>n</i>)          │ <i>carg</i>(<i>n</i>), the function         │
             │ <i>cproj</i>(<i>f</i>)         │ <i>cprojf</i>(<i>f</i>)                     │
             │ <i>creal</i>(<i>d</i>)         │ <i>creal</i>(<i>d</i>), the function        │
             │ <i>cimag</i>(<i>ld</i>)        │ <i>cimagl</i>(<i>ld</i>)                    │
             │ <i>cabs</i>(<i>fc</i>)         │ <i>cabsf</i>(<i>fc</i>)                     │
             │ <i>carg</i>(<i>dc</i>)         │ <i>carg</i>(<i>dc</i>), the function        │
             │ <i>cproj</i>(<i>ldc</i>)       │ <i>cprojl</i>(<i>ldc</i>)                   │
             └──────────────────┴───────────────────────────────┘
</pre> <h2>
RATIONALE </h2>
<pre>
       Type-generic macros allow calling a function whose type is
       determined by the argument type, as is the case for C operators
       such as <b>'+' </b>and <b>'*'</b>.  For example, with a type-generic <i>cos</i>()
       macro, the expression <i>cos</i>((<b>float</b>)<i>x</i>) will have type <b>float</b>.  This
       feature enables writing more portably efficient code and
       alleviates need for awkward casting and suffixing in the process
       of porting or adjusting precision. Generic math functions are a
       widely appreciated feature of Fortran.

       The only arguments that affect the type resolution are the
       arguments corresponding to the parameters that have type <b>double</b>
       in the synopsis. Hence the type of a type-generic call to
       <i>nexttoward</i>(), whose second parameter is <b>long double </b>in the
       synopsis, is determined solely by the type of the first argument.

       The term ``type-generic'' was chosen over the proposed
       alternatives of intrinsic and overloading. The term is more
       specific than intrinsic, which already is widely used with a more
       general meaning, and reflects a closer match to Fortran's generic
       functions than to C++ overloading.

       The macros are placed in their own header in order not to
       silently break old programs that include the <i>&lt;math.h&gt;</i> header; for
       example, with:

           printf ("%e", sin(x))

       <i>modf</i>(<b>double</b>, <b>double *</b>) is excluded because no way was seen to
       make it safe without complicating the type resolution.

       The implementation might, as an extension, endow appropriate ones
       of the macros that POSIX.1‐2008 specifies only for real arguments
       with the ability to invoke the complex functions.

       POSIX.1‐2008 does not prescribe any particular implementation
       mechanism for generic macros. It could be implemented simply with
       built-in macros. The generic macro for <i>sqrt</i>(), for example, could
       be implemented with:

           #undef sqrt
           #define sqrt(x) __BUILTIN_GENERIC_sqrt(x)

       Generic macros are designed for a useful level of consistency
       with C++ overloaded math functions.

       The great majority of existing C programs are expected to be
       unaffected when the <i>&lt;tgmath.h&gt;</i> header is included instead of the
       <i>&lt;math.h&gt;</i> or <i>&lt;complex.h&gt;</i> headers. Generic macros are similar to
       the ISO/IEC 9899:1999 standard library masking macros, though the
       semantic types of return values differ.

       The ability to overload on integer as well as floating types
       would have been useful for some functions; for example,
       <i>copysign</i>().  Overloading with different numbers of arguments
       would have allowed reusing names; for example, <i>remainder</i>() for
       <i>remquo</i>().  However, these facilities would have complicated the
       specification; and their natural consistent use, such as for a
       floating <i>abs</i>() or a two-argument <i>atan</i>(), would have introduced
       further inconsistencies with the ISO/IEC 9899:1999 standard for
       insufficient benefit.

       The ISO C standard in no way limits the implementation's options
       for efficiency, including inlining library functions.
</pre> <h2>
FUTURE DIRECTIONS </h2>
<pre>
       None.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="math.h.0p.html">math.h(0p)</a>, <a href="complex.h.0p.html">complex.h(0p)</a>

       The System Interfaces volume of POSIX.1‐2017, <a href="../man3/cabs.3p.html">cabs(3p)</a>, <a href="../man3/fabs.3p.html">fabs(3p)</a>,
       <a href="../man3/modf.3p.html">modf(3p)</a>
</pre> <h2>
COPYRIGHT </h2>
<pre>
       Portions of this text are reprinted and reproduced in electronic
       form from IEEE Std 1003.1-2017, Standard for Information
       Technology -- Portable Operating System Interface (POSIX), The
       Open Group Base Specifications Issue 7, 2018 Edition, Copyright
       (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any
       discrepancy between this version and the original IEEE and The
       Open Group Standard, the original IEEE and The Open Group
       Standard is the referee document. The original Standard can be
       obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page
       are most likely to have been introduced during the conversion of
       the source files to man page format. To report such errors, see
       <a href="https://www.kernel.org/doc/man-pages/reporting_bugs.html">https://www.kernel.org/doc/man-pages/reporting_bugs.html</a> .

<span class="footline">IEEE/The Open Group               2017                      <i>tgmath.h</i>(0P)</span>
</pre>  <p>Pages that refer to this page: <a href="../man3/nextafter.3p.html">nextafter(3p)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man0/tgmath.h.0p.html" class="_attribution-link">https://man7.org/linux/man-pages/man0/tgmath.h.0p.html</a>
  </p>
</div>
