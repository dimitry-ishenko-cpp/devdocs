<h1>lex(1p) — Linux manual page</h1>   <pre>
<span class="headline"><i>LEX</i>(1P)                 POSIX Programmer's Manual                <i>LEX</i>(1P)</span>
</pre> <h2>
PROLOG </h2>
<pre>
       This manual page is part of the POSIX Programmer's Manual.  The
       Linux implementation of this interface may differ (consult the
       corresponding Linux manual page for details of Linux behavior),
       or the interface may not be implemented on Linux.
</pre> <h2>
NAME </h2>
<pre>
       lex — generate programs for lexical tasks (<b>DEVELOPMENT</b>)
</pre> <h2>
SYNOPSIS </h2>
<pre>
       lex <b>[</b>-t<b>] [</b>-n|-v<b>] [</b><i>file</i>...<b>]</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <i>lex</i> utility shall generate C programs to be used in lexical
       processing of character input, and that can be used as an
       interface to <i>yacc</i>.  The C programs shall be generated from <i>lex</i>
       source code and conform to the ISO C standard, without depending
       on any undefined, unspecified, or implementation-defined
       behavior, except in cases where the code is copied directly from
       the supplied source, or in cases that are documented by the
       implementation. Usually, the <i>lex</i> utility shall write the program
       it generates to the file <b>lex.yy.c</b>; the state of this file is
       unspecified if <i>lex</i> exits with a non-zero exit status. See the
       EXTENDED DESCRIPTION section for a complete description of the
       <i>lex</i> input language.
</pre> <h2>
OPTIONS </h2>
<pre>
       The <i>lex</i> utility shall conform to the Base Definitions volume of
       POSIX.1‐2017, <i>Section 12.2</i>, <i>Utility Syntax Guidelines</i>, except for
       Guideline 9.

       The following options shall be supported:

       <b>-n        </b>Suppress the summary of statistics usually written with
                 the <b>-v </b>option. If no table sizes are specified in the
                 <i>lex</i> source code and the <b>-v </b>option is not specified,
                 then <b>-n </b>is implied.

       <b>-t        </b>Write the resulting program to standard output instead
                 of <b>lex.yy.c</b>.

       <b>-v        </b>Write a summary of <i>lex</i> statistics to the standard
                 output. (See the discussion of <i>lex</i> table sizes in
                 <i>Definitions in lex</i>.)  If the <b>-t </b>option is specified and
                 <b>-n </b>is not specified, this report shall be written to
                 standard error. If table sizes are specified in the <i>lex</i>
                 source code, and if the <b>-n </b>option is not specified, the
                 <b>-v </b>option may be enabled.
</pre> <h2>
OPERANDS </h2>
<pre>
       The following operand shall be supported:

       <i>file</i>      A pathname of an input file. If more than one such <i>file</i>
                 is specified, all files shall be concatenated to
                 produce a single <i>lex</i> program. If no <i>file</i> operands are
                 specified, or if a <i>file</i> operand is <b>'-'</b>, the standard
                 input shall be used.
</pre> <h2>
STDIN </h2>
<pre>
       The standard input shall be used if no <i>file</i> operands are
       specified, or if a <i>file</i> operand is <b>'-'</b>.  See INPUT FILES.
</pre> <h2>
INPUT FILES </h2>
<pre>
       The input files shall be text files containing <i>lex</i> source code,
       as described in the EXTENDED DESCRIPTION section.
</pre> <h2>
ENVIRONMENT VARIABLES </h2>
<pre>
       The following environment variables shall affect the execution of
       <i>lex</i>:

       <i>LANG</i>      Provide a default value for the internationalization
                 variables that are unset or null. (See the Base
                 Definitions volume of POSIX.1‐2017, <i>Section 8.2</i>,
                 <i>Internationalization Variables</i> for the precedence of
                 internationalization variables used to determine the
                 values of locale categories.)

       <i>LC_ALL</i>    If set to a non-empty string value, override the values
                 of all the other internationalization variables.

       <i>LC_COLLATE</i>
                 Determine the locale for the behavior of ranges,
                 equivalence classes, and multi-character collating
                 elements within regular expressions. If this variable
                 is not set to the POSIX locale, the results are
                 unspecified.

       <i>LC_CTYPE</i>  Determine the locale for the interpretation of
                 sequences of bytes of text data as characters (for
                 example, single-byte as opposed to multi-byte
                 characters in arguments and input files), and the
                 behavior of character classes within regular
                 expressions. If this variable is not set to the POSIX
                 locale, the results are unspecified.

       <i>LC_MESSAGES</i>
                 Determine the locale that should be used to affect the
                 format and contents of diagnostic messages written to
                 standard error.

       <i>NLSPATH</i>   Determine the location of message catalogs for the
                 processing of <i>LC_MESSAGES</i>.
</pre> <h2>
ASYNCHRONOUS EVENTS </h2>
<pre>
       Default.
</pre> <h2>
STDOUT </h2>
<pre>
       If the <b>-t </b>option is specified, the text file of C source code
       output of <i>lex</i> shall be written to standard output.

       If the <b>-t </b>option is not specified:

        *  Implementation-defined informational, error, and warning
           messages concerning the contents of <i>lex</i> source code input
           shall be written to either the standard output or standard
           error.

        *  If the <b>-v </b>option is specified and the <b>-n </b>option is not
           specified, <i>lex</i> statistics shall also be written to either the
           standard output or standard error, in an implementation-
           defined format. These statistics may also be generated if
           table sizes are specified with a <b>'%' </b>operator in the
           <i>Definitions</i> section, as long as the <b>-n </b>option is not
           specified.
</pre> <h2>
STDERR </h2>
<pre>
       If the <b>-t </b>option is specified, implementation-defined
       informational, error, and warning messages concerning the
       contents of <i>lex</i> source code input shall be written to the
       standard error.

       If the <b>-t </b>option is not specified:

        1. Implementation-defined informational, error, and warning
           messages concerning the contents of <i>lex</i> source code input
           shall be written to either the standard output or standard
           error.

        2. If the <b>-v </b>option is specified and the <b>-n </b>option is not
           specified, <i>lex</i> statistics shall also be written to either the
           standard output or standard error, in an implementation-
           defined format. These statistics may also be generated if
           table sizes are specified with a <b>'%' </b>operator in the
           <i>Definitions</i> section, as long as the <b>-n </b>option is not
           specified.
</pre> <h2>
OUTPUT FILES </h2>
<pre>
       A text file containing C source code shall be written to
       <b>lex.yy.c</b>, or to the standard output if the <b>-t </b>option is present.
</pre> <h2>
EXTENDED DESCRIPTION </h2>
<pre>
       Each input file shall contain <i>lex</i> source code, which is a table
       of regular expressions with corresponding actions in the form of
       C program fragments.

       When <b>lex.yy.c </b>is compiled and linked with the <i>lex</i> library (using
       the <b>-l l </b>operand with <i>c99</i>), the resulting program shall read
       character input from the standard input and shall partition it
       into strings that match the given expressions.

       When an expression is matched, these actions shall occur:

        *  The input string that was matched shall be left in <i>yytext</i> as
           a null-terminated string; <i>yytext</i> shall either be an external
           character array or a pointer to a character string. As
           explained in <i>Definitions in lex</i>, the type can be explicitly
           selected using the <b>%array </b>or <b>%pointer </b>declarations, but the
           default is implementation-defined.

        *  The external <b>int </b><i>yyleng</i> shall be set to the length of the
           matching string.

        *  The expression's corresponding program fragment, or action,
           shall be executed.

       During pattern matching, <i>lex</i> shall search the set of patterns for
       the single longest possible match. Among rules that match the
       same number of characters, the rule given first shall be chosen.

       The general format of <i>lex</i> source shall be:

              <i>Definitions</i> <b>%% </b><i>Rules</i> <b>%% </b><i>User</i>Subroutines

       The first <b>"%%" </b>is required to mark the beginning of the rules
       (regular expressions and actions); the second <b>"%%" </b>is required
       only if user subroutines follow.

       Any line in the <i>Definitions</i> section beginning with a &lt;blank&gt;
       shall be assumed to be a C program fragment and shall be copied
       to the external definition area of the <b>lex.yy.c </b>file. Similarly,
       anything in the <i>Definitions</i> section included between delimiter
       lines containing only <b>"%{" </b>and <b>"%}" </b>shall also be copied
       unchanged to the external definition area of the <b>lex.yy.c </b>file.

       Any such input (beginning with a &lt;blank&gt; or within <b>"%{" </b>and <b>"%}"</b>
       delimiter lines) appearing at the beginning of the <i>Rules</i> section
       before any rules are specified shall be written to <b>lex.yy.c </b>after
       the declarations of variables for the <i>yylex</i>() function and before
       the first line of code in <i>yylex</i>().  Thus, user variables local to
       <i>yylex</i>() can be declared here, as well as application code to
       execute upon entry to <i>yylex</i>().

       The action taken by <i>lex</i> when encountering any input beginning
       with a &lt;blank&gt; or within <b>"%{" </b>and <b>"%}" </b>delimiter lines appearing
       in the <i>Rules</i> section but coming after one or more rules is
       undefined. The presence of such input may result in an erroneous
       definition of the <i>yylex</i>() function.

       C-language code in the input shall not contain C-language
       trigraphs.  The C-language code within <b>"%{" </b>and <b>"%}" </b>delimiter
       lines shall not contain any lines consisting only of <b>"%}"</b>, or
       only of <b>"%%"</b>.

   <b>Definitions in lex</b>
       <i>Definitions</i> appear before the first <b>"%%" </b>delimiter. Any line in
       this section not contained between <b>"%{" </b>and <b>"%}" </b>lines and not
       beginning with a &lt;blank&gt; shall be assumed to define a <i>lex</i>
       substitution string. The format of these lines shall be:

           <i>name substitute</i>

       If a <i>name</i> does not meet the requirements for identifiers in the
       ISO C standard, the result is undefined. The string <i>substitute</i>
       shall replace the string {<i>name</i>} when it is used in a rule. The
       <i>name</i> string shall be recognized in this context only when the
       braces are provided and when it does not appear within a bracket
       expression or within double-quotes.

       In the <i>Definitions</i> section, any line beginning with a &lt;percent-
       sign&gt; (<b>'%'</b>) character and followed by an alphanumeric word
       beginning with either <b>'s' </b>or <b>'S' </b>shall define a set of start
       conditions. Any line beginning with a <b>'%' </b>followed by a word
       beginning with either <b>'x' </b>or <b>'X' </b>shall define a set of exclusive
       start conditions. When the generated scanner is in a <b>%s </b>state,
       patterns with no state specified shall be also active; in a <b>%x</b>
       state, such patterns shall not be active. The rest of the line,
       after the first word, shall be considered to be one or more
       &lt;blank&gt;-separated names of start conditions. Start condition
       names shall be constructed in the same way as definition names.
       Start conditions can be used to restrict the matching of regular
       expressions to one or more states as described in <i>Regular</i>
       <i>Expressions in lex</i>.

       Implementations shall accept either of the following two
       mutually-exclusive declarations in the <i>Definitions</i> section:

       <b>%array    </b>Declare the type of <i>yytext</i> to be a null-terminated
                 character array.

       <b>%pointer  </b>Declare the type of <i>yytext</i> to be a pointer to a null-
                 terminated character string.

       The default type of <i>yytext</i> is implementation-defined. If an
       application refers to <i>yytext</i> outside of the scanner source file
       (that is, via an <b>extern</b>), the application shall include the
       appropriate <b>%array </b>or <b>%pointer </b>declaration in the scanner source
       file.

       Implementations shall accept declarations in the <i>Definitions</i>
       section for setting certain internal table sizes. The
       declarations are shown in the following table.

                     <b>Table: Table Size Declarations in </b><i>lex</i>
     ┌─────────────┬────────────────────────────────────┬───────────────┐
     │ <b>Declaration </b>│            <b>Description             </b>│ <b>Minimum Value </b>│
     ├─────────────┼────────────────────────────────────┼───────────────┤
     │ %<b>p </b><i>n</i>        │ Number of positions                │     2500      │
     │ %<b>n </b><i>n</i>        │ Number of states                   │      500      │
     │ %<b>a </b><i>n</i>        │ Number of transitions              │     2000      │
     │ %<b>e </b><i>n</i>        │ Number of parse tree nodes         │     1000      │
     │ %<b>k </b><i>n</i>        │ Number of packed character classes │     1000      │
     │ %<b>o </b><i>n</i>        │ Size of the output array           │     3000      │
     └─────────────┴────────────────────────────────────┴───────────────┘

       In the table, <i>n</i> represents a positive decimal integer, preceded
       by one or more &lt;blank&gt; characters. The exact meaning of these
       table size numbers is implementation-defined. The implementation
       shall document how these numbers affect the <i>lex</i> utility and how
       they are related to any output that may be generated by the
       implementation should limitations be encountered during the
       execution of <i>lex</i>.  It shall be possible to determine from this
       output which of the table size values needs to be modified to
       permit <i>lex</i> to successfully generate tables for the input
       language. The values in the column Minimum Value represent the
       lowest values conforming implementations shall provide.

   <b>Rules in lex</b>
       The rules in <i>lex</i> source files are a table in which the left
       column contains regular expressions and the right column contains
       actions (C program fragments) to be executed when the expressions
       are recognized.

           <i>ERE action</i>
           <i>ERE action</i>
           ...

       The extended regular expression (ERE) portion of a row shall be
       separated from <i>action</i> by one or more &lt;blank&gt; characters. A
       regular expression containing &lt;blank&gt; characters shall be
       recognized under one of the following conditions:

        *  The entire expression appears within double-quotes.

        *  The &lt;blank&gt; characters appear within double-quotes or square
           brackets.

        *  Each &lt;blank&gt; is preceded by a &lt;backslash&gt; character.

   <b>User Subroutines in lex</b>
       Anything in the user subroutines section shall be copied to
       <b>lex.yy.c </b>following <i>yylex</i>().

   <b>Regular Expressions in lex</b>
       The <i>lex</i> utility shall support the set of extended regular
       expressions (see the Base Definitions volume of POSIX.1‐2017,
       <i>Section 9.4</i>, <i>Extended Regular Expressions</i>), with the following
       additions and exceptions to the syntax:

       "..."     Any string enclosed in double-quotes shall represent
                 the characters within the double-quotes as themselves,
                 except that &lt;backslash&gt;-escapes (which appear in the
                 following table) shall be recognized. Any
                 &lt;backslash&gt;-escape sequence shall be terminated by the
                 closing quote. For example, <b>"\01""1" </b>represents a
                 single string: the octal value 1 followed by the
                 character <b>'1'</b>.

       &lt;<i>state</i>&gt;<i>r</i>, &lt;<i>state1,state2,</i>...&gt;<i>r</i>
                 The regular expression <i>r</i> shall be matched only when the
                 program is in one of the start conditions indicated by
                 <i>state</i>, <i>state1</i>, and so on; see <i>Actions in lex</i>.  (As an
                 exception to the typographical conventions of the rest
                 of this volume of POSIX.1‐2017, in this case &lt;<i>state</i>&gt;
                 does not represent a metavariable, but the literal
                 angle-bracket characters surrounding a symbol.) The
                 start condition shall be recognized as such only at the
                 beginning of a regular expression.

       <i>r</i>/<i>x</i>       The regular expression <i>r</i> shall be matched only if it is
                 followed by an occurrence of regular expression <i>x</i> (<i>x</i> is
                 the instance of trailing context, further defined
                 below). The token returned in <i>yytext</i> shall only match
                 <i>r</i>.  If the trailing portion of <i>r</i> matches the beginning
                 of <i>x</i>, the result is unspecified. The <i>r</i> expression
                 cannot include further trailing context or the <b>'$'</b>
                 (match-end-of-line) operator; <i>x</i> cannot include the <b>'^'</b>
                 (match-beginning-of-line) operator, nor trailing
                 context, nor the <b>'$' </b>operator. That is, only one
                 occurrence of trailing context is allowed in a <i>lex</i>
                 regular expression, and the <b>'^' </b>operator only can be
                 used at the beginning of such an expression.

       {<i>name</i>}    When <i>name</i> is one of the substitution symbols from the
                 <i>Definitions</i> section, the string, including the
                 enclosing braces, shall be replaced by the <i>substitute</i>
                 value. The <i>substitute</i> value shall be treated in the
                 extended regular expression as if it were enclosed in
                 parentheses. No substitution shall occur if {<i>name</i>}
                 occurs within a bracket expression or within double-
                 quotes.

       Within an ERE, a &lt;backslash&gt; character shall be considered to
       begin an escape sequence as specified in the table in the Base
       Definitions volume of POSIX.1‐2017, <i>Chapter 5</i>, <i>File Format</i>
       <i>Notation</i> (<b>'\\'</b>, <b>'\a'</b>, <b>'\b'</b>, <b>'\f'</b>, <b>'\n'</b>, <b>'\r'</b>, <b>'\t'</b>, <b>'\v'</b>).  In
       addition, the escape sequences in the following table shall be
       recognized.

       A literal &lt;newline&gt; cannot occur within an ERE; the escape
       sequence <b>'\n' </b>can be used to represent a &lt;newline&gt;.  A &lt;newline&gt;
       shall not be matched by a period operator.

                        <b>Table: Escape Sequences in </b><i>lex</i>
      ┌──────────┬──────────────────────────┬──────────────────────────┐
      │  <b>Escape  </b>│                          │                          │
      │ <b>Sequence </b>│       <b>Description        </b>│         <b>Meaning          </b>│
      ├──────────┼──────────────────────────┼──────────────────────────┤
      │ \<i>digits</i>  │ A &lt;backslash&gt; character  │ The character whose      │
      │          │ followed by the longest  │ encoding is represented  │
      │          │ sequence of one, two, or │ by the one, two, or      │
      │          │ three octal-digit        │ three-digit octal        │
      │          │ characters (01234567).   │ integer. Multi-byte      │
      │          │ If all of the digits are │ characters require       │
      │          │ 0 (that is,              │ multiple, concatenated   │
      │          │ representation of the    │ escape sequences of this │
      │          │ NUL character), the      │ type, including the      │
      │          │ behavior is undefined.   │ leading &lt;backslash&gt; for  │
      │          │                          │ each byte.               │
      ├──────────┼──────────────────────────┼──────────────────────────┤
      │ \x<i>digits</i> │ A &lt;backslash&gt; character  │ The character whose      │
      │          │ followed by the longest  │ encoding is represented  │
      │          │ sequence of hexadecimal- │ by the hexadecimal       │
      │          │ digit characters         │ integer.                 │
      │          │ (01234567abcdefABCDEF).  │                          │
      │          │ If all of the digits are │                          │
      │          │ 0 (that is,              │                          │
      │          │ representation of the    │                          │
      │          │ NUL character), the      │                          │
      │          │ behavior is undefined.   │                          │
      ├──────────┼──────────────────────────┼──────────────────────────┤
      │ \c       │ A &lt;backslash&gt; character  │ The character <b>'c'</b>,       │
      │          │ followed by any          │ unchanged.               │
      │          │ character not described  │                          │
      │          │ in this table or in the  │                          │
      │          │ table in the Base        │                          │
      │          │ Definitions volume of    │                          │
      │          │ POSIX.1‐2017, <i>Chapter 5</i>, │                          │
      │          │ <i>File Format Notation</i>     │                          │
      │          │ (<b>'\\'</b>, <b>'\a'</b>, <b>'\b'</b>, <b>'\f'</b>, │                          │
      │          │ <b>'\n'</b>, <b>'\r'</b>, <b>'\t'</b>, <b>'\v'</b>). │                          │
      └──────────┴──────────────────────────┴──────────────────────────┘

       <b>Note:  </b>If a <b>'\x' </b>sequence needs to be immediately followed by a
              hexadecimal digit character, a sequence such as <b>"\x1""1"</b>
              can be used, which represents a character containing the
              value 1, followed by the character <b>'1'</b>.

       The order of precedence given to extended regular expressions for
       <i>lex</i> differs from that specified in the Base Definitions volume of
       POSIX.1‐2017, <i>Section 9.4</i>, <i>Extended Regular Expressions</i>.  The
       order of precedence for <i>lex</i> shall be as shown in the following
       table, from high to low.

       <b>Note:  </b>The escaped characters entry is not meant to imply that
              these are operators, but they are included in the table to
              show their relationships to the true operators. The start
              condition, trailing context, and anchoring notations have
              been omitted from the table because of the placement
              restrictions described in this section; they can only
              appear at the beginning or ending of an ERE.

                         <b>Table: ERE Precedence in </b><i>lex</i>
         ┌───────────────────────────────────┬──────────────────────┐
         │    <b>Extended Regular Expression    </b>│      <b>Precedence      </b>│
         ├───────────────────────────────────┼──────────────────────┤
         │ <i>collation-related bracket symbols</i> │ [= =]  [: :]  [. .]  │
         │ <i>escaped characters</i>                │ \&lt;<i>special character</i>&gt; │
         │ <i>bracket expression</i>                │ [ ]                  │
         │ <i>quoting</i>                           │ "..."                │
         │ <i>grouping</i>                          │ ( )                  │
         │ <i>definition</i>                        │ {<i>name</i>}               │
         │ <i>single-character RE duplication</i>   │ * + ?                │
         │ <i>concatenation</i>                     │                      │
         │ <i>interval expression</i>               │ {m,n}                │
         │ <i>alternation</i>                       │ |                    │
         └───────────────────────────────────┴──────────────────────┘

       The ERE anchoring operators <b>'^' </b>and <b>'$' </b>do not appear in the
       table. With <i>lex</i> regular expressions, these operators are
       restricted in their use: the <b>'^' </b>operator can only be used at the
       beginning of an entire regular expression, and the <b>'$' </b>operator
       only at the end. The operators apply to the entire regular
       expression. Thus, for example, the pattern <b>"(^abc)|(def$)" </b>is
       undefined; it can instead be written as two separate rules, one
       with the regular expression <b>"^abc" </b>and one with <b>"def$"</b>, which
       share a common action via the special <b>'|' </b>action (see below). If
       the pattern were written <b>"^abc|def$"</b>, it would match either <b>"abc"</b>
       or <b>"def" </b>on a line by itself.

       Unlike the general ERE rules, embedded anchoring is not allowed
       by most historical <i>lex</i> implementations. An example of embedded
       anchoring would be for patterns such as <b>"(^| )foo( |$)" </b>to match
       <b>"foo" </b>when it exists as a complete word. This functionality can
       be obtained using existing <i>lex</i> features:

           ^foo/[ \n]      |
           " foo"/[ \n]    /* Found foo as a separate word. */

       Note also that <b>'$' </b>is a form of trailing context (it is
       equivalent to <b>"/\n"</b>) and as such cannot be used with regular
       expressions containing another instance of the operator (see the
       preceding discussion of trailing context).

       The additional regular expressions trailing-context operator <b>'/'</b>
       can be used as an ordinary character if presented within double-
       quotes, <b>"/"</b>; preceded by a &lt;backslash&gt;, <b>"\/"</b>; or within a bracket
       expression, <b>"[/]"</b>.  The start-condition <b>'&lt;' </b>and <b>'&gt;' </b>operators
       shall be special only in a start condition at the beginning of a
       regular expression; elsewhere in the regular expression they
       shall be treated as ordinary characters.

   <b>Actions in lex</b>
       The action to be taken when an ERE is matched can be a C program
       fragment or the special actions described below; the program
       fragment can contain one or more C statements, and can also
       include special actions. The empty C statement <b>';' </b>shall be a
       valid action; any string in the <b>lex.yy.c </b>input that matches the
       pattern portion of such a rule is effectively ignored or skipped.
       However, the absence of an action shall not be valid, and the
       action <i>lex</i> takes in such a condition is undefined.

       The specification for an action, including C statements and
       special actions, can extend across several lines if enclosed in
       braces:

           <i>ERE</i> &lt;<i>one or more blanks</i>&gt; { <i>program statement</i>
                                      <i>program statement</i> }

       The program statements shall not contain unbalanced curly brace
       preprocessing tokens.

       The default action when a string in the input to a <b>lex.yy.c</b>
       program is not matched by any expression shall be to copy the
       string to the output. Because the default behavior of a program
       generated by <i>lex</i> is to read the input and copy it to the output,
       a minimal <i>lex</i> source program that has just <b>"%%" </b>shall generate a
       C program that simply copies the input to the output unchanged.

       Four special actions shall be available:

           |   ECHO;   REJECT;   BEGIN

       |         The action <b>'|' </b>means that the action for the next rule
                 is the action for this rule.  Unlike the other three
                 actions, <b>'|' </b>cannot be enclosed in braces or be
                 &lt;semicolon&gt;-terminated; the application shall ensure
                 that it is specified alone, with no other actions.

       <b>ECHO;     </b>Write the contents of the string <i>yytext</i> on the output.

       <b>REJECT;   </b>Usually only a single expression is matched by a given
                 string in the input.  <b>REJECT </b>means ``continue to the
                 next expression that matches the current input'', and
                 shall cause whatever rule was the second choice after
                 the current rule to be executed for the same input.
                 Thus, multiple rules can be matched and executed for
                 one input string or overlapping input strings. For
                 example, given the regular expressions <b>"xyz" </b>and <b>"xy"</b>
                 and the input <b>"xyz"</b>, usually only the regular
                 expression <b>"xyz" </b>would match. The next attempted match
                 would start after <b>z.  </b>If the last action in the <b>"xyz"</b>
                 rule is <b>REJECT</b>, both this rule and the <b>"xy" </b>rule would
                 be executed. The <b>REJECT </b>action may be implemented in
                 such a fashion that flow of control does not continue
                 after it, as if it were equivalent to a <b>goto </b>to another
                 part of <i>yylex</i>().  The use of <b>REJECT </b>may result in
                 somewhat larger and slower scanners.

       <b>BEGIN     </b>The action:

                     BEGIN <i>newstate</i>;

                 switches the state (start condition) to <i>newstate</i>.  If
                 the string <i>newstate</i> has not been declared previously as
                 a start condition in the <i>Definitions</i> section, the
                 results are unspecified. The initial state is indicated
                 by the digit <b>'0' </b>or the token <b>INITIAL</b>.

       The functions or macros described below are accessible to user
       code included in the <i>lex</i> input. It is unspecified whether they
       appear in the C code output of <i>lex</i>, or are accessible only
       through the <b>-l l </b>operand to <i>c99</i> (the <i>lex</i> library).

       <b>int </b><i>yylex</i>(<b>void</b>)
             Performs lexical analysis on the input; this is the primary
             function generated by the <i>lex</i> utility. The function shall
             return zero when the end of input is reached; otherwise, it
             shall return non-zero values (tokens) determined by the
             actions that are selected.

       <b>int </b><i>yymore</i>(<b>void</b>)
             When called, indicates that when the next input string is
             recognized, it is to be appended to the current value of
             <i>yytext</i> rather than replacing it; the value in <i>yyleng</i> shall
             be adjusted accordingly.

       <b>int </b><i>yyless</i>(<b>int </b><i>n</i>)
             Retains <i>n</i> initial characters in <i>yytext</i>, NUL-terminated, and
             treats the remaining characters as if they had not been
             read; the value in <i>yyleng</i> shall be adjusted accordingly.

       <b>int </b><i>input</i>(<b>void</b>)
             Returns the next character from the input, or zero on end-
             of-file. It shall obtain input from the stream pointer
             <i>yyin</i>, although possibly via an intermediate buffer. Thus,
             once scanning has begun, the effect of altering the value
             of <i>yyin</i> is undefined. The character read shall be removed
             from the input stream of the scanner without any processing
             by the scanner.

       <b>int </b><i>unput</i>(<b>int </b><i>c</i>)
             Returns the character <b>'c' </b>to the input; <i>yytext</i> and <i>yyleng</i>
             are undefined until the next expression is matched. The
             result of using <i>unput</i>() for more characters than have been
             input is unspecified.

       The following functions shall appear only in the <i>lex</i> library
       accessible through the <b>-l l </b>operand; they can therefore be
       redefined by a conforming application:

       <b>int </b><i>yywrap</i>(<b>void</b>)
             Called by <i>yylex</i>() at end-of-file; the default <i>yywrap</i>()
             shall always return 1. If the application requires <i>yylex</i>()
             to continue processing with another source of input, then
             the application can include a function <i>yywrap</i>(), which
             associates another file with the external variable <b>FILE *</b>
             <i>yyin</i> and shall return a value of zero.

       <b>int </b><i>main</i>(<b>int </b><i>argc</i>, <b>char *</b><i>argv</i>[])
             Calls <i>yylex</i>() to perform lexical analysis, then exits. The
             user code can contain <i>main</i>() to perform application-
             specific operations, calling <i>yylex</i>() as applicable.

       Except for <i>input</i>(), <i>unput</i>(), and <i>main</i>(), all external and static
       names generated by <i>lex</i> shall begin with the prefix <b>yy </b>or <b>YY</b>.
</pre> <h2>
EXIT STATUS </h2>
<pre>
       The following exit values shall be returned:

        0    Successful completion.

       &gt;0    An error occurred.
</pre> <h2>
CONSEQUENCES OF ERRORS </h2>
<pre>
       Default.

       <i>The following sections are informative.</i>
</pre> <h2>
APPLICATION USAGE </h2>
<pre>
       Conforming applications are warned that in the <i>Rules</i> section, an
       ERE without an action is not acceptable, but need not be detected
       as erroneous by <i>lex</i>.  This may result in compilation or runtime
       errors.

       The purpose of <i>input</i>() is to take characters off the input stream
       and discard them as far as the lexical analysis is concerned. A
       common use is to discard the body of a comment once the beginning
       of a comment is recognized.

       The <i>lex</i> utility is not fully internationalized in its treatment
       of regular expressions in the <i>lex</i> source code or generated
       lexical analyzer. It would seem desirable to have the lexical
       analyzer interpret the regular expressions given in the <i>lex</i>
       source according to the environment specified when the lexical
       analyzer is executed, but this is not possible with the current
       <i>lex</i> technology. Furthermore, the very nature of the lexical
       analyzers produced by <i>lex</i> must be closely tied to the lexical
       requirements of the input language being described, which is
       frequently locale-specific anyway. (For example, writing an
       analyzer that is used for French text is not automatically useful
       for processing other languages.)
</pre> <h2>
EXAMPLES </h2>
<pre>
       The following is an example of a <i>lex</i> program that implements a
       rudimentary scanner for a Pascal-like syntax:

           %{
           /* Need this for the call to atof() below. */
           #include &lt;math.h&gt;
           /* Need this for printf(), fopen(), and stdin below. */
           #include &lt;stdio.h&gt;
           %}

           DIGIT    [0-9]
           ID       [a-z][a-z0-9]*

           %%

           {DIGIT}+ {
               printf("An integer: %s (%d)\n", yytext,
                   atoi(yytext));
               }

           {DIGIT}+"."{DIGIT}*        {
               printf("A float: %s (%g)\n", yytext,
                   atof(yytext));
               }

           if|then|begin|end|procedure|function        {
               printf("A keyword: %s\n", yytext);
               }

           {ID}    printf("An identifier: %s\n", yytext);

           "+"|"-"|"*"|"/"        printf("An operator: %s\n", yytext);

           "{"[^}\n]*"}"    /* Eat up one-line comments. */

           [ \t\n]+        /* Eat up white space. */

           .  printf("Unrecognized character: %s\n", yytext);

           %%

           int main(int argc, char *argv[])
           {
               ++argv, --argc;  /* Skip over program name. */
               if (argc &gt; 0)
                   yyin = fopen(argv[0], "r");
               else
                   yyin = stdin;

               yylex();
           }
</pre> <h2>
RATIONALE </h2>
<pre>
       Even though the <b>-c </b>option and references to the C language are
       retained in this description, <i>lex</i> may be generalized to other
       languages, as was done at one time for EFL, the Extended FORTRAN
       Language. Since the <i>lex</i> input specification is essentially
       language-independent, versions of this utility could be written
       to produce Ada, Modula-2, or Pascal code, and there are known
       historical implementations that do so.

       The current description of <i>lex</i> bypasses the issue of dealing with
       internationalized EREs in the <i>lex</i> source code or generated
       lexical analyzer. If it follows the model used by <i>awk</i> (the source
       code is assumed to be presented in the POSIX locale, but input
       and output are in the locale specified by the environment
       variables), then the tables in the lexical analyzer produced by
       <i>lex</i> would interpret EREs specified in the <i>lex</i> source in terms of
       the environment variables specified when <i>lex</i> was executed. The
       desired effect would be to have the lexical analyzer interpret
       the EREs given in the <i>lex</i> source according to the environment
       specified when the lexical analyzer is executed, but this is not
       possible with the current <i>lex</i> technology.

       The description of octal and hexadecimal-digit escape sequences
       agrees with the ISO C standard use of escape sequences.

       Earlier versions of this standard allowed for implementations
       with bytes other than eight bits, but this has been modified in
       this version.

       There is no detailed output format specification. The observed
       behavior of <i>lex</i> under four different historical implementations
       was that none of these implementations consistently reported the
       line numbers for error and warning messages. Furthermore, there
       was a desire that <i>lex</i> be allowed to output additional diagnostic
       messages. Leaving message formats unspecified avoids these
       formatting questions and problems with internationalization.

       Although the <b>%x </b>specifier for <i>exclusive</i> start conditions is not
       historical practice, it is believed to be a minor change to
       historical implementations and greatly enhances the usability of
       <i>lex</i> programs since it permits an application to obtain the
       expected functionality with fewer statements.

       The <b>%array </b>and <b>%pointer </b>declarations were added as a compromise
       between historical systems.  The System V-based <i>lex</i> copies the
       matched text to a <i>yytext</i> array. The <i>flex</i> program, supported in
       BSD and GNU systems, uses a pointer. In the latter case,
       significant performance improvements are available for some
       scanners. Most historical programs should require no change in
       porting from one system to another because the string being
       referenced is null-terminated in both cases. (The method used by
       <i>flex</i> in its case is to null-terminate the token in place by
       remembering the character that used to come right after the token
       and replacing it before continuing on to the next scan.) Multi-
       file programs with external references to <i>yytext</i> outside the
       scanner source file should continue to operate on their
       historical systems, but would require one of the new declarations
       to be considered strictly portable.

       The description of EREs avoids unnecessary duplication of ERE
       details because their meanings within a <i>lex</i> ERE are the same as
       that for the ERE in this volume of POSIX.1‐2017.

       The reason for the undefined condition associated with text
       beginning with a &lt;blank&gt; or within <b>"%{" </b>and <b>"%}" </b>delimiter lines
       appearing in the <i>Rules</i> section is historical practice. Both the
       BSD and System V <i>lex</i> copy the indented (or enclosed) input in the
       <i>Rules</i> section (except at the beginning) to unreachable areas of
       the <i>yylex</i>() function (the code is written directly after a <i>break</i>
       statement). In some cases, the System V <i>lex</i> generates an error
       message or a syntax error, depending on the form of indented
       input.

       The intention in breaking the list of functions into those that
       may appear in <b>lex.yy.c </b><i>versus</i> those that only appear in <b>libl.a </b>is
       that only those functions in <b>libl.a </b>can be reliably redefined by
       a conforming application.

       The descriptions of standard output and standard error are
       somewhat complicated because historical <i>lex</i> implementations chose
       to issue diagnostic messages to standard output (unless <b>-t </b>was
       given). POSIX.1‐2008 allows this behavior, but leaves an opening
       for the more expected behavior of using standard error for
       diagnostics.  Also, the System V behavior of writing the
       statistics when any table sizes are given is allowed, while BSD-
       derived systems can avoid it. The programmer can always precisely
       obtain the desired results by using either the <b>-t </b>or <b>-n </b>options.

       The OPERANDS section does not mention the use of <b>- </b>as a synonym
       for standard input; not all historical implementations support
       such usage for any of the <i>file</i> operands.

       A description of the <i>translation table</i> was deleted from early
       proposals because of its relatively low usage in historical
       applications.

       The change to the definition of the <i>input</i>() function that allows
       buffering of input presents the opportunity for major performance
       gains in some applications.

       The following examples clarify the differences between <i>lex</i>
       regular expressions and regular expressions appearing elsewhere
       in this volume of POSIX.1‐2017. For regular expressions of the
       form <b>"r/x"</b>, the string matching <i>r</i> is always returned; confusion
       may arise when the beginning of <i>x</i> matches the trailing portion of
       <i>r</i>.  For example, given the regular expression <b>"a*b/cc" </b>and the
       input <b>"aaabcc"</b>, <i>yytext</i> would contain the string <b>"aaab" </b>on this
       match. But given the regular expression <b>"x*/xy" </b>and the input
       <b>"xxxy"</b>, the token <b>xxx</b>, not <b>xx</b>, is returned by some
       implementations because <b>xxx </b>matches <b>"x*"</b>.

       In the rule <b>"ab*/bc"</b>, the <b>"b*" </b>at the end of <i>r</i> extends <i>r</i>'s match
       into the beginning of the trailing context, so the result is
       unspecified. If this rule were <b>"ab/bc"</b>, however, the rule matches
       the text <b>"ab" </b>when it is followed by the text <b>"bc"</b>.  In this
       latter case, the matching of <i>r</i> cannot extend into the beginning
       of <i>x</i>, so the result is specified.
</pre> <h2>
FUTURE DIRECTIONS </h2>
<pre>
       None.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="c99.1p.html">c99(1p)</a>, <a href="ed.1p.html">ed(1p)</a>, <a href="yacc.1p.html">yacc(1p)</a>

       The Base Definitions volume of POSIX.1‐2017, <i>Chapter 5</i>, <i>File</i>
       <i>Format Notation</i>, <i>Chapter 8</i>, <i>Environment Variables</i>, <i>Chapter 9</i>,
       <i>Regular Expressions</i>, <i>Section 12.2</i>, <i>Utility Syntax Guidelines</i>
</pre> <h2>
COPYRIGHT </h2>
<pre>
       Portions of this text are reprinted and reproduced in electronic
       form from IEEE Std 1003.1-2017, Standard for Information
       Technology -- Portable Operating System Interface (POSIX), The
       Open Group Base Specifications Issue 7, 2018 Edition, Copyright
       (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any
       discrepancy between this version and the original IEEE and The
       Open Group Standard, the original IEEE and The Open Group
       Standard is the referee document. The original Standard can be
       obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page
       are most likely to have been introduced during the conversion of
       the source files to man page format. To report such errors, see
       <a href="https://www.kernel.org/doc/man-pages/reporting_bugs.html">https://www.kernel.org/doc/man-pages/reporting_bugs.html</a> .

<span class="footline">IEEE/The Open Group               2017                           <i>LEX</i>(1P)</span>
</pre>  <p>Pages that refer to this page: <a href="awk.1p.html">awk(1p)</a>, <a href="cflow.1p.html">cflow(1p)</a>, <a href="make.1p.html">make(1p)</a>, <a href="yacc.1p.html">yacc(1p)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man1/lex.1p.html" class="_attribution-link">https://man7.org/linux/man-pages/man1/lex.1p.html</a>
  </p>
</div>
