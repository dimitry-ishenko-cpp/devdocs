<h1>git-name-rev(1) — Linux manual page</h1>   <pre>
<span class="headline"><i>GIT-NAME-REV</i>(1)                Git Manual                <i>GIT-NAME-REV</i>(1)</span>
</pre> <h2>
NAME </h2>
<pre>
       git-name-rev - Find symbolic names for given revs
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <i>git name-rev</i> [--tags] [--refs=&lt;pattern&gt;]
                      ( --all | --annotate-stdin | &lt;commit-ish&gt;... )
</pre> <h2>
DESCRIPTION </h2>
<pre>
       Finds symbolic names suitable for human digestion for revisions
       given in any format parsable by <i>git rev-parse</i>.
</pre> <h2>
OPTIONS </h2>
<pre>
       --tags
           Do not use branch names, but only tags to name the commits

       --refs=&lt;pattern&gt;
           Only use refs whose names match a given shell pattern. The
           pattern can be a branch name, a tag name, or a fully
           qualified ref name. If given multiple times, use refs whose
           names match any of the given shell patterns. Use <b>--no-refs </b>to
           clear any previous ref patterns given.

       --exclude=&lt;pattern&gt;
           Do not use any ref whose name matches a given shell pattern.
           The pattern can be one of branch name, tag name or fully
           qualified ref name. If given multiple times, a ref will be
           excluded when it matches any of the given patterns. When used
           together with --refs, a ref will be used as a match only when
           it matches at least one --refs pattern and does not match any
           --exclude patterns. Use <b>--no-exclude </b>to clear the list of
           exclude patterns.

       --all
           List all commits reachable from all refs

       --annotate-stdin
           Transform stdin by substituting all the 40-character SHA-1
           hexes (say $hex) with "$hex ($rev_name)". When used with
           --name-only, substitute with "$rev_name", omitting $hex
           altogether. This option was called <b>--stdin </b>in older versions
           of Git.

           For example:

               $ cat sample.txt

               An abbreviated revision 2ae0a9cb82 will not be substituted.
               The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907,
               while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad

               $ git name-rev --annotate-stdin &lt;sample.txt

               An abbreviated revision 2ae0a9cb82 will not be substituted.
               The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907 (master),
               while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad

               $ git name-rev --name-only --annotate-stdin &lt;sample.txt

               An abbreviated revision 2ae0a9cb82 will not be substituted.
               The full name after substitution is master,
               while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad

       --name-only
           Instead of printing both the SHA-1 and the name, print only
           the name. If given with --tags the usual tag prefix of
           "tags/" is also omitted from the name, matching the output of
           <b>git-describe </b>more closely.

       --no-undefined
           Die with error code != 0 when a reference is undefined,
           instead of printing <b>undefined</b>.

       --always
           Show uniquely abbreviated commit object as fallback.
</pre> <h2>
EXAMPLES </h2>
<pre>
       Given a commit, find out where it is relative to the local refs.
       Say somebody wrote you about that fantastic commit
       33db5f4d9027a10e477ccf054b2c1ab94f74c85a. Of course, you look
       into the commit, but that only tells you what happened, but not
       the context.

       Enter <i>git name-rev</i>:

           % git name-rev 33db5f4d9027a10e477ccf054b2c1ab94f74c85a
           33db5f4d9027a10e477ccf054b2c1ab94f74c85a tags/v0.99~940

       Now you are wiser, because you know that it happened 940
       revisions before v0.99.

       Another nice thing you can do is:

           % git log | git name-rev --annotate-stdin
</pre> <h2>
GIT </h2>
<pre>
       Part of the <a href="git.1.html">git(1)</a> suite
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>git</i> (Git distributed version control
       system) project.  Information about the project can be found at
       ⟨<a href="http://git-scm.com/">http://git-scm.com/</a>⟩.  If you have a bug report for this manual
       page, see ⟨<a href="http://git-scm.com/community">http://git-scm.com/community</a>⟩.  This page was obtained
       from the project's upstream Git repository
       ⟨<a href="https://github.com/git/git.git">https://github.com/git/git.git</a>⟩ on 2024-06-14.  (At that time,
       the date of the most recent commit that was found in the
       repository was 2024-06-12.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Git 2.45.2.492.gd63586         2024-06-12                <i>GIT-NAME-REV</i>(1)</span>
</pre>  <p>Pages that refer to this page: <a href="git.1.html">git(1)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man1/git-name-rev.1.html" class="_attribution-link">https://man7.org/linux/man-pages/man1/git-name-rev.1.html</a>
  </p>
</div>
