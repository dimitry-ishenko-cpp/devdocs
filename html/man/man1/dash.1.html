<h1>dash(1) — Linux manual page</h1>   <pre>
<span class="headline"><i>DASH</i>(1)                  General Commands Manual                 <i>DASH</i>(1)</span>
</pre> <h2>
NAME </h2>
<pre>
       <b>dash </b>— command interpreter (shell)
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>dash </b>[<b>-aCefnuvxIimqVEb</b>] [<b>+aCefnuvxIimqVEb</b>] [<b>-o </b><i>option_name</i>]
       [<b>+o </b><i>option_name</i>] [<i>command_file</i> [<i>argument ...</i>]] <b>dash -c</b>
       [<b>-aCefnuvxIimqVEb</b>] [<b>+aCefnuvxIimqVEb</b>] [<b>-o </b><i>option_name</i>]
       [<b>+o </b><i>option_name</i>] <i>command_string</i> [<i>command_name</i> [<i>argument ...</i>]]
       <b>dash -s </b>[<b>-aCefnuvxIimqVEb</b>] [<b>+aCefnuvxIimqVEb</b>] [<b>-o </b><i>option_name</i>]
       [<b>+o </b><i>option_name</i>] [<i>argument ...</i>]
</pre> <h2>
DESCRIPTION </h2>
<pre>
       <b>dash </b>is the standard command interpreter for the system.  The
       current version of <b>dash </b>is in the process of being changed to
       conform with the POSIX 1003.2 and 1003.2a specifications for the
       shell.  This version has many features which make it appear
       similar in some respects to the Korn shell, but it is not a Korn
       shell clone (see <i>ksh</i>(1)).  Only features designated by POSIX,
       plus a few Berkeley extensions, are being incorporated into this
       shell.  This man page is not intended to be a tutorial or a
       complete specification of the shell.

   <b>Overview</b>
       The shell is a command that reads lines from either a file or the
       terminal, interprets them, and generally executes other commands.
       It is the program that is running when a user logs into the
       system (although a user can select a different shell with the
       <i>chsh</i>(1) command).  The shell implements a language that has flow
       control constructs, a macro facility that provides a variety of
       features in addition to data storage, along with built in history
       and line editing capabilities.  It incorporates many features to
       aid interactive use and has the advantage that the interpretative
       language is common to both interactive and non-interactive use
       (shell scripts).  That is, commands can be typed directly to the
       running shell or can be put into a file and the file can be
       executed directly by the shell.

   <b>Invocation</b>
       If no args are present and if the standard input of the shell is
       connected to a terminal (or if the <b>-i </b>flag is set), and the <b>-c</b>
       option is not present, the shell is considered an interactive
       shell.  An interactive shell generally prompts before each
       command and handles programming and command errors differently
       (as described below).  When first starting, the shell inspects
       argument 0, and if it begins with a dash ‘-’, the shell is also
       considered a login shell.  This is normally done automatically by
       the system when the user first logs in.  A login shell first
       reads commands from the files <i>/etc/profile</i> and <i>.profile</i> if they
       exist.  If the environment variable ENV is set on entry to an
       interactive shell, or is set in the <i>.profile</i> of a login shell,
       the shell next reads commands from the file named in ENV.
       Therefore, a user should place commands that are to be executed
       only at login time in the <i>.profile</i> file, and commands that are
       executed for every interactive shell inside the ENV file.  To set
       the ENV variable to some file, place the following line in your
       <i>.profile</i> of your home directory

             <b>ENV=$HOME/.shinit; export ENV</b>

       substituting for “.shinit” any filename you wish.

       If command line arguments besides the options have been
       specified, then the shell treats the first argument as the name
       of a file from which to read commands (a shell script), and the
       remaining arguments are set as the positional parameters of the
       shell ($1, $2, etc).  Otherwise, the shell reads commands from
       its standard input.

   <b>Argument List Processing</b>
       All of the single letter options that have a corresponding name
       can be used as an argument to the <b>-o </b>option.  The set <b>-o </b>name is
       provided next to the single letter option in the description
       below.  Specifying a dash “-” turns the option on, while using a
       plus “+” disables the option.  The following options can be set
       from the command line or with the <b>set </b>builtin (described later).

             <b>-a </b><i>allexport</i>     Export all variables assigned to.

             <b>-c               </b>Read commands from the <i>command_string</i>
                              operand instead of from the standard
                              input.  Special parameter 0 will be set
                              from the <i>command_name</i> operand and the
                              positional parameters ($1, $2, etc.)  set
                              from the remaining argument operands.

             <b>-C </b><i>noclobber</i>     Don't overwrite existing files with “&gt;”.

             <b>-e </b><i>errexit</i>       If not interactive, exit immediately if
                              any untested command fails.  The exit
                              status of a command is considered to be
                              explicitly tested if the command is used
                              to control an <b>if</b>, <b>elif</b>, <b>while</b>, or <b>until</b>;
                              or if the command is the left hand operand
                              of an “&amp;&amp;” or “||” operator.

             <b>-f </b><i>noglob</i>        Disable pathname expansion.

             <b>-n </b><i>noexec</i>        If not interactive, read commands but do
                              not execute them.  This is useful for
                              checking the syntax of shell scripts.

             <b>-u </b><i>nounset</i>       Write a message to standard error when
                              attempting to expand a variable that is
                              not set, and if the shell is not
                              interactive, exit immediately.

             <b>-v </b><i>verbose</i>       The shell writes its input to standard
                              error as it is read.  Useful for
                              debugging.

             <b>-x </b><i>xtrace</i>        Write each command to standard error
                              (preceded by a ‘+ ’) before it is
                              executed.  Useful for debugging.

             <b>-I </b><i>ignoreeof</i>     Ignore EOF's from input when interactive.

             <b>-i </b><i>interactive</i>   Force the shell to behave interactively.

             <b>-l               </b>Make dash act as if it had been invoked as
                              a login shell.

             <b>-m </b><i>monitor</i>       Turn on job control (set automatically
                              when interactive).

             <b>-s </b><i>stdin</i>         Read commands from standard input (set
                              automatically if no file arguments are
                              present).  This option has no effect when
                              set after the shell has already started
                              running (i.e. with <b>set</b>).

             <b>-V </b><i>vi</i>            Enable the built-in <i>vi</i>(1) command line
                              editor (disables <b>-E </b>if it has been set).

             <b>-E </b><i>emacs</i>         Enable the built-in <i>emacs</i>(1) command line
                              editor (disables <b>-V </b>if it has been set).

             <b>-b </b><i>notify</i>        Enable asynchronous notification of
                              background job completion.  (UNIMPLEMENTED
                              for 4.4alpha)

   <b>Lexical Structure</b>
       The shell reads input in terms of lines from a file and breaks it
       up into words at whitespace (blanks and tabs), and at certain
       sequences of characters that are special to the shell called
       “operators”.  There are two types of operators: control operators
       and redirection operators (their meaning is discussed later).
       Following is a list of operators:

             Control operators:
                   <b>&amp; &amp;&amp; ( ) ; ;; </b>| <b>|| &lt;newline&gt;</b>

             Redirection operators:
                   <b>&lt; &gt; &gt;| &lt;&lt; &gt;&gt; &lt;&amp; &gt;&amp; &lt;&lt;- &lt;&gt;</b>

   <b>Quoting</b>
       Quoting is used to remove the special meaning of certain
       characters or words to the shell, such as operators, whitespace,
       or keywords.  There are three types of quoting: matched single
       quotes, matched double quotes, and backslash.

   <b>Backslash</b>
       A backslash preserves the literal meaning of the following
       character, with the exception of ⟨newline⟩.  A backslash
       preceding a ⟨newline⟩ is treated as a line continuation.

   <b>Single Quotes</b>
       Enclosing characters in single quotes preserves the literal
       meaning of all the characters (except single quotes, making it
       impossible to put single-quotes in a single-quoted string).

   <b>Double Quotes</b>
       Enclosing characters within double quotes preserves the literal
       meaning of all characters except dollarsign ($), backquote (`),
       and backslash (\).  The backslash inside double quotes is
       historically weird, and serves to quote only the following
       characters:
             <b>$ ` " \ &lt;newline&gt;</b>.
       Otherwise it remains literal.

   <b>Reserved Words</b>
       Reserved words are words that have special meaning to the shell
       and are recognized at the beginning of a line and after a control
       operator.  The following are reserved words:

             !       elif    fi      while   case
             else    for     then    {       }
             do      done    until   if      esac

       Their meaning is discussed later.

   <b>Aliases</b>
       An alias is a name and corresponding value set using the <i>alias</i>(1)
       builtin command.  Whenever a reserved word may occur (see above),
       and after checking for reserved words, the shell checks the word
       to see if it matches an alias.  If it does, it replaces it in the
       input stream with its value.  For example, if there is an alias
       called “lf” with the value “ls -F”, then the input:

             <b>lf foobar </b>⟨return⟩

       would become

             <b>ls -F foobar </b>⟨return⟩

       Aliases provide a convenient way for naive users to create
       shorthands for commands without having to learn how to create
       functions with arguments.  They can also be used to create
       lexically obscure code.  This use is discouraged.

   <b>Commands</b>
       The shell interprets the words it reads according to a language,
       the specification of which is outside the scope of this man page
       (refer to the BNF in the POSIX 1003.2 document).  Essentially
       though, a line is read and if the first word of the line (or
       after a control operator) is not a reserved word, then the shell
       has recognized a simple command.  Otherwise, a complex command or
       some other special construct may have been recognized.

   <b>Simple Commands</b>
       If a simple command has been recognized, the shell performs the
       following actions:

             1.   Leading words of the form “name=value” are stripped
                  off and assigned to the environment of the simple
                  command.  Redirection operators and their arguments
                  (as described below) are stripped off and saved for
                  processing.

             2.   The remaining words are expanded as described in the
                  section called “Expansions”, and the first remaining
                  word is considered the command name and the command is
                  located.  The remaining words are considered the
                  arguments of the command.  If no command name
                  resulted, then the “name=value” variable assignments
                  recognized in item 1 affect the current shell.

             3.   Redirections are performed as described in the next
                  section.

   <b>Redirections</b>
       Redirections are used to change where a command reads its input
       or sends its output.  In general, redirections open, close, or
       duplicate an existing reference to a file.  The overall format
       used for redirection is:

             <b>[n] </b><i>redir-op file</i>

       where <i>redir-op</i> is one of the redirection operators mentioned
       previously.  Following is a list of the possible redirections.
       The [n] is an optional number between 0 and 9, as in ‘3’ (not
       ‘[3]’), that refers to a file descriptor.

             [n]&gt; file   Redirect standard output (or n) to file.

             [n]&gt;| file  Same, but override the <b>-C </b>option.

             [n]&gt;&gt; file  Append standard output (or n) to file.

             [n]&lt; file   Redirect standard input (or n) from file.

             [n1]&lt;&amp;n2    Copy file descriptor n2 as stdin (or fd n1).

             [n]&lt;&amp;-      Close standard input (or n).

             [n1]&gt;&amp;n2    Copy file descriptor n2 as stdout (or fd n1).

             [n]&gt;&amp;-      Close standard output (or n).

             [n]&lt;&gt; file  Open file for reading and writing on standard
                         input (or n).

       The following redirection is often called a “here-document”.

             <b>[n]&lt;&lt; delimiter</b>
                   <b>here-doc-text ...</b>
             <b>delimiter</b>

       All the text on successive lines up to the delimiter is saved
       away and made available to the command on standard input, or file
       descriptor n if it is specified.  If the delimiter as specified
       on the initial line is quoted, then the here-doc-text is treated
       literally, otherwise the text is subjected to parameter
       expansion, command substitution, and arithmetic expansion (as
       described in the section on “Expansions”).  If the operator is
       “&lt;&lt;-” instead of “&lt;&lt;”, then leading tabs in the here-doc-text are
       stripped.

   <b>Search and Execution</b>
       There are three types of commands: shell functions, builtin
       commands, and normal programs – and the command is searched for
       (by name) in that order.  They each are executed in a different
       way.

       When a shell function is executed, all of the shell positional
       parameters (except $0, which remains unchanged) are set to the
       arguments of the shell function.  The variables which are
       explicitly placed in the environment of the command (by placing
       assignments to them before the function name) are made local to
       the function and are set to the values given.  Then the command
       given in the function definition is executed.  The positional
       parameters are restored to their original values when the command
       completes.  This all occurs within the current shell.

       Shell builtins are executed internally to the shell, without
       spawning a new process.

       Otherwise, if the command name doesn't match a function or
       builtin, the command is searched for as a normal program in the
       file system (as described in the next section).  When a normal
       program is executed, the shell runs the program, passing the
       arguments and the environment to the program.  If the program is
       not a normal executable file (i.e., if it does not begin with the
       "magic number" whose ASCII representation is "#!", so <i>execve</i>(2)
       returns ENOEXEC then) the shell will interpret the program in a
       subshell.  The child shell will reinitialize itself in this case,
       so that the effect will be as if a new shell had been invoked to
       handle the ad-hoc shell script, except that the location of
       hashed commands located in the parent shell will be remembered by
       the child.

       Note that previous versions of this document and the source code
       itself misleadingly and sporadically refer to a shell script
       without a magic number as a "shell procedure".

   <b>Path Search</b>
       When locating a command, the shell first looks to see if it has a
       shell function by that name.  Then it looks for a builtin command
       by that name.  If a builtin command is not found, one of two
       things happen:

       1.   Command names containing a slash are simply executed without
            performing any searches.

       2.   The shell searches each entry in PATH in turn for the
            command.  The value of the PATH variable should be a series
            of entries separated by colons.  Each entry consists of a
            directory name.  The current directory may be indicated
            implicitly by an empty directory name, or explicitly by a
            single period.

   <b>Command Exit Status</b>
       Each command has an exit status that can influence the behaviour
       of other shell commands.  The paradigm is that a command exits
       with zero for normal or success, and non-zero for failure, error,
       or a false indication.  The man page for each command should
       indicate the various exit codes and what they mean.
       Additionally, the builtin commands return exit codes, as does an
       executed shell function.

       If a command consists entirely of variable assignments then the
       exit status of the command is that of the last command
       substitution if any, otherwise 0.

   <b>Complex Commands</b>
       Complex commands are combinations of simple commands with control
       operators or reserved words, together creating a larger complex
       command.  More generally, a command is one of the following:

       <b>•   </b>simple command

       <b>•   </b>pipeline

       <b>•   </b>list or compound-list

       <b>•   </b>compound command

       <b>•   </b>function definition

       Unless otherwise stated, the exit status of a command is that of
       the last simple command executed by the command.

   <b>Pipelines</b>
       A pipeline is a sequence of one or more commands separated by the
       control operator |.  The standard output of all but the last
       command is connected to the standard input of the next command.
       The standard output of the last command is inherited from the
       shell, as usual.

       The format for a pipeline is:

             <b>[!] command1 </b>[| <b>command2 ...]</b>

       The standard output of command1 is connected to the standard
       input of command2.  The standard input, standard output, or both
       of a command is considered to be assigned by the pipeline before
       any redirection specified by redirection operators that are part
       of the command.

       If the pipeline is not in the background (discussed later), the
       shell waits for all commands to complete.

       If the <i>pipefail</i> option was enabled when the shell began execution
       of the pipeline, the pipeline's exit status is the exit status of
       the last command specified in the pipeline that exited with non-
       zero status, or zero if all commands in the pipeline exited with
       a status of zero. If the <i>pipefail</i> option was not enabled, the
       pipeline's exit status is the exit status of the last command
       specified in the pipeline; the exit statuses of any other
       commands are not used. If the reserved word ! precedes the
       pipeline, its exit status is the logical NOT of the exit status
       described above.

       Because pipeline assignment of standard input or standard output
       or both takes place before redirection, it can be modified by
       redirection.  For example:

             <b>$ command1 2&gt;&amp;1 </b>| <b>command2</b>

       sends both the standard output and standard error of command1 to
       the standard input of command2.

       A ; or ⟨newline⟩ terminator causes the preceding AND-OR-list
       (described next) to be executed sequentially; a &amp; causes
       asynchronous execution of the preceding AND-OR-list.

       Note that unlike some other shells, each process in the pipeline
       is a child of the invoking shell (unless it is a shell builtin,
       in which case it executes in the current shell – but any effect
       it has on the environment is wiped).

   <b>Background Commands – &amp;</b>
       If a command is terminated by the control operator ampersand (&amp;),
       the shell executes the command asynchronously – that is, the
       shell does not wait for the command to finish before executing
       the next command.

       The format for running a command in background is:

             <b>command1 &amp; [command2 &amp; ...]</b>

       If the shell is not interactive, the standard input of an
       asynchronous command is set to <i>/dev/null</i>.

   <b>Lists – Generally Speaking</b>
       A list is a sequence of zero or more commands separated by
       newlines, semicolons, or ampersands, and optionally terminated by
       one of these three characters.  The commands in a list are
       executed in the order they are written.  If command is followed
       by an ampersand, the shell starts the command and immediately
       proceeds onto the next command; otherwise it waits for the
       command to terminate before proceeding to the next one.

   <b>Short-Circuit List Operators</b>
       “&amp;&amp;” and “||” are AND-OR list operators.  “&amp;&amp;” executes the first
       command, and then executes the second command if and only if the
       exit status of the first command is zero.  “||” is similar, but
       executes the second command if and only if the exit status of the
       first command is nonzero.  “&amp;&amp;” and “||” both have the same
       priority.

   <b>Flow-Control Constructs – if, while, for, case</b>
       The syntax of the if command is

             if list
             then list
             [ elif list
             then    list ] ...
             [ else list ]
             fi

       The syntax of the while command is

             while list
             do   list
             done

       The two lists are executed repeatedly while the exit status of
       the first list is zero.  The until command is similar, but has
       the word until in place of while, which causes it to repeat until
       the exit status of the first list is zero.

       The syntax of the for command is

             for variable [ in [ word ... ] ]
             do   list
             done

       The words following <i>in</i> are expanded, and then the list is
       executed repeatedly with the variable set to each word in turn.
       Omitting in word ... is equivalent to in "$@".

       The syntax of the break and continue command is

             break [ num ]
             continue [ num ]

       Break terminates the num innermost for or while loops.  Continue
       continues with the next iteration of the innermost loop.  These
       are implemented as builtin commands.

       The syntax of the case command is

             case word in
             [(]pattern) list ;;
             ...
             esac

       The pattern can actually be one or more patterns (see “Shell
       Patterns” described later), separated by “|” characters.  The “(”
       character before the pattern is optional.

   <b>Grouping Commands Together</b>
       Commands may be grouped by writing either

             <b>(list)</b>

       or

             <b>{ list; }</b>

       The first of these executes the commands in a subshell.  Builtin
       commands grouped into a (list) will not affect the current shell.
       The second form does not fork another shell so is slightly more
       efficient.  Grouping commands together this way allows you to
       redirect their output as though they were one program:

             { printf " hello " ; printf " world\n" ; } &gt; greeting

       Note that “}” must follow a control operator (here, “;”) so that
       it is recognized as a reserved word and not as another command
       argument.

   <b>Functions</b>
       The syntax of a function definition is

             <b>name </b>() <b>command</b>

       A function definition is an executable statement; when executed
       it installs a function named name and returns an exit status of
       zero.  The command is normally a list enclosed between “{” and
       “}”.

       Variables may be declared to be local to a function by using a
       local command.  This should appear as the first statement of a
       function, and the syntax is

             <b>local </b>[<b>variable </b>| <b>-</b>] <b>...</b>

       Local is implemented as a builtin command.

       When a variable is made local, it inherits the initial value and
       exported and readonly flags from the variable with the same name
       in the surrounding scope, if there is one.  Otherwise, the
       variable is initially unset.  The shell uses dynamic scoping, so
       that if you make the variable x local to function f, which then
       calls function g, references to the variable x made inside g will
       refer to the variable x declared inside f, not to the global
       variable named x.

       The only special parameter that can be made local is “-”.  Making
       “-” local any shell options that are changed via the set command
       inside the function to be restored to their original values when
       the function returns.

       The syntax of the return command is

             <b>return </b>[<b>exitstatus</b>]

       It terminates the currently executing function.  Return is
       implemented as a builtin command.

   <b>Variables and Parameters</b>
       The shell maintains a set of parameters.  A parameter denoted by
       a name is called a variable.  When starting up, the shell turns
       all the environment variables into shell variables.  New
       variables can be set using the form

             <b>name=value</b>

       Variables set by the user must have a name consisting solely of
       alphabetics, numerics, and underscores - the first of which must
       not be numeric.  A parameter can also be denoted by a number or a
       special character as explained below.

   <b>Positional Parameters</b>
       A positional parameter is a parameter denoted by a number (n &gt;
       0).  The shell sets these initially to the values of its command
       line arguments that follow the name of the shell script.  The <b>set</b>
       builtin can also be used to set or reset them.

   <b>Special Parameters</b>
       A special parameter is a parameter denoted by one of the
       following special characters.  The value of the parameter is
       listed next to its character.

       *            Expands to the positional parameters, starting from
                    one.  When the expansion occurs within a double-
                    quoted string it expands to a single field with the
                    value of each parameter separated by the first
                    character of the IFS variable, or by a ⟨space⟩ if
                    IFS is unset.

       @            Expands to the positional parameters, starting from
                    one.  When the expansion occurs within double-
                    quotes, each positional parameter expands as a
                    separate argument.  If there are no positional
                    parameters, the expansion of @ generates zero
                    arguments, even when @ is double-quoted.  What this
                    basically means, for example, is if $1 is “abc” and
                    $2 is “def ghi”, then "$@" expands to the two
                    arguments:

                          <b>"abc" "def ghi"</b>

       #            Expands to the number of positional parameters.

       ?            Expands to the exit status of the most recent
                    pipeline.

       - (Hyphen.)  Expands to the current option flags (the single-
                    letter option names concatenated into a string) as
                    specified on invocation, by the set builtin command,
                    or implicitly by the shell.

       $            Expands to the process ID of the invoked shell.  A
                    subshell retains the same value of $ as its parent.

       !            Expands to the process ID of the most recent
                    background command executed from the current shell.
                    For a pipeline, the process ID is that of the last
                    command in the pipeline.

       0 (Zero.)    Expands to the name of the shell or shell script.

   <b>Word Expansions</b>
       This clause describes the various expansions that are performed
       on words.  Not all expansions are performed on every word, as
       explained later.

       Tilde expansions, parameter expansions, command substitutions,
       arithmetic expansions, and quote removals that occur within a
       single word expand to a single field.  It is only field splitting
       or pathname expansion that can create multiple fields from a
       single word.  The single exception to this rule is the expansion
       of the special parameter @ within double-quotes, as was described
       above.

       The order of word expansion is:

       1.   Tilde Expansion, Parameter Expansion, Command Substitution,
            Arithmetic Expansion (these all occur at the same time).

       2.   Field Splitting is performed on fields generated by step (1)
            unless the IFS variable is null.

       3.   Pathname Expansion (unless set <b>-f </b>is in effect).

       4.   Quote Removal.

       The $ character is used to introduce parameter expansion, command
       substitution, or arithmetic evaluation.

   <b>Tilde Expansion (substituting a user's home directory)</b>
       A word beginning with an unquoted tilde character (~) is
       subjected to tilde expansion.  All the characters up to a slash
       (/) or the end of the word are treated as a username and are
       replaced with the user's home directory.  If the username is
       missing (as in <i>~/foobar</i>), the tilde is replaced with the value of
       the <i>HOME</i> variable (the current user's home directory).

   <b>Parameter Expansion</b>
       The format for parameter expansion is as follows:

             <b>${expression}</b>

       where expression consists of all characters until the matching
       “}”.  Any “}” escaped by a backslash or within a quoted string,
       and characters in embedded arithmetic expansions, command
       substitutions, and variable expansions, are not examined in
       determining the matching “}”.

       The simplest form for parameter expansion is:

             <b>${parameter}</b>

       The value, if any, of parameter is substituted.

       The parameter name or symbol can be enclosed in braces, which are
       optional except for positional parameters with more than one
       digit or when parameter is followed by a character that could be
       interpreted as part of the name.  If a parameter expansion occurs
       inside double-quotes:

       1.   Pathname expansion is not performed on the results of the
            expansion.

       2.   Field splitting is not performed on the results of the
            expansion, with the exception of @.

       In addition, a parameter expansion can be modified by using one
       of the following formats.

       ${parameter:-word}    Use Default Values.  If parameter is unset
                             or null, the expansion of word is
                             substituted; otherwise, the value of
                             parameter is substituted.

       ${parameter:=word}    Assign Default Values.  If parameter is
                             unset or null, the expansion of word is
                             assigned to parameter.  In all cases, the
                             final value of parameter is substituted.
                             Only variables, not positional parameters
                             or special parameters, can be assigned in
                             this way.

       ${parameter:?[word]}  Indicate Error if Null or Unset.  If
                             parameter is unset or null, the expansion
                             of word (or a message indicating it is
                             unset if word is omitted) is written to
                             standard error and the shell exits with a
                             nonzero exit status.  Otherwise, the value
                             of parameter is substituted.  An
                             interactive shell need not exit.

       ${parameter:+word}    Use Alternative Value.  If parameter is
                             unset or null, null is substituted;
                             otherwise, the expansion of word is
                             substituted.

       In the parameter expansions shown previously, use of the colon in
       the format results in a test for a parameter that is unset or
       null; omission of the colon results in a test for a parameter
       that is only unset.

       ${#parameter}         String Length.  The length in characters of
                             the value of parameter.

       The following four varieties of parameter expansion provide for
       substring processing.  In each case, pattern matching notation
       (see “Shell Patterns”), rather than regular expression notation,
       is used to evaluate the patterns.  If parameter is * or @, the
       result of the expansion is unspecified.  Enclosing the full
       parameter expansion string in double-quotes does not cause the
       following four varieties of pattern characters to be quoted,
       whereas quoting characters within the braces has this effect.

       ${parameter%word}     Remove Smallest Suffix Pattern.  The word
                             is expanded to produce a pattern.  The
                             parameter expansion then results in
                             parameter, with the smallest portion of the
                             suffix matched by the pattern deleted.

       ${parameter%%word}    Remove Largest Suffix Pattern.  The word is
                             expanded to produce a pattern.  The
                             parameter expansion then results in
                             parameter, with the largest portion of the
                             suffix matched by the pattern deleted.

       ${parameter#word}     Remove Smallest Prefix Pattern.  The word
                             is expanded to produce a pattern.  The
                             parameter expansion then results in
                             parameter, with the smallest portion of the
                             prefix matched by the pattern deleted.

       ${parameter##word}    Remove Largest Prefix Pattern.  The word is
                             expanded to produce a pattern.  The
                             parameter expansion then results in
                             parameter, with the largest portion of the
                             prefix matched by the pattern deleted.

   <b>Command Substitution</b>
       Command substitution allows the output of a command to be
       substituted in place of the command name itself.  Command
       substitution occurs when the command is enclosed as follows:

             <b>$(command)</b>

       or (“backquoted” version):

             <b>`command`</b>

       The shell expands the command substitution by executing command
       in a subshell environment and replacing the command substitution
       with the standard output of the command, removing sequences of
       one or more ⟨newline⟩s at the end of the substitution.  (Embedded
       ⟨newline⟩s before the end of the output are not removed; however,
       during field splitting, they may be translated into ⟨space⟩s,
       depending on the value of IFS and quoting that is in effect.)

   <b>Arithmetic Expansion</b>
       Arithmetic expansion provides a mechanism for evaluating an
       arithmetic expression and substituting its value.  The format for
       arithmetic expansion is as follows:

             <b>$((expression))</b>

       The expression is treated as if it were in double-quotes, except
       that a double-quote inside the expression is not treated
       specially.  The shell expands all tokens in the expression for
       parameter expansion, command substitution, and quote removal.

       Next, the shell treats this as an arithmetic expression and
       substitutes the value of the expression.

   <b>White Space Splitting (Field Splitting)</b>
       After parameter expansion, command substitution, and arithmetic
       expansion the shell scans the results of expansions and
       substitutions that did not occur in double-quotes for field
       splitting and multiple fields can result.

       The shell treats each character of the IFS as a delimiter and
       uses the delimiters to split the results of parameter expansion
       and command substitution into fields.

       If IFS is empty, field splitting yields no fields if the input
       string was empty, and one string with the unchanged value of the
       input otherwise.  For example, with the default IFS, “<b>read -r </b>l”
       will remove any initial whitespace, but “IFS= <b>read -r </b>l” will
       leave the entire line in l.

   <b>Pathname Expansion (File Name Generation)</b>
       Unless the <b>-f </b>flag is set, file name generation is performed
       after word splitting is complete.  Each word is viewed as a
       series of patterns, separated by slashes.  The process of
       expansion replaces the word with the names of all existing files
       whose names can be formed by replacing each pattern with a string
       that matches the specified pattern.  There are two restrictions
       on this: first, a pattern cannot match a string containing a
       slash, and second, a pattern cannot match a string starting with
       a period unless the first character of the pattern is a period.
       The next section describes the patterns used for both Pathname
       Expansion and the <b>case </b>command.

   <b>Shell Patterns</b>
       A pattern consists of normal characters, which match themselves,
       and meta-characters.  The meta-characters are “!”, “*”, “?”, and
       “[”.  These characters lose their special meanings if they are
       quoted.  When command or variable substitution is performed and
       the dollar sign or back quotes are not double quoted, the value
       of the variable or the output of the command is scanned for these
       characters and they are turned into meta-characters.

       An asterisk (“*”) matches any string of characters.  A question
       mark matches any single character.  A left bracket (“[”)
       introduces a character class.  The end of the character class is
       indicated by a (“]”); if the “]” is missing then the “[” matches
       a “[” rather than introducing a character class.  A character
       class matches any of the characters between the square brackets.
       A range of characters may be specified using a minus sign.  The
       character class may be complemented by making an exclamation
       point the first character of the character class.

       To include a “]” in a character class, make it the first
       character listed (after the “!”, if any).  To include a minus
       sign, make it the first or last character listed.

   <b>Builtins</b>
       This section lists the builtin commands which are builtin because
       they need to perform some operation that can't be performed by a
       separate process.  In addition to these, there are several other
       commands that may be builtin for efficiency (e.g.  <i>printf</i>(1),
       <i>echo</i>(1), <i>test</i>(1), etc).

       :

       true   A null command that returns a 0 (true) exit value.

       false  A null command that returns a 1 (false) exit value.

       . file
              The commands in the specified file are read and executed
              by the shell.

       alias [<i>name</i>[<i>=string ...</i>]]
              If <i>name=string</i> is specified, the shell defines the alias
              <i>name</i> with value <i>string</i>.  If just <i>name</i> is specified, the
              value of the alias <i>name</i> is printed.  With no arguments,
              the <b>alias </b>builtin prints the names and values of all
              defined aliases (see <b>unalias</b>).

       bg [<i>job</i>] <i>...</i>
              Continue the specified jobs (or the current job if no jobs
              are given) in the background.

       command [<b>-p</b>] [<b>-v</b>] [<b>-V</b>] <i>command</i> [<i>arg ...</i>]
              Execute the specified command but ignore shell functions
              when searching for it.  (This is useful when you have a
              shell function with the same name as a builtin command.)

              <b>-p     </b>search for command using a PATH that guarantees to
                     find all the standard utilities.

              <b>-V     </b>Do not execute the command but search for the
                     command and print the resolution of the command
                     search.  This is the same as the type builtin.

              <b>-v     </b>Do not execute the command but search for the
                     command and print the absolute pathname of
                     utilities, the name for builtins or the expansion
                     of aliases.

       cd|chdir <i>-</i>

       cd|chdir [<b>-LP</b>] [<i>directory</i>]
              Switch to the specified directory (default HOME).  If an
              entry for CDPATH appears in the environment of the <b>cd</b>
              command or the shell variable CDPATH is set and the
              directory name does not begin with a slash, then the
              directories listed in CDPATH will be searched for the
              specified directory.  The format of CDPATH is the same as
              that of PATH.  If a single dash is specified as the
              argument, it will be replaced by the value of OLDPWD.  The
              <b>cd </b>command will print out the name of the directory that
              it actually switched to if this is different from the name
              that the user gave.  These may be different either because
              the CDPATH mechanism was used or because the argument is a
              single dash.  The <b>-P </b>option causes the physical directory
              structure to be used, that is, all symbolic links are
              resolved to their respective values.  The <b>-L </b>option turns
              off the effect of any preceding <b>-P </b>options.

       echo [<b>-n</b>] <i>args...</i>
              Print the arguments on the standard output, separated by
              spaces.  Unless the <b>-n </b>option is present, a newline is
              output following the arguments.

              If any of the following sequences of characters is
              encountered during output, the sequence is not output.
              Instead, the specified action is performed:

              <b>\b      </b>A backspace character is output.

              <b>\c      </b>Subsequent output is suppressed.  This is normally
                      used at the end of the last argument to suppress
                      the trailing newline that <b>echo </b>would otherwise
                      output.

              <b>\f      </b>Output a form feed.

              <b>\n      </b>Output a newline character.

              <b>\r      </b>Output a carriage return.

              <b>\t      </b>Output a (horizontal) tab character.

              <b>\v      </b>Output a vertical tab.

              <b>\0</b><i>digits</i>
                      Output the character whose value is given by zero
                      to three octal digits.  If there are zero digits,
                      a nul character is output.

              <b>\\      </b>Output a backslash.

              All other backslash sequences elicit undefined behaviour.

       eval <i>string ...</i>
              Concatenate all the arguments with spaces.  Then re-parse
              and execute the command.

       exec [<i>command arg ...</i>]
              Unless command is omitted, the shell process is replaced
              with the specified program (which must be a real program,
              not a shell builtin or function).  Any redirections on the
              <b>exec </b>command are marked as permanent, so that they are not
              undone when the <b>exec </b>command finishes.

       exit [<i>exitstatus</i>]
              Terminate the shell process.  If <i>exitstatus</i> is given it is
              used as the exit status of the shell; otherwise the exit
              status of the preceding command is used.

       export <i>name ...</i>

       export <b>-p</b>
              The specified names are exported so that they will appear
              in the environment of subsequent commands.  The only way
              to un-export a variable is to unset it.  The shell allows
              the value of a variable to be set at the same time it is
              exported by writing

                    <b>export name=value</b>

              With no arguments the export command lists the names of
              all exported variables.  With the <b>-p </b>option specified the
              output will be formatted suitably for non-interactive use.

       fc [<b>-e </b><i>editor</i>] [<i>first</i> [<i>last</i>]]

       fc <b>-l </b>[<b>-nr</b>] [<i>first</i> [<i>last</i>]]

       fc <b>-s </b>[<i>old=new</i>] [<i>first</i>]
              The <b>fc </b>builtin lists, or edits and re-executes, commands
              previously entered to an interactive shell.

              <b>-e </b>editor
                     Use the editor named by editor to edit the
                     commands.  The editor string is a command name,
                     subject to search via the PATH variable.  The value
                     in the FCEDIT variable is used as a default when <b>-e</b>
                     is not specified.  If FCEDIT is null or unset, the
                     value of the EDITOR variable is used.  If EDITOR is
                     null or unset, <i>ed</i>(1) is used as the editor.

              <b>-l </b>(ell)
                     List the commands rather than invoking an editor on
                     them.  The commands are written in the sequence
                     indicated by the first and last operands, as
                     affected by <b>-r</b>, with each command preceded by the
                     command number.

              <b>-n     </b>Suppress command numbers when listing with -l.

              <b>-r     </b>Reverse the order of the commands listed (with <b>-l</b>)
                     or edited (with neither <b>-l </b>nor <b>-s</b>).

              <b>-s     </b>Re-execute the command without invoking an editor.

              first

              last   Select the commands to list or edit.  The number of
                     previous commands that can be accessed are
                     determined by the value of the HISTSIZE variable.
                     The value of first or last or both are one of the
                     following:

                     [+]number
                            A positive number representing a command
                            number; command numbers can be displayed
                            with the <b>-l </b>option.

                     <b>-number</b>
                            A negative decimal number representing the
                            command that was executed number of commands
                            previously.  For example, -1 is the
                            immediately previous command.

              string
                     A string indicating the most recently entered
                     command that begins with that string.  If the
                     old=new operand is not also specified with <b>-s</b>, the
                     string form of the first operand cannot contain an
                     embedded equal sign.

              The following environment variables affect the execution
              of fc:

              FCEDIT    Name of the editor to use.

              HISTSIZE  The number of previous commands that are
                        accessible.

       fg [<i>job</i>]
              Move the specified job or the current job to the
              foreground.

       getopts <i>optstring var</i> [<i>arg ...</i>]
              The POSIX <b>getopts </b>command, not to be confused with the
              <i>Bell Labs</i>-derived <i>getopt</i>(1).

              The first argument should be a series of letters, each of
              which may be optionally followed by a colon to indicate
              that the option requires an argument.  The variable
              specified is set to the parsed option.

              The <b>getopts </b>command deprecates the older <i>getopt</i>(1) utility
              due to its handling of arguments containing whitespace.

              The <b>getopts </b>builtin may be used to obtain options and
              their arguments from a list of parameters.  When invoked,
              <b>getopts </b>places the value of the next option from the
              option string in the list in the shell variable specified
              by <i>var</i> and its index in the shell variable OPTIND.  When
              the shell is invoked, OPTIND is initialized to 1.  For
              each option that requires an argument, the <b>getopts </b>builtin
              will place it in the shell variable OPTARG.  If an option
              is not allowed for in the <i>optstring</i>, then OPTARG will be
              unset.

              By default, the variables <i>$1</i>, <i>...</i>, <i>$n</i> are inspected; if
              <i>arg</i>s are specified, they'll be parsed instead.

              <i>optstring</i> is a string of recognized option letters (see
              <i>getopt</i>(3)).  If a letter is followed by a colon, the
              option is expected to have an argument which may or may
              not be separated from it by white space.  If an option
              character is not found where expected, <b>getopts </b>will set
              the variable <i>var</i> to a “?”; <b>getopts </b>will then unset OPTARG
              and write output to standard error.  By specifying a colon
              as the first character of <i>optstring</i> all errors will be
              ignored.

              After the last option <b>getopts </b>will return a non-zero value
              and set <i>var</i> to “?”.

              The following code fragment shows how one might process
              the arguments for a command that can take the options [a]
              and [b], and the option [c], which requires an argument.

                    while getopts abc: f
                    do
                            case $f in
                            a | b)  flag=$f;;
                            c)      carg=$OPTARG;;
                            \?)     echo $USAGE; exit 1;;
                            esac
                    done
                    shift $((OPTIND - 1))

              This code will accept any of the following as equivalent:

                    cmd -acarg file file
                    cmd -a -c arg file file
                    cmd -carg -a file file
                    cmd -a -carg -- file file

       hash [<i>command ...</i>]

       hash <b>-r</b>
              The shell maintains a hash table which remembers the
              locations of commands.  With no arguments whatsoever, the
              <b>hash </b>command prints out the contents of this table.
              Entries which have not been looked at since the last <b>cd</b>
              command are marked with an asterisk; it is possible for
              these entries to be invalid.

              With arguments, the <b>hash </b>command removes the specified
              commands from the hash table (unless they are functions)
              and then locates them.  The <b>-r </b>option causes the hash
              command to delete all the entries in the hash table except
              for functions.

       jobs [<b>-lp</b>] [<i>job ...</i>]
              Display the status of all, or just the specified, <i>job</i>s:
                   By default  display the job number, currency (<b>+-</b>)
                               status, if any, the job state, and its
                               shell command.
                   <b>-l          </b>also output the PID of the group leader,
                               and just the PID and shell commands of
                               other members of the job.
                   <b>-p          </b>Display only leader PIDs, one per line.

       kill [<b>-s </b><i>sigspec</i> | <b>-</b><i>signum</i> | <b>-</b><i>sigspec</i>] [<i>pid</i> | <i>job ...</i>]
              Equivalent to <i>kill</i>(1), but a <i>job</i> spec may also be
              specified.  Signals can be either case-insensitive names
              without SIG prefixes or decimal numbers; the default is
              TERM.

       kill <b>-l </b>[<i>signum</i> | <i>exitstatus</i>]
              List available signal names without the SIG prefix
              (<i>sigspec</i>s).  If <i>signum</i> specified, display just the <i>sigspec</i>
              for that signal.  If <i>exitstatus</i> specified (&gt; <b>128</b>), display
              just the <i>sigspec</i> that caused it.

       pwd [<b>-LP</b>]
              builtin command remembers what the current directory is
              rather than recomputing it each time.  This makes it
              faster.  However, if the current directory is renamed, the
              builtin version of <b>pwd </b>will continue to print the old name
              for the directory.  The <b>-P </b>option causes the physical
              value of the current working directory to be shown, that
              is, all symbolic links are resolved to their respective
              values.  The <b>-L </b>option turns off the effect of any
              preceding <b>-P </b>options.

       read [<b>-p </b><i>prompt</i>] [<b>-r</b>] <i>variable</i> [<i>...</i>]
              The prompt is printed if the <b>-p </b>option is specified and
              the standard input is a terminal.  Then a line is read
              from the standard input.  The trailing newline is deleted
              from the line and the line is split as described in the
              section on word splitting above, and the pieces are
              assigned to the variables in order.  At least one variable
              must be specified.  If there are more pieces than
              variables, the remaining pieces (along with the characters
              in IFS that separated them) are assigned to the last
              variable.  If there are more variables than pieces, the
              remaining variables are assigned the null string.  The
              <b>read </b>builtin will indicate success unless EOF is
              encountered on input, in which case failure is returned.

              By default, unless the <b>-r </b>option is specified, the
              backslash “\” acts as an escape character, causing the
              following character to be treated literally.  If a
              backslash is followed by a newline, the backslash and the
              newline will be deleted.

       readonly <i>name ...</i>

       readonly <b>-p</b>
              The specified names are marked as read only, so that they
              cannot be subsequently modified or unset.  The shell
              allows the value of a variable to be set at the same time
              it is marked read only by writing

                    <b>readonly name=value</b>

              With no arguments the readonly command lists the names of
              all read only variables.  With the <b>-p </b>option specified the
              output will be formatted suitably for non-interactive use.

       printf <i>format</i> [<i>value</i>]...
              <b>printf </b>formats and prints its arguments according to
              <i>format</i>, a character string which contains three types of
              objects: plain characters, which are simply copied to
              standard output, character escape sequences which are
              converted and copied to the standard output, and format
              specifications, each of which causes printing of the next
              successive <i>value</i>.

              Each <i>value</i> is treated as a string if the corresponding
              format specification is either <b>b</b>, <b>c</b>, or <b>s</b>; otherwise it is
              evaluated as a C constant, with the following additions:
                    <b>•   </b>A leading plus or minus sign is allowed.
                    <b>•   </b>If the leading character is a single or double
                        quote, the value of the next byte.

              The format string is reused as often as necessary until
              all <i>value</i>s are consumed.  Any extra format specifications
              are evaluated with zero or the null string.

              Character escape sequences are in backslash notation as
              defined in ANSI X3.159-1989 (“ANSI C89”).  The characters
              and their meanings are as follows:

                    <b>\a      </b>Write a &lt;bell&gt; character.

                    <b>\b      </b>Write a &lt;backspace&gt; character.

                    <b>\f      </b>Write a &lt;form-feed&gt; character.

                    <b>\n      </b>Write a &lt;new-line&gt; character.

                    <b>\r      </b>Write a &lt;carriage return&gt; character.

                    <b>\t      </b>Write a &lt;tab&gt; character.

                    <b>\v      </b>Write a &lt;vertical tab&gt; character.

                    <b>\\      </b>Write a backslash character.

                    <b>\</b><i>num</i>    Write an 8-bit character whose ASCII value
                            is the 1-, 2-, or 3-digit octal number <i>num</i>.

              Each format specification is introduced by the percent
              character (``%'').  The remainder of the format
              specification includes, in the following order:

              Zero or more of the following flags:

                      <b>#       </b>A `#' character specifying that the value
                              should be printed in an ``alternative
                              form''.  For <b>b</b>, <b>c</b>, <b>d</b>, and <b>s </b>formats, this
                              option has no effect.  For the <b>o </b>format
                              the precision of the number is increased
                              to force the first character of the output
                              string to a zero.  For the <b>x </b>(<b>X</b>) format, a
                              non-zero result has the string <b>0x </b>(<b>0X</b>)
                              prepended to it.  For <b>e</b>, <b>E</b>, <b>f</b>, <b>g</b>, and <b>G</b>
                              formats, the result will always contain a
                              decimal point, even if no digits follow
                              the point (normally, a decimal point only
                              appears in the results of those formats if
                              a digit follows the decimal point).  For <b>g</b>
                              and <b>G </b>formats, trailing zeros are not
                              removed from the result as they would
                              otherwise be.

                      <b>-       </b>A minus sign `-' which specifies <i>left</i>
                              <i>adjustment</i> of the output in the indicated
                              field;

                      <b>+       </b>A `+' character specifying that there
                              should always be a sign placed before the
                              number when using signed formats.

                      ‘ ’     A space specifying that a blank should be
                              left before a positive number for a signed
                              format.  A `+' overrides a space if both
                              are used;

                      <b>0       </b>A zero `0' character indicating that zero-
                              padding should be used rather than blank-
                              padding.  A `-' overrides a `0' if both
                              are used;

              Field Width:
                      An optional digit string specifying a <i>field width</i>;
                      if the output string has fewer characters than the
                      field width it will be blank-padded on the left
                      (or right, if the left-adjustment indicator has
                      been given) to make up the field width (note that
                      a leading zero is a flag, but an embedded zero is
                      part of a field width);

              Precision:
                      An optional period, ‘<b>.</b>’, followed by an optional
                      digit string giving a <i>precision</i> which specifies
                      the number of digits to appear after the decimal
                      point, for <b>e </b>and <b>f </b>formats, or the maximum number
                      of bytes to be printed from a string (<b>b </b>and <b>s</b>
                      formats); if the digit string is missing, the
                      precision is treated as zero;

              Format:
                      A character which indicates the type of format to
                      use (one of <b>diouxXfwEgGbcs</b>).

              A field width or precision may be ‘<b>*</b>’ instead of a digit
              string.  In this case an <i>argument</i> supplies the field width
              or precision.

              The format characters and their meanings are:

              <b>diouXx      </b>The <i>argument</i> is printed as a signed decimal (d
                          or i), unsigned octal, unsigned decimal, or
                          unsigned hexadecimal (X or x), respectively.

              <b>f           </b>The <i>argument</i> is printed in the style
                          [-]ddd<b>.</b>ddd where the number of d's after the
                          decimal point is equal to the precision
                          specification for the argument.  If the
                          precision is missing, 6 digits are given; if
                          the precision is explicitly 0, no digits and
                          no decimal point are printed.

              <b>eE          </b>The <i>argument</i> is printed in the style
                          [-]d<b>.</b>ddd<b>e</b>±dd where there is one digit before
                          the decimal point and the number after is
                          equal to the precision specification for the
                          argument; when the precision is missing, 6
                          digits are produced.  An upper-case E is used
                          for an `E' format.

              <b>gG          </b>The <i>argument</i> is printed in style <b>f </b>or in style
                          <b>e </b>(<b>E</b>) whichever gives full precision in
                          minimum space.

              <b>b           </b>Characters from the string <i>argument</i> are
                          printed with backslash-escape sequences
                          expanded.
                          The following additional backslash-escape
                          sequences are supported:

                          <b>\c      </b>Causes <b>dash </b>to ignore any remaining
                                  characters in the string operand
                                  containing it, any remaining string
                                  operands, and any additional
                                  characters in the format operand.

                          <b>\0</b><i>num</i>   Write an 8-bit character whose ASCII
                                  value is the 1-, 2-, or 3-digit octal
                                  number <i>num</i>.

              <b>c           </b>The first character of <i>argument</i> is printed.

              <b>s           </b>Characters from the string <i>argument</i> are
                          printed until the end is reached or until the
                          number of bytes indicated by the precision
                          specification is reached; if the precision is
                          omitted, all characters in the string are
                          printed.

              <b>%           </b>Print a `%'; no argument is used.

              In no case does a non-existent or small field width cause
              truncation of a field; padding takes place only if the
              specified field width exceeds the actual width.

       set [{ <b>-options </b>| <b>+options </b>| <b>-- }</b>] <i>arg ...</i>
              The <b>set </b>command performs three different functions.

              With no arguments, it lists the values of all shell
              variables.

              If options are given, it sets the specified option flags,
              or clears them as described in the section called
              “Argument List Processing”.  As a special case, if the
              option is -o or +o and no argument is supplied, the shell
              prints the settings of all its options.  If the option is
              -o, the settings are printed in a human-readable format;
              if the option is +o, the settings are printed in a format
              suitable for reinput to the shell to affect the same
              option settings.

              In addition to the option names listed in the “Argument
              List Processing” section, the following options may be
              specified as arguments to -o or +o:

              <i>pipefail</i>  Derive the exit status of a pipeline from the
                        exit statuses of all of the commands in the
                        pipeline, not just the last command, as
                        described in the “Pipelines” section.

              The third use of the set command is to set the values of
              the shell's positional parameters to the specified args.
              To change the positional parameters without changing any
              options, use “--” as the first argument to set.  If no
              args are present, the set command will clear all the
              positional parameters (equivalent to executing “shift
              $#”.)

       shift [<i>n</i>]
              Shift the positional parameters n times.  A <b>shift </b>sets the
              value of <i>$1</i> to the value of <i>$2</i>, the value of <i>$2</i> to the
              value of <i>$3</i>, and so on, decreasing the value of <i>$#</i> by one.
              If n is greater than the number of positional parameters,
              <b>shift </b>will issue an error message, and exit with return
              status 2.

       test <i>expression</i>

       [ <i>expression</i> <b>]</b>
              The <b>test </b>utility evaluates the expression and, if it
              evaluates to true, returns a zero (true) exit status;
              otherwise it returns 1 (false).  If there is no
              expression, test also returns 1 (false).

              All operators and flags are separate arguments to the <b>test</b>
              utility.

              The following primaries are used to construct expression:

              <b>-b </b><i>file</i>       True if <i>file</i> exists and is a block special
                            file.

              <b>-c </b><i>file</i>       True if <i>file</i> exists and is a character
                            special file.

              <b>-d </b><i>file</i>       True if <i>file</i> exists and is a directory.

              <b>-e </b><i>file</i>       True if <i>file</i> exists (regardless of type).

              <b>-f </b><i>file</i>       True if <i>file</i> exists and is a regular file.

              <b>-g </b><i>file</i>       True if <i>file</i> exists and its set group ID
                            flag is set.

              <b>-h </b><i>file</i>       True if <i>file</i> exists and is a symbolic link.

              <b>-k </b><i>file</i>       True if <i>file</i> exists and its sticky bit is
                            set.

              <b>-n </b><i>string</i>     True if the length of <i>string</i> is nonzero.

              <b>-p </b><i>file</i>       True if <i>file</i> is a named pipe (FIFO).

              <b>-r </b><i>file</i>       True if <i>file</i> exists and is readable.

              <b>-s </b><i>file</i>       True if <i>file</i> exists and has a size greater
                            than zero.

              <b>-t </b><i>file_descriptor</i>
                            True if the file whose file descriptor
                            number is <i>file_descriptor</i> is open and is
                            associated with a terminal.

              <b>-u </b><i>file</i>       True if <i>file</i> exists and its set user ID flag
                            is set.

              <b>-w </b><i>file</i>       True if <i>file</i> exists and is writable.  True
                            indicates only that the write flag is on.
                            The file is not writable on a read-only file
                            system even if this test indicates true.

              <b>-x </b><i>file</i>       True if <i>file</i> exists and is executable.  True
                            indicates only that the execute flag is on.
                            If <i>file</i> is a directory, true indicates that
                            <i>file</i> can be searched.

              <b>-z </b><i>string</i>     True if the length of <i>string</i> is zero.

              <b>-L </b><i>file</i>       True if <i>file</i> exists and is a symbolic link.
                            This operator is retained for compatibility
                            with previous versions of this program.  Do
                            not rely on its existence; use <b>-h </b>instead.

              <b>-O </b><i>file</i>       True if <i>file</i> exists and its owner matches
                            the effective user id of this process.

              <b>-G </b><i>file</i>       True if <i>file</i> exists and its group matches
                            the effective group id of this process.

              <b>-S </b><i>file</i>       True if <i>file</i> exists and is a socket.

              <i>file1</i> <b>-nt </b><i>file2</i>
                            True if <i>file1</i> and <i>file2</i> exist and <i>file1</i> is
                            newer than <i>file2</i>.

              <i>file1</i> <b>-ot </b><i>file2</i>
                            True if <i>file1</i> and <i>file2</i> exist and <i>file1</i> is
                            older than <i>file2</i>.

              <i>file1</i> <b>-ef </b><i>file2</i>
                            True if <i>file1</i> and <i>file2</i> exist and refer to
                            the same file.

              <i>string</i>        True if <i>string</i> is not the null string.

              <i>s1</i> <b>= </b><i>s2</i>       True if the strings <i>s1</i> and <i>s2</i> are identical.

              <i>s1</i> <b>!= </b><i>s2</i>      True if the strings <i>s1</i> and <i>s2</i> are not
                            identical.

              <i>s1</i> <b>&lt; </b><i>s2</i>       True if string <i>s1</i> comes before <i>s2</i> based on
                            the ASCII value of their characters.

              <i>s1</i> <b>&gt; </b><i>s2</i>       True if string <i>s1</i> comes after <i>s2</i> based on
                            the ASCII value of their characters.

              <i>n1</i> <b>-eq </b><i>n2</i>     True if the integers <i>n1</i> and <i>n2</i> are
                            algebraically equal.

              <i>n1</i> <b>-ne </b><i>n2</i>     True if the integers <i>n1</i> and <i>n2</i> are not
                            algebraically equal.

              <i>n1</i> <b>-gt </b><i>n2</i>     True if the integer <i>n1</i> is algebraically
                            greater than the integer <i>n2</i>.

              <i>n1</i> <b>-ge </b><i>n2</i>     True if the integer <i>n1</i> is algebraically
                            greater than or equal to the integer <i>n2</i>.

              <i>n1</i> <b>-lt </b><i>n2</i>     True if the integer <i>n1</i> is algebraically less
                            than the integer <i>n2</i>.

              <i>n1</i> <b>-le </b><i>n2</i>     True if the integer <i>n1</i> is algebraically less
                            than or equal to the integer <i>n2</i>.

              These primaries can be combined with the following
              operators:

              <b>! </b><i>expression</i>  True if <i>expression</i> is false.

              <i>expression1</i> <b>-a </b><i>expression2</i>
                            True if both <i>expression1</i> and <i>expression2</i> are
                            true.

              <i>expression1</i> <b>-o </b><i>expression2</i>
                            True if either <i>expression1</i> or <i>expression2</i>
                            are true.

              <b>(</b><i>expression</i><b>)  </b>True if expression is true.

              The <b>-a </b>operator has higher precedence than the <b>-o</b>
              operator.

       times  Print the accumulated user and system times for the shell
              and for processes run from the shell.  The return status
              is 0.

       trap [<i>action signal ...</i>]
              Cause the shell to parse and execute action when any of
              the specified signals are received.  The signals are
              specified by signal number or as the name of the signal.
              If <i>signal</i> is <b>0 </b>or <b>EXIT</b>, the action is executed when the
              shell exits.  <i>action</i> may be empty (<b>''</b>), which causes the
              specified signals to be ignored.  With <i>action</i> omitted or
              set to `-' the specified signals are set to their default
              action.  When the shell forks off a subshell, it resets
              trapped (but not ignored) signals to the default action.
              The <b>trap </b>command has no effect on signals that were
              ignored on entry to the shell.  <b>trap </b>without any arguments
              cause it to write a list of signals and their associated
              action to the standard output in a format that is suitable
              as an input to the shell that achieves the same trapping
              results.

              Examples:

                    <b>trap</b>

              List trapped signals and their corresponding action

                    <b>trap '' INT QUIT tstp 30</b>

              Ignore signals INT QUIT TSTP USR1

                    <b>trap date INT</b>

              Print date upon receiving signal INT

       type [<i>name ...</i>]
              Interpret each name as a command and print the resolution
              of the command search.  Possible resolutions are: shell
              keyword, alias, shell builtin, command, tracked alias and
              not found.  For aliases the alias expansion is printed;
              for commands and tracked aliases the complete pathname of
              the command is printed.

       ulimit [<b>-H </b>| <b>-S</b>] [<b>-a </b>| <b>-tfdscmlpnvwr </b>[<i>value</i>]]
              Inquire about or set the hard or soft limits on processes
              or set new limits.  The choice between hard limit (which
              no process is allowed to violate, and which may not be
              raised once it has been lowered) and soft limit (which
              causes processes to be signaled but not necessarily
              killed, and which may be raised) is made with these flags:

              <b>-H          </b>set or inquire about hard limits

              <b>-S          </b>set or inquire about soft limits.  If neither
                          <b>-H </b>nor <b>-S </b>is specified, the soft limit is
                          displayed or both limits are set.  If both are
                          specified, the last one wins.

              The limit to be interrogated or set, then, is chosen by
              specifying any one of these flags:

              <b>-a          </b>show all the current limits

              <b>-t          </b>show or set the limit on CPU time (in seconds)

              <b>-f          </b>show or set the limit on the largest file that
                          can be created (in 512-byte blocks)

              <b>-d          </b>show or set the limit on the data segment size
                          of a process (in kilobytes)

              <b>-s          </b>show or set the limit on the stack size of a
                          process (in kilobytes)

              <b>-c          </b>show or set the limit on the largest core dump
                          size that can be produced (in 512-byte blocks)

              <b>-m          </b>show or set the limit on the total physical
                          memory that can be in use by a process (in
                          kilobytes)

              <b>-l          </b>show or set the limit on how much memory a
                          process can lock with <i>mlock</i>(2) (in kilobytes)

              <b>-p          </b>show or set the limit on the number of
                          processes this user can have at one time

              <b>-n          </b>show or set the limit on the number files a
                          process can have open at once

              <b>-v          </b>show or set the limit on the total virtual
                          memory that can be in use by a process (in
                          kilobytes)

              <b>-w          </b>show or set the limit on the total number of
                          locks held by a process

              <b>-r          </b>show or set the limit on the real-time
                          scheduling priority of a process

              If none of these is specified, it is the limit on file
              size that is shown or set.  If <i>value</i> is specified, the
              limit is set to that number; otherwise the current limit
              is displayed.  The special <i>value</i> <b>unlimited </b>represents the
              lack of any limit.

              Limits of an arbitrary process can be displayed or set
              using the <i>sysctl</i>(8) utility.

       umask [<i>mask</i>]
              Set the value of umask (see <i>umask</i>(2)) to the specified
              octal value.  If the argument is omitted, the umask value
              is printed.

       unalias [<b>-a</b>] [<i>name</i>]
              If <i>name</i> is specified, the shell removes that alias.  If <b>-a</b>
              is specified, all aliases are removed.

       unset [<b>-fv</b>] <i>name ...</i>
              The specified variables and functions are unset and
              unexported.  If <b>-f </b>or <b>-v </b>is specified, the corresponding
              function or variable is unset, respectively.  If a given
              name corresponds to both a variable and a function, and no
              options are given, only the variable is unset.

       wait [<i>job</i>]
              Wait for the specified job to complete and return the exit
              status of the last process in the job.  If the argument is
              omitted, wait for all jobs to complete and return an exit
              status of zero.

   <b>Command Line Editing</b>
       When <b>dash </b>is being used interactively from a terminal, the
       current command and the command history (see <b>fc </b>in “Builtins”)
       can be edited using vi-mode command-line editing.  This mode uses
       commands, described below, similar to a subset of those described
       in the vi man page.  The command ‘set -o vi’ enables vi-mode
       editing and places sh into vi insert mode.  With vi-mode enabled,
       sh can be switched between insert mode and command mode.  It is
       similar to vi: typing ⟨ESC⟩ enters vi command mode.  Hitting
       ⟨return⟩ while in command mode will pass the line to the shell.
</pre> <h2>
EXIT STATUS </h2>
<pre>
       Errors that are detected by the shell, such as a syntax error,
       will cause the shell to exit with a non-zero exit status.  If the
       shell is not an interactive shell, the execution of the shell
       file will be aborted.  Otherwise the shell will return the exit
       status of the last command executed, or if the exit builtin is
       used with a numeric argument, it will return the argument.
</pre> <h2>
ENVIRONMENT </h2>
<pre>
       HOME       Set automatically by <i>login</i>(1) from the user's login
                  directory in the password file (<i>passwd</i>(4)).  This
                  environment variable also functions as the default
                  argument for the cd builtin.

       PATH       The default search path for executables.  See the
                  above section “Path Search”.

       CDPATH     The search path used with the cd builtin.

       MAIL       The name of a mail file, that will be checked for the
                  arrival of new mail.  Overridden by MAILPATH.

       MAILCHECK  The frequency in seconds that the shell checks for the
                  arrival of mail in the files specified by the MAILPATH
                  or the MAIL file.  If set to 0, the check will occur
                  at each prompt.

       MAILPATH   A colon “:” separated list of file names, for the
                  shell to check for incoming mail.  This environment
                  setting overrides the MAIL setting.  There is a
                  maximum of 10 mailboxes that can be monitored at once.

       PS1        The primary prompt string, which defaults to “$ ”,
                  unless you are the superuser, in which case it
                  defaults to “# ”.

       PS2        The secondary prompt string, which defaults to “&gt; ”.

       PS4        Output before each line when execution trace (set -x)
                  is enabled, defaults to “+ ”.

       IFS        Input Field Separators.  This is normally set to
                  ⟨space⟩, ⟨tab⟩, and ⟨newline⟩.  See the “White Space
                  Splitting” section for more details.

       TERM       The default terminal setting for the shell.  This is
                  inherited by children of the shell, and is used in the
                  history editing modes.

       HISTSIZE   The number of lines in the history buffer for the
                  shell.

       PWD        The logical value of the current working directory.
                  This is set by the <b>cd </b>command.

       OLDPWD     The previous logical value of the current working
                  directory.  This is set by the <b>cd </b>command.

       PPID       The process ID of the parent process of the shell.
</pre> <h2>
FILES </h2>
<pre>
       <i>$HOME/.profile</i>

       <i>/etc/profile</i>
</pre> <h2>
SEE ALSO </h2>
<pre>
       <i>csh</i>(1), <i>echo</i>(1), <i>getopt</i>(1), <i>ksh</i>(1), <i>login</i>(1), <i>printf</i>(1), <i>test</i>(1),
       <i>getopt</i>(3), <i>passwd</i>(5), <i>environ</i>(7), <i>sysctl</i>(8)
</pre> <h2>
HISTORY </h2>
<pre>
       <b>dash </b>is a POSIX-compliant implementation of /bin/sh that aims to
       be as small as possible.  <b>dash </b>is a direct descendant of the
       NetBSD version of ash (the Almquist SHell), ported to Linux in
       early 1997.  It was renamed to <b>dash </b>in 2002.
</pre> <h2>
BUGS </h2>
<pre>
       Setuid shell scripts should be avoided at all costs, as they are
       a significant security risk.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>dash</i> (Debian Almquist shell) project.
       Information about the project can be found at
       <a href="http://gondor.apana.org.au/~herbert/dash/">http://gondor.apana.org.au/~herbert/dash/</a>.  If you have a bug
       report for this manual page, send it to dash@vger.kernel.org.
       This page was obtained from the project's upstream Git repository
       ⟨git://git.kernel.org/pub/scm/utils/dash/dash.git⟩ on 2024-06-14.
       (At that time, the date of the most recent commit that was found
       in the repository was 2024-06-08.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">GNU                         January 19, 2003                     <i>DASH</i>(1)</span>
</pre>  <p>Pages that refer to this page: <a href="intro.1.html">intro(1)</a>, <a href="systemctl.1.html">systemctl(1)</a>, <a href="../man3/system.3.html">system(3)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man1/dash.1.html" class="_attribution-link">https://man7.org/linux/man-pages/man1/dash.1.html</a>
  </p>
</div>
