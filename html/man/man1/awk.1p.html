<h1>awk(1p) — Linux manual page</h1>   <pre>
<span class="headline"><i>AWK</i>(1P)                 POSIX Programmer's Manual                <i>AWK</i>(1P)</span>
</pre> <h2>
PROLOG </h2>
<pre>
       This manual page is part of the POSIX Programmer's Manual.  The
       Linux implementation of this interface may differ (consult the
       corresponding Linux manual page for details of Linux behavior),
       or the interface may not be implemented on Linux.
</pre> <h2>
NAME </h2>
<pre>
       awk — pattern scanning and processing language
</pre> <h2>
SYNOPSIS </h2>
<pre>
       awk <b>[</b>-F <i>sepstring</i><b>] [</b>-v <i>assignment</i><b>]</b>... <i>program</i> <b>[</b><i>argument</i>...<b>]</b>

       awk <b>[</b>-F <i>sepstring</i><b>] </b>-f <i>progfile</i> <b>[</b>-f <i>progfile</i><b>]</b>... <b>[</b>-v <i>assignment</i><b>]</b>...
            <b>[</b><i>argument</i>...<b>]</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <i>awk</i> utility shall execute programs written in the <i>awk</i>
       programming language, which is specialized for textual data
       manipulation. An <i>awk</i> program is a sequence of patterns and
       corresponding actions. When input is read that matches a pattern,
       the action associated with that pattern is carried out.

       Input shall be interpreted as a sequence of records. By default,
       a record is a line, less its terminating &lt;newline&gt;, but this can
       be changed by using the <b>RS </b>built-in variable. Each record of
       input shall be matched in turn against each pattern in the
       program. For each pattern matched, the associated action shall be
       executed.

       The <i>awk</i> utility shall interpret each input record as a sequence
       of fields where, by default, a field is a string of non-&lt;blank&gt;
       non-&lt;newline&gt; characters. This default &lt;blank&gt; and &lt;newline&gt;
       field delimiter can be changed by using the <b>FS </b>built-in variable
       or the <b>-F </b><i>sepstring</i> option. The <i>awk</i> utility shall denote the
       first field in a record $1, the second $2, and so on. The symbol
       $0 shall refer to the entire record; setting any other field
       causes the re-evaluation of $0. Assigning to $0 shall reset the
       values of all other fields and the <b>NF </b>built-in variable.
</pre> <h2>
OPTIONS </h2>
<pre>
       The <i>awk</i> utility shall conform to the Base Definitions volume of
       POSIX.1‐2017, <i>Section 12.2</i>, <i>Utility Syntax Guidelines</i>.

       The following options shall be supported:

       <b>-F </b><i>sepstring</i>
                 Define the input field separator. This option shall be
                 equivalent to:

                     -v FS=<i>sepstring</i>

                 except that if <b>-F </b><i>sepstring</i> and <b>-v </b>FS=<i>sepstring</i> are
                 both used, it is unspecified whether the <b>FS </b>assignment
                 resulting from <b>-F </b><i>sepstring</i> is processed in command
                 line order or is processed after the last <b>-v</b>
                 FS=<i>sepstring</i>.  See the description of the <b>FS </b>built-in
                 variable, and how it is used, in the EXTENDED
                 DESCRIPTION section.

       <b>-f </b><i>progfile</i>
                 Specify the pathname of the file <i>progfile</i> containing an
                 <i>awk</i> program. A pathname of <b>'-' </b>shall denote the
                 standard input. If multiple instances of this option
                 are specified, the concatenation of the files specified
                 as <i>progfile</i> in the order specified shall be the <i>awk</i>
                 program. The <i>awk</i> program can alternatively be specified
                 in the command line as a single argument.

       <b>-v </b><i>assignment</i>
                 The application shall ensure that the <i>assignment</i>
                 argument is in the same form as an <i>assignment</i> operand.
                 The specified variable assignment shall occur prior to
                 executing the <i>awk</i> program, including the actions
                 associated with <b>BEGIN </b>patterns (if any). Multiple
                 occurrences of this option can be specified.
</pre> <h2>
OPERANDS </h2>
<pre>
       The following operands shall be supported:

       <i>program</i>   If no <b>-f </b>option is specified, the first operand to <i>awk</i>
                 shall be the text of the <i>awk</i> program. The application
                 shall supply the <i>program</i> operand as a single argument
                 to <i>awk</i>.  If the text does not end in a &lt;newline&gt;, <i>awk</i>
                 shall interpret the text as if it did.

       <i>argument</i>  Either of the following two types of <i>argument</i> can be
                 intermixed:

                 <i>file</i>      A pathname of a file that contains the input
                           to be read, which is matched against the set
                           of patterns in the program. If no <i>file</i>
                           operands are specified, or if a <i>file</i> operand
                           is <b>'-'</b>, the standard input shall be used.

                 <i>assignment</i>
                           An operand that begins with an &lt;underscore&gt;
                           or alphabetic character from the portable
                           character set (see the table in the Base
                           Definitions volume of POSIX.1‐2017, <i>Section</i>
                           <i>6.1</i>, <i>Portable Character Set</i>), followed by a
                           sequence of underscores, digits, and
                           alphabetics from the portable character set,
                           followed by the <b>'=' </b>character, shall specify
                           a variable assignment rather than a pathname.
                           The characters before the <b>'=' </b>represent the
                           name of an <i>awk</i> variable; if that name is an
                           <i>awk</i> reserved word (see <i>Grammar</i>) the behavior
                           is undefined. The characters following the
                           &lt;equals-sign&gt; shall be interpreted as if they
                           appeared in the <i>awk</i> program preceded and
                           followed by a double-quote (<b>'"'</b>) character,
                           as a <b>STRING </b>token (see <i>Grammar</i>), except that
                           if the last character is an unescaped
                           &lt;backslash&gt;, it shall be interpreted as a
                           literal &lt;backslash&gt; rather than as the first
                           character of the sequence <b>"\""</b>.  The variable
                           shall be assigned the value of that <b>STRING</b>
                           token and, if appropriate, shall be
                           considered a <i>numeric string</i> (see <i>Expressions</i>
                           <i>in awk</i>), the variable shall also be assigned
                           its numeric value. Each such variable
                           assignment shall occur just prior to the
                           processing of the following <i>file</i>, if any.
                           Thus, an assignment before the first <i>file</i>
                           argument shall be executed after the <b>BEGIN</b>
                           actions (if any), while an assignment after
                           the last <i>file</i> argument shall occur before the
                           <b>END </b>actions (if any). If there are no <i>file</i>
                           arguments, assignments shall be executed
                           before processing the standard input.
</pre> <h2>
STDIN </h2>
<pre>
       The standard input shall be used only if no <i>file</i> operands are
       specified, or if a <i>file</i> operand is <b>'-'</b>, or if a <i>progfile</i> option-
       argument is <b>'-'</b>; see the INPUT FILES section. If the <i>awk</i> program
       contains no actions and no patterns, but is otherwise a valid <i>awk</i>
       program, standard input and any <i>file</i> operands shall not be read
       and <i>awk</i> shall exit with a return status of zero.
</pre> <h2>
INPUT FILES </h2>
<pre>
       Input files to the <i>awk</i> program from any of the following sources
       shall be text files:

        *  Any <i>file</i> operands or their equivalents, achieved by modifying
           the <i>awk</i> variables <b>ARGV </b>and <b>ARGC</b>

        *  Standard input in the absence of any <i>file</i> operands

        *  Arguments to the <b>getline </b>function

       Whether the variable <b>RS </b>is set to a value other than a &lt;newline&gt;
       or not, for these files, implementations shall support records
       terminated with the specified separator up to {LINE_MAX} bytes
       and may support longer records.

       If <b>-f </b><i>progfile</i> is specified, the application shall ensure that
       the files named by each of the <i>progfile</i> option-arguments are text
       files and their concatenation, in the same order as they appear
       in the arguments, is an <i>awk</i> program.
</pre> <h2>
ENVIRONMENT VARIABLES </h2>
<pre>
       The following environment variables shall affect the execution of
       <i>awk</i>:

       <i>LANG</i>      Provide a default value for the internationalization
                 variables that are unset or null. (See the Base
                 Definitions volume of POSIX.1‐2017, <i>Section 8.2</i>,
                 <i>Internationalization Variables</i> for the precedence of
                 internationalization variables used to determine the
                 values of locale categories.)

       <i>LC_ALL</i>    If set to a non-empty string value, override the values
                 of all the other internationalization variables.

       <i>LC_COLLATE</i>
                 Determine the locale for the behavior of ranges,
                 equivalence classes, and multi-character collating
                 elements within regular expressions and in comparisons
                 of string values.

       <i>LC_CTYPE</i>  Determine the locale for the interpretation of
                 sequences of bytes of text data as characters (for
                 example, single-byte as opposed to multi-byte
                 characters in arguments and input files), the behavior
                 of character classes within regular expressions, the
                 identification of characters as letters, and the
                 mapping of uppercase and lowercase characters for the
                 <b>toupper </b>and <b>tolower </b>functions.

       <i>LC_MESSAGES</i>
                 Determine the locale that should be used to affect the
                 format and contents of diagnostic messages written to
                 standard error.

       <i>LC_NUMERIC</i>
                 Determine the radix character used when interpreting
                 numeric input, performing conversions between numeric
                 and string values, and formatting numeric output.
                 Regardless of locale, the &lt;period&gt; character (the
                 decimal-point character of the POSIX locale) is the
                 decimal-point character recognized in processing <i>awk</i>
                 programs (including assignments in command line
                 arguments).

       <i>NLSPATH</i>   Determine the location of message catalogs for the
                 processing of <i>LC_MESSAGES</i>.

       <i>PATH</i>      Determine the search path when looking for commands
                 executed by <i>system</i>(<i>expr</i>), or input and output pipes;
                 see the Base Definitions volume of POSIX.1‐2017,
                 <i>Chapter 8</i>, <i>Environment Variables</i>.

       In addition, all environment variables shall be visible via the
       <i>awk</i> variable <b>ENVIRON</b>.
</pre> <h2>
ASYNCHRONOUS EVENTS </h2>
<pre>
       Default.
</pre> <h2>
STDOUT </h2>
<pre>
       The nature of the output files depends on the <i>awk</i> program.
</pre> <h2>
STDERR </h2>
<pre>
       The standard error shall be used only for diagnostic messages.
</pre> <h2>
OUTPUT FILES </h2>
<pre>
       The nature of the output files depends on the <i>awk</i> program.
</pre> <h2>
EXTENDED DESCRIPTION </h2>
<pre>
   <b>Overall Program Structure</b>
       An <i>awk</i> program is composed of pairs of the form:

           <i>pattern</i> { <i>action</i> }

       Either the pattern or the action (including the enclosing brace
       characters) can be omitted.

       A missing pattern shall match any record of input, and a missing
       action shall be equivalent to:

           { print }

       Execution of the <i>awk</i> program shall start by first executing the
       actions associated with all <b>BEGIN </b>patterns in the order they
       occur in the program. Then each <i>file</i> operand (or standard input
       if no files were specified) shall be processed in turn by reading
       data from the file until a record separator is seen (&lt;newline&gt; by
       default). Before the first reference to a field in the record is
       evaluated, the record shall be split into fields, according to
       the rules in <i>Regular Expressions</i>, using the value of <b>FS </b>that was
       current at the time the record was read. Each pattern in the
       program then shall be evaluated in the order of occurrence, and
       the action associated with each pattern that matches the current
       record executed. The action for a matching pattern shall be
       executed before evaluating subsequent patterns. Finally, the
       actions associated with all <b>END </b>patterns shall be executed in the
       order they occur in the program.

   <b>Expressions in awk</b>
       Expressions describe computations used in <i>patterns</i> and <i>actions</i>.
       In the following table, valid expression operations are given in
       groups from highest precedence first to lowest precedence last,
       with equal-precedence operators grouped between horizontal lines.
       In expression evaluation, where the grammar is formally
       ambiguous, higher precedence operators shall be evaluated before
       lower precedence operators. In this table <i>expr</i>, <i>expr1</i>, <i>expr2</i>, and
       <i>expr3</i> represent any expression, while lvalue represents any
       entity that can be assigned to (that is, on the left side of an
       assignment operator).  The precise syntax of expressions is given
       in <i>Grammar</i>.

            <b>Table 4-1: Expressions in Decreasing Precedence in </b><i>awk</i>
┌──────────────────────┬─────────────────────────┬────────────────┬──────────────┐
│        <b>Syntax        </b>│          <b>Name           </b>│ <b>Type of Result </b>│<b>Associativity </b>│
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ ( <i>expr</i> )             │Grouping                 │Type of <i>expr</i>    │N/A           │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ $<i>expr</i>                │Field reference          │String          │N/A           │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ lvalue ++            │Post-increment           │Numeric         │N/A           │
│ lvalue --            │Post-decrement           │Numeric         │N/A           │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ ++ lvalue            │Pre-increment            │Numeric         │N/A           │
│ -- lvalue            │Pre-decrement            │Numeric         │N/A           │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ <i>expr</i> ^ <i>expr</i>          │Exponentiation           │Numeric         │Right         │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ ! <i>expr</i>               │Logical not              │Numeric         │N/A           │
│ + <i>expr</i>               │Unary plus               │Numeric         │N/A           │
│ - <i>expr</i>               │Unary minus              │Numeric         │N/A           │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ <i>expr</i> * <i>expr</i>          │Multiplication           │Numeric         │Left          │
│ <i>expr</i> / <i>expr</i>          │Division                 │Numeric         │Left          │
│ <i>expr</i> % <i>expr</i>          │Modulus                  │Numeric         │Left          │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ <i>expr</i> + <i>expr</i>          │Addition                 │Numeric         │Left          │
│ <i>expr</i> - <i>expr</i>          │Subtraction              │Numeric         │Left          │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ <i>expr expr</i>            │String concatenation     │String          │Left          │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ <i>expr</i> &lt; <i>expr</i>          │Less than                │Numeric         │None          │
│ <i>expr</i> &lt;= <i>expr</i>         │Less than or equal to    │Numeric         │None          │
│ <i>expr</i> != <i>expr</i>         │Not equal to             │Numeric         │None          │
│ <i>expr</i> == <i>expr</i>         │Equal to                 │Numeric         │None          │
│ <i>expr</i> &gt; <i>expr</i>          │Greater than             │Numeric         │None          │
│ <i>expr</i> &gt;= <i>expr</i>         │Greater than or equal to │Numeric         │None          │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ <i>expr</i> ~ <i>expr</i>          │ERE match                │Numeric         │None          │
│ <i>expr</i> !~ <i>expr</i>         │ERE non-match            │Numeric         │None          │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ <i>expr</i> in array        │Array membership         │Numeric         │Left          │
│ ( <i>index</i> ) in <i>array</i>   │Multi-dimension array    │Numeric         │Left          │
│                      │membership               │                │              │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ <i>expr</i> &amp;&amp; <i>expr</i>         │Logical AND              │Numeric         │Left          │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ <i>expr</i> || <i>expr</i>         │Logical OR               │Numeric         │Left          │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ <i>expr1</i> ? <i>expr2</i> : <i>expr3</i>│Conditional expression   │Type of selected│Right         │
│                      │                         │<i>expr2</i> or <i>expr3</i>  │              │
├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
│ lvalue ^= <i>expr</i>       │Exponentiation assignment│Numeric         │Right         │
│ lvalue %= <i>expr</i>       │Modulus assignment       │Numeric         │Right         │
│ lvalue *= <i>expr</i>       │Multiplication assignment│Numeric         │Right         │
│ lvalue /= <i>expr</i>       │Division assignment      │Numeric         │Right         │
│ lvalue += <i>expr</i>       │Addition assignment      │Numeric         │Right         │
│ lvalue -= <i>expr</i>       │Subtraction assignment   │Numeric         │Right         │
│ lvalue = <i>expr</i>        │Assignment               │Type of <i>expr</i>    │Right         │
└──────────────────────┴─────────────────────────┴────────────────┴──────────────┘

       Each expression shall have either a string value, a numeric
       value, or both. Except as stated for specific contexts, the value
       of an expression shall be implicitly converted to the type needed
       for the context in which it is used. A string value shall be
       converted to a numeric value either by the equivalent of the
       following calls to functions defined by the ISO C standard:

           setlocale(LC_NUMERIC, "");
           <i>numeric_value</i> = atof(<i>string_value</i>);

       or by converting the initial portion of the string to type <b>double</b>
       representation as follows:

              The input string is decomposed into two parts: an initial,
              possibly empty, sequence of white-space characters (as
              specified by <i>isspace</i>()) and a subject sequence interpreted
              as a floating-point constant.

              The expected form of the subject sequence is an optional
              <b>'+' </b>or <b>'-' </b>sign, then a non-empty sequence of digits
              optionally containing a &lt;period&gt;, then an optional
              exponent part. An exponent part consists of <b>'e' </b>or <b>'E'</b>,
              followed by an optional sign, followed by one or more
              decimal digits.

              The sequence starting with the first digit or the &lt;period&gt;
              (whichever occurs first) is interpreted as a floating
              constant of the C language, and if neither an exponent
              part nor a &lt;period&gt; appears, a &lt;period&gt; is assumed to
              follow the last digit in the string. If the subject
              sequence begins with a &lt;hyphen-minus&gt;, the value resulting
              from the conversion is negated.

       A numeric value that is exactly equal to the value of an integer
       (see <i>Section 1.1.2</i>, <i>Concepts Derived from the ISO C Standard</i>)
       shall be converted to a string by the equivalent of a call to the
       <b>sprintf </b>function (see <i>String Functions</i>) with the string <b>"%d" </b>as
       the <i>fmt</i> argument and the numeric value being converted as the
       first and only <i>expr</i> argument. Any other numeric value shall be
       converted to a string by the equivalent of a call to the <b>sprintf</b>
       function with the value of the variable <b>CONVFMT </b>as the <i>fmt</i>
       argument and the numeric value being converted as the first and
       only <i>expr</i> argument. The result of the conversion is unspecified
       if the value of <b>CONVFMT </b>is not a floating-point format
       specification. This volume of POSIX.1‐2017 specifies no explicit
       conversions between numbers and strings. An application can force
       an expression to be treated as a number by adding zero to it, or
       can force it to be treated as a string by concatenating the null
       string (<b>""</b>) to it.

       A string value shall be considered a <i>numeric string</i> if it comes
       from one of the following:

        1. Field variables

        2. Input from the <i>getline</i>() function

        3. <b>FILENAME</b>

        4. <b>ARGV </b>array elements

        5. <b>ENVIRON </b>array elements

        6. Array elements created by the <i>split</i>() function

        7. A command line variable assignment

        8. Variable assignment from another numeric string variable

       and an implementation-dependent condition corresponding to either
       case (a) or (b) below is met.

        a. After the equivalent of the following calls to functions
           defined by the ISO C standard, <i>string_value_end</i> would differ
           from <i>string_value</i>, and any characters before the terminating
           null character in <i>string_value_end</i> would be &lt;blank&gt;
           characters:

               char *string_value_end;
               setlocale(LC_NUMERIC, "");
               numeric_value = strtod (string_value, &amp;string_value_end);

        b. After all the following conversions have been applied, the
           resulting string would lexically be recognized as a <b>NUMBER</b>
           token as described by the lexical conventions in <i>Grammar</i>:

           --  All leading and trailing &lt;blank&gt; characters are
               discarded.

           --  If the first non-&lt;blank&gt; is <b>'+' </b>or <b>'-'</b>, it is discarded.

           --  Each occurrence of the decimal point character from the
               current locale is changed to a &lt;period&gt;.
       In case (a) the numeric value of the <i>numeric string</i> shall be the
       value that would be returned by the <i>strtod</i>() call. In case (b) if
       the first non-&lt;blank&gt; is <b>'-'</b>, the numeric value of the <i>numeric</i>
       <i>string</i> shall be the negation of the numeric value of the
       recognized <b>NUMBER </b>token; otherwise, the numeric value of the
       <i>numeric string</i> shall be the numeric value of the recognized
       <b>NUMBER </b>token. Whether or not a string is a <i>numeric string</i> shall
       be relevant only in contexts where that term is used in this
       section.

       When an expression is used in a Boolean context, if it has a
       numeric value, a value of zero shall be treated as false and any
       other value shall be treated as true. Otherwise, a string value
       of the null string shall be treated as false and any other value
       shall be treated as true.  A Boolean context shall be one of the
       following:

        *  The first subexpression of a conditional expression

        *  An expression operated on by logical NOT, logical AND, or
           logical OR

        *  The second expression of a <b>for </b>statement

        *  The expression of an <b>if </b>statement

        *  The expression of the <b>while </b>clause in either a <b>while </b>or
           <b>do</b>...<b>while </b>statement

        *  An expression used as a pattern (as in Overall Program
           Structure)

       All arithmetic shall follow the semantics of floating-point
       arithmetic as specified by the ISO C standard (see <i>Section 1.1.2</i>,
       <i>Concepts Derived from the ISO C Standard</i>).

       The value of the expression:

           <i>expr1</i> ^ <i>expr2</i>

       shall be equivalent to the value returned by the ISO C standard
       function call:

           pow(<i>expr1</i>, <i>expr2</i>)

       The expression:

           lvalue ^= <i>expr</i>

       shall be equivalent to the ISO C standard expression:

           lvalue = pow(lvalue, <i>expr</i>)

       except that lvalue shall be evaluated only once. The value of the
       expression:

           <i>expr1</i> % <i>expr2</i>

       shall be equivalent to the value returned by the ISO C standard
       function call:

           fmod(<i>expr1</i>, <i>expr2</i>)

       The expression:

           lvalue %= <i>expr</i>

       shall be equivalent to the ISO C standard expression:

           lvalue = fmod(lvalue, <i>expr</i>)

       except that lvalue shall be evaluated only once.

       Variables and fields shall be set by the assignment statement:

           lvalue = <i>expression</i>

       and the type of <i>expression</i> shall determine the resulting variable
       type. The assignment includes the arithmetic assignments (<b>"+="</b>,
       <b>"-="</b>, <b>"*="</b>, <b>"/="</b>, <b>"%="</b>, <b>"^="</b>, <b>"++"</b>, <b>"--"</b>) all of which shall
       produce a numeric result. The left-hand side of an assignment and
       the target of increment and decrement operators can be one of a
       variable, an array with index, or a field selector.

       The <i>awk</i> language supplies arrays that are used for storing
       numbers or strings.  Arrays need not be declared. They shall
       initially be empty, and their sizes shall change dynamically. The
       subscripts, or element identifiers, are strings, providing a type
       of associative array capability. An array name followed by a
       subscript within square brackets can be used as an lvalue and
       thus as an expression, as described in the grammar; see <i>Grammar</i>.
       Unsubscripted array names can be used in only the following
       contexts:

        *  A parameter in a function definition or function call

        *  The <b>NAME </b>token following any use of the keyword <b>in </b>as
           specified in the grammar (see <i>Grammar</i>); if the name used in
           this context is not an array name, the behavior is undefined

       A valid array <i>index</i> shall consist of one or more
       &lt;comma&gt;-separated expressions, similar to the way in which multi-
       dimensional arrays are indexed in some programming languages.
       Because <i>awk</i> arrays are really one-dimensional, such a
       &lt;comma&gt;-separated list shall be converted to a single string by
       concatenating the string values of the separate expressions, each
       separated from the other by the value of the <b>SUBSEP </b>variable.
       Thus, the following two index operations shall be equivalent:

           <i>var</i><b>[</b><i>expr1</i>, <i>expr2</i>, ... <i>exprn</i><b>]</b>

           <i>var</i><b>[</b><i>expr1</i> SUBSEP <i>expr2</i> SUBSEP ... SUBSEP <i>exprn</i><b>]</b>

       The application shall ensure that a multi-dimensioned <i>index</i> used
       with the <b>in </b>operator is parenthesized. The <b>in </b>operator, which
       tests for the existence of a particular array element, shall not
       cause that element to exist. Any other reference to a nonexistent
       array element shall automatically create it.

       Comparisons (with the <b>'&lt;'</b>, <b>"&lt;="</b>, <b>"!="</b>, <b>"=="</b>, <b>'&gt;'</b>, and <b>"&gt;="</b>
       operators) shall be made numerically if both operands are
       numeric, if one is numeric and the other has a string value that
       is a numeric string, or if one is numeric and the other has the
       uninitialized value.  Otherwise, operands shall be converted to
       strings as required and a string comparison shall be made as
       follows:

        *  For the <b>"!=" </b>and <b>"==" </b>operators, the strings should be
           compared to check if they are identical but may be compared
           using the locale-specific collation sequence to check if they
           collate equally.

        *  For the other operators, the strings shall be compared using
           the locale-specific collation sequence.

       The value of the comparison expression shall be 1 if the relation
       is true, or 0 if the relation is false.

   <b>Variables and Special Variables</b>
       Variables can be used in an <i>awk</i> program by referencing them. With
       the exception of function parameters (see <i>User-Defined</i>
       <i>Functions</i>), they are not explicitly declared. Function parameter
       names shall be local to the function; all other variable names
       shall be global. The same name shall not be used as both a
       function parameter name and as the name of a function or a
       special <i>awk</i> variable. The same name shall not be used both as a
       variable name with global scope and as the name of a function.
       The same name shall not be used within the same scope both as a
       scalar variable and as an array.  Uninitialized variables,
       including scalar variables, array elements, and field variables,
       shall have an uninitialized value. An uninitialized value shall
       have both a numeric value of zero and a string value of the empty
       string. Evaluation of variables with an uninitialized value, to
       either string or numeric, shall be determined by the context in
       which they are used.

       Field variables shall be designated by a <b>'$' </b>followed by a number
       or numerical expression. The effect of the field number
       <i>expression</i> evaluating to anything other than a non-negative
       integer is unspecified; uninitialized variables or string values
       need not be converted to numeric values in this context. New
       field variables can be created by assigning a value to them.
       References to nonexistent fields (that is, fields after $<b>NF</b>),
       shall evaluate to the uninitialized value. Such references shall
       not create new fields. However, assigning to a nonexistent field
       (for example, $(<b>NF</b>+2)=5) shall increase the value of <b>NF</b>; create
       any intervening fields with the uninitialized value; and cause
       the value of $0 to be recomputed, with the fields being separated
       by the value of <b>OFS</b>.  Each field variable shall have a string
       value or an uninitialized value when created. Field variables
       shall have the uninitialized value when created from $0 using <b>FS</b>
       and the variable does not contain any characters. If appropriate,
       the field variable shall be considered a numeric string (see
       <i>Expressions in awk</i>).

       Implementations shall support the following other special
       variables that are set by <i>awk</i>:

       <b>ARGC      </b>The number of elements in the <b>ARGV </b>array.

       <b>ARGV      </b>An array of command line arguments, excluding options
                 and the <i>program</i> argument, numbered from zero to <b>ARGC</b>-1.

                 The arguments in <b>ARGV </b>can be modified or added to; <b>ARGC</b>
                 can be altered. As each input file ends, <i>awk</i> shall
                 treat the next non-null element of <b>ARGV</b>, up to the
                 current value of <b>ARGC</b>-1, inclusive, as the name of the
                 next input file. Thus, setting an element of <b>ARGV </b>to
                 null means that it shall not be treated as an input
                 file. The name <b>'-' </b>indicates the standard input. If an
                 argument matches the format of an <i>assignment</i> operand,
                 this argument shall be treated as an <i>assignment</i> rather
                 than a <i>file</i> argument.

       <b>CONVFMT   </b>The <b>printf </b>format for converting numbers to strings
                 (except for output statements, where <b>OFMT </b>is used);
                 <b>"%.6g" </b>by default.

       <b>ENVIRON   </b>An array representing the value of the environment, as
                 described in the <i>exec</i> functions defined in the System
                 Interfaces volume of POSIX.1‐2017. The indices of the
                 array shall be strings consisting of the names of the
                 environment variables, and the value of each array
                 element shall be a string consisting of the value of
                 that variable. If appropriate, the environment variable
                 shall be considered a <i>numeric string</i> (see <i>Expressions</i>
                 <i>in awk</i>); the array element shall also have its numeric
                 value.

                 In all cases where the behavior of <i>awk</i> is affected by
                 environment variables (including the environment of any
                 commands that <i>awk</i> executes via the <b>system </b>function or
                 via pipeline redirections with the <b>print </b>statement, the
                 <b>printf </b>statement, or the <b>getline </b>function), the
                 environment used shall be the environment at the time
                 <i>awk</i> began executing; it is implementation-defined
                 whether any modification of <b>ENVIRON </b>affects this
                 environment.

       <b>FILENAME  </b>A pathname of the current input file. Inside a <b>BEGIN</b>
                 action the value is undefined. Inside an <b>END </b>action the
                 value shall be the name of the last input file
                 processed.

       <b>FNR       </b>The ordinal number of the current record in the current
                 file. Inside a <b>BEGIN </b>action the value shall be zero.
                 Inside an <b>END </b>action the value shall be the number of
                 the last record processed in the last file processed.

       <b>FS        </b>Input field separator regular expression; a &lt;space&gt; by
                 default.

       <b>NF        </b>The number of fields in the current record. Inside a
                 <b>BEGIN </b>action, the use of <b>NF </b>is undefined unless a
                 <b>getline </b>function without a <i>var</i> argument is executed
                 previously. Inside an <b>END </b>action, <b>NF </b>shall retain the
                 value it had for the last record read, unless a
                 subsequent, redirected, <b>getline </b>function without a <i>var</i>
                 argument is performed prior to entering the <b>END </b>action.

       <b>NR        </b>The ordinal number of the current record from the start
                 of input.  Inside a <b>BEGIN </b>action the value shall be
                 zero. Inside an <b>END </b>action the value shall be the
                 number of the last record processed.

       <b>OFMT      </b>The <b>printf </b>format for converting numbers to strings in
                 output statements (see <i>Output Statements</i>); <b>"%.6g" </b>by
                 default. The result of the conversion is unspecified if
                 the value of <b>OFMT </b>is not a floating-point format
                 specification.

       <b>OFS       </b>The <b>print </b>statement output field separator; &lt;space&gt; by
                 default.

       <b>ORS       </b>The <b>print </b>statement output record separator; a
                 &lt;newline&gt; by default.

       <b>RLENGTH   </b>The length of the string matched by the <b>match </b>function.

       <b>RS        </b>The first character of the string value of <b>RS </b>shall be
                 the input record separator; a &lt;newline&gt; by default. If
                 <b>RS </b>contains more than one character, the results are
                 unspecified. If <b>RS </b>is null, then records are separated
                 by sequences consisting of a &lt;newline&gt; plus one or more
                 blank lines, leading or trailing blank lines shall not
                 result in empty records at the beginning or end of the
                 input, and a &lt;newline&gt; shall always be a field
                 separator, no matter what the value of <b>FS </b>is.

       <b>RSTART    </b>The starting position of the string matched by the
                 <b>match </b>function, numbering from 1. This shall always be
                 equivalent to the return value of the <b>match </b>function.

       <b>SUBSEP    </b>The subscript separator string for multi-dimensional
                 arrays; the default value is implementation-defined.

   <b>Regular Expressions</b>
       The <i>awk</i> utility shall make use of the extended regular expression
       notation (see the Base Definitions volume of POSIX.1‐2017,
       <i>Section 9.4</i>, <i>Extended Regular Expressions</i>) except that it shall
       allow the use of C-language conventions for escaping special
       characters within the EREs, as specified in the table in the Base
       Definitions volume of POSIX.1‐2017, <i>Chapter 5</i>, <i>File Format</i>
       <i>Notation</i> (<b>'\\'</b>, <b>'\a'</b>, <b>'\b'</b>, <b>'\f'</b>, <b>'\n'</b>, <b>'\r'</b>, <b>'\t'</b>, <b>'\v'</b>) and the
       following table; these escape sequences shall be recognized both
       inside and outside bracket expressions. Note that records need
       not be separated by &lt;newline&gt; characters and string constants can
       contain &lt;newline&gt; characters, so even the <b>"\n" </b>sequence is valid
       in <i>awk</i> EREs. Using a &lt;slash&gt; character within an ERE requires the
       escaping shown in the following table.

                      <b>Table 4-2: Escape Sequences in </b><i>awk</i>
┌──────────┬────────────────────────────────────┬────────────────────────────────────┐
│  <b>Escape  </b>│                                    │                                    │
│ <b>Sequence </b>│            <b>Description             </b>│              <b>Meaning               </b>│
├──────────┼────────────────────────────────────┼────────────────────────────────────┤
│ \"       │ &lt;backslash&gt; &lt;quotation-mark&gt;       │ &lt;quotation-mark&gt; character         │
├──────────┼────────────────────────────────────┼────────────────────────────────────┤
│ \/       │ &lt;backslash&gt; &lt;slash&gt;                │ &lt;slash&gt; character                  │
├──────────┼────────────────────────────────────┼────────────────────────────────────┤
│ \ddd     │ A &lt;backslash&gt; character followed   │ The character whose encoding is    │
│          │ by the longest sequence of one,    │ represented by the one, two, or    │
│          │ two, or three octal-digit          │ three-digit octal integer. Multi-  │
│          │ characters (01234567). If all of   │ byte characters require multiple,  │
│          │ the digits are 0 (that is,         │ concatenated escape sequences of   │
│          │ representation of the NUL          │ this type, including the leading   │
│          │ character), the behavior is        │ &lt;backslash&gt; for each byte.         │
│          │ undefined.                         │                                    │
├──────────┼────────────────────────────────────┼────────────────────────────────────┤
│ \c       │ A &lt;backslash&gt; character followed   │ Undefined                          │
│          │ by any character not described in  │                                    │
│          │ this table or in the table in the  │                                    │
│          │ Base Definitions volume of         │                                    │
│          │ POSIX.1‐2017, <i>Chapter 5</i>, <i>File</i>      │                                    │
│          │ <i>Format Notation</i> (<b>'\\'</b>, <b>'\a'</b>, <b>'\b'</b>, │                                    │
│          │ <b>'\f'</b>, <b>'\n'</b>, <b>'\r'</b>, <b>'\t'</b>, <b>'\v'</b>).     │                                    │
└──────────┴────────────────────────────────────┴────────────────────────────────────┘

       A  regular  expression can be matched against a specific field or
       string by using  one  of  the  two  regular  expression  matching
       operators,  <b>'~'  </b>and <b>"!~"</b>.  These operators shall interpret their
       right-hand operand as a regular expression  and  their  left-hand
       operand  as  a  string.  If  the  regular  expression matches the
       string, the <b>'~' </b>expression shall evaluate to a value  of  1,  and
       the  <b>"!~" </b>expression shall evaluate to a value of 0. (The regular
       expression matching operation is as defined by the  term  matched
       in  the  Base  Definitions  volume  of POSIX.1‐2017, <i>Section 9.1</i>,
       <i>Regular Expression Definitions</i>, where a match occurs on any  part
       of  the  string unless the regular expression is limited with the
       &lt;circumflex&gt; or &lt;dollar-sign&gt; special characters.) If the regular
       expression does not match the string, the  <b>'~'  </b>expression  shall
       evaluate  to a value of 0, and the <b>"!~" </b>expression shall evaluate
       to a value of 1. If the  right-hand  operand  is  any  expression
       other  than  the  lexical  token  <b>ERE</b>,  the  string  value of the
       expression  shall  be  interpreted   as   an   extended   regular
       expression,  including  the  escape  conventions described above.
       Note that these same escape conventions shall also be applied  in
       determining  the  value  of  a  string literal (the lexical token
       <b>STRING</b>), and thus shall be applied a second time  when  a  string
       literal is used in this context.

       When  an  <b>ERE </b>token appears as an expression in any context other
       than as the right-hand of the <b>'~' </b>or <b>"!~" </b>operator or as  one  of
       the built-in function arguments described below, the value of the
       resulting expression shall be the equivalent of:

           $0 ~ /<i>ere</i>/

       The  <i>ere</i>  argument  to the <b>gsub</b>, <b>match</b>, <b>sub </b>functions, and the <i>fs</i>
       argument to the <b>split </b>function (see <i>String</i>  <i>Functions</i>)  shall  be
       interpreted  as extended regular expressions. These can be either
       <b>ERE </b>tokens or arbitrary expressions, and shall be interpreted  in
       the  same  manner  as  the  right-hand  side  of  the <b>'~' </b>or <b>"!~"</b>
       operator.

       An extended regular expression can be used to separate fields  by
       assigning  a  string  containing  the  expression to the built-in
       variable <b>FS</b>, either directly or as a consequence of using the  <b>-F</b>
       <i>sepstring</i>  option.  The default value of the <b>FS </b>variable shall be
       a single &lt;space&gt;.  The following describes <b>FS </b>behavior:

        1. If <b>FS </b>is a null string, the behavior is unspecified.

        2. If <b>FS </b>is a single character:

            a. If <b>FS </b>is &lt;space&gt;, skip leading and trailing &lt;blank&gt; and
               &lt;newline&gt; characters; fields shall be delimited by sets
               of one or more &lt;blank&gt; or &lt;newline&gt; characters.

            b. Otherwise, if <b>FS </b>is any other character <i>c</i>, fields shall
               be delimited by each single occurrence of <i>c</i>.

        3. Otherwise, the string value of <b>FS </b>shall be considered to be
           an extended regular expression. Each occurrence of a sequence
           matching the extended regular expression shall delimit
           fields.

       Except for the <b>'~' </b>and <b>"!~" </b>operators, and in the <b>gsub</b>, <b>match</b>,
       <b>split</b>, and <b>sub </b>built-in functions, ERE matching shall be based on
       input records; that is, record separator characters (the first
       character of the value of the variable <b>RS</b>, &lt;newline&gt; by default)
       cannot be embedded in the expression, and no expression shall
       match the record separator character. If the record separator is
       not &lt;newline&gt;, &lt;newline&gt; characters embedded in the expression
       can be matched. For the <b>'~' </b>and <b>"!~" </b>operators, and in those four
       built-in functions, ERE matching shall be based on text strings;
       that is, any character (including &lt;newline&gt; and the record
       separator) can be embedded in the pattern, and an appropriate
       pattern shall match any character. However, in all <i>awk</i> ERE
       matching, the use of one or more NUL characters in the pattern,
       input record, or text string produces undefined results.

   <b>Patterns</b>
       A <i>pattern</i> is any valid <i>expression</i>, a range specified by two
       expressions separated by a comma, or one of the two special
       patterns <b>BEGIN </b>or <b>END</b>.

   <b>Special Patterns</b>
       The <i>awk</i> utility shall recognize two special patterns, <b>BEGIN </b>and
       <b>END</b>.  Each <b>BEGIN </b>pattern shall be matched once and its associated
       action executed before the first record of input is read—except
       possibly by use of the <b>getline </b>function (see <i>Input/Output and</i>
       <i>General Functions</i>) in a prior <b>BEGIN </b>action—and before command
       line assignment is done. Each <b>END </b>pattern shall be matched once
       and its associated action executed after the last record of input
       has been read. These two patterns shall have associated actions.

       <b>BEGIN </b>and <b>END </b>shall not combine with other patterns. Multiple
       <b>BEGIN </b>and <b>END </b>patterns shall be allowed. The actions associated
       with the <b>BEGIN </b>patterns shall be executed in the order specified
       in the program, as are the <b>END </b>actions. An <b>END </b>pattern can
       precede a <b>BEGIN </b>pattern in a program.

       If an <i>awk</i> program consists of only actions with the pattern
       <b>BEGIN</b>, and the <b>BEGIN </b>action contains no <b>getline </b>function, <i>awk</i>
       shall exit without reading its input when the last statement in
       the last <b>BEGIN </b>action is executed. If an <i>awk</i> program consists of
       only actions with the pattern <b>END </b>or only actions with the
       patterns <b>BEGIN </b>and <b>END</b>, the input shall be read before the
       statements in the <b>END </b>actions are executed.

   <b>Expression Patterns</b>
       An expression pattern shall be evaluated as if it were an
       expression in a Boolean context. If the result is true, the
       pattern shall be considered to match, and the associated action
       (if any) shall be executed. If the result is false, the action
       shall not be executed.

   <b>Pattern Ranges</b>
       A pattern range consists of two expressions separated by a comma;
       in this case, the action shall be performed for all records
       between a match of the first expression and the following match
       of the second expression, inclusive. At this point, the pattern
       range can be repeated starting at input records subsequent to the
       end of the matched range.

   <b>Actions</b>
       An action is a sequence of statements as shown in the grammar in
       <i>Grammar</i>.  Any single statement can be replaced by a statement
       list enclosed in curly braces. The application shall ensure that
       statements in a statement list are separated by &lt;newline&gt; or
       &lt;semicolon&gt; characters. Statements in a statement list shall be
       executed sequentially in the order that they appear.

       The <i>expression</i> acting as the conditional in an <b>if </b>statement shall
       be evaluated and if it is non-zero or non-null, the following
       statement shall be executed; otherwise, if <b>else </b>is present, the
       statement following the <b>else </b>shall be executed.

       The <b>if</b>, <b>while</b>, <b>do</b>...<b>while</b>, <b>for</b>, <b>break</b>, and <b>continue </b>statements
       are based on the ISO C standard (see <i>Section 1.1.2</i>, <i>Concepts</i>
       <i>Derived from the ISO C Standard</i>), except that the Boolean
       expressions shall be treated as described in <i>Expressions in awk</i>,
       and except in the case of:

           for (<i>variable</i> in <i>array</i>)

       which shall iterate, assigning each <i>index</i> of <i>array</i> to <i>variable</i> in
       an unspecified order. The results of adding new elements to <i>array</i>
       within such a <b>for </b>loop are undefined. If a <b>break </b>or <b>continue</b>
       statement occurs outside of a loop, the behavior is undefined.

       The <b>delete </b>statement shall remove an individual array element.
       Thus, the following code deletes an entire array:

           for (index in array)
               delete array[index]

       The <b>next </b>statement shall cause all further processing of the
       current input record to be abandoned. The behavior is undefined
       if a <b>next </b>statement appears or is invoked in a <b>BEGIN </b>or <b>END</b>
       action.

       The <b>exit </b>statement shall invoke all <b>END </b>actions in the order in
       which they occur in the program source and then terminate the
       program without reading further input. An <b>exit </b>statement inside
       an <b>END </b>action shall terminate the program without further
       execution of <b>END </b>actions. If an expression is specified in an
       <b>exit </b>statement, its numeric value shall be the exit status of
       <i>awk</i>, unless subsequent errors are encountered or a subsequent
       <b>exit </b>statement with an expression is executed.

   <b>Output Statements</b>
       Both <b>print </b>and <b>printf </b>statements shall write to standard output
       by default. The output shall be written to the location specified
       by <i>output_redirection</i> if one is supplied, as follows:

           &gt; <i>expression</i>
           &gt;&gt; <i>expression</i>
           | <i>expression</i>

       In all cases, the <i>expression</i> shall be evaluated to produce a
       string that is used as a pathname into which to write (for <b>'&gt;' </b>or
       <b>"&gt;&gt;"</b>) or as a command to be executed (for <b>'|'</b>).  Using the first
       two forms, if the file of that name is not currently open, it
       shall be opened, creating it if necessary and using the first
       form, truncating the file. The output then shall be appended to
       the file. As long as the file remains open, subsequent calls in
       which <i>expression</i> evaluates to the same string value shall simply
       append output to the file. The file remains open until the <b>close</b>
       function (see <i>Input/Output and General Functions</i>) is called with
       an expression that evaluates to the same string value.

       The third form shall write output onto a stream piped to the
       input of a command. The stream shall be created if no stream is
       currently open with the value of <i>expression</i> as its command name.
       The stream created shall be equivalent to one created by a call
       to the <i>popen</i>() function defined in the System Interfaces volume
       of POSIX.1‐2017 with the value of <i>expression</i> as the <i>command</i>
       argument and a value of <i>w</i> as the <i>mode</i> argument. As long as the
       stream remains open, subsequent calls in which <i>expression</i>
       evaluates to the same string value shall write output to the
       existing stream. The stream shall remain open until the <b>close</b>
       function (see <i>Input/Output and General Functions</i>) is called with
       an expression that evaluates to the same string value.  At that
       time, the stream shall be closed as if by a call to the <i>pclose</i>()
       function defined in the System Interfaces volume of POSIX.1‐2017.

       As described in detail by the grammar in <i>Grammar</i>, these output
       statements shall take a &lt;comma&gt;-separated list of <i>expression</i>s
       referred to in the grammar by the non-terminal symbols <b>expr_list</b>,
       <b>print_expr_list</b>, or <b>print_expr_list_opt</b>.  This list is referred
       to here as the <i>expression list</i>, and each member is referred to as
       an <i>expression argument</i>.

       The <b>print </b>statement shall write the value of each expression
       argument onto the indicated output stream separated by the
       current output field separator (see variable <b>OFS </b>above), and
       terminated by the output record separator (see variable <b>ORS</b>
       above). All expression arguments shall be taken as strings, being
       converted if necessary; this conversion shall be as described in
       <i>Expressions in awk</i>, with the exception that the <b>printf </b>format in
       <b>OFMT </b>shall be used instead of the value in <b>CONVFMT</b>.  An empty
       expression list shall stand for the whole input record ($0).

       The <b>printf </b>statement shall produce output based on a notation
       similar to the File Format Notation used to describe file formats
       in this volume of POSIX.1‐2017 (see the Base Definitions volume
       of POSIX.1‐2017, <i>Chapter 5</i>, <i>File Format Notation</i>).  Output shall
       be produced as specified with the first <i>expression</i> argument as
       the string <i>format</i> and subsequent <i>expression</i> arguments as the
       strings <i>arg1</i> to <i>argn</i>, inclusive, with the following exceptions:

        1. The <i>format</i> shall be an actual character string rather than a
           graphical representation. Therefore, it cannot contain empty
           character positions. The &lt;space&gt; in the <i>format</i> string, in any
           context other than a <i>flag</i> of a conversion specification,
           shall be treated as an ordinary character that is copied to
           the output.

        2. If the character set contains a <b>'</b>' character and that
           character appears in the <i>format</i> string, it shall be treated
           as an ordinary character that is copied to the output.

        3. The <i>escape sequences</i> beginning with a &lt;backslash&gt; character
           shall be treated as sequences of ordinary characters that are
           copied to the output. Note that these same sequences shall be
           interpreted lexically by <i>awk</i> when they appear in literal
           strings, but they shall not be treated specially by the
           <b>printf </b>statement.

        4. A <i>field width</i> or <i>precision</i> can be specified as the <b>'*'</b>
           character instead of a digit string. In this case the next
           argument from the expression list shall be fetched and its
           numeric value taken as the field width or precision.

        5. The implementation shall not precede or follow output from
           the <b>d </b>or <b>u </b>conversion specifier characters with &lt;blank&gt;
           characters not specified by the <i>format</i> string.

        6. The implementation shall not precede output from the <b>o</b>
           conversion specifier character with leading zeros not
           specified by the <i>format</i> string.

        7. For the <b>c </b>conversion specifier character: if the argument has
           a numeric value, the character whose encoding is that value
           shall be output. If the value is zero or is not the encoding
           of any character in the character set, the behavior is
           undefined. If the argument does not have a numeric value, the
           first character of the string value shall be output; if the
           string does not contain any characters, the behavior is
           undefined.

        8. For each conversion specification that consumes an argument,
           the next expression argument shall be evaluated. With the
           exception of the <b>c </b>conversion specifier character, the value
           shall be converted (according to the rules specified in
           <i>Expressions in awk</i>) to the appropriate type for the
           conversion specification.

        9. If there are insufficient expression arguments to satisfy all
           the conversion specifications in the <i>format</i> string, the
           behavior is undefined.

       10. If any character sequence in the <i>format</i> string begins with a
           <b>'%' </b>character, but does not form a valid conversion
           specification, the behavior is unspecified.

       Both <b>print </b>and <b>printf </b>can output at least {LINE_MAX} bytes.

   <b>Functions</b>
       The <i>awk</i> language has a variety of built-in functions: arithmetic,
       string, input/output, and general.

   <b>Arithmetic Functions</b>
       The arithmetic functions, except for <b>int</b>, shall be based on the
       ISO C standard (see <i>Section 1.1.2</i>, <i>Concepts Derived from the ISO</i>
       <i>C Standard</i>).  The behavior is undefined in cases where the ISO C
       standard specifies that an error be returned or that the behavior
       is undefined. Although the grammar (see <i>Grammar</i>) permits built-in
       functions to appear with no arguments or parentheses, unless the
       argument or parentheses are indicated as optional in the
       following list (by displaying them within the <b>"[]" </b>brackets),
       such use is undefined.

       <b>atan2</b>(<i>y</i>,<i>x</i>)
                 Return arctangent of <i>y</i>/<i>x</i> in radians in the range
                 [-π,π].

       <b>cos</b>(<i>x</i>)    Return cosine of <i>x</i>, where <i>x</i> is in radians.

       <b>sin</b>(<i>x</i>)    Return sine of <i>x</i>, where <i>x</i> is in radians.

       <b>exp</b>(<i>x</i>)    Return the exponential function of <i>x</i>.

       <b>log</b>(<i>x</i>)    Return the natural logarithm of <i>x</i>.

       <b>sqrt</b>(<i>x</i>)   Return the square root of <i>x</i>.

       <b>int</b>(<i>x</i>)    Return the argument truncated to an integer. Truncation
                 shall be toward 0 when <i>x</i>&gt;0.

       <b>rand</b>()    Return a random number <i>n</i>, such that 0≤<i>n</i>&lt;1.

       <b>srand</b>(<b>[</b><i>expr</i><b>]</b>)
                 Set the seed value for <i>rand</i> to <i>expr</i> or use the time of
                 day if <i>expr</i> is omitted. The previous seed value shall
                 be returned.

   <b>String Functions</b>
       The string functions in the following list shall be supported.
       Although the grammar (see <i>Grammar</i>) permits built-in functions to
       appear with no arguments or parentheses, unless the argument or
       parentheses are indicated as optional in the following list (by
       displaying them within the <b>"[]" </b>brackets), such use is undefined.

       <b>gsub</b>(<i>ere</i>, <i>repl</i><b>[</b>, <i>in</i><b>]</b>)
                 Behave like <b>sub </b>(see below), except that it shall
                 replace all occurrences of the regular expression (like
                 the <i>ed</i> utility global substitute) in $0 or in the <i>in</i>
                 argument, when specified.

       <b>index</b>(<i>s</i>, <i>t</i>)
                 Return the position, in characters, numbering from 1,
                 in string <i>s</i> where string <i>t</i> first occurs, or zero if it
                 does not occur at all.

       <b>length[</b>(<b>[</b><i>s</i><b>]</b>)<b>]</b>
                 Return the length, in characters, of its argument taken
                 as a string, or of the whole record, $0, if there is no
                 argument.

       <b>match</b>(<i>s</i>, <i>ere</i>)
                 Return the position, in characters, numbering from 1,
                 in string <i>s</i> where the extended regular expression <i>ere</i>
                 occurs, or zero if it does not occur at all. RSTART
                 shall be set to the starting position (which is the
                 same as the returned value), zero if no match is found;
                 RLENGTH shall be set to the length of the matched
                 string, -1 if no match is found.

       <b>split</b>(<i>s</i>, <i>a</i><b>[</b>, <i>fs</i> <b>]</b>)
                 Split the string <i>s</i> into array elements <i>a</i>[1], <i>a</i>[2], ...,
                 <i>a</i>[<i>n</i>], and return <i>n</i>.  All elements of the array shall be
                 deleted before the split is performed. The separation
                 shall be done with the ERE <i>fs</i> or with the field
                 separator <b>FS </b>if <i>fs</i> is not given. Each array element
                 shall have a string value when created and, if
                 appropriate, the array element shall be considered a
                 numeric string (see <i>Expressions in awk</i>).  The effect of
                 a null string as the value of <i>fs</i> is unspecified.

       <b>sprintf</b>(<i>fmt</i>, <i>expr</i>, <i>expr</i>, ...)
                 Format the expressions according to the <b>printf </b>format
                 given by <i>fmt</i> and return the resulting string.

       <b>sub(</b><i>ere</i>, <i>repl</i><b>[</b>, <i>in</i> <b>]</b>)
                 Substitute the string <i>repl</i> in place of the first
                 instance of the extended regular expression <i>ERE</i> in
                 string <i>in</i> and return the number of substitutions. An
                 &lt;ampersand&gt; (<b>'&amp;'</b>) appearing in the string <i>repl</i> shall be
                 replaced by the string from <i>in</i> that matches the ERE. An
                 &lt;ampersand&gt; preceded with a &lt;backslash&gt; shall be
                 interpreted as the literal &lt;ampersand&gt; character. An
                 occurrence of two consecutive &lt;backslash&gt; characters
                 shall be interpreted as just a single literal
                 &lt;backslash&gt; character. Any other occurrence of a
                 &lt;backslash&gt; (for example, preceding any other
                 character) shall be treated as a literal &lt;backslash&gt;
                 character. Note that if <i>repl</i> is a string literal (the
                 lexical token <b>STRING</b>; see <i>Grammar</i>), the handling of the
                 &lt;ampersand&gt; character occurs after any lexical
                 processing, including any lexical &lt;backslash&gt;-escape
                 sequence processing. If <i>in</i> is specified and it is not
                 an lvalue (see <i>Expressions in awk</i>), the behavior is
                 undefined. If <i>in</i> is omitted, <i>awk</i> shall use the current
                 record ($0) in its place.

       <b>substr</b>(<i>s</i>, <i>m</i><b>[</b>, <i>n</i> <b>]</b>)
                 Return the at most <i>n</i>-character substring of <i>s</i> that
                 begins at position <i>m</i>, numbering from 1. If <i>n</i> is
                 omitted, or if <i>n</i> specifies more characters than are
                 left in the string, the length of the substring shall
                 be limited by the length of the string <i>s</i>.

       <b>tolower</b>(<i>s</i>)
                 Return a string based on the string <i>s</i>.  Each character
                 in <i>s</i> that is an uppercase letter specified to have a
                 <b>tolower </b>mapping by the <i>LC_CTYPE</i> category of the current
                 locale shall be replaced in the returned string by the
                 lowercase letter specified by the mapping. Other
                 characters in <i>s</i> shall be unchanged in the returned
                 string.

       <b>toupper</b>(<i>s</i>)
                 Return a string based on the string <i>s</i>.  Each character
                 in <i>s</i> that is a lowercase letter specified to have a
                 <b>toupper </b>mapping by the <i>LC_CTYPE</i> category of the current
                 locale is replaced in the returned string by the
                 uppercase letter specified by the mapping. Other
                 characters in <i>s</i> are unchanged in the returned string.

       All of the preceding functions that take <i>ERE</i> as a parameter
       expect a pattern or a string valued expression that is a regular
       expression as defined in <i>Regular Expressions</i>.

   <b>Input/Output and General Functions</b>
       The input/output and general functions are:

       <b>close</b>(<i>expression</i>)
                 Close the file or pipe opened by a <b>print </b>or <b>printf</b>
                 statement or a call to <b>getline </b>with the same string-
                 valued <i>expression</i>.  The limit on the number of open
                 <i>expression</i> arguments is implementation-defined. If the
                 close was successful, the function shall return zero;
                 otherwise, it shall return non-zero.

       <i>expression |</i> <b>getline [</b><i>var</i><b>]</b>
                 Read a record of input from a stream piped from the
                 output of a command. The stream shall be created if no
                 stream is currently open with the value of <i>expression</i>
                 as its command name. The stream created shall be
                 equivalent to one created by a call to the <i>popen</i>()
                 function with the value of <i>expression</i> as the <i>command</i>
                 argument and a value of <i>r</i> as the <i>mode</i> argument. As long
                 as the stream remains open, subsequent calls in which
                 <i>expression</i> evaluates to the same string value shall
                 read subsequent records from the stream. The stream
                 shall remain open until the <b>close </b>function is called
                 with an expression that evaluates to the same string
                 value. At that time, the stream shall be closed as if
                 by a call to the <i>pclose</i>() function. If <i>var</i> is omitted,
                 $0 and <b>NF </b>shall be set; otherwise, <i>var</i> shall be set
                 and, if appropriate, it shall be considered a numeric
                 string (see <i>Expressions in awk</i>).

                 The <b>getline </b>operator can form ambiguous constructs when
                 there are unparenthesized operators (including
                 concatenate) to the left of the <b>'|' </b>(to the beginning
                 of the expression containing <b>getline</b>).  In the context
                 of the <b>'$' </b>operator, <b>'|' </b>shall behave as if it had a
                 lower precedence than <b>'$'</b>.  The result of evaluating
                 other operators is unspecified, and conforming
                 applications shall parenthesize properly all such
                 usages.

       <b>getline   </b>Set $0 to the next input record from the current input
                 file. This form of <b>getline </b>shall set the <b>NF</b>, <b>NR</b>, and
                 <b>FNR </b>variables.

       <b>getline </b><i>var</i>
                 Set variable <i>var</i> to the next input record from the
                 current input file and, if appropriate, <i>var</i> shall be
                 considered a numeric string (see <i>Expressions in awk</i>).
                 This form of <b>getline </b>shall set the <b>FNR </b>and <b>NR</b>
                 variables.

       <b>getline [</b><i>var</i><b>] </b>&lt; <i>expression</i>
                 Read the next record of input from a named file. The
                 <i>expression</i> shall be evaluated to produce a string that
                 is used as a pathname.  If the file of that name is not
                 currently open, it shall be opened. As long as the
                 stream remains open, subsequent calls in which
                 <i>expression</i> evaluates to the same string value shall
                 read subsequent records from the file. The file shall
                 remain open until the <b>close </b>function is called with an
                 expression that evaluates to the same string value. If
                 <i>var</i> is omitted, $0 and <b>NF </b>shall be set; otherwise, <i>var</i>
                 shall be set and, if appropriate, it shall be
                 considered a numeric string (see <i>Expressions in awk</i>).

                 The <b>getline </b>operator can form ambiguous constructs when
                 there are unparenthesized binary operators (including
                 concatenate) to the right of the <b>'&lt;' </b>(up to the end of
                 the expression containing the <b>getline</b>).  The result of
                 evaluating such a construct is unspecified, and
                 conforming applications shall parenthesize properly all
                 such usages.

       <b>system</b>(<i>expression</i>)
                 Execute the command given by <i>expression</i> in a manner
                 equivalent to the <i>system</i>() function defined in the
                 System Interfaces volume of POSIX.1‐2017 and return the
                 exit status of the command.

       All forms of <b>getline </b>shall return 1 for successful input, zero
       for end-of-file, and -1 for an error.

       Where strings are used as the name of a file or pipeline, the
       application shall ensure that the strings are textually
       identical. The terminology ``same string value'' implies that
       ``equivalent strings'', even those that differ only by &lt;space&gt;
       characters, represent different files.

   <b>User-Defined Functions</b>
       The <i>awk</i> language also provides user-defined functions. Such
       functions can be defined as:

           function <i>name</i>(<b>[</b><i>parameter</i>, ...<b>]</b>) { <i>statements</i> }

       A function can be referred to anywhere in an <i>awk</i> program; in
       particular, its use can precede its definition. The scope of a
       function is global.

       Function parameters, if present, can be either scalars or arrays;
       the behavior is undefined if an array name is passed as a
       parameter that the function uses as a scalar, or if a scalar
       expression is passed as a parameter that the function uses as an
       array. Function parameters shall be passed by value if scalar and
       by reference if array name.

       The number of parameters in the function definition need not
       match the number of parameters in the function call. Excess
       formal parameters can be used as local variables. If fewer
       arguments are supplied in a function call than are in the
       function definition, the extra parameters that are used in the
       function body as scalars shall evaluate to the uninitialized
       value until they are otherwise initialized, and the extra
       parameters that are used in the function body as arrays shall be
       treated as uninitialized arrays where each element evaluates to
       the uninitialized value until otherwise initialized.

       When invoking a function, no white space can be placed between
       the function name and the opening parenthesis. Function calls can
       be nested and recursive calls can be made upon functions. Upon
       return from any nested or recursive function call, the values of
       all of the calling function's parameters shall be unchanged,
       except for array parameters passed by reference. The <b>return</b>
       statement can be used to return a value. If a <b>return </b>statement
       appears outside of a function definition, the behavior is
       undefined.

       In the function definition, &lt;newline&gt; characters shall be
       optional before the opening brace and after the closing brace.
       Function definitions can appear anywhere in the program where a
       <i>pattern-action</i> pair is allowed.

   <b>Grammar</b>
       The grammar in this section and the lexical conventions in the
       following section shall together describe the syntax for <i>awk</i>
       programs. The general conventions for this style of grammar are
       described in <i>Section 1.3</i>, <i>Grammar Conventions</i>.  A valid program
       can be represented as the non-terminal symbol <i>program</i> in the
       grammar. This formal syntax shall take precedence over the
       preceding text syntax description.

           %token NAME NUMBER STRING ERE
           %token FUNC_NAME   /* Name followed by '(' without white space. */

           /* Keywords */
           %token       Begin   End
           /*          'BEGIN' 'END'                            */

           %token       Break   Continue   Delete   Do   Else
           /*          'break' 'continue' 'delete' 'do' 'else'  */

           %token       Exit   For   Function   If   In
           /*          'exit' 'for' 'function' 'if' 'in'        */

           %token       Next   Print   Printf   Return   While
           /*          'next' 'print' 'printf' 'return' 'while' */

           /* Reserved function names */
           %token BUILTIN_FUNC_NAME
                       /* One token for the following:
                        * atan2 cos sin exp log sqrt int rand srand
                        * gsub index length match split sprintf sub
                        * substr tolower toupper close system
                        */
           %token GETLINE
                       /* Syntactically different from other built-ins. */

           /* Two-character tokens. */
           %token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN POW_ASSIGN
           /*     '+='       '-='       '*='       '/='       '%='       '^=' */

           %token OR   AND  NO_MATCH   EQ   LE   GE   NE   INCR  DECR  APPEND
           /*     '||' '&amp;&amp;' '!~' '==' '&lt;=' '&gt;=' '!=' '++'  '--'  '&gt;&gt;'   */

           /* One-character tokens. */
           %token '{' '}' '(' ')' '[' ']' ',' ';' NEWLINE
           %token '+' '-' '*' '%' '^' '!' '&gt;' '&lt;' '|' '?' ':' '~' '$' '='

           %start program
           %%

           program          : item_list
                            | item_list item
                            ;

           item_list        : /* empty */
                            | item_list item terminator
                            ;

           item             : action
                            | pattern action
                            | normal_pattern
                            | Function NAME      '(' param_list_opt ')'
                                  newline_opt action
                            | Function FUNC_NAME '(' param_list_opt ')'
                                  newline_opt action
                            ;

           param_list_opt   : /* empty */
                            | param_list
                            ;

           param_list       : NAME
                            | param_list ',' NAME
                            ;

           pattern          : normal_pattern
                            | special_pattern
                            ;

           normal_pattern   : expr
                            | expr ',' newline_opt expr
                            ;

           special_pattern  : Begin
                            | End
                            ;

           action           : '{' newline_opt                             '}'
                            | '{' newline_opt terminated_statement_list   '}'
                            | '{' newline_opt unterminated_statement_list '}'
                            ;

           terminator       : terminator NEWLINE
                            |            ';'
                            |            NEWLINE
                            ;

           terminated_statement_list : terminated_statement
                            | terminated_statement_list terminated_statement
                            ;

           unterminated_statement_list : unterminated_statement
                            | terminated_statement_list unterminated_statement
                            ;

           terminated_statement : action newline_opt
                            | If '(' expr ')' newline_opt terminated_statement
                            | If '(' expr ')' newline_opt terminated_statement
                                  Else newline_opt terminated_statement
                            | While '(' expr ')' newline_opt terminated_statement
                            | For '(' simple_statement_opt ';'
                                 expr_opt ';' simple_statement_opt ')' newline_opt
                                 terminated_statement
                            | For '(' NAME In NAME ')' newline_opt
                                 terminated_statement
                            | ';' newline_opt
                            | terminatable_statement NEWLINE newline_opt
                            | terminatable_statement ';'     newline_opt
                            ;

           unterminated_statement : terminatable_statement
                            | If '(' expr ')' newline_opt unterminated_statement
                            | If '(' expr ')' newline_opt terminated_statement
                                 Else newline_opt unterminated_statement
                            | While '(' expr ')' newline_opt unterminated_statement
                            | For '(' simple_statement_opt ';'
                             expr_opt ';' simple_statement_opt ')' newline_opt
                                 unterminated_statement
                            | For '(' NAME In NAME ')' newline_opt
                                 unterminated_statement
                            ;

           terminatable_statement : simple_statement
                            | Break
                            | Continue
                            | Next
                            | Exit expr_opt
                            | Return expr_opt
                            | Do newline_opt terminated_statement While '(' expr ')'
                            ;

           simple_statement_opt : /* empty */
                            | simple_statement
                            ;

           simple_statement : Delete NAME '[' expr_list ']'
                            | expr
                            | print_statement
                            ;

           print_statement  : simple_print_statement
                            | simple_print_statement output_redirection
                            ;

           simple_print_statement : Print  print_expr_list_opt
                            | Print  '(' multiple_expr_list ')'
                            | Printf print_expr_list
                            | Printf '(' multiple_expr_list ')'
                            ;

           output_redirection : '&gt;'    expr
                            | APPEND expr
                            | '|'    expr
                            ;

           expr_list_opt    : /* empty */
                            | expr_list
                            ;

           expr_list        : expr
                            | multiple_expr_list
                            ;

           multiple_expr_list : expr ',' newline_opt expr
                            | multiple_expr_list ',' newline_opt expr
                            ;

           expr_opt         : /* empty */
                            | expr
                            ;

           expr             : unary_expr
                            | non_unary_expr
                            ;

           unary_expr       : '+' expr
                            | '-' expr
                            | unary_expr '^'      expr
                            | unary_expr '*'      expr
                            | unary_expr '/'      expr
                            | unary_expr '%'      expr
                            | unary_expr '+'      expr
                            | unary_expr '-'      expr
                            | unary_expr          non_unary_expr
                            | unary_expr '&lt;'      expr
                            | unary_expr LE       expr
                            | unary_expr NE       expr
                            | unary_expr EQ       expr
                            | unary_expr '&gt;'      expr
                            | unary_expr GE       expr
                            | unary_expr '~'      expr
                            | unary_expr NO_MATCH expr
                            | unary_expr In NAME
                            | unary_expr AND newline_opt expr
                            | unary_expr OR  newline_opt expr
                            | unary_expr '?' expr ':' expr
                            | unary_input_function
                            ;

           non_unary_expr   : '(' expr ')'
                            | '!' expr
                            | non_unary_expr '^'      expr
                            | non_unary_expr '*'      expr
                            | non_unary_expr '/'      expr
                            | non_unary_expr '%'      expr
                            | non_unary_expr '+'      expr
                            | non_unary_expr '-'      expr
                            | non_unary_expr          non_unary_expr
                            | non_unary_expr '&lt;'      expr
                            | non_unary_expr LE       expr
                            | non_unary_expr NE       expr
                            | non_unary_expr EQ       expr
                            | non_unary_expr '&gt;'      expr
                            | non_unary_expr GE       expr
                            | non_unary_expr '~'      expr
                            | non_unary_expr NO_MATCH expr
                            | non_unary_expr In NAME
                            | '(' multiple_expr_list ')' In NAME
                            | non_unary_expr AND newline_opt expr
                            | non_unary_expr OR  newline_opt expr
                            | non_unary_expr '?' expr ':' expr
                            | NUMBER
                            | STRING
                            | lvalue
                            | ERE
                            | lvalue INCR
                            | lvalue DECR
                            | INCR lvalue
                            | DECR lvalue
                            | lvalue POW_ASSIGN expr
                            | lvalue MOD_ASSIGN expr
                            | lvalue MUL_ASSIGN expr
                            | lvalue DIV_ASSIGN expr
                            | lvalue ADD_ASSIGN expr
                            | lvalue SUB_ASSIGN expr
                            | lvalue '=' expr
                            | FUNC_NAME '(' expr_list_opt ')'
                                 /* no white space allowed before '(' */
                            | BUILTIN_FUNC_NAME '(' expr_list_opt ')'
                            | BUILTIN_FUNC_NAME
                            | non_unary_input_function
                            ;

           print_expr_list_opt : /* empty */
                            | print_expr_list
                            ;

           print_expr_list  : print_expr
                            | print_expr_list ',' newline_opt print_expr
                            ;

           print_expr       : unary_print_expr
                            | non_unary_print_expr
                            ;

           unary_print_expr : '+' print_expr
                            | '-' print_expr
                            | unary_print_expr '^'      print_expr
                            | unary_print_expr '*'      print_expr
                            | unary_print_expr '/'      print_expr
                            | unary_print_expr '%'      print_expr
                            | unary_print_expr '+'      print_expr
                            | unary_print_expr '-'      print_expr
                            | unary_print_expr          non_unary_print_expr
                            | unary_print_expr '~'      print_expr
                            | unary_print_expr NO_MATCH print_expr
                            | unary_print_expr In NAME
                            | unary_print_expr AND newline_opt print_expr
                            | unary_print_expr OR  newline_opt print_expr
                            | unary_print_expr '?' print_expr ':' print_expr
                            ;

           non_unary_print_expr : '(' expr ')'
                            | '!' print_expr
                            | non_unary_print_expr '^'      print_expr
                            | non_unary_print_expr '*'      print_expr
                            | non_unary_print_expr '/'      print_expr
                            | non_unary_print_expr '%'      print_expr
                            | non_unary_print_expr '+'      print_expr
                            | non_unary_print_expr '-'      print_expr
                            | non_unary_print_expr          non_unary_print_expr
                            | non_unary_print_expr '~'      print_expr
                            | non_unary_print_expr NO_MATCH print_expr
                            | non_unary_print_expr In NAME
                            | '(' multiple_expr_list ')' In NAME
                            | non_unary_print_expr AND newline_opt print_expr
                            | non_unary_print_expr OR  newline_opt print_expr
                            | non_unary_print_expr '?' print_expr ':' print_expr
                            | NUMBER
                            | STRING
                            | lvalue
                            | ERE
                            | lvalue INCR
                            | lvalue DECR
                            | INCR lvalue
                            | DECR lvalue
                            | lvalue POW_ASSIGN print_expr
                            | lvalue MOD_ASSIGN print_expr
                            | lvalue MUL_ASSIGN print_expr
                            | lvalue DIV_ASSIGN print_expr
                            | lvalue ADD_ASSIGN print_expr
                            | lvalue SUB_ASSIGN print_expr
                            | lvalue '=' print_expr
                            | FUNC_NAME '(' expr_list_opt ')'
                                /* no white space allowed before '(' */
                            | BUILTIN_FUNC_NAME '(' expr_list_opt ')'
                            | BUILTIN_FUNC_NAME
                            ;

           lvalue           : NAME
                            | NAME '[' expr_list ']'
                            | '$' expr
                            ;

           non_unary_input_function : simple_get
                            | simple_get '&lt;' expr
                            | non_unary_expr '|' simple_get
                            ;

           unary_input_function : unary_expr '|' simple_get
                            ;

           simple_get       : GETLINE
                            | GETLINE lvalue
                            ;

           newline_opt      : /* empty */
                            | newline_opt NEWLINE
                            ;

       This grammar has several ambiguities that shall be resolved as
       follows:

        *  Operator precedence and associativity shall be as described
           in <i>Table 4-1, Expressions in Decreasing Precedence in awk</i>.

        *  In case of ambiguity, an <b>else </b>shall be associated with the
           most immediately preceding <b>if </b>that would satisfy the grammar.

        *  In some contexts, a &lt;slash&gt; (<b>'/'</b>) that is used to surround an
           ERE could also be the division operator.  This shall be
           resolved in such a way that wherever the division operator
           could appear, a &lt;slash&gt; is assumed to be the division
           operator. (There is no unary division operator.)

       Each expression in an <i>awk</i> program shall conform to the precedence
       and associativity rules, even when this is not needed to resolve
       an ambiguity. For example, because <b>'$' </b>has higher precedence than
       <b>'++'</b>, the string <b>"$x++--" </b>is not a valid <i>awk</i> expression, even
       though it is unambiguously parsed by the grammar as <b>"$(x++)--"</b>.

       One convention that might not be obvious from the formal grammar
       is where &lt;newline&gt; characters are acceptable. There are several
       obvious placements such as terminating a statement, and a
       &lt;backslash&gt; can be used to escape &lt;newline&gt; characters between
       any lexical tokens. In addition, &lt;newline&gt; characters without
       &lt;backslash&gt; characters can follow a comma, an open brace, logical
       AND operator (<b>"&amp;&amp;"</b>), logical OR operator (<b>"||"</b>), the <b>do </b>keyword,
       the <b>else </b>keyword, and the closing parenthesis of an <b>if</b>, <b>for</b>, or
       <b>while </b>statement. For example:

           { print  $1,
                    $2 }

   <b>Lexical Conventions</b>
       The lexical conventions for <i>awk</i> programs, with respect to the
       preceding grammar, shall be as follows:

        1. Except as noted, <i>awk</i> shall recognize the longest possible
           token or delimiter beginning at a given point.

        2. A comment shall consist of any characters beginning with the
           &lt;number-sign&gt; character and terminated by, but excluding the
           next occurrence of, a &lt;newline&gt;.  Comments shall have no
           effect, except to delimit lexical tokens.

        3. The &lt;newline&gt; shall be recognized as the token <b>NEWLINE</b>.

        4. A &lt;backslash&gt; character immediately followed by a &lt;newline&gt;
           shall have no effect.

        5. The token <b>STRING </b>shall represent a string constant. A string
           constant shall begin with the character <b>'"'</b>.  Within a string
           constant, a &lt;backslash&gt; character shall be considered to
           begin an escape sequence as specified in the table in the
           Base Definitions volume of POSIX.1‐2017, <i>Chapter 5</i>, <i>File</i>
           <i>Format Notation</i> (<b>'\\'</b>, <b>'\a'</b>, <b>'\b'</b>, <b>'\f'</b>, <b>'\n'</b>, <b>'\r'</b>, <b>'\t'</b>,
           <b>'\v'</b>).  In addition, the escape sequences in <i>Table 4-2,</i>
           <i>Escape Sequences in awk</i> shall be recognized. A &lt;newline&gt;
           shall not occur within a string constant. A string constant
           shall be terminated by the first unescaped occurrence of the
           character <b>'"' </b>after the one that begins the string constant.
           The value of the string shall be the sequence of all
           unescaped characters and values of escape sequences between,
           but not including, the two delimiting <b>'"' </b>characters.

        6. The token <b>ERE </b>represents an extended regular expression
           constant. An ERE constant shall begin with the &lt;slash&gt;
           character. Within an ERE constant, a &lt;backslash&gt; character
           shall be considered to begin an escape sequence as specified
           in the table in the Base Definitions volume of POSIX.1‐2017,
           <i>Chapter 5</i>, <i>File Format Notation</i>.  In addition, the escape
           sequences in <i>Table 4-2, Escape Sequences in awk</i> shall be
           recognized. The application shall ensure that a &lt;newline&gt;
           does not occur within an ERE constant. An ERE constant shall
           be terminated by the first unescaped occurrence of the
           &lt;slash&gt; character after the one that begins the ERE constant.
           The extended regular expression represented by the ERE
           constant shall be the sequence of all unescaped characters
           and values of escape sequences between, but not including,
           the two delimiting &lt;slash&gt; characters.

        7. A &lt;blank&gt; shall have no effect, except to delimit lexical
           tokens or within <b>STRING </b>or <b>ERE </b>tokens.

        8. The token <b>NUMBER </b>shall represent a numeric constant. Its form
           and numeric value shall either be equivalent to the <b>decimal-</b>
           <b>floating-constant </b>token as specified by the ISO C standard,
           or it shall be a sequence of decimal digits and shall be
           evaluated as an integer constant in decimal. In addition,
           implementations may accept numeric constants with the form
           and numeric value equivalent to the <b>hexadecimal-constant </b>and
           <b>hexadecimal-floating-constant </b>tokens as specified by the
           ISO C standard.

           If the value is too large or too small to be representable
           (see <i>Section 1.1.2</i>, <i>Concepts Derived from the ISO C</i>
           <i>Standard</i>), the behavior is undefined.

        9. A sequence of underscores, digits, and alphabetics from the
           portable character set (see the Base Definitions volume of
           POSIX.1‐2017, <i>Section 6.1</i>, <i>Portable Character Set</i>), beginning
           with an &lt;underscore&gt; or alphabetic character, shall be
           considered a word.

       10. The following words are keywords that shall be recognized as
           individual tokens; the name of the token is the same as the
           keyword:
           <b>BEGIN      delete     END        function   in         printf</b>
           <b>break      do         exit       getline    next       return</b>
           <b>continue   else       for        if         print      while</b>

       11. The following words are names of built-in functions and shall
           be recognized as the token <b>BUILTIN_FUNC_NAME</b>:
           <b>atan2     gsub      log       split     sub       toupper</b>
           <b>close     index     match     sprintf   substr</b>
           <b>cos       int       rand      sqrt      system</b>
           <b>exp       length    sin       srand     tolower</b>

           The above-listed keywords and names of built-in functions are
           considered reserved words.

       12. The token <b>NAME </b>shall consist of a word that is not a keyword
           or a name of a built-in function and is not followed
           immediately (without any delimiters) by the <b>'(' </b>character.

       13. The token <b>FUNC_NAME </b>shall consist of a word that is not a
           keyword or a name of a built-in function, followed
           immediately (without any delimiters) by the <b>'(' </b>character.
           The <b>'(' </b>character shall not be included as part of the token.

       14. The following two-character sequences shall be recognized as
           the named tokens:
                ┌────────────┬──────────┬────────────┬──────────┐
                │ <b>Token Name </b>│ <b>Sequence </b>│ <b>Token Name </b>│ <b>Sequence </b>│
                ├────────────┼──────────┼────────────┼──────────┤
                │ <b>ADD_ASSIGN </b>│    +=    │ <b>NO_MATCH   </b>│    !~    │
                │ <b>SUB_ASSIGN </b>│    -=    │ <b>EQ         </b>│    ==    │
                │ <b>MUL_ASSIGN </b>│    *=    │ <b>LE         </b>│    &lt;=    │
                │ <b>DIV_ASSIGN </b>│    /=    │ <b>GE         </b>│    &gt;=    │
                │ <b>MOD_ASSIGN </b>│    %=    │ <b>NE         </b>│    !=    │
                │ <b>POW_ASSIGN </b>│    ^=    │ <b>INCR       </b>│    ++    │
                │ <b>OR         </b>│    ||    │ <b>DECR       </b>│    --    │
                │ <b>AND        </b>│    &amp;&amp;    │ <b>APPEND     </b>│    &gt;&gt;    │
                └────────────┴──────────┴────────────┴──────────┘

       15. The following single characters shall be recognized as tokens
           whose names are the character:

               &lt;newline&gt; { } ( ) [ ] , ; + - * % ^ ! &gt; &lt; | ? : ~ $ =

       There is a lexical ambiguity between the token <b>ERE </b>and the tokens
       <b>'/' </b>and <b>DIV_ASSIGN</b>.  When an input sequence begins with a &lt;slash&gt;
       character in any syntactic context where the token <b>'/' </b>or
       <b>DIV_ASSIGN </b>could appear as the next token in a valid program, the
       longer of those two tokens that can be recognized shall be
       recognized. In any other syntactic context where the token <b>ERE</b>
       could appear as the next token in a valid program, the token <b>ERE</b>
       shall be recognized.
</pre> <h2>
EXIT STATUS </h2>
<pre>
       The following exit values shall be returned:

        0    All input files were processed successfully.

       &gt;0    An error occurred.

       The exit status can be altered within the program by using an
       <b>exit </b>expression.
</pre> <h2>
CONSEQUENCES OF ERRORS </h2>
<pre>
       If any <i>file</i> operand is specified and the named file cannot be
       accessed, <i>awk</i> shall write a diagnostic message to standard error
       and terminate without any further action.

       If the program specified by either the <i>program</i> operand or a
       <i>progfile</i> operand is not a valid <i>awk</i> program (as specified in the
       EXTENDED DESCRIPTION section), the behavior is undefined.

       <i>The following sections are informative.</i>
</pre> <h2>
APPLICATION USAGE </h2>
<pre>
       The <b>index</b>, <b>length</b>, <b>match</b>, and <b>substr </b>functions should not be
       confused with similar functions in the ISO C standard; the <i>awk</i>
       versions deal with characters, while the ISO C standard deals
       with bytes.

       Because the concatenation operation is represented by adjacent
       expressions rather than an explicit operator, it is often
       necessary to use parentheses to enforce the proper evaluation
       precedence.

       When using <i>awk</i> to process pathnames, it is recommended that
       LC_ALL, or at least LC_CTYPE and LC_COLLATE, are set to POSIX or
       C in the environment, since pathnames can contain byte sequences
       that do not form valid characters in some locales, in which case
       the utility's behavior would be undefined. In the POSIX locale
       each byte is a valid single-byte character, and therefore this
       problem is avoided.

       On implementations where the <b>"==" </b>operator checks if strings
       collate equally, applications needing to check whether strings
       are identical can use:

           length(a) == length(b) &amp;&amp; index(a,b) == 1

       On implementations where the <b>"==" </b>operator checks if strings are
       identical, applications needing to check whether strings collate
       equally can use:

           a &lt;= b &amp;&amp; a &gt;= b
</pre> <h2>
EXAMPLES </h2>
<pre>
       The <i>awk</i> program specified in the command line is most easily
       specified within single-quotes (for example, '<i>program</i>') for
       applications using <i>sh</i>, because <i>awk</i> programs commonly contain
       characters that are special to the shell, including double-
       quotes. In the cases where an <i>awk</i> program contains single-quote
       characters, it is usually easiest to specify most of the program
       as strings within single-quotes concatenated by the shell with
       quoted single-quote characters. For example:

           awk '/'\''/ { print "quote:", $0 }'

       prints all lines from the standard input containing a single-
       quote character, prefixed with <i>quote</i>:.

       The following are examples of simple <i>awk</i> programs:

        1. Write to the standard output all input lines for which field
           3 is greater than 5:

               $3 &gt; 5

        2. Write every tenth line:

               (NR % 10) == 0

        3. Write any line with a substring matching the regular
           expression:

               /(G|D)(2[0-9][[:alpha:]]*)/

        4. Print any line with a substring containing a <b>'G' </b>or <b>'D'</b>,
           followed by a sequence of digits and characters. This example
           uses character classes <b>digit </b>and <b>alpha </b>to match language-
           independent digit and alphabetic characters respectively:

               /(G|D)([[:digit:][:alpha:]]*)/

        5. Write any line in which the second field matches the regular
           expression and the fourth field does not:

               $2 ~ /xyz/ &amp;&amp; $4 !~ /xyz/

        6. Write any line in which the second field contains a
           &lt;backslash&gt;:

               $2 ~ /\\/

        7. Write any line in which the second field contains a
           &lt;backslash&gt;.  Note that &lt;backslash&gt;-escapes are interpreted
           twice; once in lexical processing of the string and once in
           processing the regular expression:

               $2 ~ "\\\\"

        8. Write the second to the last and the last field in each line.
           Separate the fields by a &lt;colon&gt;:

               {OFS=":";print $(NF-1), $NF}

        9. Write the line number and number of fields in each line. The
           three strings representing the line number, the &lt;colon&gt;, and
           the number of fields are concatenated and that string is
           written to standard output:

               {print NR ":" NF}

       10. Write lines longer than 72 characters:

               length($0) &gt; 72

       11. Write the first two fields in opposite order separated by
           <b>OFS</b>:

               { print $2, $1 }

       12. Same, with input fields separated by a &lt;comma&gt; or &lt;space&gt; and
           &lt;tab&gt; characters, or both:

               BEGIN { FS = ",[ \t]*|[ \t]+" }
                     { print $2, $1 }

       13. Add up the first column, print sum, and average:

                     {s += $1 }
               END   {print "sum is ", s, " average is", s/NR}

       14. Write fields in reverse order, one per line (many lines out
           for each line in):

               { for (i = NF; i &gt; 0; --i) print $i }

       15. Write all lines between occurrences of the strings <b>start </b>and
           <b>stop</b>:

               /start/, /stop/

       16. Write all lines whose first field is different from the
           previous one:

               $1 != prev { print; prev = $1 }

       17. Simulate <i>echo</i>:

               BEGIN  {
                       for (i = 1; i &lt; ARGC; ++i)
                       printf("%s%s", ARGV[i], i==ARGC-1?"\n":" ")
               }

       18. Write the path prefixes contained in the <i>PATH</i> environment
           variable, one per line:

               BEGIN  {
                       n = split (ENVIRON["PATH"], path, ":")
                       for (i = 1; i &lt;= n; ++i)
                       print path[i]
               }

       19. If there is a file named <b>input </b>containing page headers of the
           form: Page #

           and a file named <b>program </b>that contains:

               /Page/   { $2 = n++; }
                        { print }

           then the command line:

               awk -f program n=5 input

           prints the file <b>input</b>, filling in page numbers starting at 5.
</pre> <h2>
RATIONALE </h2>
<pre>
       This description is based on the new <i>awk</i>, ``nawk'', (see the
       referenced <i>The AWK Programming Language</i>), which introduced a
       number of new features to the historical <i>awk</i>:

        1. New keywords: <b>delete</b>, <b>do</b>, <b>function</b>, <b>return</b>

        2. New built-in functions: <b>atan2</b>, <b>close</b>, <b>cos</b>, <b>gsub</b>, <b>match</b>, <b>rand</b>,
           <b>sin</b>, <b>srand</b>, <b>sub</b>, <b>system</b>

        3. New predefined variables: <b>FNR</b>, <b>ARGC</b>, <b>ARGV</b>, <b>RSTART</b>, <b>RLENGTH</b>,
           <b>SUBSEP</b>

        4. New expression operators: <b>?</b>, <b>:</b>, <b>,</b>, <b>^</b>

        5. The <b>FS </b>variable and the third argument to <b>split</b>, now treated
           as extended regular expressions.

        6. The operator precedence, changed to more closely match the C
           language.  Two examples of code that operate differently are:

               while ( n /= 10 &gt; 1) ...
               if (!"wk" ~ /bwk/) ...

       Several features have been added based on newer implementations
       of <i>awk</i>:

        *  Multiple instances of <b>-f </b><i>progfile</i> are permitted.

        *  The new option <b>-v </b><i>assignment.</i>

        *  The new predefined variable <b>ENVIRON</b>.

        *  New built-in functions <b>toupper </b>and <b>tolower</b>.

        *  More formatting capabilities are added to <b>printf </b>to match the
           ISO C standard.

       Earlier versions of this standard required implementations to
       support multiple adjacent &lt;semicolon&gt;s, lines with one or more
       &lt;semicolon&gt; before a rule (<i>pattern-action</i> pairs), and lines with
       only &lt;semicolon&gt;(s).  These are not required by this standard and
       are considered poor programming practice, but can be accepted by
       an implementation of <i>awk</i> as an extension.

       The overall <i>awk</i> syntax has always been based on the C language,
       with a few features from the shell command language and other
       sources. Because of this, it is not completely compatible with
       any other language, which has caused confusion for some users. It
       is not the intent of the standard developers to address such
       issues. A few relatively minor changes toward making the language
       more compatible with the ISO C standard were made; most of these
       changes are based on similar changes in recent implementations,
       as described above. There remain several C-language conventions
       that are not in <i>awk</i>.  One of the notable ones is the &lt;comma&gt;
       operator, which is commonly used to specify multiple expressions
       in the C language <b>for </b>statement. Also, there are various places
       where <i>awk</i> is more restrictive than the C language regarding the
       type of expression that can be used in a given context. These
       limitations are due to the different features that the <i>awk</i>
       language does provide.

       Regular expressions in <i>awk</i> have been extended somewhat from
       historical implementations to make them a pure superset of
       extended regular expressions, as defined by POSIX.1‐2008 (see the
       Base Definitions volume of POSIX.1‐2017, <i>Section 9.4</i>, <i>Extended</i>
       <i>Regular Expressions</i>).  The main extensions are
       internationalization features and interval expressions.
       Historical implementations of <i>awk</i> have long supported
       &lt;backslash&gt;-escape sequences as an extension to extended regular
       expressions, and this extension has been retained despite
       inconsistency with other utilities. The number of escape
       sequences recognized in both extended regular expressions and
       strings has varied (generally increasing with time) among
       implementations. The set specified by POSIX.1‐2008 includes most
       sequences known to be supported by popular implementations and by
       the ISO C standard. One sequence that is not supported is
       hexadecimal value escapes beginning with <b>'\x'</b>.  This would allow
       values expressed in more than 9 bits to be used within <i>awk</i> as in
       the ISO C standard. However, because this syntax has a non-
       deterministic length, it does not permit the subsequent character
       to be a hexadecimal digit. This limitation can be dealt with in
       the C language by the use of lexical string concatenation. In the
       <i>awk</i> language, concatenation could also be a solution for strings,
       but not for extended regular expressions (either lexical ERE
       tokens or strings used dynamically as regular expressions).
       Because of this limitation, the feature has not been added to
       POSIX.1‐2008.

       When a string variable is used in a context where an extended
       regular expression normally appears (where the lexical token ERE
       is used in the grammar) the string does not contain the literal
       &lt;slash&gt; characters.

       Some versions of <i>awk</i> allow the form:

           func name(args, ... ) { statements }

       This has been deprecated by the authors of the language, who
       asked that it not be specified.

       Historical implementations of <i>awk</i> produce an error if a <b>next</b>
       statement is executed in a <b>BEGIN </b>action, and cause <i>awk</i> to
       terminate if a <b>next </b>statement is executed in an <b>END </b>action. This
       behavior has not been documented, and it was not believed that it
       was necessary to standardize it.

       The specification of conversions between string and numeric
       values is much more detailed than in the documentation of
       historical implementations or in the referenced <i>The AWK</i>
       <i>Programming Language</i>. Although most of the behavior is designed
       to be intuitive, the details are necessary to ensure compatible
       behavior from different implementations. This is especially
       important in relational expressions since the types of the
       operands determine whether a string or numeric comparison is
       performed. From the perspective of an application developer, it
       is usually sufficient to expect intuitive behavior and to force
       conversions (by adding zero or concatenating a null string) when
       the type of an expression does not obviously match what is
       needed. The intent has been to specify historical practice in
       almost all cases. The one exception is that, in historical
       implementations, variables and constants maintain both string and
       numeric values after their original value is converted by any
       use. This means that referencing a variable or constant can have
       unexpected side-effects. For example, with historical
       implementations the following program:

           {
               a = "+2"
               b = 2
               if (NR % 2)
                   c = a + b
               if (a == b)
                   print "numeric comparison"
               else
                   print "string comparison"
           }

       would perform a numeric comparison (and output numeric
       comparison) for each odd-numbered line, but perform a string
       comparison (and output string comparison) for each even-numbered
       line. POSIX.1‐2008 ensures that comparisons will be numeric if
       necessary. With historical implementations, the following
       program:

           BEGIN {
               OFMT = "%e"
               print 3.14
               OFMT = "%f"
               print 3.14
           }

       would output <b>"3.140000e+00" </b>twice, because in the second <b>print</b>
       statement the constant <b>"3.14" </b>would have a string value from the
       previous conversion. POSIX.1‐2008 requires that the output of the
       second <b>print </b>statement be <b>"3.140000"</b>.  The behavior of historical
       implementations was seen as too unintuitive and unpredictable.

       It was pointed out that with the rules contained in early drafts,
       the following script would print nothing:

           BEGIN {
               y[1.5] = 1
               OFMT = "%e"
               print y[1.5]
           }

       Therefore, a new variable, <b>CONVFMT</b>, was introduced. The <b>OFMT</b>
       variable is now restricted to affecting output conversions of
       numbers to strings and <b>CONVFMT </b>is used for internal conversions,
       such as comparisons or array indexing. The default value is the
       same as that for <b>OFMT</b>, so unless a program changes <b>CONVFMT </b>(which
       no historical program would do), it will receive the historical
       behavior associated with internal string conversions.

       The POSIX <i>awk</i> lexical and syntactic conventions are specified
       more formally than in other sources. Again the intent has been to
       specify historical practice. One convention that may not be
       obvious from the formal grammar as in other verbal descriptions
       is where &lt;newline&gt; characters are acceptable. There are several
       obvious placements such as terminating a statement, and a
       &lt;backslash&gt; can be used to escape &lt;newline&gt; characters between
       any lexical tokens. In addition, &lt;newline&gt; characters without
       &lt;backslash&gt; characters can follow a comma, an open brace, a
       logical AND operator (<b>"&amp;&amp;"</b>), a logical OR operator (<b>"||"</b>), the <b>do</b>
       keyword, the <b>else </b>keyword, and the closing parenthesis of an <b>if</b>,
       <b>for</b>, or <b>while </b>statement. For example:

           { print $1,
                   $2 }

       The requirement that <i>awk</i> add a trailing &lt;newline&gt; to the program
       argument text is to simplify the grammar, making it match a text
       file in form. There is no way for an application or test suite to
       determine whether a literal &lt;newline&gt; is added or whether <i>awk</i>
       simply acts as if it did.

       POSIX.1‐2008 requires several changes from historical
       implementations in order to support internationalization.
       Probably the most subtle of these is the use of the decimal-point
       character, defined by the <i>LC_NUMERIC</i> category of the locale, in
       representations of floating-point numbers.  This locale-specific
       character is used in recognizing numeric input, in converting
       between strings and numeric values, and in formatting output.
       However, regardless of locale, the &lt;period&gt; character (the
       decimal-point character of the POSIX locale) is the decimal-point
       character recognized in processing <i>awk</i> programs (including
       assignments in command line arguments). This is essentially the
       same convention as the one used in the ISO C standard. The
       difference is that the C language includes the <i>setlocale</i>()
       function, which permits an application to modify its locale.
       Because of this capability, a C application begins executing with
       its locale set to the C locale, and only executes in the
       environment-specified locale after an explicit call to
       <i>setlocale</i>().  However, adding such an elaborate new feature to
       the <i>awk</i> language was seen as inappropriate for POSIX.1‐2008. It
       is possible to execute an <i>awk</i> program explicitly in any desired
       locale by setting the environment in the shell.

       The undefined behavior resulting from NULs in extended regular
       expressions allows future extensions for the GNU <i>gawk</i> program to
       process binary data.

       The behavior in the case of invalid <i>awk</i> programs (including
       lexical, syntactic, and semantic errors) is undefined because it
       was considered overly limiting on implementations to specify. In
       most cases such errors can be expected to produce a diagnostic
       and a non-zero exit status. However, some implementations may
       choose to extend the language in ways that make use of certain
       invalid constructs. Other invalid constructs might be deemed
       worthy of a warning, but otherwise cause some reasonable
       behavior. Still other constructs may be very difficult to detect
       in some implementations.  Also, different implementations might
       detect a given error during an initial parsing of the program
       (before reading any input files) while others might detect it
       when executing the program after reading some input. Implementors
       should be aware that diagnosing errors as early as possible and
       producing useful diagnostics can ease debugging of applications,
       and thus make an implementation more usable.

       The unspecified behavior from using multi-character <b>RS </b>values is
       to allow possible future extensions based on extended regular
       expressions used for record separators. Historical
       implementations take the first character of the string and ignore
       the others.

       Unspecified behavior when <i>split</i>(<i>string</i>,<i>array</i>,&lt;null&gt;) is used is
       to allow a proposed future extension that would split up a string
       into an array of individual characters.

       In the context of the <b>getline </b>function, equally good arguments
       for different precedences of the <b>| </b>and <b>&lt; </b>operators can be made.
       Historical practice has been that:

           getline &lt; "a" "b"

       is parsed as:

           ( getline &lt; "a" ) "b"

       although many would argue that the intent was that the file <b>ab</b>
       should be read. However:

           getline &lt; "x" + 1

       parses as:

           getline &lt; ( "x" + 1 )

       Similar problems occur with the <b>| </b>version of <b>getline</b>,
       particularly in combination with <b>$</b>.  For example:

           $"echo hi" | getline

       (This situation is particularly problematic when used in a <b>print</b>
       statement, where the <b>|getline </b>part might be a redirection of the
       <b>print</b>.)

       Since in most cases such constructs are not (or at least should
       not) be used (because they have a natural ambiguity for which
       there is no conventional parsing), the meaning of these
       constructs has been made explicitly unspecified. (The effect is
       that a conforming application that runs into the problem must
       parenthesize to resolve the ambiguity.)  There appeared to be few
       if any actual uses of such constructs.

       Grammars can be written that would cause an error under these
       circumstances. Where backwards-compatibility is not a large
       consideration, implementors may wish to use such grammars.

       Some historical implementations have allowed some built-in
       functions to be called without an argument list, the result being
       a default argument list chosen in some ``reasonable'' way. Use of
       <b>length </b>as a synonym for <b>length($0) </b>is the only one of these forms
       that is thought to be widely known or widely used; this
       particular form is documented in various places (for example,
       most historical <i>awk</i> reference pages, although not in the
       referenced <i>The AWK Programming Language</i>) as legitimate practice.
       With this exception, default argument lists have always been
       undocumented and vaguely defined, and it is not at all clear how
       (or if) they should be generalized to user-defined functions.
       They add no useful functionality and preclude possible future
       extensions that might need to name functions without calling
       them. Not standardizing them seems the simplest course. The
       standard developers considered that <b>length </b>merited special
       treatment, however, since it has been documented in the past and
       sees possibly substantial use in historical programs.
       Accordingly, this usage has been made legitimate, but Issue 5
       removed the obsolescent marking for XSI-conforming
       implementations and many otherwise conforming applications depend
       on this feature.

       In <b>sub </b>and <b>gsub</b>, if <i>repl</i> is a string literal (the lexical token
       <b>STRING</b>), then two consecutive &lt;backslash&gt; characters should be
       used in the string to ensure a single &lt;backslash&gt; will precede
       the &lt;ampersand&gt; when the resultant string is passed to the
       function. (For example, to specify one literal &lt;ampersand&gt; in the
       replacement string, use <b>gsub</b>(<b>ERE</b>, <b>"\\&amp;"</b>).)

       Historically, the only special character in the <i>repl</i> argument of
       <b>sub </b>and <b>gsub </b>string functions was the &lt;ampersand&gt; (<b>'&amp;'</b>) character
       and preceding it with the &lt;backslash&gt; character was used to turn
       off its special meaning.

       The description in the ISO POSIX‐2:1993 standard introduced
       behavior such that the &lt;backslash&gt; character was another special
       character and it was unspecified whether there were any other
       special characters. This description introduced several
       portability problems, some of which are described below, and so
       it has been replaced with the more historical description. Some
       of the problems include:

        *  Historically, to create the replacement string, a script
           could use <b>gsub</b>(<b>ERE</b>, <b>"\\&amp;"</b>), but with the ISO POSIX‐2:1993
           standard wording, it was necessary to use <b>gsub</b>(<b>ERE</b>, <b>"\\\\&amp;"</b>).
           The &lt;backslash&gt; characters are doubled here because all
           string literals are subject to lexical analysis, which would
           reduce each pair of &lt;backslash&gt; characters to a single
           &lt;backslash&gt; before being passed to <b>gsub</b>.

        *  Since it was unspecified what the special characters were,
           for portable scripts to guarantee that characters are printed
           literally, each character had to be preceded with a
           &lt;backslash&gt;.  (For example, a portable script had to use
           <b>gsub</b>(<b>ERE</b>, <b>"\\h\\i"</b>) to produce a replacement string of <b>"hi"</b>.)

       The description for comparisons in the ISO POSIX‐2:1993 standard
       did not properly describe historical practice because of the way
       numeric strings are compared as numbers. The current rules cause
       the following code:

           if (0 == "000")
               print "strange, but true"
           else
               print "not true"

       to do a numeric comparison, causing the <b>if </b>to succeed. It should
       be intuitively obvious that this is incorrect behavior, and
       indeed, no historical implementation of <i>awk</i> actually behaves this
       way.

       To fix this problem, the definition of <i>numeric string</i> was
       enhanced to include only those values obtained from specific
       circumstances (mostly external sources) where it is not possible
       to determine unambiguously whether the value is intended to be a
       string or a numeric.

       Variables that are assigned to a numeric string shall also be
       treated as a numeric string. (For example, the notion of a
       numeric string can be propagated across assignments.) In
       comparisons, all variables having the uninitialized value are to
       be treated as a numeric operand evaluating to the numeric value
       zero.

       Uninitialized variables include all types of variables including
       scalars, array elements, and fields. The definition of an
       uninitialized value in <i>Variables and Special Variables</i> is
       necessary to describe the value placed on uninitialized variables
       and on fields that are valid (for example, <b>&lt; $NF</b>) but have no
       characters in them and to describe how these variables are to be
       used in comparisons. A valid field, such as <b>$1</b>, that has no
       characters in it can be obtained from an input line of <b>"\t\t"</b>
       when <b>FS='\t'</b>.  Historically, the comparison (<b>$1&lt;</b>10) was done
       numerically after evaluating <b>$1 </b>to the value zero.

       The phrase ``... also shall have the numeric value of the numeric
       string'' was removed from several sections of the
       ISO POSIX‐2:1993 standard because is specifies an unnecessary
       implementation detail. It is not necessary for POSIX.1‐2008 to
       specify that these objects be assigned two different values.  It
       is only necessary to specify that these objects may evaluate to
       two different values depending on context.

       Historical implementations of <i>awk</i> did not parse hexadecimal
       integer or floating constants like <b>"0xa" </b>and <b>"0xap0"</b>.  Due to an
       oversight, the 2001 through 2004 editions of this standard
       required support for hexadecimal floating constants. This was due
       to the reference to <i>atof</i>().  This version of the standard allows
       but does not require implementations to use <i>atof</i>() and includes a
       description of how floating-point numbers are recognized as an
       alternative to match historic behavior. The intent of this change
       is to allow implementations to recognize floating-point constants
       according to either the ISO/IEC 9899:1990 standard or
       ISO/IEC 9899:1999 standard, and to allow (but not require)
       implementations to recognize hexadecimal integer constants.

       Historical implementations of <i>awk</i> did not support floating-point
       infinities and NaNs in <i>numeric strings</i>; e.g., <b>"-INF" </b>and <b>"NaN"</b>.
       However, implementations that use the <i>atof</i>() or <i>strtod</i>()
       functions to do the conversion picked up support for these values
       if they used a ISO/IEC 9899:1999 standard version of the function
       instead of a ISO/IEC 9899:1990 standard version. Due to an
       oversight, the 2001 through 2004 editions of this standard did
       not allow support for infinities and NaNs, but in this revision
       support is allowed (but not required). This is a silent change to
       the behavior of <i>awk</i> programs; for example, in the POSIX locale
       the expression:

           ("-INF" + 0 &lt; 0)

       formerly had the value 0 because <b>"-INF" </b>converted to 0, but now
       it may have the value 0 or 1.
</pre> <h2>
FUTURE DIRECTIONS </h2>
<pre>
       A future version of this standard may require the <b>"!=" </b>and <b>"=="</b>
       operators to perform string comparisons by checking if the
       strings are identical (and not by checking if they collate
       equally).
</pre> <h2>
SEE ALSO </h2>
<pre>
       <i>Section 1.3</i>, <i>Grammar Conventions</i>, <a href="grep.1p.html">grep(1p)</a>, <a href="lex.1p.html">lex(1p)</a>, <a href="sed.1p.html">sed(1p)</a>

       The Base Definitions volume of POSIX.1‐2017, <i>Chapter 5</i>, <i>File</i>
       <i>Format Notation</i>, <i>Section 6.1</i>, <i>Portable Character Set</i>, <i>Chapter 8</i>,
       <i>Environment Variables</i>, <i>Chapter 9</i>, <i>Regular Expressions</i>, <i>Section</i>
       <i>12.2</i>, <i>Utility Syntax Guidelines</i>

       The System Interfaces volume of POSIX.1‐2017, <a href="../man3/atof.3p.html">atof(3p)</a>, <a href="exec.1p.html">exec(1p)</a>,
       <a href="../man3/isspace.3p.html">isspace(3p)</a>, <a href="../man3/popen.3p.html">popen(3p)</a>, <a href="../man3/setlocale.3p.html">setlocale(3p)</a>, <a href="../man3/strtod.3p.html">strtod(3p)</a>
</pre> <h2>
COPYRIGHT </h2>
<pre>
       Portions of this text are reprinted and reproduced in electronic
       form from IEEE Std 1003.1-2017, Standard for Information
       Technology -- Portable Operating System Interface (POSIX), The
       Open Group Base Specifications Issue 7, 2018 Edition, Copyright
       (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any
       discrepancy between this version and the original IEEE and The
       Open Group Standard, the original IEEE and The Open Group
       Standard is the referee document. The original Standard can be
       obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page
       are most likely to have been introduced during the conversion of
       the source files to man page format. To report such errors, see
       <a href="https://www.kernel.org/doc/man-pages/reporting_bugs.html">https://www.kernel.org/doc/man-pages/reporting_bugs.html</a> .

<span class="footline">IEEE/The Open Group               2017                           <i>AWK</i>(1P)</span>
</pre>  <p>Pages that refer to this page: <a href="bc.1p.html">bc(1p)</a>, <a href="colrm.1.html">colrm(1)</a>, <a href="join.1p.html">join(1p)</a>, <a href="printf.1p.html">printf(1p)</a>, <a href="sed.1p.html">sed(1p)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man1/awk.1p.html" class="_attribution-link">https://man7.org/linux/man-pages/man1/awk.1p.html</a>
  </p>
</div>
