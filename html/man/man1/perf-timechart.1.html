<h1>perf-timechart(1) — Linux manual page</h1>   <pre>
<span class="headline"><i>PERF-TIMECHART</i>(1)              perf Manual             <i>PERF-TIMECHART</i>(1)</span>
</pre> <h2>
NAME </h2>
<pre>
       perf-timechart - Tool to visualize total system behavior during a
       workload
</pre> <h2>
SYNOPSIS </h2>
 <h2>
DESCRIPTION </h2>
<pre>
       There are two variants of perf timechart:

           'perf timechart record &lt;command&gt;' to record the system level events
           of an arbitrary workload. By default timechart records only scheduler
           and CPU events (task switches, running times, CPU power states, etc),
           but it's possible to record IO (disk, network) activity using -I argument.

           'perf timechart' to turn a trace into a Scalable Vector Graphics file,
           that can be viewed with popular SVG viewers such as 'Inkscape'. Depending
           on the events in the perf.data file, timechart will contain scheduler/cpu
           events or IO events.

           In IO mode, every bar has two charts: upper and lower.
           Upper bar shows incoming events (disk reads, ingress network packets).
           Lower bar shows outgoing events (disk writes, egress network packets).
           There are also poll bars which show how much time application spent
           in poll/epoll/select syscalls.
</pre> <h2>
TIMECHART OPTIONS </h2>
<pre>
       -o, --output=
           Select the output file (default: output.svg)

       -i, --input=
           Select the input file (default: perf.data unless stdin is a
           fifo)

       -w, --width=
           Select the width of the SVG file (default: 1000)

       -P, --power-only
           Only output the CPU power section of the diagram

       -T, --tasks-only
           Don’t output processor state transitions

       -p, --process
           Select the processes to display, by name or PID

       -f, --force
           Don’t complain, do it.

       --symfs=&lt;directory&gt;
           Look for files with symbols relative to this directory.

       -n, --proc-num
           Print task info for at least given number of tasks.

       -t, --topology
           Sort CPUs according to topology.

       --highlight=&lt;duration_nsecs|task_name&gt;
           Highlight tasks (using different color) that run more than
           given duration or tasks with given name. If number is given
           it’s interpreted as number of nanoseconds. If non-numeric
           string is given it’s interpreted as task name.

       --io-skip-eagain
           Don’t draw EAGAIN IO events.

       --io-min-time=&lt;nsecs&gt;
           Draw small events as if they lasted min-time. Useful when you
           need to see very small and fast IO. It’s possible to specify
           ms or us suffix to specify time in milliseconds or
           microseconds. Default value is 1ms.

       --io-merge-dist=&lt;nsecs&gt;
           Merge events that are merge-dist nanoseconds apart. Reduces
           number of figures on the SVG and makes it more
           render-friendly. It’s possible to specify ms or us suffix to
           specify time in milliseconds or microseconds. Default value
           is 1us.
</pre> <h2>
RECORD OPTIONS </h2>
<pre>
       -P, --power-only
           Record only power-related events

       -T, --tasks-only
           Record only tasks-related events

       -I, --io-only
           Record only io-related events

       -g, --callchain
           Do call-graph (stack chain/backtrace) recording
</pre> <h2>
EXAMPLES </h2>
<pre>
       $ perf timechart record git pull

           [ perf record: Woken up 13 times to write data ]
           [ perf record: Captured and wrote 4.253 MB perf.data (~185801 samples) ]

       $ perf timechart

           Written 10.2 seconds of trace to output.svg.

       Record system-wide timechart:

           $ perf timechart record

           then generate timechart and highlight 'gcc' tasks:

           $ perf timechart --highlight gcc

       Record system-wide IO events:

           $ perf timechart record -I

           then generate timechart:

           $ perf timechart
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="perf-record.1.html">perf-record(1)</a>
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>perf</i> (Performance analysis tools for
       Linux (in Linux source tree)) project.  Information about the
       project can be found at 
       ⟨<a href="https://perf.wiki.kernel.org/index.php/Main_Page">https://perf.wiki.kernel.org/index.php/Main_Page</a>⟩.  If you have a
       bug report for this manual page, send it to
       linux-kernel@vger.kernel.org.  This page was obtained from the
       project's upstream Git repository
       ⟨<a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git">http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git</a>⟩
       on 2024-06-14.  (At that time, the date of the most recent commit
       that was found in the repository was 2024-06-13.)  If you
       discover any rendering problems in this HTML version of the page,
       or you believe there is a better or more up-to-date source for
       the page, or you have corrections or improvements to the
       information in this COLOPHON (which is <i>not</i> part of the original
       manual page), send a mail to man-pages@man7.org

<span class="footline">perf                           2017-11-16              <i>PERF-TIMECHART</i>(1)</span>
</pre>          <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man1/perf-timechart.1.html" class="_attribution-link">https://man7.org/linux/man-pages/man1/perf-timechart.1.html</a>
  </p>
</div>
