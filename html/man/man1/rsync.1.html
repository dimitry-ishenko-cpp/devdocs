<h1>rsync(1) — Linux manual page</h1>   <pre>
<span class="headline"><i>rsync</i>(1)                      User Commands                     <i>rsync</i>(1)</span>
</pre> <h2>
NAME </h2>
<pre>
       rsync - a fast, versatile, remote (and local) file-copying tool
</pre> <h2>
SYNOPSIS </h2>
<pre>
       Local:
           rsync [OPTION...] SRC... [DEST]

       Access via remote shell:
           Pull:
               rsync [OPTION...] [USER@]HOST:SRC... [DEST]
           Push:
               rsync [OPTION...] SRC... [USER@]HOST:DEST

       Access via rsync daemon:
           Pull:
               rsync [OPTION...] [USER@]HOST::SRC... [DEST]
               rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
           Push:
               rsync [OPTION...] SRC... [USER@]HOST::DEST
               rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST)

       Usages with just one SRC arg and no DEST arg will list the source
       files instead of copying.

       The online version of this manpage (that includes cross-linking
       of topics) is available at 
       ⟨<a href="https://download.samba.org/pub/rsync/rsync.1">https://download.samba.org/pub/rsync/rsync.1</a>⟩.
</pre> <h2>
DESCRIPTION </h2>
<pre>
       Rsync is a fast and extraordinarily versatile file copying tool.
       It can copy locally, to/from another host over any remote shell,
       or to/from a remote rsync daemon.  It offers a large number of
       options that control every aspect of its behavior and permit very
       flexible specification of the set of files to be copied.  It is
       famous for its delta-transfer algorithm, which reduces the amount
       of data sent over the network by sending only the differences
       between the source files and the existing files in the
       destination.  Rsync is widely used for backups and mirroring and
       as an improved copy command for everyday use.

       Rsync finds files that need to be transferred using a "quick
       check" algorithm (by default) that looks for files that have
       changed in size or in last-modified time.  Any changes in the
       other preserved attributes (as requested by options) are made on
       the destination file directly when the quick check indicates that
       the file's data does not need to be updated.

       Some of the additional features of rsync are:

       o      support for copying links, devices, owners, groups, and
              permissions

       o      exclude and exclude-from options similar to GNU tar

       o      a CVS exclude mode for ignoring the same files that CVS
              would ignore

       o      can use any transparent remote shell, including ssh or rsh

       o      does not require super-user privileges

       o      pipelining of file transfers to minimize latency costs

       o      support for anonymous or authenticated rsync daemons
              (ideal for mirroring)
</pre> <h2>
GENERAL </h2>
<pre>
       Rsync copies files either to or from a remote host, or locally on
       the current host (it does not support copying files between two
       remote hosts).

       There are two different ways for rsync to contact a remote
       system: using a remote-shell program as the transport (such as
       ssh or rsh) or contacting an rsync daemon directly via TCP.  The
       remote-shell transport is used whenever the source or destination
       path contains a single colon (:) separator after a host
       specification.  Contacting an rsync daemon directly happens when
       the source or destination path contains a double colon (::)
       separator after a host specification, OR when an rsync:// URL is
       specified (see also the USING RSYNC-DAEMON FEATURES VIA A REMOTE-
       SHELL CONNECTION section for an exception to this latter rule).

       As a special case, if a single source arg is specified without a
       destination, the files are listed in an output format similar to
       "<b>ls -l</b>".

       As expected, if neither the source or destination path specify a
       remote host, the copy occurs locally (see also the <b>--list-only</b>
       option).

       Rsync refers to the local side as the client and the remote side
       as the server.  Don't confuse server with an rsync daemon.  A
       daemon is always a server, but a server can be either a daemon or
       a remote-shell spawned process.
</pre> <h2>
SETUP </h2>
<pre>
       See the file README.md for installation instructions.

       Once installed, you can use rsync to any machine that you can
       access via a remote shell (as well as some that you can access
       using the rsync daemon-mode protocol).  For remote transfers, a
       modern rsync uses ssh for its communications, but it may have
       been configured to use a different remote shell by default, such
       as rsh or remsh.

       You can also specify any remote shell you like, either by using
       the <b>-e </b>command line option, or by setting the <b>RSYNC_RSH</b>
       environment variable.

       Note that rsync must be installed on both the source and
       destination machines.
</pre> <h2>
USAGE </h2>
<pre>
       You use rsync in the same way you use rcp.  You must specify a
       source and a destination, one of which may be remote.

       Perhaps the best way to explain the syntax is with some examples:

           rsync -t *.c foo:src/

       This would transfer all files matching the pattern <b>*.c </b>from the
       current directory to the directory src on the machine foo.  If
       any of the files already exist on the remote system then the
       rsync remote-update protocol is used to update the file by
       sending only the differences in the data.  Note that the
       expansion of wildcards on the command-line (<b>*.c</b>) into a list of
       files is handled by the shell before it runs rsync and not by
       rsync itself (exactly the same as all other Posix-style
       programs).

           rsync -avz foo:src/bar /data/tmp

       This would recursively transfer all files from the directory
       src/bar on the machine foo into the /data/tmp/bar directory on
       the local machine.  The files are transferred in archive mode,
       which ensures that symbolic links, devices, attributes,
       permissions, ownerships, etc. are preserved in the transfer.
       Additionally, compression will be used to reduce the size of data
       portions of the transfer.

           rsync -avz foo:src/bar/ /data/tmp

       A trailing slash on the source changes this behavior to avoid
       creating an additional directory level at the destination.  You
       can think of a trailing / on a source as meaning "copy the
       contents of this directory" as opposed to "copy the directory by
       name", but in both cases the attributes of the containing
       directory are transferred to the containing directory on the
       destination.  In other words, each of the following commands
       copies the files in the same way, including their setting of the
       attributes of /dest/foo:

           rsync -av /src/foo /dest
           rsync -av /src/foo/ /dest/foo

       Note also that host and module references don't require a
       trailing slash to copy the contents of the default directory.
       For example, both of these copy the remote directory's contents
       into "/dest":

           rsync -av host: /dest
           rsync -av host::module /dest

       You can also use rsync in local-only mode, where both the source
       and destination don't have a ':' in the name.  In this case it
       behaves like an improved copy command.

       Finally, you can list all the (listable) modules available from a
       particular rsync daemon by leaving off the module name:

           rsync somehost.mydomain.com::
</pre> <h2>
COPYING TO A DIFFERENT NAME </h2>
<pre>
       When you want to copy a directory to a different name, use a
       trailing slash on the source directory to put the contents of the
       directory into any destination directory you like:

           rsync -ai foo/ bar/

       Rsync also has the ability to customize a destination file's name
       when copying a single item.  The rules for this are:

       o      The transfer list must consist of a single item (either a
              file or an empty directory)

       o      The final element of the destination path must not exist
              as a directory

       o      The destination path must not have been specified with a
              trailing slash

       Under those circumstances, rsync will set the name of the
       destination's single item to the last element of the destination
       path.  Keep in mind that it is best to only use this idiom when
       copying a file and use the above trailing-slash idiom when
       copying a directory.

       The following example copies the <b>foo.c </b>file as <b>bar.c </b>in the <b>save</b>
       dir (assuming that <b>bar.c </b>isn't a directory):

           rsync -ai src/foo.c save/bar.c

       The single-item copy rule might accidentally bite you if you
       unknowingly copy a single item and specify a destination dir that
       doesn't exist (without using a trailing slash).  For example, if
       <b>src/*.c </b>matches one file and <b>save/dir </b>doesn't exist, this will
       confuse you by naming the destination file <b>save/dir</b>:

           rsync -ai src/*.c save/dir

       To prevent such an accident, either make sure the destination dir
       exists or specify the destination path with a trailing slash:

           rsync -ai src/*.c save/dir/
</pre> <h2>
SORTED TRANSFER ORDER </h2>
<pre>
       Rsync always sorts the specified filenames into its internal
       transfer list.  This handles the merging together of the contents
       of identically named directories, makes it easy to remove
       duplicate filenames. It can, however, confuse someone when the
       files are transferred in a different order than what was given on
       the command-line.

       If you need a particular file to be transferred prior to another,
       either separate the files into different rsync calls, or consider
       using <b>--delay-updates </b>(which doesn't affect the sorted transfer
       order, but does make the final file-updating phase happen much
       more rapidly).
</pre> <h2>
MULTI-HOST SECURITY </h2>
<pre>
       Rsync takes steps to ensure that the file requests that are
       shared in a transfer are protected against various security
       issues.  Most of the potential problems arise on the receiving
       side where rsync takes steps to ensure that the list of files
       being transferred remains within the bounds of what was
       requested.

       Toward this end, rsync 3.1.2 and later have aborted when a file
       list contains an absolute or relative path that tries to escape
       out of the top of the transfer.  Also, beginning with version
       3.2.5, rsync does two more safety checks of the file list to (1)
       ensure that no extra source arguments were added into the
       transfer other than those that the client requested and (2)
       ensure that the file list obeys the exclude rules that were sent
       to the sender.

       For those that don't yet have a 3.2.5 client rsync (or those that
       want to be extra careful), it is safest to do a copy into a
       dedicated destination directory for the remote files when you
       don't trust the remote host.  For example, instead of doing an
       rsync copy into your home directory:

           rsync -aiv host1:dir1 ~

       Dedicate a "host1-files" dir to the remote content:

           rsync -aiv host1:dir1 ~/host1-files

       See the <b>--trust-sender </b>option for additional details.

       CAUTION: it is not particularly safe to use rsync to copy files
       from a case-preserving filesystem to a case-ignoring filesystem.
       If you must perform such a copy, you should either disable
       symlinks via <b>--no-links </b>or enable the munging of symlinks via
       <b>--munge-links </b>(and make sure you use the right local or remote
       option).  This will prevent rsync from doing potentially
       dangerous things if a symlink name overlaps with a file or
       directory. It does not, however, ensure that you get a full copy
       of all the files (since that may not be possible when the names
       overlap). A potentially better solution is to list all the source
       files and create a safe list of filenames that you pass to the
       <b>--files-from </b>option.  Any files that conflict in name would need
       to be copied to different destination directories using more than
       one copy.

       While a copy of a case-ignoring filesystem to a case-ignoring
       filesystem can work out fairly well, if no <b>--delete-during </b>or
       <b>--delete-before </b>option is active, rsync can potentially update an
       existing file on the receiving side without noticing that the
       upper-/lower-case of the filename should be changed to match the
       sender.
</pre> <h2>
ADVANCED USAGE </h2>
<pre>
       The syntax for requesting multiple files from a remote host is
       done by specifying additional remote-host args in the same style
       as the first, or with the hostname omitted.  For instance, all
       these work:

           rsync -aiv host:file1 :file2 host:file{3,4} /dest/
           rsync -aiv host::modname/file{1,2} host::modname/extra /dest/
           rsync -aiv host::modname/first ::extra-file{1,2} /dest/

       Note that a daemon connection only supports accessing one module
       per copy command, so if the start of a follow-up path doesn't
       begin with the modname of the first path, it is assumed to be a
       path in the module (such as the extra-file1 &amp; extra-file2 that
       are grabbed above).

       Really old versions of rsync (2.6.9 and before) only allowed
       specifying one remote-source arg, so some people have instead
       relied on the remote-shell performing space splitting to break up
       an arg into multiple paths. Such unintuitive behavior is no
       longer supported by default (though you can request it, as
       described below).

       Starting in 3.2.4, filenames are passed to a remote shell in such
       a way as to preserve the characters you give it. Thus, if you ask
       for a file with spaces in the name, that's what the remote rsync
       looks for:

           rsync -aiv host:'a simple file.pdf' /dest/

       If you use scripts that have been written to manually apply extra
       quoting to the remote rsync args (or to require remote arg
       splitting), you can ask rsync to let your script handle the extra
       escaping.  This is done by either adding the <b>--old-args </b>option to
       the rsync runs in the script (which requires a new rsync) or
       exporting RSYNC_OLD_ARGS=1 and RSYNC_PROTECT_ARGS=0 (which works
       with old or new rsync versions).
</pre> <h2>
CONNECTING TO AN RSYNC DAEMON </h2>
<pre>
       It is also possible to use rsync without a remote shell as the
       transport.  In this case you will directly connect to a remote
       rsync daemon, typically using TCP port 873. (This obviously
       requires the daemon to be running on the remote system, so refer
       to the STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS section
       below for information on that.)

       Using rsync in this way is the same as using it with a remote
       shell except that:

       o      Use either double-colon syntax or rsync:// URL syntax
              instead of the single-colon (remote shell) syntax.

       o      The first element of the "path" is actually a module name.

       o      Additional remote source args can use an abbreviated
              syntax that omits the hostname and/or the module name, as
              discussed in ADVANCED USAGE.

       o      The remote daemon may print a "message of the day" when
              you connect.

       o      If you specify only the host (with no module or path) then
              a list of accessible modules on the daemon is output.

       o      If you specify a remote source path but no destination, a
              listing of the matching files on the remote daemon is
              output.

       o      The <b>--rsh </b>(<b>-e</b>) option must be omitted to avoid changing
              the connection style from using a socket connection to
              USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION.

       An example that copies all the files in a remote module named
       "src":

           rsync -av host::src /dest

       Some modules on the remote daemon may require authentication.  If
       so, you will receive a password prompt when you connect.  You can
       avoid the password prompt by setting the environment variable
       <b>RSYNC_PASSWORD </b>to the password you want to use or using the
       <b>--password-file </b>option.  This may be useful when scripting rsync.

       WARNING: On some systems environment variables are visible to all
       users.  On those systems using <b>--password-file </b>is recommended.

       You may establish the connection via a web proxy by setting the
       environment variable <b>RSYNC_PROXY </b>to a hostname:port pair pointing
       to your web proxy.  Note that your web proxy's configuration must
       support proxy connections to port 873.

       You may also establish a daemon connection using a program as a
       proxy by setting the environment variable <b>RSYNC_CONNECT_PROG </b>to
       the commands you wish to run in place of making a direct socket
       connection.  The string may contain the escape "%H" to represent
       the hostname specified in the rsync command (so use "%%" if you
       need a single "%" in your string).  For example:

           export RSYNC_CONNECT_PROG='ssh proxyhost nc %H 873'
           rsync -av targethost1::module/src/ /dest/
           rsync -av rsync://targethost2/module/src/ /dest/

       The command specified above uses ssh to run nc (netcat) on a
       proxyhost, which forwards all data to port 873 (the rsync daemon)
       on the targethost (%H).

       Note also that if the <b>RSYNC_SHELL </b>environment variable is set,
       that program will be used to run the <b>RSYNC_CONNECT_PROG </b>command
       instead of using the default shell of the <b>system() </b>call.
</pre> <h2>
USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION </h2>
<pre>
       It is sometimes useful to use various features of an rsync daemon
       (such as named modules) without actually allowing any new socket
       connections into a system (other than what is already required to
       allow remote-shell access).  Rsync supports connecting to a host
       using a remote shell and then spawning a single-use "daemon"
       server that expects to read its config file in the home dir of
       the remote user.  This can be useful if you want to encrypt a
       daemon-style transfer's data, but since the daemon is started up
       fresh by the remote user, you may not be able to use features
       such as chroot or change the uid used by the daemon. (For another
       way to encrypt a daemon transfer, consider using ssh to tunnel a
       local port to a remote machine and configure a normal rsync
       daemon on that remote host to only allow connections from
       "localhost".)

       From the user's perspective, a daemon transfer via a remote-shell
       connection uses nearly the same command-line syntax as a normal
       rsync-daemon transfer, with the only exception being that you
       must explicitly set the remote shell program on the command-line
       with the <b>--rsh=COMMAND </b>option. (Setting the RSYNC_RSH in the
       environment will not turn on this functionality.) For example:

           rsync -av --rsh=ssh host::module /dest

       If you need to specify a different remote-shell user, keep in
       mind that the user@ prefix in front of the host is specifying the
       rsync-user value (for a module that requires user-based
       authentication).  This means that you must give the '-l user'
       option to ssh when specifying the remote-shell, as in this
       example that uses the short version of the <b>--rsh </b>option:

           rsync -av -e "ssh -l ssh-user" rsync-user@host::module /dest

       The "ssh-user" will be used at the ssh level; the "rsync-user"
       will be used to log-in to the "module".

       In this setup, the daemon is started by the ssh command that is
       accessing the system (which can be forced via the
       <b>~/.ssh/authorized_keys </b>file, if desired).  However, when
       accessing a daemon directly, it needs to be started beforehand.
</pre> <h2>
STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS </h2>
<pre>
       In order to connect to an rsync daemon, the remote system needs
       to have a daemon already running (or it needs to have configured
       something like inetd to spawn an rsync daemon for incoming
       connections on a particular port).  For full information on how
       to start a daemon that will handling incoming socket connections,
       see the <a href="../man5/rsyncd.conf.5.html">rsyncd.conf(5)</a> manpage -- that is the config file for the
       daemon, and it contains the full details for how to run the
       daemon (including stand-alone and inetd configurations).

       If you're using one of the remote-shell transports for the
       transfer, there is no need to manually start an rsync daemon.
</pre> <h2>
EXAMPLES </h2>
<pre>
       Here are some examples of how rsync can be used.

       To backup a home directory, which consists of large MS Word files
       and mail folders, a per-user cron job can be used that runs this
       each day:

           rsync -aiz . bkhost:backup/joe/

       To move some files from a remote host to the local host, you
       could run:

           rsync -aiv --remove-source-files rhost:/tmp/{file1,file2}.c ~/src/
</pre> <h2>
OPTION SUMMARY </h2>
<pre>
       Here is a short summary of the options available in rsync.  Each
       option also has its own detailed description later in this
       manpage.

       --verbose, -v            increase verbosity
       --info=FLAGS             fine-grained informational verbosity
       --debug=FLAGS            fine-grained debug verbosity
       --stderr=e|a|c           change stderr output mode (default: errors)
       --quiet, -q              suppress non-error messages
       --no-motd                suppress daemon-mode MOTD
       --checksum, -c           skip based on checksum, not mod-time &amp; size
       --archive, -a            archive mode is -rlptgoD (no -A,-X,-U,-N,-H)
       --no-OPTION              turn off an implied OPTION (e.g. --no-D)
       --recursive, -r          recurse into directories
       --relative, -R           use relative path names
       --no-implied-dirs        don't send implied dirs with --relative
       --backup, -b             make backups (see --suffix &amp; --backup-dir)
       --backup-dir=DIR         make backups into hierarchy based in DIR
       --suffix=SUFFIX          backup suffix (default ~ w/o --backup-dir)
       --update, -u             skip files that are newer on the receiver
       --inplace                update destination files in-place
       --append                 append data onto shorter files
       --append-verify          --append w/old data in file checksum
       --dirs, -d               transfer directories without recursing
       --old-dirs, --old-d      works like --dirs when talking to old rsync
       --mkpath                 create destination's missing path components
       --links, -l              copy symlinks as symlinks
       --copy-links, -L         transform symlink into referent file/dir
       --copy-unsafe-links      only "unsafe" symlinks are transformed
       --safe-links             ignore symlinks that point outside the tree
       --munge-links            munge symlinks to make them safe &amp; unusable
       --copy-dirlinks, -k      transform symlink to dir into referent dir
       --keep-dirlinks, -K      treat symlinked dir on receiver as dir
       --hard-links, -H         preserve hard links
       --perms, -p              preserve permissions
       --executability, -E      preserve executability
       --chmod=CHMOD            affect file and/or directory permissions
       --acls, -A               preserve ACLs (implies --perms)
       --xattrs, -X             preserve extended attributes
       --owner, -o              preserve owner (super-user only)
       --group, -g              preserve group
       --devices                preserve device files (super-user only)
       --copy-devices           copy device contents as a regular file
       --write-devices          write to devices as files (implies --inplace)
       --specials               preserve special files
       -D                       same as --devices --specials
       --times, -t              preserve modification times
       --atimes, -U             preserve access (use) times
       --open-noatime           avoid changing the atime on opened files
       --crtimes, -N            preserve create times (newness)
       --omit-dir-times, -O     omit directories from --times
       --omit-link-times, -J    omit symlinks from --times
       --super                  receiver attempts super-user activities
       --fake-super             store/recover privileged attrs using xattrs
       --sparse, -S             turn sequences of nulls into sparse blocks
       --preallocate            allocate dest files before writing them
       --dry-run, -n            perform a trial run with no changes made
       --whole-file, -W         copy files whole (w/o delta-xfer algorithm)
       --checksum-choice=STR    choose the checksum algorithm (aka --cc)
       --one-file-system, -x    don't cross filesystem boundaries
       --block-size=SIZE, -B    force a fixed checksum block-size
       --rsh=COMMAND, -e        specify the remote shell to use
       --rsync-path=PROGRAM     specify the rsync to run on remote machine
       --existing               skip creating new files on receiver
       --ignore-existing        skip updating files that exist on receiver
       --remove-source-files    sender removes synchronized files (non-dir)
       --del                    an alias for --delete-during
       --delete                 delete extraneous files from dest dirs
       --delete-before          receiver deletes before xfer, not during
       --delete-during          receiver deletes during the transfer
       --delete-delay           find deletions during, delete after
       --delete-after           receiver deletes after transfer, not during
       --delete-excluded        also delete excluded files from dest dirs
       --ignore-missing-args    ignore missing source args without error
       --delete-missing-args    delete missing source args from destination
       --ignore-errors          delete even if there are I/O errors
       --force                  force deletion of dirs even if not empty
       --max-delete=NUM         don't delete more than NUM files
       --max-size=SIZE          don't transfer any file larger than SIZE
       --min-size=SIZE          don't transfer any file smaller than SIZE
       --max-alloc=SIZE         change a limit relating to memory alloc
       --partial                keep partially transferred files
       --partial-dir=DIR        put a partially transferred file into DIR
       --delay-updates          put all updated files into place at end
       --prune-empty-dirs, -m   prune empty directory chains from file-list
       --numeric-ids            don't map uid/gid values by user/group name
       --usermap=STRING         custom username mapping
       --groupmap=STRING        custom groupname mapping
       --chown=USER:GROUP       simple username/groupname mapping
       --timeout=SECONDS        set I/O timeout in seconds
       --contimeout=SECONDS     set daemon connection timeout in seconds
       --ignore-times, -I       don't skip files that match size and time
       --size-only              skip files that match in size
       --modify-window=NUM, -@  set the accuracy for mod-time comparisons
       --temp-dir=DIR, -T       create temporary files in directory DIR
       --fuzzy, -y              find similar file for basis if no dest file
       --compare-dest=DIR       also compare destination files relative to DIR
       --copy-dest=DIR          ... and include copies of unchanged files
       --link-dest=DIR          hardlink to files in DIR when unchanged
       --compress, -z           compress file data during the transfer
       --compress-choice=STR    choose the compression algorithm (aka --zc)
       --compress-level=NUM     explicitly set compression level (aka --zl)
       --skip-compress=LIST     skip compressing files with suffix in LIST
       --cvs-exclude, -C        auto-ignore files in the same way CVS does
       --filter=RULE, -f        add a file-filtering RULE
       -F                       same as --filter='dir-merge /.rsync-filter'
                                repeated: --filter='- .rsync-filter'
       --exclude=PATTERN        exclude files matching PATTERN
       --exclude-from=FILE      read exclude patterns from FILE
       --include=PATTERN        don't exclude files matching PATTERN
       --include-from=FILE      read include patterns from FILE
       --files-from=FILE        read list of source-file names from FILE
       --from0, -0              all *-from/filter files are delimited by 0s
       --old-args               disable the modern arg-protection idiom
       --secluded-args, -s      use the protocol to safely send the args
       --trust-sender           trust the remote sender's file list
       --copy-as=USER[:GROUP]   specify user &amp; optional group for the copy
       --address=ADDRESS        bind address for outgoing socket to daemon
       --port=PORT              specify double-colon alternate port number
       --sockopts=OPTIONS       specify custom TCP options
       --blocking-io            use blocking I/O for the remote shell
       --outbuf=N|L|B           set out buffering to None, Line, or Block
       --stats                  give some file-transfer stats
       --8-bit-output, -8       leave high-bit chars unescaped in output
       --human-readable, -h     output numbers in a human-readable format
       --progress               show progress during transfer
       -P                       same as --partial --progress
       --itemize-changes, -i    output a change-summary for all updates
       --remote-option=OPT, -M  send OPTION to the remote side only
       --out-format=FORMAT      output updates using the specified FORMAT
       --log-file=FILE          log what we're doing to the specified FILE
       --log-file-format=FMT    log updates using the specified FMT
       --password-file=FILE     read daemon-access password from FILE
       --early-input=FILE       use FILE for daemon's early exec input
       --list-only              list the files instead of copying them
       --bwlimit=RATE           limit socket I/O bandwidth
       --stop-after=MINS        Stop rsync after MINS minutes have elapsed
       --stop-at=y-m-dTh:m      Stop rsync at the specified point in time
       --fsync                  fsync every written file
       --write-batch=FILE       write a batched update to FILE
       --only-write-batch=FILE  like --write-batch but w/o updating dest
       --read-batch=FILE        read a batched update from FILE
       --protocol=NUM           force an older protocol version to be used
       --iconv=CONVERT_SPEC     request charset conversion of filenames
       --checksum-seed=NUM      set block/file checksum seed (advanced)
       --ipv4, -4               prefer IPv4
       --ipv6, -6               prefer IPv6
       --version, -V            print the version + other info and exit
       --help, -h (*)           show this help (* -h is help only on its own)

       Rsync can also be run as a daemon, in which case the following
       options are accepted:

       --daemon                 run as an rsync daemon
       --address=ADDRESS        bind to the specified address
       --bwlimit=RATE           limit socket I/O bandwidth
       --config=FILE            specify alternate rsyncd.conf file
       --dparam=OVERRIDE, -M    override global daemon config parameter
       --no-detach              do not detach from the parent
       --port=PORT              listen on alternate port number
       --log-file=FILE          override the "log file" setting
       --log-file-format=FMT    override the "log format" setting
       --sockopts=OPTIONS       specify custom TCP options
       --verbose, -v            increase verbosity
       --ipv4, -4               prefer IPv4
       --ipv6, -6               prefer IPv6
       --help, -h               show this help (when used with --daemon)
</pre> <h2>
OPTIONS </h2>
<pre>
       Rsync accepts both long (double-dash + word) and short (single-
       dash + letter) options.  The full list of the available options
       are described below.  If an option can be specified in more than
       one way, the choices are comma-separated.  Some options only have
       a long variant, not a short.

       If the option takes a parameter, the parameter is only listed
       after the long variant, even though it must also be specified for
       the short.  When specifying a parameter, you can either use the
       form <b>--option=param</b>, <b>--option param</b>, <b>-o=param</b>, <b>-o param</b>, or
       <b>-oparam </b>(the latter choices assume that your option has a short
       variant).

       The parameter may need to be quoted in some manner for it to
       survive the shell's command-line parsing.  Also keep in mind that
       a leading tilde (<b>~</b>) in a pathname is substituted by your shell,
       so make sure that you separate the option name from the pathname
       using a space if you want the local shell to expand it.

       <b>--help </b>Print a short help page describing the options available
              in rsync and exit.  You can also use <b>-h </b>for <b>--help </b>when it
              is used without any other options (since it normally means
              <b>--human-readable</b>).

       <b>--version</b>, <b>-V</b>
              Print the rsync version plus other info and exit.  When
              repeated, the information is output is a JSON format that
              is still fairly readable (client side only).

              The output includes a list of compiled-in capabilities, a
              list of optimizations, the default list of checksum
              algorithms, the default list of compression algorithms,
              the default list of daemon auth digests, a link to the
              rsync web site, and a few other items.

       <b>--verbose</b>, <b>-v</b>
              This option increases the amount of information you are
              given during the transfer.  By default, rsync works
              silently.  A single <b>-v </b>will give you information about
              what files are being transferred and a brief summary at
              the end.  Two <b>-v </b>options will give you information on what
              files are being skipped and slightly more information at
              the end.  More than two <b>-v </b>options should only be used if
              you are debugging rsync.

              The end-of-run summary tells you the number of bytes sent
              to the remote rsync (which is the receiving side on a
              local copy), the number of bytes received from the remote
              host, and the average bytes per second of the transferred
              data computed over the entire length of the rsync run. The
              second line shows the total size (in bytes), which is the
              sum of all the file sizes that rsync considered
              transferring.  It also shows a "speedup" value, which is a
              ratio of the total file size divided by the sum of the
              sent and received bytes (which is really just a feel-good
              bigger-is-better number).  Note that these byte values can
              be made more (or less) human-readable by using the
              <b>--human-readable </b>(or <b>--no-human-readable</b>) options.

              In a modern rsync, the <b>-v </b>option is equivalent to the
              setting of groups of <b>--info </b>and <b>--debug </b>options.  You can
              choose to use these newer options in addition to, or in
              place of using <b>--verbose</b>, as any fine-grained settings
              override the implied settings of <b>-v</b>.  Both <b>--info </b>and
              <b>--debug </b>have a way to ask for help that tells you exactly
              what flags are set for each increase in verbosity.

              However, do keep in mind that a daemon's "<b>max verbosity</b>"
              setting will limit how high of a level the various
              individual flags can be set on the daemon side.  For
              instance, if the max is 2, then any info and/or debug flag
              that is set to a higher value than what would be set by
              <b>-vv </b>will be downgraded to the <b>-vv </b>level in the daemon's
              logging.

       <b>--info=FLAGS</b>
              This option lets you have fine-grained control over the
              information output you want to see.  An individual flag
              name may be followed by a level number, with 0 meaning to
              silence that output, 1 being the default output level, and
              higher numbers increasing the output of that flag (for
              those that support higher levels).  Use <b>--info=help </b>to see
              all the available flag names, what they output, and what
              flag names are added for each increase in the verbose
              level.  Some examples:

                  rsync -a --info=progress2 src/ dest/
                  rsync -avv --info=stats2,misc1,flist0 src/ dest/

              Note that <b>--info=name</b>'s output is affected by the <b>--out-</b>
              <b>format </b>and <b>--itemize-changes </b>(<b>-i</b>) options.  See those
              options for more information on what is output and when.

              This option was added to 3.1.0, so an older rsync on the
              server side might reject your attempts at fine-grained
              control (if one or more flags needed to be send to the
              server and the server was too old to understand them).
              See also the "<b>max verbosity</b>" caveat above when dealing
              with a daemon.

       <b>--debug=FLAGS</b>
              This option lets you have fine-grained control over the
              debug output you want to see.  An individual flag name may
              be followed by a level number, with 0 meaning to silence
              that output, 1 being the default output level, and higher
              numbers increasing the output of that flag (for those that
              support higher levels).  Use <b>--debug=help </b>to see all the
              available flag names, what they output, and what flag
              names are added for each increase in the verbose level.
              Some examples:

                  rsync -avvv --debug=none src/ dest/
                  rsync -avA --del --debug=del2,acl src/ dest/

              Note that some debug messages will only be output when the
              <b>--stderr=all </b>option is specified, especially those
              pertaining to I/O and buffer debugging.

              Beginning in 3.2.0, this option is no longer auto-
              forwarded to the server side in order to allow you to
              specify different debug values for each side of the
              transfer, as well as to specify a new debug option that is
              only present in one of the rsync versions.  If you want to
              duplicate the same option on both sides, using brace
              expansion is an easy way to save you some typing.  This
              works in zsh and bash:

                  rsync -aiv {-M,}--debug=del2 src/ dest/

       <b>--stderr=errors|all|client</b>
              This option controls which processes output to stderr and
              if info messages are also changed to stderr.  The mode
              strings can be abbreviated, so feel free to use a single
              letter value.  The 3 possible choices are:

              o      <b>errors </b>- (the default) causes all the rsync
                     processes to send an error directly to stderr, even
                     if the process is on the remote side of the
                     transfer.  Info messages are sent to the client
                     side via the protocol stream.  If stderr is not
                     available (i.e. when directly connecting with a
                     daemon via a socket) errors fall back to being sent
                     via the protocol stream.

              o      <b>all </b>- causes all rsync messages (info and error) to
                     get written directly to stderr from all (possible)
                     processes.  This causes stderr to become line-
                     buffered (instead of raw) and eliminates the
                     ability to divide up the info and error messages by
                     file handle.  For those doing debugging or using
                     several levels of verbosity, this option can help
                     to avoid clogging up the transfer stream (which
                     should prevent any chance of a deadlock bug hanging
                     things up).  It also allows <b>--debug </b>to enable some
                     extra I/O related messages.

              o      <b>client </b>- causes all rsync messages to be sent to
                     the client side via the protocol stream.  One
                     client process outputs all messages, with errors on
                     stderr and info messages on stdout.  This <b>was </b>the
                     default in older rsync versions, but can cause
                     error delays when a lot of transfer data is ahead
                     of the messages.  If you're pushing files to an
                     older rsync, you may want to use <b>--stderr=all </b>since
                     that idiom has been around for several releases.

              This option was added in rsync 3.2.3.  This version also
              began the forwarding of a non-default setting to the
              remote side, though rsync uses the backward-compatible
              options <b>--msgs2stderr </b>and <b>--no-msgs2stderr </b>to represent
              the <b>all </b>and <b>client </b>settings, respectively.  A newer rsync
              will continue to accept these older option names to
              maintain compatibility.

       <b>--quiet</b>, <b>-q</b>
              This option decreases the amount of information you are
              given during the transfer, notably suppressing information
              messages from the remote server.  This option is useful
              when invoking rsync from cron.

       <b>--no-motd</b>
              This option affects the information that is output by the
              client at the start of a daemon transfer.  This suppresses
              the message-of-the-day (MOTD) text, but it also affects
              the list of modules that the daemon sends in response to
              the "rsync host::" request (due to a limitation in the
              rsync protocol), so omit this option if you want to
              request the list of modules from the daemon.

       <b>--ignore-times</b>, <b>-I</b>
              Normally rsync will skip any files that are already the
              same size and have the same modification timestamp.  This
              option turns off this "quick check" behavior, causing all
              files to be updated.

              This option can be confusing compared to <b>--ignore-existing</b>
              and <b>--ignore-non-existing </b>in that that they cause rsync to
              transfer fewer files, while this option causes rsync to
              transfer more files.

       <b>--size-only</b>
              This modifies rsync's "quick check" algorithm for finding
              files that need to be transferred, changing it from the
              default of transferring files with either a changed size
              or a changed last-modified time to just looking for files
              that have changed in size.  This is useful when starting
              to use rsync after using another mirroring system which
              may not preserve timestamps exactly.

       <b>--modify-window=NUM</b>, <b>-@</b>
              When comparing two timestamps, rsync treats the timestamps
              as being equal if they differ by no more than the modify-
              window value.  The default is 0, which matches just
              integer seconds.  If you specify a negative value (and the
              receiver is at least version 3.1.3) then nanoseconds will
              also be taken into account.  Specifying 1 is useful for
              copies to/from MS Windows FAT filesystems, because FAT
              represents times with a 2-second resolution (allowing
              times to differ from the original by up to 1 second).

              If you want all your transfers to default to comparing
              nanoseconds, you can create a <b>~/.popt </b>file and put these
              lines in it:

                  rsync alias -a -a@-1
                  rsync alias -t -t@-1

              With that as the default, you'd need to specify <b>--modify-</b>
              <b>window=0 </b>(aka <b>-@0</b>) to override it and ignore nanoseconds,
              e.g. if you're copying between ext3 and ext4, or if the
              receiving rsync is older than 3.1.3.

       <b>--checksum</b>, <b>-c</b>
              This changes the way rsync checks if the files have been
              changed and are in need of a transfer.  Without this
              option, rsync uses a "quick check" that (by default)
              checks if each file's size and time of last modification
              match between the sender and receiver.  This option
              changes this to compare a 128-bit checksum for each file
              that has a matching size.  Generating the checksums means
              that both sides will expend a lot of disk I/O reading all
              the data in the files in the transfer, so this can slow
              things down significantly (and this is prior to any
              reading that will be done to transfer changed files)

              The sending side generates its checksums while it is doing
              the file-system scan that builds the list of the available
              files.  The receiver generates its checksums when it is
              scanning for changed files, and will checksum any file
              that has the same size as the corresponding sender's file:
              files with either a changed size or a changed checksum are
              selected for transfer.

              Note that rsync always verifies that each <i>transferred</i> file
              was correctly reconstructed on the receiving side by
              checking a whole-file checksum that is generated as the
              file is transferred, but that automatic after-the-transfer
              verification has nothing to do with this option's before-
              the-transfer "Does this file need to be updated?" check.

              The checksum used is auto-negotiated between the client
              and the server, but can be overridden using either the
              <b>--checksum-choice </b>(<b>--cc</b>) option or an environment variable
              that is discussed in that option's section.

       <b>--archive</b>, <b>-a</b>
              This is equivalent to <b>-rlptgoD</b>.  It is a quick way of
              saying you want recursion and want to preserve almost
              everything.  Be aware that it does <b>not </b>include preserving
              ACLs (<b>-A</b>), xattrs (<b>-X</b>), atimes (<b>-U</b>), crtimes (<b>-N</b>), nor the
              finding and preserving of hardlinks (<b>-H</b>).

              The only exception to the above equivalence is when
              <b>--files-from </b>is specified, in which case <b>-r </b>is not
              implied.

       <b>--no-OPTION</b>
              You may turn off one or more implied options by prefixing
              the option name with "no-".  Not all positive options have
              a negated opposite, but a lot do, including those that can
              be used to disable an implied option (e.g.  <b>--no-D</b>, <b>--no-</b>
              <b>perms</b>) or have different defaults in various circumstances
              (e.g. <b>--no-whole-file</b>, <b>--no-blocking-io</b>, <b>--no-dirs</b>).
              Every valid negated option accepts both the short and the
              long option name after the "no-" prefix (e.g. <b>--no-R </b>is
              the same as <b>--no-relative</b>).

              As an example, if you want to use <b>--archive </b>(<b>-a</b>) but don't
              want <b>--owner </b>(<b>-o</b>), instead of converting <b>-a </b>into <b>-rlptgD</b>,
              you can specify <b>-a --no-o </b>(aka <b>--archive --no-owner</b>).

              The order of the options is important: if you specify
              <b>--no-r -a</b>, the <b>-r </b>option would end up being turned on, the
              opposite of <b>-a --no-r</b>.  Note also that the side-effects of
              the <b>--files-from </b>option are NOT positional, as it affects
              the default state of several options and slightly changes
              the meaning of <b>-a </b>(see the <b>--files-from </b>option for more
              details).

       <b>--recursive</b>, <b>-r</b>
              This tells rsync to copy directories recursively.  See
              also <b>--dirs </b>(<b>-d</b>) for an option that allows the scanning of
              a single directory.

              See the <b>--inc-recursive </b>option for a discussion of the
              incremental recursion for creating the list of files to
              transfer.

       <b>--inc-recursive</b>, <b>--i-r</b>
              This option explicitly enables on incremental recursion
              when scanning for files, which is enabled by default when
              using the <b>--recursive </b>option and both sides of the
              transfer are running rsync 3.0.0 or newer.

              Incremental recursion uses much less memory than non-
              incremental, while also beginning the transfer more
              quickly (since it doesn't need to scan the entire transfer
              hierarchy before it starts transferring files).  If no
              recursion is enabled in the source files, this option has
              no effect.

              Some options require rsync to know the full file list, so
              these options disable the incremental recursion mode.
              These include:

              o      <b>--delete-before </b>(the old default of <b>--delete</b>)

              o      <b>--delete-after</b>

              o      <b>--prune-empty-dirs</b>

              o      <b>--delay-updates</b>

              In order to make <b>--delete </b>compatible with incremental
              recursion, rsync 3.0.0 made <b>--delete-during </b>the default
              delete mode (which was first added in 2.6.4).

              One side-effect of incremental recursion is that any
              missing sub-directories inside a recursively-scanned
              directory are (by default) created prior to recursing into
              the sub-dirs.  This earlier creation point (compared to a
              non-incremental recursion) allows rsync to then set the
              modify time of the finished directory right away (without
              having to delay that until a bunch of recursive copying
              has finished).  However, these early directories don't yet
              have their completed mode, mtime, or ownership set -- they
              have more restrictive rights until the subdirectory's
              copying actually begins.  This early-creation idiom can be
              avoided by using the <b>--omit-dir-times </b>option.

              Incremental recursion can be disabled using the <b>--no-inc-</b>
              <b>recursive </b>(<b>--no-i-r</b>) option.

       <b>--no-inc-recursive</b>, <b>--no-i-r</b>
              Disables the new incremental recursion algorithm of the
              <b>--recursive </b>option.  This makes rsync scan the full file
              list before it begins to transfer files.  See <b>--inc-</b>
              <b>recursive </b>for more info.

       <b>--relative</b>, <b>-R</b>
              Use relative paths.  This means that the full path names
              specified on the command line are sent to the server
              rather than just the last parts of the filenames.  This is
              particularly useful when you want to send several
              different directories at the same time.  For example, if
              you used this command:

                  rsync -av /foo/bar/baz.c remote:/tmp/

              would create a file named baz.c in /tmp/ on the remote
              machine.  If instead you used

                  rsync -avR /foo/bar/baz.c remote:/tmp/

              then a file named /tmp/foo/bar/baz.c would be created on
              the remote machine, preserving its full path.  These extra
              path elements are called "implied directories" (i.e. the
              "foo" and the "foo/bar" directories in the above example).

              Beginning with rsync 3.0.0, rsync always sends these
              implied directories as real directories in the file list,
              even if a path element is really a symlink on the sending
              side.  This prevents some really unexpected behaviors when
              copying the full path of a file that you didn't realize
              had a symlink in its path.  If you want to duplicate a
              server-side symlink, include both the symlink via its
              path, and referent directory via its real path.  If you're
              dealing with an older rsync on the sending side, you may
              need to use the <b>--no-implied-dirs </b>option.

              It is also possible to limit the amount of path
              information that is sent as implied directories for each
              path you specify.  With a modern rsync on the sending side
              (beginning with 2.6.7), you can insert a dot and a slash
              into the source path, like this:

                  rsync -avR /foo/./bar/baz.c remote:/tmp/

              That would create /tmp/bar/baz.c on the remote machine.
              (Note that the dot must be followed by a slash, so
              "/foo/." would not be abbreviated.) For older rsync
              versions, you would need to use a chdir to limit the
              source path.  For example, when pushing files:

                  (cd /foo; rsync -avR bar/baz.c remote:/tmp/)

              (Note that the parens put the two commands into a sub-
              shell, so that the "cd" command doesn't remain in effect
              for future commands.) If you're pulling files from an
              older rsync, use this idiom (but only for a non-daemon
              transfer):

                  rsync -avR --rsync-path="cd /foo; rsync" \
                       remote:bar/baz.c /tmp/

       <b>--no-implied-dirs</b>
              This option affects the default behavior of the <b>--relative</b>
              option.  When it is specified, the attributes of the
              implied directories from the source names are not included
              in the transfer.  This means that the corresponding path
              elements on the destination system are left unchanged if
              they exist, and any missing implied directories are
              created with default attributes.  This even allows these
              implied path elements to have big differences, such as
              being a symlink to a directory on the receiving side.

              For instance, if a command-line arg or a files-from entry
              told rsync to transfer the file "path/foo/file", the
              directories "path" and "path/foo" are implied when
              <b>--relative </b>is used.  If "path/foo" is a symlink to "bar"
              on the destination system, the receiving rsync would
              ordinarily delete "path/foo", recreate it as a directory,
              and receive the file into the new directory.  With <b>--no-</b>
              <b>implied-dirs</b>, the receiving rsync updates "path/foo/file"
              using the existing path elements, which means that the
              file ends up being created in "path/bar".  Another way to
              accomplish this link preservation is to use the <b>--keep-</b>
              <b>dirlinks </b>option (which will also affect symlinks to
              directories in the rest of the transfer).

              When pulling files from an rsync older than 3.0.0, you may
              need to use this option if the sending side has a symlink
              in the path you request and you wish the implied
              directories to be transferred as normal directories.

       <b>--backup</b>, <b>-b</b>
              With this option, preexisting destination files are
              renamed as each file is transferred or deleted.  You can
              control where the backup file goes and what (if any)
              suffix gets appended using the <b>--backup-dir </b>and <b>--suffix</b>
              options.

              If you don't specify <b>--backup-dir</b>:

              1.     the <b>--omit-dir-times </b>option will be forced on

              2.     the use of <b>--delete </b>(without <b>--delete-excluded</b>),
                     causes rsync to add a "protect" filter-rule for the
                     backup suffix to the end of all your existing
                     filters that looks like this: <b>-f "P *~"</b>.  This rule
                     prevents previously backed-up files from being
                     deleted.

              Note that if you are supplying your own filter rules, you
              may need to manually insert your own exclude/protect rule
              somewhere higher up in the list so that it has a high
              enough priority to be effective (e.g. if your rules
              specify a trailing inclusion/exclusion of <b>*</b>, the auto-
              added rule would never be reached).

       <b>--backup-dir=DIR</b>
              This implies the <b>--backup </b>option, and tells rsync to store
              all backups in the specified directory on the receiving
              side.  This can be used for incremental backups.  You can
              additionally specify a backup suffix using the <b>--suffix</b>
              option (otherwise the files backed up in the specified
              directory will keep their original filenames).

              Note that if you specify a relative path, the backup
              directory will be relative to the destination directory,
              so you probably want to specify either an absolute path or
              a path that starts with "../".  If an rsync daemon is the
              receiver, the backup dir cannot go outside the module's
              path hierarchy, so take extra care not to delete it or
              copy into it.

       <b>--suffix=SUFFIX</b>
              This option allows you to override the default backup
              suffix used with the <b>--backup </b>(<b>-b</b>) option.  The default
              suffix is a <b>~ </b>if no <b>--backup-dir </b>was specified, otherwise
              it is an empty string.

       <b>--update</b>, <b>-u</b>
              This forces rsync to skip any files which exist on the
              destination and have a modified time that is newer than
              the source file. (If an existing destination file has a
              modification time equal to the source file's, it will be
              updated if the sizes are different.)

              Note that this does not affect the copying of dirs,
              symlinks, or other special files.  Also, a difference of
              file format between the sender and receiver is always
              considered to be important enough for an update, no matter
              what date is on the objects.  In other words, if the
              source has a directory where the destination has a file,
              the transfer would occur regardless of the timestamps.

              This option is a TRANSFER RULE, so don't expect any
              exclude side effects.

              A caution for those that choose to combine <b>--inplace </b>with
              <b>--update</b>: an interrupted transfer will leave behind a
              partial file on the receiving side that has a very recent
              modified time, so re-running the transfer will probably
              <b>not </b>continue the interrupted file.  As such, it is usually
              best to avoid combining this with <b>--inplace </b>unless you
              have implemented manual steps to handle any interrupted
              in-progress files.

       <b>--inplace</b>
              This option changes how rsync transfers a file when its
              data needs to be updated: instead of the default method of
              creating a new copy of the file and moving it into place
              when it is complete, rsync instead writes the updated data
              directly to the destination file.

              This has several effects:

              o      Hard links are not broken.  This means the new data
                     will be visible through other hard links to the
                     destination file.  Moreover, attempts to copy
                     differing source files onto a multiply-linked
                     destination file will result in a "tug of war" with
                     the destination data changing back and forth.

              o      In-use binaries cannot be updated (either the OS
                     will prevent this from happening, or binaries that
                     attempt to swap-in their data will misbehave or
                     crash).

              o      The file's data will be in an inconsistent state
                     during the transfer and will be left that way if
                     the transfer is interrupted or if an update fails.

              o      A file that rsync cannot write to cannot be
                     updated.  While a super user can update any file, a
                     normal user needs to be granted write permission
                     for the open of the file for writing to be
                     successful.

              o      The efficiency of rsync's delta-transfer algorithm
                     may be reduced if some data in the destination file
                     is overwritten before it can be copied to a
                     position later in the file.  This does not apply if
                     you use <b>--backup</b>, since rsync is smart enough to
                     use the backup file as the basis file for the
                     transfer.

              WARNING: you should not use this option to update files
              that are being accessed by others, so be careful when
              choosing to use this for a copy.

              This option is useful for transferring large files with
              block-based changes or appended data, and also on systems
              that are disk bound, not network bound.  It can also help
              keep a copy-on-write filesystem snapshot from diverging
              the entire contents of a file that only has minor changes.

              The option implies <b>--partial </b>(since an interrupted
              transfer does not delete the file), but conflicts with
              <b>--partial-dir </b>and <b>--delay-updates</b>.  Prior to rsync 2.6.4
              <b>--inplace </b>was also incompatible with <b>--compare-dest </b>and
              <b>--link-dest</b>.

       <b>--append</b>
              This special copy mode only works to efficiently update
              files that are known to be growing larger where any
              existing content on the receiving side is also known to be
              the same as the content on the sender.  The use of
              <b>--append can be dangerous </b>if you aren't 100% sure that all
              the files in the transfer are shared, growing files.  You
              should thus use filter rules to ensure that you weed out
              any files that do not fit this criteria.

              Rsync updates these growing file in-place without
              verifying any of the existing content in the file (it only
              verifies the content that it is appending).  Rsync skips
              any files that exist on the receiving side that are not
              shorter than the associated file on the sending side
              (which means that new files are transferred).  It also
              skips any files whose size on the sending side gets
              shorter during the send negotiations (rsync warns about a
              "diminished" file when this happens).

              This does not interfere with the updating of a file's non-
              content attributes (e.g.  permissions, ownership, etc.)
              when the file does not need to be transferred, nor does it
              affect the updating of any directories or non-regular
              files.

       <b>--append-verify</b>
              This special copy mode works like <b>--append </b>except that all
              the data in the file is included in the checksum
              verification (making it less efficient but also
              potentially safer).  This option <b>can be dangerous </b>if you
              aren't 100% sure that all the files in the transfer are
              shared, growing files.  See the <b>--append </b>option for more
              details.

              Note: prior to rsync 3.0.0, the <b>--append </b>option worked
              like <b>--append-verify</b>, so if you are interacting with an
              older rsync (or the transfer is using a protocol prior to
              30), specifying either append option will initiate an
              <b>--append-verify </b>transfer.

       <b>--dirs</b>, <b>-d</b>
              Tell the sending side to include any directories that are
              encountered.  Unlike <b>--recursive</b>, a directory's contents
              are not copied unless the directory name specified is "."
              or ends with a trailing slash (e.g.  ".", "dir/.", "dir/",
              etc.).  Without this option or the <b>--recursive </b>option,
              rsync will skip all directories it encounters (and output
              a message to that effect for each one).  If you specify
              both <b>--dirs </b>and <b>--recursive</b>, <b>--recursive </b>takes precedence.

              The <b>--dirs </b>option is implied by the <b>--files-from </b>option or
              the <b>--list-only </b>option (including an implied <b>--list-only</b>
              usage) if <b>--recursive </b>wasn't specified (so that
              directories are seen in the listing).  Specify <b>--no-dirs</b>
              (or <b>--no-d</b>) if you want to turn this off.

              There is also a backward-compatibility helper option,
              <b>--old-dirs </b>(<b>--old-d</b>) that tells rsync to use a hack of
              <b>-r --exclude='/*/*' </b>to get an older rsync to list a single
              directory without recursing.

       <b>--mkpath</b>
              Create all missing path components of the destination
              path.

              By default, rsync allows only the final component of the
              destination path to not exist, which is an attempt to help
              you to validate your destination path.  With this option,
              rsync creates all the missing destination-path components,
              just as if <b>mkdir -p $DEST_PATH </b>had been run on the
              receiving side.

              When specifying a destination path, including a trailing
              slash ensures that the whole path is treated as directory
              names to be created, even when the file list has a single
              item. See the COPYING TO A DIFFERENT NAME section for full
              details on how rsync decides if a final destination-path
              component should be created as a directory or not.

              If you would like the newly-created destination dirs to
              match the dirs on the sending side, you should be using
              <b>--relative </b>(<b>-R</b>) instead of <b>--mkpath</b>.  For instance, the
              following two commands result in the same destination
              tree, but only the second command ensures that the
              "some/extra/path" components match the dirs on the sending
              side:

                  rsync -ai --mkpath host:some/extra/path/*.c some/extra/path/
                  rsync -aiR host:some/extra/path/*.c ./

       <b>--links</b>, <b>-l</b>
              Add symlinks to the transferred files instead of noisily
              ignoring them with a "non-regular file" warning for each
              symlink encountered.  You can alternately silence the
              warning by specifying <b>--info=nonreg0</b>.

              The default handling of symlinks is to recreate each
              symlink's unchanged value on the receiving side.

              See the SYMBOLIC LINKS section for multi-option info.

       <b>--copy-links</b>, <b>-L</b>
              The sender transforms each symlink encountered in the
              transfer into the referent item, following the symlink
              chain to the file or directory that it references.  If a
              symlink chain is broken, an error is output and the file
              is dropped from the transfer.

              This option supersedes any other options that affect
              symlinks in the transfer, since there are no symlinks left
              in the transfer.

              This option does not change the handling of existing
              symlinks on the receiving side, unlike versions of rsync
              prior to 2.6.3 which had the side-effect of telling the
              receiving side to also follow symlinks.  A modern rsync
              won't forward this option to a remote receiver (since only
              the sender needs to know about it), so this caveat should
              only affect someone using an rsync client older than 2.6.7
              (which is when <b>-L </b>stopped being forwarded to the
              receiver).

              See the <b>--keep-dirlinks </b>(<b>-K</b>) if you need a symlink to a
              directory to be treated as a real directory on the
              receiving side.

              See the SYMBOLIC LINKS section for multi-option info.

       <b>--copy-unsafe-links</b>
              This tells rsync to copy the referent of symbolic links
              that point outside the copied tree.  Absolute symlinks are
              also treated like ordinary files, and so are any symlinks
              in the source path itself when <b>--relative </b>is used.

              Note that the cut-off point is the top of the transfer,
              which is the part of the path that rsync isn't mentioning
              in the verbose output.  If you copy "/src/subdir" to
              "/dest/" then the "subdir" directory is a name inside the
              transfer tree, not the top of the transfer (which is /src)
              so it is legal for created relative symlinks to refer to
              other names inside the /src and /dest directories.  If you
              instead copy "/src/subdir/" (with a trailing slash) to
              "/dest/subdir" that would not allow symlinks to any files
              outside of "subdir".

              Note that safe symlinks are only copied if <b>--links </b>was
              also specified or implied. The <b>--copy-unsafe-links </b>option
              has no extra effect when combined with <b>--copy-links</b>.

              See the SYMBOLIC LINKS section for multi-option info.

       <b>--safe-links</b>
              This tells the receiving rsync to ignore any symbolic
              links in the transfer which point outside the copied tree.
              All absolute symlinks are also ignored.

              Since this ignoring is happening on the receiving side, it
              will still be effective even when the sending side has
              munged symlinks (when it is using <b>--munge-links</b>). It also
              affects deletions, since the file being present in the
              transfer prevents any matching file on the receiver from
              being deleted when the symlink is deemed to be unsafe and
              is skipped.

              This option must be combined with <b>--links </b>(or <b>--archive</b>)
              to have any symlinks in the transfer to conditionally
              ignore. Its effect is superseded by <b>--copy-unsafe-links</b>.

              Using this option in conjunction with <b>--relative </b>may give
              unexpected results.

              See the SYMBOLIC LINKS section for multi-option info.

       <b>--munge-links</b>
              This option affects just one side of the transfer and
              tells rsync to munge symlink values when it is receiving
              files or unmunge symlink values when it is sending files.
              The munged values make the symlinks unusable on disk but
              allows the original contents of the symlinks to be
              recovered.

              The server-side rsync often enables this option without
              the client's knowledge, such as in an rsync daemon's
              configuration file or by an option given to the rrsync
              (restricted rsync) script.  When specified on the client
              side, specify the option normally if it is the client side
              that has/needs the munged symlinks, or use <b>-M--munge-links</b>
              to give the option to the server when it has/needs the
              munged symlinks.  Note that on a local transfer, the
              client is the sender, so specifying the option directly
              unmunges symlinks while specifying it as a remote option
              munges symlinks.

              This option has no effect when sent to a daemon via
              <b>--remote-option </b>because the daemon configures whether it
              wants munged symlinks via its "<b>munge symlinks</b>" parameter.

              The symlink value is munged/unmunged once it is in the
              transfer, so any option that transforms symlinks into non-
              symlinks occurs prior to the munging/unmunging <b>except </b>for
              <b>--safe-links</b>, which is a choice that the receiver makes,
              so it bases its decision on the munged/unmunged value.
              This does mean that if a receiver has munging enabled,
              that using <b>--safe-links </b>will cause all symlinks to be
              ignored (since they are all absolute).

              The method that rsync uses to munge the symlinks is to
              prefix each one's value with the string "/rsyncd-munged/".
              This prevents the links from being used as long as the
              directory does not exist.  When this option is enabled,
              rsync will refuse to run if that path is a directory or a
              symlink to a directory (though it only checks at startup).
              See also the "munge-symlinks" python script in the support
              directory of the source code for a way to munge/unmunge
              one or more symlinks in-place.

       <b>--copy-dirlinks</b>, <b>-k</b>
              This option causes the sending side to treat a symlink to
              a directory as though it were a real directory.  This is
              useful if you don't want symlinks to non-directories to be
              affected, as they would be using <b>--copy-links</b>.

              Without this option, if the sending side has replaced a
              directory with a symlink to a directory, the receiving
              side will delete anything that is in the way of the new
              symlink, including a directory hierarchy (as long as
              <b>--force </b>or <b>--delete </b>is in effect).

              See also <b>--keep-dirlinks </b>for an analogous option for the
              receiving side.

              <b>--copy-dirlinks </b>applies to all symlinks to directories in
              the source.  If you want to follow only a few specified
              symlinks, a trick you can use is to pass them as
              additional source args with a trailing slash, using
              <b>--relative </b>to make the paths match up right.  For example:

                  rsync -r --relative src/./ src/./follow-me/ dest/

              This works because rsync calls <a href="../man2/lstat.2.html">lstat(2)</a> on the source arg
              as given, and the trailing slash makes <a href="../man2/lstat.2.html">lstat(2)</a> follow the
              symlink, giving rise to a directory in the file-list which
              overrides the symlink found during the scan of "src/./".

              See the SYMBOLIC LINKS section for multi-option info.

       <b>--keep-dirlinks</b>, <b>-K</b>
              This option causes the receiving side to treat a symlink
              to a directory as though it were a real directory, but
              only if it matches a real directory from the sender.
              Without this option, the receiver's symlink would be
              deleted and replaced with a real directory.

              For example, suppose you transfer a directory "foo" that
              contains a file "file", but "foo" is a symlink to
              directory "bar" on the receiver.  Without <b>--keep-dirlinks</b>,
              the receiver deletes symlink "foo", recreates it as a
              directory, and receives the file into the new directory.
              With <b>--keep-dirlinks</b>, the receiver keeps the symlink and
              "file" ends up in "bar".

              One note of caution: if you use <b>--keep-dirlinks</b>, you must
              trust all the symlinks in the copy or enable the <b>--munge-</b>
              <b>links </b>option on the receiving side!  If it is possible for
              an untrusted user to create their own symlink to any real
              directory, the user could then (on a subsequent copy)
              replace the symlink with a real directory and affect the
              content of whatever directory the symlink references.  For
              backup copies, you are better off using something like a
              bind mount instead of a symlink to modify your receiving
              hierarchy.

              See also <b>--copy-dirlinks </b>for an analogous option for the
              sending side.

              See the SYMBOLIC LINKS section for multi-option info.

       <b>--hard-links</b>, <b>-H</b>
              This tells rsync to look for hard-linked files in the
              source and link together the corresponding files on the
              destination.  Without this option, hard-linked files in
              the source are treated as though they were separate files.

              This option does NOT necessarily ensure that the pattern
              of hard links on the destination exactly matches that on
              the source.  Cases in which the destination may end up
              with extra hard links include the following:

              o      If the destination contains extraneous hard-links
                     (more linking than what is present in the source
                     file list), the copying algorithm will not break
                     them explicitly.  However, if one or more of the
                     paths have content differences, the normal file-
                     update process will break those extra links (unless
                     you are using the <b>--inplace </b>option).

              o      If you specify a <b>--link-dest </b>directory that
                     contains hard links, the linking of the destination
                     files against the <b>--link-dest </b>files can cause some
                     paths in the destination to become linked together
                     due to the <b>--link-dest </b>associations.

              Note that rsync can only detect hard links between files
              that are inside the transfer set.  If rsync updates a file
              that has extra hard-link connections to files outside the
              transfer, that linkage will be broken.  If you are tempted
              to use the <b>--inplace </b>option to avoid this breakage, be
              very careful that you know how your files are being
              updated so that you are certain that no unintended changes
              happen due to lingering hard links (and see the <b>--inplace</b>
              option for more caveats).

              If incremental recursion is active (see <b>--inc-recursive</b>),
              rsync may transfer a missing hard-linked file before it
              finds that another link for that contents exists elsewhere
              in the hierarchy.  This does not affect the accuracy of
              the transfer (i.e. which files are hard-linked together),
              just its efficiency (i.e. copying the data for a new,
              early copy of a hard-linked file that could have been
              found later in the transfer in another member of the hard-
              linked set of files).  One way to avoid this inefficiency
              is to disable incremental recursion using the <b>--no-inc-</b>
              <b>recursive </b>option.

       <b>--perms</b>, <b>-p</b>
              This option causes the receiving rsync to set the
              destination permissions to be the same as the source
              permissions. (See also the <b>--chmod </b>option for a way to
              modify what rsync considers to be the source permissions.)

              When this option is <i>off</i>, permissions are set as follows:

              o      Existing files (including updated files) retain
                     their existing permissions, though the
                     <b>--executability </b>option might change just the
                     execute permission for the file.

              o      New files get their "normal" permission bits set to
                     the source file's permissions masked with the
                     receiving directory's default permissions (either
                     the receiving process's umask, or the permissions
                     specified via the destination directory's default
                     ACL), and their special permission bits disabled
                     except in the case where a new directory inherits a
                     setgid bit from its parent directory.

              Thus, when <b>--perms </b>and <b>--executability </b>are both disabled,
              rsync's behavior is the same as that of other file-copy
              utilities, such as <a href="cp.1.html">cp(1)</a> and <a href="tar.1.html">tar(1)</a>.

              In summary: to give destination files (both old and new)
              the source permissions, use <b>--perms</b>.  To give new files
              the destination-default permissions (while leaving
              existing files unchanged), make sure that the <b>--perms</b>
              option is off and use <b>--chmod=ugo=rwX </b>(which ensures that
              all non-masked bits get enabled).  If you'd care to make
              this latter behavior easier to type, you could define a
              popt alias for it, such as putting this line in the file
              <b>~/.popt </b>(the following defines the <b>-Z </b>option, and includes
              <b>--no-g </b>to use the default group of the destination dir):

                  rsync alias -Z --no-p --no-g --chmod=ugo=rwX

              You could then use this new option in a command such as
              this one:

                  rsync -avZ src/ dest/

              (Caveat: make sure that <b>-a </b>does not follow <b>-Z</b>, or it will
              re-enable the two <b>--no-* </b>options mentioned above.)

              The preservation of the destination's setgid bit on newly-
              created directories when <b>--perms </b>is off was added in rsync
              2.6.7.  Older rsync versions erroneously preserved the
              three special permission bits for newly-created files when
              <b>--perms </b>was off, while overriding the destination's setgid
              bit setting on a newly-created directory.  Default ACL
              observance was added to the ACL patch for rsync 2.6.7, so
              older (or non-ACL-enabled) rsyncs use the umask even if
              default ACLs are present.  (Keep in mind that it is the
              version of the receiving rsync that affects these
              behaviors.)

       <b>--executability</b>, <b>-E</b>
              This option causes rsync to preserve the executability (or
              non-executability) of regular files when <b>--perms </b>is not
              enabled.  A regular file is considered to be executable if
              at least one 'x' is turned on in its permissions.  When an
              existing destination file's executability differs from
              that of the corresponding source file, rsync modifies the
              destination file's permissions as follows:

              o      To make a file non-executable, rsync turns off all
                     its 'x' permissions.

              o      To make a file executable, rsync turns on each 'x'
                     permission that has a corresponding 'r' permission
                     enabled.

              If <b>--perms </b>is enabled, this option is ignored.

       <b>--acls</b>, <b>-A</b>
              This option causes rsync to update the destination ACLs to
              be the same as the source ACLs.  The option also implies
              <b>--perms</b>.

              The source and destination systems must have compatible
              ACL entries for this option to work properly.  See the
              <b>--fake-super </b>option for a way to backup and restore ACLs
              that are not compatible.

       <b>--xattrs</b>, <b>-X</b>
              This option causes rsync to update the destination
              extended attributes to be the same as the source ones.

              For systems that support extended-attribute namespaces, a
              copy being done by a super-user copies all namespaces
              except system.*.  A normal user only copies the user.*
              namespace.  To be able to backup and restore non-user
              namespaces as a normal user, see the <b>--fake-super </b>option.

              The above name filtering can be overridden by using one or
              more filter options with the <b>x </b>modifier.  When you specify
              an xattr-affecting filter rule, rsync requires that you do
              your own system/user filtering, as well as any additional
              filtering for what xattr names are copied and what names
              are allowed to be deleted.  For example, to skip the
              system namespace, you could specify:

                  --filter='-x system.*'

              To skip all namespaces except the user namespace, you
              could specify a negated-user match:

                  --filter='-x! user.*'

              To prevent any attributes from being deleted, you could
              specify a receiver-only rule that excludes all names:

                  --filter='-xr *'

              Note that the <b>-X </b>option does not copy rsync's special
              xattr values (e.g.  those used by <b>--fake-super</b>) unless you
              repeat the option (e.g. <b>-XX</b>).  This "copy all xattrs" mode
              cannot be used with <b>--fake-super</b>.

       <b>--chmod=CHMOD</b>
              This option tells rsync to apply one or more comma-
              separated "chmod" modes to the permission of the files in
              the transfer.  The resulting value is treated as though it
              were the permissions that the sending side supplied for
              the file, which means that this option can seem to have no
              effect on existing files if <b>--perms </b>is not enabled.

              In addition to the normal parsing rules specified in the
              <a href="chmod.1.html">chmod(1)</a> manpage, you can specify an item that should only
              apply to a directory by prefixing it with a 'D', or
              specify an item that should only apply to a file by
              prefixing it with a 'F'.  For example, the following will
              ensure that all directories get marked set-gid, that no
              files are other-writable, that both are user-writable and
              group-writable, and that both have consistent
              executability across all bits:

                  --chmod=Dg+s,ug+w,Fo-w,+X

              Using octal mode numbers is also allowed:

                  --chmod=D2775,F664

              It is also legal to specify multiple <b>--chmod </b>options, as
              each additional option is just appended to the list of
              changes to make.

              See the <b>--perms </b>and <b>--executability </b>options for how the
              resulting permission value can be applied to the files in
              the transfer.

       <b>--owner</b>, <b>-o</b>
              This option causes rsync to set the owner of the
              destination file to be the same as the source file, but
              only if the receiving rsync is being run as the super-user
              (see also the <b>--super </b>and <b>--fake-super </b>options).  Without
              this option, the owner of new and/or transferred files are
              set to the invoking user on the receiving side.

              The preservation of ownership will associate matching
              names by default, but may fall back to using the ID number
              in some circumstances (see also the <b>--numeric-ids </b>option
              for a full discussion).

       <b>--group</b>, <b>-g</b>
              This option causes rsync to set the group of the
              destination file to be the same as the source file.  If
              the receiving program is not running as the super-user (or
              if <b>--no-super </b>was specified), only groups that the
              invoking user on the receiving side is a member of will be
              preserved.  Without this option, the group is set to the
              default group of the invoking user on the receiving side.

              The preservation of group information will associate
              matching names by default, but may fall back to using the
              ID number in some circumstances (see also the <b>--numeric-</b>
              <b>ids </b>option for a full discussion).

       <b>--devices</b>
              This option causes rsync to transfer character and block
              device files to the remote system to recreate these
              devices.  If the receiving rsync is not being run as the
              super-user, rsync silently skips creating the device files
              (see also the <b>--super </b>and <b>--fake-super </b>options).

              By default, rsync generates a "non-regular file" warning
              for each device file encountered when this option is not
              set.  You can silence the warning by specifying
              <b>--info=nonreg0</b>.

       <b>--specials</b>
              This option causes rsync to transfer special files, such
              as named sockets and fifos.  If the receiving rsync is not
              being run as the super-user, rsync silently skips creating
              the special files (see also the <b>--super </b>and <b>--fake-super</b>
              options).

              By default, rsync generates a "non-regular file" warning
              for each special file encountered when this option is not
              set.  You can silence the warning by specifying
              <b>--info=nonreg0</b>.

       <b>-D     </b>The <b>-D </b>option is equivalent to "<b>--devices --specials</b>".

       <b>--copy-devices</b>
              This tells rsync to treat a device on the sending side as
              a regular file, allowing it to be copied to a normal
              destination file (or another device if <b>--write-devices </b>was
              also specified).

              This option is refused by default by an rsync daemon.

       <b>--write-devices</b>
              This tells rsync to treat a device on the receiving side
              as a regular file, allowing the writing of file data into
              a device.

              This option implies the <b>--inplace </b>option.

              Be careful using this, as you should know what devices are
              present on the receiving side of the transfer, especially
              when running rsync as root.

              This option is refused by default by an rsync daemon.

       <b>--times</b>, <b>-t</b>
              This tells rsync to transfer modification times along with
              the files and update them on the remote system.  Note that
              if this option is not used, the optimization that excludes
              files that have not been modified cannot be effective; in
              other words, a missing <b>-t </b>(or <b>-a</b>) will cause the next
              transfer to behave as if it used <b>--ignore-times </b>(<b>-I</b>),
              causing all files to be updated (though rsync's delta-
              transfer algorithm will make the update fairly efficient
              if the files haven't actually changed, you're much better
              off using <b>-t</b>).

              A modern rsync that is using transfer protocol 30 or 31
              conveys a modify time using up to 8-bytes. If rsync is
              forced to speak an older protocol (perhaps due to the
              remote rsync being older than 3.0.0) a modify time is
              conveyed using 4-bytes. Prior to 3.2.7, these shorter
              values could convey a date range of 13-Dec-1901 to
              19-Jan-2038.  Beginning with 3.2.7, these 4-byte values
              now convey a date range of 1-Jan-1970 to 7-Feb-2106.  If
              you have files dated older than 1970, make sure your rsync
              executables are upgraded so that the full range of dates
              can be conveyed.

       <b>--atimes</b>, <b>-U</b>
              This tells rsync to set the access (use) times of the
              destination files to the same value as the source files.

              If repeated, it also sets the <b>--open-noatime </b>option, which
              can help you to make the sending and receiving systems
              have the same access times on the transferred files
              without needing to run rsync an extra time after a file is
              transferred.

              Note that some older rsync versions (prior to 3.2.0) may
              have been built with a pre-release <b>--atimes </b>patch that
              does not imply <b>--open-noatime </b>when this option is
              repeated.

       <b>--open-noatime</b>
              This tells rsync to open files with the O_NOATIME flag (on
              systems that support it) to avoid changing the access time
              of the files that are being transferred.  If your OS does
              not support the O_NOATIME flag then rsync will silently
              ignore this option.  Note also that some filesystems are
              mounted to avoid updating the atime on read access even
              without the O_NOATIME flag being set.

       <b>--crtimes</b>, <b>-N,</b>
              This tells rsync to set the create times (newness) of the
              destination files to the same value as the source files.
              Your OS &amp; filesystem must support the setting of arbitrary
              creation (birth) times for this option to be supported.

       <b>--omit-dir-times</b>, <b>-O</b>
              This tells rsync to omit directories when it is preserving
              modification, access, and create times.  If NFS is sharing
              the directories on the receiving side, it is a good idea
              to use <b>-O</b>.  This option is inferred if you use <b>--backup</b>
              without <b>--backup-dir</b>.

              This option also has the side-effect of avoiding early
              creation of missing sub-directories when incremental
              recursion is enabled, as discussed in the <b>--inc-recursive</b>
              section.

       <b>--omit-link-times</b>, <b>-J</b>
              This tells rsync to omit symlinks when it is preserving
              modification, access, and create times.

       <b>--super</b>
              This tells the receiving side to attempt super-user
              activities even if the receiving rsync wasn't run by the
              super-user.  These activities include: preserving users
              via the <b>--owner </b>option, preserving all groups (not just
              the current user's groups) via the <b>--group </b>option, and
              copying devices via the <b>--devices </b>option.  This is useful
              for systems that allow such activities without being the
              super-user, and also for ensuring that you will get errors
              if the receiving side isn't being run as the super-user.
              To turn off super-user activities, the super-user can use
              <b>--no-super</b>.

       <b>--fake-super</b>
              When this option is enabled, rsync simulates super-user
              activities by saving/restoring the privileged attributes
              via special extended attributes that are attached to each
              file (as needed).  This includes the file's owner and
              group (if it is not the default), the file's device info
              (device &amp; special files are created as empty text files),
              and any permission bits that we won't allow to be set on
              the real file (e.g. the real file gets u-s,g-s,o-t for
              safety) or that would limit the owner's access (since the
              real super-user can always access/change a file, the files
              we create can always be accessed/changed by the creating
              user).  This option also handles ACLs (if <b>--acls </b>was
              specified) and non-user extended attributes (if <b>--xattrs</b>
              was specified).

              This is a good way to backup data without using a super-
              user, and to store ACLs from incompatible systems.

              The <b>--fake-super </b>option only affects the side where the
              option is used.  To affect the remote side of a remote-
              shell connection, use the <b>--remote-option </b>(<b>-M</b>) option:

                  rsync -av -M--fake-super /src/ host:/dest/

              For a local copy, this option affects both the source and
              the destination.  If you wish a local copy to enable this
              option just for the destination files, specify <b>-M--fake-</b>
              <b>super</b>.  If you wish a local copy to enable this option
              just for the source files, combine <b>--fake-super </b>with
              <b>-M--super</b>.

              This option is overridden by both <b>--super </b>and <b>--no-super</b>.

              See also the <b>fake super </b>setting in the daemon's
              rsyncd.conf file.

       <b>--sparse</b>, <b>-S</b>
              Try to handle sparse files efficiently so they take up
              less space on the destination.  If combined with <b>--inplace</b>
              the file created might not end up with sparse blocks with
              some combinations of kernel version and/or filesystem
              type.  If <b>--whole-file </b>is in effect (e.g. for a local
              copy) then it will always work because rsync truncates the
              file prior to writing out the updated version.

              Note that versions of rsync older than 3.1.3 will reject
              the combination of <b>--sparse </b>and <b>--inplace</b>.

       <b>--preallocate</b>
              This tells the receiver to allocate each destination file
              to its eventual size before writing data to the file.
              Rsync will only use the real filesystem-level
              preallocation support provided by Linux's <a href="../man2/fallocate.2.html">fallocate(2)</a>
              system call or Cygwin's <a href="../man3/posix_fallocate.3.html">posix_fallocate(3)</a>, not the slow
              glibc implementation that writes a null byte into each
              block.

              Without this option, larger files may not be entirely
              contiguous on the filesystem, but with this option rsync
              will probably copy more slowly.  If the destination is not
              an extent-supporting filesystem (such as ext4, xfs, NTFS,
              etc.), this option may have no positive effect at all.

              If combined with <b>--sparse</b>, the file will only have sparse
              blocks (as opposed to allocated sequences of null bytes)
              if the kernel version and filesystem type support creating
              holes in the allocated data.

       <b>--dry-run</b>, <b>-n</b>
              This makes rsync perform a trial run that doesn't make any
              changes (and produces mostly the same output as a real
              run).  It is most commonly used in combination with the
              <b>--verbose </b>(<b>-v</b>) and/or <b>--itemize-changes </b>(<b>-i</b>) options to
              see what an rsync command is going to do before one
              actually runs it.

              The output of <b>--itemize-changes </b>is supposed to be exactly
              the same on a dry run and a subsequent real run (barring
              intentional trickery and system call failures); if it
              isn't, that's a bug.  Other output should be mostly
              unchanged, but may differ in some areas.  Notably, a dry
              run does not send the actual data for file transfers, so
              <b>--progress </b>has no effect, the "bytes sent", "bytes
              received", "literal data", and "matched data" statistics
              are too small, and the "speedup" value is equivalent to a
              run where no file transfers were needed.

       <b>--whole-file</b>, <b>-W</b>
              This option disables rsync's delta-transfer algorithm,
              which causes all transferred files to be sent whole.  The
              transfer may be faster if this option is used when the
              bandwidth between the source and destination machines is
              higher than the bandwidth to disk (especially when the
              "disk" is actually a networked filesystem).  This is the
              default when both the source and destination are specified
              as local paths, but only if no batch-writing option is in
              effect.

       <b>--no-whole-file</b>, <b>--no-W</b>
              Disable whole-file updating when it is enabled by default
              for a local transfer.  This usually slows rsync down, but
              it can be useful if you are trying to minimize the writes
              to the destination file (if combined with <b>--inplace</b>) or
              for testing the checksum-based update algorithm.

              See also the <b>--whole-file </b>option.

       <b>--checksum-choice=STR</b>, <b>--cc=STR</b>
              This option overrides the checksum algorithms.  If one
              algorithm name is specified, it is used for both the
              transfer checksums and (assuming <b>--checksum </b>is specified)
              the pre-transfer checksums.  If two comma-separated names
              are supplied, the first name affects the transfer
              checksums, and the second name affects the pre-transfer
              checksums (<b>-c</b>).

              The checksum options that you may be able to use are:

              o      <b>auto </b>(the default automatic choice)

              o      <b>xxh128</b>

              o      <b>xxh3</b>

              o      <b>xxh64 </b>(aka <b>xxhash</b>)

              o      <b>md5</b>

              o      <b>md4</b>

              o      <b>sha1</b>

              o      <b>none</b>

              Run <b>rsync --version </b>to see the default checksum list
              compiled into your version (which may differ from the list
              above).

              If "none" is specified for the first (or only) name, the
              <b>--whole-file </b>option is forced on and no checksum
              verification is performed on the transferred data.  If
              "none" is specified for the second (or only) name, the
              <b>--checksum </b>option cannot be used.

              The "auto" option is the default, where rsync bases its
              algorithm choice on a negotiation between the client and
              the server as follows:

              When both sides of the transfer are at least 3.2.0, rsync
              chooses the first algorithm in the client's list of
              choices that is also in the server's list of choices.  If
              no common checksum choice is found, rsync exits with an
              error.  If the remote rsync is too old to support checksum
              negotiation, a value is chosen based on the protocol
              version (which chooses between MD5 and various flavors of
              MD4 based on protocol age).

              The default order can be customized by setting the
              environment variable <b>RSYNC_CHECKSUM_LIST </b>to a space-
              separated list of acceptable checksum names.  If the
              string contains a "<b>&amp;</b>" character, it is separated into the
              "client string &amp; server string", otherwise the same string
              applies to both.  If the string (or string portion)
              contains no non-whitespace characters, the default
              checksum list is used.  This method does not allow you to
              specify the transfer checksum separately from the pre-
              transfer checksum, and it discards "auto" and all unknown
              checksum names.  A list with only invalid names results in
              a failed negotiation.

              The use of the <b>--checksum-choice </b>option overrides this
              environment list.

       <b>--one-file-system</b>, <b>-x</b>
              This tells rsync to avoid crossing a filesystem boundary
              when recursing.  This does not limit the user's ability to
              specify items to copy from multiple filesystems, just
              rsync's recursion through the hierarchy of each directory
              that the user specified, and also the analogous recursion
              on the receiving side during deletion.  Also keep in mind
              that rsync treats a "bind" mount to the same device as
              being on the same filesystem.

              If this option is repeated, rsync omits all mount-point
              directories from the copy.  Otherwise, it includes an
              empty directory at each mount-point it encounters (using
              the attributes of the mounted directory because those of
              the underlying mount-point directory are inaccessible).

              If rsync has been told to collapse symlinks (via <b>--copy-</b>
              <b>links </b>or <b>--copy-unsafe-links</b>), a symlink to a directory on
              another device is treated like a mount-point.  Symlinks to
              non-directories are unaffected by this option.

       <b>--ignore-non-existing</b>, <b>--existing</b>
              This tells rsync to skip creating files (including
              directories) that do not exist yet on the destination.  If
              this option is combined with the <b>--ignore-existing </b>option,
              no files will be updated (which can be useful if all you
              want to do is delete extraneous files).

              This option is a TRANSFER RULE, so don't expect any
              exclude side effects.

       <b>--ignore-existing</b>
              This tells rsync to skip updating files that already exist
              on the destination (this does <i>not</i> ignore existing
              directories, or nothing would get done).  See also
              <b>--ignore-non-existing</b>.

              This option is a TRANSFER RULE, so don't expect any
              exclude side effects.

              This option can be useful for those doing backups using
              the <b>--link-dest </b>option when they need to continue a backup
              run that got interrupted.  Since a <b>--link-dest </b>run is
              copied into a new directory hierarchy (when it is used
              properly), using [<b>--ignore-existing </b>will ensure that the
              already-handled files don't get tweaked (which avoids a
              change in permissions on the hard-linked files).  This
              does mean that this option is only looking at the existing
              files in the destination hierarchy itself.

              When <b>--info=skip2 </b>is used rsync will output "FILENAME
              exists (INFO)" messages where the INFO indicates one of
              "type change", "sum change" (requires <b>-c</b>), "file change"
              (based on the quick check), "attr change", or "uptodate".
              Using <b>--info=skip1 </b>(which is also implied by 2 <b>-v </b>options)
              outputs the exists message without the INFO suffix.

       <b>--remove-source-files</b>
              This tells rsync to remove from the sending side the files
              (meaning non-directories) that are a part of the transfer
              and have been successfully duplicated on the receiving
              side.

              Note that you should only use this option on source files
              that are quiescent.  If you are using this to move files
              that show up in a particular directory over to another
              host, make sure that the finished files get renamed into
              the source directory, not directly written into it, so
              that rsync can't possibly transfer a file that is not yet
              fully written.  If you can't first write the files into a
              different directory, you should use a naming idiom that
              lets rsync avoid transferring files that are not yet
              finished (e.g. name the file "foo.new" when it is written,
              rename it to "foo" when it is done, and then use the
              option <b>--exclude='*.new' </b>for the rsync transfer).

              Starting with 3.1.0, rsync will skip the sender-side
              removal (and output an error) if the file's size or modify
              time has not stayed unchanged.

              Starting with 3.2.6, a local rsync copy will ensure that
              the sender does not remove a file the receiver just
              verified, such as when the user accidentally makes the
              source and destination directory the same path.

       <b>--delete</b>
              This tells rsync to delete extraneous files from the
              receiving side (ones that aren't on the sending side), but
              only for the directories that are being synchronized.  You
              must have asked rsync to send the whole directory (e.g.
              "<b>dir</b>" or "<b>dir/</b>") without using a wildcard for the
              directory's contents (e.g. "<b>dir/*</b>") since the wildcard is
              expanded by the shell and rsync thus gets a request to
              transfer individual files, not the files' parent
              directory.  Files that are excluded from the transfer are
              also excluded from being deleted unless you use the
              <b>--delete-excluded </b>option or mark the rules as only
              matching on the sending side (see the include/exclude
              modifiers in the FILTER RULES section).

              Prior to rsync 2.6.7, this option would have no effect
              unless <b>--recursive </b>was enabled.  Beginning with 2.6.7,
              deletions will also occur when <b>--dirs </b>(<b>-d</b>) is enabled, but
              only for directories whose contents are being copied.

              This option can be dangerous if used incorrectly! It is a
              very good idea to first try a run using the <b>--dry-run </b>(<b>-n</b>)
              option to see what files are going to be deleted.

              If the sending side detects any I/O errors, then the
              deletion of any files at the destination will be
              automatically disabled.  This is to prevent temporary
              filesystem failures (such as NFS errors) on the sending
              side from causing a massive deletion of files on the
              destination.  You can override this with the <b>--ignore-</b>
              <b>errors </b>option.

              The <b>--delete </b>option may be combined with one of the
              --delete-WHEN options without conflict, as well as
              <b>--delete-excluded</b>.  However, if none of the <b>--delete-WHEN</b>
              options are specified, rsync will choose the <b>--delete-</b>
              <b>during </b>algorithm when talking to rsync 3.0.0 or newer, or
              the <b>--delete-before </b>algorithm when talking to an older
              rsync.  See also <b>--delete-delay </b>and <b>--delete-after</b>.

       <b>--delete-before</b>
              Request that the file-deletions on the receiving side be
              done before the transfer starts.  See <b>--delete </b>(which is
              implied) for more details on file-deletion.

              Deleting before the transfer is helpful if the filesystem
              is tight for space and removing extraneous files would
              help to make the transfer possible.  However, it does
              introduce a delay before the start of the transfer, and
              this delay might cause the transfer to timeout (if
              <b>--timeout </b>was specified).  It also forces rsync to use the
              old, non-incremental recursion algorithm that requires
              rsync to scan all the files in the transfer into memory at
              once (see <b>--recursive</b>).

       <b>--delete-during</b>, <b>--del</b>
              Request that the file-deletions on the receiving side be
              done incrementally as the transfer happens.  The per-
              directory delete scan is done right before each directory
              is checked for updates, so it behaves like a more
              efficient <b>--delete-before</b>, including doing the deletions
              prior to any per-directory filter files being updated.
              This option was first added in rsync version 2.6.4.  See
              <b>--delete </b>(which is implied) for more details on file-
              deletion.

       <b>--delete-delay</b>
              Request that the file-deletions on the receiving side be
              computed during the transfer (like <b>--delete-during</b>), and
              then removed after the transfer completes.  This is useful
              when combined with <b>--delay-updates </b>and/or <b>--fuzzy</b>, and is
              more efficient than using <b>--delete-after </b>(but can behave
              differently, since <b>--delete-after </b>computes the deletions
              in a separate pass after all updates are done).  If the
              number of removed files overflows an internal buffer, a
              temporary file will be created on the receiving side to
              hold the names (it is removed while open, so you shouldn't
              see it during the transfer).  If the creation of the
              temporary file fails, rsync will try to fall back to using
              <b>--delete-after </b>(which it cannot do if <b>--recursive </b>is doing
              an incremental scan).  See <b>--delete </b>(which is implied) for
              more details on file-deletion.

       <b>--delete-after</b>
              Request that the file-deletions on the receiving side be
              done after the transfer has completed.  This is useful if
              you are sending new per-directory merge files as a part of
              the transfer and you want their exclusions to take effect
              for the delete phase of the current transfer.  It also
              forces rsync to use the old, non-incremental recursion
              algorithm that requires rsync to scan all the files in the
              transfer into memory at once (see <b>--recursive</b>). See
              <b>--delete </b>(which is implied) for more details on file-
              deletion.

              See also the <b>--delete-delay </b>option that might be a faster
              choice for those that just want the deletions to occur at
              the end of the transfer.

       <b>--delete-excluded</b>
              This option turns any unqualified exclude/include rules
              into server-side rules that do not affect the receiver's
              deletions.

              By default, an exclude or include has both a server-side
              effect (to "hide" and "show" files when building the
              server's file list) and a receiver-side effect (to
              "protect" and "risk" files when deletions are occurring).
              Any rule that has no modifier to specify what sides it is
              executed on will be instead treated as if it were a
              server-side rule only, avoiding any "protect" effects of
              the rules.

              A rule can still apply to both sides even with this option
              specified if the rule is given both the sender &amp; receiver
              modifier letters (e.g., <b>-f'-sr foo'</b>).  Receiver-side
              protect/risk rules can also be explicitly specified to
              limit the deletions.  This saves you from having to edit a
              bunch of <b>-f'- foo' </b>rules into <b>-f'-s foo' </b>(aka <b>-f'H foo'</b>)
              rules (not to mention the corresponding includes).

              See the FILTER RULES section for more information.  See
              <b>--delete </b>(which is implied) for more details on deletion.

       <b>--ignore-missing-args</b>
              When rsync is first processing the explicitly requested
              source files (e.g.  command-line arguments or <b>--files-from</b>
              entries), it is normally an error if the file cannot be
              found.  This option suppresses that error, and does not
              try to transfer the file.  This does not affect subsequent
              vanished-file errors if a file was initially found to be
              present and later is no longer there.

       <b>--delete-missing-args</b>
              This option takes the behavior of the (implied) <b>--ignore-</b>
              <b>missing-args </b>option a step farther: each missing arg will
              become a deletion request of the corresponding destination
              file on the receiving side (should it exist).  If the
              destination file is a non-empty directory, it will only be
              successfully deleted if <b>--force </b>or <b>--delete </b>are in effect.
              Other than that, this option is independent of any other
              type of delete processing.

              The missing source files are represented by special file-
              list entries which display as a "<b>*missing</b>" entry in the
              <b>--list-only </b>output.

       <b>--ignore-errors</b>
              Tells <b>--delete </b>to go ahead and delete files even when
              there are I/O errors.

       <b>--force</b>
              This option tells rsync to delete a non-empty directory
              when it is to be replaced by a non-directory.  This is
              only relevant if deletions are not active (see <b>--delete</b>
              for details).

              Note for older rsync versions: <b>--force </b>used to still be
              required when using <b>--delete-after</b>, and it used to be non-
              functional unless the <b>--recursive </b>option was also enabled.

       <b>--max-delete=NUM</b>
              This tells rsync not to delete more than NUM files or
              directories.  If that limit is exceeded, all further
              deletions are skipped through the end of the transfer.  At
              the end, rsync outputs a warning (including a count of the
              skipped deletions) and exits with an error code of 25
              (unless some more important error condition also
              occurred).

              Beginning with version 3.0.0, you may specify <b>--max-</b>
              <b>delete=0 </b>to be warned about any extraneous files in the
              destination without removing any of them.  Older clients
              interpreted this as "unlimited", so if you don't know what
              version the client is, you can use the less obvious <b>--max-</b>
              <b>delete=-1 </b>as a backward-compatible way to specify that no
              deletions be allowed (though really old versions didn't
              warn when the limit was exceeded).

       <b>--max-size=SIZE</b>
              This tells rsync to avoid transferring any file that is
              larger than the specified SIZE.  A numeric value can be
              suffixed with a string to indicate the numeric units or
              left unqualified to specify bytes.  Feel free to use a
              fractional value along with the units, such as <b>--max-</b>
              <b>size=1.5m</b>.

              This option is a TRANSFER RULE, so don't expect any
              exclude side effects.

              The first letter of a units string can be <b>B </b>(bytes), <b>K</b>
              (kilo), <b>M </b>(mega), <b>G </b>(giga), <b>T </b>(tera), or <b>P </b>(peta).  If the
              string is a single char or has "ib" added to it (e.g. "G"
              or "GiB") then the units are multiples of 1024.  If you
              use a two-letter suffix that ends with a "B" (e.g. "kb")
              then you get units that are multiples of 1000.  The
              string's letters can be any mix of upper and lower-case
              that you want to use.

              Finally, if the string ends with either "+1" or "-1", it
              is offset by one byte in the indicated direction.  The
              largest possible value is usually <b>8192P-1</b>.

              Examples: <b>--max-size=1.5mb-1 </b>is 1499999 bytes, and <b>--max-</b>
              <b>size=2g+1 </b>is 2147483649 bytes.

              Note that rsync versions prior to 3.1.0 did not allow
              <b>--max-size=0</b>.

       <b>--min-size=SIZE</b>
              This tells rsync to avoid transferring any file that is
              smaller than the specified SIZE, which can help in not
              transferring small, junk files.  See the <b>--max-size </b>option
              for a description of SIZE and other info.

              Note that rsync versions prior to 3.1.0 did not allow
              <b>--min-size=0</b>.

       <b>--max-alloc=SIZE</b>
              By default rsync limits an individual malloc/realloc to
              about 1GB in size.  For most people this limit works just
              fine and prevents a protocol error causing rsync to
              request massive amounts of memory.  However, if you have
              many millions of files in a transfer, a large amount of
              server memory, and you don't want to split up your
              transfer into multiple parts, you can increase the per-
              allocation limit to something larger and rsync will
              consume more memory.

              Keep in mind that this is not a limit on the total size of
              allocated memory.  It is a sanity-check value for each
              individual allocation.

              See the <b>--max-size </b>option for a description of how SIZE
              can be specified.  The default suffix if none is given is
              bytes.

              Beginning in 3.2.7, a value of 0 is an easy way to specify
              SIZE_MAX (the largest limit possible).

              You can set a default value using the environment variable
              <b>RSYNC_MAX_ALLOC </b>using the same SIZE values as supported by
              this option.  If the remote rsync doesn't understand the
              <b>--max-alloc </b>option, you can override an environmental
              value by specifying <b>--max-alloc=1g</b>, which will make rsync
              avoid sending the option to the remote side (because "1G"
              is the default).

       <b>--block-size=SIZE</b>, <b>-B</b>
              This forces the block size used in rsync's delta-transfer
              algorithm to a fixed value.  It is normally selected based
              on the size of each file being updated.  See the technical
              report for details.

              Beginning in 3.2.3 the SIZE can be specified with a suffix
              as detailed in the <b>--max-size </b>option.  Older versions only
              accepted a byte count.

       <b>--rsh=COMMAND</b>, <b>-e</b>
              This option allows you to choose an alternative remote
              shell program to use for communication between the local
              and remote copies of rsync.  Typically, rsync is
              configured to use ssh by default, but you may prefer to
              use rsh on a local network.

              If this option is used with <b>[user@]host::module/path</b>, then
              the remote shell <i>COMMAND</i> will be used to run an rsync
              daemon on the remote host, and all data will be
              transmitted through that remote shell connection, rather
              than through a direct socket connection to a running rsync
              daemon on the remote host.  See the USING RSYNC-DAEMON
              FEATURES VIA A REMOTE-SHELL CONNECTION section above.

              Beginning with rsync 3.2.0, the <b>RSYNC_PORT </b>environment
              variable will be set when a daemon connection is being
              made via a remote-shell connection.  It is set to 0 if the
              default daemon port is being assumed, or it is set to the
              value of the rsync port that was specified via either the
              <b>--port </b>option or a non-empty port value in an <b>rsync://</b>
              URL.  This allows the script to discern if a non-default
              port is being requested, allowing for things such as an
              SSL or stunnel helper script to connect to a default or
              alternate port.

              Command-line arguments are permitted in COMMAND provided
              that COMMAND is presented to rsync as a single argument.
              You must use spaces (not tabs or other whitespace) to
              separate the command and args from each other, and you can
              use single- and/or double-quotes to preserve spaces in an
              argument (but not backslashes).  Note that doubling a
              single-quote inside a single-quoted string gives you a
              single-quote; likewise for double-quotes (though you need
              to pay attention to which quotes your shell is parsing and
              which quotes rsync is parsing).  Some examples:

                  -e 'ssh -p 2234'
                  -e 'ssh -o "ProxyCommand nohup ssh firewall nc -w1 %h %p"'

              (Note that ssh users can alternately customize site-
              specific connect options in their .ssh/config file.)

              You can also choose the remote shell program using the
              <b>RSYNC_RSH </b>environment variable, which accepts the same
              range of values as <b>-e</b>.

              See also the <b>--blocking-io </b>option which is affected by
              this option.

       <b>--rsync-path=PROGRAM</b>
              Use this to specify what program is to be run on the
              remote machine to start-up rsync.  Often used when rsync
              is not in the default remote-shell's path (e.g. <b>--rsync-</b>
              <b>path=/usr/local/bin/rsync</b>).  Note that PROGRAM is run with
              the help of a shell, so it can be any program, script, or
              command sequence you'd care to run, so long as it does not
              corrupt the standard-in &amp; standard-out that rsync is using
              to communicate.

              One tricky example is to set a different default directory
              on the remote machine for use with the <b>--relative </b>option.
              For instance:

                  rsync -avR --rsync-path="cd /a/b &amp;&amp; rsync" host:c/d /e/

       <b>--remote-option=OPTION</b>, <b>-M</b>
              This option is used for more advanced situations where you
              want certain effects to be limited to one side of the
              transfer only.  For instance, if you want to pass <b>--log-</b>
              <b>file=FILE </b>and <b>--fake-super </b>to the remote system, specify
              it like this:

                  rsync -av -M --log-file=foo -M--fake-super src/ dest/

              If you want to have an option affect only the local side
              of a transfer when it normally affects both sides, send
              its negation to the remote side.  Like this:

                  rsync -av -x -M--no-x src/ dest/

              Be cautious using this, as it is possible to toggle an
              option that will cause rsync to have a different idea
              about what data to expect next over the socket, and that
              will make it fail in a cryptic fashion.

              Note that you should use a separate <b>-M </b>option for each
              remote option you want to pass.  On older rsync versions,
              the presence of any spaces in the remote-option arg could
              cause it to be split into separate remote args, but this
              requires the use of <b>--old-args </b>in a modern rsync.

              When performing a local transfer, the "local" side is the
              sender and the "remote" side is the receiver.

              Note some versions of the popt option-parsing library have
              a bug in them that prevents you from using an adjacent arg
              with an equal in it next to a short option letter (e.g.
              <b>-M--log-file=/tmp/foo</b>).  If this bug affects your version
              of popt, you can use the version of popt that is included
              with rsync.

       <b>--cvs-exclude</b>, <b>-C</b>
              This is a useful shorthand for excluding a broad range of
              files that you often don't want to transfer between
              systems.  It uses a similar algorithm to CVS to determine
              if a file should be ignored.

              The exclude list is initialized to exclude the following
              items (these initial items are marked as perishable -- see
              the FILTER RULES section):

                  <b>RCS SCCS CVS CVS.adm RCSLOG cvslog.*  tags TAGS</b>
                  <b>.make.state .nse_depinfo *~ #* .#* ,* _$* *$ *.old</b>
                  <b>*.bak *.BAK *.orig *.rej .del-* *.a *.olb *.o *.obj</b>
                  <b>*.so *.exe *.Z *.elc *.ln core .svn/ .git/ .hg/ .bzr/</b>

              then, files listed in a $HOME/.cvsignore are added to the
              list and any files listed in the CVSIGNORE environment
              variable (all cvsignore names are delimited by
              whitespace).

              Finally, any file is ignored if it is in the same
              directory as a .cvsignore file and matches one of the
              patterns listed therein.  Unlike rsync's filter/exclude
              files, these patterns are split on whitespace.  See the
              <b>cvs</b>(1) manual for more information.

              If you're combining <b>-C </b>with your own <b>--filter </b>rules, you
              should note that these CVS excludes are appended at the
              end of your own rules, regardless of where the <b>-C </b>was
              placed on the command-line.  This makes them a lower
              priority than any rules you specified explicitly.  If you
              want to control where these CVS excludes get inserted into
              your filter rules, you should omit the <b>-C </b>as a command-
              line option and use a combination of <b>--filter=:C </b>and
              <b>--filter=-C </b>(either on your command-line or by putting the
              ":C" and "-C" rules into a filter file with your other
              rules).  The first option turns on the per-directory
              scanning for the .cvsignore file.  The second option does
              a one-time import of the CVS excludes mentioned above.

       <b>--filter=RULE</b>, <b>-f</b>
              This option allows you to add rules to selectively exclude
              certain files from the list of files to be transferred.
              This is most useful in combination with a recursive
              transfer.

              You may use as many <b>--filter </b>options on the command line
              as you like to build up the list of files to exclude.  If
              the filter contains whitespace, be sure to quote it so
              that the shell gives the rule to rsync as a single
              argument.  The text below also mentions that you can use
              an underscore to replace the space that separates a rule
              from its arg.

              See the FILTER RULES section for detailed information on
              this option.

       <b>-F     </b>The <b>-F </b>option is a shorthand for adding two <b>--filter </b>rules
              to your command.  The first time it is used is a shorthand
              for this rule:

                  --filter='dir-merge /.rsync-filter'

              This tells rsync to look for per-directory .rsync-filter
              files that have been sprinkled through the hierarchy and
              use their rules to filter the files in the transfer.  If
              <b>-F </b>is repeated, it is a shorthand for this rule:

                  --filter='exclude .rsync-filter'

              This filters out the .rsync-filter files themselves from
              the transfer.

              See the FILTER RULES section for detailed information on
              how these options work.

       <b>--exclude=PATTERN</b>
              This option is a simplified form of the <b>--filter </b>option
              that specifies an exclude rule and does not allow the full
              rule-parsing syntax of normal filter rules.  This is
              equivalent to specifying <b>-f'- PATTERN'</b>.

              See the FILTER RULES section for detailed information on
              this option.

       <b>--exclude-from=FILE</b>
              This option is related to the <b>--exclude </b>option, but it
              specifies a FILE that contains exclude patterns (one per
              line).  Blank lines in the file are ignored, as are whole-
              line comments that start with '<b>;</b>' or '<b>#</b>' (filename rules
              that contain those characters are unaffected).

              If a line begins with "<b>- </b>" (dash, space) or "<b>+ </b>" (plus,
              space), then the type of rule is being explicitly
              specified as an exclude or an include (respectively).  Any
              rules without such a prefix are taken to be an exclude.

              If a line consists of just "<b>!</b>", then the current filter
              rules are cleared before adding any further rules.

              If <i>FILE</i> is '<b>-</b>', the list will be read from standard input.

       <b>--include=PATTERN</b>
              This option is a simplified form of the <b>--filter </b>option
              that specifies an include rule and does not allow the full
              rule-parsing syntax of normal filter rules.  This is
              equivalent to specifying <b>-f'+ PATTERN'</b>.

              See the FILTER RULES section for detailed information on
              this option.

       <b>--include-from=FILE</b>
              This option is related to the <b>--include </b>option, but it
              specifies a FILE that contains include patterns (one per
              line).  Blank lines in the file are ignored, as are whole-
              line comments that start with '<b>;</b>' or '<b>#</b>' (filename rules
              that contain those characters are unaffected).

              If a line begins with "<b>- </b>" (dash, space) or "<b>+ </b>" (plus,
              space), then the type of rule is being explicitly
              specified as an exclude or an include (respectively).  Any
              rules without such a prefix are taken to be an include.

              If a line consists of just "<b>!</b>", then the current filter
              rules are cleared before adding any further rules.

              If <i>FILE</i> is '<b>-</b>', the list will be read from standard input.

       <b>--files-from=FILE</b>
              Using this option allows you to specify the exact list of
              files to transfer (as read from the specified FILE or '<b>-</b>'
              for standard input).  It also tweaks the default behavior
              of rsync to make transferring just the specified files and
              directories easier:

              o      The <b>--relative </b>(<b>-R</b>) option is implied, which
                     preserves the path information that is specified
                     for each item in the file (use <b>--no-relative </b>or
                     <b>--no-R </b>if you want to turn that off).

              o      The <b>--dirs </b>(<b>-d</b>) option is implied, which will
                     create directories specified in the list on the
                     destination rather than noisily skipping them (use
                     <b>--no-dirs </b>or <b>--no-d </b>if you want to turn that off).

              o      The <b>--archive </b>(<b>-a</b>) option's behavior does not imply
                     <b>--recursive </b>(<b>-r</b>), so specify it explicitly, if you
                     want it.

              o      These side-effects change the default state of
                     rsync, so the position of the <b>--files-from </b>option
                     on the command-line has no bearing on how other
                     options are parsed (e.g. <b>-a </b>works the same before
                     or after <b>--files-from</b>, as does <b>--no-R </b>and all other
                     options).

              The filenames that are read from the FILE are all relative
              to the source dir -- any leading slashes are removed and
              no ".." references are allowed to go higher than the
              source dir.  For example, take this command:

                  rsync -a --files-from=/tmp/foo /usr remote:/backup

              If /tmp/foo contains the string "bin" (or even "/bin"),
              the /usr/bin directory will be created as /backup/bin on
              the remote host.  If it contains "bin/" (note the trailing
              slash), the immediate contents of the directory would also
              be sent (without needing to be explicitly mentioned in the
              file -- this began in version 2.6.4).  In both cases, if
              the <b>-r </b>option was enabled, that dir's entire hierarchy
              would also be transferred (keep in mind that <b>-r </b>needs to
              be specified explicitly with <b>--files-from</b>, since it is not
              implied by <b>-a</b>.  Also note that the effect of the (enabled
              by default) <b>-r </b>option is to duplicate only the path info
              that is read from the file -- it does not force the
              duplication of the source-spec path (/usr in this case).

              In addition, the <b>--files-from </b>file can be read from the
              remote host instead of the local host if you specify a
              "host:" in front of the file (the host must match one end
              of the transfer).  As a short-cut, you can specify just a
              prefix of ":" to mean "use the remote end of the
              transfer".  For example:

                  rsync -a --files-from=:/path/file-list src:/ /tmp/copy

              This would copy all the files specified in the /path/file-
              list file that was located on the remote "src" host.

              If the <b>--iconv </b>and <b>--secluded-args </b>options are specified
              and the <b>--files-from </b>filenames are being sent from one
              host to another, the filenames will be translated from the
              sending host's charset to the receiving host's charset.

              NOTE: sorting the list of files in the <b>--files-from </b>input
              helps rsync to be more efficient, as it will avoid re-
              visiting the path elements that are shared between
              adjacent entries.  If the input is not sorted, some path
              elements (implied directories) may end up being scanned
              multiple times, and rsync will eventually unduplicate them
              after they get turned into file-list elements.

       <b>--from0</b>, <b>-0</b>
              This tells rsync that the rules/filenames it reads from a
              file are terminated by a null ('\0') character, not a NL,
              CR, or CR+LF.  This affects <b>--exclude-from</b>, <b>--include-</b>
              <b>from</b>, <b>--files-from</b>, and any merged files specified in a
              <b>--filter </b>rule.  It does not affect <b>--cvs-exclude </b>(since
              all names read from a .cvsignore file are split on
              whitespace).

       <b>--old-args</b>
              This option tells rsync to stop trying to protect the arg
              values on the remote side from unintended word-splitting
              or other misinterpretation.  It also allows the client to
              treat an empty arg as a "." instead of generating an
              error.

              The default in a modern rsync is for "shell-active"
              characters (including spaces) to be backslash-escaped in
              the args that are sent to the remote shell.  The wildcard
              characters <b>*</b>, <b>?</b>, <b>[</b>, &amp; <b>] </b>are not escaped in filename args
              (allowing them to expand into multiple filenames) while
              being protected in option args, such as <b>--usermap</b>.

              If you have a script that wants to use old-style arg
              splitting in its filenames, specify this option once.  If
              the remote shell has a problem with any backslash escapes
              at all, specify this option twice.

              You may also control this setting via the <b>RSYNC_OLD_ARGS</b>
              environment variable.  If it has the value "1", rsync will
              default to a single-option setting.  If it has the value
              "2" (or more), rsync will default to a repeated-option
              setting.  If it is "0", you'll get the default escaping
              behavior.  The environment is always overridden by
              manually specified positive or negative options (the
              negative is <b>--no-old-args</b>).

              Note that this option also disables the extra safety check
              added in 3.2.5 that ensures that a remote sender isn't
              including extra top-level items in the file-list that you
              didn't request.  This side-effect is necessary because we
              can't know for sure what names to expect when the remote
              shell is interpreting the args.

              This option conflicts with the <b>--secluded-args </b>option.

       <b>--secluded-args</b>, <b>-s</b>
              This option sends all filenames and most options to the
              remote rsync via the protocol (not the remote shell
              command line) which avoids letting the remote shell modify
              them.  Wildcards are expanded on the remote host by rsync
              instead of a shell.

              This is similar to the default backslash-escaping of args
              that was added in 3.2.4 (see <b>--old-args</b>) in that it
              prevents things like space splitting and unwanted special-
              character side-effects. However, it has the drawbacks of
              being incompatible with older rsync versions (prior to
              3.0.0) and of being refused by restricted shells that want
              to be able to inspect all the option values for safety.

              This option is useful for those times that you need the
              argument's character set to be converted for the remote
              host, if the remote shell is incompatible with the default
              backslash-escpaing method, or there is some other reason
              that you want the majority of the options and arguments to
              bypass the command-line of the remote shell.

              If you combine this option with <b>--iconv</b>, the args related
              to the remote side will be translated from the local to
              the remote character-set.  The translation happens before
              wild-cards are expanded.  See also the <b>--files-from</b>
              option.

              You may also control this setting via the
              <b>RSYNC_PROTECT_ARGS </b>environment variable.  If it has a non-
              zero value, this setting will be enabled by default,
              otherwise it will be disabled by default.  Either state is
              overridden by a manually specified positive or negative
              version of this option (note that <b>--no-s </b>and <b>--no-</b>
              <b>secluded-args </b>are the negative versions).  This
              environment variable is also superseded by a non-zero
              <b>RSYNC_OLD_ARGS </b>export.

              This option conflicts with the <b>--old-args </b>option.

              This option used to be called <b>--protect-args </b>(before
              3.2.6) and that older name can still be used (though
              specifying it as <b>-s </b>is always the easiest and most
              compatible choice).

       <b>--trust-sender</b>
              This option disables two extra validation checks that a
              local client performs on the file list generated by a
              remote sender.  This option should only be used if you
              trust the sender to not put something malicious in the
              file list (something that could possibly be done via a
              modified rsync, a modified shell, or some other similar
              manipulation).

              Normally, the rsync client (as of version 3.2.5) runs two
              extra validation checks when pulling files from a remote
              rsync:

              o      It verifies that additional arg items didn't get
                     added at the top of the transfer.

              o      It verifies that none of the items in the file list
                     are names that should have been excluded (if filter
                     rules were specified).

              Note that various options can turn off one or both of
              these checks if the option interferes with the validation.
              For instance:

              o      Using a per-directory filter file reads filter
                     rules that only the server knows about, so the
                     filter checking is disabled.

              o      Using the <b>--old-args </b>option allows the sender to
                     manipulate the requested args, so the arg checking
                     is disabled.

              o      Reading the files-from list from the server side
                     means that the client doesn't know the arg list, so
                     the arg checking is disabled.

              o      Using <b>--read-batch </b>disables both checks since the
                     batch file's contents will have been verified when
                     it was created.

              This option may help an under-powered client server if the
              extra pattern matching is slowing things down on a huge
              transfer.  It can also be used to work around a currently-
              unknown bug in the verification logic for a transfer from
              a trusted sender.

              When using this option it is a good idea to specify a
              dedicated destination directory, as discussed in the
              MULTI-HOST SECURITY section.

       <b>--copy-as=USER[:GROUP]</b>
              This option instructs rsync to use the USER and (if
              specified after a colon) the GROUP for the copy
              operations.  This only works if the user that is running
              rsync has the ability to change users.  If the group is
              not specified then the user's default groups are used.

              This option can help to reduce the risk of an rsync being
              run as root into or out of a directory that might have
              live changes happening to it and you want to make sure
              that root-level read or write actions of system files are
              not possible.  While you could alternatively run all of
              rsync as the specified user, sometimes you need the root-
              level host-access credentials to be used, so this allows
              rsync to drop root for the copying part of the operation
              after the remote-shell or daemon connection is
              established.

              The option only affects one side of the transfer unless
              the transfer is local, in which case it affects both
              sides.  Use the <b>--remote-option </b>to affect the remote side,
              such as <b>-M--copy-as=joe</b>.  For a local transfer, the lsh
              (or lsh.sh) support file provides a local-shell helper
              script that can be used to allow a "localhost:" or "lh:"
              host-spec to be specified without needing to setup any
              remote shells, allowing you to specify remote options that
              affect the side of the transfer that is using the host-
              spec (and using hostname "lh" avoids the overriding of the
              remote directory to the user's home dir).

              For example, the following rsync writes the local files as
              user "joe":

                  sudo rsync -aiv --copy-as=joe host1:backups/joe/ /home/joe/

              This makes all files owned by user "joe", limits the
              groups to those that are available to that user, and makes
              it impossible for the joe user to do a timed exploit of
              the path to induce a change to a file that the joe user
              has no permissions to change.

              The following command does a local copy into the "dest/"
              dir as user "joe" (assuming you've installed support/lsh
              into a dir on your $PATH):

                  sudo rsync -aive lsh -M--copy-as=joe src/ lh:dest/

       <b>--temp-dir=DIR</b>, <b>-T</b>
              This option instructs rsync to use DIR as a scratch
              directory when creating temporary copies of the files
              transferred on the receiving side.  The default behavior
              is to create each temporary file in the same directory as
              the associated destination file.  Beginning with rsync
              3.1.1, the temp-file names inside the specified DIR will
              not be prefixed with an extra dot (though they will still
              have a random suffix added).

              This option is most often used when the receiving disk
              partition does not have enough free space to hold a copy
              of the largest file in the transfer.  In this case (i.e.
              when the scratch directory is on a different disk
              partition), rsync will not be able to rename each received
              temporary file over the top of the associated destination
              file, but instead must copy it into place.  Rsync does
              this by copying the file over the top of the destination
              file, which means that the destination file will contain
              truncated data during this copy.  If this were not done
              this way (even if the destination file were first removed,
              the data locally copied to a temporary file in the
              destination directory, and then renamed into place) it
              would be possible for the old file to continue taking up
              disk space (if someone had it open), and thus there might
              not be enough room to fit the new version on the disk at
              the same time.

              If you are using this option for reasons other than a
              shortage of disk space, you may wish to combine it with
              the <b>--delay-updates </b>option, which will ensure that all
              copied files get put into subdirectories in the
              destination hierarchy, awaiting the end of the transfer.
              If you don't have enough room to duplicate all the
              arriving files on the destination partition, another way
              to tell rsync that you aren't overly concerned about disk
              space is to use the <b>--partial-dir </b>option with a relative
              path; because this tells rsync that it is OK to stash off
              a copy of a single file in a subdir in the destination
              hierarchy, rsync will use the partial-dir as a staging
              area to bring over the copied file, and then rename it
              into place from there. (Specifying a <b>--partial-dir </b>with an
              absolute path does not have this side-effect.)

       <b>--fuzzy</b>, <b>-y</b>
              This option tells rsync that it should look for a basis
              file for any destination file that is missing.  The
              current algorithm looks in the same directory as the
              destination file for either a file that has an identical
              size and modified-time, or a similarly-named file.  If
              found, rsync uses the fuzzy basis file to try to speed up
              the transfer.

              If the option is repeated, the fuzzy scan will also be
              done in any matching alternate destination directories
              that are specified via <b>--compare-dest</b>, <b>--copy-dest</b>, or
              <b>--link-dest</b>.

              Note that the use of the <b>--delete </b>option might get rid of
              any potential fuzzy-match files, so either use <b>--delete-</b>
              <b>after </b>or specify some filename exclusions if you need to
              prevent this.

       <b>--compare-dest=DIR</b>
              This option instructs rsync to use <i>DIR</i> on the destination
              machine as an additional hierarchy to compare destination
              files against doing transfers (if the files are missing in
              the destination directory).  If a file is found in <i>DIR</i>
              that is identical to the sender's file, the file will NOT
              be transferred to the destination directory.  This is
              useful for creating a sparse backup of just files that
              have changed from an earlier backup.  This option is
              typically used to copy into an empty (or newly created)
              directory.

              Beginning in version 2.6.4, multiple <b>--compare-dest</b>
              directories may be provided, which will cause rsync to
              search the list in the order specified for an exact match.
              If a match is found that differs only in attributes, a
              local copy is made and the attributes updated.  If a match
              is not found, a basis file from one of the <i>DIRs</i> will be
              selected to try to speed up the transfer.

              If <i>DIR</i> is a relative path, it is relative to the
              destination directory.  See also <b>--copy-dest </b>and <b>--link-</b>
              <b>dest</b>.

              NOTE: beginning with version 3.1.0, rsync will remove a
              file from a non-empty destination hierarchy if an exact
              match is found in one of the compare-dest hierarchies
              (making the end result more closely match a fresh copy).

       <b>--copy-dest=DIR</b>
              This option behaves like <b>--compare-dest</b>, but rsync will
              also copy unchanged files found in <i>DIR</i> to the destination
              directory using a local copy.  This is useful for doing
              transfers to a new destination while leaving existing
              files intact, and then doing a flash-cutover when all
              files have been successfully transferred.

              Multiple <b>--copy-dest </b>directories may be provided, which
              will cause rsync to search the list in the order specified
              for an unchanged file.  If a match is not found, a basis
              file from one of the <i>DIRs</i> will be selected to try to speed
              up the transfer.

              If <i>DIR</i> is a relative path, it is relative to the
              destination directory.  See also <b>--compare-dest </b>and
              <b>--link-dest</b>.

       <b>--link-dest=DIR</b>
              This option behaves like <b>--copy-dest</b>, but unchanged files
              are hard linked from <i>DIR</i> to the destination directory.
              The files must be identical in all preserved attributes
              (e.g. permissions, possibly ownership) in order for the
              files to be linked together.  An example:

                  rsync -av --link-dest=$PWD/prior_dir host:src_dir/ new_dir/

              If files aren't linking, double-check their attributes.
              Also check if some attributes are getting forced outside
              of rsync's control, such a mount option that squishes root
              to a single user, or mounts a removable drive with generic
              ownership (such as OS X's "Ignore ownership on this
              volume" option).

              Beginning in version 2.6.4, multiple <b>--link-dest</b>
              directories may be provided, which will cause rsync to
              search the list in the order specified for an exact match
              (there is a limit of 20 such directories).  If a match is
              found that differs only in attributes, a local copy is
              made and the attributes updated.  If a match is not found,
              a basis file from one of the <i>DIRs</i> will be selected to try
              to speed up the transfer.

              This option works best when copying into an empty
              destination hierarchy, as existing files may get their
              attributes tweaked, and that can affect alternate
              destination files via hard-links.  Also, itemizing of
              changes can get a bit muddled.  Note that prior to version
              3.1.0, an alternate-directory exact match would never be
              found (nor linked into the destination) when a destination
              file already exists.

              Note that if you combine this option with <b>--ignore-times</b>,
              rsync will not link any files together because it only
              links identical files together as a substitute for
              transferring the file, never as an additional check after
              the file is updated.

              If <i>DIR</i> is a relative path, it is relative to the
              destination directory.  See also <b>--compare-dest </b>and
              <b>--copy-dest</b>.

              Note that rsync versions prior to 2.6.1 had a bug that
              could prevent <b>--link-dest </b>from working properly for a non-
              super-user when <b>--owner </b>(<b>-o</b>) was specified (or implied).
              You can work-around this bug by avoiding the <b>-o </b>option (or
              using <b>--no-o</b>) when sending to an old rsync.

       <b>--compress</b>, <b>-z</b>
              With this option, rsync compresses the file data as it is
              sent to the destination machine, which reduces the amount
              of data being transmitted -- something that is useful over
              a slow connection.

              Rsync supports multiple compression methods and will
              choose one for you unless you force the choice using the
              <b>--compress-choice </b>(<b>--zc</b>) option.

              Run <b>rsync --version </b>to see the default compress list
              compiled into your version.

              When both sides of the transfer are at least 3.2.0, rsync
              chooses the first algorithm in the client's list of
              choices that is also in the server's list of choices.  If
              no common compress choice is found, rsync exits with an
              error.  If the remote rsync is too old to support checksum
              negotiation, its list is assumed to be "zlib".

              The default order can be customized by setting the
              environment variable <b>RSYNC_COMPRESS_LIST </b>to a space-
              separated list of acceptable compression names.  If the
              string contains a "<b>&amp;</b>" character, it is separated into the
              "client string &amp; server string", otherwise the same string
              applies to both.  If the string (or string portion)
              contains no non-whitespace characters, the default
              compress list is used.  Any unknown compression names are
              discarded from the list, but a list with only invalid
              names results in a failed negotiation.

              There are some older rsync versions that were configured
              to reject a <b>-z </b>option and require the use of <b>-zz </b>because
              their compression library was not compatible with the
              default zlib compression method.  You can usually ignore
              this weirdness unless the rsync server complains and tells
              you to specify <b>-zz</b>.

       <b>--compress-choice=STR</b>, <b>--zc=STR</b>
              This option can be used to override the automatic
              negotiation of the compression algorithm that occurs when
              <b>--compress </b>is used.  The option implies <b>--compress </b>unless
              "none" was specified, which instead implies <b>--no-compress</b>.

              The compression options that you may be able to use are:

              o      <b>zstd</b>

              o      <b>lz4</b>

              o      <b>zlibx</b>

              o      <b>zlib</b>

              o      <b>none</b>

              Run <b>rsync --version </b>to see the default compress list
              compiled into your version (which may differ from the list
              above).

              Note that if you see an error about an option named <b>--old-</b>
              <b>compress </b>or <b>--new-compress</b>, this is rsync trying to send
              the <b>--compress-choice=zlib </b>or <b>--compress-choice=zlibx</b>
              option in a backward-compatible manner that more rsync
              versions understand.  This error indicates that the older
              rsync version on the server will not allow you to force
              the compression type.

              Note that the "zlibx" compression algorithm is just the
              "zlib" algorithm with matched data excluded from the
              compression stream (to try to make it more compatible with
              an external zlib implementation).

       <b>--compress-level=NUM</b>, <b>--zl=NUM</b>
              Explicitly set the compression level to use (see
              <b>--compress</b>, <b>-z</b>) instead of letting it default.  The
              <b>--compress </b>option is implied as long as the level chosen
              is not a "don't compress" level for the compression
              algorithm that is in effect (e.g. zlib compression treats
              level 0 as "off").

              The level values vary depending on the checksum in effect.
              Because rsync will negotiate a checksum choice by default
              (when the remote rsync is new enough), it can be good to
              combine this option with a <b>--compress-choice </b>(<b>--zc</b>) option
              unless you're sure of the choice in effect.  For example:

                  rsync -aiv --zc=zstd --zl=22 host:src/ dest/

              For zlib &amp; zlibx compression the valid values are from 1
              to 9 with 6 being the default.  Specifying <b>--zl=0 </b>turns
              compression off, and specifying <b>--zl=-1 </b>chooses the
              default level of 6.

              For zstd compression the valid values are from -131072 to
              22 with 3 being the default. Specifying 0 chooses the
              default of 3.

              For lz4 compression there are no levels, so the value is
              always 0.

              If you specify a too-large or too-small value, the number
              is silently limited to a valid value.  This allows you to
              specify something like <b>--zl=999999999 </b>and be assured that
              you'll end up with the maximum compression level no matter
              what algorithm was chosen.

              If you want to know the compression level that is in
              effect, specify <b>--debug=nstr </b>to see the "negotiated
              string" results.  This will report something like
              "<b>Client compress: zstd (level 3)</b>" (along with the checksum
              choice in effect).

       <b>--skip-compress=LIST</b>
              <b>NOTE: </b>no compression method currently supports per-file
              compression changes, so this option has no effect.

              Override the list of file suffixes that will be compressed
              as little as possible.  Rsync sets the compression level
              on a per-file basis based on the file's suffix.  If the
              compression algorithm has an "off" level, then no
              compression occurs for those files.  Other algorithms that
              support changing the streaming level on-the-fly will have
              the level minimized to reduces the CPU usage as much as
              possible for a matching file.

              The <b>LIST </b>should be one or more file suffixes (without the
              dot) separated by slashes (<b>/</b>).  You may specify an empty
              string to indicate that no files should be skipped.

              Simple character-class matching is supported: each must
              consist of a list of letters inside the square brackets
              (e.g. no special classes, such as "[:alpha:]", are
              supported, and '-' has no special meaning).

              The characters asterisk (<b>*</b>) and question-mark (<b>?</b>) have no
              special meaning.

              Here's an example that specifies 6 suffixes to skip (since
              1 of the 5 rules matches 2 suffixes):

                  --skip-compress=gz/jpg/mp[34]/7z/bz2

              The default file suffixes in the skip-compress list in
              this version of rsync are:

                  3g2 3gp 7z aac ace apk avi bz2 deb dmg ear f4v flac
                  flv gpg gz iso jar jpeg jpg lrz lz lz4 lzma lzo m1a
                  m1v m2a m2ts m2v m4a m4b m4p m4r m4v mka mkv mov mp1
                  mp2 mp3 mp4 mpa mpeg mpg mpv mts odb odf odg odi odm
                  odp ods odt oga ogg ogm ogv ogx opus otg oth otp ots
                  ott oxt png qt rar rpm rz rzip spx squashfs sxc sxd
                  sxg sxm sxw sz tbz tbz2 tgz tlz ts txz tzo vob war
                  webm webp xz z zip zst

              This list will be replaced by your <b>--skip-compress </b>list in
              all but one situation: a copy from a daemon rsync will add
              your skipped suffixes to its list of non-compressing files
              (and its list may be configured to a different default).

       <b>--numeric-ids</b>
              With this option rsync will transfer numeric group and
              user IDs rather than using user and group names and
              mapping them at both ends.

              By default rsync will use the username and groupname to
              determine what ownership to give files.  The special uid 0
              and the special group 0 are never mapped via user/group
              names even if the <b>--numeric-ids </b>option is not specified.

              If a user or group has no name on the source system or it
              has no match on the destination system, then the numeric
              ID from the source system is used instead.  See also the
              <b>use chroot </b>setting in the rsyncd.conf manpage for some
              comments on how the chroot setting affects rsync's ability
              to look up the names of the users and groups and what you
              can do about it.

       <b>--usermap=STRING</b>, <b>--groupmap=STRING</b>
              These options allow you to specify users and groups that
              should be mapped to other values by the receiving side.
              The <b>STRING </b>is one or more <b>FROM</b>:<b>TO </b>pairs of values
              separated by commas.  Any matching <b>FROM </b>value from the
              sender is replaced with a <b>TO </b>value from the receiver.  You
              may specify usernames or user IDs for the <b>FROM </b>and <b>TO</b>
              values, and the <b>FROM </b>value may also be a wild-card string,
              which will be matched against the sender's names (wild-
              cards do NOT match against ID numbers, though see below
              for why a '<b>*</b>' matches everything).  You may instead
              specify a range of ID numbers via an inclusive range: LOW-
              HIGH.  For example:

                  --usermap=0-99:nobody,wayne:admin,*:normal --groupmap=usr:1,1:usr

              The first match in the list is the one that is used.  You
              should specify all your user mappings using a single
              <b>--usermap </b>option, and/or all your group mappings using a
              single <b>--groupmap </b>option.

              Note that the sender's name for the 0 user and group are
              not transmitted to the receiver, so you should either
              match these values using a 0, or use the names in effect
              on the receiving side (typically "root").  All other <b>FROM</b>
              names match those in use on the sending side.  All <b>TO</b>
              names match those in use on the receiving side.

              Any IDs that do not have a name on the sending side are
              treated as having an empty name for the purpose of
              matching.  This allows them to be matched via a "<b>*</b>" or
              using an empty name.  For instance:

                  --usermap=:nobody --groupmap=*:nobody

              When the <b>--numeric-ids </b>option is used, the sender does not
              send any names, so all the IDs are treated as having an
              empty name.  This means that you will need to specify
              numeric <b>FROM </b>values if you want to map these nameless IDs
              to different values.

              For the <b>--usermap </b>option to work, the receiver will need
              to be running as a super-user (see also the <b>--super </b>and
              <b>--fake-super </b>options).  For the <b>--groupmap </b>option to work,
              the receiver will need to have permissions to set that
              group.

              Starting with rsync 3.2.4, the <b>--usermap </b>option implies
              the <b>--owner </b>(<b>-o</b>) option while the <b>--groupmap </b>option
              implies the <b>--group </b>(<b>-g</b>) option (since rsync needs to have
              those options enabled for the mapping options to work).

              An older rsync client may need to use <b>-s </b>to avoid a
              complaint about wildcard characters, but a modern rsync
              handles this automatically.

       <b>--chown=USER:GROUP</b>
              This option forces all files to be owned by USER with
              group GROUP.  This is a simpler interface than using
              <b>--usermap </b>&amp; <b>--groupmap </b>directly, but it is implemented
              using those options internally so they cannot be mixed.
              If either the USER or GROUP is empty, no mapping for the
              omitted user/group will occur.  If GROUP is empty, the
              trailing colon may be omitted, but if USER is empty, a
              leading colon must be supplied.

              If you specify "<b>--chown=foo:bar</b>", this is exactly the same
              as specifying "<b>--usermap=*:foo --groupmap=*:bar</b>", only
              easier (and with the same implied <b>--owner </b>and/or <b>--group</b>
              options).

              An older rsync client may need to use <b>-s </b>to avoid a
              complaint about wildcard characters, but a modern rsync
              handles this automatically.

       <b>--timeout=SECONDS</b>
              This option allows you to set a maximum I/O timeout in
              seconds.  If no data is transferred for the specified time
              then rsync will exit.  The default is 0, which means no
              timeout.

       <b>--contimeout=SECONDS</b>
              This option allows you to set the amount of time that
              rsync will wait for its connection to an rsync daemon to
              succeed.  If the timeout is reached, rsync exits with an
              error.

       <b>--address=ADDRESS</b>
              By default rsync will bind to the wildcard address when
              connecting to an rsync daemon.  The <b>--address </b>option
              allows you to specify a specific IP address (or hostname)
              to bind to.

              See also the daemon version of the <b>--address </b>option.

       <b>--port=PORT</b>
              This specifies an alternate TCP port number to use rather
              than the default of 873.  This is only needed if you are
              using the double-colon (::) syntax to connect with an
              rsync daemon (since the URL syntax has a way to specify
              the port as a part of the URL).

              See also the daemon version of the <b>--port </b>option.

       <b>--sockopts=OPTIONS</b>
              This option can provide endless fun for people who like to
              tune their systems to the utmost degree.  You can set all
              sorts of socket options which may make transfers faster
              (or slower!).  Read the manpage for the <b>setsockopt()</b>
              system call for details on some of the options you may be
              able to set.  By default no special socket options are
              set.  This only affects direct socket connections to a
              remote rsync daemon.

              See also the daemon version of the <b>--sockopts </b>option.

       <b>--blocking-io</b>
              This tells rsync to use blocking I/O when launching a
              remote shell transport.  If the remote shell is either rsh
              or remsh, rsync defaults to using blocking I/O, otherwise
              it defaults to using non-blocking I/O. (Note that ssh
              prefers non-blocking I/O.)

       <b>--outbuf=MODE</b>
              This sets the output buffering mode.  The mode can be None
              (aka Unbuffered), Line, or Block (aka Full).  You may
              specify as little as a single letter for the mode, and use
              upper or lower case.

              The main use of this option is to change Full buffering to
              Line buffering when rsync's output is going to a file or
              pipe.

       <b>--itemize-changes</b>, <b>-i</b>
              Requests a simple itemized list of the changes that are
              being made to each file, including attribute changes.
              This is exactly the same as specifying <b>--out-</b>
              <b>format='%i %n%L'</b>.  If you repeat the option, unchanged
              files will also be output, but only if the receiving rsync
              is at least version 2.6.7 (you can use <b>-vv </b>with older
              versions of rsync, but that also turns on the output of
              other verbose messages).

              The "%i" escape has a cryptic output that is 11 letters
              long.  The general format is like the string <b>YXcstpoguax</b>,
              where <b>Y </b>is replaced by the type of update being done, <b>X </b>is
              replaced by the file-type, and the other letters represent
              attributes that may be output if they are being modified.

              The update types that replace the <b>Y </b>are as follows:

              o      A <b>&lt; </b>means that a file is being transferred to the
                     remote host (sent).

              o      A <b>&gt; </b>means that a file is being transferred to the
                     local host (received).

              o      A <b>c </b>means that a local change/creation is occurring
                     for the item (such as the creation of a directory
                     or the changing of a symlink, etc.).

              o      A <b>h </b>means that the item is a hard link to another
                     item (requires <b>--hard-links</b>).

              o      A <b>. </b>means that the item is not being updated
                     (though it might have attributes that are being
                     modified).

              o      A <b>* </b>means that the rest of the itemized-output area
                     contains a message (e.g. "deleting").

              The file-types that replace the <b>X </b>are: <b>f </b>for a file, a <b>d</b>
              for a directory, an <b>L </b>for a symlink, a <b>D </b>for a device, and
              a <b>S </b>for a special file (e.g. named sockets and fifos).

              The other letters in the string indicate if some
              attributes of the file have changed, as follows:

              o      "<b>.</b>" - the attribute is unchanged.

              o      "<b>+</b>" - the file is newly created.

              o      " " - all the attributes are unchanged (all dots
                     turn to spaces).

              o      "<b>?</b>" - the change is unknown (when the remote rsync
                     is old).

              o      A letter indicates an attribute is being updated.

              The attribute that is associated with each letter is as
              follows:

              o      A <b>c </b>means either that a regular file has a
                     different checksum (requires <b>--checksum</b>) or that a
                     symlink, device, or special file has a changed
                     value.  Note that if you are sending files to an
                     rsync prior to 3.0.1, this change flag will be
                     present only for checksum-differing regular files.

              o      A <b>s </b>means the size of a regular file is different
                     and will be updated by the file transfer.

              o      A <b>t </b>means the modification time is different and is
                     being updated to the sender's value (requires
                     <b>--times</b>).  An alternate value of <b>T </b>means that the
                     modification time will be set to the transfer time,
                     which happens when a file/symlink/device is updated
                     without <b>--times </b>and when a symlink is changed and
                     the receiver can't set its time. (Note: when using
                     an rsync 3.0.0 client, you might see the <b>s </b>flag
                     combined with <b>t </b>instead of the proper <b>T </b>flag for
                     this time-setting failure.)

              o      A <b>p </b>means the permissions are different and are
                     being updated to the sender's value (requires
                     <b>--perms</b>).

              o      An <b>o </b>means the owner is different and is being
                     updated to the sender's value (requires <b>--owner </b>and
                     super-user privileges).

              o      A <b>g </b>means the group is different and is being
                     updated to the sender's value (requires <b>--group </b>and
                     the authority to set the group).

              o

                     o      A <b>u</b>|<b>n</b>|<b>b </b>indicates the following information:

                            <b>u  </b>means the access (use) time is different
                            and is being updated to the sender's value
                            (requires <b>--atimes</b>)

                     o      <b>n </b>means the create time (newness) is
                            different and is being updated to the
                            sender's value (requires <b>--crtimes</b>)

                     o      <b>b </b>means that both the access and create
                            times are being updated

              o      The <b>a </b>means that the ACL information is being
                     changed.

              o      The <b>x </b>means that the extended attribute information
                     is being changed.

              One other output is possible: when deleting files, the
              "%i" will output the string "<b>*deleting</b>" for each item that
              is being removed (assuming that you are talking to a
              recent enough rsync that it logs deletions instead of
              outputting them as a verbose message).

       <b>--out-format=FORMAT</b>
              This allows you to specify exactly what the rsync client
              outputs to the user on a per-update basis.  The format is
              a text string containing embedded single-character escape
              sequences prefixed with a percent (%) character.  A
              default format of "%n%L" is assumed if either <b>--info=name</b>
              or <b>-v </b>is specified (this tells you just the name of the
              file and, if the item is a link, where it points).  For a
              full list of the possible escape characters, see the
              <b>log format </b>setting in the rsyncd.conf manpage.

              Specifying the <b>--out-format </b>option implies the <b>--info=name</b>
              option, which will mention each file, dir, etc. that gets
              updated in a significant way (a transferred file, a
              recreated symlink/device, or a touched directory).  In
              addition, if the itemize-changes escape (%i) is included
              in the string (e.g. if the <b>--itemize-changes </b>option was
              used), the logging of names increases to mention any item
              that is changed in any way (as long as the receiving side
              is at least 2.6.4).  See the <b>--itemize-changes </b>option for
              a description of the output of "%i".

              Rsync will output the out-format string prior to a file's
              transfer unless one of the transfer-statistic escapes is
              requested, in which case the logging is done at the end of
              the file's transfer.  When this late logging is in effect
              and <b>--progress </b>is also specified, rsync will also output
              the name of the file being transferred prior to its
              progress information (followed, of course, by the out-
              format output).

       <b>--log-file=FILE</b>
              This option causes rsync to log what it is doing to a
              file.  This is similar to the logging that a daemon does,
              but can be requested for the client side and/or the server
              side of a non-daemon transfer.  If specified as a client
              option, transfer logging will be enabled with a default
              format of "%i %n%L".  See the <b>--log-file-format </b>option if
              you wish to override this.

              Here's an example command that requests the remote side to
              log what is happening:

                  rsync -av --remote-option=--log-file=/tmp/rlog src/ dest/

              This is very useful if you need to debug why a connection
              is closing unexpectedly.

              See also the daemon version of the <b>--log-file </b>option.

       <b>--log-file-format=FORMAT</b>
              This allows you to specify exactly what per-update logging
              is put into the file specified by the <b>--log-file </b>option
              (which must also be specified for this option to have any
              effect).  If you specify an empty string, updated files
              will not be mentioned in the log file.  For a list of the
              possible escape characters, see the <b>log format </b>setting in
              the rsyncd.conf manpage.

              The default FORMAT used if <b>--log-file </b>is specified and
              this option is not is '%i %n%L'.

              See also the daemon version of the <b>--log-file-format</b>
              option.

       <b>--stats</b>
              This tells rsync to print a verbose set of statistics on
              the file transfer, allowing you to tell how effective
              rsync's delta-transfer algorithm is for your data.  This
              option is equivalent to <b>--info=stats2 </b>if combined with 0
              or 1 <b>-v </b>options, or <b>--info=stats3 </b>if combined with 2 or
              more <b>-v </b>options.

              The current statistics are as follows:

              o      <b>Number of files </b>is the count of all "files" (in the
                     generic sense), which includes directories,
                     symlinks, etc.  The total count will be followed by
                     a list of counts by filetype (if the total is non-
                     zero).  For example: "(reg: 5, dir: 3, link: 2,
                     dev: 1, special: 1)" lists the totals for regular
                     files, directories, symlinks, devices, and special
                     files.  If any of value is 0, it is completely
                     omitted from the list.

              o      <b>Number of created files </b>is the count of how many
                     "files" (generic sense) were created (as opposed to
                     updated).  The total count will be followed by a
                     list of counts by filetype (if the total is non-
                     zero).

              o      <b>Number of deleted files </b>is the count of how many
                     "files" (generic sense) were deleted.  The total
                     count will be followed by a list of counts by
                     filetype (if the total is non-zero).  Note that
                     this line is only output if deletions are in
                     effect, and only if protocol 31 is being used (the
                     default for rsync 3.1.x).

              o      <b>Number of regular files transferred </b>is the count of
                     normal files that were updated via rsync's delta-
                     transfer algorithm, which does not include dirs,
                     symlinks, etc.  Note that rsync 3.1.0 added the
                     word "regular" into this heading.

              o      <b>Total file size </b>is the total sum of all file sizes
                     in the transfer.  This does not count any size for
                     directories or special files, but does include the
                     size of symlinks.

              o      <b>Total transferred file size </b>is the total sum of all
                     files sizes for just the transferred files.

              o      <b>Literal data </b>is how much unmatched file-update data
                     we had to send to the receiver for it to recreate
                     the updated files.

              o      <b>Matched data </b>is how much data the receiver got
                     locally when recreating the updated files.

              o      <b>File list size </b>is how big the file-list data was
                     when the sender sent it to the receiver.  This is
                     smaller than the in-memory size for the file list
                     due to some compressing of duplicated data when
                     rsync sends the list.

              o      <b>File list generation time </b>is the number of seconds
                     that the sender spent creating the file list.  This
                     requires a modern rsync on the sending side for
                     this to be present.

              o      <b>File list transfer time </b>is the number of seconds
                     that the sender spent sending the file list to the
                     receiver.

              o      <b>Total bytes sent </b>is the count of all the bytes that
                     rsync sent from the client side to the server side.

              o      <b>Total bytes received </b>is the count of all non-
                     message bytes that rsync received by the client
                     side from the server side. "Non-message" bytes
                     means that we don't count the bytes for a verbose
                     message that the server sent to us, which makes the
                     stats more consistent.

       <b>--8-bit-output</b>, <b>-8</b>
              This tells rsync to leave all high-bit characters
              unescaped in the output instead of trying to test them to
              see if they're valid in the current locale and escaping
              the invalid ones.  All control characters (but never tabs)
              are always escaped, regardless of this option's setting.

              The escape idiom that started in 2.6.7 is to output a
              literal backslash (<b>\</b>) and a hash (<b>#</b>), followed by exactly
              3 octal digits.  For example, a newline would output as
              "<b>\#012</b>".  A literal backslash that is in a filename is not
              escaped unless it is followed by a hash and 3 digits
              (0-9).

       <b>--human-readable</b>, <b>-h</b>
              Output numbers in a more human-readable format.  There are
              3 possible levels:

              1.     output numbers with a separator between each set of
                     3 digits (either a comma or a period, depending on
                     if the decimal point is represented by a period or
                     a comma).

              2.     output numbers in units of 1000 (with a character
                     suffix for larger units -- see below).

              3.     output numbers in units of 1024.

              The default is human-readable level 1.  Each <b>-h </b>option
              increases the level by one.  You can take the level down
              to 0 (to output numbers as pure digits) by specifying the
              <b>--no-human-readable </b>(<b>--no-h</b>) option.

              The unit letters that are appended in levels 2 and 3 are:
              <b>K </b>(kilo), <b>M </b>(mega), <b>G </b>(giga), <b>T </b>(tera), or <b>P </b>(peta).  For
              example, a 1234567-byte file would output as 1.23M in
              level-2 (assuming that a period is your local decimal
              point).

              Backward compatibility note: versions of rsync prior to
              3.1.0 do not support human-readable level 1, and they
              default to level 0.  Thus, specifying one or two <b>-h</b>
              options will behave in a comparable manner in old and new
              versions as long as you didn't specify a <b>--no-h </b>option
              prior to one or more <b>-h </b>options.  See the <b>--list-only</b>
              option for one difference.

       <b>--partial</b>
              By default, rsync will delete any partially transferred
              file if the transfer is interrupted.  In some
              circumstances it is more desirable to keep partially
              transferred files.  Using the <b>--partial </b>option tells rsync
              to keep the partial file which should make a subsequent
              transfer of the rest of the file much faster.

       <b>--partial-dir=DIR</b>
              This option modifies the behavior of the <b>--partial </b>option
              while also implying that it be enabled.  This enhanced
              partial-file method puts any partially transferred files
              into the specified <i>DIR</i> instead of writing the partial file
              out to the destination file.  On the next transfer, rsync
              will use a file found in this dir as data to speed up the
              resumption of the transfer and then delete it after it has
              served its purpose.

              Note that if <b>--whole-file </b>is specified (or implied), any
              partial-dir files that are found for a file that is being
              updated will simply be removed (since rsync is sending
              files without using rsync's delta-transfer algorithm).

              Rsync will create the <i>DIR</i> if it is missing, but just the
              last dir -- not the whole path.  This makes it easy to use
              a relative path (such as "<b>--partial-dir=.rsync-partial</b>")
              to have rsync create the partial-directory in the
              destination file's directory when it is needed, and then
              remove it again when the partial file is deleted.  Note
              that this directory removal is only done for a relative
              pathname, as it is expected that an absolute path is to a
              directory that is reserved for partial-dir work.

              If the partial-dir value is not an absolute path, rsync
              will add an exclude rule at the end of all your existing
              excludes.  This will prevent the sending of any partial-
              dir files that may exist on the sending side, and will
              also prevent the untimely deletion of partial-dir items on
              the receiving side.  An example: the above <b>--partial-dir</b>
              option would add the equivalent of this "perishable"
              exclude at the end of any other filter rules:
              <b>-f '-p .rsync-partial/'</b>

              If you are supplying your own exclude rules, you may need
              to add your own exclude/hide/protect rule for the partial-
              dir because:

              1.     the auto-added rule may be ineffective at the end
                     of your other rules, or

              2.     you may wish to override rsync's exclude choice.

              For instance, if you want to make rsync clean-up any left-
              over partial-dirs that may be lying around, you should
              specify <b>--delete-after </b>and add a "risk" filter rule, e.g.
              <b>-f 'R .rsync-partial/'</b>. Avoid using <b>--delete-before </b>or
              <b>--delete-during </b>unless you don't need rsync to use any of
              the left-over partial-dir data during the current run.

              IMPORTANT: the <b>--partial-dir </b>should not be writable by
              other users or it is a security risk!  E.g. AVOID "/tmp"!

              You can also set the partial-dir value the
              <b>RSYNC_PARTIAL_DIR </b>environment variable.  Setting this in
              the environment does not force <b>--partial </b>to be enabled,
              but rather it affects where partial files go when
              <b>--partial </b>is specified.  For instance, instead of using
              <b>--partial-dir=.rsync-tmp </b>along with <b>--progress</b>, you could
              set <b>RSYNC_PARTIAL_DIR=.rsync-tmp </b>in your environment and
              then use the <b>-P </b>option to turn on the use of the .rsync-
              tmp dir for partial transfers.  The only times that the
              <b>--partial </b>option does not look for this environment value
              are:

              1.     when <b>--inplace </b>was specified (since <b>--inplace</b>
                     conflicts with <b>--partial-dir</b>), and

              2.     when <b>--delay-updates </b>was specified (see below).

              When a modern rsync resumes the transfer of a file in the
              partial-dir, that partial file is now updated in-place
              instead of creating yet another tmp-file copy (so it maxes
              out at dest + tmp instead of dest + partial + tmp).  This
              requires both ends of the transfer to be at least version
              3.2.0.

              For the purposes of the daemon-config's "<b>refuse options</b>"
              setting, <b>--partial-dir </b>does <i>not</i> imply <b>--partial</b>.  This is
              so that a refusal of the <b>--partial </b>option can be used to
              disallow the overwriting of destination files with a
              partial transfer, while still allowing the safer idiom
              provided by <b>--partial-dir</b>.

       <b>--delay-updates</b>
              This option puts the temporary file from each updated file
              into a holding directory until the end of the transfer, at
              which time all the files are renamed into place in rapid
              succession.  This attempts to make the updating of the
              files a little more atomic.  By default the files are
              placed into a directory named <b>.~tmp~ </b>in each file's
              destination directory, but if you've specified the
              <b>--partial-dir </b>option, that directory will be used instead.
              See the comments in the <b>--partial-dir </b>section for a
              discussion of how this <b>.~tmp~ </b>dir will be excluded from
              the transfer, and what you can do if you want rsync to
              cleanup old <b>.~tmp~ </b>dirs that might be lying around.
              Conflicts with <b>--inplace </b>and <b>--append</b>.

              This option implies <b>--no-inc-recursive </b>since it needs the
              full file list in memory in order to be able to iterate
              over it at the end.

              This option uses more memory on the receiving side (one
              bit per file transferred) and also requires enough free
              disk space on the receiving side to hold an additional
              copy of all the updated files.  Note also that you should
              not use an absolute path to <b>--partial-dir </b>unless:

              1.     there is no chance of any of the files in the
                     transfer having the same name (since all the
                     updated files will be put into a single directory
                     if the path is absolute), and

              2.     there are no mount points in the hierarchy (since
                     the delayed updates will fail if they can't be
                     renamed into place).

              See also the "atomic-rsync" python script in the "support"
              subdir for an update algorithm that is even more atomic
              (it uses <b>--link-dest </b>and a parallel hierarchy of files).

       <b>--prune-empty-dirs</b>, <b>-m</b>
              This option tells the receiving rsync to get rid of empty
              directories from the file-list, including nested
              directories that have no non-directory children.  This is
              useful for avoiding the creation of a bunch of useless
              directories when the sending rsync is recursively scanning
              a hierarchy of files using include/exclude/filter rules.

              This option can still leave empty directories on the
              receiving side if you make use of TRANSFER_RULES.

              Because the file-list is actually being pruned, this
              option also affects what directories get deleted when a
              delete is active.  However, keep in mind that excluded
              files and directories can prevent existing items from
              being deleted due to an exclude both hiding source files
              and protecting destination files.  See the perishable
              filter-rule option for how to avoid this.

              You can prevent the pruning of certain empty directories
              from the file-list by using a global "protect" filter.
              For instance, this option would ensure that the directory
              "emptydir" was kept in the file-list:

                  --filter 'protect emptydir/'

              Here's an example that copies all .pdf files in a
              hierarchy, only creating the necessary destination
              directories to hold the .pdf files, and ensures that any
              superfluous files and directories in the destination are
              removed (note the hide filter of non-directories being
              used instead of an exclude):

                  rsync -avm --del --include='*.pdf' -f 'hide,! */' src/ dest

              If you didn't want to remove superfluous destination
              files, the more time-honored options of
              <b>--include='*/' --exclude='*' </b>would work fine in place of
              the hide-filter (if that is more natural to you).

       <b>--progress</b>
              This option tells rsync to print information showing the
              progress of the transfer.  This gives a bored user
              something to watch.  With a modern rsync this is the same
              as specifying <b>--info=flist2,name,progress</b>, but any user-
              supplied settings for those info flags takes precedence
              (e.g.  <b>--info=flist0 --progress</b>).

              While rsync is transferring a regular file, it updates a
              progress line that looks like this:

                  782448  63%  110.64kB/s    0:00:04

              In this example, the receiver has reconstructed 782448
              bytes or 63% of the sender's file, which is being
              reconstructed at a rate of 110.64 kilobytes per second,
              and the transfer will finish in 4 seconds if the current
              rate is maintained until the end.

              These statistics can be misleading if rsync's delta-
              transfer algorithm is in use.  For example, if the
              sender's file consists of the basis file followed by
              additional data, the reported rate will probably drop
              dramatically when the receiver gets to the literal data,
              and the transfer will probably take much longer to finish
              than the receiver estimated as it was finishing the
              matched part of the file.

              When the file transfer finishes, rsync replaces the
              progress line with a summary line that looks like this:

                  1,238,099 100%  146.38kB/s    0:00:08  (xfr#5, to-chk=169/396)

              In this example, the file was 1,238,099 bytes long in
              total, the average rate of transfer for the whole file was
              146.38 kilobytes per second over the 8 seconds that it
              took to complete, it was the 5th transfer of a regular
              file during the current rsync session, and there are 169
              more files for the receiver to check (to see if they are
              up-to-date or not) remaining out of the 396 total files in
              the file-list.

              In an incremental recursion scan, rsync won't know the
              total number of files in the file-list until it reaches
              the ends of the scan, but since it starts to transfer
              files during the scan, it will display a line with the
              text "ir-chk" (for incremental recursion check) instead of
              "to-chk" until the point that it knows the full size of
              the list, at which point it will switch to using "to-chk".
              Thus, seeing "ir-chk" lets you know that the total count
              of files in the file list is still going to increase (and
              each time it does, the count of files left to check will
              increase by the number of the files added to the list).

       <b>-P     </b>The <b>-P </b>option is equivalent to "<b>--partial --progress</b>".
              Its purpose is to make it much easier to specify these two
              options for a long transfer that may be interrupted.

              There is also a <b>--info=progress2 </b>option that outputs
              statistics based on the whole transfer, rather than
              individual files.  Use this flag without outputting a
              filename (e.g. avoid <b>-v </b>or specify <b>--info=name0</b>) if you
              want to see how the transfer is doing without scrolling
              the screen with a lot of names. (You don't need to specify
              the <b>--progress </b>option in order to use <b>--info=progress2</b>.)

              Finally, you can get an instant progress report by sending
              rsync a signal of either SIGINFO or SIGVTALRM.  On BSD
              systems, a SIGINFO is generated by typing a Ctrl+T (Linux
              doesn't currently support a SIGINFO signal).  When the
              client-side process receives one of those signals, it sets
              a flag to output a single progress report which is output
              when the current file transfer finishes (so it may take a
              little time if a big file is being handled when the signal
              arrives).  A filename is output (if needed) followed by
              the <b>--info=progress2 </b>format of progress info.  If you
              don't know which of the 3 rsync processes is the client
              process, it's OK to signal all of them (since the non-
              client processes ignore the signal).

              CAUTION: sending SIGVTALRM to an older rsync (pre-3.2.0)
              will kill it.

       <b>--password-file=FILE</b>
              This option allows you to provide a password for accessing
              an rsync daemon via a file or via standard input if <b>FILE</b>
              is <b>-</b>.  The file should contain just the password on the
              first line (all other lines are ignored).  Rsync will exit
              with an error if <b>FILE </b>is world readable or if a root-run
              rsync command finds a non-root-owned file.

              This option does not supply a password to a remote shell
              transport such as ssh; to learn how to do that, consult
              the remote shell's documentation.  When accessing an rsync
              daemon using a remote shell as the transport, this option
              only comes into effect after the remote shell finishes its
              authentication (i.e. if you have also specified a password
              in the daemon's config file).

       <b>--early-input=FILE</b>
              This option allows rsync to send up to 5K of data to the
              "early exec" script on its stdin.  One possible use of
              this data is to give the script a secret that can be used
              to mount an encrypted filesystem (which you should unmount
              in the the "post-xfer exec" script).

              The daemon must be at least version 3.2.1.

       <b>--list-only</b>
              This option will cause the source files to be listed
              instead of transferred.  This option is inferred if there
              is a single source arg and no destination specified, so
              its main uses are:

              1.     to turn a copy command that includes a destination
                     arg into a file-listing command, or

              2.     to be able to specify more than one source arg.
                     Note: be sure to include the destination.

              CAUTION: keep in mind that a source arg with a wild-card
              is expanded by the shell into multiple args, so it is
              never safe to try to specify a single wild-card arg to try
              to infer this option. A safe example is:

                  rsync -av --list-only foo* dest/

              This option always uses an output format that looks
              similar to this:

                  drwxrwxr-x          4,096 2022/09/30 12:53:11 support
                  -rw-rw-r--             80 2005/01/11 10:37:37 support/Makefile

              The only option that affects this output style is (as of
              3.1.0) the <b>--human-readable </b>(<b>-h</b>) option.  The default is
              to output sizes as byte counts with digit separators (in a
              14-character-width column).  Specifying at least one <b>-h</b>
              option makes the sizes output with unit suffixes.  If you
              want old-style bytecount sizes without digit separators
              (and an 11-character-width column) use <b>--no-h</b>.

              Compatibility note: when requesting a remote listing of
              files from an rsync that is version 2.6.3 or older, you
              may encounter an error if you ask for a non-recursive
              listing.  This is because a file listing implies the
              <b>--dirs </b>option w/o <b>--recursive</b>, and older rsyncs don't have
              that option.  To avoid this problem, either specify the
              <b>--no-dirs </b>option (if you don't need to expand a
              directory's content), or turn on recursion and exclude the
              content of subdirectories: <b>-r --exclude='/*/*'</b>.

       <b>--bwlimit=RATE</b>
              This option allows you to specify the maximum transfer
              rate for the data sent over the socket, specified in units
              per second.  The RATE value can be suffixed with a string
              to indicate a size multiplier, and may be a fractional
              value (e.g. <b>--bwlimit=1.5m</b>).  If no suffix is specified,
              the value will be assumed to be in units of 1024 bytes (as
              if "K" or "KiB" had been appended).  See the <b>--max-size</b>
              option for a description of all the available suffixes.  A
              value of 0 specifies no limit.

              For backward-compatibility reasons, the rate limit will be
              rounded to the nearest KiB unit, so no rate smaller than
              1024 bytes per second is possible.

              Rsync writes data over the socket in blocks, and this
              option both limits the size of the blocks that rsync
              writes, and tries to keep the average transfer rate at the
              requested limit.  Some burstiness may be seen where rsync
              writes out a block of data and then sleeps to bring the
              average rate into compliance.

              Due to the internal buffering of data, the <b>--progress</b>
              option may not be an accurate reflection on how fast the
              data is being sent.  This is because some files can show
              up as being rapidly sent when the data is quickly
              buffered, while other can show up as very slow when the
              flushing of the output buffer occurs.  This may be fixed
              in a future version.

              See also the daemon version of the <b>--bwlimit </b>option.

       <b>--stop-after=MINS</b>, (<b>--time-limit=MINS</b>)
              This option tells rsync to stop copying when the specified
              number of minutes has elapsed.

              For maximal flexibility, rsync does not communicate this
              option to the remote rsync since it is usually enough that
              one side of the connection quits as specified.  This
              allows the option's use even when only one side of the
              connection supports it.  You can tell the remote side
              about the time limit using <b>--remote-option </b>(<b>-M</b>), should
              the need arise.

              The <b>--time-limit </b>version of this option is deprecated.

       <b>--stop-at=y-m-dTh:m</b>
              This option tells rsync to stop copying when the specified
              point in time has been reached. The date &amp; time can be
              fully specified in a numeric format of year-month-
              dayThour:minute (e.g. 2000-12-31T23:59) in the local
              timezone.  You may choose to separate the date numbers
              using slashes instead of dashes.

              The value can also be abbreviated in a variety of ways,
              such as specifying a 2-digit year and/or leaving off
              various values.  In all cases, the value will be taken to
              be the next possible point in time where the supplied
              information matches.  If the value specifies the current
              time or a past time, rsync exits with an error.

              For example, "1-30" specifies the next January 30th (at
              midnight local time), "14:00" specifies the next 2 P.M.,
              "1" specifies the next 1st of the month at midnight, "31"
              specifies the next month where we can stop on its 31st
              day, and ":59" specifies the next 59th minute after the
              hour.

              For maximal flexibility, rsync does not communicate this
              option to the remote rsync since it is usually enough that
              one side of the connection quits as specified.  This
              allows the option's use even when only one side of the
              connection supports it.  You can tell the remote side
              about the time limit using <b>--remote-option </b>(<b>-M</b>), should
              the need arise.  Do keep in mind that the remote host may
              have a different default timezone than your local host.

       <b>--fsync</b>
              Cause the receiving side to fsync each finished file.
              This may slow down the transfer, but can help to provide
              peace of mind when updating critical files.

       <b>--write-batch=FILE</b>
              Record a file that can later be applied to another
              identical destination with <b>--read-batch</b>.  See the "BATCH
              MODE" section for details, and also the <b>--only-write-batch</b>
              option.

              This option overrides the negotiated checksum &amp; compress
              lists and always negotiates a choice based on old-school
              md5/md4/zlib choices.  If you want a more modern choice,
              use the <b>--checksum-choice </b>(<b>--cc</b>) and/or <b>--compress-choice</b>
              (<b>--zc</b>) options.

       <b>--only-write-batch=FILE</b>
              Works like <b>--write-batch</b>, except that no updates are made
              on the destination system when creating the batch.  This
              lets you transport the changes to the destination system
              via some other means and then apply the changes via
              <b>--read-batch</b>.

              Note that you can feel free to write the batch directly to
              some portable media: if this media fills to capacity
              before the end of the transfer, you can just apply that
              partial transfer to the destination and repeat the whole
              process to get the rest of the changes (as long as you
              don't mind a partially updated destination system while
              the multi-update cycle is happening).

              Also note that you only save bandwidth when pushing
              changes to a remote system because this allows the batched
              data to be diverted from the sender into the batch file
              without having to flow over the wire to the receiver (when
              pulling, the sender is remote, and thus can't write the
              batch).

       <b>--read-batch=FILE</b>
              Apply all of the changes stored in FILE, a file previously
              generated by <b>--write-batch</b>.  If <i>FILE</i> is <b>-</b>, the batch data
              will be read from standard input. See the "BATCH MODE"
              section for details.

       <b>--protocol=NUM</b>
              Force an older protocol version to be used.  This is
              useful for creating a batch file that is compatible with
              an older version of rsync.  For instance, if rsync 2.6.4
              is being used with the <b>--write-batch </b>option, but rsync
              2.6.3 is what will be used to run the <b>--read-batch </b>option,
              you should use "--protocol=28" when creating the batch
              file to force the older protocol version to be used in the
              batch file (assuming you can't upgrade the rsync on the
              reading system).

       <b>--iconv=CONVERT_SPEC</b>
              Rsync can convert filenames between character sets using
              this option.  Using a CONVERT_SPEC of "." tells rsync to
              look up the default character-set via the locale setting.
              Alternately, you can fully specify what conversion to do
              by giving a local and a remote charset separated by a
              comma in the order <b>--iconv=LOCAL,REMOTE</b>, e.g.
              <b>--iconv=utf8,iso88591</b>.  This order ensures that the option
              will stay the same whether you're pushing or pulling
              files.  Finally, you can specify either <b>--no-iconv </b>or a
              CONVERT_SPEC of "-" to turn off any conversion.  The
              default setting of this option is site-specific, and can
              also be affected via the <b>RSYNC_ICONV </b>environment variable.

              For a list of what charset names your local iconv library
              supports, you can run "<b>iconv --list</b>".

              If you specify the <b>--secluded-args </b>(<b>-s</b>) option, rsync will
              translate the filenames you specify on the command-line
              that are being sent to the remote host.  See also the
              <b>--files-from </b>option.

              Note that rsync does not do any conversion of names in
              filter files (including include/exclude files).  It is up
              to you to ensure that you're specifying matching rules
              that can match on both sides of the transfer.  For
              instance, you can specify extra include/exclude rules if
              there are filename differences on the two sides that need
              to be accounted for.

              When you pass an <b>--iconv </b>option to an rsync daemon that
              allows it, the daemon uses the charset specified in its
              "charset" configuration parameter regardless of the remote
              charset you actually pass.  Thus, you may feel free to
              specify just the local charset for a daemon transfer (e.g.
              <b>--iconv=utf8</b>).

       <b>--ipv4</b>, <b>-4 </b>or <b>--ipv6</b>, <b>-6</b>
              Tells rsync to prefer IPv4/IPv6 when creating sockets or
              running ssh.  This affects sockets that rsync has direct
              control over, such as the outgoing socket when directly
              contacting an rsync daemon, as well as the forwarding of
              the <b>-4 </b>or <b>-6 </b>option to ssh when rsync can deduce that ssh
              is being used as the remote shell.  For other remote
              shells you'll need to specify the "<b>--rsh SHELL -4</b>" option
              directly (or whatever IPv4/IPv6 hint options it uses).

              See also the daemon version of these options.

              If rsync was compiled without support for IPv6, the <b>--ipv6</b>
              option will have no effect.  The <b>rsync --version </b>output
              will contain "<b>no IPv6</b>" if is the case.

       <b>--checksum-seed=NUM</b>
              Set the checksum seed to the integer NUM.  This 4 byte
              checksum seed is included in each block and MD4 file
              checksum calculation (the more modern MD5 file checksums
              don't use a seed).  By default the checksum seed is
              generated by the server and defaults to the current
              <b>time</b>().  This option is used to set a specific checksum
              seed, which is useful for applications that want
              repeatable block checksums, or in the case where the user
              wants a more random checksum seed.  Setting NUM to 0
              causes rsync to use the default of <b>time</b>() for checksum
              seed.
</pre> <h2>
DAEMON OPTIONS </h2>
<pre>
       The options allowed when starting an rsync daemon are as follows:

       <b>--daemon</b>
              This tells rsync that it is to run as a daemon.  The
              daemon you start running may be accessed using an rsync
              client using the <b>host::module </b>or <b>rsync://host/module/</b>
              syntax.

              If standard input is a socket then rsync will assume that
              it is being run via inetd, otherwise it will detach from
              the current terminal and become a background daemon.  The
              daemon will read the config file (rsyncd.conf) on each
              connect made by a client and respond to requests
              accordingly.

              See the <a href="../man5/rsyncd.conf.5.html">rsyncd.conf(5)</a> manpage for more details.

       <b>--address=ADDRESS</b>
              By default rsync will bind to the wildcard address when
              run as a daemon with the <b>--daemon </b>option.  The <b>--address</b>
              option allows you to specify a specific IP address (or
              hostname) to bind to.  This makes virtual hosting possible
              in conjunction with the <b>--config </b>option.

              See also the address global option in the rsyncd.conf
              manpage and the client version of the <b>--address </b>option.

       <b>--bwlimit=RATE</b>
              This option allows you to specify the maximum transfer
              rate for the data the daemon sends over the socket.  The
              client can still specify a smaller <b>--bwlimit </b>value, but no
              larger value will be allowed.

              See the client version of the <b>--bwlimit </b>option for some
              extra details.

       <b>--config=FILE</b>
              This specifies an alternate config file than the default.
              This is only relevant when <b>--daemon </b>is specified.  The
              default is /etc/rsyncd.conf unless the daemon is running
              over a remote shell program and the remote user is not the
              super-user; in that case the default is rsyncd.conf in the
              current directory (typically $HOME).

       <b>--dparam=OVERRIDE</b>, <b>-M</b>
              This option can be used to set a daemon-config parameter
              when starting up rsync in daemon mode.  It is equivalent
              to adding the parameter at the end of the global settings
              prior to the first module's definition.  The parameter
              names can be specified without spaces, if you so desire.
              For instance:

                  rsync --daemon -M pidfile=/path/rsync.pid

       <b>--no-detach</b>
              When running as a daemon, this option instructs rsync to
              not detach itself and become a background process.  This
              option is required when running as a service on Cygwin,
              and may also be useful when rsync is supervised by a
              program such as <b>daemontools </b>or AIX's
              <b>System Resource Controller</b>.  <b>--no-detach </b>is also
              recommended when rsync is run under a debugger.  This
              option has no effect if rsync is run from inetd or sshd.

       <b>--port=PORT</b>
              This specifies an alternate TCP port number for the daemon
              to listen on rather than the default of 873.

              See also the client version of the <b>--port </b>option and the
              port global setting in the rsyncd.conf manpage.

       <b>--log-file=FILE</b>
              This option tells the rsync daemon to use the given log-
              file name instead of using the "<b>log file</b>" setting in the
              config file.

              See also the client version of the <b>--log-file </b>option.

       <b>--log-file-format=FORMAT</b>
              This option tells the rsync daemon to use the given FORMAT
              string instead of using the "<b>log format</b>" setting in the
              config file.  It also enables "<b>transfer logging</b>" unless
              the string is empty, in which case transfer logging is
              turned off.

              See also the client version of the <b>--log-file-format</b>
              option.

       <b>--sockopts</b>
              This overrides the <b>socket options </b>setting in the
              rsyncd.conf file and has the same syntax.

              See also the client version of the <b>--sockopts </b>option.

       <b>--verbose</b>, <b>-v</b>
              This option increases the amount of information the daemon
              logs during its startup phase.  After the client connects,
              the daemon's verbosity level will be controlled by the
              options that the client used and the "<b>max verbosity</b>"
              setting in the module's config section.

              See also the client version of the <b>--verbose </b>option.

       <b>--ipv4</b>, <b>-4 </b>or <b>--ipv6</b>, <b>-6</b>
              Tells rsync to prefer IPv4/IPv6 when creating the incoming
              sockets that the rsync daemon will use to listen for
              connections.  One of these options may be required in
              older versions of Linux to work around an IPv6 bug in the
              kernel (if you see an "address already in use" error when
              nothing else is using the port, try specifying <b>--ipv6 </b>or
              <b>--ipv4 </b>when starting the daemon).

              See also the client version of these options.

              If rsync was compiled without support for IPv6, the <b>--ipv6</b>
              option will have no effect.  The <b>rsync --version </b>output
              will contain "<b>no IPv6</b>" if is the case.

       <b>--help</b>, <b>-h</b>
              When specified after <b>--daemon</b>, print a short help page
              describing the options available for starting an rsync
              daemon.
</pre> <h2>
FILTER RULES </h2>
<pre>
       The filter rules allow for custom control of several aspects of
       how files are handled:

       o      Control which files the sending side puts into the file
              list that describes the transfer hierarchy

       o      Control which files the receiving side protects from
              deletion when the file is not in the sender's file list

       o      Control which extended attribute names are skipped when
              copying xattrs

       The rules are either directly specified via option arguments or
       they can be read in from one or more files.  The filter-rule
       files can even be a part of the hierarchy of files being copied,
       affecting different parts of the tree in different ways.

   <b>SIMPLE INCLUDE/EXCLUDE RULES</b>
       We will first cover the basics of how include &amp; exclude rules
       affect what files are transferred, ignoring any deletion side-
       effects.  Filter rules mainly affect the contents of directories
       that rsync is "recursing" into, but they can also affect a top-
       level item in the transfer that was specified as a argument.

       The default for any unmatched file/dir is for it to be included
       in the transfer, which puts the file/dir into the sender's file
       list.  The use of an exclude rule causes one or more matching
       files/dirs to be left out of the sender's file list.  An include
       rule can be used to limit the effect of an exclude rule that is
       matching too many files.

       The order of the rules is important because the first rule that
       matches is the one that takes effect.  Thus, if an early rule
       excludes a file, no include rule that comes after it can have any
       effect. This means that you must place any include overrides
       somewhere prior to the exclude that it is intended to limit.

       When a directory is excluded, all its contents and sub-contents
       are also excluded.  The sender doesn't scan through any of it at
       all, which can save a lot of time when skipping large unneeded
       sub-trees.

       It is also important to understand that the include/exclude rules
       are applied to every file and directory that the sender is
       recursing into. Thus, if you want a particular deep file to be
       included, you have to make sure that none of the directories that
       must be traversed on the way down to that file are excluded or
       else the file will never be discovered to be included. As an
       example, if the directory "<b>a/path</b>" was given as a transfer
       argument and you want to ensure that the file
       "<b>a/path/down/deep/wanted.txt</b>" is a part of the transfer, then the
       sender must not exclude the directories "<b>a/path</b>", "<b>a/path/down</b>",
       or "<b>a/path/down/deep</b>" as it makes it way scanning through the
       file tree.

       When you are working on the rules, it can be helpful to ask rsync
       to tell you what is being excluded/included and why.  Specifying
       <b>--debug=FILTER </b>or (when pulling files) <b>-M--debug=FILTER </b>turns on
       level 1 of the FILTER debug information that will output a
       message any time that a file or directory is included or excluded
       and which rule it matched.  Beginning in 3.2.4 it will also warn
       if a filter rule has trailing whitespace, since an exclude of
       "foo " (with a trailing space) will not exclude a file named
       "foo".

       Exclude and include rules can specify wildcard PATTERN MATCHING
       RULES (similar to shell wildcards) that allow you to match things
       like a file suffix or a portion of a filename.

       A rule can be limited to only affecting a directory by putting a
       trailing slash onto the filename.

   <b>SIMPLE INCLUDE/EXCLUDE EXAMPLE</b>
       With the following file tree created on the sending side:

           mkdir x/
           touch x/file.txt
           mkdir x/y/
           touch x/y/file.txt
           touch x/y/zzz.txt
           mkdir x/z/
           touch x/z/file.txt

       Then the following rsync command will transfer the file
       "<b>x/y/file.txt</b>" and the directories needed to hold it, resulting
       in the path "<b>/tmp/x/y/file.txt</b>" existing on the remote host:

           rsync -ai -f'+ x/' -f'+ x/y/' -f'+ x/y/file.txt' -f'- *' x host:/tmp/

       Aside: this copy could also have been accomplished using the <b>-R</b>
       option (though the 2 commands behave differently if deletions are
       enabled):

           rsync -aiR x/y/file.txt host:/tmp/

       The following command does not need an include of the "x"
       directory because it is not a part of the transfer (note the
       traililng slash).  Running this command would copy just
       "<b>/tmp/x/file.txt</b>" because the "y" and "z" dirs get excluded:

           rsync -ai -f'+ file.txt' -f'- *' x/ host:/tmp/x/

       This command would omit the zzz.txt file while copying "x" and
       everything else it contains:

           rsync -ai -f'- zzz.txt' x host:/tmp/

   <b>FILTER RULES WHEN DELETING</b>
       By default the include &amp; exclude filter rules affect both the
       sender (as it creates its file list) and the receiver (as it
       creates its file lists for calculating deletions).  If no delete
       option is in effect, the receiver skips creating the delete-
       related file lists.  This two-sided default can be manually
       overridden so that you are only specifying sender rules or
       receiver rules, as described in the FILTER RULES IN DEPTH
       section.

       When deleting, an exclude protects a file from being removed on
       the receiving side while an include overrides that protection
       (putting the file at risk of deletion). The default is for a file
       to be at risk -- its safety depends on it matching a
       corresponding file from the sender.

       An example of the two-sided exclude effect can be illustrated by
       the copying of a C development directory between 2 systems.  When
       doing a touch-up copy, you might want to skip copying the built
       executable and the <b>.o </b>files (sender hide) so that the receiving
       side can build their own and not lose any object files that are
       already correct (receiver protect).  For instance:

           rsync -ai --del -f'- *.o' -f'- cmd' src host:/dest/

       Note that using <b>-f'-p *.o' </b>is even better than <b>-f'- *.o' </b>if there
       is a chance that the directory structure may have changed.  The
       "p" modifier is discussed in FILTER RULE MODIFIERS.

       One final note, if your shell doesn't mind unexpanded wildcards,
       you could simplify the typing of the filter options by using an
       underscore in place of the space and leaving off the quotes.  For
       instance, <b>-f -_*.o -f -_cmd </b>(and similar) could be used instead
       of the filter options above.

   <b>FILTER RULES IN DEPTH</b>
       Rsync supports old-style include/exclude rules and new-style
       filter rules.  The older rules are specified using <b>--include </b>and
       <b>--exclude </b>as well as the <b>--include-from </b>and <b>--exclude-from</b>. These
       are limited in behavior but they don't require a "-" or "+"
       prefix.  An old-style exclude rule is turned into a "<b>- name</b>"
       filter rule (with no modifiers) and an old-style include rule is
       turned into a "<b>+ name</b>" filter rule (with no modifiers).

       Rsync builds an ordered list of filter rules as specified on the
       command-line and/or read-in from files.  New style filter rules
       have the following syntax:

           RULE [PATTERN_OR_FILENAME]
           RULE,MODIFIERS [PATTERN_OR_FILENAME]

       You have your choice of using either short or long RULE names, as
       described below.  If you use a short-named rule, the ','
       separating the RULE from the MODIFIERS is optional.  The PATTERN
       or FILENAME that follows (when present) must come after either a
       single space or an underscore (_). Any additional spaces and/or
       underscores are considered to be a part of the pattern name.
       Here are the available rule prefixes:

       <b>exclude, '-'</b>
              specifies an exclude pattern that (by default) is both a
              <b>hide </b>and a <b>protect</b>.

       <b>include, '+'</b>
              specifies an include pattern that (by default) is both a
              <b>show </b>and a <b>risk</b>.

       <b>merge, '.'</b>
              specifies a merge-file on the client side to read for more
              rules.

       <b>dir-merge, ':'</b>
              specifies a per-directory merge-file.  Using this kind of
              filter rule requires that you trust the sending side's
              filter checking, so it has the side-effect mentioned under
              the <b>--trust-sender </b>option.

       <b>hide, 'H'</b>
              specifies a pattern for hiding files from the transfer.
              Equivalent to a sender-only exclude, so <b>-f'H foo' </b>could
              also be specified as <b>-f'-s foo'</b>.

       <b>show, 'S'</b>
              files that match the pattern are not hidden. Equivalent to
              a sender-only include, so <b>-f'S foo' </b>could also be
              specified as <b>-f'+s foo'</b>.

       <b>protect, 'P'</b>
              specifies a pattern for protecting files from deletion.
              Equivalent to a receiver-only exclude, so <b>-f'P foo' </b>could
              also be specified as <b>-f'-r foo'</b>.

       <b>risk, 'R'</b>
              files that match the pattern are not protected. Equivalent
              to a receiver-only include, so <b>-f'R foo' </b>could also be
              specified as <b>-f'+r foo'</b>.

       <b>clear, '!'</b>
              clears the current include/exclude list (takes no arg)

       When rules are being read from a file (using merge or dir-merge),
       empty lines are ignored, as are whole-line comments that start
       with a '<b>#</b>' (filename rules that contain a hash character are
       unaffected).

       Note also that the <b>--filter</b>, <b>--include</b>, and <b>--exclude </b>options
       take one rule/pattern each.  To add multiple ones, you can repeat
       the options on the command-line, use the merge-file syntax of the
       <b>--filter </b>option, or the <b>--include-from </b>/ <b>--exclude-from </b>options.

   <b>PATTERN MATCHING RULES</b>
       Most of the rules mentioned above take an argument that specifies
       what the rule should match.  If rsync is recursing through a
       directory hierarchy, keep in mind that each pattern is matched
       against the name of every directory in the descent path as rsync
       finds the filenames to send.

       The matching rules for the pattern argument take several forms:

       o      If a pattern contains a <b>/ </b>(not counting a trailing slash)
              or a "<b>**</b>" (which can match a slash), then the pattern is
              matched against the full pathname, including any leading
              directories within the transfer.  If the pattern doesn't
              contain a (non-trailing) <b>/ </b>or a "<b>**</b>", then it is matched
              only against the final component of the filename or
              pathname. For example, <b>foo </b>means that the final path
              component must be "foo" while <b>foo/bar </b>would match the last
              2 elements of the path (as long as both elements are
              within the transfer).

       o      A pattern that ends with a <b>/ </b>only matches a directory, not
              a regular file, symlink, or device.

       o      A pattern that starts with a <b>/ </b>is anchored to the start of
              the transfer path instead of the end.  For example,
              <b>/foo/** </b>or <b>/foo/bar/** </b>match only leading elements in the
              path.  If the rule is read from a per-directory filter
              file, the transfer path being matched will begin at the
              level of the filter file instead of the top of the
              transfer.  See the section on ANCHORING INCLUDE/EXCLUDE
              PATTERNS for a full discussion of how to specify a pattern
              that matches at the root of the transfer.

       Rsync chooses between doing a simple string match and wildcard
       matching by checking if the pattern contains one of these three
       wildcard characters: '<b>*</b>', '<b>?</b>', and '<b>[</b>' :

       o      a '<b>?</b>' matches any single character except a slash (<b>/</b>).

       o      a '<b>*</b>' matches zero or more non-slash characters.

       o      a '<b>**</b>' matches zero or more characters, including slashes.

       o      a '<b>[</b>' introduces a character class, such as <b>[a-z] </b>or
              <b>[[:alpha:]]</b>, that must match one character.

       o      a trailing <b>*** </b>in the pattern is a shorthand that allows
              you to match a directory and all its contents using a
              single rule.  For example, specifying "<b>dir_name/***</b>" will
              match both the "dir_name" directory (as if "<b>dir_name/</b>" had
              been specified) and everything in the directory (as if
              "<b>dir_name/**</b>" had been specified).

       o      a backslash can be used to escape a wildcard character,
              but it is only interpreted as an escape character if at
              least one wildcard character is present in the match
              pattern. For instance, the pattern "<b>foo\bar</b>" matches that
              single backslash literally, while the pattern "<b>foo\bar*</b>"
              would need to be changed to "<b>foo\\bar*</b>" to avoid the "<b>\b</b>"
              becoming just "b".

       Here are some examples of exclude/include matching:

       o      Option <b>-f'- *.o' </b>would exclude all filenames ending with
              <b>.o</b>

       o      Option <b>-f'- /foo' </b>would exclude a file (or directory)
              named foo in the transfer-root directory

       o      Option <b>-f'- foo/' </b>would exclude any directory named foo

       o      Option <b>-f'- foo/*/bar' </b>would exclude any file/dir named
              bar which is at two levels below a directory named foo (if
              foo is in the transfer)

       o      Option <b>-f'- /foo/**/bar' </b>would exclude any file/dir named
              bar that was two or more levels below a top-level
              directory named foo (note that /foo/bar is <b>not </b>excluded by
              this)

       o      Options <b>-f'+ */' -f'+ *.c' -f'- *' </b>would include all
              directories and .c source files but nothing else

       o      Options <b>-f'+ foo/' -f'+ foo/bar.c' -f'- *' </b>would include
              only the foo directory and foo/bar.c (the foo directory
              must be explicitly included or it would be excluded by the
              "<b>- *</b>")

   <b>FILTER RULE MODIFIERS</b>
       The following modifiers are accepted after an include (+) or
       exclude (-) rule:

       o      A <b>/ </b>specifies that the include/exclude rule should be
              matched against the absolute pathname of the current item.
              For example, <b>-f'-/ /etc/passwd' </b>would exclude the passwd
              file any time the transfer was sending files from the
              "/etc" directory, and "-/ subdir/foo" would always exclude
              "foo" when it is in a dir named "subdir", even if "foo" is
              at the root of the current transfer.

       o      A <b>! </b>specifies that the include/exclude should take effect
              if the pattern fails to match.  For instance, <b>-f'-! */'</b>
              would exclude all non-directories.

       o      A <b>C </b>is used to indicate that all the global CVS-exclude
              rules should be inserted as excludes in place of the "-C".
              No arg should follow.

       o      An <b>s </b>is used to indicate that the rule applies to the
              sending side.  When a rule affects the sending side, it
              affects what files are put into the sender's file list.
              The default is for a rule to affect both sides unless
              <b>--delete-excluded </b>was specified, in which case default
              rules become sender-side only.  See also the hide (H) and
              show (S) rules, which are an alternate way to specify
              sending-side includes/excludes.

       o      An <b>r </b>is used to indicate that the rule applies to the
              receiving side.  When a rule affects the receiving side,
              it prevents files from being deleted.  See the <b>s </b>modifier
              for more info.  See also the protect (P) and risk (R)
              rules, which are an alternate way to specify receiver-side
              includes/excludes.

       o      A <b>p </b>indicates that a rule is perishable, meaning that it
              is ignored in directories that are being deleted.  For
              instance, the <b>--cvs-exclude </b>(<b>-C</b>) option's default rules
              that exclude things like "CVS" and "<b>*.o</b>" are marked as
              perishable, and will not prevent a directory that was
              removed on the source from being deleted on the
              destination.

       o      An <b>x </b>indicates that a rule affects xattr names in xattr
              copy/delete operations (and is thus ignored when matching
              file/dir names).  If no xattr-matching rules are
              specified, a default xattr filtering rule is used (see the
              <b>--xattrs </b>option).

   <b>MERGE-FILE FILTER RULES</b>
       You can merge whole files into your filter rules by specifying
       either a merge (.) or a dir-merge (:) filter rule (as introduced
       in the FILTER RULES section above).

       There are two kinds of merged files -- single-instance ('.') and
       per-directory (':').  A single-instance merge file is read one
       time, and its rules are incorporated into the filter list in the
       place of the "." rule.  For per-directory merge files, rsync will
       scan every directory that it traverses for the named file,
       merging its contents when the file exists into the current list
       of inherited rules.  These per-directory rule files must be
       created on the sending side because it is the sending side that
       is being scanned for the available files to transfer.  These rule
       files may also need to be transferred to the receiving side if
       you want them to affect what files don't get deleted (see PER-
       DIRECTORY RULES AND DELETE below).

       Some examples:

           merge /etc/rsync/default.rules
           . /etc/rsync/default.rules
           dir-merge .per-dir-filter
           dir-merge,n- .non-inherited-per-dir-excludes
           :n- .non-inherited-per-dir-excludes

       The following modifiers are accepted after a merge or dir-merge
       rule:

       o      A <b>- </b>specifies that the file should consist of only exclude
              patterns, with no other rule-parsing except for in-file
              comments.

       o      A <b>+ </b>specifies that the file should consist of only include
              patterns, with no other rule-parsing except for in-file
              comments.

       o      A <b>C </b>is a way to specify that the file should be read in a
              CVS-compatible manner.  This turns on 'n', 'w', and '-',
              but also allows the list-clearing token (!) to be
              specified.  If no filename is provided, ".cvsignore" is
              assumed.

       o      A <b>e </b>will exclude the merge-file name from the transfer;
              e.g.  "dir-merge,e .rules" is like "dir-merge .rules" and
              "- .rules".

       o      An <b>n </b>specifies that the rules are not inherited by
              subdirectories.

       o      A <b>w </b>specifies that the rules are word-split on whitespace
              instead of the normal line-splitting.  This also turns off
              comments.  Note: the space that separates the prefix from
              the rule is treated specially, so "- foo + bar" is parsed
              as two rules (assuming that prefix-parsing wasn't also
              disabled).

       o      You may also specify any of the modifiers for the "+" or
              "-" rules (above) in order to have the rules that are read
              in from the file default to having that modifier set
              (except for the <b>! </b>modifier, which would not be useful).
              For instance, "merge,-/ .excl" would treat the contents of
              .excl as absolute-path excludes, while "dir-merge,s .filt"
              and ":sC" would each make all their per-directory rules
              apply only on the sending side.  If the merge rule
              specifies sides to affect (via the <b>s </b>or <b>r </b>modifier or
              both), then the rules in the file must not specify sides
              (via a modifier or a rule prefix such as <b>hide</b>).

       Per-directory rules are inherited in all subdirectories of the
       directory where the merge-file was found unless the 'n' modifier
       was used.  Each subdirectory's rules are prefixed to the
       inherited per-directory rules from its parents, which gives the
       newest rules a higher priority than the inherited rules.  The
       entire set of dir-merge rules are grouped together in the spot
       where the merge-file was specified, so it is possible to override
       dir-merge rules via a rule that got specified earlier in the list
       of global rules.  When the list-clearing rule ("!") is read from
       a per-directory file, it only clears the inherited rules for the
       current merge file.

       Another way to prevent a single rule from a dir-merge file from
       being inherited is to anchor it with a leading slash.  Anchored
       rules in a per-directory merge-file are relative to the merge-
       file's directory, so a pattern "/foo" would only match the file
       "foo" in the directory where the dir-merge filter file was found.

       Here's an example filter file which you'd specify via
       <b>--filter=". file":</b>

           merge /home/user/.global-filter
           - *.gz
           dir-merge .rules
           + *.[ch]
           - *.o
           - foo*

       This will merge the contents of the /home/user/.global-filter
       file at the start of the list and also turns the ".rules"
       filename into a per-directory filter file.  All rules read in
       prior to the start of the directory scan follow the global
       anchoring rules (i.e. a leading slash matches at the root of the
       transfer).

       If a per-directory merge-file is specified with a path that is a
       parent directory of the first transfer directory, rsync will scan
       all the parent dirs from that starting point to the transfer
       directory for the indicated per-directory file.  For instance,
       here is a common filter (see <b>-F</b>):

           --filter=': /.rsync-filter'

       That rule tells rsync to scan for the file .rsync-filter in all
       directories from the root down through the parent directory of
       the transfer prior to the start of the normal directory scan of
       the file in the directories that are sent as a part of the
       transfer. (Note: for an rsync daemon, the root is always the same
       as the module's "path".)

       Some examples of this pre-scanning for per-directory files:

           rsync -avF /src/path/ /dest/dir
           rsync -av --filter=': ../../.rsync-filter' /src/path/ /dest/dir
           rsync -av --filter=': .rsync-filter' /src/path/ /dest/dir

       The first two commands above will look for ".rsync-filter" in "/"
       and "/src" before the normal scan begins looking for the file in
       "/src/path" and its subdirectories.  The last command avoids the
       parent-dir scan and only looks for the ".rsync-filter" files in
       each directory that is a part of the transfer.

       If you want to include the contents of a ".cvsignore" in your
       patterns, you should use the rule ":C", which creates a dir-merge
       of the .cvsignore file, but parsed in a CVS-compatible manner.
       You can use this to affect where the <b>--cvs-exclude </b>(<b>-C</b>) option's
       inclusion of the per-directory .cvsignore file gets placed into
       your rules by putting the ":C" wherever you like in your filter
       rules.  Without this, rsync would add the dir-merge rule for the
       .cvsignore file at the end of all your other rules (giving it a
       lower priority than your command-line rules).  For example:

           cat &lt;&lt;EOT | rsync -avC --filter='. -' a/ b
           + foo.o
           :C
           - *.old
           EOT
           rsync -avC --include=foo.o -f :C --exclude='*.old' a/ b

       Both of the above rsync commands are identical.  Each one will
       merge all the per-directory .cvsignore rules in the middle of the
       list rather than at the end.  This allows their dir-specific
       rules to supersede the rules that follow the :C instead of being
       subservient to all your rules.  To affect the other CVS exclude
       rules (i.e. the default list of exclusions, the contents of
       $HOME/.cvsignore, and the value of $CVSIGNORE) you should omit
       the <b>-C </b>command-line option and instead insert a "-C" rule into
       your filter rules; e.g.  "<b>--filter=-C</b>".

   <b>LIST-CLEARING FILTER RULE</b>
       You can clear the current include/exclude list by using the "!"
       filter rule (as introduced in the FILTER RULES section above).
       The "current" list is either the global list of rules (if the
       rule is encountered while parsing the filter options) or a set of
       per-directory rules (which are inherited in their own sub-list,
       so a subdirectory can use this to clear out the parent's rules).

   <b>ANCHORING INCLUDE/EXCLUDE PATTERNS</b>
       As mentioned earlier, global include/exclude patterns are
       anchored at the "root of the transfer" (as opposed to per-
       directory patterns, which are anchored at the merge-file's
       directory).  If you think of the transfer as a subtree of names
       that are being sent from sender to receiver, the transfer-root is
       where the tree starts to be duplicated in the destination
       directory.  This root governs where patterns that start with a /
       match.

       Because the matching is relative to the transfer-root, changing
       the trailing slash on a source path or changing your use of the
       <b>--relative </b>option affects the path you need to use in your
       matching (in addition to changing how much of the file tree is
       duplicated on the destination host).  The following examples
       demonstrate this.

       Let's say that we want to match two source files, one with an
       absolute path of "/home/me/foo/bar", and one with a path of
       "/home/you/bar/baz".  Here is how the various command choices
       differ for a 2-source transfer:

           Example cmd: rsync -a /home/me /home/you /dest
           +/- pattern: /me/foo/bar
           +/- pattern: /you/bar/baz
           Target file: /dest/me/foo/bar
           Target file: /dest/you/bar/baz

           Example cmd: rsync -a /home/me/ /home/you/ /dest
           +/- pattern: /foo/bar               (note missing "me")
           +/- pattern: /bar/baz               (note missing "you")
           Target file: /dest/foo/bar
           Target file: /dest/bar/baz

           Example cmd: rsync -a --relative /home/me/ /home/you /dest
           +/- pattern: /home/me/foo/bar       (note full path)
           +/- pattern: /home/you/bar/baz      (ditto)
           Target file: /dest/home/me/foo/bar
           Target file: /dest/home/you/bar/baz

           Example cmd: cd /home; rsync -a --relative me/foo you/ /dest
           +/- pattern: /me/foo/bar      (starts at specified path)
           +/- pattern: /you/bar/baz     (ditto)
           Target file: /dest/me/foo/bar
           Target file: /dest/you/bar/baz

       The easiest way to see what name you should filter is to just
       look at the output when using <b>--verbose </b>and put a / in front of
       the name (use the <b>--dry-run </b>option if you're not yet ready to
       copy any files).

   <b>PER-DIRECTORY RULES AND DELETE</b>
       Without a delete option, per-directory rules are only relevant on
       the sending side, so you can feel free to exclude the merge files
       themselves without affecting the transfer.  To make this easy,
       the 'e' modifier adds this exclude for you, as seen in these two
       equivalent commands:

           rsync -av --filter=': .excl' --exclude=.excl host:src/dir /dest
           rsync -av --filter=':e .excl' host:src/dir /dest

       However, if you want to do a delete on the receiving side AND you
       want some files to be excluded from being deleted, you'll need to
       be sure that the receiving side knows what files to exclude.  The
       easiest way is to include the per-directory merge files in the
       transfer and use <b>--delete-after</b>, because this ensures that the
       receiving side gets all the same exclude rules as the sending
       side before it tries to delete anything:

           rsync -avF --delete-after host:src/dir /dest

       However, if the merge files are not a part of the transfer,
       you'll need to either specify some global exclude rules (i.e.
       specified on the command line), or you'll need to maintain your
       own per-directory merge files on the receiving side.  An example
       of the first is this (assume that the remote .rules files exclude
       themselves):

           rsync -av --filter=': .rules' --filter='. /my/extra.rules'
              --delete host:src/dir /dest

       In the above example the extra.rules file can affect both sides
       of the transfer, but (on the sending side) the rules are
       subservient to the rules merged from the .rules files because
       they were specified after the per-directory merge rule.

       In one final example, the remote side is excluding the .rsync-
       filter files from the transfer, but we want to use our own
       .rsync-filter files to control what gets deleted on the receiving
       side.  To do this we must specifically exclude the per-directory
       merge files (so that they don't get deleted) and then put rules
       into the local files to control what else should not get deleted.
       Like one of these commands:

           rsync -av --filter=':e /.rsync-filter' --delete \
               host:src/dir /dest
           rsync -avFF --delete host:src/dir /dest
</pre> <h2>
TRANSFER RULES </h2>
<pre>
       In addition to the FILTER RULES that affect the recursive file
       scans that generate the file list on the sending and (when
       deleting) receiving sides, there are transfer rules. These rules
       affect which files the generator decides need to be transferred
       without the side effects of an exclude filter rule.  Transfer
       rules affect only files and never directories.

       Because a transfer rule does not affect what goes into the
       sender's (and receiver's) file list, it cannot have any effect on
       which files get deleted on the receiving side.  For example, if
       the file "foo" is present in the sender's list but its size is
       such that it is omitted due to a transfer rule, the receiving
       side does not request the file.  However, its presence in the
       file list means that a delete pass will not remove a matching
       file named "foo" on the receiving side.  On the other hand, a
       server-side exclude (hide) of the file "foo" leaves the file out
       of the server's file list, and absent a receiver-side exclude
       (protect) the receiver will remove a matching file named "foo" if
       deletions are requested.

       Given that the files are still in the sender's file list, the
       <b>--prune-empty-dirs </b>option will not judge a directory as being
       empty even if it contains only files that the transfer rules
       omitted.

       Similarly, a transfer rule does not have any extra effect on
       which files are deleted on the receiving side, so setting a
       maximum file size for the transfer does not prevent big files
       from being deleted.

       Examples of transfer rules include the default "quick check"
       algorithm (which compares size &amp; modify time), the <b>--update</b>
       option, the <b>--max-size </b>option, the <b>--ignore-non-existing </b>option,
       and a few others.
</pre> <h2>
BATCH MODE </h2>
<pre>
       Batch mode can be used to apply the same set of updates to many
       identical systems.  Suppose one has a tree which is replicated on
       a number of hosts.  Now suppose some changes have been made to
       this source tree and those changes need to be propagated to the
       other hosts.  In order to do this using batch mode, rsync is run
       with the write-batch option to apply the changes made to the
       source tree to one of the destination trees.  The write-batch
       option causes the rsync client to store in a "batch file" all the
       information needed to repeat this operation against other,
       identical destination trees.

       Generating the batch file once saves having to perform the file
       status, checksum, and data block generation more than once when
       updating multiple destination trees.  Multicast transport
       protocols can be used to transfer the batch update files in
       parallel to many hosts at once, instead of sending the same data
       to every host individually.

       To apply the recorded changes to another destination tree, run
       rsync with the read-batch option, specifying the name of the same
       batch file, and the destination tree.  Rsync updates the
       destination tree using the information stored in the batch file.

       For your convenience, a script file is also created when the
       write-batch option is used: it will be named the same as the
       batch file with ".sh" appended.  This script file contains a
       command-line suitable for updating a destination tree using the
       associated batch file.  It can be executed using a Bourne (or
       Bourne-like) shell, optionally passing in an alternate
       destination tree pathname which is then used instead of the
       original destination path.  This is useful when the destination
       tree path on the current host differs from the one used to create
       the batch file.

       Examples:

           $ rsync --write-batch=foo -a host:/source/dir/ /adest/dir/
           $ scp foo* remote:
           $ ssh remote ./foo.sh /bdest/dir/

           $ rsync --write-batch=foo -a /source/dir/ /adest/dir/
           $ ssh remote rsync --read-batch=- -a /bdest/dir/ &lt;foo

       In these examples, rsync is used to update /adest/dir/ from
       /source/dir/ and the information to repeat this operation is
       stored in "foo" and "foo.sh".  The host "remote" is then updated
       with the batched data going into the directory /bdest/dir.  The
       differences between the two examples reveals some of the
       flexibility you have in how you deal with batches:

       o      The first example shows that the initial copy doesn't have
              to be local -- you can push or pull data to/from a remote
              host using either the remote-shell syntax or rsync daemon
              syntax, as desired.

       o      The first example uses the created "foo.sh" file to get
              the right rsync options when running the read-batch
              command on the remote host.

       o      The second example reads the batch data via standard input
              so that the batch file doesn't need to be copied to the
              remote machine first.  This example avoids the foo.sh
              script because it needed to use a modified <b>--read-batch</b>
              option, but you could edit the script file if you wished
              to make use of it (just be sure that no other option is
              trying to use standard input, such as the <b>--exclude-from=-</b>
              option).

       Caveats:

       The read-batch option expects the destination tree that it is
       updating to be identical to the destination tree that was used to
       create the batch update fileset.  When a difference between the
       destination trees is encountered the update might be discarded
       with a warning (if the file appears to be up-to-date already) or
       the file-update may be attempted and then, if the file fails to
       verify, the update discarded with an error.  This means that it
       should be safe to re-run a read-batch operation if the command
       got interrupted.  If you wish to force the batched-update to
       always be attempted regardless of the file's size and date, use
       the <b>-I </b>option (when reading the batch).  If an error occurs, the
       destination tree will probably be in a partially updated state.
       In that case, rsync can be used in its regular (non-batch) mode
       of operation to fix up the destination tree.

       The rsync version used on all destinations must be at least as
       new as the one used to generate the batch file.  Rsync will die
       with an error if the protocol version in the batch file is too
       new for the batch-reading rsync to handle.  See also the
       <b>--protocol </b>option for a way to have the creating rsync generate a
       batch file that an older rsync can understand.  (Note that batch
       files changed format in version 2.6.3, so mixing versions older
       than that with newer versions will not work.)

       When reading a batch file, rsync will force the value of certain
       options to match the data in the batch file if you didn't set
       them to the same as the batch-writing command.  Other options can
       (and should) be changed.  For instance <b>--write-batch </b>changes to
       <b>--read-batch</b>, <b>--files-from </b>is dropped, and the <b>--filter </b>/
       <b>--include </b>/ <b>--exclude </b>options are not needed unless one of the
       <b>--delete </b>options is specified.

       The code that creates the BATCH.sh file transforms any
       filter/include/exclude options into a single list that is
       appended as a "here" document to the shell script file.  An
       advanced user can use this to modify the exclude list if a change
       in what gets deleted by <b>--delete </b>is desired.  A normal user can
       ignore this detail and just use the shell script as an easy way
       to run the appropriate <b>--read-batch </b>command for the batched data.

       The original batch mode in rsync was based on "rsync+", but the
       latest version uses a new implementation.
</pre> <h2>
SYMBOLIC LINKS </h2>
<pre>
       Three basic behaviors are possible when rsync encounters a
       symbolic link in the source directory.

       By default, symbolic links are not transferred at all.  A message
       "skipping non-regular" file is emitted for any symlinks that
       exist.

       If <b>--links </b>is specified, then symlinks are added to the transfer
       (instead of being noisily ignored), and the default handling is
       to recreate them with the same target on the destination.  Note
       that <b>--archive </b>implies <b>--links</b>.

       If <b>--copy-links </b>is specified, then symlinks are "collapsed" by
       copying their referent, rather than the symlink.

       Rsync can also distinguish "safe" and "unsafe" symbolic links.
       An example where this might be used is a web site mirror that
       wishes to ensure that the rsync module that is copied does not
       include symbolic links to <b>/etc/passwd </b>in the public section of
       the site.  Using <b>--copy-unsafe-links </b>will cause any links to be
       copied as the file they point to on the destination.  Using
       <b>--safe-links </b>will cause unsafe links to be omitted by the
       receiver.  (Note that you must specify or imply <b>--links </b>for
       <b>--safe-links </b>to have any effect.)

       Symbolic links are considered unsafe if they are absolute
       symlinks (start with <b>/</b>), empty, or if they contain enough ".."
       components to ascend from the top of the transfer.

       Here's a summary of how the symlink options are interpreted.  The
       list is in order of precedence, so if your combination of options
       isn't mentioned, use the first line that is a complete subset of
       your options:

       <b>--copy-links</b>
              Turn all symlinks into normal files and directories
              (leaving no symlinks in the transfer for any other options
              to affect).

       <b>--copy-dirlinks</b>
              Turn just symlinks to directories into real directories,
              leaving all other symlinks to be handled as described
              below.

       <b>--links --copy-unsafe-links</b>
              Turn all unsafe symlinks into files and create all safe
              symlinks.

       <b>--copy-unsafe-links</b>
              Turn all unsafe symlinks into files, noisily skip all safe
              symlinks.

       <b>--links --safe-links</b>
              The receiver skips creating unsafe symlinks found in the
              transfer and creates the safe ones.

       <b>--links</b>
              Create all symlinks.

       For the effect of <b>--munge-links</b>, see the discussion in that
       option's section.

       Note that the <b>--keep-dirlinks </b>option does not effect symlinks in
       the transfer but instead affects how rsync treats a symlink to a
       directory that already exists on the receiving side.  See that
       option's section for a warning.
</pre> <h2>
DIAGNOSTICS </h2>
<pre>
       Rsync occasionally produces error messages that may seem a little
       cryptic.  The one that seems to cause the most confusion is
       "protocol version mismatch -- is your shell clean?".

       This message is usually caused by your startup scripts or remote
       shell facility producing unwanted garbage on the stream that
       rsync is using for its transport.  The way to diagnose this
       problem is to run your remote shell like this:

           ssh remotehost /bin/true &gt; out.dat

       then look at out.dat.  If everything is working correctly then
       out.dat should be a zero length file.  If you are getting the
       above error from rsync then you will probably find that out.dat
       contains some text or data.  Look at the contents and try to work
       out what is producing it.  The most common cause is incorrectly
       configured shell startup scripts (such as .cshrc or .profile)
       that contain output statements for non-interactive logins.

       If you are having trouble debugging filter patterns, then try
       specifying the <b>-vv </b>option.  At this level of verbosity rsync will
       show why each individual file is included or excluded.
</pre> <h2>
EXIT VALUES </h2>
<pre>
       o      <b>0 </b>- Success

       o      <b>1 </b>- Syntax or usage error

       o      <b>2 </b>- Protocol incompatibility

       o      <b>3 </b>- Errors selecting input/output files, dirs

       o

              o      <b>4 </b>- Requested action not supported. Either:

                     an attempt was made to manipulate 64-bit files on a
                     platform that cannot support them

              o      an option was specified that is supported by the
                     client and not by the server

       o      <b>5 </b>- Error starting client-server protocol

       o      <b>6 </b>- Daemon unable to append to log-file

       o      <b>10 </b>- Error in socket I/O

       o      <b>11 </b>- Error in file I/O

       o      <b>12 </b>- Error in rsync protocol data stream

       o      <b>13 </b>- Errors with program diagnostics

       o      <b>14 </b>- Error in IPC code

       o      <b>20 </b>- Received SIGUSR1 or SIGINT

       o      <b>21 </b>- Some error returned by <b>waitpid()</b>

       o      <b>22 </b>- Error allocating core memory buffers

       o      <b>23 </b>- Partial transfer due to error

       o      <b>24 </b>- Partial transfer due to vanished source files

       o      <b>25 </b>- The --max-delete limit stopped deletions

       o      <b>30 </b>- Timeout in data send/receive

       o      <b>35 </b>- Timeout waiting for daemon connection
</pre> <h2>
ENVIRONMENT VARIABLES </h2>
<pre>
       <b>CVSIGNORE</b>
              The CVSIGNORE environment variable supplements any ignore
              patterns in .cvsignore files.  See the <b>--cvs-exclude</b>
              option for more details.

       <b>RSYNC_ICONV</b>
              Specify a default <b>--iconv </b>setting using this environment
              variable. First supported in 3.0.0.

       <b>RSYNC_OLD_ARGS</b>
              Specify a "1" if you want the <b>--old-args </b>option to be
              enabled by default, a "2" (or more) if you want it to be
              enabled in the repeated-option state, or a "0" to make
              sure that it is disabled by default. When this environment
              variable is set to a non-zero value, it supersedes the
              <b>RSYNC_PROTECT_ARGS </b>variable.

              This variable is ignored if <b>--old-args</b>, <b>--no-old-args</b>, or
              <b>--secluded-args </b>is specified on the command line.

              First supported in 3.2.4.

       <b>RSYNC_PROTECT_ARGS</b>
              Specify a non-zero numeric value if you want the
              <b>--secluded-args </b>option to be enabled by default, or a zero
              value to make sure that it is disabled by default.

              This variable is ignored if <b>--secluded-args</b>, <b>--no-</b>
              <b>secluded-args</b>, or <b>--old-args </b>is specified on the command
              line.

              First supported in 3.1.0.  Starting in 3.2.4, this
              variable is ignored if <b>RSYNC_OLD_ARGS </b>is set to a non-zero
              value.

       <b>RSYNC_RSH</b>
              This environment variable allows you to override the
              default shell used as the transport for rsync.  Command
              line options are permitted after the command name, just as
              in the <b>--rsh </b>(<b>-e</b>) option.

       <b>RSYNC_PROXY</b>
              This environment variable allows you to redirect your
              rsync client to use a web proxy when connecting to an
              rsync daemon.  You should set <b>RSYNC_PROXY </b>to a
              hostname:port pair.

       <b>RSYNC_PASSWORD</b>
              This environment variable allows you to set the password
              for an rsync <b>daemon </b>connection, which avoids the password
              prompt.  Note that this does <b>not </b>supply a password to a
              remote shell transport such as ssh (consult its
              documentation for how to do that).

       <b>USER </b>or <b>LOGNAME</b>
              The USER or LOGNAME environment variables are used to
              determine the default username sent to an rsync daemon.
              If neither is set, the username defaults to "nobody".  If
              both are set, <b>USER </b>takes precedence.

       <b>RSYNC_PARTIAL_DIR</b>
              This environment variable specifies the directory to use
              for a <b>--partial </b>transfer without implying that partial
              transfers be enabled.  See the <b>--partial-dir </b>option for
              full details.

       <b>RSYNC_COMPRESS_LIST</b>
              This environment variable allows you to customize the
              negotiation of the compression algorithm by specifying an
              alternate order or a reduced list of names.  Use the
              command <b>rsync --version </b>to see the available compression
              names.  See the <b>--compress </b>option for full details.

       <b>RSYNC_CHECKSUM_LIST</b>
              This environment variable allows you to customize the
              negotiation of the checksum algorithm by specifying an
              alternate order or a reduced list of names.  Use the
              command <b>rsync --version </b>to see the available checksum
              names.  See the <b>--checksum-choice </b>option for full details.

       <b>RSYNC_MAX_ALLOC</b>
              This environment variable sets an allocation maximum as if
              you had used the <b>--max-alloc </b>option.

       <b>RSYNC_PORT</b>
              This environment variable is not read by rsync, but is
              instead set in its sub-environment when rsync is running
              the remote shell in combination with a daemon connection.
              This allows a script such as <b>rsync-ssl </b>to be able to know
              the port number that the user specified on the command
              line.

       <b>HOME   </b>This environment variable is used to find the user's
              default .cvsignore file.

       <b>RSYNC_CONNECT_PROG</b>
              This environment variable is mainly used in debug setups
              to set the program to use when making a daemon connection.
              See CONNECTING TO AN RSYNC DAEMON for full details.

       <b>RSYNC_SHELL</b>
              This environment variable is mainly used in debug setups
              to set the program to use to run the program specified by
              <b>RSYNC_CONNECT_PROG</b>.  See CONNECTING TO AN RSYNC DAEMON for
              full details.
</pre> <h2>
FILES </h2>
<pre>
       /etc/rsyncd.conf or rsyncd.conf
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="rsync-ssl.1.html">rsync-ssl(1)</a>, <a href="../man5/rsyncd.conf.5.html">rsyncd.conf(5)</a>, <a href="rrsync.1.html">rrsync(1)</a>
</pre> <h2>
BUGS </h2>
<pre>
       o      Times are transferred as *nix time_t values.

       o      When transferring to FAT filesystems rsync may re-sync
              unmodified files.  See the comments on the <b>--modify-window</b>
              option.

       o      File permissions, devices, etc. are transferred as native
              numerical values.

       o      See also the comments on the <b>--delete </b>option.

       Please report bugs! See the web site at 
       ⟨<a href="https://rsync.samba.org/">https://rsync.samba.org/</a>⟩.
</pre> <h2>
VERSION </h2>
<pre>
       This manpage is current for version 3.3.0 of rsync.
</pre> <h2>
INTERNAL OPTIONS </h2>
<pre>
       The options <b>--server </b>and <b>--sender </b>are used internally by rsync,
       and should never be typed by a user under normal circumstances.
       Some awareness of these options may be needed in certain
       scenarios, such as when setting up a login that can only run an
       rsync command.  For instance, the support directory of the rsync
       distribution has an example script named rrsync (for restricted
       rsync) that can be used with a restricted ssh login.
</pre> <h2>
CREDITS </h2>
<pre>
       Rsync is distributed under the GNU General Public License.  See
       the file COPYING for details.

       An rsync web site is available at ⟨<a href="https://rsync.samba.org/">https://rsync.samba.org/</a>⟩.
       The site includes an FAQ-O-Matic which may cover questions
       unanswered by this manual page.

       The rsync github project is ⟨<a href="https://github.com/WayneD/rsync">https://github.com/WayneD/rsync</a>⟩.

       We would be delighted to hear from you if you like this program.
       Please contact the mailing-list at rsync@lists.samba.org
       ⟨mailto:rsync@lists.samba.org⟩.

       This program uses the excellent zlib compression library written
       by Jean-loup Gailly and Mark Adler.
</pre> <h2>
THANKS </h2>
<pre>
       Special thanks go out to: John Van Essen, Matt McCutchen, Wesley
       W. Terpstra, David Dykstra, Jos Backus, Sebastian Krahmer, Martin
       Pool, and our gone-but-not-forgotten compadre, J.W. Schultz.

       Thanks also to Richard Brent, Brendan Mackay, Bill Waite, Stephen
       Rothwell and David Bell.  I've probably missed some people, my
       apologies if I have.
</pre> <h2>
AUTHOR </h2>
<pre>
       Rsync was originally written by Andrew Tridgell and Paul
       Mackerras.  Many people have later contributed to it. It is
       currently maintained by Wayne Davison.

       Mailing lists for support and development are available at 
       ⟨<a href="https://lists.samba.org/">https://lists.samba.org/</a>⟩.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>rsync</i> (a fast, versatile, remote (and
       local) file-copying tool) project.  Information about the project
       can be found at ⟨<a href="https://rsync.samba.org/">https://rsync.samba.org/</a>⟩.  If you have a bug
       report for this manual page, see
       ⟨<a href="https://rsync.samba.org/bugzilla.html">https://rsync.samba.org/bugzilla.html</a>⟩.  This page was obtained
       from the tarball fetched from
       ⟨<a href="https://download.samba.org/pub/rsync/">https://download.samba.org/pub/rsync/</a>⟩ on 2024-06-14.  If you
       discover any rendering problems in this HTML version of the page,
       or you believe there is a better or more up-to-date source for
       the page, or you have corrections or improvements to the
       information in this COLOPHON (which is <i>not</i> part of the original
       manual page), send a mail to man-pages@man7.org

<span class="footline">rsync 3.3.0                    6 Apr 2024                       <i>rsync</i>(1)</span>
</pre>  <p>Pages that refer to this page: <a href="pmlogger_daily.1.html">pmlogger_daily(1)</a>, <a href="rrsync.1.html">rrsync(1)</a>, <a href="rsync-ssl.1.html">rsync-ssl(1)</a>, <a href="../man5/rsyncd.conf.5.html">rsyncd.conf(5)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man1/rsync.1.html" class="_attribution-link">https://man7.org/linux/man-pages/man1/rsync.1.html</a>
  </p>
</div>
