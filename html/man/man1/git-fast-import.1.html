<h1>git-fast-import(1) — Linux manual page</h1>   <pre>
<span class="headline"><i>GIT-FAST-IMPORT</i>(1)             Git Manual             <i>GIT-FAST-IMPORT</i>(1)</span>
</pre> <h2>
NAME </h2>
<pre>
       git-fast-import - Backend for fast Git data importers
</pre> <h2>
SYNOPSIS </h2>
<pre>
       frontend | <i>git fast-import</i> [&lt;options&gt;]
</pre> <h2>
DESCRIPTION </h2>
<pre>
       This program is usually not what the end user wants to run
       directly. Most end users want to use one of the existing frontend
       programs, which parses a specific type of foreign source and
       feeds the contents stored there to <i>git fast-import</i>.

       fast-import reads a mixed command/data stream from standard input
       and writes one or more packfiles directly into the current
       repository. When EOF is received on standard input, fast import
       writes out updated branch and tag refs, fully updating the
       current repository with the newly imported data.

       The fast-import backend itself can import into an empty
       repository (one that has already been initialized by <i>git init</i>) or
       incrementally update an existing populated repository. Whether or
       not incremental imports are supported from a particular foreign
       source depends on the frontend program in use.
</pre> <h2>
OPTIONS </h2>
<pre>
       --force
           Force updating modified existing branches, even if doing so
           would cause commits to be lost (as the new commit does not
           contain the old commit).

       --quiet
           Disable the output shown by --stats, making fast-import
           usually be silent when it is successful. However, if the
           import stream has directives intended to show user output
           (e.g.  <b>progress </b>directives), the corresponding messages will
           still be shown.

       --stats
           Display some basic statistics about the objects fast-import
           has created, the packfiles they were stored into, and the
           memory used by fast-import during this run. Showing this
           output is currently the default, but can be disabled with
           --quiet.

       --allow-unsafe-features
           Many command-line options can be provided as part of the
           fast-import stream itself by using the <b>feature </b>or <b>option</b>
           commands. However, some of these options are unsafe (e.g.,
           allowing fast-import to access the filesystem outside of the
           repository). These options are disabled by default, but can
           be allowed by providing this option on the command line. This
           currently impacts only the <b>export-marks</b>, <b>import-marks</b>, and
           <b>import-marks-if-exists </b>feature commands.

               Only enable this option if you trust the program generating the
               fast-import stream! This option is enabled automatically for
               remote-helpers that use the `import` capability, as they are
               already trusted to run their own code.

   <b>Options for Frontends</b>
       --cat-blob-fd=&lt;fd&gt;
           Write responses to <b>get-mark</b>, <b>cat-blob</b>, and <b>ls </b>queries to the
           file descriptor &lt;fd&gt; instead of <b>stdout</b>. Allows <b>progress</b>
           output intended for the end-user to be separated from other
           output.

       --date-format=&lt;fmt&gt;
           Specify the type of dates the frontend will supply to
           fast-import within <b>author</b>, <b>committer </b>and <b>tagger </b>commands. See
           “Date Formats” below for details about which formats are
           supported, and their syntax.

       --done
           Terminate with error if there is no <b>done </b>command at the end
           of the stream. This option might be useful for detecting
           errors that cause the frontend to terminate before it has
           started to write a stream.

   <b>Locations of Marks Files</b>
       --export-marks=&lt;file&gt;
           Dumps the internal marks table to &lt;file&gt; when complete. Marks
           are written one per line as <b>:markid SHA-1</b>. Frontends can use
           this file to validate imports after they have been completed,
           or to save the marks table across incremental runs. As &lt;file&gt;
           is only opened and truncated at checkpoint (or completion)
           the same path can also be safely given to --import-marks.

       --import-marks=&lt;file&gt;
           Before processing any input, load the marks specified in
           &lt;file&gt;. The input file must exist, must be readable, and must
           use the same format as produced by --export-marks. Multiple
           options may be supplied to import more than one set of marks.
           If a mark is defined to different values, the last file wins.

       --import-marks-if-exists=&lt;file&gt;
           Like --import-marks but instead of erroring out, silently
           skips the file if it does not exist.

       --[no-]relative-marks
           After specifying --relative-marks the paths specified with
           --import-marks= and --export-marks= are relative to an
           internal directory in the current repository. In
           git-fast-import this means that the paths are relative to the
           .git/info/fast-import directory. However, other importers may
           use a different location.

           Relative and non-relative marks may be combined by
           interweaving --(no-)-relative-marks with the
           --(import|export)-marks= options.

   <b>Submodule Rewriting</b>
       --rewrite-submodules-from=&lt;name&gt;:&lt;file&gt;,
       --rewrite-submodules-to=&lt;name&gt;:&lt;file&gt;
           Rewrite the object IDs for the submodule specified by &lt;name&gt;
           from the values used in the from &lt;file&gt; to those used in the
           to &lt;file&gt;. The from marks should have been created by <b>git</b>
           <b>fast-export</b>, and the to marks should have been created by <b>git</b>
           <b>fast-import </b>when importing that same submodule.

           &lt;name&gt; may be any arbitrary string not containing a colon
           character, but the same value must be used with both options
           when specifying corresponding marks. Multiple submodules may
           be specified with different values for &lt;name&gt;. It is an error
           not to use these options in corresponding pairs.

           These options are primarily useful when converting a
           repository from one hash algorithm to another; without them,
           fast-import will fail if it encounters a submodule because it
           has no way of writing the object ID into the new hash
           algorithm.

   <b>Performance and Compression Tuning</b>
       --active-branches=&lt;n&gt;
           Maximum number of branches to maintain active at once. See
           “Memory Utilization” below for details. Default is 5.

       --big-file-threshold=&lt;n&gt;
           Maximum size of a blob that fast-import will attempt to
           create a delta for, expressed in bytes. The default is 512m
           (512 MiB). Some importers may wish to lower this on systems
           with constrained memory.

       --depth=&lt;n&gt;
           Maximum delta depth, for blob and tree deltification. Default
           is 50.

       --export-pack-edges=&lt;file&gt;
           After creating a packfile, print a line of data to &lt;file&gt;
           listing the filename of the packfile and the last commit on
           each branch that was written to that packfile. This
           information may be useful after importing projects whose
           total object set exceeds the 4 GiB packfile limit, as these
           commits can be used as edge points during calls to <i>git</i>
           <i>pack-objects</i>.

       --max-pack-size=&lt;n&gt;
           Maximum size of each output packfile. The default is
           unlimited.

       fastimport.unpackLimit
           See <a href="git-config.1.html">git-config(1)</a>
</pre> <h2>
PERFORMANCE </h2>
<pre>
       The design of fast-import allows it to import large projects in a
       minimum amount of memory usage and processing time. Assuming the
       frontend is able to keep up with fast-import and feed it a
       constant stream of data, import times for projects holding 10+
       years of history and containing 100,000+ individual commits are
       generally completed in just 1-2 hours on quite modest (~$2,000
       USD) hardware.

       Most bottlenecks appear to be in foreign source data access (the
       source just cannot extract revisions fast enough) or disk IO
       (fast-import writes as fast as the disk will take the data).
       Imports will run faster if the source data is stored on a
       different drive than the destination Git repository (due to less
       IO contention).
</pre> <h2>
DEVELOPMENT COST </h2>
<pre>
       A typical frontend for fast-import tends to weigh in at
       approximately 200 lines of Perl/Python/Ruby code. Most developers
       have been able to create working importers in just a couple of
       hours, even though it is their first exposure to fast-import, and
       sometimes even to Git. This is an ideal situation, given that
       most conversion tools are throw-away (use once, and never look
       back).
</pre> <h2>
PARALLEL OPERATION </h2>
<pre>
       Like <i>git push</i> or <i>git fetch</i>, imports handled by fast-import are
       safe to run alongside parallel <b>git repack -a -d </b>or <b>git gc</b>
       invocations, or any other Git operation (including <i>git prune</i>, as
       loose objects are never used by fast-import).

       fast-import does not lock the branch or tag refs it is actively
       importing. After the import, during its ref update phase,
       fast-import tests each existing branch ref to verify the update
       will be a fast-forward update (the commit stored in the ref is
       contained in the new history of the commit to be written). If the
       update is not a fast-forward update, fast-import will skip
       updating that ref and instead prints a warning message.
       fast-import will always attempt to update all branch refs, and
       does not stop on the first failure.

       Branch updates can be forced with --force, but it’s recommended
       that this only be used on an otherwise quiet repository. Using
       --force is not necessary for an initial import into an empty
       repository.
</pre> <h2>
TECHNICAL DISCUSSION </h2>
<pre>
       fast-import tracks a set of branches in memory. Any branch can be
       created or modified at any point during the import process by
       sending a <b>commit </b>command on the input stream. This design allows
       a frontend program to process an unlimited number of branches
       simultaneously, generating commits in the order they are
       available from the source data. It also simplifies the frontend
       programs considerably.

       fast-import does not use or alter the current working directory,
       or any file within it. (It does however update the current Git
       repository, as referenced by <b>GIT_DIR</b>.) Therefore an import
       frontend may use the working directory for its own purposes, such
       as extracting file revisions from the foreign source. This
       ignorance of the working directory also allows fast-import to run
       very quickly, as it does not need to perform any costly file
       update operations when switching between branches.
</pre> <h2>
INPUT FORMAT </h2>
<pre>
       With the exception of raw file data (which Git does not
       interpret) the fast-import input format is text (ASCII) based.
       This text based format simplifies development and debugging of
       frontend programs, especially when a higher level language such
       as Perl, Python or Ruby is being used.

       fast-import is very strict about its input. Where we say SP below
       we mean <b>exactly </b>one space. Likewise LF means one (and only one)
       linefeed and HT one (and only one) horizontal tab. Supplying
       additional whitespace characters will cause unexpected results,
       such as branch names or file names with leading or trailing
       spaces in their name, or early termination of fast-import when it
       encounters unexpected input.

   <b>Stream Comments</b>
       To aid in debugging frontends fast-import ignores any line that
       begins with <b># </b>(ASCII pound/hash) up to and including the line
       ending <b>LF</b>. A comment line may contain any sequence of bytes that
       does not contain an LF and therefore may be used to include any
       detailed debugging information that might be specific to the
       frontend and useful when inspecting a fast-import data stream.

   <b>Date Formats</b>
       The following date formats are supported. A frontend should
       select the format it will use for this import by passing the
       format name in the --date-format=&lt;fmt&gt; command-line option.

       <b>raw</b>
           This is the Git native format and is <b>&lt;time&gt; SP &lt;offutc&gt;</b>. It
           is also fast-import’s default format, if --date-format was
           not specified.

           The time of the event is specified by <b>&lt;time&gt; </b>as the number of
           seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC) and
           is written as an ASCII decimal integer.

           The local offset is specified by <b>&lt;offutc&gt; </b>as a positive or
           negative offset from UTC. For example EST (which is 5 hours
           behind UTC) would be expressed in <b>&lt;tz&gt; </b>by “-0500” while UTC
           is “+0000”. The local offset does not affect <b>&lt;time&gt;</b>; it is
           used only as an advisement to help formatting routines
           display the timestamp.

           If the local offset is not available in the source material,
           use “+0000”, or the most common local offset. For example
           many organizations have a CVS repository which has only ever
           been accessed by users who are located in the same location
           and time zone. In this case a reasonable offset from UTC
           could be assumed.

           Unlike the <b>rfc2822 </b>format, this format is very strict. Any
           variation in formatting will cause fast-import to reject the
           value, and some sanity checks on the numeric values may also
           be performed.

       <b>raw-permissive</b>
           This is the same as <b>raw </b>except that no sanity checks on the
           numeric epoch and local offset are performed. This can be
           useful when trying to filter or import an existing history
           with e.g. bogus timezone values.

       <b>rfc2822</b>
           This is the standard date format as described by RFC 2822.

           An example value is “Tue Feb 6 11:22:18 2007 -0500”. The Git
           parser is accurate, but a little on the lenient side. It is
           the same parser used by <i>git am</i> when applying patches received
           from email.

           Some malformed strings may be accepted as valid dates. In
           some of these cases Git will still be able to obtain the
           correct date from the malformed string. There are also some
           types of malformed strings which Git will parse wrong, and
           yet consider valid. Seriously malformed strings will be
           rejected.

           Unlike the <b>raw </b>format above, the time zone/UTC offset
           information contained in an RFC 2822 date string is used to
           adjust the date value to UTC prior to storage. Therefore it
           is important that this information be as accurate as
           possible.

           If the source material uses RFC 2822 style dates, the
           frontend should let fast-import handle the parsing and
           conversion (rather than attempting to do it itself) as the
           Git parser has been well tested in the wild.

           Frontends should prefer the <b>raw </b>format if the source material
           already uses UNIX-epoch format, can be coaxed to give dates
           in that format, or its format is easily convertible to it, as
           there is no ambiguity in parsing.

       <b>now</b>
           Always use the current time and time zone. The literal <b>now</b>
           must always be supplied for <b>&lt;when&gt;</b>.

           This is a toy format. The current time and time zone of this
           system is always copied into the identity string at the time
           it is being created by fast-import. There is no way to
           specify a different time or time zone.

           This particular format is supplied as it’s short to implement
           and may be useful to a process that wants to create a new
           commit right now, without needing to use a working directory
           or <i>git update-index</i>.

           If separate <b>author </b>and <b>committer </b>commands are used in a
           <b>commit </b>the timestamps may not match, as the system clock will
           be polled twice (once for each command). The only way to
           ensure that both author and committer identity information
           has the same timestamp is to omit <b>author </b>(thus copying from
           <b>committer</b>) or to use a date format other than <b>now</b>.

   <b>Commands</b>
       fast-import accepts several commands to update the current
       repository and control the current import process. More detailed
       discussion (with examples) of each command follows later.

       <b>commit</b>
           Creates a new branch or updates an existing branch by
           creating a new commit and updating the branch to point at the
           newly created commit.

       <b>tag</b>
           Creates an annotated tag object from an existing commit or
           branch. Lightweight tags are not supported by this command,
           as they are not recommended for recording meaningful points
           in time.

       <b>reset</b>
           Reset an existing branch (or a new branch) to a specific
           revision. This command must be used to change a branch to a
           specific revision without making a commit on it.

       <b>blob</b>
           Convert raw file data into a blob, for future use in a <b>commit</b>
           command. This command is optional and is not needed to
           perform an import.

       <b>alias</b>
           Record that a mark refers to a given object without first
           creating any new object. Using --import-marks and referring
           to missing marks will cause fast-import to fail, so aliases
           can provide a way to set otherwise pruned commits to a valid
           value (e.g. the nearest non-pruned ancestor).

       <b>checkpoint</b>
           Forces fast-import to close the current packfile, generate
           its unique SHA-1 checksum and index, and start a new
           packfile. This command is optional and is not needed to
           perform an import.

       <b>progress</b>
           Causes fast-import to echo the entire line to its own
           standard output. This command is optional and is not needed
           to perform an import.

       <b>done</b>
           Marks the end of the stream. This command is optional unless
           the <b>done </b>feature was requested using the <b>--done </b>command-line
           option or <b>feature done </b>command.

       <b>get-mark</b>
           Causes fast-import to print the SHA-1 corresponding to a mark
           to the file descriptor set with <b>--cat-blob-fd</b>, or <b>stdout </b>if
           unspecified.

       <b>cat-blob</b>
           Causes fast-import to print a blob in <i>cat-file --batch</i> format
           to the file descriptor set with <b>--cat-blob-fd </b>or <b>stdout </b>if
           unspecified.

       <b>ls</b>
           Causes fast-import to print a line describing a directory
           entry in <i>ls-tree</i> format to the file descriptor set with
           <b>--cat-blob-fd </b>or <b>stdout </b>if unspecified.

       <b>feature</b>
           Enable the specified feature. This requires that fast-import
           supports the specified feature, and aborts if it does not.

       <b>option</b>
           Specify any of the options listed under OPTIONS that do not
           change stream semantic to suit the frontend’s needs. This
           command is optional and is not needed to perform an import.

   <b>commit</b>
       Create or update a branch with a new commit, recording one
       logical change to the project.

                   'commit' SP &lt;ref&gt; LF
                   mark?
                   original-oid?
                   ('author' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF)?
                   'committer' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
                   ('encoding' SP &lt;encoding&gt;)?
                   data
                   ('from' SP &lt;commit-ish&gt; LF)?
                   ('merge' SP &lt;commit-ish&gt; LF)*
                   (filemodify | filedelete | filecopy | filerename | filedeleteall | notemodify)*
                   LF?

       where <b>&lt;ref&gt; </b>is the name of the branch to make the commit on.
       Typically branch names are prefixed with <b>refs/heads/ </b>in Git, so
       importing the CVS branch symbol <b>RELENG-1_0 </b>would use
       <b>refs/heads/RELENG-1_0 </b>for the value of <b>&lt;ref&gt;</b>. The value of <b>&lt;ref&gt;</b>
       must be a valid refname in Git. As <b>LF </b>is not valid in a Git
       refname, no quoting or escaping syntax is supported here.

       A <b>mark </b>command may optionally appear, requesting fast-import to
       save a reference to the newly created commit for future use by
       the frontend (see below for format). It is very common for
       frontends to mark every commit they create, thereby allowing
       future branch creation from any imported commit.

       The <b>data </b>command following <b>committer </b>must supply the commit
       message (see below for <b>data </b>command syntax). To import an empty
       commit message use a 0 length data. Commit messages are free-form
       and are not interpreted by Git. Currently they must be encoded in
       UTF-8, as fast-import does not permit other encodings to be
       specified.

       Zero or more <b>filemodify</b>, <b>filedelete</b>, <b>filecopy</b>, <b>filerename</b>,
       <b>filedeleteall </b>and <b>notemodify </b>commands may be included to update
       the contents of the branch prior to creating the commit. These
       commands may be supplied in any order. However it is recommended
       that a <b>filedeleteall </b>command precede all <b>filemodify</b>, <b>filecopy</b>,
       <b>filerename </b>and <b>notemodify </b>commands in the same commit, as
       <b>filedeleteall </b>wipes the branch clean (see below).

       The <b>LF </b>after the command is optional (it used to be required).
       Note that for reasons of backward compatibility, if the commit
       ends with a <b>data </b>command (i.e. it has no <b>from</b>, <b>merge</b>, <b>filemodify</b>,
       <b>filedelete</b>, <b>filecopy</b>, <b>filerename</b>, <b>filedeleteall </b>or <b>notemodify</b>
       commands) then two <b>LF </b>commands may appear at the end of the
       command instead of just one.

       <b>author</b>

           An <b>author </b>command may optionally appear, if the author
           information might differ from the committer information. If
           <b>author </b>is omitted then fast-import will automatically use the
           committer’s information for the author portion of the commit.
           See below for a description of the fields in <b>author</b>, as they
           are identical to <b>committer</b>.

       <b>committer</b>

           The <b>committer </b>command indicates who made this commit, and
           when they made it.

           Here <b>&lt;name&gt; </b>is the person’s display name (for example “Com M
           Itter”) and <b>&lt;email&gt; </b>is the person’s email address
           (“cm@example.com”). <b>LT </b>and <b>GT </b>are the literal less-than
           (\x3c) and greater-than (\x3e) symbols. These are required to
           delimit the email address from the other fields in the line.
           Note that <b>&lt;name&gt; </b>and <b>&lt;email&gt; </b>are free-form and may contain
           any sequence of bytes, except <b>LT</b>, <b>GT </b>and <b>LF</b>. <b>&lt;name&gt; </b>is
           typically UTF-8 encoded.

           The time of the change is specified by <b>&lt;when&gt; </b>using the date
           format that was selected by the --date-format=&lt;fmt&gt;
           command-line option. See “Date Formats” above for the set of
           supported formats, and their syntax.

       <b>encoding</b>

           The optional <b>encoding </b>command indicates the encoding of the
           commit message. Most commits are UTF-8 and the encoding is
           omitted, but this allows importing commit messages into git
           without first reencoding them.

       <b>from</b>

           The <b>from </b>command is used to specify the commit to initialize
           this branch from. This revision will be the first ancestor of
           the new commit. The state of the tree built at this commit
           will begin with the state at the <b>from </b>commit, and be altered
           by the content modifications in this commit.

           Omitting the <b>from </b>command in the first commit of a new branch
           will cause fast-import to create that commit with no
           ancestor. This tends to be desired only for the initial
           commit of a project. If the frontend creates all files from
           scratch when making a new branch, a <b>merge </b>command may be used
           instead of <b>from </b>to start the commit with an empty tree.
           Omitting the <b>from </b>command on existing branches is usually
           desired, as the current commit on that branch is
           automatically assumed to be the first ancestor of the new
           commit.

           As <b>LF </b>is not valid in a Git refname or SHA-1 expression, no
           quoting or escaping syntax is supported within <b>&lt;commit-ish&gt;</b>.

           Here <b>&lt;commit-ish&gt; </b>is any of the following:

           •   The name of an existing branch already in fast-import’s
               internal branch table. If fast-import doesn’t know the
               name, it’s treated as a SHA-1 expression.

           •   A mark reference, <b>:&lt;idnum&gt;</b>, where <b>&lt;idnum&gt; </b>is the mark
               number.

               The reason fast-import uses <b>: </b>to denote a mark reference
               is this character is not legal in a Git branch name. The
               leading <b>: </b>makes it easy to distinguish between the mark
               42 (<b>:42</b>) and the branch 42 (<b>42 </b>or <b>refs/heads/42</b>), or an
               abbreviated SHA-1 which happened to consist only of
               base-10 digits.

               Marks must be declared (via <b>mark</b>) before they can be
               used.

           •   A complete 40 byte or abbreviated commit SHA-1 in hex.

           •   Any valid Git SHA-1 expression that resolves to a commit.
               See “SPECIFYING REVISIONS” in <a href="../man7/gitrevisions.7.html">gitrevisions(7)</a> for
               details.

           •   The special null SHA-1 (40 zeros) specifies that the
               branch is to be removed.

           The special case of restarting an incremental import from the
           current branch value should be written as:

                       from refs/heads/branch^0

           The <b>^0 </b>suffix is necessary as fast-import does not permit a
           branch to start from itself, and the branch is created in
           memory before the <b>from </b>command is even read from the input.
           Adding <b>^0 </b>will force fast-import to resolve the commit
           through Git’s revision parsing library, rather than its
           internal branch table, thereby loading in the existing value
           of the branch.

       <b>merge</b>

           Includes one additional ancestor commit. The additional
           ancestry link does not change the way the tree state is built
           at this commit. If the <b>from </b>command is omitted when creating
           a new branch, the first <b>merge </b>commit will be the first
           ancestor of the current commit, and the branch will start out
           with no files. An unlimited number of <b>merge </b>commands per
           commit are permitted by fast-import, thereby establishing an
           n-way merge.

           Here <b>&lt;commit-ish&gt; </b>is any of the commit specification
           expressions also accepted by <b>from </b>(see above).

       <b>filemodify</b>

           Included in a <b>commit </b>command to add a new file or change the
           content of an existing file. This command has two different
           means of specifying the content of the file.

           External data format
               The data content for the file was already supplied by a
               prior <b>blob </b>command. The frontend just needs to connect
               it.

                           'M' SP &lt;mode&gt; SP &lt;dataref&gt; SP &lt;path&gt; LF

               Here usually <b>&lt;dataref&gt; </b>must be either a mark reference
               (<b>:&lt;idnum&gt;</b>) set by a prior <b>blob </b>command, or a full 40-byte
               SHA-1 of an existing Git blob object. If <b>&lt;mode&gt; </b>is
               <b>040000` </b>then <b>&lt;dataref&gt; </b>must be the full 40-byte SHA-1 of
               an existing Git tree object or a mark reference set with
               <b>--import-marks</b>.

           Inline data format
               The data content for the file has not been supplied yet.
               The frontend wants to supply it as part of this modify
               command.

                           'M' SP &lt;mode&gt; SP 'inline' SP &lt;path&gt; LF
                           data

               See below for a detailed description of the <b>data </b>command.

           In both formats <b>&lt;mode&gt; </b>is the type of file entry, specified
           in octal. Git only supports the following modes:

           •   <b>100644 </b>or <b>644</b>: A normal (not-executable) file. The
               majority of files in most projects use this mode. If in
               doubt, this is what you want.

           •   <b>100755 </b>or <b>755</b>: A normal, but executable, file.

           •   <b>120000</b>: A symlink, the content of the file will be the
               link target.

           •   <b>160000</b>: A gitlink, SHA-1 of the object refers to a commit
               in another repository. Git links can only be specified
               either by SHA or through a commit mark. They are used to
               implement submodules.

           •   <b>040000</b>: A subdirectory. Subdirectories can only be
               specified by SHA or through a tree mark set with
               <b>--import-marks</b>.

           In both formats <b>&lt;path&gt; </b>is the complete path of the file to be
           added (if not already existing) or modified (if already
           existing).

           A <b>&lt;path&gt; </b>can be written as unquoted bytes or a C-style quoted
           string.

           When a <b>&lt;path&gt; </b>does not start with a double quote (<b>"</b>), it is
           an unquoted string and is parsed as literal bytes without any
           escape sequences. However, if the filename contains <b>LF </b>or
           starts with double quote, it cannot be represented as an
           unquoted string and must be quoted. Additionally, the source
           <b>&lt;path&gt; </b>in <b>filecopy </b>or <b>filerename </b>must be quoted if it
           contains SP.

           When a <b>&lt;path&gt; </b>starts with a double quote (<b>"</b>), it is a C-style
           quoted string, where the complete filename is enclosed in a
           pair of double quotes and escape sequences are used. Certain
           characters must be escaped by preceding them with a
           backslash: <b>LF </b>is written as <b>\n</b>, backslash as <b>\\</b>, and double
           quote as <b>\"</b>. Some characters may optionally be written with
           escape sequences: <b>\a </b>for bell, <b>\b </b>for backspace, <b>\f </b>for form
           feed, <b>\n </b>for line feed, <b>\r </b>for carriage return, <b>\t </b>for
           horizontal tab, and <b>\v </b>for vertical tab. Any byte can be
           written with 3-digit octal codes (e.g., <b>\033</b>). All filenames
           can be represented as quoted strings.

           A <b>&lt;path&gt; </b>must use UNIX-style directory separators (forward
           slash <b>/</b>) and its value must be in canonical form. That is it
           must not:

           •   contain an empty directory component (e.g.  <b>foo//bar </b>is
               invalid),

           •   end with a directory separator (e.g.  <b>foo/ </b>is invalid),

           •   start with a directory separator (e.g.  <b>/foo </b>is invalid),

           •   contain the special component <b>.  </b>or <b>..  </b>(e.g.  <b>foo/./bar</b>
               and <b>foo/../bar </b>are invalid).

           The root of the tree can be represented by an empty string as
           <b>&lt;path&gt;</b>.

           <b>&lt;path&gt; </b>cannot contain NUL, either literally or escaped as
           <b>\000</b>. It is recommended that <b>&lt;path&gt; </b>always be encoded using
           UTF-8.

       <b>filedelete</b>

           Included in a <b>commit </b>command to remove a file or recursively
           delete an entire directory from the branch. If the file or
           directory removal makes its parent directory empty, the
           parent directory will be automatically removed too. This
           cascades up the tree until the first non-empty directory or
           the root is reached.

                       'D' SP &lt;path&gt; LF

           here <b>&lt;path&gt; </b>is the complete path of the file or subdirectory
           to be removed from the branch. See <b>filemodify </b>above for a
           detailed description of <b>&lt;path&gt;</b>.

       <b>filecopy</b>

           Recursively copies an existing file or subdirectory to a
           different location within the branch. The existing file or
           directory must exist. If the destination exists it will be
           completely replaced by the content copied from the source.

                       'C' SP &lt;path&gt; SP &lt;path&gt; LF

           here the first <b>&lt;path&gt; </b>is the source location and the second
           <b>&lt;path&gt; </b>is the destination. See <b>filemodify </b>above for a
           detailed description of what <b>&lt;path&gt; </b>may look like. To use a
           source path that contains SP the path must be quoted.

           A <b>filecopy </b>command takes effect immediately. Once the source
           location has been copied to the destination any future
           commands applied to the source location will not impact the
           destination of the copy.

       <b>filerename</b>

           Renames an existing file or subdirectory to a different
           location within the branch. The existing file or directory
           must exist. If the destination exists it will be replaced by
           the source directory.

                       'R' SP &lt;path&gt; SP &lt;path&gt; LF

           here the first <b>&lt;path&gt; </b>is the source location and the second
           <b>&lt;path&gt; </b>is the destination. See <b>filemodify </b>above for a
           detailed description of what <b>&lt;path&gt; </b>may look like. To use a
           source path that contains SP the path must be quoted.

           A <b>filerename </b>command takes effect immediately. Once the
           source location has been renamed to the destination any
           future commands applied to the source location will create
           new files there and not impact the destination of the rename.

           Note that a <b>filerename </b>is the same as a <b>filecopy </b>followed by
           a <b>filedelete </b>of the source location. There is a slight
           performance advantage to using <b>filerename</b>, but the advantage
           is so small that it is never worth trying to convert a
           delete/add pair in source material into a rename for
           fast-import. This <b>filerename </b>command is provided just to
           simplify frontends that already have rename information and
           don’t want bother with decomposing it into a <b>filecopy</b>
           followed by a <b>filedelete</b>.

       <b>filedeleteall</b>

           Included in a <b>commit </b>command to remove all files (and also
           all directories) from the branch. This command resets the
           internal branch structure to have no files in it, allowing
           the frontend to subsequently add all interesting files from
           scratch.

                       'deleteall' LF

           This command is extremely useful if the frontend does not
           know (or does not care to know) what files are currently on
           the branch, and therefore cannot generate the proper
           <b>filedelete </b>commands to update the content.

           Issuing a <b>filedeleteall </b>followed by the needed <b>filemodify</b>
           commands to set the correct content will produce the same
           results as sending only the needed <b>filemodify </b>and <b>filedelete</b>
           commands. The <b>filedeleteall </b>approach may however require
           fast-import to use slightly more memory per active branch
           (less than 1 MiB for even most large projects); so frontends
           that can easily obtain only the affected paths for a commit
           are encouraged to do so.

       <b>notemodify</b>

           Included in a <b>commit &lt;notes-ref&gt; </b>command to add a new note
           annotating a <b>&lt;commit-ish&gt; </b>or change this annotation contents.
           Internally it is similar to filemodify 100644 on <b>&lt;commit-ish&gt;</b>
           path (maybe split into subdirectories). It’s not advised to
           use any other commands to write to the <b>&lt;notes-ref&gt; </b>tree
           except <b>filedeleteall </b>to delete all existing notes in this
           tree. This command has two different means of specifying the
           content of the note.

           External data format
               The data content for the note was already supplied by a
               prior <b>blob </b>command. The frontend just needs to connect it
               to the commit that is to be annotated.

                           'N' SP &lt;dataref&gt; SP &lt;commit-ish&gt; LF

               Here <b>&lt;dataref&gt; </b>can be either a mark reference (<b>:&lt;idnum&gt;</b>)
               set by a prior <b>blob </b>command, or a full 40-byte SHA-1 of
               an existing Git blob object.

           Inline data format
               The data content for the note has not been supplied yet.
               The frontend wants to supply it as part of this modify
               command.

                           'N' SP 'inline' SP &lt;commit-ish&gt; LF
                           data

               See below for a detailed description of the <b>data </b>command.

           In both formats <b>&lt;commit-ish&gt; </b>is any of the commit
           specification expressions also accepted by <b>from </b>(see above).

   <b>mark</b>
       Arranges for fast-import to save a reference to the current
       object, allowing the frontend to recall this object at a future
       point in time, without knowing its SHA-1. Here the current object
       is the object creation command the <b>mark </b>command appears within.
       This can be <b>commit</b>, <b>tag</b>, and <b>blob</b>, but <b>commit </b>is the most common
       usage.

                   'mark' SP ':' &lt;idnum&gt; LF

       where <b>&lt;idnum&gt; </b>is the number assigned by the frontend to this
       mark. The value of <b>&lt;idnum&gt; </b>is expressed as an ASCII decimal
       integer. The value 0 is reserved and cannot be used as a mark.
       Only values greater than or equal to 1 may be used as marks.

       New marks are created automatically. Existing marks can be moved
       to another object simply by reusing the same <b>&lt;idnum&gt; </b>in another
       <b>mark </b>command.

   <b>original-oid</b>
       Provides the name of the object in the original source control
       system. fast-import will simply ignore this directive, but filter
       processes which operate on and modify the stream before feeding
       to fast-import may have uses for this information

                   'original-oid' SP &lt;object-identifier&gt; LF

       where <b>&lt;object-identifier&gt; </b>is any string not containing LF.

   <b>tag</b>
       Creates an annotated tag referring to a specific commit. To
       create lightweight (non-annotated) tags see the <b>reset </b>command
       below.

                   'tag' SP &lt;name&gt; LF
                   mark?
                   'from' SP &lt;commit-ish&gt; LF
                   original-oid?
                   'tagger' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
                   data

       where <b>&lt;name&gt; </b>is the name of the tag to create.

       Tag names are automatically prefixed with <b>refs/tags/ </b>when stored
       in Git, so importing the CVS branch symbol <b>RELENG-1_0-FINAL </b>would
       use just <b>RELENG-1_0-FINAL </b>for <b>&lt;name&gt;</b>, and fast-import will write
       the corresponding ref as <b>refs/tags/RELENG-1_0-FINAL</b>.

       The value of <b>&lt;name&gt; </b>must be a valid refname in Git and therefore
       may contain forward slashes. As <b>LF </b>is not valid in a Git refname,
       no quoting or escaping syntax is supported here.

       The <b>from </b>command is the same as in the <b>commit </b>command; see above
       for details.

       The <b>tagger </b>command uses the same format as <b>committer </b>within
       <b>commit</b>; again see above for details.

       The <b>data </b>command following <b>tagger </b>must supply the annotated tag
       message (see below for <b>data </b>command syntax). To import an empty
       tag message use a 0 length data. Tag messages are free-form and
       are not interpreted by Git. Currently they must be encoded in
       UTF-8, as fast-import does not permit other encodings to be
       specified.

       Signing annotated tags during import from within fast-import is
       not supported. Trying to include your own PGP/GPG signature is
       not recommended, as the frontend does not (easily) have access to
       the complete set of bytes which normally goes into such a
       signature. If signing is required, create lightweight tags from
       within fast-import with <b>reset</b>, then create the annotated versions
       of those tags offline with the standard <i>git tag</i> process.

   <b>reset</b>
       Creates (or recreates) the named branch, optionally starting from
       a specific revision. The reset command allows a frontend to issue
       a new <b>from </b>command for an existing branch, or to create a new
       branch from an existing commit without creating a new commit.

                   'reset' SP &lt;ref&gt; LF
                   ('from' SP &lt;commit-ish&gt; LF)?
                   LF?

       For a detailed description of <b>&lt;ref&gt; </b>and <b>&lt;commit-ish&gt; </b>see above
       under <b>commit </b>and <b>from</b>.

       The <b>LF </b>after the command is optional (it used to be required).

       The <b>reset </b>command can also be used to create lightweight
       (non-annotated) tags. For example:

           reset refs/tags/938
           from :938

       would create the lightweight tag <b>refs/tags/938 </b>referring to
       whatever commit mark <b>:938 </b>references.

   <b>blob</b>
       Requests writing one file revision to the packfile. The revision
       is not connected to any commit; this connection must be formed in
       a subsequent <b>commit </b>command by referencing the blob through an
       assigned mark.

                   'blob' LF
                   mark?
                   original-oid?
                   data

       The mark command is optional here as some frontends have chosen
       to generate the Git SHA-1 for the blob on their own, and feed
       that directly to <b>commit</b>. This is typically more work than it’s
       worth however, as marks are inexpensive to store and easy to use.

   <b>data</b>
       Supplies raw data (for use as blob/file content, commit messages,
       or annotated tag messages) to fast-import. Data can be supplied
       using an exact byte count or delimited with a terminating line.
       Real frontends intended for production-quality conversions should
       always use the exact byte count format, as it is more robust and
       performs better. The delimited format is intended primarily for
       testing fast-import.

       Comment lines appearing within the <b>&lt;raw&gt; </b>part of <b>data </b>commands
       are always taken to be part of the body of the data and are
       therefore never ignored by fast-import. This makes it safe to
       import any file/message content whose lines might start with <b>#</b>.

       Exact byte count format
           The frontend must specify the number of bytes of data.

                       'data' SP &lt;count&gt; LF
                       &lt;raw&gt; LF?

           where <b>&lt;count&gt; </b>is the exact number of bytes appearing within
           <b>&lt;raw&gt;</b>. The value of <b>&lt;count&gt; </b>is expressed as an ASCII decimal
           integer. The <b>LF </b>on either side of <b>&lt;raw&gt; </b>is not included in
           <b>&lt;count&gt; </b>and will not be included in the imported data.

           The <b>LF </b>after <b>&lt;raw&gt; </b>is optional (it used to be required) but
           recommended. Always including it makes debugging a
           fast-import stream easier as the next command always starts
           in column 0 of the next line, even if <b>&lt;raw&gt; </b>did not end with
           an <b>LF</b>.

       Delimited format
           A delimiter string is used to mark the end of the data.
           fast-import will compute the length by searching for the
           delimiter. This format is primarily useful for testing and is
           not recommended for real data.

                       'data' SP '&lt;&lt;' &lt;delim&gt; LF
                       &lt;raw&gt; LF
                       &lt;delim&gt; LF
                       LF?

           where <b>&lt;delim&gt; </b>is the chosen delimiter string. The string
           <b>&lt;delim&gt; </b>must not appear on a line by itself within <b>&lt;raw&gt;</b>, as
           otherwise fast-import will think the data ends earlier than
           it really does. The <b>LF </b>immediately trailing <b>&lt;raw&gt; </b>is part of
           <b>&lt;raw&gt;</b>. This is one of the limitations of the delimited
           format, it is impossible to supply a data chunk which does
           not have an LF as its last byte.

           The <b>LF </b>after <b>&lt;delim&gt; LF </b>is optional (it used to be required).

   <b>alias</b>
       Record that a mark refers to a given object without first
       creating any new object.

                   'alias' LF
                   mark
                   'to' SP &lt;commit-ish&gt; LF
                   LF?

       For a detailed description of <b>&lt;commit-ish&gt; </b>see above under <b>from</b>.

   <b>checkpoint</b>
       Forces fast-import to close the current packfile, start a new
       one, and to save out all current branch refs, tags and marks.

                   'checkpoint' LF
                   LF?

       Note that fast-import automatically switches packfiles when the
       current packfile reaches --max-pack-size, or 4 GiB, whichever
       limit is smaller. During an automatic packfile switch fast-import
       does not update the branch refs, tags or marks.

       As a <b>checkpoint </b>can require a significant amount of CPU time and
       disk IO (to compute the overall pack SHA-1 checksum, generate the
       corresponding index file, and update the refs) it can easily take
       several minutes for a single <b>checkpoint </b>command to complete.

       Frontends may choose to issue checkpoints during extremely large
       and long running imports, or when they need to allow another Git
       process access to a branch. However given that a 30 GiB
       Subversion repository can be loaded into Git through fast-import
       in about 3 hours, explicit checkpointing may not be necessary.

       The <b>LF </b>after the command is optional (it used to be required).

   <b>progress</b>
       Causes fast-import to print the entire <b>progress </b>line unmodified
       to its standard output channel (file descriptor 1) when the
       command is processed from the input stream. The command otherwise
       has no impact on the current import, or on any of fast-import’s
       internal state.

                   'progress' SP &lt;any&gt; LF
                   LF?

       The <b>&lt;any&gt; </b>part of the command may contain any sequence of bytes
       that does not contain <b>LF</b>. The <b>LF </b>after the command is optional.
       Callers may wish to process the output through a tool such as sed
       to remove the leading part of the line, for example:

           frontend | git fast-import | sed 's/^progress //'

       Placing a <b>progress </b>command immediately after a <b>checkpoint </b>will
       inform the reader when the <b>checkpoint </b>has been completed and it
       can safely access the refs that fast-import updated.

   <b>get-mark</b>
       Causes fast-import to print the SHA-1 corresponding to a mark to
       stdout or to the file descriptor previously arranged with the
       <b>--cat-blob-fd </b>argument. The command otherwise has no impact on
       the current import; its purpose is to retrieve SHA-1s that later
       commits might want to refer to in their commit messages.

                   'get-mark' SP ':' &lt;idnum&gt; LF

       See “Responses To Commands” below for details about how to read
       this output safely.

   <b>cat-blob</b>
       Causes fast-import to print a blob to a file descriptor
       previously arranged with the <b>--cat-blob-fd </b>argument. The command
       otherwise has no impact on the current import; its main purpose
       is to retrieve blobs that may be in fast-import’s memory but not
       accessible from the target repository.

                   'cat-blob' SP &lt;dataref&gt; LF

       The <b>&lt;dataref&gt; </b>can be either a mark reference (<b>:&lt;idnum&gt;</b>) set
       previously or a full 40-byte SHA-1 of a Git blob, preexisting or
       ready to be written.

       Output uses the same format as <b>git cat-file --batch</b>:

           &lt;sha1&gt; SP 'blob' SP &lt;size&gt; LF
           &lt;contents&gt; LF

       This command can be used where a <b>filemodify </b>directive can appear,
       allowing it to be used in the middle of a commit. For a
       <b>filemodify </b>using an inline directive, it can also appear right
       before the <b>data </b>directive.

       See “Responses To Commands” below for details about how to read
       this output safely.

   <b>ls</b>
       Prints information about the object at a path to a file
       descriptor previously arranged with the <b>--cat-blob-fd </b>argument.
       This allows printing a blob from the active commit (with
       <b>cat-blob</b>) or copying a blob or tree from a previous commit for
       use in the current one (with <b>filemodify</b>).

       The <b>ls </b>command can also be used where a <b>filemodify </b>directive can
       appear, allowing it to be used in the middle of a commit.

       Reading from the active commit
           This form can only be used in the middle of a <b>commit</b>. The
           path names a directory entry within fast-import’s active
           commit. The path must be quoted in this case.

                       'ls' SP &lt;path&gt; LF

       Reading from a named tree
           The <b>&lt;dataref&gt; </b>can be a mark reference (<b>:&lt;idnum&gt;</b>) or the full
           40-byte SHA-1 of a Git tag, commit, or tree object,
           preexisting or waiting to be written. The path is relative to
           the top level of the tree named by <b>&lt;dataref&gt;</b>.

                       'ls' SP &lt;dataref&gt; SP &lt;path&gt; LF

       See <b>filemodify </b>above for a detailed description of <b>&lt;path&gt;</b>.

       Output uses the same format as <b>git ls-tree &lt;tree&gt; -- &lt;path&gt;</b>:

           &lt;mode&gt; SP ('blob' | 'tree' | 'commit') SP &lt;dataref&gt; HT &lt;path&gt; LF

       The &lt;dataref&gt; represents the blob, tree, or commit object at
       &lt;path&gt; and can be used in later <i>get-mark</i>, <i>cat-blob</i>, <i>filemodify</i>,
       or <i>ls</i> commands.

       If there is no file or subtree at that path, <i>git fast-import</i> will
       instead report

           missing SP &lt;path&gt; LF

       See “Responses To Commands” below for details about how to read
       this output safely.

   <b>feature</b>
       Require that fast-import supports the specified feature, or abort
       if it does not.

                   'feature' SP &lt;feature&gt; ('=' &lt;argument&gt;)? LF

       The &lt;feature&gt; part of the command may be any one of the
       following:

       date-format, export-marks, relative-marks, no-relative-marks,
       force
           Act as though the corresponding command-line option with a
           leading <b>-- </b>was passed on the command line (see OPTIONS,
           above).

       import-marks, import-marks-if-exists
           Like --import-marks except in two respects: first, only one
           "feature import-marks" or "feature import-marks-if-exists"
           command is allowed per stream; second, an --import-marks= or
           --import-marks-if-exists command-line option overrides any of
           these "feature" commands in the stream; third, "feature
           import-marks-if-exists" like a corresponding command-line
           option silently skips a nonexistent file.

       get-mark, cat-blob, ls
           Require that the backend support the <i>get-mark</i>, <i>cat-blob</i>, or
           <i>ls</i> command respectively. Versions of fast-import not
           supporting the specified command will exit with a message
           indicating so. This lets the import error out early with a
           clear message, rather than wasting time on the early part of
           an import before the unsupported command is detected.

       notes
           Require that the backend support the <i>notemodify</i> (N)
           subcommand to the <i>commit</i> command. Versions of fast-import not
           supporting notes will exit with a message indicating so.

       done
           Error out if the stream ends without a <i>done</i> command. Without
           this feature, errors causing the frontend to end abruptly at
           a convenient point in the stream can go undetected. This may
           occur, for example, if an import front end dies in
           mid-operation without emitting SIGTERM or SIGKILL at its
           subordinate git fast-import instance.

   <b>option</b>
       Processes the specified option so that git fast-import behaves in
       a way that suits the frontend’s needs. Note that options
       specified by the frontend are overridden by any options the user
       may specify to git fast-import itself.

               'option' SP &lt;option&gt; LF

       The <b>&lt;option&gt; </b>part of the command may contain any of the options
       listed in the OPTIONS section that do not change import
       semantics, without the leading <b>-- </b>and is treated in the same way.

       Option commands must be the first commands on the input (not
       counting feature commands), to give an option command after any
       non-option command is an error.

       The following command-line options change import semantics and
       may therefore not be passed as option:

       •   date-format

       •   import-marks

       •   export-marks

       •   cat-blob-fd

       •   force

   <b>done</b>
       If the <b>done </b>feature is not in use, treated as if EOF was read.
       This can be used to tell fast-import to finish early.

       If the <b>--done </b>command-line option or <b>feature done </b>command is in
       use, the <b>done </b>command is mandatory and marks the end of the
       stream.
</pre> <h2>
RESPONSES TO COMMANDS </h2>
<pre>
       New objects written by fast-import are not available immediately.
       Most fast-import commands have no visible effect until the next
       checkpoint (or completion). The frontend can send commands to
       fill fast-import’s input pipe without worrying about how quickly
       they will take effect, which improves performance by simplifying
       scheduling.

       For some frontends, though, it is useful to be able to read back
       data from the current repository as it is being updated (for
       example when the source material describes objects in terms of
       patches to be applied to previously imported objects). This can
       be accomplished by connecting the frontend and fast-import via
       bidirectional pipes:

           mkfifo fast-import-output
           frontend &lt;fast-import-output |
           git fast-import &gt;fast-import-output

       A frontend set up this way can use <b>progress</b>, <b>get-mark</b>, <b>ls</b>, and
       <b>cat-blob </b>commands to read information from the import in
       progress.

       To avoid deadlock, such frontends must completely consume any
       pending output from <b>progress</b>, <b>ls</b>, <b>get-mark</b>, and <b>cat-blob </b>before
       performing writes to fast-import that might block.
</pre> <h2>
CRASH REPORTS </h2>
<pre>
       If fast-import is supplied invalid input it will terminate with a
       non-zero exit status and create a crash report in the top level
       of the Git repository it was importing into. Crash reports
       contain a snapshot of the internal fast-import state as well as
       the most recent commands that lead up to the crash.

       All recent commands (including stream comments, file changes and
       progress commands) are shown in the command history within the
       crash report, but raw file data and commit messages are excluded
       from the crash report. This exclusion saves space within the
       report file and reduces the amount of buffering that fast-import
       must perform during execution.

       After writing a crash report fast-import will close the current
       packfile and export the marks table. This allows the frontend
       developer to inspect the repository state and resume the import
       from the point where it crashed. The modified branches and tags
       are not updated during a crash, as the import did not complete
       successfully. Branch and tag information can be found in the
       crash report and must be applied manually if the update is
       needed.

       An example crash:

           $ cat &gt;in &lt;&lt;END_OF_INPUT
           # my very first test commit
           commit refs/heads/master
           committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
           # who is that guy anyway?
           data &lt;&lt;EOF
           this is my commit
           EOF
           M 644 inline .gitignore
           data &lt;&lt;EOF
           .gitignore
           EOF
           M 777 inline bob
           END_OF_INPUT

           $ git fast-import &lt;in
           fatal: Corrupt mode: M 777 inline bob
           fast-import: dumping crash report to .git/fast_import_crash_8434

           $ cat .git/fast_import_crash_8434
           fast-import crash report:
               fast-import process: 8434
               parent process     : 1391
               at Sat Sep 1 00:58:12 2007

           fatal: Corrupt mode: M 777 inline bob

           Most Recent Commands Before Crash
           ---------------------------------
             # my very first test commit
             commit refs/heads/master
             committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
             # who is that guy anyway?
             data &lt;&lt;EOF
             M 644 inline .gitignore
             data &lt;&lt;EOF
           * M 777 inline bob

           Active Branch LRU
           -----------------
               active_branches = 1 cur, 5 max

           pos  clock name
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            1)      0 refs/heads/master

           Inactive Branches
           -----------------
           refs/heads/master:
             status      : active loaded dirty
             tip commit  : 0000000000000000000000000000000000000000
             old tree    : 0000000000000000000000000000000000000000
             cur tree    : 0000000000000000000000000000000000000000
             commit clock: 0
             last pack   :

           -------------------
           END OF CRASH REPORT
</pre> <h2>
TIPS AND TRICKS </h2>
<pre>
       The following tips and tricks have been collected from various
       users of fast-import, and are offered here as suggestions.

   <b>Use One Mark Per Commit</b>
       When doing a repository conversion, use a unique mark per commit
       (<b>mark :&lt;n&gt;</b>) and supply the --export-marks option on the command
       line. fast-import will dump a file which lists every mark and the
       Git object SHA-1 that corresponds to it. If the frontend can tie
       the marks back to the source repository, it is easy to verify the
       accuracy and completeness of the import by comparing each Git
       commit to the corresponding source revision.

       Coming from a system such as Perforce or Subversion, this should
       be quite simple, as the fast-import mark can also be the Perforce
       changeset number or the Subversion revision number.

   <b>Freely Skip Around Branches</b>
       Don’t bother trying to optimize the frontend to stick to one
       branch at a time during an import. Although doing so might be
       slightly faster for fast-import, it tends to increase the
       complexity of the frontend code considerably.

       The branch LRU builtin to fast-import tends to behave very well,
       and the cost of activating an inactive branch is so low that
       bouncing around between branches has virtually no impact on
       import performance.

   <b>Handling Renames</b>
       When importing a renamed file or directory, simply delete the old
       name(s) and modify the new name(s) during the corresponding
       commit. Git performs rename detection after-the-fact, rather than
       explicitly during a commit.

   <b>Use Tag Fixup Branches</b>
       Some other SCM systems let the user create a tag from multiple
       files which are not from the same commit/changeset. Or to create
       tags which are a subset of the files available in the repository.

       Importing these tags as-is in Git is impossible without making at
       least one commit which “fixes up” the files to match the content
       of the tag. Use fast-import’s <b>reset </b>command to reset a dummy
       branch outside of your normal branch space to the base commit for
       the tag, then commit one or more file fixup commits, and finally
       tag the dummy branch.

       For example since all normal branches are stored under
       <b>refs/heads/ </b>name the tag fixup branch <b>TAG_FIXUP</b>. This way it is
       impossible for the fixup branch used by the importer to have
       namespace conflicts with real branches imported from the source
       (the name <b>TAG_FIXUP </b>is not <b>refs/heads/TAG_FIXUP</b>).

       When committing fixups, consider using <b>merge </b>to connect the
       commit(s) which are supplying file revisions to the fixup branch.
       Doing so will allow tools such as <i>git blame</i> to track through the
       real commit history and properly annotate the source files.

       After fast-import terminates the frontend will need to do <b>rm</b>
       <b>.git/TAG_FIXUP </b>to remove the dummy branch.

   <b>Import Now, Repack Later</b>
       As soon as fast-import completes the Git repository is completely
       valid and ready for use. Typically this takes only a very short
       time, even for considerably large projects (100,000+ commits).

       However repacking the repository is necessary to improve data
       locality and access performance. It can also take hours on
       extremely large projects (especially if -f and a large --window
       parameter is used). Since repacking is safe to run alongside
       readers and writers, run the repack in the background and let it
       finish when it finishes. There is no reason to wait to explore
       your new Git project!

       If you choose to wait for the repack, don’t try to run benchmarks
       or performance tests until repacking is completed. fast-import
       outputs suboptimal packfiles that are simply never seen in real
       use situations.

   <b>Repacking Historical Data</b>
       If you are repacking very old imported data (e.g. older than the
       last year), consider expending some extra CPU time and supplying
       --window=50 (or higher) when you run <i>git repack</i>. This will take
       longer, but will also produce a smaller packfile. You only need
       to expend the effort once, and everyone using your project will
       benefit from the smaller repository.

   <b>Include Some Progress Messages</b>
       Every once in a while have your frontend emit a <b>progress </b>message
       to fast-import. The contents of the messages are entirely
       free-form, so one suggestion would be to output the current month
       and year each time the current commit date moves into the next
       month. Your users will feel better knowing how much of the data
       stream has been processed.
</pre> <h2>
PACKFILE OPTIMIZATION </h2>
<pre>
       When packing a blob fast-import always attempts to deltify
       against the last blob written. Unless specifically arranged for
       by the frontend, this will probably not be a prior version of the
       same file, so the generated delta will not be the smallest
       possible. The resulting packfile will be compressed, but will not
       be optimal.

       Frontends which have efficient access to all revisions of a
       single file (for example reading an RCS/CVS ,v file) can choose
       to supply all revisions of that file as a sequence of consecutive
       <b>blob </b>commands. This allows fast-import to deltify the different
       file revisions against each other, saving space in the final
       packfile. Marks can be used to later identify individual file
       revisions during a sequence of <b>commit </b>commands.

       The packfile(s) created by fast-import do not encourage good disk
       access patterns. This is caused by fast-import writing the data
       in the order it is received on standard input, while Git
       typically organizes data within packfiles to make the most recent
       (current tip) data appear before historical data. Git also
       clusters commits together, speeding up revision traversal through
       better cache locality.

       For this reason it is strongly recommended that users repack the
       repository with <b>git repack -a -d </b>after fast-import completes,
       allowing Git to reorganize the packfiles for faster data access.
       If blob deltas are suboptimal (see above) then also adding the <b>-f</b>
       option to force recomputation of all deltas can significantly
       reduce the final packfile size (30-50% smaller can be quite
       typical).

       Instead of running <b>git repack </b>you can also run <b>git gc</b>
       <b>--aggressive</b>, which will also optimize other things after an
       import (e.g. pack loose refs). As noted in the "AGGRESSIVE"
       section in <a href="git-gc.1.html">git-gc(1)</a> the <b>--aggressive </b>option will find new deltas
       with the <b>-f </b>option to <a href="git-repack.1.html">git-repack(1)</a>. For the reasons elaborated
       on above using <b>--aggressive </b>after a fast-import is one of the few
       cases where it’s known to be worthwhile.
</pre> <h2>
MEMORY UTILIZATION </h2>
<pre>
       There are a number of factors which affect how much memory
       fast-import requires to perform an import. Like critical sections
       of core Git, fast-import uses its own memory allocators to
       amortize any overheads associated with malloc. In practice
       fast-import tends to amortize any malloc overheads to 0, due to
       its use of large block allocations.

   <b>per object</b>
       fast-import maintains an in-memory structure for every object
       written in this execution. On a 32 bit system the structure is 32
       bytes, on a 64 bit system the structure is 40 bytes (due to the
       larger pointer sizes). Objects in the table are not deallocated
       until fast-import terminates. Importing 2 million objects on a 32
       bit system will require approximately 64 MiB of memory.

       The object table is actually a hashtable keyed on the object name
       (the unique SHA-1). This storage configuration allows fast-import
       to reuse an existing or already written object and avoid writing
       duplicates to the output packfile. Duplicate blobs are
       surprisingly common in an import, typically due to branch merges
       in the source.

   <b>per mark</b>
       Marks are stored in a sparse array, using 1 pointer (4 bytes or 8
       bytes, depending on pointer size) per mark. Although the array is
       sparse, frontends are still strongly encouraged to use marks
       between 1 and n, where n is the total number of marks required
       for this import.

   <b>per branch</b>
       Branches are classified as active and inactive. The memory usage
       of the two classes is significantly different.

       Inactive branches are stored in a structure which uses 96 or 120
       bytes (32 bit or 64 bit systems, respectively), plus the length
       of the branch name (typically under 200 bytes), per branch.
       fast-import will easily handle as many as 10,000 inactive
       branches in under 2 MiB of memory.

       Active branches have the same overhead as inactive branches, but
       also contain copies of every tree that has been recently modified
       on that branch. If subtree <b>include </b>has not been modified since
       the branch became active, its contents will not be loaded into
       memory, but if subtree <b>src </b>has been modified by a commit since
       the branch became active, then its contents will be loaded in
       memory.

       As active branches store metadata about the files contained on
       that branch, their in-memory storage size can grow to a
       considerable size (see below).

       fast-import automatically moves active branches to inactive
       status based on a simple least-recently-used algorithm. The LRU
       chain is updated on each <b>commit </b>command. The maximum number of
       active branches can be increased or decreased on the command line
       with --active-branches=.

   <b>per active tree</b>
       Trees (aka directories) use just 12 bytes of memory on top of the
       memory required for their entries (see “per active file” below).
       The cost of a tree is virtually 0, as its overhead amortizes out
       over the individual file entries.

   <b>per active file entry</b>
       Files (and pointers to subtrees) within active trees require 52
       or 64 bytes (32/64 bit platforms) per entry. To conserve space,
       file and tree names are pooled in a common string table, allowing
       the filename “Makefile” to use just 16 bytes (after including the
       string header overhead) no matter how many times it occurs within
       the project.

       The active branch LRU, when coupled with the filename string pool
       and lazy loading of subtrees, allows fast-import to efficiently
       import projects with 2,000+ branches and 45,114+ files in a very
       limited memory footprint (less than 2.7 MiB per active branch).
</pre> <h2>
SIGNALS </h2>
<pre>
       Sending <b>SIGUSR1 </b>to the <i>git fast-import</i> process ends the current
       packfile early, simulating a <b>checkpoint </b>command. The impatient
       operator can use this facility to peek at the objects and refs
       from an import in progress, at the cost of some added running
       time and worse compression.
</pre> <h2>
CONFIGURATION </h2>
<pre>
       Everything below this line in this section is selectively
       included from the <a href="git-config.1.html">git-config(1)</a> documentation. The content is the
       same as what’s found there:

       fastimport.unpackLimit
           If the number of objects imported by <a href="git-fast-import.1.html">git-fast-import(1)</a> is
           below this limit, then the objects will be unpacked into
           loose object files. However, if the number of imported
           objects equals or exceeds this limit, then the pack will be
           stored as a pack. Storing the pack from a fast-import can
           make the import operation complete faster, especially on slow
           filesystems. If not set, the value of <b>transfer.unpackLimit </b>is
           used instead.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="git-fast-export.1.html">git-fast-export(1)</a>
</pre> <h2>
GIT </h2>
<pre>
       Part of the <a href="git.1.html">git(1)</a> suite
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>git</i> (Git distributed version control
       system) project.  Information about the project can be found at
       ⟨<a href="http://git-scm.com/">http://git-scm.com/</a>⟩.  If you have a bug report for this manual
       page, see ⟨<a href="http://git-scm.com/community">http://git-scm.com/community</a>⟩.  This page was obtained
       from the project's upstream Git repository
       ⟨<a href="https://github.com/git/git.git">https://github.com/git/git.git</a>⟩ on 2024-06-14.  (At that time,
       the date of the most recent commit that was found in the
       repository was 2024-06-12.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Git 2.45.2.492.gd63586         2024-06-12             <i>GIT-FAST-IMPORT</i>(1)</span>
</pre>  <p>Pages that refer to this page: <a href="git.1.html">git(1)</a>, <a href="git-config.1.html">git-config(1)</a>, <a href="git-fast-export.1.html">git-fast-export(1)</a>, <a href="git-fast-import.1.html">git-fast-import(1)</a>, <a href="git-gc.1.html">git-gc(1)</a>, <a href="../man5/githooks.5.html">githooks(5)</a>, <a href="../man7/gitremote-helpers.7.html">gitremote-helpers(7)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man1/git-fast-import.1.html" class="_attribution-link">https://man7.org/linux/man-pages/man1/git-fast-import.1.html</a>
  </p>
</div>
