<h1>make(1p) — Linux manual page</h1>   <pre>
<span class="headline"><i>MAKE</i>(1P)                POSIX Programmer's Manual               <i>MAKE</i>(1P)</span>
</pre> <h2>
PROLOG </h2>
<pre>
       This manual page is part of the POSIX Programmer's Manual.  The
       Linux implementation of this interface may differ (consult the
       corresponding Linux manual page for details of Linux behavior),
       or the interface may not be implemented on Linux.
</pre> <h2>
NAME </h2>
<pre>
       make — maintain, update, and regenerate groups of programs
       (<b>DEVELOPMENT</b>)
</pre> <h2>
SYNOPSIS </h2>
<pre>
       make <b>[</b>-einpqrst<b>] [</b>-f <i>makefile</i><b>]</b>... <b>[</b>-k|-S<b>] [</b><i>macro</i>=<i>value</i>...<b>]</b>
           <b>[</b><i>target_name</i>...<b>]</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <i>make</i> utility shall update files that are derived from other
       files. A typical case is one where object files are derived from
       the corresponding source files. The <i>make</i> utility examines time
       relationships and shall update those derived files (called
       targets) that have modified times earlier than the modified times
       of the files (called prerequisites) from which they are derived.
       A description file (makefile) contains a description of the
       relationships between files, and the commands that need to be
       executed to update the targets to reflect changes in their
       prerequisites. Each specification, or rule, shall consist of a
       target, optional prerequisites, and optional commands to be
       executed when a prerequisite is newer than the target. There are
       two types of rule:

        1. <i>Inference rules</i>, which have one target name with at least one
           &lt;period&gt; (<b>'.'</b>)  and no &lt;slash&gt; (<b>'/'</b>)

        2. <i>Target rules</i>, which can have more than one target name

       In addition, <i>make</i> shall have a collection of built-in macros and
       inference rules that infer prerequisite relationships to simplify
       maintenance of programs.

       To receive exactly the behavior described in this section, the
       user shall ensure that a portable makefile shall:

        *  Include the special target <b>.POSIX</b>

        *  Omit any special target reserved for implementations (a
           leading period followed by uppercase letters) that has not
           been specified by this section

       The behavior of <i>make</i> is unspecified if either or both of these
       conditions are not met.
</pre> <h2>
OPTIONS </h2>
<pre>
       The <i>make</i> utility shall conform to the Base Definitions volume of
       POSIX.1‐2017, <i>Section 12.2</i>, <i>Utility Syntax Guidelines</i>, except for
       Guideline 9.

       The following options shall be supported:

       <b>-e        </b>Cause environment variables, including those with null
                 values, to override macro assignments within makefiles.

       <b>-f </b><i>makefile</i>
                 Specify a different makefile. The argument <i>makefile</i> is
                 a pathname of a description file, which is also
                 referred to as the <i>makefile</i>.  A pathname of <b>'-' </b>shall
                 denote the standard input. There can be multiple
                 instances of this option, and they shall be processed
                 in the order specified. The effect of specifying the
                 same option-argument more than once is unspecified.

       <b>-i        </b>Ignore error codes returned by invoked commands. This
                 mode is the same as if the special target <b>.IGNORE </b>were
                 specified without prerequisites.

       <b>-k        </b>Continue to update other targets that do not depend on
                 the current target if a non-ignored error occurs while
                 executing the commands to bring a target up-to-date.

       <b>-n        </b>Write commands that would be executed on standard
                 output, but do not execute them. However, lines with a
                 &lt;plus-sign&gt; (<b>'+'</b>) prefix shall be executed. In this
                 mode, lines with an at-sign (<b>'@'</b>) character prefix
                 shall be written to standard output.

       <b>-p        </b>Write to standard output the complete set of macro
                 definitions and target descriptions. The output format
                 is unspecified.

       <b>-q        </b>Return a zero exit value if the target file is up-to-
                 date; otherwise, return an exit value of 1. Targets
                 shall not be updated if this option is specified.
                 However, a makefile command line (associated with the
                 targets) with a &lt;plus-sign&gt; (<b>'+'</b>) prefix shall be
                 executed.

       <b>-r        </b>Clear the suffix list and do not use the built-in
                 rules.

       <b>-S        </b>Terminate <i>make</i> if an error occurs while executing the
                 commands to bring a target up-to-date. This shall be
                 the default and the opposite of <b>-k</b>.

       <b>-s        </b>Do not write makefile command lines or touch messages
                 (see <b>-t</b>) to standard output before executing. This mode
                 shall be the same as if the special target <b>.SILENT </b>were
                 specified without prerequisites.

       <b>-t        </b>Update the modification time of each target as though a
                 <i>touch target</i> had been executed. Targets that have
                 prerequisites but no commands (see <i>Target Rules</i>), or
                 that are already up-to-date, shall not be touched in
                 this manner.  Write messages to standard output for
                 each target file indicating the name of the file and
                 that it was touched. Normally, the <i>makefile</i> command
                 lines associated with each target are not executed.
                 However, a command line with a &lt;plus-sign&gt; (<b>'+'</b>) prefix
                 shall be executed.

       Any options specified in the <i>MAKEFLAGS</i> environment variable shall
       be evaluated before any options specified on the <i>make</i> utility
       command line. If the <b>-k </b>and <b>-S </b>options are both specified on the
       <i>make</i> utility command line or by the <i>MAKEFLAGS</i> environment
       variable, the last option specified shall take precedence.  If
       the <b>-f </b>or <b>-p </b>options appear in the <i>MAKEFLAGS</i> environment
       variable, the result is undefined.
</pre> <h2>
OPERANDS </h2>
<pre>
       The following operands shall be supported:

       <i>target_name</i>
                 Target names, as defined in the EXTENDED DESCRIPTION
                 section. If no target is specified, while <i>make</i> is
                 processing the makefiles, the first target that <i>make</i>
                 encounters that is not a special target or an inference
                 rule shall be used.

       <i>macro</i>=<i>value</i>
                 Macro definitions, as defined in <i>Macros</i>.

       If the <i>target_name</i> and <i>macro</i>=<i>value</i> operands are intermixed on the
       <i>make</i> utility command line, the results are unspecified.
</pre> <h2>
STDIN </h2>
<pre>
       The standard input shall be used only if the <i>makefile</i> option-
       argument is <b>'-'</b>.  See the INPUT FILES section.
</pre> <h2>
INPUT FILES </h2>
<pre>
       The input file, otherwise known as the makefile, is a text file
       containing rules, macro definitions, include lines, and comments.
       See the EXTENDED DESCRIPTION section.
</pre> <h2>
ENVIRONMENT VARIABLES </h2>
<pre>
       The following environment variables shall affect the execution of
       <i>make</i>:

       <i>LANG</i>      Provide a default value for the internationalization
                 variables that are unset or null. (See the Base
                 Definitions volume of POSIX.1‐2017, <i>Section 8.2</i>,
                 <i>Internationalization Variables</i> for the precedence of
                 internationalization variables used to determine the
                 values of locale categories.)

       <i>LC_ALL</i>    If set to a non-empty string value, override the values
                 of all the other internationalization variables.

       <i>LC_CTYPE</i>  Determine the locale for the interpretation of
                 sequences of bytes of text data as characters (for
                 example, single-byte as opposed to multi-byte
                 characters in arguments and input files).

       <i>LC_MESSAGES</i>
                 Determine the locale that should be used to affect the
                 format and contents of diagnostic messages written to
                 standard error.

       <i>MAKEFLAGS</i>
                 This variable shall be interpreted as a character
                 string representing a series of option characters to be
                 used as the default options. The implementation shall
                 accept both of the following formats (but need not
                 accept them when intermixed):

                  *  The characters are option letters without the
                     leading &lt;hyphen-minus&gt; characters or &lt;blank&gt;
                     separation used on a <i>make</i> utility command line.

                  *  The characters are formatted in a manner similar to
                     a portion of the <i>make</i> utility command line: options
                     are preceded by &lt;hyphen-minus&gt; characters and
                     &lt;blank&gt;-separated as described in the Base
                     Definitions volume of POSIX.1‐2017, <i>Section 12.2</i>,
                     <i>Utility Syntax Guidelines</i>.  The <i>macro</i>=<i>value</i> macro
                     definition operands can also be included. The
                     difference between the contents of <i>MAKEFLAGS</i> and
                     the <i>make</i> utility command line is that the contents
                     of the variable shall not be subjected to the word
                     expansions (see <i>Section 2.6</i>, <i>Word Expansions</i>)
                     associated with parsing the command line values.

       <i>NLSPATH</i>   Determine the location of message catalogs for the
                 processing of <i>LC_MESSAGES</i>.

       <i>PROJECTDIR</i>
                 Provide a directory to be used to search for SCCS files
                 not found in the current directory. In all of the
                 following cases, the search for SCCS files is made in
                 the directory <b>SCCS </b>in the identified directory. If the
                 value of <i>PROJECTDIR</i> begins with a &lt;slash&gt;, it shall be
                 considered an absolute pathname; otherwise, the value
                 of <i>PROJECTDIR</i> is treated as a user name and that user's
                 initial working directory shall be examined for a
                 subdirectory <b>src </b>or <b>source</b>.  If such a directory is
                 found, it shall be used. Otherwise, the value is used
                 as a relative pathname.

                 If <i>PROJECTDIR</i> is not set or has a null value, the
                 search for SCCS files shall be made in the directory
                 <b>SCCS </b>in the current directory.

                 The setting of <i>PROJECTDIR</i> affects all files listed in
                 the remainder of this utility description for files
                 with a component named <b>SCCS</b>.

       The value of the <i>SHELL</i> environment variable shall not be used as
       a macro and shall not be modified by defining the <b>SHELL </b>macro in
       a makefile or on the command line. All other environment
       variables, including those with null values, shall be used as
       macros, as defined in <i>Macros</i>.
</pre> <h2>
ASYNCHRONOUS EVENTS </h2>
<pre>
       If not already ignored, <i>make</i> shall trap SIGHUP, SIGTERM, SIGINT,
       and SIGQUIT and remove the current target unless the target is a
       directory or the target is a prerequisite of the special target
       <b>.PRECIOUS </b>or unless one of the <b>-n</b>, <b>-p</b>, or <b>-q </b>options was
       specified. Any targets removed in this manner shall be reported
       in diagnostic messages of unspecified format, written to standard
       error. After this cleanup process, if any, <i>make</i> shall take the
       standard action for all other signals.
</pre> <h2>
STDOUT </h2>
<pre>
       The <i>make</i> utility shall write all commands to be executed to
       standard output unless the <b>-s </b>option was specified, the command
       is prefixed with an at-sign, or the special target <b>.SILENT </b>has
       either the current target as a prerequisite or has no
       prerequisites. If <i>make</i> is invoked without any work needing to be
       done, it shall write a message to standard output indicating that
       no action was taken. If the <b>-t </b>option is present and a file is
       touched, <i>make</i> shall write to standard output a message of
       unspecified format indicating that the file was touched,
       including the filename of the file.
</pre> <h2>
STDERR </h2>
<pre>
       The standard error shall be used only for diagnostic messages.
</pre> <h2>
OUTPUT FILES </h2>
<pre>
       Files can be created when the <b>-t </b>option is present. Additional
       files can also be created by the utilities invoked by <i>make</i>.
</pre> <h2>
EXTENDED DESCRIPTION </h2>
<pre>
       The <i>make</i> utility attempts to perform the actions required to
       ensure that the specified targets are up-to-date. A target shall
       be considered up-to-date if it exists and is newer than all of
       its dependencies, or if it has already been made up-to-date by
       the current invocation of <i>make</i> (regardless of the target's
       existence or age). A target may also be considered up-to-date if
       it exists, is the same age as one or more of its prerequisites,
       and is newer than the remaining prerequisites (if any).  The <i>make</i>
       utility shall treat all prerequisites as targets themselves and
       recursively ensure that they are up-to-date, processing them in
       the order in which they appear in the rule. The <i>make</i> utility
       shall use the modification times of files to determine whether
       the corresponding targets are out-of-date.

       To ensure that a target is up-to-date, <i>make</i> shall ensure that all
       of the prerequisites of a target are up-to-date, then check to
       see if the target itself is up-to-date. If the target is not up-
       to-date, the target shall be made up-to-date by executing the
       rule's commands (if any). If the target does not exist after the
       target has been successfully made up-to-date, the target shall be
       treated as being newer than any target for which it is a
       prerequisite.

       If a target exists and there is neither a target rule nor an
       inference rule for the target, the target shall be considered up-
       to-date. It shall be an error if <i>make</i> attempts to ensure that a
       target is up-to-date but the target does not exist and there is
       neither a target rule nor an inference rule for the target.

   <b>Makefile Syntax</b>
       A makefile can contain rules, macro definitions (see <i>Macros</i>),
       include lines, and comments. There are two kinds of rules:
       <i>inference rules</i> and <i>target rules</i>.  The <i>make</i> utility shall contain
       a set of built-in inference rules. If the <b>-r </b>option is present,
       the built-in rules shall not be used and the suffix list shall be
       cleared. Additional rules of both types can be specified in a
       makefile. If a rule is defined more than once, the value of the
       rule shall be that of the last one specified. Macros can also be
       defined more than once, and the value of the macro is specified
       in <i>Macros</i>.  There are three kinds of comments: blank lines, empty
       lines, and a &lt;number-sign&gt; (<b>'#'</b>) and all following characters up
       to the first unescaped &lt;newline&gt; character. Blank lines, empty
       lines, and lines with &lt;number-sign&gt; (<b>'#'</b>) as the first character
       on the line are also known as comment lines.

       By default, the following files shall be tried in sequence:
       <b>./makefile </b>and <b>./Makefile</b>.  If neither <b>./makefile </b>or <b>./Makefile</b>
       are found, other implementation-defined files may also be tried.
       On XSI-conformant systems, the additional files <b>./s.makefile</b>,
       <b>SCCS/s.makefile</b>, <b>./s.Makefile</b>, and <b>SCCS/s.Makefile </b>shall also be
       tried.

       The <b>-f </b>option shall direct <i>make</i> to ignore any of these default
       files and use the specified argument as a makefile instead. If
       the <b>'-' </b>argument is specified, standard input shall be used.

       The term <i>makefile</i> is used to refer to any rules provided by the
       user, whether in <b>./makefile </b>or its variants, or specified by the
       <b>-f </b>option.

       The rules in makefiles shall consist of the following types of
       lines: target rules, including special targets (see <i>Target</i>
       <i>Rules</i>), inference rules (see <i>Inference Rules</i>), macro definitions
       (see <i>Macros</i>), and comments.

       Target and Inference Rules may contain <i>command lines</i>.  Command
       lines can have a prefix that shall be removed before execution
       (see <i>Makefile Execution</i>).

       When an escaped &lt;newline&gt; (one preceded by a &lt;backslash&gt;) is
       found anywhere in the makefile except in a command line, an
       include line, or a line immediately preceding an include line, it
       shall be replaced, along with any leading white space on the
       following line, with a single &lt;space&gt;.  When an escaped &lt;newline&gt;
       is found in a command line in a makefile, the command line shall
       contain the &lt;backslash&gt;, the &lt;newline&gt;, and the next line, except
       that the first character of the next line shall not be included
       if it is a &lt;tab&gt;.  When an escaped &lt;newline&gt; is found in an
       include line or in a line immediately preceding an include line,
       the behavior is unspecified.

   <b>Include Lines</b>
       If the word <b>include </b>appears at the beginning of a line and is
       followed by one or more &lt;blank&gt; characters, the string formed by
       the remainder of the line shall be processed as follows to
       produce a pathname:

        *  The trailing &lt;newline&gt;, any &lt;blank&gt; characters immediately
           preceding a comment, and any comment shall be discarded. If
           the resulting string contains any double-quote characters
           (<b>'"'</b>) the behavior is unspecified.

        *  The resulting string shall be processed for macro expansion
           (see <i>Macros</i>).

        *  Any &lt;blank&gt; characters that appear after the first
           non-&lt;blank&gt; shall be used as separators to divide the macro-
           expanded string into fields. It is unspecified whether any
           other white-space characters are also used as separators. It
           is unspecified whether pathname expansion (see <i>Section 2.13</i>,
           <i>Pattern Matching Notation</i>) is also performed.

        *  If the processing of separators and optional pathname
           expansion results in either zero or two or more non-empty
           fields, the behavior is unspecified. If it results in one
           non-empty field, that field is taken as the pathname.

       If the pathname does not begin with a <b>'/' </b>it shall be treated as
       relative to the current working directory of the process, not
       relative to the directory containing the makefile.  If the file
       does not exist in this location, it is unspecified whether
       additional directories are searched.

       The contents of the file specified by the pathname shall be read
       and processed as if they appeared in the makefile in place of the
       include line. If the file ends with an escaped &lt;newline&gt; the
       behavior is unspecified.

       The file may itself contain further include lines.
       Implementations shall support nesting of include files up to a
       depth of at least 16.

   <b>Makefile Execution</b>
       Makefile command lines shall be processed one at a time.

       Makefile command lines can have one or more of the following
       prefixes: a &lt;hyphen-minus&gt; (<b>'-'</b>), an at-sign (<b>'@'</b>), or a &lt;plus-
       sign&gt; (<b>'+'</b>).  These shall modify the way in which <i>make</i> processes
       the command.

       -     If the command prefix contains a &lt;hyphen-minus&gt;, or the <b>-i</b>
             option is present, or the special target <b>.IGNORE </b>has either
             the current target as a prerequisite or has no
             prerequisites, any error found while executing the command
             shall be ignored.

       @     If the command prefix contains an at-sign and the <i>make</i>
             utility command line <b>-n </b>option is not specified, or the <b>-s</b>
             option is present, or the special target <b>.SILENT </b>has either
             the current target as a prerequisite or has no
             prerequisites, the command shall not be written to standard
             output before it is executed.

       +     If the command prefix contains a &lt;plus-sign&gt;, this
             indicates a makefile command line that shall be executed
             even if <b>-n</b>, <b>-q</b>, or <b>-t </b>is specified.

       An <i>execution line</i> is built from the command line by removing any
       prefix characters. Except as described under the at-sign prefix,
       the execution line shall be written to the standard output,
       optionally preceded by a &lt;tab&gt;.  The execution line shall then be
       executed by a shell as if it were passed as the argument to the
       <i>system</i>() interface, except that if errors are not being ignored
       then the shell <b>-e </b>option shall also be in effect. If errors are
       being ignored for the command (as a result of the <b>-i </b>option, a
       <b>'-' </b>command prefix, or a <b>.IGNORE </b>special target), the shell <b>-e</b>
       option shall not be in effect. The environment for the command
       being executed shall contain all of the variables in the
       environment of <i>make</i>.

       By default, when <i>make</i> receives a non-zero status from the
       execution of a command, it shall terminate with an error message
       to standard error.

   <b>Target Rules</b>
       Target rules are formatted as follows:

           <i>target</i> <b>[</b><i>target</i>...<b>]</b>: <b>[</b><i>prerequisite</i>...<b>][;</b><i>command</i><b>]</b>
           <b>[</b>&lt;tab&gt;<i>command</i>
           &lt;tab&gt;<i>command</i>
           ...<b>]</b>

           <i>line that does not begin with</i> &lt;tab&gt;

       Target entries are specified by a &lt;blank&gt;-separated, non-null
       list of targets, then a &lt;colon&gt;, then a &lt;blank&gt;-separated,
       possibly empty list of prerequisites. Text following a
       &lt;semicolon&gt;, if any, and all following lines that begin with a
       &lt;tab&gt;, are makefile command lines to be executed to update the
       target. The first non-empty line that does not begin with a &lt;tab&gt;
       or <b>'#' </b>shall begin a new entry. Any comment line may begin a new
       entry.

       Applications shall select target names from the set of characters
       consisting solely of periods, underscores, digits, and
       alphabetics from the portable character set (see the Base
       Definitions volume of POSIX.1‐2017, <i>Section 6.1</i>, <i>Portable</i>
       <i>Character Set</i>).  Implementations may allow other characters in
       target names as extensions. The interpretation of targets
       containing the characters <b>'%' </b>and <b>'"' </b>is implementation-defined.

       A target that has prerequisites, but does not have any commands,
       can be used to add to the prerequisite list for that target. Only
       one target rule for any given target can contain commands.

       Lines that begin with one of the following are called <i>special</i>
       <i>targets</i> and control the operation of <i>make</i>:

       <b>.DEFAULT  </b>If the makefile uses this special target, the
                 application shall ensure that it is specified with
                 commands, but without prerequisites. The commands shall
                 be used by <i>make</i> if there are no other rules available
                 to build a target.

       <b>.IGNORE   </b>Prerequisites of this special target are targets
                 themselves; this shall cause errors from commands
                 associated with them to be ignored in the same manner
                 as specified by the <b>-i </b>option. Subsequent occurrences
                 of <b>.IGNORE </b>shall add to the list of targets ignoring
                 command errors. If no prerequisites are specified, <i>make</i>
                 shall behave as if the <b>-i </b>option had been specified and
                 errors from all commands associated with all targets
                 shall be ignored.

       <b>.POSIX    </b>The application shall ensure that this special target
                 is specified without prerequisites or commands. If it
                 appears as the first non-comment line in the makefile,
                 <i>make</i> shall process the makefile as specified by this
                 section; otherwise, the behavior of <i>make</i> is
                 unspecified.

       <b>.PRECIOUS </b>Prerequisites of this special target shall not be
                 removed if <i>make</i> receives one of the asynchronous events
                 explicitly described in the ASYNCHRONOUS EVENTS
                 section. Subsequent occurrences of <b>.PRECIOUS </b>shall add
                 to the list of precious files. If no prerequisites are
                 specified, all targets in the makefile shall be treated
                 as if specified with <b>.PRECIOUS</b>.

       <b>.SCCS_GET </b>The application shall ensure that this special target
                 is specified without prerequisites. If this special
                 target is included in a makefile, the commands
                 specified with this target shall replace the default
                 commands associated with this special target (see
                 <i>Default Rules</i>).  The commands specified with this
                 target are used to get all SCCS files that are not
                 found in the current directory.

                 When source files are named in a dependency list, <i>make</i>
                 shall treat them just like any other target. Because
                 the source file is presumed to be present in the
                 directory, there is no need to add an entry for it to
                 the makefile. When a target has no dependencies, but is
                 present in the directory, <i>make</i> shall assume that that
                 file is up-to-date. If, however, an SCCS file named
                 <b>SCCS/s.</b><i>source_file</i> is found for a target <i>source_file</i>,
                 <i>make</i> compares the timestamp of the target file with
                 that of the <b>SCCS/s.source_file </b>to ensure the target is
                 up-to-date. If the target is missing, or if the SCCS
                 file is newer, <i>make</i> shall automatically issue the
                 commands specified for the <b>.SCCS_GET </b>special target to
                 retrieve the most recent version. However, if the
                 target is writable by anyone, <i>make</i> shall not retrieve a
                 new version.

       <b>.SILENT   </b>Prerequisites of this special target are targets
                 themselves; this shall cause commands associated with
                 them not to be written to the standard output before
                 they are executed. Subsequent occurrences of <b>.SILENT</b>
                 shall add to the list of targets with silent commands.
                 If no prerequisites are specified, <i>make</i> shall behave as
                 if the <b>-s </b>option had been specified and no commands or
                 touch messages associated with any target shall be
                 written to standard output.

       <b>.SUFFIXES </b>Prerequisites of <b>.SUFFIXES </b>shall be appended to the
                 list of known suffixes and are used in conjunction with
                 the inference rules (see <i>Inference Rules</i>).  If
                 <b>.SUFFIXES </b>does not have any prerequisites, the list of
                 known suffixes shall be cleared.

       The special targets <b>.IGNORE</b>, <b>.POSIX</b>, <b>.PRECIOUS</b>, <b>.SILENT</b>, and
       <b>.SUFFIXES </b>shall be specified without commands.

       Targets with names consisting of a leading &lt;period&gt; followed by
       the uppercase letters <b>"POSIX" </b>and then any other characters are
       reserved for future standardization.  Targets with names
       consisting of a leading &lt;period&gt; followed by one or more
       uppercase letters are reserved for implementation extensions.

   <b>Macros</b>
       Macro definitions are in the form:

           <i>string1</i> = <b>[</b><i>string2</i><b>]</b>

       The macro named <i>string1</i> is defined as having the value of
       <i>string2</i>, where <i>string2</i> is defined as all characters, if any,
       after the &lt;equals-sign&gt;, up to a comment character (<b>'#'</b>) or an
       unescaped &lt;newline&gt;.  Any &lt;blank&gt; characters immediately before
       or after the &lt;equals-sign&gt; shall be ignored.

       Applications shall select macro names from the set of characters
       consisting solely of periods, underscores, digits, and
       alphabetics from the portable character set (see the Base
       Definitions volume of POSIX.1‐2017, <i>Section 6.1</i>, <i>Portable</i>
       <i>Character Set</i>).  A macro name shall not contain an &lt;equals-sign&gt;.
       Implementations may allow other characters in macro names as
       extensions.

       Macros can appear anywhere in the makefile. Macro expansions
       using the forms $(<i>string1</i>) or ${<i>string1</i>} shall be replaced by
       <i>string2</i>, as follows:

        *  Macros in target lines shall be evaluated when the target
           line is read.

        *  Macros in makefile command lines shall be evaluated when the
           command is executed.

        *  Macros in the string before the &lt;equals-sign&gt; in a macro
           definition shall be evaluated when the macro assignment is
           made.

        *  Macros after the &lt;equals-sign&gt; in a macro definition shall
           not be evaluated until the defined macro is used in a rule or
           command, or before the &lt;equals-sign&gt; in a macro definition.

       The parentheses or braces are optional if <i>string1</i> is a single
       character. The macro $$ shall be replaced by the single character
       <b>'$'</b>.  If <i>string1</i> in a macro expansion contains a macro expansion,
       the results are unspecified.

       Macro expansions using the forms $(<i>string1</i><b>[:</b><i>subst1</i><b>=[</b><i>subst2</i><b>]]</b>) or
       ${<i>string1</i><b>[:</b><i>subst1</i><b>=[</b><i>subst2</i><b>]]</b>} can be used to replace all
       occurrences of <i>subst1</i> with <i>subst2</i> when the macro substitution is
       performed. The <i>subst1</i> to be replaced shall be recognized when it
       is a suffix at the end of a word in <i>string1</i> (where a <i>word</i>, in
       this context, is defined to be a string delimited by the
       beginning of the line, a &lt;blank&gt;, or a &lt;newline&gt;).  If <i>string1</i> in
       a macro expansion contains a macro expansion, the results are
       unspecified. If a &lt;percent-sign&gt; character appears as part of
       <i>subst1</i> or <i>subst2</i> after any macros have been recursively expanded,
       the results are unspecified.

       Macro expansions in <i>string1</i> of macro definition lines shall be
       evaluated when read. Macro expansions in <i>string2</i> of macro
       definition lines shall be performed when the macro identified by
       <i>string1</i> is expanded in a rule or command.

       Macro definitions shall be taken from the following sources, in
       the following logical order, before the makefile(s) are read.

        1. Macros specified on the <i>make</i> utility command line, in the
           order specified on the command line. It is unspecified
           whether the internal macros defined in <i>Internal Macros</i> are
           accepted from this source.

        2. Macros defined by the <i>MAKEFLAGS</i> environment variable, in the
           order specified in the environment variable. It is
           unspecified whether the internal macros defined in <i>Internal</i>
           <i>Macros</i> are accepted from this source.

        3. The contents of the environment, excluding the <i>MAKEFLAGS</i> and
           <i>SHELL</i> variables and including the variables with null values.

        4. Macros defined in the inference rules built into <i>make</i>.

       Macro definitions from these sources shall not override macro
       definitions from a lower-numbered source. Macro definitions from
       a single source (for example, the <i>make</i> utility command line, the
       <i>MAKEFLAGS</i> environment variable, or the other environment
       variables) shall override previous macro definitions from the
       same source.

       Macros defined in the makefile(s) shall override macro
       definitions that occur before them in the makefile(s) and macro
       definitions from source 4. If the <b>-e </b>option is not specified,
       macros defined in the makefile(s) shall override macro
       definitions from source 3. Macros defined in the makefile(s)
       shall not override macro definitions from source 1 or source 2.

       Before the makefile(s) are read, all of the <i>make</i> utility command
       line options (except <b>-f </b>and <b>-p</b>) and <i>make</i> utility command line
       macro definitions (except any for the <i>MAKEFLAGS</i> macro), not
       already included in the <i>MAKEFLAGS</i> macro, shall be added to the
       <i>MAKEFLAGS</i> macro, quoted in an implementation-defined manner such
       that when <i>MAKEFLAGS</i> is read by another instance of the <i>make</i>
       command, the original macro's value is recovered. Other
       implementation-defined options and macros may also be added to
       the <i>MAKEFLAGS</i> macro. If this modifies the value of the <i>MAKEFLAGS</i>
       macro, or, if the <i>MAKEFLAGS</i> macro is modified at any subsequent
       time, the <i>MAKEFLAGS</i> environment variable shall be modified to
       match the new value of the <i>MAKEFLAGS</i> macro. The result of setting
       <i>MAKEFLAGS</i> in the Makefile is unspecified.

       Before the makefile(s) are read, all of the <i>make</i> utility command
       line macro definitions (except the <i>MAKEFLAGS</i> macro or the <i>SHELL</i>
       macro) shall be added to the environment of <i>make</i>.  Other
       implementation-defined variables may also be added to the
       environment of <i>make</i>.  Macros defined by the <i>MAKEFLAGS</i> environment
       variable and macros defined in the makefile(s) shall not be added
       to the environment of <i>make</i> if they are not already in its
       environment. With the exception of <i>SHELL</i> (see below), it is
       unspecified whether macros defined in these ways update the value
       of an environment variable that already exists in the environment
       of <i>make</i>.

       The <b>SHELL </b>macro shall be treated specially. It shall be provided
       by <i>make</i> and set to the pathname of the shell command language
       interpreter (see <a href="sh.1p.html">sh(1p)</a>).  The <i>SHELL</i> environment variable shall
       not affect the value of the <b>SHELL </b>macro. If <b>SHELL </b>is defined in
       the makefile or is specified on the command line, it shall
       replace the original value of the <b>SHELL </b>macro, but shall not
       affect the <i>SHELL</i> environment variable. Other effects of defining
       <b>SHELL </b>in the makefile or on the command line are implementation-
       defined.

   <b>Inference Rules</b>
       Inference rules are formatted as follows:

           <i>target</i>:
           &lt;tab&gt;<i>command</i>
           <b>[</b>&lt;tab&gt;<i>command</i><b>]</b>
           ...

           <i>line that does not begin with</i> &lt;tab&gt; <i>or</i> #

       The application shall ensure that the <i>target</i> portion is a valid
       target name (see <i>Target Rules</i>) of the form <b>.s2 </b>or <b>.s1.s2 </b>(where
       <b>.s1 </b>and <b>.s2 </b>are suffixes that have been given as prerequisites of
       the <b>.SUFFIXES </b>special target and <i>s1</i> and <i>s2</i> do not contain any
       &lt;slash&gt; or &lt;period&gt; characters.) If there is only one &lt;period&gt; in
       the target, it is a single-suffix inference rule. Targets with
       two periods are double-suffix inference rules. Inference rules
       can have only one target before the &lt;colon&gt;.

       The application shall ensure that the makefile does not specify
       prerequisites for inference rules; no characters other than white
       space shall follow the &lt;colon&gt; in the first line, except when
       creating the <i>empty rule,</i> described below. Prerequisites are
       inferred, as described below.

       Inference rules can be redefined. A target that matches an
       existing inference rule shall overwrite the old inference rule.
       An empty rule can be created with a command consisting of simply
       a &lt;semicolon&gt; (that is, the rule still exists and is found during
       inference rule search, but since it is empty, execution has no
       effect). The empty rule can also be formatted as follows:

           <i>rule</i>: ;

       where zero or more &lt;blank&gt; characters separate the &lt;colon&gt; and
       &lt;semicolon&gt;.

       The <i>make</i> utility uses the suffixes of targets and their
       prerequisites to infer how a target can be made up-to-date. A
       list of inference rules defines the commands to be executed. By
       default, <i>make</i> contains a built-in set of inference rules.
       Additional rules can be specified in the makefile.

       The special target <b>.SUFFIXES </b>contains as its prerequisites a list
       of suffixes that shall be used by the inference rules. The order
       in which the suffixes are specified defines the order in which
       the inference rules for the suffixes are used. New suffixes shall
       be appended to the current list by specifying a <b>.SUFFIXES </b>special
       target in the makefile. A <b>.SUFFIXES </b>target with no prerequisites
       shall clear the list of suffixes. An empty <b>.SUFFIXES </b>target
       followed by a new <b>.SUFFIXES </b>list is required to change the order
       of the suffixes.

       Normally, the user would provide an inference rule for each
       suffix.  The inference rule to update a target with a suffix <b>.s1</b>
       from a prerequisite with a suffix <b>.s2 </b>is specified as a target
       <b>.s2.s1</b>.  The internal macros provide the means to specify general
       inference rules (see <i>Internal Macros</i>).

       When no target rule is found to update a target, the inference
       rules shall be checked. The suffix of the target (<b>.s1</b>) to be
       built is compared to the list of suffixes specified by the
       <b>.SUFFIXES </b>special targets. If the <b>.s1 </b>suffix is found in
       <b>.SUFFIXES</b>, the inference rules shall be searched in the order
       defined for the first <b>.s2.s1 </b>rule whose prerequisite file (<b>$*.s2</b>)
       exists. If the target is out-of-date with respect to this
       prerequisite, the commands for that inference rule shall be
       executed.

       If the target to be built does not contain a suffix and there is
       no rule for the target, the single suffix inference rules shall
       be checked. The single-suffix inference rules define how to build
       a target if a file is found with a name that matches the target
       name with one of the single suffixes appended. A rule with one
       suffix <b>.s2 </b>is the definition of how to build <i>target</i> from
       <b>target.s2</b>.  The other suffix (<b>.s1</b>) is treated as null.

       A &lt;tilde&gt; (<b>'~'</b>) in the above rules refers to an SCCS file in the
       current directory.  Thus, the rule <b>.c~.o </b>would transform an SCCS
       C-language source file into an object file (<b>.o</b>).  Because the <b>s.</b>
       of the SCCS files is a prefix, it is incompatible with <i>make</i>'s
       suffix point of view. Hence, the <b>'~' </b>is a way of changing any
       file reference into an SCCS file reference.

   <b>Libraries</b>
       If a target or prerequisite contains parentheses, it shall be
       treated as a member of an archive library. For the <i>lib</i>(<i>member</i><b>.o</b>)
       expression <i>lib</i> refers to the name of the archive library and
       <i>member</i><b>.o </b>to the member name. The application shall ensure that
       the member is an object file with the <b>.o </b>suffix. The modification
       time of the expression is the modification time for the member as
       kept in the archive library; see <a href="ar.1p.html">ar(1p)</a>.  The <b>.a </b>suffix shall
       refer to an archive library. The <b>.s2.a </b>rule shall be used to
       update a member in the library from a file with a suffix <b>.s2</b>.

   <b>Internal Macros</b>
       The <i>make</i> utility shall maintain five internal macros that can be
       used in target and inference rules. In order to clearly define
       the meaning of these macros, some clarification of the terms
       <i>target rule</i>, <i>inference rule</i>, <i>target</i>, and <i>prerequisite</i> is
       necessary.

       Target rules are specified by the user in a makefile for a
       particular target. Inference rules are user-specified or <i>make</i>-
       specified rules for a particular class of target name. Explicit
       prerequisites are those prerequisites specified in a makefile on
       target lines.  Implicit prerequisites are those prerequisites
       that are generated when inference rules are used. Inference rules
       are applied to implicit prerequisites or to explicit
       prerequisites that do not have target rules defined for them in
       the makefile. Target rules are applied to targets specified in
       the makefile.

       Before any target in the makefile is updated, each of its
       prerequisites (both explicit and implicit) shall be updated. This
       shall be accomplished by recursively processing each
       prerequisite. Upon recursion, each prerequisite shall become a
       target itself. Its prerequisites in turn shall be processed
       recursively until a target is found that has no prerequisites, or
       further recursion would require applying two inference rules one
       immediately after the other, at which point the recursion shall
       stop. As an extension, implementations may continue recursion
       when two or more successive inference rules need to be applied;
       however, if there are multiple different chains of such rules
       that could be used to create the target, it is unspecified which
       chain is used. The recursion shall then back up, updating each
       target as it goes.

       In the definitions that follow, the word <i>target</i> refers to one of:

        *  A target specified in the makefile

        *  An explicit prerequisite specified in the makefile that
           becomes the target when <i>make</i> processes it during recursion

        *  An implicit prerequisite that becomes a target when <i>make</i>
           processes it during recursion

       In the definitions that follow, the word <i>prerequisite</i> refers to
       one of the following:

        *  An explicit prerequisite specified in the makefile for a
           particular target

        *  An implicit prerequisite generated as a result of locating an
           appropriate inference rule and corresponding file that
           matches the suffix of the target

       The five internal macros are:

       $@      The $@ shall evaluate to the full target name of the
               current target, or the archive filename part of a library
               archive target. It shall be evaluated for both target and
               inference rules.

               For example, in the <b>.c.a </b>inference rule, $@ represents
               the out-of-date <b>.a </b>file to be built. Similarly, in a
               makefile target rule to build <b>lib.a </b>from <b>file.c</b>, $@
               represents the out-of-date <b>lib.a</b>.

       $%      The $% macro shall be evaluated only when the current
               target is an archive library member of the form
               <i>libname</i>(<i>member</i><b>.o</b>).  In these cases, $@ shall evaluate to
               <i>libname</i> and $% shall evaluate to <i>member</i><b>.o</b>.  The $% macro
               shall be evaluated for both target and inference rules.

               For example, in a makefile target rule to build
               <b>lib.a</b>(<b>file.o</b>), $% represents <b>file.o</b>, as opposed to $@,
               which represents <b>lib.a</b>.

       $?      The $? macro shall evaluate to the list of prerequisites
               that are newer than the current target. It shall be
               evaluated for both target and inference rules.

               For example, in a makefile target rule to build <i>prog</i> from
               <b>file1.o</b>, <b>file2.o</b>, and <b>file3.o</b>, and where <i>prog</i> is not out-
               of-date with respect to <b>file1.o</b>, but is out-of-date with
               respect to <b>file2.o </b>and <b>file3.o</b>, $? represents <b>file2.o </b>and
               <b>file3.o</b>.

       $&lt;      In an inference rule, the $&lt; macro shall evaluate to the
               filename whose existence allowed the inference rule to be
               chosen for the target.  In the <b>.DEFAULT </b>rule, the $&lt;
               macro shall evaluate to the current target name. The
               meaning of the $&lt; macro shall be otherwise unspecified.

               For example, in the <b>.c.a </b>inference rule, $&lt; represents
               the prerequisite <b>.c </b>file.

       $*      The $* macro shall evaluate to the current target name
               with its suffix deleted. It shall be evaluated at least
               for inference rules.

               For example, in the <b>.c.a </b>inference rule, $*.o represents
               the out-of-date <b>.o </b>file that corresponds to the
               prerequisite <b>.c </b>file.

       Each of the internal macros has an alternative form. When an
       uppercase <b>'D' </b>or <b>'F' </b>is appended to any of the macros, the
       meaning shall be changed to the <i>directory part</i> for <b>'D' </b>and
       <i>filename part</i> for <b>'F'</b>.  The directory part is the path prefix of
       the file without a trailing &lt;slash&gt;; for the current directory,
       the directory part is <b>'.'</b>.  When the $? macro contains more than
       one prerequisite filename, the $(?D) and $(?F) (or ${?D} and
       ${?F}) macros expand to a list of directory name parts and
       filename parts respectively.

       For the target <i>lib</i>(<i>member</i><b>.o</b>) and the <b>s2.a </b>rule, the internal
       macros shall be defined as:

       $&lt;      <i>member</i><b>.s2</b>

       $*      <i>member</i>

       $@      <i>lib</i>

       $?      <i>member</i><b>.s2</b>

       $%      <i>member</i><b>.o</b>

   <b>Default Rules</b>
       The default rules for <i>make</i> shall achieve results that are the
       same as if the following were used.  Implementations that do not
       support the C-Language Development Utilities option may omit <b>CC</b>,
       <b>CFLAGS</b>, <b>YACC</b>, <b>YFLAGS</b>, <b>LEX</b>, <b>LFLAGS</b>, <b>LDFLAGS</b>, and the <b>.c</b>, <b>.y</b>, and
       <b>.l </b>inference rules. Implementations that do not support FORTRAN
       may omit <b>FC</b>, <b>FFLAGS</b>, and the <b>.f </b>inference rules. Implementations
       may provide additional macros and rules.

           <i>SPECIAL TARGETS</i>

           .SCCS_GET: sccs $(SCCSFLAGS) get $(SCCSGETFLAGS) $@

           .SUFFIXES: .o .c .y .l .a .sh .f .c~ .y~ .l~ .sh~ .f~

           <i>MACROS</i>

           MAKE=make
           AR=ar
           ARFLAGS=-rv
           YACC=yacc
           YFLAGS=
           LEX=lex
           LFLAGS=
           LDFLAGS=
           CC=c99
           CFLAGS=-O 1
           FC=fort77
           FFLAGS=-O 1
           GET=get
           GFLAGS=
           SCCSFLAGS=
           SCCSGETFLAGS=-s

           <i>SINGLE SUFFIX RULES</i>

           .c:
               $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $&lt;

           .f:
               $(FC) $(FFLAGS) $(LDFLAGS) -o $@ $&lt;

           .sh:
               cp $&lt; $@
               chmod a+x $@

           .c~:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.c
               $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $*.c

           .f~:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.f
               $(FC) $(FFLAGS) $(LDFLAGS) -o $@ $*.f

           .sh~:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.sh
               cp $*.sh $@
               chmod a+x $@

           <i>DOUBLE SUFFIX RULES</i>

           .c.o:
               $(CC) $(CFLAGS) -c $&lt;

           .f.o:
               $(FC) $(FFLAGS) -c $&lt;

           .y.o:
               $(YACC) $(YFLAGS) $&lt;
               $(CC) $(CFLAGS) -c y.tab.c
               rm -f y.tab.c
               mv y.tab.o $@

           .l.o:
               $(LEX) $(LFLAGS) $&lt;
               $(CC) $(CFLAGS) -c lex.yy.c
               rm -f lex.yy.c
               mv lex.yy.o $@

           .y.c:
               $(YACC) $(YFLAGS) $&lt;
               mv y.tab.c $@

           .l.c:
               $(LEX) $(LFLAGS) $&lt;
               mv lex.yy.c $@

           .c~.o:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.c
               $(CC) $(CFLAGS) -c $*.c

           .f~.o:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.f
               $(FC) $(FFLAGS) -c $*.f

           .y~.o:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.y
               $(YACC) $(YFLAGS) $*.y
               $(CC) $(CFLAGS) -c y.tab.c
               rm -f y.tab.c
               mv y.tab.o $@

           .l~.o:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.l
               $(LEX) $(LFLAGS) $*.l
               $(CC) $(CFLAGS) -c lex.yy.c
               rm -f lex.yy.c
               mv lex.yy.o $@

           .y~.c:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.y
               $(YACC) $(YFLAGS) $*.y
               mv y.tab.c $@

           .l~.c:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.l
               $(LEX) $(LFLAGS) $*.l
               mv lex.yy.c $@

           .c.a:
               $(CC) -c $(CFLAGS) $&lt;
               $(AR) $(ARFLAGS) $@ $*.o
               rm -f $*.o

           .f.a:
               $(FC) -c $(FFLAGS) $&lt;
               $(AR) $(ARFLAGS) $@ $*.o
               rm -f $*.o
</pre> <h2>
EXIT STATUS </h2>
<pre>
       When the <b>-q </b>option is specified, the <i>make</i> utility shall exit with
       one of the following values:

        0    Successful completion.

        1    The target was not up-to-date.

       &gt;1    An error occurred.

       When the <b>-q </b>option is not specified, the <i>make</i> utility shall exit
       with one of the following values:

        0    Successful completion.

       &gt;0    An error occurred.
</pre> <h2>
CONSEQUENCES OF ERRORS </h2>
<pre>
       Default.

       <i>The following sections are informative.</i>
</pre> <h2>
APPLICATION USAGE </h2>
<pre>
       If there is a source file (such as <b>./source.c</b>) and there are two
       SCCS files corresponding to it (<b>./s.source.c </b>and
       <b>./SCCS/s.source.c</b>), on XSI-conformant systems <i>make</i> uses the SCCS
       file in the current directory. However, users are advised to use
       the underlying SCCS utilities (<i>admin</i>, <i>delta</i>, <i>get</i>, and so on) or
       the <i>sccs</i> utility for all source files in a given directory. If
       both forms are used for a given source file, future developers
       are very likely to be confused.

       It is incumbent upon portable makefiles to specify the <b>.POSIX</b>
       special target in order to guarantee that they are not affected
       by local extensions.

       The <b>-k </b>and <b>-S </b>options are both present so that the relationship
       between the command line, the <i>MAKEFLAGS</i> variable, and the
       makefile can be controlled precisely. If the <b>k </b>flag is passed in
       <i>MAKEFLAGS</i> and a command is of the form:

           $(MAKE) -S foo

       then the default behavior is restored for the child <i>make</i>.

       When the <b>-n </b>option is specified, it is always added to <i>MAKEFLAGS</i>.
       This allows a recursive <i>make</i> <b>-n </b><i>target</i> to be used to see all of
       the action that would be taken to update <i>target</i>.

       Because of widespread historical practice, interpreting a
       &lt;number-sign&gt; (<b>'#'</b>) inside a variable as the start of a comment
       has the unfortunate side-effect of making it impossible to place
       a &lt;number-sign&gt; in a variable, thus forbidding something like:

           CFLAGS = "-D COMMENT_CHAR='#'"

       Many historical <i>make</i> utilities stop chaining together inference
       rules when an intermediate target is nonexistent. For example, it
       might be possible for a <i>make</i> to determine that both <b>.y.c </b>and <b>.c.o</b>
       could be used to convert a <b>.y </b>to a <b>.o</b>.  Instead, in this case,
       <i>make</i> requires the use of a <b>.y.o </b>rule.

       The best way to provide portable makefiles is to include all of
       the rules needed in the makefile itself. The rules provided use
       only features provided by other parts of this volume of
       POSIX.1‐2017. The default rules include rules for optional
       commands in this volume of POSIX.1‐2017. Only rules pertaining to
       commands that are provided are needed in an implementation's
       default set.

       Macros used within other macros are evaluated when the new macro
       is used rather than when the new macro is defined. Therefore:

           MACRO = <i>value1</i>
           NEW   = $(MACRO)
           MACRO = <i>value2</i>

           target:
               echo $(NEW)

       would produce <i>value2</i> and not <i>value1</i> since <b>NEW </b>was not expanded
       until it was needed in the <i>echo</i> command line.

       Some historical applications have been known to intermix
       <i>target_name</i> and <i>macro=name</i> operands on the command line,
       expecting that all of the macros are processed before any of the
       targets are dealt with. Conforming applications do not do this,
       although some backwards-compatibility support may be included in
       some implementations.

       The following characters in filenames may give trouble: <b>'='</b>, <b>':'</b>,
       <b>'`'</b>, single-quote, and <b>'@'</b>.  In include filenames, pattern
       matching characters and <b>'"' </b>should also be avoided, as they may
       be treated as special by some implementations.

       For inference rules, the description of $&lt; and $? seem similar.
       However, an example shows the minor difference. In a makefile
       containing:

           foo.o: foo.h

       if <b>foo.h </b>is newer than <b>foo.o</b>, yet <b>foo.c </b>is older than <b>foo.o</b>, the
       built-in rule to make <b>foo.o </b>from <b>foo.c </b>is used, with $&lt; equal to
       <b>foo.c </b>and $? equal to <b>foo.h</b>.  If <b>foo.c </b>is also newer than <b>foo.o</b>,
       $&lt; is equal to <b>foo.c </b>and $? is equal to <b>foo.h foo.c</b>.

       As a consequence of the general rules for target updating, a
       useful special case is that if a target has no prerequisites and
       no commands, and the target of the rule is a nonexistent file,
       then <i>make</i> acts as if this target has been updated whenever its
       rule is run.

       <b>Note:  </b>This implies that all targets depending on this one will
              always have their commands run.

       Shell command sequences like <i>make; cp original copy; make</i> may
       have problems on filesystems where the timestamp resolution is
       the minimum (1 second) required by the standard and where <i>make</i>
       considers identical timestamps to be up-to-date. Conversely,
       rules like <i>copy: original; cp -p original copy</i> will result in
       redundant work on <i>make</i> implementations that consider identical
       timestamps to be out-of-date.

       This standard does not specify precedence between macro
       definition and include directives. Thus, the behavior of:

           include =foo.mk

       is unspecified. To define a variable named include, either the
       white space before the &lt;equal-sign&gt; should be removed, or another
       macro should be used, as in:

           INCLUDE_NAME = include
           $(INCLUDE_NAME) =foo.mk

       On the other hand, if the intent is to include a file which
       starts with an &lt;equal-sign&gt;, either the filename should be
       changed to <i>./=foo.mk</i>, or the makefile should be written as:

           INCLUDE_FILE = =foo.mk
           include $(INCLUDE_FILE)
</pre> <h2>
EXAMPLES </h2>
<pre>
        1. The following command:

               make

           makes the first target found in the makefile.

        2. The following command:

               make junk

           makes the target <b>junk</b>.

        3. The following makefile says that <b>pgm </b>depends on two files,
           <b>a.o </b>and <b>b.o</b>, and that they in turn depend on their
           corresponding source files (<b>a.c </b>and <b>b.c</b>), and a common file
           <b>incl.h</b>:

               .POSIX:
               pgm: a.o b.o
                   c99 a.o b.o -o pgm
               a.o: incl.h a.c
                   c99 -c a.c
               b.o: incl.h b.c
                   c99 -c b.c

        4. An example for making optimized <b>.o </b>files from <b>.c </b>files is:

               .c.o:
                   c99 -c -O 1 $*.c

           or:

               .c.o:
                   c99 -c -O 1 $&lt;

        5. The most common use of the archive interface follows. Here,
           it is assumed that the source files are all C-language
           source:

               lib: lib(file1.o) lib(file2.o) lib(file3.o)
                   @echo lib is now up-to-date

           The <b>.c.a </b>rule is used to make <b>file1.o</b>, <b>file2.o</b>, and <b>file3.o</b>
           and insert them into <b>lib</b>.

           The treatment of escaped &lt;newline&gt; characters throughout the
           makefile is historical practice. For example, the inference
           rule:

               .c.o\
               :

           works, and the macro:

               f=  bar baz\
                   biz
               a:
                   echo ==$f==

           echoes <b>"==bar baz biz=="</b>.

           If $? were:

               /usr/include/stdio.h /usr/include/unistd.h foo.h

           then $(?D) would be:

               /usr/include /usr/include .

           and $(?F) would be:

               stdio.h unistd.h foo.h

        6. The contents of the built-in rules can be viewed by running:

               make -p -f /dev/null 2&gt;/dev/null
</pre> <h2>
RATIONALE </h2>
<pre>
       The <i>make</i> utility described in this volume of POSIX.1‐2017 is
       intended to provide the means for changing portable source code
       into executables that can be run on an POSIX.1‐2008-conforming
       system. It reflects the most common features present in System V
       and BSD <i>make</i>s.

       Historically, the <i>make</i> utility has been an especially fertile
       ground for vendor and research organization-specific syntax
       modifications and extensions. Examples include:

        *  Syntax supporting parallel execution (such as from various
           multi-processor vendors, GNU, and others)

        *  Additional ``operators'' separating targets and their
           prerequisites (System V, BSD, and others)

        *  Specifying that command lines containing the strings
           <b>"${MAKE}" </b>and <b>"$(MAKE)" </b>are executed when the <b>-n </b>option is
           specified (GNU and System V)

        *  Modifications of the meaning of internal macros when
           referencing libraries (BSD and others)

        *  Using a single instance of the shell for all of the command
           lines of the target (BSD and others)

        *  Allowing &lt;space&gt; characters as well as &lt;tab&gt; characters to
           delimit command lines (BSD)

        *  Adding C preprocessor-style ``include'' and ``ifdef''
           constructs (System V, GNU, BSD, and others)

        *  Remote execution of command lines (Sprite and others)

        *  Specifying additional special targets (BSD, System V, and
           most others)

        *  Specifying an alternate shell to use to process commands.

       Additionally, many vendors and research organizations have
       rethought the basic concepts of <i>make</i>, creating vastly extended,
       as well as completely new, syntaxes. Each of these versions of
       <i>make</i> fulfills the needs of a different community of users; it is
       unreasonable for this volume of POSIX.1‐2017 to require behavior
       that would be incompatible (and probably inferior) to historical
       practice for such a community.

       In similar circumstances, when the industry has enough
       sufficiently incompatible formats as to make them irreconcilable,
       this volume of POSIX.1‐2017 has followed one or both of two
       courses of action. Commands have been renamed (<i>cksum</i>, <i>echo</i>, and
       <i>pax</i>) and/or command line options have been provided to select the
       desired behavior (<i>grep</i>, <i>od</i>, and <i>pax</i>).

       Because the syntax specified for the <i>make</i> utility is, by and
       large, a subset of the syntaxes accepted by almost all versions
       of <i>make</i>, it was decided that it would be counter-productive to
       change the name.  And since the makefile itself is a basic unit
       of portability, it would not be completely effective to reserve a
       new option letter, such as <i>make</i> <b>-P</b>, to achieve the portable
       behavior. Therefore, the special target <b>.POSIX </b>was added to the
       makefile, allowing users to specify ``standard'' behavior. This
       special target does not preclude extensions in the <i>make</i> utility,
       nor does it preclude such extensions being used by the makefile
       specifying the target; it does, however, preclude any extensions
       from being applied that could alter the behavior of previously
       valid syntax; such extensions must be controlled via command line
       options or new special targets. It is incumbent upon portable
       makefiles to specify the <b>.POSIX </b>special target in order to
       guarantee that they are not affected by local extensions.

       The portable version of <i>make</i> described in this reference page is
       not intended to be the state-of-the-art software generation tool
       and, as such, some newer and more leading-edge features have not
       been included. An attempt has been made to describe the portable
       makefile in a manner that does not preclude such extensions as
       long as they do not disturb the portable behavior described here.

       When the <b>-n </b>option is specified, it is always added to <i>MAKEFLAGS</i>.
       This allows a recursive <i>make</i> <b>-n </b><i>target</i> to be used to see all of
       the action that would be taken to update <i>target</i>.

       The definition of <i>MAKEFLAGS</i> allows both the System V letter
       string and the BSD command line formats. The two formats are
       sufficiently different to allow implementations to support both
       without ambiguity.

       Early proposals stated that an ``unquoted'' &lt;number-sign&gt; was
       treated as the start of a comment. The <i>make</i> utility does not pay
       any attention to quotes. A &lt;number-sign&gt; starts a comment
       regardless of its surroundings.

       The text about ``other implementation-defined pathnames may also
       be tried'' in addition to <b>./makefile </b>and <b>./Makefile </b>is to allow
       such extensions as <b>SCCS/s.Makefile </b>and other variations. It was
       made an implementation-defined requirement (as opposed to
       unspecified behavior) to highlight surprising implementations
       that might select something unexpected like <b>/etc/Makefile</b>.  XSI-
       conformant systems also try <b>./s.makefile</b>, <b>SCCS/s.makefile</b>,
       <b>./s.Makefile</b>, and <b>SCCS/s.Makefile</b>.

       Early proposals contained the macro <b>NPROC </b>as a means of
       specifying that <i>make</i> should use <i>n</i> processes to do the work
       required. While this feature is a valuable extension for many
       systems, it is not common usage and could require other non-
       trivial extensions to makefile syntax. This extension is not
       required by this volume of POSIX.1‐2017, but could be provided as
       a compatible extension. The macro <b>PARALLEL </b>is used by some
       historical systems with essentially the same meaning (but without
       using a name that is a common system limit value). It is
       suggested that implementors recognize the existing use of <b>NPROC</b>
       and/or <b>PARALLEL </b>as extensions to <i>make</i>.

       The default rules are based on System V. The default <b>CC= </b>value is
       <i>c99</i> instead of <i>cc</i> because this volume of POSIX.1‐2017 does not
       standardize the utility named <i>cc</i>.  Thus, every conforming
       application would be required to define <b>CC=</b><i>c99</i> to expect to run.
       There is no advantage conferred by the hope that the makefile
       might hit the ``preferred'' compiler because this cannot be
       guaranteed to work. Also, since the portable makescript can only
       use the <i>c99</i> options, no advantage is conferred in terms of what
       the script can do.  It is a quality-of-implementation issue as to
       whether <i>c99</i> is as valuable as <i>cc</i>.

       The <b>-d </b>option to <i>make</i> is frequently used to produce debugging
       information, but is too implementation-defined to add to this
       volume of POSIX.1‐2017.

       The <b>-p </b>option is not passed in <i>MAKEFLAGS</i> on most historical
       implementations and to change this would cause many
       implementations to break without sufficiently increased
       portability.

       Commands that begin with a &lt;plus-sign&gt; (<b>'+'</b>) are executed even if
       the <b>-n </b>option is present. Based on the GNU version of <i>make</i>, the
       behavior of <b>-n </b>when the &lt;plus-sign&gt; prefix is encountered has
       been extended to apply to <b>-q </b>and <b>-t </b>as well. However, the System
       V convention of forcing command execution with <b>-n </b>when the
       command line of a target contains either of the strings <b>"$(MAKE)"</b>
       or <b>"${MAKE}" </b>has not been adopted. This functionality appeared in
       early proposals, but the danger of this approach was pointed out
       with the following example of a portion of a makefile:

           subdir:
               cd subdir; rm all_the_files; $(MAKE)

       The loss of the System V behavior in this case is well-balanced
       by the safety afforded to other makefiles that were not aware of
       this situation. In any event, the command line &lt;plus-sign&gt; prefix
       can provide the desired functionality.

       The double &lt;colon&gt; in the target rule format is supported in BSD
       systems to allow more than one target line containing the same
       target name to have commands associated with it. Since this is
       not functionality described in the SVID or XPG3 it has been
       allowed as an extension, but not mandated.

       The default rules are provided with text specifying that the
       built-in rules shall be the same as if the listed set were used.
       The intent is that implementations should be able to use the
       rules without change, but will be allowed to alter them in ways
       that do not affect the primary behavior.

       One point of discussion was whether to drop the default rules
       list from this volume of POSIX.1‐2017. They provide convenience,
       but do not enhance portability of applications. The prime benefit
       is in portability of users who wish to type <i>make command</i> and have
       the command build from a <b>command.c </b>file.

       The historical <i>MAKESHELL</i> feature, and related features provided
       by other <i>make</i> implementations, were omitted. In some
       implementations it is used to let a user override the shell to be
       used to run <i>make</i> commands. This was confusing; for a portable
       <i>make</i>, the shell should be chosen by the makefile writer. Further,
       a makefile writer cannot require an alternate shell to be used
       and still consider the makefile portable. While it would be
       possible to standardize a mechanism for specifying an alternate
       shell, existing implementations do not agree on such a mechanism,
       and makefile writers can already invoke an alternate shell by
       specifying the shell name in the rule for a target; for example:

           python -c "foo"

       The <i>make</i> utilities in most historical implementations process the
       prerequisites of a target in left-to-right order, and the
       makefile format requires this. It supports the standard idiom
       used in many makefiles that produce <i>yacc</i> programs; for example:

           foo: y.tab.o lex.o main.o
               $(CC) $(CFLAGS) -o $@ t.tab.o lex.o main.o

       In this example, if <i>make</i> chose any arbitrary order, the <b>lex.o</b>
       might not be made with the correct <b>y.tab.h</b>.  Although there may
       be better ways to express this relationship, it is widely used
       historically. Implementations that desire to update prerequisites
       in parallel should require an explicit extension to <i>make</i> or the
       makefile format to accomplish it, as described previously.

       The algorithm for determining a new entry for target rules is
       partially unspecified. Some historical <i>make</i>s allow comment lines
       (including blank and empty lines) within the collection of
       commands marked by leading &lt;tab&gt; characters. A conforming
       makefile must ensure that each command starts with a &lt;tab&gt;, but
       implementations are free to ignore comments without triggering
       the start of a new entry.

       The ASYNCHRONOUS EVENTS section includes having SIGTERM and
       SIGHUP, along with the more traditional SIGINT and SIGQUIT,
       remove the current target unless directed not to do so. SIGTERM
       and SIGHUP were added to parallel other utilities that have
       historically cleaned up their work as a result of these signals.
       When <i>make</i> receives any signal other than SIGQUIT, it is required
       to resend itself the signal it received so that it exits with a
       status that reflects the signal. The results from SIGQUIT are
       partially unspecified because, on systems that create <b>core </b>files
       upon receipt of SIGQUIT, the <b>core </b>from <i>make</i> would conflict with a
       <b>core </b>file from the command that was running when the SIGQUIT
       arrived. The main concern was to prevent damaged files from
       appearing up-to-date when <i>make</i> is rerun.

       The <b>.PRECIOUS </b>special target was extended to affect all targets
       globally (by specifying no prerequisites). The <b>.IGNORE </b>and
       <b>.SILENT </b>special targets were extended to allow prerequisites; it
       was judged to be more useful in some cases to be able to turn off
       errors or echoing for a list of targets than for the entire
       makefile. These extensions to <i>make</i> in System V were made to match
       historical practice from the BSD <i>make</i>.

       Macros are not exported to the environment of commands to be run.
       This was never the case in any historical <i>make</i> and would have
       serious consequences. The environment is the same as the
       environment to <i>make</i> except that <i>MAKEFLAGS</i> and macros defined on
       the <i>make</i> command line are added, and except that macros defined
       by the <i>MAKEFLAGS</i> environment variable and macros defined in the
       makefile(s) may update the value of an existing environment
       variable (other than <i>SHELL</i>).

       Some implementations do not use <i>system</i>() for all command lines,
       as required by the portable makefile format; as a performance
       enhancement, they select lines without shell metacharacters for
       direct execution by <i>execve</i>().  There is no requirement that
       <i>system</i>() be used specifically, but merely that the same results
       be achieved.  The metacharacters typically used to bypass the
       direct <i>execve</i>() execution have been any of:

           =  |  ^  (  )  ;  &amp;  &lt;  &gt;  *  ?  [  ]  :  $  `  '  "  \  \n

       The default in some advanced versions of <i>make</i> is to group all the
       command lines for a target and execute them using a single shell
       invocation; the System V method is to pass each line individually
       to a separate shell. The single-shell method has the advantages
       in performance and the lack of a requirement for many continued
       lines. However, converting to this newer method has caused
       portability problems with many historical makefiles, so the
       behavior with the POSIX makefile is specified to be the same as
       that of System V. It is suggested that the special target
       <b>.ONESHELL </b>be used as an implementation extension to achieve the
       single-shell grouping for a target or group of targets.

       Novice users of <i>make</i> have had difficulty with the historical need
       to start commands with a &lt;tab&gt;.  Since it is often difficult to
       discern differences between &lt;tab&gt; and &lt;space&gt; characters on
       terminals or printed listings, confusing bugs can arise. In early
       proposals, an attempt was made to correct this problem by
       allowing leading &lt;blank&gt; characters instead of &lt;tab&gt; characters.
       However, implementors reported many makefiles that failed in
       subtle ways following this change, and it is difficult to
       implement a <i>make</i> that unambiguously can differentiate between
       macro and command lines.  There is extensive historical practice
       of allowing leading &lt;space&gt; characters before macro definitions.
       Forcing macro lines into column 1 would be a significant
       backwards-compatibility problem for some makefiles.  Therefore,
       historical practice was restored.

       There is substantial variation in the handling of include lines
       by different implementations. However, there is enough
       commonality for the standard to be able to specify a minimum set
       of requirements that allow the feature to be used portably. Known
       variations have been explicitly called out as unspecified
       behavior in the description.

       The System V dynamic dependency feature was not included. It
       would support:

           cat: $$@.c

       that would expand to;

           cat: cat.c

       This feature exists only in the new version of System V <i>make</i> and,
       while useful, is not in wide usage. This means that macros are
       expanded twice for prerequisites: once at makefile parse time and
       once at target update time.

       Consideration was given to adding metarules to the POSIX <i>make</i>.
       This would make <b>%.o: %.c </b>the same as <b>.c.o:</b>.  This is quite useful
       and available from some vendors, but it would cause too many
       changes to this <i>make</i> to support. It would have introduced rule
       chaining and new substitution rules. However, the rules for
       target names have been set to reserve the <b>'%' </b>and <b>'"' </b>characters.
       These are traditionally used to implement metarules and quoting
       of target names, respectively. Implementors are strongly
       encouraged to use these characters only for these purposes.

       A request was made to extend the suffix delimiter character from
       a &lt;period&gt; to any character. The metarules feature in newer <i>make</i>s
       solves this problem in a more general way. This volume of
       POSIX.1‐2017 is staying with the more conservative historical
       definition.

       The standard output format for the <b>-p </b>option is not described
       because it is primarily a debugging option and because the format
       is not generally useful to programs. In historical
       implementations the output is not suitable for use in generating
       makefiles. The <b>-p </b>format has been variable across historical
       implementations. Therefore, the definition of <b>-p </b>was only to
       provide a consistently named option for obtaining <i>make</i> script
       debugging information.

       Some historical implementations have not cleared the suffix list
       with <b>-r</b>.

       Implementations should be aware that some historical applications
       have intermixed <i>target_name</i> and <i>macro</i>=<i>value</i> operands on the
       command line, expecting that all of the macros are processed
       before any of the targets are dealt with. Conforming applications
       do not do this, but some backwards-compatibility support may be
       warranted.

       Empty inference rules are specified with a &lt;semicolon&gt; command
       rather than omitting all commands, as described in an early
       proposal. The latter case has no traditional meaning and is
       reserved for implementation extensions, such as in GNU <i>make</i>.

       Earlier versions of this standard defined comment lines only as
       lines with <b>'#' </b>as the first character. Many places then talked
       about comments, blank lines, and empty lines; but some places
       inadvertently only mentioned comments when blank lines and empty
       lines had also been accepted in all known implementations. The
       standard now defines comment lines to be blank lines, empty
       lines, and lines starting with a <b>'#' </b>character and explictily
       lists cases where blank lines and empty lines are not acceptable.

       On most historic systems, the <i>make</i> utility considered a target
       with a prerequisite that had an identical timestamp as up-to-
       date. The HP-UX implementation of <i>make</i> treated it as out-of-date.
       The standard now allows either behavior, but implementations are
       encouraged to follow the example set by HP-UX.  This is
       especially important on file systems where the timestamp
       resolution is the minimum (1 second) required by the standard.
       All implementations of <i>make</i> should make full use of the finest
       timestamp resolution available on the file systems holding
       targets and prerequisites to ensure that targets are up-to-date
       even for prerequisite files with timestamps that were updated
       within the same second. However, if the timestamp resolutions of
       the file systems containing a target and a prerequisite are
       different, the timestamp with the more precise resolution should
       be rounded down to the resolution of the less precise timestamp
       for the comparison.
</pre> <h2>
FUTURE DIRECTIONS </h2>
<pre>
       Some implementations of <i>make</i> include an <i>export</i> directive to add
       specified <i>make</i> variables to the environment. This may be
       considered for standardization in a future version.

       A future version of this standard may require that macro
       expansions using the forms $(<i>string1</i><b>:[</b><i>op</i><b>]%[</b><i>os</i><b>]=[</b><i>np</i><b>][%][</b><i>ns</i><b>]</b>) or
       ${<i>string1</i><b>:[</b><i>op</i><b>]%[</b><i>os</i><b>]=[</b><i>np</i><b>][%][</b><i>ns</i><b>]</b>} are treated as pattern macro
       expansions.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <i>Chapter 2</i>, <i>Shell Command Language</i>, <a href="ar.1p.html">ar(1p)</a>, <a href="c99.1p.html">c99(1p)</a>, <a href="get.1p.html">get(1p)</a>,
       <a href="lex.1p.html">lex(1p)</a>, <a href="sccs.1p.html">sccs(1p)</a>, <a href="sh.1p.html">sh(1p)</a>, <a href="yacc.1p.html">yacc(1p)</a>

       The Base Definitions volume of POSIX.1‐2017, <i>Section 6.1</i>,
       <i>Portable Character Set</i>, <i>Chapter 8</i>, <i>Environment Variables</i>, <i>Section</i>
       <i>12.2</i>, <i>Utility Syntax Guidelines</i>

       The System Interfaces volume of POSIX.1‐2017, <a href="exec.1p.html">exec(1p)</a>,
       <a href="../man3/system.3p.html">system(3p)</a>
</pre> <h2>
COPYRIGHT </h2>
<pre>
       Portions of this text are reprinted and reproduced in electronic
       form from IEEE Std 1003.1-2017, Standard for Information
       Technology -- Portable Operating System Interface (POSIX), The
       Open Group Base Specifications Issue 7, 2018 Edition, Copyright
       (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any
       discrepancy between this version and the original IEEE and The
       Open Group Standard, the original IEEE and The Open Group
       Standard is the referee document. The original Standard can be
       obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page
       are most likely to have been introduced during the conversion of
       the source files to man page format. To report such errors, see
       <a href="https://www.kernel.org/doc/man-pages/reporting_bugs.html">https://www.kernel.org/doc/man-pages/reporting_bugs.html</a> .

<span class="footline">IEEE/The Open Group               2017                          <i>MAKE</i>(1P)</span>
</pre>  <p>Pages that refer to this page: <a href="c99.1p.html">c99(1p)</a>, <a href="sccs.1p.html">sccs(1p)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man1/make.1p.html" class="_attribution-link">https://man7.org/linux/man-pages/man1/make.1p.html</a>
  </p>
</div>
