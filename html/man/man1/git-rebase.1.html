<h1>git-rebase(1) — Linux manual page</h1>   <pre>
<span class="headline"><i>GIT-REBASE</i>(1)                  Git Manual                  <i>GIT-REBASE</i>(1)</span>
</pre> <h2>
NAME </h2>
<pre>
       git-rebase - Reapply commits on top of another base tip
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <i>git rebase</i> [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;]
               [--onto &lt;newbase&gt; | --keep-base] [&lt;upstream&gt; [&lt;branch&gt;]]
       <i>git rebase</i> [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]
               --root [&lt;branch&gt;]
       <i>git rebase</i> (--continue|--skip|--abort|--quit|--edit-todo|--show-current-patch)
</pre> <h2>
DESCRIPTION </h2>
<pre>
       If <b>&lt;branch&gt; </b>is specified, <b>git rebase </b>will perform an automatic
       <b>git switch &lt;branch&gt; </b>before doing anything else. Otherwise it
       remains on the current branch.

       If <b>&lt;upstream&gt; </b>is not specified, the upstream configured in
       <b>branch.&lt;name&gt;.remote </b>and <b>branch.&lt;name&gt;.merge </b>options will be used
       (see <a href="git-config.1.html">git-config(1)</a> for details) and the <b>--fork-point </b>option is
       assumed. If you are currently not on any branch or if the current
       branch does not have a configured upstream, the rebase will
       abort.

       All changes made by commits in the current branch but that are
       not in <b>&lt;upstream&gt; </b>are saved to a temporary area. This is the same
       set of commits that would be shown by <b>git log &lt;upstream&gt;..HEAD</b>;
       or by <b>git log 'fork_point'..HEAD</b>, if <b>--fork-point </b>is active (see
       the description on <b>--fork-point </b>below); or by <b>git log HEAD</b>, if
       the <b>--root </b>option is specified.

       The current branch is reset to <b>&lt;upstream&gt; </b>or <b>&lt;newbase&gt; </b>if the
       <b>--onto </b>option was supplied. This has the exact same effect as <b>git</b>
       <b>reset --hard &lt;upstream&gt; </b>(or <b>&lt;newbase&gt;</b>). <b>ORIG_HEAD </b>is set to point
       at the tip of the branch before the reset.

           <b>Note</b>

           <b>ORIG_HEAD </b>is not guaranteed to still point to the previous
           branch tip at the end of the rebase if other commands that
           write that pseudo-ref (e.g. <b>git reset</b>) are used during the
           rebase. The previous branch tip, however, is accessible using
           the reflog of the current branch (i.e. <b>@{1}</b>, see
           <a href="../man7/gitrevisions.7.html">gitrevisions(7)</a>).

       The commits that were previously saved into the temporary area
       are then reapplied to the current branch, one by one, in order.
       Note that any commits in <b>HEAD </b>which introduce the same textual
       changes as a commit in <b>HEAD..&lt;upstream&gt; </b>are omitted (i.e., a
       patch already accepted upstream with a different commit message
       or timestamp will be skipped).

       It is possible that a merge failure will prevent this process
       from being completely automatic. You will have to resolve any
       such merge failure and run <b>git rebase --continue</b>. Another option
       is to bypass the commit that caused the merge failure with <b>git</b>
       <b>rebase --skip</b>. To check out the original <b>&lt;branch&gt; </b>and remove the
       <b>.git/rebase-apply </b>working files, use the command <b>git rebase</b>
       <b>--abort </b>instead.

       Assume the following history exists and the current branch is
       "topic":

                     A---B---C topic
                    /
               D---E---F---G master

       From this point, the result of either of the following commands:

           git rebase master
           git rebase master topic

       would be:

                             A'--B'--C' topic
                            /
               D---E---F---G master

       <b>NOTE: </b>The latter form is just a short-hand of <b>git checkout topic</b>
       followed by <b>git rebase master</b>. When rebase exits <b>topic </b>will
       remain the checked-out branch.

       If the upstream branch already contains a change you have made
       (e.g., because you mailed a patch which was applied upstream),
       then that commit will be skipped and warnings will be issued (if
       the <i>merge</i> backend is used). For example, running <b>git rebase</b>
       <b>master </b>on the following history (in which <b>A' </b>and <b>A </b>introduce the
       same set of changes, but have different committer information):

                     A---B---C topic
                    /
               D---E---A'---F master

       will result in:

                              B'---C' topic
                             /
               D---E---A'---F master

       Here is how you would transplant a topic branch based on one
       branch to another, to pretend that you forked the topic branch
       from the latter branch, using <b>rebase --onto</b>.

       First let’s assume your <i>topic</i> is based on branch <i>next</i>. For
       example, a feature developed in <i>topic</i> depends on some
       functionality which is found in <i>next</i>.

               o---o---o---o---o  master
                    \
                     o---o---o---o---o  next
                                      \
                                       o---o---o  topic

       We want to make <i>topic</i> forked from branch <i>master</i>; for example,
       because the functionality on which <i>topic</i> depends was merged into
       the more stable <i>master</i> branch. We want our tree to look like
       this:

               o---o---o---o---o  master
                   |            \
                   |             o'--o'--o'  topic
                    \
                     o---o---o---o---o  next

       We can get this using the following command:

           git rebase --onto master next topic

       Another example of --onto option is to rebase part of a branch.
       If we have the following situation:

                                       H---I---J topicB
                                      /
                             E---F---G  topicA
                            /
               A---B---C---D  master

       then the command

           git rebase --onto master topicA topicB

       would result in:

                            H'--I'--J'  topicB
                           /
                           | E---F---G  topicA
                           |/
               A---B---C---D  master

       This is useful when topicB does not depend on topicA.

       A range of commits could also be removed with rebase. If we have
       the following situation:

               E---F---G---H---I---J  topicA

       then the command

           git rebase --onto topicA~5 topicA~3 topicA

       would result in the removal of commits F and G:

               E---H'---I'---J'  topicA

       This is useful if F and G were flawed in some way, or should not
       be part of topicA. Note that the argument to <b>--onto </b>and the
       <b>&lt;upstream&gt; </b>parameter can be any valid commit-ish.

       In case of conflict, <b>git rebase </b>will stop at the first
       problematic commit and leave conflict markers in the tree. You
       can use <b>git diff </b>to locate the markers (&lt;&lt;&lt;&lt;&lt;&lt;) and make edits to
       resolve the conflict. For each file you edit, you need to tell
       Git that the conflict has been resolved, typically this would be
       done with

           git add &lt;filename&gt;

       After resolving the conflict manually and updating the index with
       the desired resolution, you can continue the rebasing process
       with

           git rebase --continue

       Alternatively, you can undo the <i>git rebase</i> with

           git rebase --abort
</pre> <h2>
MODE OPTIONS </h2>
<pre>
       The options in this section cannot be used with any other option,
       including not with each other:

       --continue
           Restart the rebasing process after having resolved a merge
           conflict.

       --skip
           Restart the rebasing process by skipping the current patch.

       --abort
           Abort the rebase operation and reset HEAD to the original
           branch. If <b>&lt;branch&gt; </b>was provided when the rebase operation
           was started, then <b>HEAD </b>will be reset to <b>&lt;branch&gt;</b>. Otherwise
           <b>HEAD </b>will be reset to where it was when the rebase operation
           was started.

       --quit
           Abort the rebase operation but <b>HEAD </b>is not reset back to the
           original branch. The index and working tree are also left
           unchanged as a result. If a temporary stash entry was created
           using <b>--autostash</b>, it will be saved to the stash list.

       --edit-todo
           Edit the todo list during an interactive rebase.

       --show-current-patch
           Show the current patch in an interactive rebase or when
           rebase is stopped because of conflicts. This is the
           equivalent of <b>git show REBASE_HEAD</b>.
</pre> <h2>
OPTIONS </h2>
<pre>
       --onto &lt;newbase&gt;
           Starting point at which to create the new commits. If the
           <b>--onto </b>option is not specified, the starting point is
           <b>&lt;upstream&gt;</b>. May be any valid commit, and not just an existing
           branch name.

           As a special case, you may use "A...B" as a shortcut for the
           merge base of A and B if there is exactly one merge base. You
           can leave out at most one of A and B, in which case it
           defaults to HEAD.

       --keep-base
           Set the starting point at which to create the new commits to
           the merge base of <b>&lt;upstream&gt; </b>and <b>&lt;branch&gt;</b>. Running <b>git rebase</b>
           <b>--keep-base &lt;upstream&gt; &lt;branch&gt; </b>is equivalent to running <b>git</b>
           <b>rebase --reapply-cherry-picks --no-fork-point --onto</b>
           <b>&lt;upstream&gt;...&lt;branch&gt; &lt;upstream&gt; &lt;branch&gt;</b>.

           This option is useful in the case where one is developing a
           feature on top of an upstream branch. While the feature is
           being worked on, the upstream branch may advance and it may
           not be the best idea to keep rebasing on top of the upstream
           but to keep the base commit as-is. As the base commit is
           unchanged this option implies <b>--reapply-cherry-picks </b>to avoid
           losing commits.

           Although both this option and <b>--fork-point </b>find the merge
           base between <b>&lt;upstream&gt; </b>and <b>&lt;branch&gt;</b>, this option uses the
           merge base as the <i>starting point</i> on which new commits will be
           created, whereas <b>--fork-point </b>uses the merge base to
           determine the <i>set of commits</i> which will be rebased.

           See also INCOMPATIBLE OPTIONS below.

       &lt;upstream&gt;
           Upstream branch to compare against. May be any valid commit,
           not just an existing branch name. Defaults to the configured
           upstream for the current branch.

       &lt;branch&gt;
           Working branch; defaults to <b>HEAD</b>.

       --apply
           Use applying strategies to rebase (calling <b>git-am</b>
           internally). This option may become a no-op in the future
           once the merge backend handles everything the apply one does.

           See also INCOMPATIBLE OPTIONS below.

       --empty=(drop|keep|stop)
           How to handle commits that are not empty to start and are not
           clean cherry-picks of any upstream commit, but which become
           empty after rebasing (because they contain a subset of
           already upstream changes):

           <b>drop</b>
               The commit will be dropped. This is the default behavior.

           <b>keep</b>
               The commit will be kept. This option is implied when
               <b>--exec </b>is specified unless <b>-i</b>/<b>--interactive </b>is also
               specified.

           <b>stop</b>, <b>ask</b>
               The rebase will halt when the commit is applied, allowing
               you to choose whether to drop it, edit files more, or
               just commit the empty changes. This option is implied
               when <b>-i</b>/<b>--interactive </b>is specified.  <b>ask </b>is a deprecated
               synonym of <b>stop</b>.

           Note that commits which start empty are kept (unless
           <b>--no-keep-empty </b>is specified), and commits which are clean
           cherry-picks (as determined by <b>git log --cherry-mark ...</b>) are
           detected and dropped as a preliminary step (unless
           <b>--reapply-cherry-picks </b>or <b>--keep-base </b>is passed).

           See also INCOMPATIBLE OPTIONS below.

       --no-keep-empty, --keep-empty
           Do not keep commits that start empty before the rebase (i.e.
           that do not change anything from its parent) in the result.
           The default is to keep commits which start empty, since
           creating such commits requires passing the <b>--allow-empty</b>
           override flag to <b>git commit</b>, signifying that a user is very
           intentionally creating such a commit and thus wants to keep
           it.

           Usage of this flag will probably be rare, since you can get
           rid of commits that start empty by just firing up an
           interactive rebase and removing the lines corresponding to
           the commits you don’t want. This flag exists as a convenient
           shortcut, such as for cases where external tools generate
           many empty commits and you want them all removed.

           For commits which do not start empty but become empty after
           rebasing, see the <b>--empty </b>flag.

           See also INCOMPATIBLE OPTIONS below.

       --reapply-cherry-picks, --no-reapply-cherry-picks
           Reapply all clean cherry-picks of any upstream commit instead
           of preemptively dropping them. (If these commits then become
           empty after rebasing, because they contain a subset of
           already upstream changes, the behavior towards them is
           controlled by the <b>--empty </b>flag.)

           In the absence of <b>--keep-base </b>(or if
           <b>--no-reapply-cherry-picks </b>is given), these commits will be
           automatically dropped. Because this necessitates reading all
           upstream commits, this can be expensive in repositories with
           a large number of upstream commits that need to be read. When
           using the <i>merge</i> backend, warnings will be issued for each
           dropped commit (unless <b>--quiet </b>is given). Advice will also be
           issued unless <b>advice.skippedCherryPicks </b>is set to false (see
           <a href="git-config.1.html">git-config(1)</a>).

           <b>--reapply-cherry-picks </b>allows rebase to forgo reading all
           upstream commits, potentially improving performance.

           See also INCOMPATIBLE OPTIONS below.

       --allow-empty-message
           No-op. Rebasing commits with an empty message used to fail
           and this option would override that behavior, allowing
           commits with empty messages to be rebased. Now commits with
           an empty message do not cause rebasing to halt.

           See also INCOMPATIBLE OPTIONS below.

       -m, --merge
           Using merging strategies to rebase (default).

           Note that a rebase merge works by replaying each commit from
           the working branch on top of the <b>&lt;upstream&gt; </b>branch. Because
           of this, when a merge conflict happens, the side reported as
           <i>ours</i> is the so-far rebased series, starting with <b>&lt;upstream&gt;</b>,
           and <i>theirs</i> is the working branch. In other words, the sides
           are swapped.

           See also INCOMPATIBLE OPTIONS below.

       -s &lt;strategy&gt;, --strategy=&lt;strategy&gt;
           Use the given merge strategy, instead of the default <b>ort</b>.
           This implies <b>--merge</b>.

           Because <b>git rebase </b>replays each commit from the working
           branch on top of the <b>&lt;upstream&gt; </b>branch using the given
           strategy, using the <b>ours </b>strategy simply empties all patches
           from the <b>&lt;branch&gt;</b>, which makes little sense.

           See also INCOMPATIBLE OPTIONS below.

       -X &lt;strategy-option&gt;, --strategy-option=&lt;strategy-option&gt;
           Pass the &lt;strategy-option&gt; through to the merge strategy.
           This implies <b>--merge </b>and, if no strategy has been specified,
           <b>-s ort</b>. Note the reversal of <i>ours</i> and <i>theirs</i> as noted above
           for the <b>-m </b>option.

           See also INCOMPATIBLE OPTIONS below.

       --rerere-autoupdate, --no-rerere-autoupdate
           After the rerere mechanism reuses a recorded resolution on
           the current conflict to update the files in the working tree,
           allow it to also update the index with the result of
           resolution.  <b>--no-rerere-autoupdate </b>is a good way to
           double-check what <b>rerere </b>did and catch potential mismerges,
           before committing the result to the index with a separate <b>git</b>
           <b>add</b>.

       -S[&lt;keyid&gt;], --gpg-sign[=&lt;keyid&gt;], --no-gpg-sign
           GPG-sign commits. The <b>keyid </b>argument is optional and defaults
           to the committer identity; if specified, it must be stuck to
           the option without a space.  <b>--no-gpg-sign </b>is useful to
           countermand both <b>commit.gpgSign </b>configuration variable, and
           earlier <b>--gpg-sign</b>.

       -q, --quiet
           Be quiet. Implies <b>--no-stat</b>.

       -v, --verbose
           Be verbose. Implies <b>--stat</b>.

       --stat
           Show a diffstat of what changed upstream since the last
           rebase. The diffstat is also controlled by the configuration
           option rebase.stat.

       -n, --no-stat
           Do not show a diffstat as part of the rebase process.

       --no-verify
           This option bypasses the pre-rebase hook. See also
           <a href="../man5/githooks.5.html">githooks(5)</a>.

       --verify
           Allows the pre-rebase hook to run, which is the default. This
           option can be used to override <b>--no-verify</b>. See also
           <a href="../man5/githooks.5.html">githooks(5)</a>.

       -C&lt;n&gt;
           Ensure at least <b>&lt;n&gt; </b>lines of surrounding context match before
           and after each change. When fewer lines of surrounding
           context exist they all must match. By default no context is
           ever ignored. Implies <b>--apply</b>.

           See also INCOMPATIBLE OPTIONS below.

       --no-ff, --force-rebase, -f
           Individually replay all rebased commits instead of
           fast-forwarding over the unchanged ones. This ensures that
           the entire history of the rebased branch is composed of new
           commits.

           You may find this helpful after reverting a topic branch
           merge, as this option recreates the topic branch with fresh
           commits so it can be remerged successfully without needing to
           "revert the reversion" (see the <b>revert-a-faulty-merge</b>
           <b>How-To</b>[1] for details).

       --fork-point, --no-fork-point
           Use reflog to find a better common ancestor between
           <b>&lt;upstream&gt; </b>and <b>&lt;branch&gt; </b>when calculating which commits have
           been introduced by <b>&lt;branch&gt;</b>.

           When <b>--fork-point </b>is active, <i>fork_point</i> will be used instead
           of <b>&lt;upstream&gt; </b>to calculate the set of commits to rebase,
           where <i>fork_point</i> is the result of <b>git merge-base --fork-point</b>
           <b>&lt;upstream&gt; &lt;branch&gt; </b>command (see <a href="git-merge-base.1.html">git-merge-base(1)</a>). If
           <i>fork_point</i> ends up being empty, the <b>&lt;upstream&gt; </b>will be used
           as a fallback.

           If <b>&lt;upstream&gt; </b>or <b>--keep-base </b>is given on the command line,
           then the default is <b>--no-fork-point</b>, otherwise the default is
           <b>--fork-point</b>. See also <b>rebase.forkpoint </b>in <a href="git-config.1.html">git-config(1)</a>.

           If your branch was based on <b>&lt;upstream&gt; </b>but <b>&lt;upstream&gt; </b>was
           rewound and your branch contains commits which were dropped,
           this option can be used with <b>--keep-base </b>in order to drop
           those commits from your branch.

           See also INCOMPATIBLE OPTIONS below.

       --ignore-whitespace
           Ignore whitespace differences when trying to reconcile
           differences. Currently, each backend implements an
           approximation of this behavior:

           apply backend
               When applying a patch, ignore changes in whitespace in
               context lines. Unfortunately, this means that if the
               "old" lines being replaced by the patch differ only in
               whitespace from the existing file, you will get a merge
               conflict instead of a successful patch application.

           merge backend
               Treat lines with only whitespace changes as unchanged
               when merging. Unfortunately, this means that any patch
               hunks that were intended to modify whitespace and nothing
               else will be dropped, even if the other side had no
               changes that conflicted.

       --whitespace=&lt;option&gt;
           This flag is passed to the <b>git apply </b>program (see
           <a href="git-apply.1.html">git-apply(1)</a>) that applies the patch. Implies <b>--apply</b>.

           See also INCOMPATIBLE OPTIONS below.

       --committer-date-is-author-date
           Instead of using the current time as the committer date, use
           the author date of the commit being rebased as the committer
           date. This option implies <b>--force-rebase</b>.

       --ignore-date, --reset-author-date
           Instead of using the author date of the original commit, use
           the current time as the author date of the rebased commit.
           This option implies <b>--force-rebase</b>.

           See also INCOMPATIBLE OPTIONS below.

       --signoff
           Add a <b>Signed-off-by </b>trailer to all the rebased commits. Note
           that if <b>--interactive </b>is given then only commits marked to be
           picked, edited or reworded will have the trailer added.

           See also INCOMPATIBLE OPTIONS below.

       -i, --interactive
           Make a list of the commits which are about to be rebased. Let
           the user edit that list before rebasing. This mode can also
           be used to split commits (see SPLITTING COMMITS below).

           The commit list format can be changed by setting the
           configuration option rebase.instructionFormat. A customized
           instruction format will automatically have the commit hash
           prepended to the format.

           See also INCOMPATIBLE OPTIONS below.

       -r, --rebase-merges[=(rebase-cousins|no-rebase-cousins)],
       --no-rebase-merges
           By default, a rebase will simply drop merge commits from the
           todo list, and put the rebased commits into a single, linear
           branch. With <b>--rebase-merges</b>, the rebase will instead try to
           preserve the branching structure within the commits that are
           to be rebased, by recreating the merge commits. Any resolved
           merge conflicts or manual amendments in these merge commits
           will have to be resolved/re-applied manually.
           <b>--no-rebase-merges </b>can be used to countermand both the
           <b>rebase.rebaseMerges </b>config option and a previous
           <b>--rebase-merges</b>.

           When rebasing merges, there are two modes: <b>rebase-cousins </b>and
           <b>no-rebase-cousins</b>. If the mode is not specified, it defaults
           to <b>no-rebase-cousins</b>. In <b>no-rebase-cousins </b>mode, commits
           which do not have <b>&lt;upstream&gt; </b>as direct ancestor will keep
           their original branch point, i.e. commits that would be
           excluded by <a href="git-log.1.html">git-log(1)</a>'s <b>--ancestry-path </b>option will keep
           their original ancestry by default. In <b>rebase-cousins </b>mode,
           such commits are instead rebased onto <b>&lt;upstream&gt; </b>(or <b>&lt;onto&gt;</b>,
           if specified).

           It is currently only possible to recreate the merge commits
           using the <b>ort </b>merge strategy; different merge strategies can
           be used only via explicit <b>exec git merge -s &lt;strategy&gt; [...]</b>
           commands.

           See also REBASING MERGES and INCOMPATIBLE OPTIONS below.

       -x &lt;cmd&gt;, --exec &lt;cmd&gt;
           Append "exec &lt;cmd&gt;" after each line creating a commit in the
           final history.  <b>&lt;cmd&gt; </b>will be interpreted as one or more
           shell commands. Any command that fails will interrupt the
           rebase, with exit code 1.

           You may execute several commands by either using one instance
           of <b>--exec </b>with several commands:

               git rebase -i --exec "cmd1 &amp;&amp; cmd2 &amp;&amp; ..."

           or by giving more than one <b>--exec</b>:

               git rebase -i --exec "cmd1" --exec "cmd2" --exec ...

           If <b>--autosquash </b>is used, <b>exec </b>lines will not be appended for
           the intermediate commits, and will only appear at the end of
           each squash/fixup series.

           This uses the <b>--interactive </b>machinery internally, but it can
           be run without an explicit <b>--interactive</b>.

           See also INCOMPATIBLE OPTIONS below.

       --root
           Rebase all commits reachable from <b>&lt;branch&gt;</b>, instead of
           limiting them with an <b>&lt;upstream&gt;</b>. This allows you to rebase
           the root commit(s) on a branch.

           See also INCOMPATIBLE OPTIONS below.

       --autosquash, --no-autosquash
           Automatically squash commits with specially formatted
           messages into previous commits being rebased. If a commit
           message starts with "squash! ", "fixup! " or "amend! ", the
           remainder of the subject line is taken as a commit specifier,
           which matches a previous commit if it matches the subject
           line or the hash of that commit. If no commit matches fully,
           matches of the specifier with the start of commit subjects
           are considered.

           In the rebase todo list, the actions of squash, fixup and
           amend commits are changed from <b>pick </b>to <b>squash</b>, <b>fixup </b>or <b>fixup</b>
           <b>-C</b>, respectively, and they are moved right after the commit
           they modify. The <b>--interactive </b>option can be used to review
           and edit the todo list before proceeding.

           The recommended way to create commits with squash markers is
           by using the <b>--squash</b>, <b>--fixup</b>, <b>--fixup=amend: </b>or
           <b>--fixup=reword: </b>options of <a href="git-commit.1.html">git-commit(1)</a>, which take the
           target commit as an argument and automatically fill in the
           subject line of the new commit from that.

           Setting configuration variable <b>rebase.autoSquash </b>to true
           enables auto-squashing by default for interactive rebase. The
           <b>--no-autosquash </b>option can be used to override that setting.

           See also INCOMPATIBLE OPTIONS below.

       --autostash, --no-autostash
           Automatically create a temporary stash entry before the
           operation begins, and apply it after the operation ends. This
           means that you can run rebase on a dirty worktree. However,
           use with care: the final stash application after a successful
           rebase might result in non-trivial conflicts.

       --reschedule-failed-exec, --no-reschedule-failed-exec
           Automatically reschedule <b>exec </b>commands that failed. This only
           makes sense in interactive mode (or when an <b>--exec </b>option was
           provided).

           This option applies once a rebase is started. It is preserved
           for the whole rebase based on, in order, the command line
           option provided to the initial <b>git rebase</b>, the
           <b>rebase.rescheduleFailedExec </b>configuration (see <a href="git-config.1.html">git-config(1)</a>
           or "CONFIGURATION" below), or it defaults to false.

           Recording this option for the whole rebase is a convenience
           feature. Otherwise an explicit <b>--no-reschedule-failed-exec </b>at
           the start would be overridden by the presence of a
           <b>rebase.rescheduleFailedExec=true </b>configuration when <b>git</b>
           <b>rebase --continue </b>is invoked. Currently, you cannot pass
           <b>--[no-]reschedule-failed-exec </b>to <b>git rebase --continue</b>.

       --update-refs, --no-update-refs
           Automatically force-update any branches that point to commits
           that are being rebased. Any branches that are checked out in
           a worktree are not updated in this way.

           If the configuration variable <b>rebase.updateRefs </b>is set, then
           this option can be used to override and disable this setting.

           See also INCOMPATIBLE OPTIONS below.
</pre> <h2>
INCOMPATIBLE OPTIONS </h2>
<pre>
       The following options:

       •   --apply

       •   --whitespace

       •   -C

       are incompatible with the following options:

       •   --merge

       •   --strategy

       •   --strategy-option

       •   --autosquash

       •   --rebase-merges

       •   --interactive

       •   --exec

       •   --no-keep-empty

       •   --empty=

       •   --[no-]reapply-cherry-picks when used without --keep-base

       •   --update-refs

       •   --root when used without --onto

       In addition, the following pairs of options are incompatible:

       •   --keep-base and --onto

       •   --keep-base and --root

       •   --fork-point and --root
</pre> <h2>
BEHAVIORAL DIFFERENCES </h2>
<pre>
       <b>git rebase </b>has two primary backends: <i>apply</i> and <i>merge</i>. (The <i>apply</i>
       backend used to be known as the <i>am</i> backend, but the name led to
       confusion as it looks like a verb instead of a noun. Also, the
       <i>merge</i> backend used to be known as the interactive backend, but it
       is now used for non-interactive cases as well. Both were renamed
       based on lower-level functionality that underpinned each.) There
       are some subtle differences in how these two backends behave:

   <b>Empty commits</b>
       The <i>apply</i> backend unfortunately drops intentionally empty
       commits, i.e. commits that started empty, though these are rare
       in practice. It also drops commits that become empty and has no
       option for controlling this behavior.

       The <i>merge</i> backend keeps intentionally empty commits by default
       (though with <b>-i </b>they are marked as empty in the todo list editor,
       or they can be dropped automatically with <b>--no-keep-empty</b>).

       Similar to the apply backend, by default the merge backend drops
       commits that become empty unless <b>-i</b>/<b>--interactive </b>is specified
       (in which case it stops and asks the user what to do). The merge
       backend also has an <b>--empty=(drop|keep|stop) </b>option for changing
       the behavior of handling commits that become empty.

   <b>Directory rename detection</b>
       Due to the lack of accurate tree information (arising from
       constructing fake ancestors with the limited information
       available in patches), directory rename detection is disabled in
       the <i>apply</i> backend. Disabled directory rename detection means that
       if one side of history renames a directory and the other adds new
       files to the old directory, then the new files will be left
       behind in the old directory without any warning at the time of
       rebasing that you may want to move these files into the new
       directory.

       Directory rename detection works with the <i>merge</i> backend to
       provide you warnings in such cases.

   <b>Context</b>
       The <i>apply</i> backend works by creating a sequence of patches (by
       calling <b>format-patch </b>internally), and then applying the patches
       in sequence (calling <b>am </b>internally). Patches are composed of
       multiple hunks, each with line numbers, a context region, and the
       actual changes. The line numbers have to be taken with some fuzz,
       since the other side will likely have inserted or deleted lines
       earlier in the file. The context region is meant to help find how
       to adjust the line numbers in order to apply the changes to the
       right lines. However, if multiple areas of the code have the same
       surrounding lines of context, the wrong one can be picked. There
       are real-world cases where this has caused commits to be
       reapplied incorrectly with no conflicts reported. Setting
       <b>diff.context </b>to a larger value may prevent such types of
       problems, but increases the chance of spurious conflicts (since
       it will require more lines of matching context to apply).

       The <i>merge</i> backend works with a full copy of each relevant file,
       insulating it from these types of problems.

   <b>Labelling of conflicts markers</b>
       When there are content conflicts, the merge machinery tries to
       annotate each side’s conflict markers with the commits where the
       content came from. Since the <i>apply</i> backend drops the original
       information about the rebased commits and their parents (and
       instead generates new fake commits based off limited information
       in the generated patches), those commits cannot be identified;
       instead it has to fall back to a commit summary. Also, when
       <b>merge.conflictStyle </b>is set to <b>diff3 </b>or <b>zdiff3</b>, the <i>apply</i> backend
       will use "constructed merge base" to label the content from the
       merge base, and thus provide no information about the merge base
       commit whatsoever.

       The <i>merge</i> backend works with the full commits on both sides of
       history and thus has no such limitations.

   <b>Hooks</b>
       The <i>apply</i> backend has not traditionally called the post-commit
       hook, while the <i>merge</i> backend has. Both have called the
       post-checkout hook, though the <i>merge</i> backend has squelched its
       output. Further, both backends only call the post-checkout hook
       with the starting point commit of the rebase, not the
       intermediate commits nor the final commit. In each case, the
       calling of these hooks was by accident of implementation rather
       than by design (both backends were originally implemented as
       shell scripts and happened to invoke other commands like <b>git</b>
       <b>checkout </b>or <b>git commit </b>that would call the hooks). Both backends
       should have the same behavior, though it is not entirely clear
       which, if any, is correct. We will likely make rebase stop
       calling either of these hooks in the future.

   <b>Interruptability</b>
       The <i>apply</i> backend has safety problems with an ill-timed
       interrupt; if the user presses Ctrl-C at the wrong time to try to
       abort the rebase, the rebase can enter a state where it cannot be
       aborted with a subsequent <b>git rebase --abort</b>. The <i>merge</i> backend
       does not appear to suffer from the same shortcoming. (See
       <b>https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/ </b>for
       details.)

   <b>Commit Rewording</b>
       When a conflict occurs while rebasing, rebase stops and asks the
       user to resolve. Since the user may need to make notable changes
       while resolving conflicts, after conflicts are resolved and the
       user has run <b>git rebase --continue</b>, the rebase should open an
       editor and ask the user to update the commit message. The <i>merge</i>
       backend does this, while the <i>apply</i> backend blindly applies the
       original commit message.

   <b>Miscellaneous differences</b>
       There are a few more behavioral differences that most folks would
       probably consider inconsequential but which are mentioned for
       completeness:

       •   Reflog: The two backends will use different wording when
           describing the changes made in the reflog, though both will
           make use of the word "rebase".

       •   Progress, informational, and error messages: The two backends
           provide slightly different progress and informational
           messages. Also, the apply backend writes error messages (such
           as "Your files would be overwritten...") to stdout, while the
           merge backend writes them to stderr.

       •   State directories: The two backends keep their state in
           different directories under <b>.git/</b>
</pre> <h2>
MERGE STRATEGIES </h2>
<pre>
       The merge mechanism (<b>git merge </b>and <b>git pull </b>commands) allows the
       backend <i>merge strategies</i> to be chosen with <b>-s </b>option. Some
       strategies can also take their own options, which can be passed
       by giving <b>-X&lt;option&gt; </b>arguments to <b>git merge </b>and/or <b>git pull</b>.

       ort
           This is the default merge strategy when pulling or merging
           one branch. This strategy can only resolve two heads using a
           3-way merge algorithm. When there is more than one common
           ancestor that can be used for 3-way merge, it creates a
           merged tree of the common ancestors and uses that as the
           reference tree for the 3-way merge. This has been reported to
           result in fewer merge conflicts without causing mismerges by
           tests done on actual merge commits taken from Linux 2.6
           kernel development history. Additionally this strategy can
           detect and handle merges involving renames. It does not make
           use of detected copies. The name for this algorithm is an
           acronym ("Ostensibly Recursive’s Twin") and came from the
           fact that it was written as a replacement for the previous
           default algorithm, <b>recursive</b>.

           The <i>ort</i> strategy can take the following options:

           ours
               This option forces conflicting hunks to be auto-resolved
               cleanly by favoring <i>our</i> version. Changes from the other
               tree that do not conflict with our side are reflected in
               the merge result. For a binary file, the entire contents
               are taken from our side.

               This should not be confused with the <i>ours</i> merge strategy,
               which does not even look at what the other tree contains
               at all. It discards everything the other tree did,
               declaring <i>our</i> history contains all that happened in it.

           theirs
               This is the opposite of <i>ours</i>; note that, unlike <i>ours</i>,
               there is no <i>theirs</i> merge strategy to confuse this merge
               option with.

           ignore-space-change, ignore-all-space, ignore-space-at-eol,
           ignore-cr-at-eol
               Treats lines with the indicated type of whitespace change
               as unchanged for the sake of a three-way merge.
               Whitespace changes mixed with other changes to a line are
               not ignored. See also <a href="git-diff.1.html">git-diff(1)</a> <b>-b</b>, <b>-w</b>,
               <b>--ignore-space-at-eol</b>, and <b>--ignore-cr-at-eol</b>.

               •   If <i>their</i> version only introduces whitespace changes
                   to a line, <i>our</i> version is used;

               •   If <i>our</i> version introduces whitespace changes but
                   <i>their</i> version includes a substantial change, <i>their</i>
                   version is used;

               •   Otherwise, the merge proceeds in the usual way.

           renormalize
               This runs a virtual check-out and check-in of all three
               stages of a file when resolving a three-way merge. This
               option is meant to be used when merging branches with
               different clean filters or end-of-line normalization
               rules. See "Merging branches with differing
               checkin/checkout attributes" in <a href="../man5/gitattributes.5.html">gitattributes(5)</a> for
               details.

           no-renormalize
               Disables the <b>renormalize </b>option. This overrides the
               <b>merge.renormalize </b>configuration variable.

           find-renames[=&lt;n&gt;]
               Turn on rename detection, optionally setting the
               similarity threshold. This is the default. This overrides
               the <i>merge.renames</i> configuration variable. See also
               <a href="git-diff.1.html">git-diff(1)</a> <b>--find-renames</b>.

           rename-threshold=&lt;n&gt;
               Deprecated synonym for <b>find-renames=&lt;n&gt;</b>.

           subtree[=&lt;path&gt;]
               This option is a more advanced form of <i>subtree</i> strategy,
               where the strategy makes a guess on how two trees must be
               shifted to match with each other when merging. Instead,
               the specified path is prefixed (or stripped from the
               beginning) to make the shape of two trees to match.

       recursive
           This can only resolve two heads using a 3-way merge
           algorithm. When there is more than one common ancestor that
           can be used for 3-way merge, it creates a merged tree of the
           common ancestors and uses that as the reference tree for the
           3-way merge. This has been reported to result in fewer merge
           conflicts without causing mismerges by tests done on actual
           merge commits taken from Linux 2.6 kernel development
           history. Additionally this can detect and handle merges
           involving renames. It does not make use of detected copies.
           This was the default strategy for resolving two heads from
           Git v0.99.9k until v2.33.0.

           The <i>recursive</i> strategy takes the same options as <i>ort</i>.
           However, there are three additional options that <i>ort</i> ignores
           (not documented above) that are potentially useful with the
           <i>recursive</i> strategy:

           patience
               Deprecated synonym for <b>diff-algorithm=patience</b>.

           diff-algorithm=[patience|minimal|histogram|myers]
               Use a different diff algorithm while merging, which can
               help avoid mismerges that occur due to unimportant
               matching lines (such as braces from distinct functions).
               See also <a href="git-diff.1.html">git-diff(1)</a> <b>--diff-algorithm</b>. Note that <b>ort</b>
               specifically uses <b>diff-algorithm=histogram</b>, while
               <b>recursive </b>defaults to the <b>diff.algorithm </b>config setting.

           no-renames
               Turn off rename detection. This overrides the
               <b>merge.renames </b>configuration variable. See also
               <a href="git-diff.1.html">git-diff(1)</a> <b>--no-renames</b>.

       resolve
           This can only resolve two heads (i.e. the current branch and
           another branch you pulled from) using a 3-way merge
           algorithm. It tries to carefully detect criss-cross merge
           ambiguities. It does not handle renames.

       octopus
           This resolves cases with more than two heads, but refuses to
           do a complex merge that needs manual resolution. It is
           primarily meant to be used for bundling topic branch heads
           together. This is the default merge strategy when pulling or
           merging more than one branch.

       ours
           This resolves any number of heads, but the resulting tree of
           the merge is always that of the current branch head,
           effectively ignoring all changes from all other branches. It
           is meant to be used to supersede old development history of
           side branches. Note that this is different from the -Xours
           option to the <i>recursive</i> merge strategy.

       subtree
           This is a modified <b>ort </b>strategy. When merging trees A and B,
           if B corresponds to a subtree of A, B is first adjusted to
           match the tree structure of A, instead of reading the trees
           at the same level. This adjustment is also done to the common
           ancestor tree.

       With the strategies that use 3-way merge (including the default,
       <i>ort</i>), if a change is made on both branches, but later reverted on
       one of the branches, that change will be present in the merged
       result; some people find this behavior confusing. It occurs
       because only the heads and the merge base are considered when
       performing a merge, not the individual commits. The merge
       algorithm therefore considers the reverted change as no change at
       all, and substitutes the changed version instead.
</pre> <h2>
NOTES </h2>
<pre>
       You should understand the implications of using <b>git rebase </b>on a
       repository that you share. See also RECOVERING FROM UPSTREAM
       REBASE below.

       When the rebase is run, it will first execute a <b>pre-rebase </b>hook
       if one exists. You can use this hook to do sanity checks and
       reject the rebase if it isn’t appropriate. Please see the
       template <b>pre-rebase </b>hook script for an example.

       Upon completion, <b>&lt;branch&gt; </b>will be the current branch.
</pre> <h2>
INTERACTIVE MODE </h2>
<pre>
       Rebasing interactively means that you have a chance to edit the
       commits which are rebased. You can reorder the commits, and you
       can remove them (weeding out bad or otherwise unwanted patches).

       The interactive mode is meant for this type of workflow:

        1. have a wonderful idea

        2. hack on the code

        3. prepare a series for submission

        4. submit

       where point 2. consists of several instances of

       a) regular use

        1. finish something worthy of a commit

        2. commit

       b) independent fixup

        1. realize that something does not work

        2. fix that

        3. commit it

       Sometimes the thing fixed in b.2. cannot be amended to the
       not-quite perfect commit it fixes, because that commit is buried
       deeply in a patch series. That is exactly what interactive rebase
       is for: use it after plenty of "a"s and "b"s, by rearranging and
       editing commits, and squashing multiple commits into one.

       Start it with the last commit you want to retain as-is:

           git rebase -i &lt;after-this-commit&gt;

       An editor will be fired up with all the commits in your current
       branch (ignoring merge commits), which come after the given
       commit. You can reorder the commits in this list to your heart’s
       content, and you can remove them. The list looks more or less
       like this:

           pick deadbee The oneline of this commit
           pick fa1afe1 The oneline of the next commit
           ...

       The oneline descriptions are purely for your pleasure; <i>git rebase</i>
       will not look at them but at the commit names ("deadbee" and
       "fa1afe1" in this example), so do not delete or edit the names.

       By replacing the command "pick" with the command "edit", you can
       tell <b>git rebase </b>to stop after applying that commit, so that you
       can edit the files and/or the commit message, amend the commit,
       and continue rebasing.

       To interrupt the rebase (just like an "edit" command would do,
       but without cherry-picking any commit first), use the "break"
       command.

       If you just want to edit the commit message for a commit, replace
       the command "pick" with the command "reword".

       To drop a commit, replace the command "pick" with "drop", or just
       delete the matching line.

       If you want to fold two or more commits into one, replace the
       command "pick" for the second and subsequent commits with
       "squash" or "fixup". If the commits had different authors, the
       folded commit will be attributed to the author of the first
       commit. The suggested commit message for the folded commit is the
       concatenation of the first commit’s message with those identified
       by "squash" commands, omitting the messages of commits identified
       by "fixup" commands, unless "fixup -c" is used. In that case the
       suggested commit message is only the message of the "fixup -c"
       commit, and an editor is opened allowing you to edit the message.
       The contents (patch) of the "fixup -c" commit are still
       incorporated into the folded commit. If there is more than one
       "fixup -c" commit, the message from the final one is used. You
       can also use "fixup -C" to get the same behavior as "fixup -c"
       except without opening an editor.

       <b>git rebase </b>will stop when "pick" has been replaced with "edit" or
       when a command fails due to merge errors. When you are done
       editing and/or resolving conflicts you can continue with <b>git</b>
       <b>rebase --continue</b>.

       For example, if you want to reorder the last 5 commits, such that
       what was <b>HEAD~4 </b>becomes the new <b>HEAD</b>. To achieve that, you would
       call <b>git rebase </b>like this:

           $ git rebase -i HEAD~5

       And move the first patch to the end of the list.

       You might want to recreate merge commits, e.g. if you have a
       history like this:

                      X
                       \
                    A---M---B
                   /
           ---o---O---P---Q

       Suppose you want to rebase the side branch starting at "A" to
       "Q". Make sure that the current <b>HEAD </b>is "B", and call

           $ git rebase -i -r --onto Q O

       Reordering and editing commits usually creates untested
       intermediate steps. You may want to check that your history
       editing did not break anything by running a test, or at least
       recompiling at intermediate points in history by using the "exec"
       command (shortcut "x"). You may do so by creating a todo list
       like this one:

           pick deadbee Implement feature XXX
           fixup f1a5c00 Fix to feature XXX
           exec make
           pick c0ffeee The oneline of the next commit
           edit deadbab The oneline of the commit after
           exec cd subdir; make test
           ...

       The interactive rebase will stop when a command fails (i.e. exits
       with non-0 status) to give you an opportunity to fix the problem.
       You can continue with <b>git rebase --continue</b>.

       The "exec" command launches the command in a shell (the default
       one, usually /bin/sh), so you can use shell features (like "cd",
       "&gt;", ";" ...). The command is run from the root of the working
       tree.

           $ git rebase -i --exec "make test"

       This command lets you check that intermediate commits are
       compilable. The todo list becomes like that:

           pick 5928aea one
           exec make test
           pick 04d0fda two
           exec make test
           pick ba46169 three
           exec make test
           pick f4593f9 four
           exec make test
</pre> <h2>
SPLITTING COMMITS </h2>
<pre>
       In interactive mode, you can mark commits with the action "edit".
       However, this does not necessarily mean that <b>git rebase </b>expects
       the result of this edit to be exactly one commit. Indeed, you can
       undo the commit, or you can add other commits. This can be used
       to split a commit into two:

       •   Start an interactive rebase with <b>git rebase -i &lt;commit&gt;^</b>,
           where <b>&lt;commit&gt; </b>is the commit you want to split. In fact, any
           commit range will do, as long as it contains that commit.

       •   Mark the commit you want to split with the action "edit".

       •   When it comes to editing that commit, execute <b>git reset</b>
           <b>HEAD^</b>. The effect is that the <b>HEAD </b>is rewound by one, and the
           index follows suit. However, the working tree stays the same.

       •   Now add the changes to the index that you want to have in the
           first commit. You can use <b>git add </b>(possibly interactively) or
           <b>git gui </b>(or both) to do that.

       •   Commit the now-current index with whatever commit message is
           appropriate now.

       •   Repeat the last two steps until your working tree is clean.

       •   Continue the rebase with <b>git rebase --continue</b>.

       If you are not absolutely sure that the intermediate revisions
       are consistent (they compile, pass the testsuite, etc.) you
       should use <b>git stash </b>to stash away the not-yet-committed changes
       after each commit, test, and amend the commit if fixes are
       necessary.
</pre> <h2>
RECOVERING FROM UPSTREAM REBASE </h2>
<pre>
       Rebasing (or any other form of rewriting) a branch that others
       have based work on is a bad idea: anyone downstream of it is
       forced to manually fix their history. This section explains how
       to do the fix from the downstream’s point of view. The real fix,
       however, would be to avoid rebasing the upstream in the first
       place.

       To illustrate, suppose you are in a situation where someone
       develops a <i>subsystem</i> branch, and you are working on a <i>topic</i> that
       is dependent on this <i>subsystem</i>. You might end up with a history
       like the following:

               o---o---o---o---o---o---o---o  master
                    \
                     o---o---o---o---o  subsystem
                                      \
                                       *---*---*  topic

       If <i>subsystem</i> is rebased against <i>master</i>, the following happens:

               o---o---o---o---o---o---o---o  master
                    \                       \
                     o---o---o---o---o       o'--o'--o'--o'--o'  subsystem
                                      \
                                       *---*---*  topic

       If you now continue development as usual, and eventually merge
       <i>topic</i> to <i>subsystem</i>, the commits from <i>subsystem</i> will remain
       duplicated forever:

               o---o---o---o---o---o---o---o  master
                    \                       \
                     o---o---o---o---o       o'--o'--o'--o'--o'--M  subsystem
                                      \                         /
                                       *---*---*-..........-*--*  topic

       Such duplicates are generally frowned upon because they clutter
       up history, making it harder to follow. To clean things up, you
       need to transplant the commits on <i>topic</i> to the new <i>subsystem</i> tip,
       i.e., rebase <i>topic</i>. This becomes a ripple effect: anyone
       downstream from <i>topic</i> is forced to rebase too, and so on!

       There are two kinds of fixes, discussed in the following
       subsections:

       Easy case: The changes are literally the same.
           This happens if the <i>subsystem</i> rebase was a simple rebase and
           had no conflicts.

       Hard case: The changes are not the same.
           This happens if the <i>subsystem</i> rebase had conflicts, or used
           <b>--interactive </b>to omit, edit, squash, or fixup commits; or if
           the upstream used one of <b>commit --amend</b>, <b>reset</b>, or a full
           history rewriting command like <b>filter-repo</b>[2].

   <b>The easy case</b>
       Only works if the changes (patch IDs based on the diff contents)
       on <i>subsystem</i> are literally the same before and after the rebase
       <i>subsystem</i> did.

       In that case, the fix is easy because <i>git rebase</i> knows to skip
       changes that are already present in the new upstream (unless
       <b>--reapply-cherry-picks </b>is given). So if you say (assuming you’re
       on <i>topic</i>)

               $ git rebase subsystem

       you will end up with the fixed history

               o---o---o---o---o---o---o---o  master
                                            \
                                             o'--o'--o'--o'--o'  subsystem
                                                              \
                                                               *---*---*  topic

   <b>The hard case</b>
       Things get more complicated if the <i>subsystem</i> changes do not
       exactly correspond to the ones before the rebase.

           <b>Note</b>

           While an "easy case recovery" sometimes appears to be
           successful even in the hard case, it may have unintended
           consequences. For example, a commit that was removed via <b>git</b>
           <b>rebase --interactive </b>will be <b>resurrected</b>!

       The idea is to manually tell <b>git rebase </b>"where the old <i>subsystem</i>
       ended and your <i>topic</i> began", that is, what the old merge base
       between them was. You will have to find a way to name the last
       commit of the old <i>subsystem</i>, for example:

       •   With the <i>subsystem</i> reflog: after <b>git fetch</b>, the old tip of
           <i>subsystem</i> is at <b>subsystem@{1}</b>. Subsequent fetches will
           increase the number. (See <a href="git-reflog.1.html">git-reflog(1)</a>.)

       •   Relative to the tip of <i>topic</i>: knowing that your <i>topic</i> has
           three commits, the old tip of <i>subsystem</i> must be <b>topic~3</b>.

       You can then transplant the old <b>subsystem..topic </b>to the new tip
       by saying (for the reflog case, and assuming you are on <i>topic</i>
       already):

               $ git rebase --onto subsystem subsystem@{1}

       The ripple effect of a "hard case" recovery is especially bad:
       <i>everyone</i> downstream from <i>topic</i> will now have to perform a "hard
       case" recovery too!
</pre> <h2>
REBASING MERGES </h2>
<pre>
       The interactive rebase command was originally designed to handle
       individual patch series. As such, it makes sense to exclude merge
       commits from the todo list, as the developer may have merged the
       then-current <b>master </b>while working on the branch, only to rebase
       all the commits onto <b>master </b>eventually (skipping the merge
       commits).

       However, there are legitimate reasons why a developer may want to
       recreate merge commits: to keep the branch structure (or "commit
       topology") when working on multiple, inter-related branches.

       In the following example, the developer works on a topic branch
       that refactors the way buttons are defined, and on another topic
       branch that uses that refactoring to implement a "Report a bug"
       button. The output of <b>git log --graph --format=%s -5 </b>may look
       like this:

           *   Merge branch 'report-a-bug'
           |\
           | * Add the feedback button
           * | Merge branch 'refactor-button'
           |\ \
           | |/
           | * Use the Button class for all buttons
           | * Extract a generic Button class from the DownloadButton one

       The developer might want to rebase those commits to a newer
       <b>master </b>while keeping the branch topology, for example when the
       first topic branch is expected to be integrated into <b>master </b>much
       earlier than the second one, say, to resolve merge conflicts with
       changes to the DownloadButton class that made it into <b>master</b>.

       This rebase can be performed using the <b>--rebase-merges </b>option. It
       will generate a todo list looking like this:

           label onto

           # Branch: refactor-button
           reset onto
           pick 123456 Extract a generic Button class from the DownloadButton one
           pick 654321 Use the Button class for all buttons
           label refactor-button

           # Branch: report-a-bug
           reset refactor-button # Use the Button class for all buttons
           pick abcdef Add the feedback button
           label report-a-bug

           reset onto
           merge -C a1b2c3 refactor-button # Merge 'refactor-button'
           merge -C 6f5e4d report-a-bug # Merge 'report-a-bug'

       In contrast to a regular interactive rebase, there are <b>label</b>,
       <b>reset </b>and <b>merge </b>commands in addition to <b>pick </b>ones.

       The <b>label </b>command associates a label with the current HEAD when
       that command is executed. These labels are created as
       worktree-local refs (<b>refs/rewritten/&lt;label&gt;</b>) that will be deleted
       when the rebase finishes. That way, rebase operations in multiple
       worktrees linked to the same repository do not interfere with one
       another. If the <b>label </b>command fails, it is rescheduled
       immediately, with a helpful message how to proceed.

       The <b>reset </b>command resets the HEAD, index and worktree to the
       specified revision. It is similar to an <b>exec git reset --hard</b>
       <b>&lt;label&gt;</b>, but refuses to overwrite untracked files. If the <b>reset</b>
       command fails, it is rescheduled immediately, with a helpful
       message how to edit the todo list (this typically happens when a
       <b>reset </b>command was inserted into the todo list manually and
       contains a typo).

       The <b>merge </b>command will merge the specified revision(s) into
       whatever is HEAD at that time. With <b>-C &lt;original-commit&gt;</b>, the
       commit message of the specified merge commit will be used. When
       the <b>-C </b>is changed to a lower-case <b>-c</b>, the message will be opened
       in an editor after a successful merge so that the user can edit
       the message.

       If a <b>merge </b>command fails for any reason other than merge
       conflicts (i.e. when the merge operation did not even start), it
       is rescheduled immediately.

       By default, the <b>merge </b>command will use the <b>ort </b>merge strategy for
       regular merges, and <b>octopus </b>for octopus merges. One can specify a
       default strategy for all merges using the <b>--strategy </b>argument
       when invoking rebase, or can override specific merges in the
       interactive list of commands by using an <b>exec </b>command to call <b>git</b>
       <b>merge </b>explicitly with a <b>--strategy </b>argument. Note that when
       calling <b>git merge </b>explicitly like this, you can make use of the
       fact that the labels are worktree-local refs (the ref
       <b>refs/rewritten/onto </b>would correspond to the label <b>onto</b>, for
       example) in order to refer to the branches you want to merge.

       Note: the first command (<b>label onto</b>) labels the revision onto
       which the commits are rebased; The name <b>onto </b>is just a
       convention, as a nod to the <b>--onto </b>option.

       It is also possible to introduce completely new merge commits
       from scratch by adding a command of the form <b>merge &lt;merge-head&gt;</b>.
       This form will generate a tentative commit message and always
       open an editor to let the user edit it. This can be useful e.g.
       when a topic branch turns out to address more than a single
       concern and wants to be split into two or even more topic
       branches. Consider this todo list:

           pick 192837 Switch from GNU Makefiles to CMake
           pick 5a6c7e Document the switch to CMake
           pick 918273 Fix detection of OpenSSL in CMake
           pick afbecd <a href="http:%20add%20support%20for%20TLS%20v1.3">http: add support for TLS v1.3</a>
           pick fdbaec Fix detection of cURL in CMake on Windows

       The one commit in this list that is not related to CMake may very
       well have been motivated by working on fixing all those bugs
       introduced by switching to CMake, but it addresses a different
       concern. To split this branch into two topic branches, the todo
       list could be edited like this:

           label onto

           pick afbecd <a href="http:%20add%20support%20for%20TLS%20v1.3">http: add support for TLS v1.3</a>
           label tlsv1.3

           reset onto
           pick 192837 Switch from GNU Makefiles to CMake
           pick 918273 Fix detection of OpenSSL in CMake
           pick fdbaec Fix detection of cURL in CMake on Windows
           pick 5a6c7e Document the switch to CMake
           label cmake

           reset onto
           merge tlsv1.3
           merge cmake
</pre> <h2>
CONFIGURATION </h2>
<pre>
       Everything below this line in this section is selectively
       included from the <a href="git-config.1.html">git-config(1)</a> documentation. The content is the
       same as what’s found there:

       rebase.backend
           Default backend to use for rebasing. Possible choices are
           <i>apply</i> or <i>merge</i>. In the future, if the merge backend gains all
           remaining capabilities of the apply backend, this setting may
           become unused.

       rebase.stat
           Whether to show a diffstat of what changed upstream since the
           last rebase. False by default.

       rebase.autoSquash
           If set to true, enable the <b>--autosquash </b>option of
           <a href="git-rebase.1.html">git-rebase(1)</a> by default for interactive mode. This can be
           overridden with the <b>--no-autosquash </b>option.

       rebase.autoStash
           When set to true, automatically create a temporary stash
           entry before the operation begins, and apply it after the
           operation ends. This means that you can run rebase on a dirty
           worktree. However, use with care: the final stash application
           after a successful rebase might result in non-trivial
           conflicts. This option can be overridden by the
           <b>--no-autostash </b>and <b>--autostash </b>options of <a href="git-rebase.1.html">git-rebase(1)</a>.
           Defaults to false.

       rebase.updateRefs
           If set to true enable <b>--update-refs </b>option by default.

       rebase.missingCommitsCheck
           If set to "warn", git rebase -i will print a warning if some
           commits are removed (e.g. a line was deleted), however the
           rebase will still proceed. If set to "error", it will print
           the previous warning and stop the rebase, <i>git rebase</i>
           <i>--edit-todo</i> can then be used to correct the error. If set to
           "ignore", no checking is done. To drop a commit without
           warning or error, use the <b>drop </b>command in the todo list.
           Defaults to "ignore".

       rebase.instructionFormat
           A format string, as specified in <a href="git-log.1.html">git-log(1)</a>, to be used for
           the todo list during an interactive rebase. The format will
           automatically have the commit hash prepended to the format.

       rebase.abbreviateCommands
           If set to true, <b>git rebase </b>will use abbreviated command names
           in the todo list resulting in something like this:

                       p deadbee The oneline of the commit
                       p fa1afe1 The oneline of the next commit
                       ...

           instead of:

                       pick deadbee The oneline of the commit
                       pick fa1afe1 The oneline of the next commit
                       ...

           Defaults to false.

       rebase.rescheduleFailedExec
           Automatically reschedule <b>exec </b>commands that failed. This only
           makes sense in interactive mode (or when an <b>--exec </b>option was
           provided). This is the same as specifying the
           <b>--reschedule-failed-exec </b>option.

       rebase.forkPoint
           If set to false set <b>--no-fork-point </b>option by default.

       rebase.rebaseMerges
           Whether and how to set the <b>--rebase-merges </b>option by default.
           Can be <b>rebase-cousins</b>, <b>no-rebase-cousins</b>, or a boolean.
           Setting to true or to <b>no-rebase-cousins </b>is equivalent to
           <b>--rebase-merges=no-rebase-cousins</b>, setting to <b>rebase-cousins</b>
           is equivalent to <b>--rebase-merges=rebase-cousins</b>, and setting
           to false is equivalent to <b>--no-rebase-merges</b>. Passing
           <b>--rebase-merges </b>on the command line, with or without an
           argument, overrides any <b>rebase.rebaseMerges </b>configuration.

       rebase.maxLabelLength
           When generating label names from commit subjects, truncate
           the names to this length. By default, the names are truncated
           to a little less than <b>NAME_MAX </b>(to allow e.g.  <b>.lock </b>files to
           be written for the corresponding loose refs).

       sequence.editor
           Text editor used by <b>git rebase -i </b>for editing the rebase
           instruction file. The value is meant to be interpreted by the
           shell when it is used. It can be overridden by the
           <b>GIT_SEQUENCE_EDITOR </b>environment variable. When not
           configured, the default commit message editor is used
           instead.
</pre> <h2>
GIT </h2>
<pre>
       Part of the <a href="git.1.html">git(1)</a> suite
</pre> <h2>
NOTES </h2>
<pre>
        1. revert-a-faulty-merge How-To
           file:///home/mtk/share/doc/git-doc/howto/revert-a-faulty-merge.html

        2. <b>filter-repo</b>
           <a href="https://github.com/newren/git-filter-repo">https://github.com/newren/git-filter-repo</a>
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>git</i> (Git distributed version control
       system) project.  Information about the project can be found at
       ⟨<a href="http://git-scm.com/">http://git-scm.com/</a>⟩.  If you have a bug report for this manual
       page, see ⟨<a href="http://git-scm.com/community">http://git-scm.com/community</a>⟩.  This page was obtained
       from the project's upstream Git repository
       ⟨<a href="https://github.com/git/git.git">https://github.com/git/git.git</a>⟩ on 2024-06-14.  (At that time,
       the date of the most recent commit that was found in the
       repository was 2024-06-12.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Git 2.45.2.492.gd63586         2024-06-12                  <i>GIT-REBASE</i>(1)</span>
</pre>  <p>Pages that refer to this page: <a href="git.1.html">git(1)</a>, <a href="git-branch.1.html">git-branch(1)</a>, <a href="git-cherry.1.html">git-cherry(1)</a>, <a href="git-commit.1.html">git-commit(1)</a>, <a href="git-config.1.html">git-config(1)</a>, <a href="git-filter-branch.1.html">git-filter-branch(1)</a>, <a href="git-format-patch.1.html">git-format-patch(1)</a>, <a href="git-pull.1.html">git-pull(1)</a>, <a href="git-rebase.1.html">git-rebase(1)</a>, <a href="git-replace.1.html">git-replace(1)</a>, <a href="git-reset.1.html">git-reset(1)</a>, <a href="git-submodule.1.html">git-submodule(1)</a>, <a href="git-svn.1.html">git-svn(1)</a>, <a href="stg-repair.1.html">stg-repair(1)</a>, <a href="../man5/githooks.5.html">githooks(5)</a>, <a href="../man7/giteveryday.7.html">giteveryday(7)</a>, <a href="../man7/gitfaq.7.html">gitfaq(7)</a>, <a href="../man7/gitworkflows.7.html">gitworkflows(7)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man1/git-rebase.1.html" class="_attribution-link">https://man7.org/linux/man-pages/man1/git-rebase.1.html</a>
  </p>
</div>
