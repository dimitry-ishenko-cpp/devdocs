<h1>mdadm(8) — Linux manual page</h1>   <pre>
<span class="headline"><i>MDADM</i>(8)                 System Manager's Manual                <i>MDADM</i>(8)</span>
</pre> <h2>
NAME </h2>
<pre>
       mdadm - manage MD devices <i>aka</i> Linux Software RAID
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>mdadm </b><i>[mode] &lt;raiddevice&gt; [options] &lt;component-devices&gt;</i>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       RAID devices are virtual devices created from two or more real
       block devices.  This allows multiple devices (typically disk
       drives or partitions thereof) to be combined into a single device
       to hold (for example) a single filesystem.  Some RAID levels
       include redundancy and so can survive some degree of device
       failure.

       Linux Software RAID devices are implemented through the md
       (Multiple Devices) device driver.

       Currently, Linux supports <b>LINEAR </b>md devices, <b>RAID0 </b>(striping),
       <b>RAID1 </b>(mirroring), <b>RAID4</b>, <b>RAID5</b>, <b>RAID6</b>, <b>RAID10</b>, <b>MULTIPATH</b>,
       <b>FAULTY</b>, and <b>CONTAINER</b>.

       <b>MULTIPATH </b>is not a Software RAID mechanism, but does involve
       multiple devices: each device is a path to one common physical
       storage device.  New installations should not use md/multipath as
       it is not well supported and has no ongoing development.  Use the
       Device Mapper based multipath-tools instead.

       <b>FAULTY </b>is also not true RAID, and it only involves one device.
       It provides a layer over a true device that can be used to inject
       faults.

       <b>CONTAINER </b>is different again.  A <b>CONTAINER </b>is a collection of
       devices that are managed as a set.  This is similar to the set of
       devices connected to a hardware RAID controller.  The set of
       devices may contain a number of different RAID arrays each
       utilising some (or all) of the blocks from a number of the
       devices in the set.  For example, two devices in a 5-device set
       might form a RAID1 using the whole devices.  The remaining three
       might have a RAID5 over the first half of each device, and a
       RAID0 over the second half.

       With a <b>CONTAINER</b>, there is one set of metadata that describes all
       of the arrays in the container.  So when <i>mdadm</i> creates a
       <b>CONTAINER </b>device, the device just represents the metadata.  Other
       normal arrays (RAID1 etc) can be created inside the container.
</pre> <h2>
MODES </h2>
<pre>
       mdadm has several major modes of operation:

       <b>Assemble</b>
              Assemble the components of a previously created array into
              an active array.  Components can be explicitly given or
              can be searched for.  <i>mdadm</i> checks that the components do
              form a bona fide array, and can, on request, fiddle
              superblock information so as to assemble a faulty array.

       <b>Build  </b>Build an array that doesn't have per-device metadata
              (superblocks).  For these sorts of arrays, <i>mdadm</i> cannot
              differentiate between initial creation and subsequent
              assembly of an array.  It also cannot perform any checks
              that appropriate components have been requested.  Because
              of this, the <b>Build </b>mode should only be used together with
              a complete understanding of what you are doing.

       <b>Create </b>Create a new array with per-device metadata (superblocks).
              Appropriate metadata is written to each device, and then
              the array comprising those devices is activated.  A
              'resync' process is started to make sure that the array is
              consistent (e.g. both sides of a mirror contain the same
              data) but the content of the device is left otherwise
              untouched.  The array can be used as soon as it has been
              created.  There is no need to wait for the initial resync
              to finish.

       <b>Follow or Monitor</b>
              Monitor one or more md devices and act on any state
              changes.  This is only meaningful for RAID1, 4, 5, 6, 10
              or multipath arrays, as only these have interesting state.
              RAID0 or Linear never have missing, spare, or failed
              drives, so there is nothing to monitor.

       <b>Grow   </b>Grow (or shrink) an array, or otherwise reshape it in some
              way.  Currently supported growth options including
              changing the active size of component devices and changing
              the number of active devices in Linear and RAID levels
              0/1/4/5/6, changing the RAID level between 0, 1, 5, and 6,
              and between 0 and 10, changing the chunk size and layout
              for RAID 0,4,5,6,10 as well as adding or removing a write-
              intent bitmap and changing the array's consistency policy.

       <b>Incremental Assembly</b>
              Add a single device to an appropriate array.  If the
              addition of the device makes the array runnable, the array
              will be started.  This provides a convenient interface to
              a <i>hot-plug</i> system.  As each device is detected, <i>mdadm</i> has
              a chance to include it in some array as appropriate.
              Optionally, when the <i>--fail</i> flag is passed in we will
              remove the device from any active array instead of adding
              it.

              If a <b>CONTAINER </b>is passed to <i>mdadm</i> in this mode, then any
              arrays within that container will be assembled and
              started.

       <b>Manage </b>This is for doing things to specific components of an
              array such as adding new spares and removing faulty
              devices.

       <b>Misc   </b>This is an 'everything else' mode that supports operations
              on active arrays, operations on component devices such as
              erasing old superblocks, and information-gathering
              operations.

       <b>Auto-detect</b>
              This mode does not act on a specific device or array, but
              rather it requests the Linux Kernel to activate any auto-
              detected arrays.
</pre> <h2>
OPTIONS </h2>
 <h2>
Options for selecting a mode are: </h2>
<pre>
       <b>-A</b>, <b>--assemble</b>
              Assemble a pre-existing array.

       <b>-B</b>, <b>--build</b>
              Build a legacy array without superblocks.

       <b>-C</b>, <b>--create</b>
              Create a new array.

       <b>-F</b>, <b>--follow</b>, <b>--monitor</b>
              Select <b>Monitor </b>mode.

       <b>-G</b>, <b>--grow</b>
              Change the size or shape of an active array.

       <b>-I</b>, <b>--incremental</b>
              Add/remove a single device to/from an appropriate array,
              and possibly start the array.

       <b>--auto-detect</b>
              Request that the kernel starts any auto-detected arrays.
              This can only work if <i>md</i> is compiled into the kernel — not
              if it is a module.  Arrays can be auto-detected by the
              kernel if all the components are in primary MS-DOS
              partitions with partition type <b>FD</b>, and all use v0.90
              metadata.  In-kernel autodetect is not recommended for new
              installations.  Using <i>mdadm</i> to detect and assemble arrays
              — possibly in an <i>initrd</i> — is substantially more flexible
              and should be preferred.

       If a device is given before any options, or if the first option
       is one of <b>--add</b>, <b>--re-add</b>, <b>--add-spare</b>, <b>--fail</b>, <b>--remove</b>, or
       <b>--replace</b>, then the MANAGE mode is assumed.  Anything other than
       these will cause the <b>Misc </b>mode to be assumed.
</pre> <h2>
Options that are not mode-specific are: </h2>
<pre>
       <b>-h</b>, <b>--help</b>
              Display a general help message or, after one of the above
              options, a mode-specific help message.

       <b>--help-options</b>
              Display more detailed help about command-line parsing and
              some commonly used options.

       <b>-V</b>, <b>--version</b>
              Print version information for mdadm.

       <b>-v</b>, <b>--verbose</b>
              Be more verbose about what is happening.  This can be used
              twice to be extra-verbose.  The extra verbosity currently
              only affects <b>--detail --scan </b>and <b>--examine --scan</b>.

       <b>-q</b>, <b>--quiet</b>
              Avoid printing purely informative messages.  With this,
              <i>mdadm</i> will be silent unless there is something really
              important to report.

       <b>-f</b>, <b>--force</b>
              Be more forceful about certain operations.  See the
              various modes for the exact meaning of this option in
              different contexts.

       <b>-c</b>, <b>--config=</b>
              Specify the config file or directory.  If not specified,
              the default config file and default conf.d directory will
              be used.  See <a href="../man5/mdadm.conf.5.html">mdadm.conf(5)</a> for more details.

              If the config file given is <b>partitions </b>then nothing will
              be read, but <i>mdadm</i> will act as though the config file
              contained exactly
                  <b>DEVICE partitions containers</b>
              and will read <b>/proc/partitions </b>to find a list of devices
              to scan, and <b>/proc/mdstat </b>to find a list of containers to
              examine.  If the word <b>none </b>is given for the config file,
              then <i>mdadm</i> will act as though the config file were empty.

              If the name given is of a directory, then <i>mdadm</i> will
              collect all the files contained in the directory with a
              name ending in <b>.conf</b>, sort them lexically, and process all
              of those files as config files.

       <b>-s</b>, <b>--scan</b>
              Scan config file or <b>/proc/mdstat </b>for missing information.
              In general, this option gives <i>mdadm</i> permission to get any
              missing information (like component devices, array
              devices, array identities, and alert destination) from the
              configuration file (see previous option); one exception is
              MISC mode when using <b>--detail </b>or <b>--stop, </b>in which case
              <b>--scan </b>says to get a list of array devices from
              <b>/proc/mdstat</b>.

       <b>-e</b>, <b>--metadata=</b>
              Declare the style of RAID metadata (superblock) to be
              used.  The default is 1.2 for <b>--create</b>, and to guess for
              other operations.  The default can be overridden by
              setting the <b>metadata </b>value for the <b>CREATE </b>keyword in
              <b>mdadm.conf</b>.

              Options are:

              0, 0.90
                     Use the original 0.90 format superblock.  This
                     format limits arrays to 28 component devices and
                     limits component devices of levels 1 and greater to
                     2 terabytes.  It is also possible for there to be
                     confusion about whether the superblock applies to a
                     whole device or just the last partition, if that
                     partition starts on a 64K boundary.

              1, 1.0, 1.1, 1.2 default
                     Use the new version-1 format superblock.  This has
                     fewer restrictions.  It can easily be moved between
                     hosts with different endian-ness, and a recovery
                     operation can be checkpointed and restarted.  The
                     different sub-versions store the superblock at
                     different locations on the device, either at the
                     end (for 1.0), at the start (for 1.1) or 4K from
                     the start (for 1.2).  "1" is equivalent to "1.2"
                     (the commonly preferred 1.x format).  "default" is
                     equivalent to "1.2".

              ddf    Use the "Industry Standard" DDF (Disk Data Format)
                     format defined by SNIA.  When creating a DDF array
                     a <b>CONTAINER </b>will be created, and normal arrays can
                     be created in that container.

              imsm   Use the Intel(R) Matrix Storage Manager metadata
                     format.  This creates a <b>CONTAINER </b>which is managed
                     in a similar manner to DDF, and is supported by an
                     option-rom on some platforms:

                     <b><a href="https://www.intel.com/content/www/us/en/support/products/122484">https://www.intel.com/content/www/us/en/support/products/122484</a> </b>

       <b>--homehost=</b>
              This will override any <b>HOMEHOST </b>setting in the config file
              and provides the identity of the host which should be
              considered the home for any arrays.

              When creating an array, the <b>homehost </b>will be recorded in
              the metadata.  For version-1 superblocks, it will be
              prefixed to the array name.  For version-0.90 superblocks,
              part of the SHA1 hash of the hostname will be stored in
              the latter half of the UUID.

              When reporting information about an array, any array which
              is tagged for the given homehost will be reported as such.

              When using Auto-Assemble, only arrays tagged for the given
              homehost will be allowed to use 'local' names (i.e. not
              ending in '_' followed by a digit string).  See below
              under <b>Auto-Assembly</b>.

              The special name "<b>any</b>" can be used as a wild card.  If an
              array is created with <b>--homehost=any </b>then the name "<b>any</b>"
              will be stored in the array and it can be assembled in the
              same way on any host.  If an array is assembled with this
              option, then the homehost recorded on the array will be
              ignored.

       <b>--prefer=</b>
              When <i>mdadm</i> needs to print the name for a device it
              normally finds the name in <b>/dev </b>which refers to the device
              and is the shortest.  When a path component is given with
              <b>--prefer </b><i>mdadm</i> will prefer a longer name if it contains
              that component.  For example <b>--prefer=by-uuid </b>will prefer
              a name in a subdirectory of <b>/dev </b>called <b>by-uuid</b>.

              This functionality is currently only provided by <b>--detail</b>
              and <b>--monitor</b>.

       <b>--home-cluster=</b>
              specifies the cluster name for the md device. The md
              device can be assembled only on the cluster which matches
              the name specified. If this option is not provided, mdadm
              tries to detect the cluster name automatically.
</pre> <h2>
For create, build, or grow: </h2>
<pre>
       <b>-n</b>, <b>--raid-devices=</b>
              Specify the number of active devices in the array.  This,
              plus the number of spare devices (see below) must equal
              the number of <i>component-devices</i> (including "<b>missing</b>"
              devices) that are listed on the command line for <b>--create</b>.
              Setting a value of 1 is probably a mistake and so requires
              that <b>--force </b>be specified first.  A value of 1 will then
              be allowed for linear, multipath, RAID0 and RAID1.  It is
              never allowed for RAID4, RAID5 or RAID6.
              This number can only be changed using <b>--grow </b>for RAID1,
              RAID4, RAID5 and RAID6 arrays, and only on kernels which
              provide the necessary support.

       <b>-x</b>, <b>--spare-devices=</b>
              Specify the number of spare (eXtra) devices in the initial
              array.  Spares can also be added and removed later.  The
              number of component devices listed on the command line
              must equal the number of RAID devices plus the number of
              spare devices.

       <b>-z</b>, <b>--size=</b>
              Amount (in Kilobytes) of space to use from each drive in
              RAID levels 1/4/5/6/10 and for RAID 0 on external
              metadata.  This must be a multiple of the chunk size, and
              must leave about 128Kb of space at the end of the drive
              for the RAID superblock.  If this is not specified (as it
              normally is not) the smallest drive (or partition) sets
              the size, though if there is a variance among the drives
              of greater than 1%, a warning is issued.

              A suffix of 'K', 'M', 'G' or 'T' can be given to indicate
              Kilobytes, Megabytes, Gigabytes or Terabytes respectively.

              Sometimes a replacement drive can be a little smaller than
              the original drives though this should be minimised by
              IDEMA standards.  Such a replacement drive will be
              rejected by <i>md</i>.  To guard against this it can be useful to
              set the initial size slightly smaller than the smaller
              device with the aim that it will still be larger than any
              replacement.

              This option can be used with <b>--create </b>for determining the
              initial size of an array. For external metadata, it can be
              used on a volume, but not on a container itself.  Setting
              the initial size of <b>RAID 0 </b>array is only valid for
              external metadata.

              This value can be set with <b>--grow </b>for RAID level
              1/4/5/6/10 though DDF arrays may not be able to support
              this.  RAID 0 array size cannot be changed.  If the array
              was created with a size smaller than the currently active
              drives, the extra space can be accessed using <b>--grow</b>.  The
              size can be given as <b>max </b>which means to choose the largest
              size that fits on all current drives.

              Before reducing the size of the array (with <b>--grow</b>
              <b>--size=</b>) you should make sure that space isn't needed.  If
              the device holds a filesystem, you would need to resize
              the filesystem to use less space.

              After reducing the array size you should check that the
              data stored in the device is still available.  If the
              device holds a filesystem, then an 'fsck' of the
              filesystem is a minimum requirement.  If there are
              problems the array can be made bigger again with no loss
              with another <b>--grow --size= </b>command.

       <b>-Z</b>, <b>--array-size=</b>
              This is only meaningful with <b>--grow </b>and its effect is not
              persistent: when the array is stopped and restarted the
              default array size will be restored.

              Setting the array-size causes the array to appear smaller
              to programs that access the data.  This is particularly
              needed before reshaping an array so that it will be
              smaller.  As the reshape is not reversible, but setting
              the size with <b>--array-size </b>is, it is required that the
              array size is reduced as appropriate before the number of
              devices in the array is reduced.

              Before reducing the size of the array you should make sure
              that space isn't needed.  If the device holds a
              filesystem, you would need to resize the filesystem to use
              less space.

              After reducing the array size you should check that the
              data stored in the device is still available.  If the
              device holds a filesystem, then an 'fsck' of the
              filesystem is a minimum requirement.  If there are
              problems the array can be made bigger again with no loss
              with another <b>--grow --array-size= </b>command.

              A suffix of 'K', 'M', 'G' or 'T' can be given to indicate
              Kilobytes, Megabytes, Gigabytes or Terabytes respectively.
              A value of <b>max </b>restores the apparent size of the array to
              be whatever the real amount of available space is.

              Clustered arrays do not support this parameter yet.

       <b>-c</b>, <b>--chunk=</b>
              Specify chunk size in kilobytes.  The default when
              creating an array is 512KB.  To ensure compatibility with
              earlier versions, the default when building an array with
              no persistent metadata is 64KB.  This is only meaningful
              for RAID0, RAID4, RAID5, RAID6, and RAID10.

              RAID4, RAID5, RAID6, and RAID10 require the chunk size to
              be a power of 2, with minimal chunk size being 4KB.

              A suffix of 'K', 'M', 'G' or 'T' can be given to indicate
              Kilobytes, Megabytes, Gigabytes or Terabytes respectively.

       <b>--rounding=</b>
              Specify the rounding factor for a Linear array.  The size
              of each component will be rounded down to a multiple of
              this size.  This is a synonym for <b>--chunk </b>but highlights
              the different meaning for Linear as compared to other RAID
              levels.  The default is 64K if a kernel earlier than
              2.6.16 is in use, and is 0K (i.e. no rounding) in later
              kernels.

       <b>-l</b>, <b>--level=</b>
              Set RAID level.  When used with <b>--create</b>, options are:
              linear, raid0, 0, stripe, raid1, 1, mirror, raid4, 4,
              raid5, 5, raid6, 6, raid10, 10, multipath, mp, faulty,
              container.  Obviously some of these are synonymous.

              When a <b>CONTAINER </b>metadata type is requested, only the
              <b>container </b>level is permitted, and it does not need to be
              explicitly given.

              When used with <b>--build</b>, only linear, stripe, raid0, 0,
              raid1, multipath, mp, and faulty are valid.

              Can be used with <b>--grow </b>to change the RAID level in some
              cases.  See LEVEL CHANGES below.

       <b>-p</b>, <b>--layout=</b>
              This option configures the fine details of data layout for
              RAID5, RAID6, and RAID10 arrays, and controls the failure
              modes for <i>faulty</i>.  It can also be used for working around
              a kernel bug with RAID0, but generally doesn't need to be
              used explicitly.

              The layout of the RAID5 parity block can be one of
              <b>left-asymmetric</b>, <b>left-symmetric</b>, <b>right-asymmetric</b>,
              <b>right-symmetric</b>, <b>la</b>, <b>ra</b>, <b>ls</b>, <b>rs</b>.  The default is
              <b>left-symmetric</b>.

              It is also possible to cause RAID5 to use a RAID4-like
              layout by choosing <b>parity-first</b>, or <b>parity-last</b>.

              Finally for RAID5 there are DDF-compatible layouts,
              <b>ddf-zero-restart</b>, <b>ddf-N-restart</b>, and <b>ddf-N-continue</b>.

              These same layouts are available for RAID6.  There are
              also 4 layouts that will provide an intermediate stage for
              converting between RAID5 and RAID6.  These provide a
              layout which is identical to the corresponding RAID5
              layout on the first N-1 devices, and has the 'Q' syndrome
              (the second 'parity' block used by RAID6) on the last
              device.  These layouts are: <b>left-symmetric-6</b>,
              <b>right-symmetric-6</b>, <b>left-asymmetric-6</b>, <b>right-asymmetric-6</b>,
              and <b>parity-first-6</b>.

              When setting the failure mode for level <i>faulty,</i> the
              options are: <b>write-transient</b>, <b>wt</b>, <b>read-transient</b>, <b>rt</b>,
              <b>write-persistent</b>, <b>wp</b>, <b>read-persistent</b>, <b>rp</b>, <b>write-all</b>,
              <b>read-fixable</b>, <b>rf</b>, <b>clear</b>, <b>flush</b>, <b>none</b>.

              Each failure mode can be followed by a number, which is
              used as a period between fault generation.  Without a
              number, the fault is generated once on the first relevant
              request.  With a number, the fault will be generated after
              that many requests, and will continue to be generated
              every time the period elapses.

              Multiple failure modes can be current simultaneously by
              using the <b>--grow </b>option to set subsequent failure modes.

              "clear" or "none" will remove any pending or periodic
              failure modes, and "flush" will clear any persistent
              faults.

              The layout options for RAID10 are one of 'n', 'o' or 'f'
              followed by a small number signifying the number of copies
              of each datablock.  The default is 'n2'.  The supported
              options are:

              <i>'n'</i> signals 'near' copies.  Multiple copies of one data
              block are at similar offsets in different devices.

              <i>'o'</i> signals 'offset' copies.  Rather than the chunks being
              duplicated within a stripe, whole stripes are duplicated
              but are rotated by one device so duplicate blocks are on
              different devices.  Thus subsequent copies of a block are
              in the next drive, and are one chunk further down.

              <i>'f'</i> signals 'far' copies (multiple copies have very
              different offsets).  See md(4) for more detail about
              'near', 'offset', and 'far'.

              As for the number of copies of each data block, 2 is
              normal, 3 can be useful.  This number can be at most equal
              to the number of devices in the array.  It does not need
              to divide evenly into that number (e.g. it is perfectly
              legal to have an 'n2' layout for an array with an odd
              number of devices).

              A bug introduced in Linux 3.14 means that RAID0 arrays
              <b>with devices of differing sizes </b>started using a different
              layout.  This could lead to data corruption.  Since Linux
              5.4 (and various stable releases that received backports),
              the kernel will not accept such an array unless a layout
              is explicitly set.  It can be set to '<b>original</b>' or
              '<b>alternate</b>'.  When creating a new array, <i>mdadm</i> will select
              '<b>original</b>' by default, so the layout does not normally
              need to be set.  An array created for either '<b>original</b>' or
              '<b>alternate</b>' will not be recognized by an (unpatched)
              kernel prior to 5.4.  To create a RAID0 array with devices
              of differing sizes that can be used on an older kernel,
              you can set the layout to '<b>dangerous</b>'.  This will use
              whichever layout the running kernel supports, so the data
              on the array may become corrupt when changing kernel from
              pre-3.14 to a later kernel.

              When an array is converted between RAID5 and RAID6 an
              intermediate RAID6 layout is used in which the second
              parity block (Q) is always on the last device.  To convert
              a RAID5 to RAID6 and leave it in this new layout (which
              does not require re-striping) use <b>--layout=preserve</b>.  This
              will try to avoid any restriping.

              The converse of this is <b>--layout=normalise </b>which will
              change a non-standard RAID6 layout into a more standard
              arrangement.

       <b>--parity=</b>
              same as <b>--layout </b>(thus explaining the p of <b>-p</b>).

       <b>-b</b>, <b>--bitmap=</b>
              Specify how to store a write-intent bitmap.  Following
              values are supported:

              <b>internal </b>- the bitmap is stored with the metadata on the
              array and so is replicated on all devices.

              <b>clustered </b>- the array is created for a clustered
              environment. One bitmap is created for each node as
              defined by the <b>--nodes </b>parameter and are stored
              internally.

              <b>none </b>- create array with no bitmap or remove any present
              bitmap (grow mode).

              Setting bitmap for file is deprecated and should not be
              used. The file should not exist unless <b>--force </b>is also
              given. The same file should be provided when assembling
              the array. The file name must contain at least one slash
              ('/'). Bitmap files are only known to work on ext2 and
              ext3. Storing bitmap files on other filesystems may result
              in serious problems.

              When creating an array on devices which are 100G or
              larger, <i>mdadm</i> automatically adds an internal bitmap as it
              will usually be beneficial.  This can be suppressed with
              <b>--bitmap=none </b>or by selecting a different consistency
              policy with <b>--consistency-policy</b>.

       <b>--bitmap-chunk=</b>
              Set the chunk size of the bitmap.  Each bit corresponds to
              that many Kilobytes of storage.  When using a file-based
              bitmap, the default is to use the smallest size that is at
              least 4 and requires no more than 2^21 chunks.  When using
              an <b>internal </b>bitmap, the chunk size defaults to 64Meg, or
              larger if necessary to fit the bitmap into the available
              space.

              A suffix of 'K', 'M', 'G' or 'T' can be given to indicate
              Kilobytes, Megabytes, Gigabytes or Terabytes respectively.

       <b>-W</b>, <b>--write-mostly</b>
              subsequent devices listed in a <b>--build</b>, <b>--create</b>, or <b>--add</b>
              command will be flagged as 'write-mostly'.  This is valid
              for RAID1 only and means that the 'md' driver will avoid
              reading from these devices if at all possible.  This can
              be useful if mirroring over a slow link.

       <b>--write-behind=</b>
              Specify that write-behind mode should be enabled (valid
              for RAID1 only).  If an argument is specified, it will set
              the maximum number of outstanding writes allowed.  The
              default value is 256.  A write-intent bitmap is required
              in order to use write-behind mode, and write-behind is
              only attempted on drives marked as <i>write-mostly</i>.

       <b>--failfast</b>
              subsequent devices listed in a <b>--create </b>or <b>--add </b>command
              will be flagged as  'failfast'.  This is valid for RAID1
              and RAID10 only.  IO requests to these devices will be
              encouraged to fail quickly rather than cause long delays
              due to error handling.  Also no attempt is made to repair
              a read error on these devices.

              If an array becomes degraded so that the 'failfast' device
              is the only usable device, the 'failfast' flag will then
              be ignored and extended delays will be preferred to
              complete failure.

              The 'failfast' flag is appropriate for storage arrays
              which have a low probability of true failure, but which
              may sometimes cause unacceptable delays due to internal
              maintenance functions.

       <b>--assume-clean</b>
              Tell <i>mdadm</i> that the array pre-existed and is known to be
              clean.  It can be useful when trying to recover from a
              major failure as you can be sure that no data will be
              affected unless you actually write to the array.  It can
              also be used when creating a RAID1 or RAID10 if you want
              to avoid the initial resync, however this practice — while
              normally safe — is not recommended.  Use this only if you
              really know what you are doing.

              When the devices that will be part of a new array were
              filled with zeros before creation the operator knows the
              array is actually clean. If that is the case, such as
              after running badblocks, this argument can be used to tell
              mdadm the facts the operator knows.

              When an array is resized to a larger size with <b>--grow</b>
              <b>--size= </b>the new space is normally resynced in that same
              way that the whole array is resynced at creation.  From
              Linux version 3.0, <b>--assume-clean </b>can be used with that
              command to avoid the automatic resync.

       <b>--write-zeroes</b>
              When creating an array, send write zeroes requests to all
              the block devices.  This should zero the data area on all
              disks such that the initial sync is not necessary and, if
              successfull, will behave as if <b>--assume-clean </b>was
              specified.

              This is intended for use with devices that have hardware
              offload for zeroing, but despite this zeroing can still
              take several minutes for large disks.  Thus a message is
              printed before and after zeroing and each disk is zeroed
              in parallel with the others.

              This is only meaningful with --create.

       <b>--backup-file=</b>
              This is needed when <b>--grow </b>is used to increase the number
              of raid devices in a RAID5 or RAID6 if there are no spare
              devices available, or to shrink, change RAID level or
              layout.  See the GROW MODE section below on RAID-DEVICES
              CHANGES.  The file must be stored on a separate device,
              not on the RAID array being reshaped.

       <b>--data-offset=</b>
              Arrays with 1.x metadata can leave a gap between the start
              of the device and the start of array data.  This gap can
              be used for various metadata.  The start of data is known
              as the <i>data-offset</i>.  Normally an appropriate data offset
              is computed automatically.  However it can be useful to
              set it explicitly such as when re-creating an array which
              was originally created using a different version of <i>mdadm</i>
              which computed a different offset.

              Setting the offset explicitly over-rides the default.  The
              value given is in Kilobytes unless a suffix of 'K', 'M',
              'G' or 'T' is used to explicitly indicate Kilobytes,
              Megabytes, Gigabytes or Terabytes respectively.

              Since Linux 3.4, <b>--data-offset </b>can also be used with
              <b>--grow </b>for some RAID levels (initially on RAID10).  This
              allows the data-offset to be changed as part of the
              reshape process.  When the data offset is changed, no
              backup file is required as the difference in offsets is
              used to provide the same functionality.

              When the new offset is earlier than the old offset, the
              number of devices in the array cannot shrink.  When it is
              after the old offset, the number of devices in the array
              cannot increase.

              When creating an array, <b>--data-offset </b>can be specified as
              <b>variable</b>.  In the case each member device is expected to
              have an offset appended to the name, separated by a colon.
              This makes it possible to recreate exactly an array which
              has varying data offsets (as can happen when different
              versions of <i>mdadm</i> are used to add different devices).

       <b>--continue</b>
              This option is complementary to the <b>--freeze-reshape</b>
              option for assembly. It is needed when <b>--grow </b>operation is
              interrupted and it is not restarted automatically due to
              <b>--freeze-reshape </b>usage during array assembly.  This option
              is used together with <b>-G </b>, ( <b>--grow </b>) command and device
              for a pending reshape to be continued.  All parameters
              required for reshape continuation will be read from array
              metadata.  If initial <b>--grow </b>command had required
              <b>--backup-file= </b>option to be set, continuation option will
              require to have exactly the same backup file given as
              well.

              Any other parameter passed together with <b>--continue </b>option
              will be ignored.

       <b>-N</b>, <b>--name=</b>
              Set a <b>name </b>for the array. It must be <b>POSIX PORTABLE NAME</b>
              compatible and cannot be longer than 32 chars. This is
              effective when creating an array with a v1 metadata, or an
              external array.

              If name is needed but not specified, it is taken from the
              basename of the device that is being created. See <b>DEVICE</b>
              <b>NAMES</b>

       <b>-R</b>, <b>--run</b>
              Insist that <i>mdadm</i> run the array, even if some of the
              components appear to be active in another array or
              filesystem.  Normally <i>mdadm</i> will ask for confirmation
              before including such components in an array.  This option
              causes that question to be suppressed.

       <b>-f</b>, <b>--force</b>
              Insist that <i>mdadm</i> accept the geometry and layout specified
              without question.  Normally <i>mdadm</i> will not allow the
              creation of an array with only one device, and will try to
              create a RAID5 array with one missing drive (as this makes
              the initial resync work faster).  With <b>--force</b>, <i>mdadm</i> will
              not try to be so clever.

       <b>-o</b>, <b>--readonly</b>
              Start the array <b>read only </b>rather than read-write as
              normal.  No writes will be allowed to the array, and no
              resync, recovery, or reshape will be started. It works
              with Create, Assemble, Manage and Misc mode.

       <b>-a</b>, <b>--auto{=yes,md,mdp,part,p}{NN}</b>
              Instruct mdadm how to create the device file if needed,
              possibly allocating an unused minor number.  "md" causes a
              non-partitionable array to be used (though since Linux
              2.6.28, these array devices are in fact partitionable).
              "mdp", "part" or "p" causes a partitionable array (2.6 and
              later) to be used.  "yes" requires the named md device to
              have a 'standard' format, and the type and minor number
              will be determined from this.  With mdadm 3.0, device
              creation is normally left up to <i>udev</i> so this option is
              unlikely to be needed.  See DEVICE NAMES below.

              The argument can also come immediately after "-a".  e.g.
              "-ap".

              If <b>--auto </b>is not given on the command line or in the
              config file, then the default will be <b>--auto=yes</b>.

              If <b>--scan </b>is also given, then any <i>auto=</i> entries in the
              config file will override the <b>--auto </b>instruction given on
              the command line.

              For partitionable arrays, <i>mdadm</i> will create the device
              file for the whole array and for the first 4 partitions.
              A different number of partitions can be specified at the
              end of this option (e.g.  <b>--auto=p7</b>).  If the device name
              ends with a digit, the partition names add a 'p', and a
              number, e.g.  <i>/dev/md/home1p3</i>.  If there is no trailing
              digit, then the partition names just have a number added,
              e.g.  <i>/dev/md/scratch3</i>.

              If the md device name is in a 'standard' format as
              described in DEVICE NAMES, then it will be created, if
              necessary, with the appropriate device number based on
              that name.  If the device name is not in one of these
              formats, then an unused device number will be allocated.
              The device number will be considered unused if there is no
              active array for that number, and there is no entry in
              /dev for that number and with a non-standard name.  Names
              that are not in 'standard' format are only allowed in
              "/dev/md/".

              This is meaningful with <b>--create </b>or <b>--build</b>.

       <b>-a</b>, <b>--add</b>
              This option can be used in Grow mode in two cases.

              If the target array is a Linear array, then <b>--add </b>can be
              used to add one or more devices to the array.  They are
              simply catenated on to the end of the array.  Once added,
              the devices cannot be removed.

              If the <b>--raid-disks </b>option is being used to increase the
              number of devices in an array, then <b>--add </b>can be used to
              add some extra devices to be included in the array.  In
              most cases this is not needed as the extra devices can be
              added as spares first, and then the number of raid disks
              can be changed.  However, for RAID0 it is not possible to
              add spares.  So to increase the number of devices in a
              RAID0, it is necessary to set the new number of devices,
              and to add the new devices, in the same command.

       <b>--nodes</b>
              Only works when the array is created for a clustered
              environment. It specifies the maximum number of nodes in
              the cluster that will use this device simultaneously. If
              not specified, this defaults to 4.

       <b>--write-journal</b>
              Specify journal device for the RAID-4/5/6 array. The
              journal device should be an SSD with a reasonable
              lifetime.

       <b>-k</b>, <b>--consistency-policy=</b>
              Specify how the array maintains consistency in the case of
              an unexpected shutdown.  Only relevant for RAID levels
              with redundancy.  Currently supported options are:

              <b>resync </b>Full resync is performed and all redundancy is
                     regenerated when the array is started after an
                     unclean shutdown.

              <b>bitmap </b>Resync assisted by a write-intent bitmap.
                     Implicitly selected when using <b>--bitmap</b>.

              <b>journal</b>
                     For RAID levels 4/5/6, the journal device is used
                     to log transactions and replay after an unclean
                     shutdown. Implicitly selected when using
                     <b>--write-journal</b>.

              <b>ppl    </b>For RAID5 only, Partial Parity Log is used to close
                     the write hole and eliminate resync. PPL is stored
                     in the metadata region of RAID member drives, no
                     additional journal drive is needed.

              Can be used with --grow to change the consistency policy
              of an active array in some cases. See CONSISTENCY POLICY
              CHANGES below.
</pre> <h2>
For assemble: </h2>
<pre>
       <b>-u</b>, <b>--uuid=</b>
              uuid of array to assemble.  Devices which don't have this
              uuid are excluded

       <b>-m</b>, <b>--super-minor=</b>
              Minor number of device that array was created for.
              Devices which don't have this minor number are excluded.
              If you create an array as /dev/md1, then all superblocks
              will contain the minor number 1, even if the array is
              later assembled as /dev/md2.

              Giving the literal word "dev" for <b>--super-minor </b>will cause
              <i>mdadm</i> to use the minor number of the md device that is
              being assembled.  e.g. when assembling <b>/dev/md0</b>,
              <b>--super-minor=dev </b>will look for super blocks with a minor
              number of 0.

              <b>--super-minor </b>is only relevant for v0.90 metadata, and
              should not normally be used.  Using <b>--uuid </b>is much safer.

       <b>-N</b>, <b>--name=</b>
              Specify the name of the array to assemble. It must be
              <b>POSIX PORTABLE NAME </b>compatible and cannot be longer than
              32 chars. This must be the name that was specified when
              creating the array. It must either match the name stored
              in the superblock exactly, or it must match with the
              current <i>homehost</i> prefixed to the start of the given name.

       <b>-f</b>, <b>--force</b>
              Assemble the array even if the metadata on some devices
              appears to be out-of-date.  If <i>mdadm</i> cannot find enough
              working devices to start the array, but can find some
              devices that are recorded as having failed, then it will
              mark those devices as working so that the array can be
              started. This works only for native. For external metadata
              it allows to start dirty degraded RAID 4, 5, 6.  An array
              which requires <b>--force </b>to be started may contain data
              corruption.  Use it carefully.

       <b>-R</b>, <b>--run</b>
              Attempt to start the array even if fewer drives were given
              than were present last time the array was active.
              Normally if not all the expected drives are found and
              <b>--scan </b>is not used, then the array will be assembled but
              not started.  With <b>--run </b>an attempt will be made to start
              it anyway.

       <b>--no-degraded</b>
              This is the reverse of <b>--run </b>in that it inhibits the
              startup of array unless all expected drives are present.
              This is only needed with <b>--scan, </b>and can be used if the
              physical connections to devices are not as reliable as you
              would like.

       <b>-a</b>, <b>--auto{=no,yes,md,mdp,part}</b>
              See this option under Create and Build options.

       <b>-b</b>, <b>--bitmap=</b>
              Specify the bitmap file that was given when the array was
              created.  If an array has an <b>internal </b>bitmap, there is no
              need to specify this when assembling the array.

       <b>--backup-file=</b>
              If <b>--backup-file </b>was used while reshaping an array (e.g.
              changing number of devices or chunk size) and the system
              crashed during the critical section, then the same
              <b>--backup-file </b>must be presented to <b>--assemble </b>to allow
              possibly corrupted data to be restored, and the reshape to
              be completed.

       <b>--invalid-backup</b>
              If the file needed for the above option is not available
              for any reason an empty file can be given together with
              this option to indicate that the backup file is invalid.
              In this case the data that was being rearranged at the
              time of the crash could be irrecoverably lost, but the
              rest of the array may still be recoverable.  This option
              should only be used as a last resort if there is no way to
              recover the backup file.

       <b>-U</b>, <b>--update=</b>
              Update the superblock on each device while assembling the
              array.  The argument given to this flag can be one of
              <b>sparc2.2</b>, <b>summaries</b>, <b>uuid</b>, <b>name</b>, <b>nodes</b>, <b>homehost</b>, <b>home-</b>
              <b>cluster</b>, <b>resync</b>, <b>byteorder</b>, <b>devicesize</b>, <b>no-bitmap</b>, <b>bbl</b>,
              <b>no-bbl</b>, <b>ppl</b>, <b>no-ppl</b>, <b>layout-original</b>, <b>layout-alternate</b>,
              <b>layout-unspecified</b>, <b>metadata</b>, or <b>super-minor</b>.

              The <b>sparc2.2 </b>option will adjust the superblock of an array
              what was created on a Sparc machine running a patched 2.2
              Linux kernel.  This kernel got the alignment of part of
              the superblock wrong.  You can use the <b>--examine</b>
              <b>--sparc2.2 </b>option to <i>mdadm</i> to see what effect this would
              have.

              The <b>super-minor </b>option will update the <b>preferred minor</b>
              field on each superblock to match the minor number of the
              array being assembled.  This can be useful if <b>--examine</b>
              reports a different "Preferred Minor" to <b>--detail</b>.  In
              some cases this update will be performed automatically by
              the kernel driver.  In particular, the update happens
              automatically at the first write to an array with
              redundancy (RAID level 1 or greater) on a 2.6 (or later)
              kernel.

              The <b>uuid </b>option will change the uuid of the array.  If a
              UUID is given with the <b>--uuid </b>option that UUID will be
              used as a new UUID and will <b>NOT </b>be used to help identify
              the devices in the array.  If no <b>--uuid </b>is given, a random
              UUID is chosen.

              The <b>name </b>option will change the <i>name</i> of the array as
              stored in the superblock.  This is only supported for
              version-1 superblocks.

              The <b>nodes </b>option will change the <i>nodes</i> of the array as
              stored in the bitmap superblock. This option only works
              for a clustered environment.

              The <b>homehost </b>option will change the <i>homehost</i> as recorded
              in the superblock.  For version-0 superblocks, this is the
              same as updating the UUID.  For version-1 superblocks,
              this involves updating the name.

              The <b>home-cluster </b>option will change the cluster name as
              recorded in the superblock and bitmap. This option only
              works for a clustered environment.

              The <b>resync </b>option will cause the array to be marked <i>dirty</i>
              meaning that any redundancy in the array (e.g. parity for
              RAID5, copies for RAID1) may be incorrect.  This will
              cause the RAID system to perform a "resync" pass to make
              sure that all redundant information is correct.

              The <b>byteorder </b>option allows arrays to be moved between
              machines with different byte-order, such as from a big-
              endian machine like a Sparc or some MIPS machines, to a
              little-endian x86_64 machine.  When assembling such an
              array for the first time after a move, giving
              <b>--update=byteorder </b>will cause <i>mdadm</i> to expect superblocks
              to have their byteorder reversed, and will correct that
              order before assembling the array.  This is only valid
              with original (Version 0.90) superblocks.

              The <b>summaries </b>option will correct the summaries in the
              superblock.  That is the counts of total, working, active,
              failed, and spare devices.

              The <b>devicesize </b>option will rarely be of use.  It applies
              to version 1.1 and 1.2 metadata only (where the metadata
              is at the start of the device) and is only useful when the
              component device has changed size (typically become
              larger).  The version 1 metadata records the amount of the
              device that can be used to store data, so if a device in a
              version 1.1 or 1.2 array becomes larger, the metadata will
              still be visible, but the extra space will not.  In this
              case it might be useful to assemble the array with
              <b>--update=devicesize</b>.  This will cause <i>mdadm</i> to determine
              the maximum usable amount of space on each device and
              update the relevant field in the metadata.

              The <b>metadata </b>option only works on v0.90 metadata arrays
              and will convert them to v1.0 metadata.  The array must
              not be dirty (i.e. it must not need a sync) and it must
              not have a write-intent bitmap.

              The old metadata will remain on the devices, but will
              appear older than the new metadata and so will usually be
              ignored. The old metadata (or indeed the new metadata) can
              be removed by giving the appropriate <b>--metadata= </b>option to
              <b>--zero-superblock</b>.

              The <b>no-bitmap </b>option can be used when an array has an
              internal bitmap which is corrupt in some way so that
              assembling the array normally fails.  It will cause any
              internal bitmap to be ignored.

              The <b>bbl </b>option will reserve space in each device for a bad
              block list.  This will be 4K in size and positioned near
              the end of any free space between the superblock and the
              data.

              The <b>no-bbl </b>option will cause any reservation of space for
              a bad block list to be removed.  If the bad block list
              contains entries, this will fail, as removing the list
              could cause data corruption.

              The <b>ppl </b>option will enable PPL for a RAID5 array and
              reserve space for PPL on each device. There must be enough
              free space between the data and superblock and a write-
              intent bitmap or journal must not be used.

              The <b>no-ppl </b>option will disable PPL in the superblock.

              The <b>layout-original </b>and <b>layout-alternate </b>options are for
              RAID0 arrays with non-uniform devices size that were in
              use before Linux 5.4.  If the array was being used with
              Linux 3.13 or earlier, then to assemble the array on a new
              kernel, <b>--update=layout-original </b>must be given.  If the
              array was created and used with a kernel from Linux 3.14
              to Linux 5.3, then <b>--update=layout-alternate </b>must be
              given.  This only needs to be given once.  Subsequent
              assembly of the array will happen normally.  For more
              information, see <a href="../man4/md.4.html">md(4)</a>.

              The <b>layout-unspecified </b>option reverts the effect of
              <b>layout-orignal </b>or <b>layout-alternate </b>and allows the array to
              be again used on a kernel prior to Linux 5.3.  This option
              should be used with great caution.

       <b>--freeze-reshape</b>
              This option is intended to be used in start-up scripts
              during the initrd boot phase.  When the array under
              reshape is assembled during the initrd phase, this option
              stops the reshape after the reshape-critical section has
              been restored. This happens before the file system pivot
              operation and avoids loss of filesystem context.  Losing
              file system context would cause reshape to be broken.

              Reshape can be continued later using the <b>--continue </b>option
              for the grow command.
</pre> <h2>
For Manage mode: </h2>
<pre>
       <b>-t</b>, <b>--test</b>
              Unless a more serious error occurred, <i>mdadm</i> will exit with
              a status of 2 if no changes were made to the array and 0
              if at least one change was made.  This can be useful when
              an indirect specifier such as <b>missing</b>, <b>detached </b>or <b>faulty</b>
              is used in requesting an operation on the array.  <b>--test</b>
              will report failure if these specifiers didn't find any
              match.

       <b>-a</b>, <b>--add</b>
              hot-add listed devices.  If a device appears to have
              recently been part of the array (possibly it failed or was
              removed) the device is re-added as described in the next
              point.  If that fails or the device was never part of the
              array, the device is added as a hot-spare.  If the array
              is degraded, it will immediately start to rebuild data
              onto that spare.

              Note that this and the following options are only
              meaningful on array with redundancy.  They don't apply to
              RAID0 or Linear.

       <b>--re-add</b>
              re-add a device that was previously removed from an array.
              If the metadata on the device reports that it is a member
              of the array, and the slot that it used is still vacant,
              then the device will be added back to the array in the
              same position.  This will normally cause the data for that
              device to be recovered.  However, based on the event count
              on the device, the recovery may only require sections that
              are flagged by a write-intent bitmap to be recovered or
              may not require any recovery at all.

              When used on an array that has no metadata (i.e. it was
              built with <b>--build) </b>it will be assumed that bitmap-based
              recovery is enough to make the device fully consistent
              with the array.

              <b>--re-add </b>can also be accompanied by <b>--update=devicesize</b>,
              <b>--update=bbl</b>, or <b>--update=no-bbl</b>.  See descriptions of
              these options when used in Assemble mode for an
              explanation of their use.

              If the device name given is <b>missing </b>then <i>mdadm</i> will try to
              find any device that looks like it should be part of the
              array but isn't and will try to re-add all such devices.

              If the device name given is <b>faulty </b>then <i>mdadm</i> will find
              all devices in the array that are marked <b>faulty</b>, remove
              them and attempt to immediately re-add them.  This can be
              useful if you are certain that the reason for failure has
              been resolved.

       <b>--add-spare</b>
              Add a device as a spare.  This is similar to <b>--add </b>except
              that it does not attempt <b>--re-add </b>first.  The device will
              be added as a spare even if it looks like it could be a
              recent member of the array.

       <b>-r</b>, <b>--remove</b>
              remove listed devices.  They must not be active.  i.e.
              they should be failed or spare devices.

              As well as the name of a device file (e.g.  <b>/dev/sda1</b>) the
              words <b>failed</b>, <b>detached </b>and names like <b>set-A </b>can be given
              to <b>--remove</b>.  The first causes all failed devices to be
              removed.  The second causes any device which is no longer
              connected to the system (i.e an 'open' returns <b>ENXIO</b>) to
              be removed.  The third will remove a set as described
              below under <b>--fail</b>.

       <b>-f</b>, <b>--fail</b>
              Mark listed devices as faulty.  As well as the name of a
              device file, the word <b>detached </b>or a set name like <b>set-A</b>
              can be given.  The former will cause any device that has
              been detached from the system to be marked as failed.  It
              can then be removed.

              For RAID10 arrays where the number of copies evenly
              divides the number of devices, the devices can be
              conceptually divided into sets where each set contains a
              single complete copy of the data on the array.  Sometimes
              a RAID10 array will be configured so that these sets are
              on separate controllers.  In this case, all the devices in
              one set can be failed by giving a name like <b>set-A </b>or <b>set-B</b>
              to <b>--fail</b>.  The appropriate set names are reported by
              <b>--detail</b>.

       <b>--set-faulty</b>
              same as <b>--fail</b>.

       <b>--replace</b>
              Mark listed devices as requiring replacement.  As soon as
              a spare is available, it will be rebuilt and will replace
              the marked device.  This is similar to marking a device as
              faulty, but the device remains in service during the
              recovery process to increase resilience against multiple
              failures.  When the replacement process finishes, the
              replaced device will be marked as faulty.

       <b>--with </b>This can follow a list of <b>--replace </b>devices.  The devices
              listed after <b>--with </b>will preferentially be used to replace
              the devices listed after <b>--replace</b>.  These devices must
              already be spare devices in the array.

       <b>--write-mostly</b>
              Subsequent devices that are added or re-added will have
              the 'write-mostly' flag set.  This is only valid for RAID1
              and means that the 'md' driver will avoid reading from
              these devices if possible.

       <b>--readwrite</b>
              Subsequent devices that are added or re-added will have
              the 'write-mostly' flag cleared.

       <b>--cluster-confirm</b>
              Confirm the existence of the device. This is issued in
              response to an --add request by a node in a cluster. When
              a node adds a device it sends a message to all nodes in
              the cluster to look for a device with a UUID. This
              translates to a udev notification with the UUID of the
              device to be added and the slot number. The receiving node
              must acknowledge this message with --cluster-confirm.
              Valid arguments are &lt;slot&gt;:&lt;devicename&gt; in case the device
              is found or &lt;slot&gt;:missing in case the device is not
              found.

       <b>--add-journal</b>
              Add a journal to an existing array, or recreate journal
              for a RAID-4/5/6 array that lost a journal device. To
              avoid interrupting ongoing write operations, <b>--add-journal</b>
              only works for array in Read-Only state.

       <b>--failfast</b>
              Subsequent devices that are added or re-added will have
              the 'failfast' flag set.  This is only valid for RAID1 and
              RAID10 and means that the 'md' driver will avoid long
              timeouts on error handling where possible.

       <b>--nofailfast</b>
              Subsequent devices that are re-added will be re-added
              without the 'failfast' flag set.

       Each of these options requires that the first device listed is
       the array to be acted upon, and the remainder are component
       devices to be added, removed, marked as faulty, etc.  Several
       different operations can be specified for different devices, e.g.
            mdadm /dev/md0 --add /dev/sda1 --fail /dev/sdb1 --remove
            /dev/sdb1
       Each operation applies to all devices listed until the next
       operation.

       If an array is using a write-intent bitmap, then devices which
       have been removed can be re-added in a way that avoids a full
       reconstruction but instead just updates the blocks that have
       changed since the device was removed.  For arrays with persistent
       metadata (superblocks) this is done automatically.  For arrays
       created with <b>--build </b>mdadm needs to be told that this device we
       removed recently with <b>--re-add</b>.

       Devices can only be removed from an array if they are not in
       active use, i.e. that must be spares or failed devices.  To
       remove an active device, it must first be marked as <b>faulty.</b>
</pre> <h2>
For Misc mode: </h2>
<pre>
       <b>-Q</b>, <b>--query</b>
              Examine a device to see (1) if it is an md device and (2)
              if it is a component of an md array.  Information about
              what is discovered is presented.

       <b>-D</b>, <b>--detail</b>
              Print details of one or more md devices.

       <b>--detail-platform</b>
              Print details of the platform's RAID capabilities
              (firmware / hardware topology) for a given metadata
              format. If used without an argument, mdadm will scan all
              controllers looking for their capabilities. Otherwise,
              mdadm will only look at the controller specified by the
              argument in the form of an absolute filepath or a link,
              e.g.  <i>/sys/devices/pci0000:00/0000:00:1f.2</i>.

       <b>-Y</b>, <b>--export</b>
              When used with <b>--detail</b>, <b>--detail-platform</b>, <b>--examine</b>, or
              <b>--incremental </b>output will be formatted as <b>key=value </b>pairs
              for easy import into the environment.

              With <b>--incremental </b>The value <b>MD_STARTED </b>indicates whether
              an array was started (<b>yes</b>) or not, which may include a
              reason (<b>unsafe</b>, <b>nothing</b>, <b>no</b>).  Also the value <b>MD_FOREIGN</b>
              indicates if the array is expected on this host (<b>no</b>), or
              seems to be from elsewhere (<b>yes</b>).

       <b>-E</b>, <b>--examine</b>
              Print contents of the metadata stored on the named
              device(s).  Note the contrast between <b>--examine </b>and
              <b>--detail</b>.  <b>--examine </b>applies to devices which are
              components of an array, while <b>--detail </b>applies to a whole
              array which is currently active.

       <b>--sparc2.2</b>
              If an array was created on a SPARC machine with a 2.2
              Linux kernel patched with RAID support, the superblock
              will have been created incorrectly, or at least
              incompatibly with 2.4 and later kernels.  Using the
              <b>--sparc2.2 </b>flag with <b>--examine </b>will fix the superblock
              before displaying it.  If this appears to do the right
              thing, then the array can be successfully assembled using
              <b>--assemble --update=sparc2.2</b>.

       <b>-X</b>, <b>--examine-bitmap</b>
              Report information about a bitmap file.  The argument is
              either an external bitmap file or an array component in
              case of an internal bitmap.  Note that running this on an
              array device (e.g.  <b>/dev/md0</b>) does not report the bitmap
              for that array.

       <b>--examine-badblocks</b>
              List the bad-blocks recorded for the device, if a bad-
              blocks list has been configured. Currently only <b>1.x </b>and
              <b>IMSM </b>metadata support bad-blocks lists.

       <b>--dump=</b><i>directory</i>

       <b>--restore=</b><i>directory</i>
              Save metadata from lists devices, or restore metadata to
              listed devices.

       <b>-R</b>, <b>--run</b>
              start a partially assembled array.  If <b>--assemble </b>did not
              find enough devices to fully start the array, it might
              leaving it partially assembled.  If you wish, you can then
              use <b>--run </b>to start the array in degraded mode.

       <b>-S</b>, <b>--stop</b>
              deactivate array, releasing all resources.

       <b>-o</b>, <b>--readonly</b>
              mark array as readonly.

       <b>-w</b>, <b>--readwrite</b>
              mark array as readwrite.

       <b>--zero-superblock</b>
              If the device contains a valid md superblock, the block is
              overwritten with zeros.  With <b>--force </b>the block where the
              superblock would be is overwritten even if it doesn't
              appear to be valid.

              <b>Note: </b>Be careful when calling --zero-superblock with
              clustered raid. Make sure the array isn't used or
              assembled in another cluster node before executing it.

       <b>--kill-subarray=</b>
              If the device is a container and the argument to
              --kill-subarray specifies an inactive subarray in the
              container, then the subarray is deleted.  Deleting all
              subarrays will leave an 'empty-container' or spare
              superblock on the drives.  See <b>--zero-superblock </b>for
              completely removing a superblock.  Note that some formats
              depend on the subarray index for generating a UUID, this
              command will fail if it would change the UUID of an active
              subarray.

       <b>--update-subarray=</b>
              If the device is a container and the argument to
              --update-subarray specifies a subarray in the container,
              then attempt to update the given superblock field in the
              subarray. See below in <b>MISC MODE </b>for details.

       <b>-t</b>, <b>--test</b>
              When used with <b>--detail</b>, the exit status of <i>mdadm</i> is set
              to reflect the status of the device.  See below in <b>MISC</b>
              <b>MODE </b>for details.

       <b>-W</b>, <b>--wait</b>
              For each md device given, wait for any resync, recovery,
              or reshape activity to finish before returning.  <i>mdadm</i>
              will return with success if it actually waited for every
              device listed, otherwise it will return failure.

       <b>--wait-clean</b>
              For each md device given, or each device in /proc/mdstat
              if <b>--scan </b>is given, arrange for the array to be marked
              clean as soon as possible.  <i>mdadm</i> will return with success
              if the array uses external metadata and we successfully
              waited.  For native arrays, this returns immediately as
              the kernel handles dirty-clean transitions at shutdown.
              No action is taken if safe-mode handling is disabled.

       <b>--action=</b>
              Set the "sync_action" for all md devices given to one of
              <b>idle</b>, <b>frozen</b>, <b>check</b>, <b>repair</b>.  Setting to <b>idle </b>will abort
              any currently running action though some actions will
              automatically restart.  Setting to <b>frozen </b>will abort any
              current action and ensure no other action starts
              automatically.

              Details of <b>check </b>and <b>repair </b>can be found it <a href="../man4/md.4.html">md(4)</a> under
              <b>SCRUBBING AND MISMATCHES</b>.
</pre> <h2>
For Incremental Assembly mode: </h2>
<pre>
       <b>--rebuild-map</b>, <b>-r</b>
              Rebuild the map file (<b>/run/mdadm/map</b>) that <i>mdadm</i> uses to
              help track which arrays are currently being assembled.

       <b>--run</b>, <b>-R</b>
              Run any array assembled as soon as a minimal number of
              devices is available, rather than waiting until all
              expected devices are present.

       <b>--scan</b>, <b>-s</b>
              Only meaningful with <b>-R </b>this will scan the <b>map </b>file for
              arrays that are being incrementally assembled and will try
              to start any that are not already started.  If any such
              array is listed in <b>mdadm.conf </b>as requiring an external
              bitmap, that bitmap will be attached first.

       <b>--fail</b>, <b>-f</b>
              This allows the hot-plug system to remove devices that
              have fully disappeared from the kernel.  It will first
              fail and then remove the device from any array it belongs
              to.  The device name given should be a kernel device name
              such as "sda", not a name in <i>/dev</i>.

       <b>--path=</b>
              Only used with --fail.  The 'path' given will be recorded
              so that if a new device appears at the same location it
              can be automatically added to the same array.  This allows
              the failed device to be automatically replaced by a new
              device without metadata if it appears at specified path.
              This option is normally only set by an <i>udev</i> script.
</pre> <h2>
For Monitor mode: </h2>
<pre>
       <b>-m</b>, <b>--mail</b>
              Give a mail address to send alerts to.

       <b>-p</b>, <b>--program</b>, <b>--alert</b>
              Give a program to be run whenever an event is detected.

       <b>-y</b>, <b>--syslog</b>
              Cause all events to be reported through 'syslog'.  The
              messages have facility of 'daemon' and varying priorities.

       <b>-d</b>, <b>--delay</b>
              Give a delay in seconds.  <i>mdadm</i> polls the md arrays and
              then waits this many seconds before polling again.  The
              default is 60 seconds.  Since 2.6.16, there is no need to
              reduce this as the kernel alerts <i>mdadm</i> immediately when
              there is any change.

       <b>-r</b>, <b>--increment</b>
              Give a percentage increment.  <i>mdadm</i> will generate
              RebuildNN events with the given percentage increment.

       <b>-f</b>, <b>--daemonise</b>
              Tell <i>mdadm</i> to run as a background daemon if it decides to
              monitor anything.  This causes it to fork and run in the
              child, and to disconnect from the terminal.  The process
              id of the child is written to stdout.  This is useful with
              <b>--scan </b>which will only continue monitoring if a mail
              address or alert program is found in the config file.

       <b>-i</b>, <b>--pid-file</b>
              When <i>mdadm</i> is running in daemon mode, write the pid of the
              daemon process to the specified file, instead of printing
              it on standard output.

       <b>-1</b>, <b>--oneshot</b>
              Check arrays only once.  This will generate <b>NewArray</b>
              events and more significantly <b>DegradedArray </b>and
              <b>SparesMissing </b>events.  Running
                      <b>mdadm --monitor --scan -1</b>
              from a cron script will ensure regular notification of any
              degraded arrays.

       <b>-t</b>, <b>--test</b>
              Generate a <b>TestMessage </b>alert for every array found at
              startup.  This alert gets mailed and passed to the alert
              program.  This can be used for testing that alert message
              do get through successfully.

       <b>--no-sharing</b>
              This inhibits the functionality for moving spares between
              arrays.  Only one monitoring process started with <b>--scan</b>
              but without this flag is allowed, otherwise the two could
              interfere with each other.
</pre> <h2>
ASSEMBLE MODE </h2>
<pre>

       Usage: <b>mdadm --assemble </b><i>md-device options-and-component-</i>
                   <i>devices...</i>

       Usage: <b>mdadm --assemble --scan </b><i>md-devices-and-options...</i>

       Usage: <b>mdadm --assemble --scan </b><i>options...</i>

       This usage assembles one or more RAID arrays from pre-existing
       components.  For each array, mdadm needs to know the md device,
       the identity of the array, and the number of component devices.
       These can be found in a number of ways.

       In the first usage example (without the <b>--scan</b>) the first device
       given is the md device.  In the second usage example, all devices
       listed are treated as md devices and assembly is attempted.  In
       the third (where no devices are listed) all md devices that are
       listed in the configuration file are assembled.  If no arrays are
       described by the configuration file, then any arrays that can be
       found on unused devices will be assembled.

       If precisely one device is listed, but <b>--scan </b>is not given, then
       <i>mdadm</i> acts as though <b>--scan </b>was given and identity information is
       extracted from the configuration file.

       The identity can be given with the <b>--uuid </b>option, the <b>--name</b>
       option, or the <b>--super-minor </b>option, will be taken from the md-
       device record in the config file, or will be taken from the super
       block of the first component-device listed on the command line.

       Devices can be given on the <b>--assemble </b>command line or in the
       config file.  Only devices which have an md superblock which
       contains the right identity will be considered for any array.

       The config file is only used if explicitly named with <b>--config </b>or
       requested with (a possibly implicit) <b>--scan</b>.  In the latter case,
       the default config file is used.  See <a href="../man5/mdadm.conf.5.html">mdadm.conf(5)</a> for more
       details.

       If <b>--scan </b>is not given, then the config file will only be used to
       find the identity of md arrays.

       Normally the array will be started after it is assembled.
       However if <b>--scan </b>is not given and not all expected drives were
       listed, then the array is not started (to guard against usage
       errors).  To insist that the array be started in this case (as
       may work for RAID1, 4, 5, 6, or 10), give the <b>--run </b>flag.

       If <i>udev</i> is active, <i>mdadm</i> does not create any entries in <b>/dev </b>but
       leaves that to <i>udev</i>.  It does record information in
       <b>/run/mdadm/map </b>which will allow <i>udev</i> to choose the correct name.

       If <i>mdadm</i> detects that udev is not configured, it will create the
       devices in <b>/dev </b>itself.

       In Linux kernels prior to version 2.6.28 there were two distinct
       types of md devices that could be created: one that could be
       partitioned using standard partitioning tools and one that could
       not.  Since 2.6.28 that distinction is no longer relevant as both
       types of devices can be partitioned.  <i>mdadm</i> will normally create
       the type that originally could not be partitioned as it has a
       well-defined major number (9).

       Prior to 2.6.28, it is important that mdadm chooses the correct
       type of array device to use.  This can be controlled with the
       <b>--auto </b>option.  In particular, a value of "mdp" or "part" or "p"
       tells mdadm to use a partitionable device rather than the
       default.

       In the no-udev case, the value given to <b>--auto </b>can be suffixed by
       a number.  This tells <i>mdadm</i> to create that number of partition
       devices rather than the default of 4.

       The value given to <b>--auto </b>can also be given in the configuration
       file as a word starting <b>auto= </b>on the ARRAY line for the relevant
       array.

   <b>Auto-Assembly</b>
       When <b>--assemble </b>is used with <b>--scan </b>and no devices are listed,
       <i>mdadm</i> will first attempt to assemble all the arrays listed in the
       config file.

       If no arrays are listed in the config (other than those marked
       <b>&lt;ignore&gt;</b>) it will look through the available devices for possible
       arrays and will try to assemble anything that it finds.  Arrays
       which are tagged as belonging to the given homehost will be
       assembled and started normally.  Arrays which do not obviously
       belong to this host are given names that are expected not to
       conflict with anything local, and are started "read-auto" so that
       nothing is written to any device until the array is written to.
       i.e.  automatic resync etc is delayed.

       If <i>mdadm</i> finds a consistent set of devices that look like they
       should comprise an array, and if the superblock is tagged as
       belonging to the given home host, it will automatically choose a
       device name and try to assemble the array.  If the array uses
       version-0.90 metadata, then the <b>minor </b>number as recorded in the
       superblock is used to create a name in <b>/dev/md/ </b>so for example
       <b>/dev/md/3</b>.  If the array uses version-1 metadata, then the <b>name</b>
       from the superblock is used to similarly create a name in
       <b>/dev/md/ </b>(the name will have any 'host' prefix stripped first).

       This behaviour can be modified by the <i>AUTO</i> line in the <i>mdadm.conf</i>
       configuration file.  This line can indicate that specific
       metadata type should, or should not, be automatically assembled.
       If an array is found which is not listed in <i>mdadm.conf</i> and has a
       metadata format that is denied by the <i>AUTO</i> line, then it will not
       be assembled.  The <i>AUTO</i> line can also request that all arrays
       identified as being for this homehost should be assembled
       regardless of their metadata type.  See <a href="../man5/mdadm.conf.5.html">mdadm.conf(5)</a> for further
       details.

       Note: Auto-assembly cannot be used for assembling and activating
       some arrays which are undergoing reshape.  In particular as the
       <b>backup-file </b>cannot be given, any reshape which requires a backup
       file to continue cannot be started by auto-assembly.  An array
       which is growing to more devices and has passed the critical
       section can be assembled using auto-assembly.
</pre> <h2>
BUILD MODE </h2>
<pre>

       Usage: <b>mdadm --build </b><i>md-device</i> <b>--chunk=</b><i>X</i> <b>--level=</b><i>Y</i>
                   <b>--raid-devices=</b><i>Z devices</i>

       This usage is similar to <b>--create</b>.  The difference is that it
       creates an array without a superblock.  With these arrays there
       is no difference between initially creating the array and
       subsequently assembling the array, except that hopefully there is
       useful data there in the second case.

       The level may raid0, linear, raid1, raid10, multipath, or faulty,
       or one of their synonyms.  All devices must be listed and the
       array will be started once complete.  It will often be
       appropriate to use <b>--assume-clean </b>with levels raid1 or raid10.
</pre> <h2>
CREATE MODE </h2>
<pre>

       Usage: <b>mdadm --create </b><i>md-device</i> <b>--chunk=</b><i>X</i> <b>--level=</b><i>Y</i>
                   <b>--raid-devices=</b><i>Z devices</i>

       This usage will initialize a new md array, associate some devices
       with it, and activate the array.

       <i>md-device</i> is a new device. This could be standard name or chosen
       name. For details see: <b>DEVICE NAMES</b>

       The named device will normally not exist when <i>mdadm --create</i> is
       run, but will be created by <i>udev</i> once the array becomes active.

       The max length md-device name is limited to 32 characters.
       Different metadata types have more strict limitation (like IMSM
       where only 16 characters are allowed).  For that reason, long
       name could be truncated or rejected, it depends on metadata
       policy.

       As devices are added, they are checked to see if they contain
       RAID superblocks or filesystems.  They are also checked to see if
       the variance in device size exceeds 1%.

       If any discrepancy is found, the array will not automatically be
       run, though the presence of a <b>--run </b>can override this caution.

       To create a "degraded" array in which some devices are missing,
       simply give the word "<b>missing</b>" in place of a device name.  This
       will cause <i>mdadm</i> to leave the corresponding slot in the array
       empty.  For a RAID4 or RAID5 array at most one slot can be
       "<b>missing</b>"; for a RAID6 array at most two slots.  For a RAID1
       array, only one real device needs to be given.  All of the others
       can be "<b>missing</b>".

       When creating a RAID5 array, <i>mdadm</i> will automatically create a
       degraded array with an extra spare drive.  This is because
       building the spare into a degraded array is in general faster
       than resyncing the parity on a non-degraded, but not clean,
       array.  This feature can be overridden with the <b>--force </b>option.

       When creating a partition based array, using <i>mdadm</i> with
       version-1.x metadata, the partition type should be set to <b>0xDA</b>
       (non fs-data).  This type of selection allows for greater
       precision since using any other [RAID auto-detect (0xFD) or a
       GNU/Linux partition (0x83)], might create problems in the event
       of array recovery through a live cdrom.

       A new array will normally get a randomly assigned 128bit UUID
       which is very likely to be unique.  If you have a specific need,
       you can choose a UUID for the array by giving the <b>--uuid= </b>option.
       Be warned that creating two arrays with the same UUID is a recipe
       for disaster.  Also, using <b>--uuid= </b>when creating a v0.90 array
       will silently override any <b>--homehost= </b>setting.

       If the array type supports a write-intent bitmap, and if the
       devices in the array exceed 100G is size, an internal write-
       intent bitmap will automatically be added unless some other
       option is explicitly requested with the <b>--bitmap </b>option or a
       different consistency policy is selected with the
       <b>--consistency-policy </b>option. In any case, space for a bitmap will
       be reserved so that one can be added later with <b>--grow</b>
       <b>--bitmap=internal</b>.

       If the metadata type supports it (currently only 1.x and IMSM
       metadata), space will be allocated to store a bad block list.
       This allows a modest number of bad blocks to be recorded,
       allowing the drive to remain in service while only partially
       functional.

       When creating an array within a <b>CONTAINER </b><i>mdadm</i> can be given
       either the list of devices to use, or simply the name of the
       container.  The former case gives control over which devices in
       the container will be used for the array.  The latter case allows
       <i>mdadm</i> to automatically choose which devices to use based on how
       much spare space is available.

       The General Management options that are valid with <b>--create </b>are:

       <b>--run  </b>insist on running the array even if some devices look like
              they might be in use.

       <b>--readonly</b>
              start the array in readonly mode.
</pre> <h2>
MANAGE MODE </h2>
<pre>

       Usage: <b>mdadm </b><i>device options... devices...</i>

       This usage will allow individual devices in an array to be
       failed, removed or added.  It is possible to perform multiple
       operations with on command.  For example:
         <b>mdadm /dev/md0 -f /dev/hda1 -r /dev/hda1 -a /dev/hda1</b>
       will firstly mark <b>/dev/hda1 </b>as faulty in <b>/dev/md0 </b>and will then
       remove it from the array and finally add it back in as a spare.
       However, only one md array can be affected by a single command.

       When a device is added to an active array, mdadm checks to see if
       it has metadata on it which suggests that it was recently a
       member of the array.  If it does, it tries to "re-add" the
       device.  If there have been no changes since the device was
       removed, or if the array has a write-intent bitmap which has
       recorded whatever changes there were, then the device will
       immediately become a full member of the array and those
       differences recorded in the bitmap will be resolved.
</pre> <h2>
MISC MODE </h2>
<pre>

       Usage: <b>mdadm </b><i>options ...</i>  <i>devices ...</i>

       MISC mode includes a number of distinct operations that operate
       on distinct devices.  The operations are:

       <b>--query</b>
              The device is examined to see if it is (1) an active md
              array, or (2) a component of an md array.  The information
              discovered is reported.

       <b>--detail</b>
              The device should be an active md device.  <b>mdadm </b>will
              display a detailed description of the array.  <b>--brief </b>or
              <b>--scan </b>will cause the output to be less detailed and the
              format to be suitable for inclusion in <b>mdadm.conf</b>.  The
              exit status of <i>mdadm</i> will normally be 0 unless <i>mdadm</i>
              failed to get useful information about the device(s);
              however, if the <b>--test </b>option is given, then the exit
              status will be:

              0      The array is functioning normally.

              1      The array has at least one failed device.

              2      The array has multiple failed devices such that it
                     is unusable.

              4      There was an error while trying to get information
                     about the device.

       <b>--detail-platform</b>
              Print detail of the platform's RAID capabilities (firmware
              / hardware topology).  If the metadata is specified with
              <b>-e </b>or <b>--metadata= </b>then the return status will be:

              0      metadata successfully enumerated its platform
                     components on this system

              1      metadata is platform independent

              2      metadata failed to find its platform components on
                     this system

       <b>--update-subarray=</b>
              If the device is a container and the argument to
              --update-subarray specifies a subarray in the container,
              then attempt to update the given superblock field in the
              subarray.  Similar to updating an array in "assemble"
              mode, the field to update is selected by <b>-U </b>or <b>--update=</b>
              option. The supported options are <b>name</b>, <b>ppl</b>, <b>no-ppl</b>,
              <b>bitmap </b>and <b>no-bitmap</b>.

              The <b>name </b>option updates the subarray name in the metadata.
              It must be <b>POSIX PORTABLE NAME </b>compatible and cannot be
              longer than 32 chars. If successes, new value will be
              respected after next assembly.

              The <b>ppl </b>and <b>no-ppl </b>options enable and disable PPL in the
              metadata. Currently supported only for IMSM subarrays.

              The <b>bitmap </b>and <b>no-bitmap </b>options enable and disable write-
              intent bitmap in the metadata. Currently supported only
              for IMSM subarrays.

       <b>--examine</b>
              The device should be a component of an md array.  <i>mdadm</i>
              will read the md superblock of the device and display the
              contents.  If <b>--brief </b>or <b>--scan </b>is given, then multiple
              devices that are components of the one array are grouped
              together and reported in a single entry suitable for
              inclusion in <b>mdadm.conf</b>.

              Having <b>--scan </b>without listing any devices will cause all
              devices listed in the config file to be examined.

       <b>--dump=</b><i>directory</i>
              If the device contains RAID metadata, a file will be
              created in the <i>directory</i> and the metadata will be written
              to it.  The file will be the same size as the device and
              will have the metadata written at the same location as it
              exists in the device.  However, the file will be "sparse"
              so that only those blocks containing metadata will be
              allocated. The total space used will be small.

              The filename used in the <i>directory</i> will be the base name
              of the device.   Further, if any links appear in
              <i>/dev/disk/by-id</i> which point to the device, then hard links
              to the file will be created in <i>directory</i> based on these
              <i>by-id</i> names.

              Multiple devices can be listed and their metadata will all
              be stored in the one directory.

       <b>--restore=</b><i>directory</i>
              This is the reverse of <b>--dump</b>.  <i>mdadm</i> will locate a file
              in the directory that has a name appropriate for the given
              device and will restore metadata from it.  Names that
              match <i>/dev/disk/by-id</i> names are preferred, however if two
              of those refer to different files, <i>mdadm</i> will not choose
              between them but will abort the operation.

              If a file name is given instead of a <i>directory</i> then <i>mdadm</i>
              will restore from that file to a single device, always
              provided the size of the file matches that of the device,
              and the file contains valid metadata.

       <b>--stop </b>The devices should be active md arrays which will be
              deactivated, as long as they are not currently in use.

       <b>--run  </b>This will fully activate a partially assembled md array.

       <b>--readonly</b>
              This will mark an active array as read-only, providing
              that it is not currently being used.

       <b>--readwrite</b>
              This will change a <b>readonly </b>array back to being
              read/write.

       <b>--scan </b>For all operations except <b>--examine</b>, <b>--scan </b>will cause the
              operation to be applied to all arrays listed in
              <b>/proc/mdstat</b>.  For <b>--examine, --scan </b>causes all devices
              listed in the config file to be examined.

       <b>-b</b>, <b>--brief</b>
              Be less verbose.  This is used with <b>--detail </b>and
              <b>--examine</b>.  Using <b>--brief </b>with <b>--verbose </b>gives an
              intermediate level of verbosity.
</pre> <h2>
MONITOR MODE </h2>
<pre>

       Usage: <b>mdadm --monitor </b><i>options... devices...</i>

       Monitor option can work in two modes:

       •   system wide mode, follow all md devices based on
           <b>/proc/mdstat,</b>

       •   follow only specified MD devices in command line.

       <b>--scan - </b>indicates system wide mode. Option causes the <i>monitor</i> to
       track all md devices that appear in <b>/proc/mdstat.  </b>If it is not
       set, then at least one <b>device </b>must be specified.

       Monitor usage causes <i>mdadm</i> to periodically poll a number of md
       arrays and to report on any events noticed.

       In both modes, <i>monitor</i> will work as long as there is an active
       array with redundancy and it is defined to follow (for <b>--scan</b>
       every array is followed).

       As well as reporting events, <i>mdadm</i> may move a spare drive from
       one array to another if they are in the same <b>spare-group </b>or
       <b>domain </b>and if the destination array has a failed drive but no
       spares.

       The result of monitoring the arrays is the generation of events.
       These events are passed to a separate program (if specified) and
       may be mailed to a given E-mail address.

       When passing events to a program, the program is run once for
       each event, and is given 2 or 3 command-line arguments: the first
       is the name of the event (see below), the second is the name of
       the md device which is affected, and the third is the name of a
       related device if relevant (such as a component device that has
       failed).

       If <b>--scan </b>is given, then a <b>program </b>or an <b>e-mail </b>address must be
       specified on the command line or in the config file. If neither
       are available, then <i>mdadm</i> will not monitor anything.  For devices
       given directly in command line, without <b>program </b>or <b>email</b>
       specified, each event is reported to <b>stdout.</b>

       Note: For systems where is configured via systemd,
       <b>mdmonitor(mdmonitor.service) </b>should be configured. The service is
       designed to be primary solution for array monitoring, it is
       configured to work in system wide mode.  It is automatically
       started and stopped according to current state and types of MD
       arrays in system.  The service may require additional
       configuration, like <b>e-mail </b>or <b>delay.  </b>That should be done in
       <b>mdadm.conf.</b>

       The different events are:

           <b>DeviceDisappeared</b>
                  An md array which previously was configured appears to
                  no longer be configured. (syslog priority: Critical)

                  If <i>mdadm</i> was told to monitor an array which is RAID0
                  or Linear, then it will report <b>DeviceDisappeared </b>with
                  the extra information <b>Wrong-Level</b>.  This is because
                  RAID0 and Linear do not support the device-failed,
                  hot-spare and resync operations which are monitored.

           <b>RebuildStarted</b>
                  An md array started reconstruction (e.g. recovery,
                  resync, reshape, check, repair). (syslog priority:
                  Warning)

           <b>Rebuild</b><i>NN</i>
                  Where <i>NN</i> is a two-digit number (eg. 05, 48). This
                  indicates that the rebuild has reached that percentage
                  of the total. The events are generated at a fixed
                  increment from 0. The increment size may be specified
                  with a command-line option (the default is 20).
                  (syslog priority: Warning)

           <b>RebuildFinished</b>
                  An md array that was rebuilding, isn't any more,
                  either because it finished normally or was aborted.
                  (syslog priority: Warning)

           <b>Fail   </b>An active component device of an array has been marked
                  as faulty. (syslog priority: Critical)

           <b>FailSpare</b>
                  A spare component device which was being rebuilt to
                  replace a faulty device has failed. (syslog priority:
                  Critical)

           <b>SpareActive</b>
                  A spare component device which was being rebuilt to
                  replace a faulty device has been successfully rebuilt
                  and has been made active.  (syslog priority: Info)

           <b>NewArray</b>
                  A new md array has been detected in the <b>/proc/mdstat</b>
                  file.  (syslog priority: Info)

           <b>DegradedArray</b>
                  A newly noticed array appears to be degraded.  This
                  message is not generated when <i>mdadm</i> notices a drive
                  failure which causes degradation, but only when <i>mdadm</i>
                  notices that an array is degraded when it first sees
                  the array.  (syslog priority: Critical)

           <b>MoveSpare</b>
                  A spare drive has been moved from one array in a
                  <b>spare-group </b>or <b>domain </b>to another to allow a failed
                  drive to be replaced.  (syslog priority: Info)

           <b>SparesMissing</b>
                  If <i>mdadm</i> has been told, via the config file, that an
                  array should have a certain number of spare devices,
                  and <i>mdadm</i> detects that it has fewer than this number
                  when it first sees the array, it will report a
                  <b>SparesMissing </b>message.  (syslog priority: Warning)

           <b>TestMessage</b>
                  An array was found at startup, and the <b>--test </b>flag was
                  given.  (syslog priority: Info)

       Only <b>Fail, FailSpare, DegradedArray, SparesMissing </b>and
       <b>TestMessage </b>cause Email to be sent.  All events cause the program
       to be run.  The program is run with two or three arguments: the
       event name, the array device and possibly a second device.

       Each event has an associated array device (e.g.  <b>/dev/md1</b>) and
       possibly a second device.  For <b>Fail</b>, <b>FailSpare</b>, and <b>SpareActive</b>
       the second device is the relevant component device.  For
       <b>MoveSpare </b>the second device is the array that the spare was moved
       from.

       For <i>mdadm</i> to move spares from one array to another, the different
       arrays need to be labeled with the same <b>spare-group </b>or the spares
       must be allowed to migrate through matching POLICY domains in the
       configuration file.  The <b>spare-group </b>name can be any string; it
       is only necessary that different spare groups use different
       names.

       When <i>mdadm</i> detects that an array in a spare group has fewer
       active devices than necessary for the complete array, and has no
       spare devices, it will look for another array in the same spare
       group that has a full complement of working drives and a spare.
       It will then attempt to remove the spare from the second array
       and add it to the first.  If the removal succeeds but the adding
       fails, then it is added back to the original array.

       If the spare group for a degraded array is not defined, <i>mdadm</i>
       will look at the rules of spare migration specified by POLICY
       lines in <b>mdadm.conf </b>and then follow similar steps as above if a
       matching spare is found.
</pre> <h2>
GROW MODE </h2>
<pre>
       The GROW mode is used for changing the size or shape of an active
       array.

       During the kernel 2.6 era the following changes were added:

       •   change the "size" attribute for RAID1, RAID4, RAID5 and
           RAID6.

       •   increase or decrease the "raid-devices" attribute of RAID0,
           RAID1, RAID4, RAID5, and RAID6.

       •   change the chunk-size and layout of RAID0, RAID4, RAID5,
           RAID6 and RAID10.

       •   convert between RAID1 and RAID5, between RAID5 and RAID6,
           between RAID0, RAID4, and RAID5, and between RAID0 and RAID10
           (in the near-2 mode).

       •   add a write-intent bitmap to any array which supports these
           bitmaps, or remove a write-intent bitmap from such an array.

       •   change the array's consistency policy.

       Using GROW on containers is currently supported only for Intel's
       IMSM container format.  The number of devices in a container can
       be increased - which affects all arrays in the container - or an
       array in a container can be converted between levels where those
       levels are supported by the container, and the conversion is on
       of those listed above.

       Notes:

       •   Intel's native checkpointing doesn't use <b>--backup-file </b>option
           and it is transparent for assembly feature.

       •   Roaming between Windows(R) and Linux systems for IMSM
           metadata is not supported during grow process.

       •   When growing a raid0 device, the new component disk size (or
           external backup size) should be larger than LCM(old, new) *
           chunk-size * 2, where LCM() is the least common multiple of
           the old and new count of component disks, and "* 2" comes
           from the fact that mdadm refuses to use more than half of a
           spare device for backup space.

   <b>SIZE CHANGES</b>
       Normally when an array is built the "size" is taken from the
       smallest of the drives.  If all the small drives in an arrays
       are, over time, removed and replaced with larger drives, then you
       could have an array of large drives with only a small amount
       used.  In this situation, changing the "size" with "GROW" mode
       will allow the extra space to start being used.  If the size is
       increased in this way, a "resync" process will start to make sure
       the new parts of the array are synchronised.

       Note that when an array changes size, any filesystem that may be
       stored in the array will not automatically grow or shrink to use
       or vacate the space.  The filesystem will need to be explicitly
       told to use the extra space after growing, or to reduce its size
       <b>prior </b>to shrinking the array.

       Also, the size of an array cannot be changed while it has an
       active bitmap.  If an array has a bitmap, it must be removed
       before the size can be changed. Once the change is complete a new
       bitmap can be created.

       Note: <b>--grow --size </b>is not yet supported for external file
       bitmap.

   <b>RAID-DEVICES CHANGES</b>
       A RAID1 array can work with any number of devices from 1 upwards
       (though 1 is not very useful).  There may be times which you want
       to increase or decrease the number of active devices.  Note that
       this is different to hot-add or hot-remove which changes the
       number of inactive devices.

       When reducing the number of devices in a RAID1 array, the slots
       which are to be removed from the array must already be vacant.
       That is, the devices which were in those slots must be failed and
       removed.

       When the number of devices is increased, any hot spares that are
       present will be activated immediately.

       Changing the number of active devices in a RAID5 or RAID6 is much
       more effort.  Every block in the array will need to be read and
       written back to a new location.  From 2.6.17, the Linux Kernel is
       able to increase the number of devices in a RAID5 safely,
       including restarting an interrupted "reshape".  From 2.6.31, the
       Linux Kernel is able to increase or decrease the number of
       devices in a RAID5 or RAID6.

       From 2.6.35, the Linux Kernel is able to convert a RAID0 in to a
       RAID4 or RAID5.  <i>mdadm</i> uses this functionality and the ability to
       add devices to a RAID4 to allow devices to be added to a RAID0.
       When requested to do this, <i>mdadm</i> will convert the RAID0 to a
       RAID4, add the necessary disks and make the reshape happen, and
       then convert the RAID4 back to RAID0.

       When decreasing the number of devices, the size of the array will
       also decrease.  If there was data in the array, it could get
       destroyed and this is not reversible, so you should firstly
       shrink the filesystem on the array to fit within the new size.
       To help prevent accidents, <i>mdadm</i> requires that the size of the
       array be decreased first with <b>mdadm --grow --array-size</b>.  This is
       a reversible change which simply makes the end of the array
       inaccessible.  The integrity of any data can then be checked
       before the non-reversible reduction in the number of devices is
       request.

       When relocating the first few stripes on a RAID5 or RAID6, it is
       not possible to keep the data on disk completely consistent and
       crash-proof.  To provide the required safety, mdadm disables
       writes to the array while this "critical section" is reshaped,
       and takes a backup of the data that is in that section.  For
       grows, this backup may be stored in any spare devices that the
       array has, however it can also be stored in a separate file
       specified with the <b>--backup-file </b>option, and is required to be
       specified for shrinks, RAID level changes and layout changes.  If
       this option is used, and the system does crash during the
       critical period, the same file must be passed to <b>--assemble </b>to
       restore the backup and reassemble the array.  When shrinking
       rather than growing the array, the reshape is done from the end
       towards the beginning, so the "critical section" is at the end of
       the reshape.

   <b>LEVEL CHANGES</b>
       Changing the RAID level of any array happens instantaneously.
       However in the RAID5 to RAID6 case this requires a non-standard
       layout of the RAID6 data, and in the RAID6 to RAID5 case that
       non-standard layout is required before the change can be
       accomplished.  So while the level change is instant, the
       accompanying layout change can take quite a long time.  A
       <b>--backup-file </b>is required.  If the array is not simultaneously
       being grown or shrunk, so that the array size will remain the
       same - for example, reshaping a 3-drive RAID5 into a 4-drive
       RAID6 - the backup file will be used not just for a "critical
       section" but throughout the reshape operation, as described below
       under LAYOUT CHANGES.

   <b>CHUNK-SIZE AND LAYOUT CHANGES</b>
       Changing the chunk-size or layout without also changing the
       number of devices as the same time will involve re-writing all
       blocks in-place.  To ensure against data loss in the case of a
       crash, a <b>--backup-file </b>must be provided for these changes.  Small
       sections of the array will be copied to the backup file while
       they are being rearranged.  This means that all the data is
       copied twice, once to the backup and once to the new layout on
       the array, so this type of reshape will go very slowly.

       If the reshape is interrupted for any reason, this backup file
       must be made available to <b>mdadm --assemble </b>so the array can be
       reassembled.  Consequently, the file cannot be stored on the
       device being reshaped.

   <b>BITMAP CHANGES</b>
       A write-intent bitmap can be added to, or removed from, an active
       array.  Either internal bitmaps, or bitmaps stored in a separate
       file, can be added.  Note that if you add a bitmap stored in a
       file which is in a filesystem that is on the RAID array being
       affected, the system will deadlock.  The bitmap must be on a
       separate filesystem.

   <b>CONSISTENCY POLICY CHANGES</b>
       The consistency policy of an active array can be changed by using
       the <b>--consistency-policy </b>option in Grow mode. Currently this
       works only for the <b>ppl </b>and <b>resync </b>policies and allows to enable
       or disable the RAID5 Partial Parity Log (PPL).
</pre> <h2>
INCREMENTAL MODE </h2>
<pre>

       Usage: <b>mdadm --incremental </b>[<b>--run</b>] [<b>--quiet</b>] <i>component-device</i>
                   [<i>optional-aliases-for-device</i>]

       Usage: <b>mdadm --incremental --fail </b><i>component-device</i>

       Usage: <b>mdadm --incremental --rebuild-map</b>

       Usage: <b>mdadm --incremental --run --scan</b>

       This mode is designed to be used in conjunction with a device
       discovery system.  As devices are found in a system, they can be
       passed to <b>mdadm --incremental </b>to be conditionally added to an
       appropriate array.

       Conversely, it can also be used with the <b>--fail </b>flag to do just
       the opposite and find whatever array a particular device is part
       of and remove the device from that array.

       If the device passed is a <b>CONTAINER </b>device created by a previous
       call to <i>mdadm</i>, then rather than trying to add that device to an
       array, all the arrays described by the metadata of the container
       will be started.

       <i>mdadm</i> performs a number of tests to determine if the device is
       part of an array, and which array it should be part of.  If an
       appropriate array is found, or can be created, <i>mdadm</i> adds the
       device to the array and conditionally starts the array.

       Note that <i>mdadm</i> will normally only add devices to an array which
       were previously working (active or spare) parts of that array.
       The support for automatic inclusion of a new drive as a spare in
       some array requires a configuration through POLICY in config
       file.

       The tests that <i>mdadm</i> makes are as follow:

       +      Is the device permitted by <b>mdadm.conf</b>?  That is, is it
              listed in a <b>DEVICES </b>line in that file.  If <b>DEVICES </b>is
              absent then the default it to allow any device.  Similarly
              if <b>DEVICES </b>contains the special word <b>partitions </b>then any
              device is allowed.  Otherwise the device name given to
              <i>mdadm</i>, or one of the aliases given, or an alias found in
              the filesystem, must match one of the names or patterns in
              a <b>DEVICES </b>line.

              This is the only context where the aliases are used.  They
              are usually provided by a <i>udev</i> rules mentioning
              <b>$env{DEVLINKS}</b>.

       +      Does the device have a valid md superblock?  If a specific
              metadata version is requested with <b>--metadata </b>or <b>-e </b>then
              only that style of metadata is accepted, otherwise <i>mdadm</i>
              finds any known version of metadata.  If no <i>md</i> metadata is
              found, the device may be still added to an array as a
              spare if POLICY allows.

       <i>mdadm</i> keeps a list of arrays that it has partially assembled in
       <b>/run/mdadm/map</b>.  If no array exists which matches the metadata on
       the new device, <i>mdadm</i> must choose a device name and unit number.
       It does this based on any name given in <b>mdadm.conf </b>or any name
       information stored in the metadata.  If this name suggests a unit
       number, that number will be used, otherwise a free unit number
       will be chosen.  Normally <i>mdadm</i> will prefer to create a
       partitionable array, however if the <b>CREATE </b>line in <b>mdadm.conf</b>
       suggests that a non-partitionable array is preferred, that will
       be honoured.

       If the array is not found in the config file and its metadata
       does not identify it as belonging to the "homehost", then <i>mdadm</i>
       will choose a name for the array which is certain not to conflict
       with any array which does belong to this host.  It does this be
       adding an underscore and a small number to the name preferred by
       the metadata.

       Once an appropriate array is found or created and the device is
       added, <i>mdadm</i> must decide if the array is ready to be started.  It
       will normally compare the number of available (non-spare) devices
       to the number of devices that the metadata suggests need to be
       active.  If there are at least that many, the array will be
       started.  This means that if any devices are missing the array
       will not be restarted.

       As an alternative, <b>--run </b>may be passed to <i>mdadm</i> in which case the
       array will be run as soon as there are enough devices present for
       the data to be accessible.  For a RAID1, that means one device
       will start the array.  For a clean RAID5, the array will be
       started as soon as all but one drive is present.

       Note that neither of these approaches is really ideal.  If it can
       be known that all device discovery has completed, then
          <b>mdadm -IRs</b>
       can be run which will try to start all arrays that are being
       incrementally assembled.  They are started in "read-auto" mode in
       which they are read-only until the first write request.  This
       means that no metadata updates are made and no attempt at resync
       or recovery happens.  Further devices that are found before the
       first write can still be added safely.
</pre> <h2>
ENVIRONMENT </h2>
<pre>
       This section describes environment variables that affect how
       mdadm operates.

       <b>MDADM_NO_MDMON</b>
              Setting this value to 1 will prevent mdadm from
              automatically launching mdmon.  This variable is intended
              primarily for debugging mdadm/mdmon.

       <b>MDADM_NO_UDEV</b>
              Normally, <i>mdadm</i> does not create any device nodes in /dev,
              but leaves that task to <i>udev</i>.  If <i>udev</i> appears not to be
              configured, or if this environment variable is set to '1',
              the <i>mdadm</i> will create and devices that are needed.

       <b>MDADM_NO_SYSTEMCTL</b>
              If <i>mdadm</i> detects that <i>systemd</i> is in use it will normally
              request <i>systemd</i> to start various background tasks
              (particularly <i>mdmon</i>) rather than forking and running them
              in the background.  This can be suppressed by setting
              <b>MDADM_NO_SYSTEMCTL=1</b>.

       <b>IMSM_NO_PLATFORM</b>
              A key value of IMSM metadata is that it allows
              interoperability with boot ROMs on Intel platforms, and
              with other major operating systems.  Consequently, <i>mdadm</i>
              will only allow an IMSM array to be created or modified if
              detects that it is running on an Intel platform which
              supports IMSM, and supports the particular configuration
              of IMSM that is being requested (some functionality
              requires newer OROM support).

              These checks can be suppressed by setting
              IMSM_NO_PLATFORM=1 in the environment.  This can be useful
              for testing or for disaster recovery.  You should be aware
              that interoperability may be compromised by setting this
              value.

              These change can also be suppressed by adding
              <b>mdadm.imsm.test=1 </b>to the kernel command line. This makes
              it easy to test IMSM code in a virtual machine that
              doesn't have IMSM virtual hardware.

       <b>MDADM_GROW_ALLOW_OLD</b>
              If an array is stopped while it is performing a reshape
              and that reshape was making use of a backup file, then
              when the array is re-assembled <i>mdadm</i> will sometimes
              complain that the backup file is too old.  If this happens
              and you are certain it is the right backup file, you can
              over-ride this check by setting <b>MDADM_GROW_ALLOW_OLD=1 </b>in
              the environment.

       <b>MDADM_CONF_AUTO</b>
              Any string given in this variable is added to the start of
              the <b>AUTO </b>line in the config file, or treated as the whole
              <b>AUTO </b>line if none is given.  It can be used to disable
              certain metadata types when <i>mdadm</i> is called from a boot
              script.  For example
                  <b>export MDADM_CONF_AUTO='-ddf -imsm'</b>
              will make sure that <i>mdadm</i> does not automatically assemble
              any DDF or IMSM arrays that are found.  This can be useful
              on systems configured to manage such arrays with <b>dmraid</b>.
</pre> <h2>
EXAMPLES </h2>
<pre>
         <b>mdadm --query /dev/name-of-device</b>
       This will find out if a given device is a RAID array, or is part
       of one, and will provide brief information about the device.

         <b>mdadm --assemble --scan</b>
       This will assemble and start all arrays listed in the standard
       config file.  This command will typically go in a system startup
       file.

         <b>mdadm --stop --scan</b>
       This will shut down all arrays that can be shut down (i.e. are
       not currently in use).  This will typically go in a system
       shutdown script.

         <b>mdadm --follow --scan --delay=120</b>
       If (and only if) there is an Email address or program given in
       the standard config file, then monitor the status of all arrays
       listed in that file by polling them ever 2 minutes.

         <b>mdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/hd[ac]1</b>
       Create /dev/md0 as a RAID1 array consisting of /dev/hda1 and
       /dev/hdc1.

         <b>echo 'DEVICE /dev/hd*[0-9] /dev/sd*[0-9]' &gt; mdadm.conf</b>
         <b>mdadm --detail --scan &gt;&gt; mdadm.conf</b>
       This will create a prototype config file that describes currently
       active arrays that are known to be made from partitions of IDE or
       SCSI drives.  This file should be reviewed before being used as
       it may contain unwanted detail.

         <b>echo 'DEVICE /dev/hd[a-z] /dev/sd*[a-z]' &gt; mdadm.conf</b>
         <b>mdadm --examine --scan --config=mdadm.conf &gt;&gt; mdadm.conf</b>
       This will find arrays which could be assembled from existing IDE
       and SCSI whole drives (not partitions), and store the information
       in the format of a config file.  This file is very likely to
       contain unwanted detail, particularly the <b>devices= </b>entries.  It
       should be reviewed and edited before being used as an actual
       config file.

         <b>mdadm --examine --brief --scan --config=partitions</b>
         <b>mdadm -Ebsc partitions</b>
       Create a list of devices by reading <b>/proc/partitions</b>, scan these
       for RAID superblocks, and printout a brief listing of all that
       were found.

         <b>mdadm -Ac partitions -m 0 /dev/md0</b>
       Scan all partitions and devices listed in <b>/proc/partitions </b>and
       assemble <b>/dev/md0 </b>out of all such devices with a RAID superblock
       with a minor number of 0.

         <b>mdadm --monitor --scan --daemonise &gt; /run/mdadm/mon.pid</b>
       If config file contains a mail address or alert program, run
       mdadm in the background in monitor mode monitoring all md
       devices.  Also write pid of mdadm daemon to <b>/run/mdadm/mon.pid</b>.

         <b>mdadm -Iq /dev/somedevice</b>
       Try to incorporate newly discovered device into some array as
       appropriate.

         <b>mdadm --incremental --rebuild-map --run --scan</b>
       Rebuild the array map from any current arrays, and then start any
       that can be started.

         <b>mdadm /dev/md4 --fail detached --remove detached</b>
       Any devices which are components of /dev/md4 will be marked as
       faulty and then remove from the array.

         <b>mdadm --grow /dev/md4 --level=6 --backup-file=/root/backup-md4</b>
       The array <b>/dev/md4 </b>which is currently a RAID5 array will be
       converted to RAID6.  There should normally already be a spare
       drive attached to the array as a RAID6 needs one more drive than
       a matching RAID5.

         <b>mdadm --create /dev/md/ddf --metadata=ddf --raid-disks 6</b>
       <b>/dev/sd[a-f]</b>
       Create a DDF array over 6 devices.

         <b>mdadm --create /dev/md/home -n3 -l5 -z 30000000 /dev/md/ddf</b>
       Create a RAID5 array over any 3 devices in the given DDF set.
       Use only 30 gigabytes of each device.

         <b>mdadm -A /dev/md/ddf1 /dev/sd[a-f]</b>
       Assemble a pre-exist ddf array.

         <b>mdadm -I /dev/md/ddf1</b>
       Assemble all arrays contained in the ddf array, assigning names
       as appropriate.

         <b>mdadm --create --help</b>
       Provide help about the Create mode.

         <b>mdadm --config --help</b>
       Provide help about the format of the config file.

         <b>mdadm --help</b>
       Provide general help.
</pre> <h2>
FILES </h2>
<pre>
   <b>/proc/mdstat</b>
       If you're using the <b>/proc </b>filesystem, <b>/proc/mdstat </b>lists all
       active md devices with information about them.  <i>mdadm</i> uses this
       to find arrays when <b>--scan </b>is given in Misc mode, and to monitor
       array reconstruction on Monitor mode.

   <b>/etc/mdadm.conf (or /etc/mdadm/mdadm.conf)</b>
       Default config file.  See <a href="../man5/mdadm.conf.5.html">mdadm.conf(5)</a> for more details.

   <b>/etc/mdadm.conf.d (or /etc/mdadm/mdadm.conf.d)</b>
       Default directory containing configuration files.  See
       <a href="../man5/mdadm.conf.5.html">mdadm.conf(5)</a> for more details.

   <b>/run/mdadm/map</b>
       When <b>--incremental </b>mode is used, this file gets a list of arrays
       currently being created.
</pre> <h2>
POSIX PORTABLE NAME </h2>
<pre>
       A valid name can only consist of characters "A-Za-z0-9.-_".  The
       name cannot start with a leading "-" and cannot exceed 255 chars.
</pre> <h2>
DEVICE NAMES </h2>
<pre>
       <i>mdadm</i> understand two sorts of names for array devices.

       The first is the so-called 'standard' format name, which matches
       the names used by the kernel and which appear in <i>/proc/mdstat</i>.

       The second sort can be freely chosen, but must reside in
       <i>/dev/md/</i>.  When giving a device name to <i>mdadm</i> to create or
       assemble an array, either full path name such as <i>/dev/md0</i> or
       <i>/dev/md/home</i> can be given, or just the suffix of the second sort
       of name, such as <i>home</i> can be given.

       In every style, raw name must be compatible with <b>POSIX PORTABLE</b>
       <b>NAME </b>and has to be no longer than 32 chars.

       When <i>mdadm</i> chooses device names during auto-assembly or
       incremental assembly, it will sometimes add a small sequence
       number to the end of the name to avoid conflicted between
       multiple arrays that have the same name.  If <i>mdadm</i> can reasonably
       determine that the array really is meant for this host, either by
       a hostname in the metadata, or by the presence of the array in
       <b>mdadm.conf</b>, then it will leave off the suffix if possible.  Also
       if the homehost is specified as <b>&lt;ignore&gt; </b><i>mdadm</i> will only use a
       suffix if a different array of the same name already exists or is
       listed in the config file.

       The standard names for non-partitioned arrays (the only sort of
       md array available in 2.4 and earlier) are of the form

              /dev/md<b>NN</b>

       where NN is a number.  The standard names for partitionable
       arrays (as available from 2.6 onwards) are of the form:

              /dev/md_d<b>NN</b>

       Partition numbers should be indicated by adding "pMM" to these,
       thus "/dev/md/d1p2".

       From kernel version 2.6.28 the "non-partitioned array" can
       actually be partitioned.  So the "md_d<b>NN</b>" names are no longer
       needed, and partitions such as "/dev/md<b>NN</b>p<b>XX</b>" are possible.

       From kernel version 2.6.29 standard names can be non-numeric
       following the form:

              /dev/md_<b>XXX</b>

       where <b>XXX </b>is any string.  These names are supported by <i>mdadm</i>
       since version 3.3 provided they are enabled in <i>mdadm.conf</i>.
</pre> <h2>
UNDERSTANDING OUTPUT </h2>
<pre>
       EXAMINE

       <b>checkpoint</b>
              Checkpoint value is reported when array is performing some
              action including resync, recovery or reshape. Checkpoints
              allow resuming action from certain point if it was
              interrupted.

              Checkpoint is reported as combination of two values:
              current migration unit and number of blocks per unit. By
              multiplying those values and dividing by array size
              checkpoint progress percentage can be obtained in relation
              to current progress reported in /proc/mdstat. Checkpoint
              is also related to (and sometimes based on) sysfs entry
              sync_completed but depending on action units may differ.
              Even if units are the same, it should not be expected that
              checkpoint and sync_completed will be exact match nor
              updated simultaneously.
</pre> <h2>
NOTE </h2>
<pre>
       <i>mdadm</i> was previously known as <i>mdctl</i>.
</pre> <h2>
SEE ALSO </h2>
<pre>
       For further information on mdadm usage, MD and the various levels
       of RAID, see:

              <b><a href="https://raid.wiki.kernel.org/">https://raid.wiki.kernel.org/</a> </b>

       (based upon Jakob Østergaard's Software-RAID.HOWTO)

       The latest version of <i>mdadm</i> should always be available from

              <b><a href="https://www.kernel.org/pub/linux/utils/raid/mdadm/">https://www.kernel.org/pub/linux/utils/raid/mdadm/</a> </b>

       Related man pages:

       <a href="mdmon.8.html">mdmon(8)</a>, <a href="../man5/mdadm.conf.5.html">mdadm.conf(5)</a>, <a href="../man4/md.4.html">md(4)</a>.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>mdadm</i> (Tool for managing md arrays in
       Linux) project.  Information about the project can be found at 
       ⟨<a href="http://neil.brown.name/blog/mdadm">http://neil.brown.name/blog/mdadm</a>⟩.  If you have a bug report for
       this manual page, send it to linux-raid@vger.kernl.org.  This
       page was obtained from the project's upstream Git repository
       ⟨<a href="https://git.kernel.org/pub/scm/utils/mdadm/mdadm.git/">https://git.kernel.org/pub/scm/utils/mdadm/mdadm.git/</a>⟩ on
       2024-06-14.  (At that time, the date of the most recent commit
       that was found in the repository was 2024-06-13.)  If you
       discover any rendering problems in this HTML version of the page,
       or you believe there is a better or more up-to-date source for
       the page, or you have corrections or improvements to the
       information in this COLOPHON (which is <i>not</i> part of the original
       manual page), send a mail to man-pages@man7.org

<span class="footline">v4.3                                                            <i>MDADM</i>(8)</span>
</pre>  <p>Pages that refer to this page: <a href="../man4/md.4.html">md(4)</a>, <a href="../man5/mdadm.conf.5.html">mdadm.conf(5)</a>, <a href="blkdeactivate.8.html">blkdeactivate(8)</a>, <a href="mdmon.8.html">mdmon(8)</a>, <a href="raid6check.8.html">raid6check(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man8/mdadm.8.html" class="_attribution-link">https://man7.org/linux/man-pages/man8/mdadm.8.html</a>
  </p>
</div>
