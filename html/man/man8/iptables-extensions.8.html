<h1>iptables-extensions(8) — Linux manual page</h1>   <pre>
<span class="headline"><i>iptables-extensions</i>(8)       iptables 1.8.10      <i>iptables-extensions</i>(8)</span>
</pre> <h2>
NAME </h2>
<pre>
       iptables-extensions — list of extensions in the standard iptables
       distribution
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>ip6tables </b>[<b>-m </b><i>name</i> [<i>module-options</i>...]]  [<b>-j </b><i>target-name</i> [<i>target-</i>
       <i>options</i>...]

       <b>iptables </b>[<b>-m </b><i>name</i> [<i>module-options</i>...]]  [<b>-j </b><i>target-name</i> [<i>target-</i>
       <i>options</i>...]
</pre> <h2>
MATCH EXTENSIONS </h2>
<pre>
       iptables can use extended packet matching modules with the <b>-m </b>or
       <b>--match </b>options, followed by the matching module name; after
       these, various extra command line options become available,
       depending on the specific module.  You can specify multiple
       extended match modules in one line, and you can use the <b>-h </b>or
       <b>--help </b>options after the module has been specified to receive
       help specific to that module.  The extended match modules are
       evaluated in the order they are specified in the rule.

       If the <b>-p </b>or <b>--protocol </b>was specified and if and only if an
       unknown option is encountered, iptables will try load a match
       module of the same name as the protocol, to try making the option
       available.

   <b>addrtype</b>
       This module matches packets based on their <b>address type.  </b>Address
       types are used within the kernel networking stack and categorize
       addresses into various groups.  The exact definition of that
       group depends on the specific layer three protocol.

       The following address types are possible:

       <b>UNSPEC </b>an unspecified address (i.e. 0.0.0.0)

       <b>UNICAST</b>
              an unicast address

       <b>LOCAL  </b>a local address

       <b>BROADCAST</b>
              a broadcast address

       <b>ANYCAST</b>
              an anycast packet

       <b>MULTICAST</b>
              a multicast address

       <b>BLACKHOLE</b>
              a blackhole address

       <b>UNREACHABLE</b>
              an unreachable address

       <b>PROHIBIT</b>
              a prohibited address

       <b>THROW  </b>FIXME

       <b>NAT    </b>FIXME

       <b>XRESOLVE</b>

       [<b>!</b>] <b>--src-type </b><i>type</i>
              Matches if the source address is of given type

       [<b>!</b>] <b>--dst-type </b><i>type</i>
              Matches if the destination address is of given type

       <b>--limit-iface-in</b>
              The address type checking can be limited to the interface
              the packet is coming in. This option is only valid in the
              <b>PREROUTING</b>, <b>INPUT </b>and <b>FORWARD </b>chains. It cannot be
              specified with the <b>--limit-iface-out </b>option.

       <b>--limit-iface-out</b>
              The address type checking can be limited to the interface
              the packet is going out. This option is only valid in the
              <b>POSTROUTING</b>, <b>OUTPUT </b>and <b>FORWARD </b>chains. It cannot be
              specified with the <b>--limit-iface-in </b>option.

   <b>ah (IPv6-specific)</b>
       This module matches the parameters in Authentication header of
       IPsec packets.

       [<b>!</b>] <b>--ahspi </b><i>spi</i>[<b>:</b><i>spi</i>]
              Matches SPI.

       [<b>!</b>] <b>--ahlen </b><i>length</i>
              Total length of this header in octets.

       <b>--ahres</b>
              Matches if the reserved field is filled with zero.

   <b>ah (IPv4-specific)</b>
       This module matches the SPIs in Authentication header of IPsec
       packets.

       [<b>!</b>] <b>--ahspi </b><i>spi</i>[<b>:</b><i>spi</i>]

   <b>bpf</b>
       Match using Linux Socket Filter. Expects a path to an eBPF object
       or a cBPF program in decimal format.

       <b>--object-pinned </b><i>path</i>
              Pass a path to a pinned eBPF object.

       Applications load eBPF programs into the kernel with the bpf()
       system call and BPF_PROG_LOAD command and can pin them in a
       virtual filesystem with BPF_OBJ_PIN.  To use a pinned object in
       iptables, mount the bpf filesystem using

              mount -t bpf bpf ${BPF_MOUNT}

       then insert the filter in iptables by path:

              iptables -A OUTPUT -m bpf --object-pinned
              ${BPF_MOUNT}/{PINNED_PATH} -j ACCEPT

       <b>--bytecode </b><i>code</i>
              Pass the BPF byte code format as generated by the
              <b>nfbpf_compile </b>utility.

       The code format is similar to the output of the tcpdump -ddd
       command: one line that stores the number of instructions,
       followed by one line for each instruction. Instruction lines
       follow the pattern 'u16 u8 u8 u32' in decimal notation. Fields
       encode the operation, jump offset if true, jump offset if false
       and generic multiuse field 'K'. Comments are not supported.

       For example, to read only packets matching 'ip proto 6', insert
       the following, without the comments or trailing whitespace:

              4               # number of instructions
              48 0 0 9        # load byte  ip-&gt;proto
              21 0 1 6        # jump equal IPPROTO_TCP
              6 0 0 1         # return     pass (non-zero)
              6 0 0 0         # return     fail (zero)

       You can pass this filter to the bpf match with the following
       command:

              iptables -A OUTPUT -m bpf --bytecode '4,48 0 0 9,21 0 1
              6,6 0 0 1,6 0 0 0' -j ACCEPT

       Or instead, you can invoke the nfbpf_compile utility.

              iptables -A OUTPUT -m bpf --bytecode "`nfbpf_compile RAW
              'ip proto 6'`" -j ACCEPT

       Or use tcpdump -ddd. In that case, generate BPF targeting a
       device with the same data link type as the xtables match.
       Iptables passes packets from the network layer up, without mac
       layer. Select a device with data link type RAW, such as a tun
       device:

              ip tuntap add tun0 mode tun
              ip link set tun0 up
              tcpdump -ddd -i tun0 ip proto 6

       See tcpdump -L -i $dev for a list of known data link types for a
       given device.

       You may want to learn more about BPF from FreeBSD's bpf(4)
       manpage.

   <b>cgroup</b>
       [<b>!</b>] <b>--path </b><i>path</i>
              Match cgroup2 membership.

              Each socket is associated with the v2 cgroup of the
              creating process.  This matches packets coming from or
              going to all sockets in the sub-hierarchy of the specified
              path.  The path should be relative to the root of the
              cgroup2 hierarchy.

       [<b>!</b>] <b>--cgroup </b><i>classid</i>
              Match cgroup net_cls classid.

              classid is the marker set through the cgroup net_cls
              controller.  This option and --path can't be used
              together.

       Example:

              iptables -A OUTPUT -p tcp --sport 80 -m cgroup ! --path
              service/http-server -j DROP

              iptables -A OUTPUT -p tcp --sport 80 -m cgroup ! --cgroup
              1 -j DROP

       <b>IMPORTANT</b>: when being used in the INPUT chain, the cgroup matcher
       is currently only of limited functionality, meaning it will only
       match on packets that are processed for local sockets through
       early socket demuxing. Therefore, general usage on the INPUT
       chain is not advised unless the implications are well understood.

       Available since Linux 3.14.

   <b>cluster</b>
       Allows you to deploy gateway and back-end load-sharing clusters
       without the need of load-balancers.

       This match requires that all the nodes see the same packets.
       Thus, the cluster match decides if this node has to handle a
       packet given the following options:

       <b>--cluster-total-nodes </b><i>num</i>
              Set number of total nodes in cluster.

       [<b>!</b>] <b>--cluster-local-node </b><i>num</i>
              Set the local node number ID.

       [<b>!</b>] <b>--cluster-local-nodemask </b><i>mask</i>
              Set the local node number ID mask. You can use this option
              instead of <b>--cluster-local-node</b>.

       <b>--cluster-hash-seed </b><i>value</i>
              Set seed value of the Jenkins hash.

       Example:

              iptables -A PREROUTING -t mangle -i eth1 -m cluster
              --cluster-total-nodes 2 --cluster-local-node 1
              --cluster-hash-seed 0xdeadbeef -j MARK --set-mark 0xffff

              iptables -A PREROUTING -t mangle -i eth2 -m cluster
              --cluster-total-nodes 2 --cluster-local-node 1
              --cluster-hash-seed 0xdeadbeef -j MARK --set-mark 0xffff

              iptables -A PREROUTING -t mangle -i eth1 -m mark ! --mark
              0xffff -j DROP

              iptables -A PREROUTING -t mangle -i eth2 -m mark ! --mark
              0xffff -j DROP

       And the following commands to make all nodes see the same
       packets:

              ip maddr add 01:00:5e:00:01:01 dev eth1

              ip maddr add 01:00:5e:00:01:02 dev eth2

              arptables -A OUTPUT -o eth1 --h-length 6 -j mangle
              --mangle-mac-s 01:00:5e:00:01:01

              arptables -A INPUT -i eth1 --h-length 6 --destination-mac
              01:00:5e:00:01:01 -j mangle --mangle-mac-d
              00:zz:yy:xx:5a:27

              arptables -A OUTPUT -o eth2 --h-length 6 -j mangle
              --mangle-mac-s 01:00:5e:00:01:02

              arptables -A INPUT -i eth2 --h-length 6 --destination-mac
              01:00:5e:00:01:02 -j mangle --mangle-mac-d
              00:zz:yy:xx:5a:27

       <b>NOTE</b>: the arptables commands above use mainstream syntax. If you
       are using arptables-jf included in some RedHat, CentOS and Fedora
       versions, you will hit syntax errors. Therefore, you'll have to
       adapt these to the arptables-jf syntax to get them working.

       In the case of TCP connections, pickup facility has to be
       disabled to avoid marking TCP ACK packets coming in the reply
       direction as valid.

              echo 0 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_loose

   <b>comment</b>
       Allows you to add comments (up to 256 characters) to any rule.

       <b>--comment </b><i>comment</i>

       Example:
              iptables -A INPUT -i eth1 -m comment --comment "my local
              LAN"

   <b>connbytes</b>
       Match by how many bytes or packets a connection (or one of the
       two flows constituting the connection) has transferred so far, or
       by average bytes per packet.

       The counters are 64-bit and are thus not expected to overflow ;)

       The primary use is to detect long-lived downloads and mark them
       to be scheduled using a lower priority band in traffic control.

       The transferred bytes per connection can also be viewed through
       `conntrack -L` and accessed via ctnetlink.

       NOTE that for connections which have no accounting information,
       the match will always return false. The
       "net.netfilter.nf_conntrack_acct" sysctl flag controls whether
       <b>new </b>connections will be byte/packet counted. Existing connection
       flows will not be gaining/losing a/the accounting structure when
       be sysctl flag is flipped.

       [<b>!</b>] <b>--connbytes </b><i>from</i>[<b>:</b><i>to</i>]
              match packets from a connection whose
              packets/bytes/average packet size is more than FROM and
              less than TO bytes/packets. if TO is omitted only FROM
              check is done. "!" is used to match packets not falling in
              the range.

       <b>--connbytes-dir </b>{<b>original</b>|<b>reply</b>|<b>both</b>}
              which packets to consider

       <b>--connbytes-mode </b>{<b>packets</b>|<b>bytes</b>|<b>avgpkt</b>}
              whether to check the amount of packets, number of bytes
              transferred or the average size (in bytes) of all packets
              received so far. Note that when "both" is used together
              with "avgpkt", and data is going (mainly) only in one
              direction (for example HTTP), the average packet size will
              be about half of the actual data packets.

       Example:
              iptables .. -m connbytes --connbytes 10000:100000
              --connbytes-dir both --connbytes-mode bytes ...

   <b>connlimit</b>
       Allows you to restrict the number of parallel connections to a
       server per client IP address (or client address block).

       <b>--connlimit-upto </b><i>n</i>
              Match if the number of existing connections is below or
              equal <i>n</i>.

       <b>--connlimit-above </b><i>n</i>
              Match if the number of existing connections is above <i>n</i>.

       <b>--connlimit-mask </b><i>prefix_length</i>
              Group hosts using the prefix length. For IPv4, this must
              be a number between (including) 0 and 32. For IPv6,
              between 0 and 128. If not specified, the maximum prefix
              length for the applicable protocol is used.

       <b>--connlimit-saddr</b>
              Apply the limit onto the source group. This is the default
              if --connlimit-daddr is not specified.

       <b>--connlimit-daddr</b>
              Apply the limit onto the destination group.

       Examples:

       •   allow 2 telnet connections per client host:
           iptables -A INPUT -p tcp --syn --dport 23 -m connlimit
           --connlimit-above 2 -j REJECT

       •   you can also match the other way around:
           iptables -A INPUT -p tcp --syn --dport 23 -m connlimit
           --connlimit-upto 2 -j ACCEPT

       •   limit the number of parallel HTTP requests to 16 per class C
           sized source network (24 bit netmask):
           iptables -p tcp --syn --dport 80 -m connlimit
           --connlimit-above 16 --connlimit-mask 24 -j REJECT

       •   limit the number of parallel HTTP requests to 16 for the link
           local network (IPv6):
           ip6tables -p tcp --syn --dport 80 -s fe80::/64 -m connlimit
           --connlimit-above 16 --connlimit-mask 64 -j REJECT

       •   Limit the number of connections to a particular host:
           ip6tables -p tcp --syn --dport 49152:65535 -d 2001:db8::1 -m
           connlimit --connlimit-above 100 -j REJECT

   <b>connmark</b>
       This module matches the netfilter mark field associated with a
       connection (which can be set using the <b>CONNMARK </b>target below).

       [<b>!</b>] <b>--mark </b><i>value</i>[<b>/</b><i>mask</i>]
              Matches packets in connections with the given mark value
              (if a mask is specified, this is logically ANDed with the
              mark before the comparison).

   <b>conntrack</b>
       This module, when combined with connection tracking, allows
       access to the connection tracking state for this
       packet/connection.

       [<b>!</b>] <b>--ctstate </b><i>statelist</i>
              <i>statelist</i> is a comma separated list of the connection
              states to match.  Possible states are listed below.

       [<b>!</b>] <b>--ctproto </b><i>l4proto</i>
              Layer-4 protocol to match (by number or name)

       [<b>!</b>] <b>--ctorigsrc </b><i>address</i>[<b>/</b><i>mask</i>]

       [<b>!</b>] <b>--ctorigdst </b><i>address</i>[<b>/</b><i>mask</i>]

       [<b>!</b>] <b>--ctreplsrc </b><i>address</i>[<b>/</b><i>mask</i>]

       [<b>!</b>] <b>--ctrepldst </b><i>address</i>[<b>/</b><i>mask</i>]
              Match against original/reply source/destination address

       [<b>!</b>] <b>--ctorigsrcport </b><i>port</i>[<b>:</b><i>port</i>]

       [<b>!</b>] <b>--ctorigdstport </b><i>port</i>[<b>:</b><i>port</i>]

       [<b>!</b>] <b>--ctreplsrcport </b><i>port</i>[<b>:</b><i>port</i>]

       [<b>!</b>] <b>--ctrepldstport </b><i>port</i>[<b>:</b><i>port</i>]
              Match against original/reply source/destination port
              (TCP/UDP/etc.) or GRE key.  Matching against port ranges
              is only supported in kernel versions above 2.6.38.

       [<b>!</b>] <b>--ctstatus </b><i>statelist</i>
              <i>statuslist</i> is a comma separated list of the connection
              statuses to match.  Possible statuses are listed below.

       [<b>!</b>] <b>--ctexpire </b><i>time</i>[<b>:</b><i>time</i>]
              Match remaining lifetime in seconds against given value or
              range of values (inclusive)

       <b>--ctdir </b>{<b>ORIGINAL</b>|<b>REPLY</b>}
              Match packets that are flowing in the specified direction.
              If this flag is not specified at all, matches packets in
              both directions.

       States for <b>--ctstate</b>:

       <b>INVALID</b>
              The packet is associated with no known connection.

       <b>NEW    </b>The packet has started a new connection or otherwise
              associated with a connection which has not seen packets in
              both directions.

       <b>ESTABLISHED</b>
              The packet is associated with a connection which has seen
              packets in both directions.

       <b>RELATED</b>
              The packet is starting a new connection, but is associated
              with an existing connection, such as an FTP data transfer
              or an ICMP error.

       <b>UNTRACKED</b>
              The packet is not tracked at all, which happens if you
              explicitly untrack it by using -j CT --notrack in the raw
              table.

       <b>SNAT   </b>A virtual state, matching if the original source address
              differs from the reply destination.

       <b>DNAT   </b>A virtual state, matching if the original destination
              differs from the reply source.

       Statuses for <b>--ctstatus</b>:

       <b>NONE   </b>None of the below.

       <b>EXPECTED</b>
              This is an expected connection (i.e. a conntrack helper
              set it up).

       <b>SEEN_REPLY</b>
              Conntrack has seen packets in both directions.

       <b>ASSURED</b>
              Conntrack entry should never be early-expired.

       <b>CONFIRMED</b>
              Connection is confirmed: originating packet has left box.

   <b>cpu</b>
       [<b>!</b>] <b>--cpu </b><i>number</i>
              Match cpu handling this packet. cpus are numbered from 0
              to NR_CPUS-1 Can be used in combination with RPS (Remote
              Packet Steering) or multiqueue NICs to spread network
              traffic on different queues.

       Example:

       iptables -t nat -A PREROUTING -p tcp --dport 80 -m cpu --cpu 0 -j
       REDIRECT --to-ports 8080

       iptables -t nat -A PREROUTING -p tcp --dport 80 -m cpu --cpu 1 -j
       REDIRECT --to-ports 8081

       Available since Linux 2.6.36.

   <b>dccp</b>
       [<b>!</b>] <b>--source-port</b>,<b>--sport </b><i>port</i>[<b>:</b><i>port</i>]

       [<b>!</b>] <b>--destination-port</b>,<b>--dport </b><i>port</i>[<b>:</b><i>port</i>]

       [<b>!</b>] <b>--dccp-types </b><i>mask</i>
              Match when the DCCP packet type is one of 'mask'. 'mask'
              is a comma-separated list of packet types.  Packet types
              are: <b>REQUEST RESPONSE DATA ACK DATAACK CLOSEREQ CLOSE</b>
              <b>RESET SYNC SYNCACK INVALID</b>.

       [<b>!</b>] <b>--dccp-option </b><i>number</i>
              Match if DCCP option set.

   <b>devgroup</b>
       Match device group of a packet's incoming/outgoing interface.

       [<b>!</b>] <b>--src-group </b><i>name</i>
              Match device group of incoming device

       [<b>!</b>] <b>--dst-group </b><i>name</i>
              Match device group of outgoing device

   <b>dscp</b>
       This module matches the 6 bit DSCP field within the TOS field in
       the IP header.  DSCP has superseded TOS within the IETF.

       [<b>!</b>] <b>--dscp </b><i>value</i>
              Match against a numeric (decimal or hex) value in the
              range 0–63.

       [<b>!</b>] <b>--dscp-class </b><i>class</i>
              Match the DiffServ class. This value may be any of the BE,
              EF, AFxx or CSx classes.  It will then be converted into
              its according numeric value.

   <b>dst (IPv6-specific)</b>
       This module matches the parameters in Destination Options header

       [<b>!</b>] <b>--dst-len </b><i>length</i>
              Total length of this header in octets.

       <b>--dst-opts </b><i>type</i>[<b>:</b><i>length</i>][<b>,</b><i>type</i>[<b>:</b><i>length</i>]...]
              numeric type of option and the length of the option data
              in octets.

   <b>ecn</b>
       This allows you to match the ECN bits of the IPv4/IPv6 and TCP
       header.  ECN is the Explicit Congestion Notification mechanism as
       specified in RFC3168

       [<b>!</b>] <b>--ecn-tcp-cwr</b>
              This matches if the TCP ECN CWR (Congestion Window
              Received) bit is set.

       [<b>!</b>] <b>--ecn-tcp-ece</b>
              This matches if the TCP ECN ECE (ECN Echo) bit is set.

       [<b>!</b>] <b>--ecn-ip-ect </b><i>num</i>
              This matches a particular IPv4/IPv6 ECT (ECN-Capable
              Transport). You have to specify a number between `0' and
              `3'.

   <b>esp</b>
       This module matches the SPIs in ESP header of IPsec packets.

       [<b>!</b>] <b>--espspi </b><i>spi</i>[<b>:</b><i>spi</i>]

   <b>eui64 (IPv6-specific)</b>
       This module matches the EUI-64 part of a stateless autoconfigured
       IPv6 address.  It compares the EUI-64 derived from the source MAC
       address in Ethernet frame with the lower 64 bits of the IPv6
       source address. But "Universal/Local" bit is not compared. This
       module doesn't match other link layer frame, and is only valid in
       the <b>PREROUTING</b>, <b>INPUT </b>and <b>FORWARD </b>chains.

   <b>frag (IPv6-specific)</b>
       This module matches the parameters in Fragment header.

       [<b>!</b>] <b>--fragid </b><i>id</i>[<b>:</b><i>id</i>]
              Matches the given Identification or range of it.

       [<b>!</b>] <b>--fraglen </b><i>length</i>
              This option cannot be used with kernel version 2.6.10 or
              later. The length of Fragment header is static and this
              option doesn't make sense.

       <b>--fragres</b>
              Matches if the reserved fields are filled with zero.

       <b>--fragfirst</b>
              Matches on the first fragment.

       <b>--fragmore</b>
              Matches if there are more fragments.

       <b>--fraglast</b>
              Matches if this is the last fragment.

   <b>hashlimit</b>
       <b>hashlimit </b>uses hash buckets to express a rate limiting match
       (like the <b>limit </b>match) for a group of connections using a <b>single</b>
       iptables rule. Grouping can be done per-hostgroup (source and/or
       destination address) and/or per-port. It gives you the ability to
       express "<i>N</i> packets per time quantum per group" or "<i>N</i> bytes per
       seconds" (see below for some examples).

       A hash limit option (<b>--hashlimit-upto</b>, <b>--hashlimit-above</b>) and
       <b>--hashlimit-name </b>are required.

       <b>--hashlimit-upto </b><i>amount</i>[<b>/second</b>|<b>/minute</b>|<b>/hour</b>|<b>/day</b>]
              Match if the rate is below or equal to <i>amount</i>/quantum. It
              is specified either as a number, with an optional time
              quantum suffix (the default is 3/hour), or as
              <i>amount</i>b/second (number of bytes per second).

       <b>--hashlimit-above </b><i>amount</i>[<b>/second</b>|<b>/minute</b>|<b>/hour</b>|<b>/day</b>]
              Match if the rate is above <i>amount</i>/quantum.

       <b>--hashlimit-burst </b><i>amount</i>
              Maximum initial number of packets to match: this number
              gets recharged by one every time the limit specified above
              is not reached, up to this number; the default is 5.  When
              byte-based rate matching is requested, this option
              specifies the amount of bytes that can exceed the given
              rate.  This option should be used with caution — if the
              entry expires, the burst value is reset too.

       <b>--hashlimit-mode </b>{<b>srcip</b>|<b>srcport</b>|<b>dstip</b>|<b>dstport</b>}<b>,</b>...
              A comma-separated list of objects to take into
              consideration. If no --hashlimit-mode option is given,
              hashlimit acts like limit, but at the expensive of doing
              the hash housekeeping.

       <b>--hashlimit-srcmask </b><i>prefix</i>
              When --hashlimit-mode srcip is used, all source addresses
              encountered will be grouped according to the given prefix
              length and the so-created subnet will be subject to
              hashlimit. <i>prefix</i> must be between (inclusive) 0 and 32.
              Note that --hashlimit-srcmask 0 is basically doing the
              same thing as not specifying srcip for --hashlimit-mode,
              but is technically more expensive.

       <b>--hashlimit-dstmask </b><i>prefix</i>
              Like --hashlimit-srcmask, but for destination addresses.

       <b>--hashlimit-name </b><i>foo</i>
              The name for the /proc/net/ipt_hashlimit/foo entry.

       <b>--hashlimit-htable-size </b><i>buckets</i>
              The number of buckets of the hash table

       <b>--hashlimit-htable-max </b><i>entries</i>
              Maximum entries in the hash.

       <b>--hashlimit-htable-expire </b><i>msec</i>
              After how many milliseconds do hash entries expire.

       <b>--hashlimit-htable-gcinterval </b><i>msec</i>
              How many milliseconds between garbage collection
              intervals.

       <b>--hashlimit-rate-match</b>
              Classify the flow instead of rate-limiting it. This acts
              like a true/false match on whether the rate is above/below
              a certain number

       <b>--hashlimit-rate-interval </b><i>sec</i>
              Can be used with --hashlimit-rate-match to specify the
              interval at which the rate should be sampled

       Examples:

       matching on source host
              "1000 packets per second for every host in 192.168.0.0/16"
              =&gt; -s 192.168.0.0/16 --hashlimit-mode srcip
              --hashlimit-upto 1000/sec

       matching on source port
              "100 packets per second for every service of 192.168.1.1"
              =&gt; -s 192.168.1.1 --hashlimit-mode srcport
              --hashlimit-upto 100/sec

       matching on subnet
              "10000 packets per minute for every /28 subnet (groups of
              8 addresses) in 10.0.0.0/8" =&gt; -s 10.0.0.0/8
              --hashlimit-mask 28 --hashlimit-upto 10000/min

       matching bytes per second
              "flows exceeding 512kbyte/s" =&gt; --hashlimit-mode
              srcip,dstip,srcport,dstport --hashlimit-above 512kb/s

       matching bytes per second
              "hosts that exceed 512kbyte/s, but permit up to 1Megabytes
              without matching" --hashlimit-mode dstip --hashlimit-above
              512kb/s --hashlimit-burst 1mb

   <b>hbh (IPv6-specific)</b>
       This module matches the parameters in Hop-by-Hop Options header

       [<b>!</b>] <b>--hbh-len </b><i>length</i>
              Total length of this header in octets.

       <b>--hbh-opts </b><i>type</i>[<b>:</b><i>length</i>][<b>,</b><i>type</i>[<b>:</b><i>length</i>]...]
              numeric type of option and the length of the option data
              in octets.

   <b>helper</b>
       This module matches packets related to a specific conntrack
       helper.

       [<b>!</b>] <b>--helper </b><i>string</i>
              Matches packets related to the specified conntrack helper.

              string can be "ftp" for packets related to an FTP session
              on default port.  For other ports, append --portnr to the
              value, ie. "ftp-2121".

              Same rules apply for other conntrack helpers.

   <b>hl (IPv6-specific)</b>
       This module matches the Hop Limit field in the IPv6 header.

       [<b>!</b>] <b>--hl-eq </b><i>value</i>
              Matches if Hop Limit equals <i>value</i>.

       <b>--hl-lt </b><i>value</i>
              Matches if Hop Limit is less than <i>value</i>.

       <b>--hl-gt </b><i>value</i>
              Matches if Hop Limit is greater than <i>value</i>.

   <b>icmp (IPv4-specific)</b>
       This extension can be used if `--protocol icmp' is specified. It
       provides the following option:

       [<b>!</b>] <b>--icmp-type </b>{<i>type</i>[<b>/</b><i>code</i>]|<i>typename</i>}
              This allows specification of the ICMP type, which can be a
              numeric ICMP type, type/code pair, or one of the ICMP type
              names shown by the command
               iptables -p icmp -h

   <b>icmp6 (IPv6-specific)</b>
       This extension can be used if `--protocol ipv6-icmp' or
       `--protocol icmpv6' is specified. It provides the following
       option:

       [<b>!</b>] <b>--icmpv6-type </b><i>type</i>[<b>/</b><i>code</i>]|<i>typename</i>
              This allows specification of the ICMPv6 type, which can be
              a numeric ICMPv6 <i>type</i>, <i>type</i> and <i>code</i>, or one of the ICMPv6
              type names shown by the command
               ip6tables -p ipv6-icmp -h

   <b>iprange</b>
       This matches on a given arbitrary range of IP addresses.

       [<b>!</b>] <b>--src-range </b><i>from</i>[<b>-</b><i>to</i>]
              Match source IP in the specified range.

       [<b>!</b>] <b>--dst-range </b><i>from</i>[<b>-</b><i>to</i>]
              Match destination IP in the specified range.

   <b>ipv6header (IPv6-specific)</b>
       This module matches IPv6 extension headers and/or upper layer
       header.

       <b>--soft </b>Matches if the packet includes <b>any </b>of the headers
              specified with <b>--header</b>.

       [<b>!</b>] <b>--header </b><i>header</i>[<b>,</b><i>header</i>...]
              Matches the packet which EXACTLY includes all specified
              headers. The headers encapsulated with ESP header are out
              of scope.  Possible <i>header</i> types can be:

       <b>hop</b>|<b>hop-by-hop</b>
              Hop-by-Hop Options header

       <b>dst    </b>Destination Options header

       <b>route  </b>Routing header

       <b>frag   </b>Fragment header

       <b>auth   </b>Authentication header

       <b>esp    </b>Encapsulating Security Payload header

       <b>none   </b>No Next header which matches 59 in the 'Next Header field'
              of IPv6 header or any IPv6 extension headers

       <b>prot   </b>which matches any upper layer protocol header. A protocol
              name from /etc/protocols and numeric value also allowed.
              The number 255 is equivalent to <b>prot</b>.

   <b>ipvs</b>
       Match IPVS connection properties.

       [<b>!</b>] <b>--ipvs</b>
              packet belongs to an IPVS connection

       Any of the following options implies --ipvs (even negated)

       [<b>!</b>] <b>--vproto </b><i>protocol</i>
              VIP protocol to match; by number or name, e.g. "tcp"

       [<b>!</b>] <b>--vaddr </b><i>address</i>[<b>/</b><i>mask</i>]
              VIP address to match

       [<b>!</b>] <b>--vport </b><i>port</i>
              VIP port to match; by number or name, e.g. "http"

       <b>--vdir </b>{<b>ORIGINAL</b>|<b>REPLY</b>}
              flow direction of packet

       [<b>!</b>] <b>--vmethod </b>{<b>GATE</b>|<b>IPIP</b>|<b>MASQ</b>}
              IPVS forwarding method used

       [<b>!</b>] <b>--vportctl </b><i>port</i>
              VIP port of the controlling connection to match, e.g. 21
              for FTP

   <b>length</b>
       This module matches the length of the layer-3 payload (e.g.
       layer-4 packet) of a packet against a specific value or range of
       values.

       [<b>!</b>] <b>--length </b><i>length</i>[<b>:</b><i>length</i>]

   <b>limit</b>
       This module matches at a limited rate using a token bucket
       filter.  A rule using this extension will match until this limit
       is reached.  It can be used in combination with the <b>LOG </b>target to
       give limited logging, for example.

       xt_limit has no negation support — you will have to use -m
       hashlimit !  --hashlimit <i>rate</i> in this case whilst omitting
       --hashlimit-mode.

       <b>--limit </b><i>rate</i>[<b>/second</b>|<b>/minute</b>|<b>/hour</b>|<b>/day</b>]
              Maximum average matching rate: specified as a number, with
              an optional `/second', `/minute', `/hour', or `/day'
              suffix; the default is 3/hour.

       <b>--limit-burst </b><i>number</i>
              Maximum initial number of packets to match: this number
              gets recharged by one every time the limit specified above
              is not reached, up to this number; the default is 5.

   <b>mac</b>
       [<b>!</b>] <b>--mac-source </b><i>address</i>
              Match source MAC address.  It must be of the form
              XX:XX:XX:XX:XX:XX.  Note that this only makes sense for
              packets coming from an Ethernet device and entering the
              <b>PREROUTING</b>, <b>FORWARD </b>or <b>INPUT </b>chains.

   <b>mark</b>
       This module matches the netfilter mark field associated with a
       packet (which can be set using the <b>MARK </b>target below).

       [<b>!</b>] <b>--mark </b><i>value</i>[<b>/</b><i>mask</i>]
              Matches packets with the given unsigned mark value (if a
              <i>mask</i> is specified, this is logically ANDed with the <i>mask</i>
              before the comparison).

   <b>mh (IPv6-specific)</b>
       This extension is loaded if `--protocol ipv6-mh' or `--protocol
       mh' is specified. It provides the following option:

       [<b>!</b>] <b>--mh-type </b><i>type</i>[<b>:</b><i>type</i>]
              This allows specification of the Mobility Header(MH) type,
              which can be a numeric MH <i>type</i>, <i>type</i> or one of the MH type
              names shown by the command
               ip6tables -p mh -h

   <b>multiport</b>
       This module matches a set of source or destination ports.  Up to
       15 ports can be specified.  A port range (port:port) counts as
       two ports.  It can only be used in conjunction with one of the
       following protocols: <b>tcp</b>, <b>udp</b>, <b>udplite</b>, <b>dccp </b>and <b>sctp</b>.

       [<b>!</b>] <b>--source-ports</b>,<b>--sports </b><i>port</i>[<b>,</b><i>port</i>|<b>,</b><i>port</i><b>:</b><i>port</i>]...
              Match if the source port is one of the given ports.  The
              flag <b>--sports </b>is a convenient alias for this option.
              Multiple ports or port ranges are separated using a comma,
              and a port range is specified using a colon.
              <b>53,1024:65535 </b>would therefore match ports 53 and all from
              1024 through 65535.

       [<b>!</b>] <b>--destination-ports</b>,<b>--dports </b><i>port</i>[<b>,</b><i>port</i>|<b>,</b><i>port</i><b>:</b><i>port</i>]...
              Match if the destination port is one of the given ports.
              The flag <b>--dports </b>is a convenient alias for this option.

       [<b>!</b>] <b>--ports </b><i>port</i>[<b>,</b><i>port</i>|<b>,</b><i>port</i><b>:</b><i>port</i>]...
              Match if either the source or destination ports are equal
              to one of the given ports.

   <b>nfacct</b>
       The nfacct match provides the extended accounting infrastructure
       for iptables.  You have to use this match together with the
       standalone user-space utility <b>nfacct</b>(8)

       The only option available for this match is the following:

       <b>--nfacct-name </b><i>name</i>
              This allows you to specify the existing object name that
              will be use for accounting the traffic that this rule-set
              is matching.

       To use this extension, you have to create an accounting object:

              nfacct add http-traffic

       Then, you have to attach it to the accounting object via
       iptables:

              iptables -I INPUT -p tcp --sport 80 -m nfacct
              --nfacct-name http-traffic

              iptables -I OUTPUT -p tcp --dport 80 -m nfacct
              --nfacct-name http-traffic

       Then, you can check for the amount of traffic that the rules
       match:

              nfacct get http-traffic

              { pkts = 00000000000000000156, bytes =
              00000000000000151786 } = http-traffic;

       You can obtain <b>nfacct</b>(8) from <a href="https://www.netfilter.org">https://www.netfilter.org</a> or,
       alternatively, from the git.netfilter.org repository.

   <b>osf</b>
       The osf module does passive operating system fingerprinting. This
       module compares some data (Window Size, MSS, options and their
       order, TTL, DF, and others) from packets with the SYN bit set.

       [<b>!</b>] <b>--genre </b><i>string</i>
              Match an operating system genre by using a passive
              fingerprinting.

       <b>--ttl </b><i>level</i>
              Do additional TTL checks on the packet to determine the
              operating system.  <i>level</i> can be one of the following
              values:

              <b>0      </b>True IP address and fingerprint TTL comparison.
                     This generally works for LANs.

              <b>1      </b>Check if the IP header's TTL is less than the
                     fingerprint one. Works for globally-routable
                     addresses.

              <b>2      </b>Do not compare the TTL at all.

       <b>--log </b><i>level</i>
              Log determined genres into dmesg even if they do not match
              the desired one.  <i>level</i> can be one of the following
              values:

              <b>0      </b>Log all matched or unknown signatures

              <b>1      </b>Log only the first one

              <b>2      </b>Log all known matched signatures

       You may find something like this in syslog:

       Windows [2000:SP3:Windows XP Pro SP1, 2000 SP3]: 11.22.33.55:4024
       -&gt; 11.22.33.44:139 hops=3 Linux [2.5-2.6:] : 1.2.3.4:42624 -&gt;
       1.2.3.5:22 hops=4

       OS fingerprints are loadable using the <b>nfnl_osf </b>program. To load
       fingerprints from a file, use:

       <b>nfnl_osf -f /usr/share/xtables/pf.os</b>

       To remove them again,

       <b>nfnl_osf -f /usr/share/xtables/pf.os -d</b>

       The fingerprint database can be downloaded from
       <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/pf.os">http://www.openbsd.org/cgi-bin/cvsweb/src/etc/pf.os</a> .

   <b>owner</b>
       This module attempts to match various characteristics of the
       packet creator, for locally generated packets. This match is only
       valid in the OUTPUT and POSTROUTING chains. Forwarded packets do
       not have any socket associated with them. Packets from kernel
       threads do have a socket, but usually no owner.

       [<b>!</b>] <b>--uid-owner </b><i>username</i>

       [<b>!</b>] <b>--uid-owner </b><i>userid</i>[<b>-</b><i>userid</i>]
              Matches if the packet socket's file structure (if it has
              one) is owned by the given user. You may also specify a
              numerical UID, or an UID range.

       [<b>!</b>] <b>--gid-owner </b><i>groupname</i>

       [<b>!</b>] <b>--gid-owner </b><i>groupid</i>[<b>-</b><i>groupid</i>]
              Matches if the packet socket's file structure is owned by
              the given group.  You may also specify a numerical GID, or
              a GID range.

       <b>--suppl-groups</b>
              Causes group(s) specified with <b>--gid-owner </b>to be also
              checked in the supplementary groups of a process.

       [<b>!</b>] <b>--socket-exists</b>
              Matches if the packet is associated with a socket.

   <b>physdev</b>
       This module matches on the bridge port input and output devices
       enslaved to a bridge device. This module is a part of the
       infrastructure that enables a transparent bridging IP firewall
       and is only useful for kernel versions above version 2.5.44.

       [<b>!</b>] <b>--physdev-in </b><i>name</i>
              Name of a bridge port via which a packet is received (only
              for packets entering the <b>INPUT</b>, <b>FORWARD </b>and <b>PREROUTING</b>
              chains). If the interface name ends in a "+", then any
              interface which begins with this name will match. If the
              packet didn't arrive through a bridge device, this packet
              won't match this option, unless '!' is used.

       [<b>!</b>] <b>--physdev-out </b><i>name</i>
              Name of a bridge port via which a packet is going to be
              sent (for bridged packets entering the <b>FORWARD </b>and
              <b>POSTROUTING </b>chains).  If the interface name ends in a "+",
              then any interface which begins with this name will match.

       [<b>!</b>] <b>--physdev-is-in</b>
              Matches if the packet has entered through a bridge
              interface.

       [<b>!</b>] <b>--physdev-is-out</b>
              Matches if the packet will leave through a bridge
              interface.

       [<b>!</b>] <b>--physdev-is-bridged</b>
              Matches if the packet is being bridged and therefore is
              not being routed.  This is only useful in the FORWARD and
              POSTROUTING chains.

   <b>pkttype</b>
       This module matches the link-layer packet type.

       [<b>!</b>] <b>--pkt-type </b>{<b>unicast</b>|<b>broadcast</b>|<b>multicast</b>}

   <b>policy</b>
       This module matches the policy used by IPsec for handling a
       packet.

       <b>--dir </b>{<b>in</b>|<b>out</b>}
              Used to select whether to match the policy used for
              decapsulation or the policy that will be used for
              encapsulation.  <b>in </b>is valid in the <b>PREROUTING, INPUT and</b>
              <b>FORWARD </b>chains, <b>out </b>is valid in the <b>POSTROUTING, OUTPUT</b>
              <b>and FORWARD </b>chains.

       <b>--pol </b>{<b>none</b>|<b>ipsec</b>}
              Matches if the packet is subject to IPsec processing.
              <b>--pol none </b>cannot be combined with <b>--strict</b>.

       <b>--strict</b>
              Selects whether to match the exact policy or match if any
              rule of the policy matches the given policy.

       For each policy element that is to be described, one can use one
       or more of the following options. When <b>--strict </b>is in effect, at
       least one must be used per element.

       [<b>!</b>] <b>--reqid </b><i>id</i>
              Matches the reqid of the policy rule. The reqid can be
              specified with <b>setkey</b>(8) using <b>unique:id </b>as level.

       [<b>!</b>] <b>--spi </b><i>spi</i>
              Matches the SPI of the SA.

       [<b>!</b>] <b>--proto </b>{<b>ah</b>|<b>esp</b>|<b>ipcomp</b>}
              Matches the encapsulation protocol.

       [<b>!</b>] <b>--mode </b>{<b>tunnel</b>|<b>transport</b>}
              Matches the encapsulation mode.

       [<b>!</b>] <b>--tunnel-src </b><i>addr</i>[<b>/</b><i>mask</i>]
              Matches the source end-point address of a tunnel mode SA.
              Only valid with <b>--mode tunnel</b>.

       [<b>!</b>] <b>--tunnel-dst </b><i>addr</i>[<b>/</b><i>mask</i>]
              Matches the destination end-point address of a tunnel mode
              SA.  Only valid with <b>--mode tunnel</b>.

       <b>--next </b>Start the next element in the policy specification. Can
              only be used with <b>--strict</b>.

   <b>quota</b>
       Implements network quotas by decrementing a byte counter with
       each packet. The condition matches until the byte counter reaches
       zero. Behavior is reversed with negation (i.e. the condition does
       not match until the byte counter reaches zero).

       [<b>!</b>] <b>--quota </b><i>bytes</i>
              The quota in bytes.

   <b>rateest</b>
       The rate estimator can match on estimated rates as collected by
       the RATEEST target. It supports matching on absolute bps/pps
       values, comparing two rate estimators and matching on the
       difference between two rate estimators.

       For a better understanding of the available options, these are
       all possible combinations:

       Absolute:

       •   <b>rateest </b><i>operator</i> <b>rateest-bps</b>

       •   <b>rateest </b><i>operator</i> <b>rateest-pps</b>

       Absolute + Delta:

       •   (<b>rateest </b>minus <b>rateest-bps1</b>) <i>operator</i> <b>rateest-bps2</b>

       •   (<b>rateest </b>minus <b>rateest-pps1</b>) <i>operator</i> <b>rateest-pps2</b>

       Relative:

       •   <b>rateest1 </b><i>operator</i> <b>rateest2 rateest-bps</b>(without rate!)

       •   <b>rateest1 </b><i>operator</i> <b>rateest2 rateest-pps</b>(without rate!)

       Relative + Delta:

       •   (<b>rateest1 </b>minus <b>rateest-bps1</b>) <i>operator</i> (<b>rateest2 </b>minus
           <b>rateest-bps2</b>)

       •   (<b>rateest1 </b>minus <b>rateest-pps1</b>) <i>operator</i> (<b>rateest2 </b>minus
           <b>rateest-pps2</b>)

       <b>--rateest-delta</b>
           For each estimator (either absolute or relative mode),
           calculate the difference between the estimator-determined
           flow rate and the static value chosen with the BPS/PPS
           options. If the flow rate is higher than the specified
           BPS/PPS, 0 will be used instead of a negative value. In other
           words, "max(0, rateest#_rate - rateest#_bps)" is used.

       [<b>!</b>] <b>--rateest-lt</b>
           Match if rate is less than given rate/estimator.

       [<b>!</b>] <b>--rateest-gt</b>
           Match if rate is greater than given rate/estimator.

       [<b>!</b>] <b>--rateest-eq</b>
           Match if rate is equal to given rate/estimator.

       In the so-called "absolute mode", only one rate estimator is used
       and compared against a static value, while in "relative mode",
       two rate estimators are compared against another.

       <b>--rateest </b><i>name</i>
              Name of the one rate estimator for absolute mode.

       <b>--rateest1 </b><i>name</i>

       <b>--rateest2 </b><i>name</i>
              The names of the two rate estimators for relative mode.

       <b>--rateest-bps </b>[<i>value</i>]

       <b>--rateest-pps </b>[<i>value</i>]

       <b>--rateest-bps1 </b>[<i>value</i>]

       <b>--rateest-bps2 </b>[<i>value</i>]

       <b>--rateest-pps1 </b>[<i>value</i>]

       <b>--rateest-pps2 </b>[<i>value</i>]
              Compare the estimator(s) by bytes or packets per second,
              and compare against the chosen value. See the above bullet
              list for which option is to be used in which case. A unit
              suffix may be used — available ones are: bit, [kmgt]bit,
              [KMGT]ibit, Bps, [KMGT]Bps, [KMGT]iBps.

       Example: This is what can be used to route outgoing data
       connections from an FTP server over two lines based on the
       available bandwidth at the time the data connection was started:

       # Estimate outgoing rates

       iptables -t mangle -A POSTROUTING -o eth0 -j RATEEST
       --rateest-name eth0 --rateest-interval 250ms --rateest-ewma 0.5s

       iptables -t mangle -A POSTROUTING -o ppp0 -j RATEEST
       --rateest-name ppp0 --rateest-interval 250ms --rateest-ewma 0.5s

       # Mark based on available bandwidth

       iptables -t mangle -A balance -m conntrack --ctstate NEW -m
       helper --helper ftp -m rateest --rateest-delta --rateest1 eth0
       --rateest-bps1 2.5mbit --rateest-gt --rateest2 ppp0
       --rateest-bps2 2mbit -j CONNMARK --set-mark 1

       iptables -t mangle -A balance -m conntrack --ctstate NEW -m
       helper --helper ftp -m rateest --rateest-delta --rateest1 ppp0
       --rateest-bps1 2mbit --rateest-gt --rateest2 eth0 --rateest-bps2
       2.5mbit -j CONNMARK --set-mark 2

       iptables -t mangle -A balance -j CONNMARK --restore-mark

   <b>realm (IPv4-specific)</b>
       This matches the routing realm.  Routing realms are used in
       complex routing setups involving dynamic routing protocols like
       BGP.

       [<b>!</b>] <b>--realm </b><i>value</i>[<b>/</b><i>mask</i>]
              Matches a given realm number (and optionally mask). If not
              a number, value can be a named realm from
              /etc/iproute2/rt_realms (mask can not be used in that
              case).  Both value and mask are four byte unsigned
              integers and may be specified in decimal, hex (by
              prefixing with "0x") or octal (if a leading zero is
              given).

   <b>recent</b>
       Allows you to dynamically create a list of IP addresses and then
       match against that list in a few different ways.

       For example, you can create a "badguy" list out of people
       attempting to connect to port 139 on your firewall and then DROP
       all future packets from them without considering them.

       <b>--set</b>, <b>--rcheck</b>, <b>--update </b>and <b>--remove </b>are mutually exclusive.

       <b>--name </b><i>name</i>
              Specify the list to use for the commands. If no name is
              given then <b>DEFAULT </b>will be used.

       [<b>!</b>] <b>--set</b>
              This will add the source address of the packet to the
              list. If the source address is already in the list, this
              will update the existing entry. This will always return
              success (or failure if <b>! </b>is passed in).

       <b>--rsource</b>
              Match/save the source address of each packet in the recent
              list table. This is the default.

       <b>--rdest</b>
              Match/save the destination address of each packet in the
              recent list table.

       <b>--mask </b><i>netmask</i>
              Netmask that will be applied to this recent list.

       [<b>!</b>] <b>--rcheck</b>
              Check if the source address of the packet is currently in
              the list.

       [<b>!</b>] <b>--update</b>
              Like <b>--rcheck</b>, except it will update the "last seen"
              timestamp if it matches.

       [<b>!</b>] <b>--remove</b>
              Check if the source address of the packet is currently in
              the list and if so that address will be removed from the
              list and the rule will return true. If the address is not
              found, false is returned.

       <b>--seconds </b><i>seconds</i>
              This option must be used in conjunction with one of
              <b>--rcheck </b>or <b>--update</b>. When used, this will narrow the
              match to only happen when the address is in the list and
              was seen within the last given number of seconds.

       <b>--reap </b>This option can only be used in conjunction with
              <b>--seconds</b>.  When used, this will cause entries older than
              the last given number of seconds to be purged.

       <b>--hitcount </b><i>hits</i>
              This option must be used in conjunction with one of
              <b>--rcheck </b>or <b>--update</b>. When used, this will narrow the
              match to only happen when the address is in the list and
              packets had been received greater than or equal to the
              given value. This option may be used along with <b>--seconds</b>
              to create an even narrower match requiring a certain
              number of hits within a specific time frame. The maximum
              value for the hitcount parameter is given by the
              "ip_pkt_list_tot" parameter of the xt_recent kernel
              module. Exceeding this value on the command line will
              cause the rule to be rejected.

       <b>--rttl </b>This option may only be used in conjunction with one of
              <b>--rcheck </b>or <b>--update</b>. When used, this will narrow the
              match to only happen when the address is in the list and
              the TTL of the current packet matches that of the packet
              which hit the <b>--set </b>rule. This may be useful if you have
              problems with people faking their source address in order
              to DoS you via this module by disallowing others access to
              your site by sending bogus packets to you.

       Examples:

              iptables -A FORWARD -m recent --name badguy --rcheck
              --seconds 60 -j DROP

              iptables -A FORWARD -p tcp -i eth0 --dport 139 -m recent
              --name badguy --set -j DROP

       <b>/proc/net/xt_recent/* </b>are the current lists of addresses and
       information about each entry of each list.

       Each file in <b>/proc/net/xt_recent/ </b>can be read from to see the
       current list or written two using the following commands to
       modify the list:

       <b>echo +</b><i>addr</i> <b>&gt;/proc/net/xt_recent/DEFAULT</b>
              to add <i>addr</i> to the DEFAULT list

       <b>echo -</b><i>addr</i> <b>&gt;/proc/net/xt_recent/DEFAULT</b>
              to remove <i>addr</i> from the DEFAULT list

       <b>echo / &gt;/proc/net/xt_recent/DEFAULT</b>
              to flush the DEFAULT list (remove all entries).

       The module itself accepts parameters, defaults shown:

       <b>ip_list_tot</b>=<i>100</i>
              Number of addresses remembered per table.

       <b>ip_pkt_list_tot</b>=<i>20</i>
              Number of packets per address remembered.

       <b>ip_list_hash_size</b>=<i>0</i>
              Hash table size. 0 means to calculate it based on
              ip_list_tot by rounding it up to the next power of two
              (with <b>ip_list_tot </b>defaulting to <i>100</i>, <b>ip_list_hash_size</b>
              will calculate to <i>128</i> by default).

       <b>ip_list_perms</b>=<i>0644</i>
              Permissions for /proc/net/xt_recent/* files.

       <b>ip_list_uid</b>=<i>0</i>
              Numerical UID for ownership of /proc/net/xt_recent/*
              files.

       <b>ip_list_gid</b>=<i>0</i>
              Numerical GID for ownership of /proc/net/xt_recent/*
              files.

   <b>rpfilter</b>
       Performs a reverse path filter test on a packet.  If a reply to
       the packet would be sent via the same interface that the packet
       arrived on, the packet will match.  Note that, unlike the in-
       kernel rp_filter, packets protected by IPSec are not treated
       specially.  Combine this match with the policy match if you want
       this.  Also, packets arriving via the loopback interface are
       always permitted.  This match can only be used in the PREROUTING
       chain of the raw or mangle table.

       <b>--loose</b>
              Used to specify that the reverse path filter test should
              match even if the selected output device is not the
              expected one.

       <b>--validmark</b>
              Also use the packets' nfmark value when performing the
              reverse path route lookup.

       <b>--accept-local</b>
              This will permit packets arriving from the network with a
              source address that is also assigned to the local machine.

       <b>--invert</b>
              This will invert the sense of the match.  Instead of
              matching packets that passed the reverse path filter test,
              match those that have failed it.

       Example to log and drop packets failing the reverse path filter
       test:

       iptables -t raw -N RPFILTER

       iptables -t raw -A RPFILTER -m rpfilter -j RETURN

       iptables -t raw -A RPFILTER -m limit --limit 10/minute -j NFLOG
       --nflog-prefix "rpfilter drop"

       iptables -t raw -A RPFILTER -j DROP

       iptables -t raw -A PREROUTING -j RPFILTER

       Example to drop failed packets, without logging:

       iptables -t raw -A RPFILTER -m rpfilter --invert -j DROP

   <b>rt (IPv6-specific)</b>
       Match on IPv6 routing header

       [<b>!</b>] <b>--rt-type </b><i>type</i>
              Match the type (numeric).

       [<b>!</b>] <b>--rt-segsleft </b><i>num</i>[<b>:</b><i>num</i>]
              Match the `segments left' field (range).

       [<b>!</b>] <b>--rt-len </b><i>length</i>
              Match the length of this header.

       <b>--rt-0-res</b>
              Match the reserved field, too (type=0)

       <b>--rt-0-addrs </b><i>addr</i>[<b>,</b><i>addr</i>...]
              Match type=0 addresses (list).

       <b>--rt-0-not-strict</b>
              List of type=0 addresses is not a strict list.

   <b>sctp</b>
       This module matches Stream Control Transmission Protocol headers.

       [<b>!</b>] <b>--source-port</b>,<b>--sport </b><i>port</i>[<b>:</b><i>port</i>]

       [<b>!</b>] <b>--destination-port</b>,<b>--dport </b><i>port</i>[<b>:</b><i>port</i>]

       [<b>!</b>] <b>--chunk-types </b>{<b>all</b>|<b>any</b>|<b>only</b>} <i>chunktype</i>[<b>:</b><i>flags</i>] [...]
              The flag letter in upper case indicates that the flag is
              to match if set, in the lower case indicates to match if
              unset.

              Match types:

       all    Match if all given chunk types are present and flags
              match.

       any    Match if any of the given chunk types is present with
              given flags.

       only   Match if only the given chunk types are present with given
              flags and none are missing.

              Chunk types: DATA INIT INIT_ACK SACK HEARTBEAT
              HEARTBEAT_ACK ABORT SHUTDOWN SHUTDOWN_ACK ERROR
              COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR SHUTDOWN_COMPLETE
              I_DATA RE_CONFIG PAD ASCONF ASCONF_ACK FORWARD_TSN
              I_FORWARD_TSN

              chunk type            available flags
              DATA                  I U B E i u b e
              I_DATA                I U B E i u b e
              ABORT                 T t
              SHUTDOWN_COMPLETE     T t

              (lowercase means flag should be "off", uppercase means
              "on")

       Examples:

       iptables -A INPUT -p sctp --dport 80 -j DROP

       iptables -A INPUT -p sctp --chunk-types any DATA,INIT -j DROP

       iptables -A INPUT -p sctp --chunk-types any DATA:Be -j ACCEPT

   <b>set</b>
       This module matches IP sets which can be defined by ipset(8).

       [<b>!</b>] <b>--match-set </b><i>setname flag</i>[<b>,</b><i>flag</i>]...
              where flags are the comma separated list of <b>src </b>and/or <b>dst</b>
              specifications and there can be no more than six of them.
              Hence the command

               iptables -A FORWARD -m set --match-set test src,dst

              will match packets, for which (if the set type is
              ipportmap) the source address and destination port pair
              can be found in the specified set. If the set type of the
              specified set is single dimension (for example ipmap),
              then the command will match packets for which the source
              address can be found in the specified set.

       <b>--return-nomatch</b>
              If the <b>--return-nomatch </b>option is specified and the set
              type supports the <b>nomatch </b>flag, then the matching is
              reversed: a match with an element flagged with <b>nomatch</b>
              returns <b>true</b>, while a match with a plain element returns
              <b>false</b>.

       <b>! --update-counters</b>
              If the <b>--update-counters </b>flag is negated, then the packet
              and byte counters of the matching element in the set won't
              be updated. Default the packet and byte counters are
              updated.

       <b>! --update-subcounters</b>
              If the <b>--update-subcounters </b>flag is negated, then the
              packet and byte counters of the matching element in the
              member set of a list type of set won't be updated. Default
              the packet and byte counters are updated.

       [<b>!</b>] <b>--packets-eq </b><i>value</i>
              If the packet is matched an element in the set, match only
              if the packet counter of the element matches the given
              value too.

       <b>--packets-lt </b><i>value</i>
              If the packet is matched an element in the set, match only
              if the packet counter of the element is less than the
              given value as well.

       <b>--packets-gt </b><i>value</i>
              If the packet is matched an element in the set, match only
              if the packet counter of the element is greater than the
              given value as well.

       [<b>!</b>] <b>--bytes-eq </b><i>value</i>
              If the packet is matched an element in the set, match only
              if the byte counter of the element matches the given value
              too.

       <b>--bytes-lt </b><i>value</i>
              If the packet is matched an element in the set, match only
              if the byte counter of the element is less than the given
              value as well.

       <b>--bytes-gt </b><i>value</i>
              If the packet is matched an element in the set, match only
              if the byte counter of the element is greater than the
              given value as well.

       The packet and byte counters related options and flags are
       ignored when the set was defined without counter support.

       The option <b>--match-set </b>can be replaced by <b>--set </b>if that does not
       clash with an option of other extensions.

       Use of -m set requires that ipset kernel support is provided,
       which, for standard kernels, is the case since Linux 2.6.39.

   <b>socket</b>
       This matches if an open TCP/UDP socket can be found by doing a
       socket lookup on the packet. It matches if there is an
       established or non-zero bound listening socket (possibly with a
       non-local address). The lookup is performed using the <b>packet</b>
       tuple of TCP/UDP packets, or the original TCP/UDP header <b>embedded</b>
       in an ICMP/ICPMv6 error packet.

       <b>--transparent</b>
              Ignore non-transparent sockets.

       <b>--nowildcard</b>
              Do not ignore sockets bound to 'any' address.  The socket
              match won't accept zero-bound listeners by default, since
              then local services could intercept traffic that would
              otherwise be forwarded.  This option therefore has
              security implications when used to match traffic being
              forwarded to redirect such packets to local machine with
              policy routing.  When using the socket match to implement
              fully transparent proxies bound to non-local addresses it
              is recommended to use the --transparent option instead.

       Example (assuming packets with mark 1 are delivered locally):

              -t mangle -A PREROUTING -m socket --transparent -j MARK
              --set-mark 1

       <b>--restore-skmark</b>
              Set the packet mark to the matching socket's mark. Can be
              combined with the <b>--transparent </b>and <b>--nowildcard </b>options
              to restrict the sockets to be matched when restoring the
              packet mark.

       Example: An application opens 2 transparent (<b>IP_TRANSPARENT</b>)
       sockets and sets a mark on them with <b>SO_MARK </b>socket option. We
       can filter matching packets:

              -t mangle -I PREROUTING -m socket --transparent
              --restore-skmark -j action

              -t mangle -A action -m mark --mark 10 -j action2

              -t mangle -A action -m mark --mark 11 -j action3

   <b>state</b>
       The "state" extension is a subset of the "conntrack" module.
       "state" allows access to the connection tracking state for this
       packet.

       [<b>!</b>] <b>--state </b><i>state</i>
              Where state is a comma separated list of the connection
              states to match. Only a subset of the states unterstood by
              "conntrack" are recognized: <b>INVALID</b>, <b>ESTABLISHED</b>, <b>NEW</b>,
              <b>RELATED </b>or <b>UNTRACKED</b>. For their description, see the
              "conntrack" heading in this manpage.

   <b>statistic</b>
       This module matches packets based on some statistic condition.
       It supports two distinct modes settable with the <b>--mode </b>option.

       Supported options:

       <b>--mode </b><i>mode</i>
              Set the matching mode of the matching rule, supported
              modes are <b>random </b>and <b>nth.</b>

       [<b>!</b>] <b>--probability </b><i>p</i>
              Set the probability for a packet to be randomly matched.
              It only works with the <b>random </b>mode. <i>p</i> must be within 0.0
              and 1.0. The supported granularity is in 1/2147483648th
              increments.

       [<b>!</b>] <b>--every </b><i>n</i>
              Match one packet every nth packet. It works only with the
              <b>nth </b>mode (see also the <b>--packet </b>option).

       <b>--packet </b><i>p</i>
              Set the initial counter value (0 &lt;= p &lt;= n-1, default 0)
              for the <b>nth </b>mode.

   <b>string</b>
       This module matches a given string by using some pattern matching
       strategy. It requires a linux kernel &gt;= 2.6.14.

       <b>--algo </b>{<b>bm</b>|<b>kmp</b>}
              Select the pattern matching strategy. (bm = Boyer-Moore,
              kmp = Knuth-Pratt-Morris)

       <b>--from </b><i>offset</i>
              Set the offset from which it starts looking for any
              matching. If not passed, default is 0.

       <b>--to </b><i>offset</i>
              Set the offset up to which should be scanned. That is,
              byte <i>offset</i> (counting from 0) is the last one that is
              scanned and the maximum position of <i>pattern</i>'s last
              character.  If not passed, default is the packet size.

       [<b>!</b>] <b>--string </b><i>pattern</i>
              Matches the given pattern.

       [<b>!</b>] <b>--hex-string </b><i>pattern</i>
              Matches the given pattern in hex notation.

       <b>--icase</b>
              Ignore case when searching.

       Examples:

              # The string pattern can be used for simple text
              characters.
              iptables -A INPUT -p tcp --dport 80 -m string --algo bm
              --string 'GET /index.html' -j LOG

              # The hex string pattern can be used for non-printable
              characters, like |0D 0A| or |0D0A|.
              iptables -p udp --dport 53 -m string --algo bm --from 40
              --to 57 --hex-string '|03|www|09|netfilter|03|org|00|'

       Note: Since Boyer-Moore (BM) performs searches for matches from
       right to left and the kernel may store a packet in multiple
       discontiguous blocks, it's possible that a match could be spread
       over multiple blocks, in which case this algorithm won't find it.

       If you wish to ensure that such thing won't ever happen, use the
       Knuth-Pratt-Morris (KMP) algorithm instead.  In conclusion,
       choose the proper string search algorithm depending on your use-
       case.

       For example, if you're using the module for filtering, NIDS or
       any similar security-focused purpose, then choose KMP. On the
       other hand, if you really care about performance — for example,
       you're classifying packets to apply Quality of Service (QoS)
       policies — and you don't mind about missing possible matches
       spread over multiple fragments, then choose BM.

   <b>tcp</b>
       These extensions can be used if `--protocol tcp' is specified. It
       provides the following options:

       [<b>!</b>] <b>--source-port</b>,<b>--sport </b><i>port</i>[<b>:</b><i>port</i>]
              Source port or port range specification. This can either
              be a service name or a port number. An inclusive range can
              also be specified, using the format <i>first</i><b>:</b><i>last</i>.  If the
              first port is omitted, "0" is assumed; if the last is
              omitted, "65535" is assumed.  The flag <b>--sport </b>is a
              convenient alias for this option.

       [<b>!</b>] <b>--destination-port</b>,<b>--dport </b><i>port</i>[<b>:</b><i>port</i>]
              Destination port or port range specification.  The flag
              <b>--dport </b>is a convenient alias for this option.

       [<b>!</b>] <b>--tcp-flags </b><i>mask comp</i>
              Match when the TCP flags are as specified.  The first
              argument <i>mask</i> is the flags which we should examine,
              written as a comma-separated list, and the second argument
              <i>comp</i> is a comma-separated list of flags which must be set.
              Flags are: <b>SYN ACK FIN RST URG PSH ALL NONE</b>.  Hence the
              command
               iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN
              will only match packets with the SYN flag set, and the
              ACK, FIN and RST flags unset.

       [<b>!</b>] <b>--syn</b>
              Only match TCP packets with the SYN bit set and the
              ACK,RST and FIN bits cleared.  Such packets are used to
              request TCP connection initiation; for example, blocking
              such packets coming in an interface will prevent incoming
              TCP connections, but outgoing TCP connections will be
              unaffected.  It is equivalent to <b>--tcp-flags</b>
              <b>SYN,RST,ACK,FIN SYN</b>.  If the "!" flag precedes the
              "--syn", the sense of the option is inverted.

       [<b>!</b>] <b>--tcp-option </b><i>number</i>
              Match if TCP option set.

   <b>tcpmss</b>
       This matches the TCP MSS (maximum segment size) field of the TCP
       header.  You can only use this on TCP SYN or SYN/ACK packets,
       since the MSS is only negotiated during the TCP handshake at
       connection startup time.

       [<b>!</b>] <b>--mss </b><i>value</i>[<b>:</b><i>value</i>]
              Match a given TCP MSS value or range. If a range is given,
              the second <i>value</i> must be greater than or equal to the
              first <i>value</i>.

   <b>time</b>
       This matches if the packet arrival time/date is within a given
       range. All options are optional, but are ANDed when specified.
       All times are interpreted as UTC by default.

       <b>--datestart </b><i>YYYY</i>[<b>-</b><i>MM</i>[<b>-</b><i>DD</i>[<b>T</b><i>hh</i>[<b>:</b><i>mm</i>[<b>:</b><i>ss</i>]]]]]

       <b>--datestop </b><i>YYYY</i>[<b>-</b><i>MM</i>[<b>-</b><i>DD</i>[<b>T</b><i>hh</i>[<b>:</b><i>mm</i>[<b>:</b><i>ss</i>]]]]]
              Only match during the given time, which must be in ISO
              8601 "T" notation.  The possible time range is
              1970-01-01T00:00:00 to 2038-01-19T04:17:07.

              If --datestart or --datestop are not specified, it will
              default to 1970-01-01 and 2038-01-19, respectively.

       <b>--timestart </b><i>hh</i><b>:</b><i>mm</i>[<b>:</b><i>ss</i>]

       <b>--timestop </b><i>hh</i><b>:</b><i>mm</i>[<b>:</b><i>ss</i>]
              Only match during the given daytime. The possible time
              range is 00:00:00 to 23:59:59. Leading zeroes are allowed
              (e.g. "06:03") and correctly interpreted as base-10.

       [<b>!</b>] <b>--monthdays </b><i>day</i>[<b>,</b><i>day</i>...]
              Only match on the given days of the month. Possible values
              are <b>1 </b>to <b>31</b>. Note that specifying <b>31 </b>will of course not
              match on months which do not have a 31st day; the same
              goes for 28- or 29-day February.

       [<b>!</b>] <b>--weekdays </b><i>day</i>[<b>,</b><i>day</i>...]
              Only match on the given weekdays. Possible values are <b>Mon</b>,
              <b>Tue</b>, <b>Wed</b>, <b>Thu</b>, <b>Fri</b>, <b>Sat</b>, <b>Sun</b>, or values from <b>1 </b>to <b>7</b>,
              respectively. You may also use two-character variants (<b>Mo</b>,
              <b>Tu</b>, etc.).

       <b>--contiguous</b>
              When <b>--timestop </b>is smaller than <b>--timestart </b>value, match
              this as a single time period instead distinct intervals.
              See EXAMPLES.

       <b>--kerneltz</b>
              Use the kernel timezone instead of UTC to determine
              whether a packet meets the time regulations.

       About kernel timezones: Linux keeps the system time in UTC, and
       always does so.  On boot, system time is initialized from a
       referential time source. Where this time source has no timezone
       information, such as the x86 CMOS RTC, UTC will be assumed. If
       the time source is however not in UTC, userspace should provide
       the correct system time and timezone to the kernel once it has
       the information.

       Local time is a feature on top of the (timezone independent)
       system time. Each process has its own idea of local time,
       specified via the TZ environment variable. The kernel also has
       its own timezone offset variable. The TZ userspace environment
       variable specifies how the UTC-based system time is displayed,
       e.g. when you run date(1), or what you see on your desktop clock.
       The TZ string may resolve to different offsets at different
       dates, which is what enables the automatic time-jumping in
       userspace. when DST changes. The kernel's timezone offset
       variable is used when it has to convert between non-UTC sources,
       such as FAT filesystems, to UTC (since the latter is what the
       rest of the system uses).

       The caveat with the kernel timezone is that Linux distributions
       may ignore to set the kernel timezone, and instead only set the
       system time. Even if a particular distribution does set the
       timezone at boot, it is usually does not keep the kernel timezone
       offset — which is what changes on DST — up to date.  ntpd will
       not touch the kernel timezone, so running it will not resolve the
       issue. As such, one may encounter a timezone that is always
       +0000, or one that is wrong half of the time of the year. As
       such, <b>using --kerneltz is highly discouraged.</b>

       EXAMPLES. To match on weekends, use:

              -m time --weekdays Sa,Su

       Or, to match (once) on a national holiday block:

              -m time --datestart 2007-12-24 --datestop 2007-12-27

       Since the stop time is actually inclusive, you would need the
       following stop time to not match the first second of the new day:

              -m time --datestart 2007-01-01T17:00 --datestop
              2007-01-01T23:59:59

       During lunch hour:

              -m time --timestart 12:30 --timestop 13:30

       The fourth Friday in the month:

              -m time --weekdays Fr --monthdays 22,23,24,25,26,27,28

       (Note that this exploits a certain mathematical property. It is
       not possible to say "fourth Thursday OR fourth Friday" in one
       rule. It is possible with multiple rules, though.)

       Matching across days might not do what is expected.  For
       instance,

              -m time --weekdays Mo --timestart 23:00  --timestop 01:00
              Will match Monday, for one hour from midnight to 1 a.m.,
              and then again for another hour from 23:00 onwards.  If
              this is unwanted, e.g. if you would like 'match for two
              hours from Montay 23:00 onwards' you need to also specify
              the --contiguous option in the example above.

   <b>tos</b>
       This module matches the 8-bit Type of Service field in the IPv4
       header (i.e.  including the "Precedence" bits) or the (also
       8-bit) Priority field in the IPv6 header.

       [<b>!</b>] <b>--tos </b><i>value</i>[<b>/</b><i>mask</i>]
              Matches packets with the given TOS mark value. If a mask
              is specified, it is logically ANDed with the TOS mark
              before the comparison.

       [<b>!</b>] <b>--tos </b><i>symbol</i>
              You can specify a symbolic name when using the tos match
              for IPv4. The list of recognized TOS names can be obtained
              by calling iptables with <b>-m tos -h</b>.  Note that this
              implies a mask of 0x3F, i.e. all but the ECN bits.

   <b>ttl (IPv4-specific)</b>
       This module matches the time to live field in the IP header.

       [<b>!</b>] <b>--ttl-eq </b><i>ttl</i>
              Matches the given TTL value.

       <b>--ttl-gt </b><i>ttl</i>
              Matches if TTL is greater than the given TTL value.

       <b>--ttl-lt </b><i>ttl</i>
              Matches if TTL is less than the given TTL value.

   <b>u32</b>
       U32 tests whether quantities of up to 4 bytes extracted from a
       packet have specified values. The specification of what to
       extract is general enough to find data at given offsets from tcp
       headers or payloads.

       [<b>!</b>] <b>--u32 </b><i>tests</i>
              The argument amounts to a program in a small language
              described below.

              tests := location "=" value | tests "&amp;&amp;" location "="
              value

              value := range | value "," range

              range := number | number ":" number

       a single number, <i>n</i>, is interpreted the same as <i>n:n</i>. <i>n:m</i> is
       interpreted as the range of numbers <b>&gt;=n </b>and <b>&lt;=m</b>.

           location := number | location operator number

           operator := "&amp;" | "&lt;&lt;" | "&gt;&gt;" | "@"

       The operators <b>&amp;</b>, <b>&lt;&lt;</b>, <b>&gt;&gt; </b>and <b>&amp;&amp; </b>mean the same as in C.  The <b>= </b>is
       really a set membership operator and the value syntax describes a
       set. The <b>@ </b>operator is what allows moving to the next header and
       is described further below.

       There are currently some artificial implementation limits on the
       size of the tests:

           *  no more than 10 of "<b>=</b>" (and 9 "<b>&amp;&amp;</b>"s) in the u32 argument

           *  no more than 10 ranges (and 9 commas) per value

           *  no more than 10 numbers (and 9 operators) per location

       To describe the meaning of location, imagine the following
       machine that interprets it. There are three registers:

              A is of type <b>char *</b>, initially the address of the IP
              header

              B and C are unsigned 32 bit integers, initially zero

       The instructions are:

       <b>number </b>B = number;

              C = (*(A+B)&lt;&lt;24) + (*(A+B+1)&lt;&lt;16) + (*(A+B+2)&lt;&lt;8) +
              *(A+B+3)

       <b>&amp;number</b>
              C = C &amp; number

       <b>&lt;&lt; number</b>
              C = C &lt;&lt; number

       <b>&gt;&gt; number</b>
              C = C &gt;&gt; number

       <b>@number</b>
              A = A + C; then do the instruction number

       Any access of memory outside [skb-&gt;data,skb-&gt;end] causes the
       match to fail.  Otherwise the result of the computation is the
       final value of C.

       Whitespace is allowed but not required in the tests. However, the
       characters that do occur there are likely to require shell
       quoting, so it is a good idea to enclose the arguments in quotes.

       Example:

              match IP packets with total length &gt;= 256

              The IP header contains a total length field in bytes 2–3.

              --u32 "<b>0 &amp; 0xFFFF = 0x100:0xFFFF</b>"

              read bytes 0–3

              AND that with 0xFFFF (giving bytes 2–3), and test whether
              that is in the range [0x100:0xFFFF]

       Example: (more realistic, hence more complicated)

              match ICMP packets with icmp type 0

              First test that it is an ICMP packet, true iff byte 9
              (protocol) = 1

              --u32 "<b>6 &amp; 0xFF = 1 &amp;&amp; </b>...

              read bytes 6–9, use <b>&amp; </b>to throw away bytes 6–8 and compare
              the result to 1. Next test that it is not a fragment. (If
              so, it might be part of such a packet but we cannot always
              tell.) N.B.: This test is generally needed if you want to
              match anything beyond the IP header. The last 6 bits of
              byte 6 and all of byte 7 are 0 iff this is a complete
              packet (not a fragment). Alternatively, you can allow
              first fragments by only testing the last 5 bits of byte 6.

               ... <b>4 &amp; 0x3FFF = 0 &amp;&amp; </b>...

              Last test: the first byte past the IP header (the type) is
              0. This is where we have to use the @syntax. The length of
              the IP header (IHL) in 32 bit words is stored in the right
              half of byte 0 of the IP header itself.

               ... <b>0 &gt;&gt; 22 &amp; 0x3C @ 0 &gt;&gt; 24 = 0</b>"

              The first 0 means read bytes 0–3, <b>&gt;&gt;22 </b>means shift that 22
              bits to the right. Shifting 24 bits would give the first
              byte, so only 22 bits is four times that plus a few more
              bits. <b>&amp;3C </b>then eliminates the two extra bits on the right
              and the first four bits of the first byte. For instance,
              if IHL=5, then the IP header is 20 (4 x 5) bytes long. In
              this case, bytes 0–1 are (in binary) xxxx0101 yyzzzzzz,
              <b>&gt;&gt;22 </b>gives the 10 bit value xxxx0101yy and <b>&amp;3C </b>gives
              010100. <b>@ </b>means to use this number as a new offset into
              the packet, and read four bytes starting from there. This
              is the first 4 bytes of the ICMP payload, of which byte 0
              is the ICMP type. Therefore, we simply shift the value 24
              to the right to throw out all but the first byte and
              compare the result with 0.

       Example:

              TCP payload bytes 8–12 is any of 1, 2, 5 or 8

              First we test that the packet is a tcp packet (similar to
              ICMP).

              --u32 "<b>6 &amp; 0xFF = 6 &amp;&amp; </b>...

              Next, test that it is not a fragment (same as above).

               ... <b>0 &gt;&gt; 22 &amp; 0x3C @ 12 &gt;&gt; 26 &amp; 0x3C @ 8 = 1,2,5,8</b>"

              <b>0&gt;&gt;22&amp;3C </b>as above computes the number of bytes in the IP
              header. <b>@ </b>makes this the new offset into the packet, which
              is the start of the TCP header. The length of the TCP
              header (again in 32 bit words) is the left half of byte 12
              of the TCP header. The <b>12&gt;&gt;26&amp;3C </b>computes this length in
              bytes (similar to the IP header before). "@" makes this
              the new offset, which is the start of the TCP payload.
              Finally, 8 reads bytes 8–12 of the payload and <b>= </b>checks
              whether the result is any of 1, 2, 5 or 8.

   <b>udp</b>
       These extensions can be used if `--protocol udp' is specified. It
       provides the following options:

       [<b>!</b>] <b>--source-port</b>,<b>--sport </b><i>port</i>[<b>:</b><i>port</i>]
              Source port or port range specification.  See the
              description of the <b>--source-port </b>option of the TCP
              extension for details.

       [<b>!</b>] <b>--destination-port</b>,<b>--dport </b><i>port</i>[<b>:</b><i>port</i>]
              Destination port or port range specification.  See the
              description of the <b>--destination-port </b>option of the TCP
              extension for details.
</pre> <h2>
TARGET EXTENSIONS </h2>
<pre>
       iptables can use extended target modules: the following are
       included in the standard distribution.

   <b>AUDIT</b>
       This target creates audit records for packets hitting the target.
       It can be used to record accepted, dropped, and rejected packets.
       See auditd(8) for additional details.

       <b>--type </b>{<b>accept</b>|<b>drop</b>|<b>reject</b>}
              Set type of audit record. Starting with linux-4.12, this
              option has no effect on generated audit messages anymore.
              It is still accepted by iptables for compatibility
              reasons, but ignored.

       Example:

              iptables -N AUDIT_DROP

              iptables -A AUDIT_DROP -j AUDIT

              iptables -A AUDIT_DROP -j DROP

   <b>CHECKSUM</b>
       This target selectively works around broken/old applications.  It
       can only be used in the mangle table.

       <b>--checksum-fill</b>
              Compute and fill in the checksum in a packet that lacks a
              checksum.  This is particularly useful, if you need to
              work around old applications such as dhcp clients, that do
              not work well with checksum offloads, but don't want to
              disable checksum offload in your device.

   <b>CLASSIFY</b>
       This module allows you to set the skb-&gt;priority value (and thus
       classify the packet into a specific CBQ class).

       <b>--set-class </b><i>major</i><b>:</b><i>minor</i>
              Set the major and minor class value. The values are always
              interpreted as hexadecimal even if no 0x prefix is given.

   <b>CLUSTERIP (IPv4-specific)</b>
       This module allows you to configure a simple cluster of nodes
       that share a certain IP and MAC address without an explicit load
       balancer in front of them.  Connections are statically
       distributed between the nodes in this cluster.

       Please note that CLUSTERIP target is considered deprecated in
       favour of cluster match which is more flexible and not limited to
       IPv4.

       <b>--new  </b>Create a new ClusterIP.  You always have to set this on
              the first rule for a given ClusterIP.

       <b>--hashmode </b><i>mode</i>
              Specify the hashing mode.  Has to be one of <b>sourceip</b>,
              <b>sourceip-sourceport</b>, <b>sourceip-sourceport-destport</b>.

       <b>--clustermac </b><i>mac</i>
              Specify the ClusterIP MAC address. Has to be a link-layer
              multicast address

       <b>--total-nodes </b><i>num</i>
              Number of total nodes within this cluster.

       <b>--local-node </b><i>num</i>
              Local node number within this cluster.

       <b>--hash-init </b><i>rnd</i>
              Specify the random seed used for hash initialization.

   <b>CONNMARK</b>
       This module sets the netfilter mark value associated with a
       connection. The mark is 32 bits wide.

       <b>--set-xmark </b><i>value</i>[<b>/</b><i>mask</i>]
              Zero out the bits given by <i>mask</i> and XOR <i>value</i> into the
              ctmark.

       <b>--save-mark </b>[<b>--nfmask </b><i>nfmask</i>] [<b>--ctmask </b><i>ctmask</i>]
              Copy the packet mark (nfmark) to the connection mark
              (ctmark) using the given masks. The new nfmark value is
              determined as follows:

              ctmark = (ctmark &amp; ~ctmask) ^ (nfmark &amp; nfmask)

              i.e. <i>ctmask</i> defines what bits to clear and <i>nfmask</i> what
              bits of the nfmark to XOR into the ctmark. <i>ctmask</i> and
              <i>nfmask</i> default to 0xFFFFFFFF.

       <b>--restore-mark </b>[<b>--nfmask </b><i>nfmask</i>] [<b>--ctmask </b><i>ctmask</i>]
              Copy the connection mark (ctmark) to the packet mark
              (nfmark) using the given masks. The new ctmark value is
              determined as follows:

              nfmark = (nfmark &amp; ~<i>nfmask</i>) ^ (ctmark &amp; <i>ctmask</i>);

              i.e. <i>nfmask</i> defines what bits to clear and <i>ctmask</i> what
              bits of the ctmark to XOR into the nfmark. <i>ctmask</i> and
              <i>nfmask</i> default to 0xFFFFFFFF.

              <b>--restore-mark </b>is only valid in the <b>mangle </b>table.

       The following mnemonics are available for <b>--set-xmark</b>:

       <b>--and-mark </b><i>bits</i>
              Binary AND the ctmark with <i>bits</i>. (Mnemonic for <b>--set-xmark</b>
              <b>0/</b><i>invbits</i>, where <i>invbits</i> is the binary negation of <i>bits</i>.)

       <b>--or-mark </b><i>bits</i>
              Binary OR the ctmark with <i>bits</i>. (Mnemonic for <b>--set-xmark</b>
              <i>bits</i><b>/</b><i>bits</i>.)

       <b>--xor-mark </b><i>bits</i>
              Binary XOR the ctmark with <i>bits</i>. (Mnemonic for <b>--set-xmark</b>
              <i>bits</i><b>/0</b>.)

       <b>--set-mark </b><i>value</i>[<b>/</b><i>mask</i>]
              Set the connection mark. If a mask is specified then only
              those bits set in the mask are modified.

       <b>--save-mark </b>[<b>--mask </b><i>mask</i>]
              Copy the nfmark to the ctmark. If a mask is specified,
              only those bits are copied.

       <b>--restore-mark </b>[<b>--mask </b><i>mask</i>]
              Copy the ctmark to the nfmark. If a mask is specified,
              only those bits are copied. This is only valid in the
              <b>mangle </b>table.

   <b>CONNSECMARK</b>
       This module copies security markings from packets to connections
       (if unlabeled), and from connections back to packets (also only
       if unlabeled).  Typically used in conjunction with SECMARK, it is
       valid in the <b>security </b>table (for backwards compatibility with
       older kernels, it is also valid in the <b>mangle </b>table).

       <b>--save </b>If the packet has a security marking, copy it to the
              connection if the connection is not marked.

       <b>--restore</b>
              If the packet does not have a security marking, and the
              connection does, copy the security marking from the
              connection to the packet.

   <b>CT</b>
       The CT target sets parameters for a packet or its associated
       connection. The target attaches a "template" connection tracking
       entry to the packet, which is then used by the conntrack core
       when initializing a new ct entry. This target is thus only valid
       in the "raw" table.

       <b>--notrack</b>
              Disables connection tracking for this packet.

       <b>--helper </b><i>name</i>
              Use the helper identified by <i>name</i> for the connection. This
              is more flexible than loading the conntrack helper modules
              with preset ports.

       <b>--ctevents </b><i>event</i>[<b>,</b>...]
              Only generate the specified conntrack events for this
              connection. Possible event types are: <b>new</b>, <b>related</b>,
              <b>destroy</b>, <b>reply</b>, <b>assured</b>, <b>protoinfo</b>, <b>helper</b>, <b>mark </b>(this
              refers to the ctmark, not nfmark), <b>natseqinfo</b>, <b>secmark</b>
              (ctsecmark).

       <b>--expevents </b><i>event</i>[<b>,</b>...]
              Only generate the specified expectation events for this
              connection.  Possible event types are: <b>new</b>.

       <b>--zone-orig </b>{<i>id</i>|<b>mark</b>}
              For traffic coming from ORIGINAL direction, assign this
              packet to zone <i>id</i> and only have lookups done in that zone.
              If <b>mark </b>is used instead of <i>id</i>, the zone is derived from
              the packet nfmark.

       <b>--zone-reply </b>{<i>id</i>|<b>mark</b>}
              For traffic coming from REPLY direction, assign this
              packet to zone <i>id</i> and only have lookups done in that zone.
              If <b>mark </b>is used instead of <i>id</i>, the zone is derived from
              the packet nfmark.

       <b>--zone </b>{<i>id</i>|<b>mark</b>}
              Assign this packet to zone <i>id</i> and only have lookups done
              in that zone.  If <b>mark </b>is used instead of <i>id</i>, the zone is
              derived from the packet nfmark. By default, packets have
              zone 0. This option applies to both directions.

       <b>--timeout </b><i>name</i>
              Use the timeout policy identified by <i>name</i> for the
              connection. This is provides more flexible timeout policy
              definition than global timeout values available at
              /proc/sys/net/netfilter/nf_conntrack_*_timeout_*.

   <b>DNAT</b>
       This target is only valid in the <b>nat </b>table, in the <b>PREROUTING </b>and
       <b>OUTPUT </b>chains, and user-defined chains which are only called from
       those chains.  It specifies that the destination address of the
       packet should be modified (and all future packets in this
       connection will also be mangled), and rules should cease being
       examined.  It takes the following options:

       <b>--to-destination </b>[<i>ipaddr</i>[<b>-</b><i>ipaddr</i>]][<b>:</b><i>port</i>[<b>-</b><i>port</i>[<b>/</b><i>baseport</i><b>]]]</b>
              which can specify a single new destination IP address, an
              inclusive range of IP addresses. Optionally a port range,
              if the rule also specifies one of the following protocols:
              <b>tcp</b>, <b>udp</b>, <b>dccp </b>or <b>sctp</b>.  If no port range is specified,
              then the destination port will never be modified. If no IP
              address is specified then only the destination port will
              be modified.  If <b>baseport </b>is given, the difference of the
              original destination port and its value is used as offset
              into the mapping port range. This allows one to create
              shifted portmap ranges and is available since kernel
              version 4.18.  For a single port or <i>baseport</i>, a service
              name as listed in <b>/etc/services </b>may be used.

       <b>--random</b>
              Randomize source port mapping (kernel &gt;= 2.6.22).

       <b>--persistent</b>
              Gives a client the same source-/destination-address for
              each connection.  This supersedes the SAME target. Support
              for persistent mappings is available from 2.6.29-rc2.

       IPv6 support available since Linux kernels &gt;= 3.7.

   <b>DNPT (IPv6-specific)</b>
       Provides stateless destination IPv6-to-IPv6 Network Prefix
       Translation (as described by RFC 6296).

       You have to use this target in the <b>mangle </b>table, not in the <b>nat</b>
       table. It takes the following options:

       <b>--src-pfx </b>[<i>prefix/length]</i>
              Set source prefix that you want to translate and length

       <b>--dst-pfx </b>[<i>prefix/length]</i>
              Set destination prefix that you want to use in the
              translation and length

       You have to use the SNPT target to undo the translation. Example:

              ip6tables -t mangle -I POSTROUTING -s fd00::/64 ! -o
              vboxnet0 -j SNPT --src-pfx fd00::/64 --dst-pfx
              2001:e20:2000:40f::/64

              ip6tables -t mangle -I PREROUTING -i wlan0 -d
              2001:e20:2000:40f::/64 -j DNPT --src-pfx
              2001:e20:2000:40f::/64 --dst-pfx fd00::/64

       You may need to enable IPv6 neighbor proxy:

              sysctl -w net.ipv6.conf.all.proxy_ndp=1

       You also have to use the <b>NOTRACK </b>target to disable connection
       tracking for translated flows.

   <b>DSCP</b>
       This target alters the value of the DSCP bits within the TOS
       header of the IPv4 packet.  As this manipulates a packet, it can
       only be used in the mangle table.

       <b>--set-dscp </b><i>value</i>
              Set the DSCP field to a numerical value (can be decimal or
              hex)

       <b>--set-dscp-class </b><i>class</i>
              Set the DSCP field to a DiffServ class.

   <b>ECN (IPv4-specific)</b>
       This target selectively works around known ECN blackholes.  It
       can only be used in the mangle table.

       <b>--ecn-tcp-remove</b>
              Remove all ECN bits from the TCP header.  Of course, it
              can only be used in conjunction with <b>-p tcp</b>.

   <b>HL (IPv6-specific)</b>
       This is used to modify the Hop Limit field in IPv6 header. The
       Hop Limit field is similar to what is known as TTL value in IPv4.
       Setting or incrementing the Hop Limit field can potentially be
       very dangerous, so it should be avoided at any cost. This target
       is only valid in <b>mangle </b>table.

       <b>Don't ever set or increment the value on packets that leave your</b>
       <b>local network!</b>

       <b>--hl-set </b><i>value</i>
              Set the Hop Limit to `value'.

       <b>--hl-dec </b><i>value</i>
              Decrement the Hop Limit `value' times.

       <b>--hl-inc </b><i>value</i>
              Increment the Hop Limit `value' times.

   <b>HMARK</b>
       Like MARK, i.e. set the fwmark, but the mark is calculated from
       hashing packet selector at choice. You have also to specify the
       mark range and, optionally, the offset to start from. ICMP error
       messages are inspected and used to calculate the hashing.

       Existing options are:

       <b>--hmark-tuple </b>tuple
              Possible tuple members are: <b>src </b>meaning source address
              (IPv4, IPv6 address), <b>dst </b>meaning destination address
              (IPv4, IPv6 address), <b>sport </b>meaning source port (TCP, UDP,
              UDPlite, SCTP, DCCP), <b>dport </b>meaning destination port (TCP,
              UDP, UDPlite, SCTP, DCCP), <b>spi </b>meaning Security Parameter
              Index (AH, ESP), and <b>ct </b>meaning the usage of the conntrack
              tuple instead of the packet selectors.

       <b>--hmark-mod </b><i>value (must be &gt; 0)</i>
              Modulus for hash calculation (to limit the range of
              possible marks)

       <b>--hmark-offset </b><i>value</i>
              Offset to start marks from.

       For advanced usage, instead of using --hmark-tuple, you can
       specify custom
              prefixes and masks:

       <b>--hmark-src-prefix </b><i>cidr</i>
              The source address mask in CIDR notation.

       <b>--hmark-dst-prefix </b><i>cidr</i>
              The destination address mask in CIDR notation.

       <b>--hmark-sport-mask </b><i>value</i>
              A 16 bit source port mask in hexadecimal.

       <b>--hmark-dport-mask </b><i>value</i>
              A 16 bit destination port mask in hexadecimal.

       <b>--hmark-spi-mask </b><i>value</i>
              A 32 bit field with spi mask.

       <b>--hmark-proto-mask </b><i>value</i>
              An 8 bit field with layer 4 protocol number.

       <b>--hmark-rnd </b><i>value</i>
              A 32 bit random custom value to feed hash calculation.

       <i>Examples:</i>

       iptables -t mangle -A PREROUTING -m conntrack --ctstate NEW
        -j HMARK --hmark-tuple ct,src,dst,proto --hmark-offset 10000
       --hmark-mod 10 --hmark-rnd 0xfeedcafe

       iptables -t mangle -A PREROUTING -j HMARK --hmark-offset 10000
       --hmark-tuple src,dst,proto --hmark-mod 10 --hmark-rnd 0xdeafbeef

   <b>IDLETIMER</b>
       This target can be used to identify when interfaces have been
       idle for a certain period of time.  Timers are identified by
       labels and are created when a rule is set with a new label.  The
       rules also take a timeout value (in seconds) as an option.  If
       more than one rule uses the same timer label, the timer will be
       restarted whenever any of the rules get a hit.  One entry for
       each timer is created in sysfs.  This attribute contains the
       timer remaining for the timer to expire.  The attributes are
       located under the xt_idletimer class:

       /sys/class/xt_idletimer/timers/&lt;label&gt;

       When the timer expires, the target module sends a sysfs
       notification to the userspace, which can then decide what to do
       (eg. disconnect to save power).

       <b>--timeout </b><i>amount</i>
              This is the time in seconds that will trigger the
              notification.

       <b>--label </b><i>string</i>
              This is a unique identifier for the timer.  The maximum
              length for the label string is 27 characters.

   <b>LED</b>
       This creates an LED-trigger that can then be attached to system
       indicator lights, to blink or illuminate them when certain
       packets pass through the system. One example might be to light up
       an LED for a few minutes every time an SSH connection is made to
       the local machine. The following options control the trigger
       behavior:

       <b>--led-trigger-id </b><i>name</i>
              This is the name given to the LED trigger. The actual name
              of the trigger will be prefixed with "netfilter-".

       <b>--led-delay </b><i>ms</i>
              This indicates how long (in milliseconds) the LED should
              be left illuminated when a packet arrives before being
              switched off again. The default is 0 (blink as fast as
              possible.) The special value <i>inf</i> can be given to leave the
              LED on permanently once activated. (In this case the
              trigger will need to be manually detached and reattached
              to the LED device to switch it off again.)

       <b>--led-always-blink</b>
              Always make the LED blink on packet arrival, even if the
              LED is already on.  This allows notification of new
              packets even with long delay values (which otherwise would
              result in a silent prolonging of the delay time.)

       Example:

       Create an LED trigger for incoming SSH traffic:
              iptables -A INPUT -p tcp --dport 22 -j LED
              --led-trigger-id ssh

       Then attach the new trigger to an LED:
              echo netfilter-ssh &gt;/sys/class/leds/<i>ledname</i>/trigger

   <b>LOG</b>
       Turn on kernel logging of matching packets.  When this option is
       set for a rule, the Linux kernel will print some information on
       all matching packets (like most IP/IPv6 header fields) via the
       kernel log (where it can be read with <a href="../man1/dmesg.1.html">dmesg(1)</a> or read in the
       syslog).

       This is a "non-terminating target", i.e. rule traversal continues
       at the next rule.  So if you want to LOG the packets you refuse,
       use two separate rules with the same matching criteria, first
       using target LOG then DROP (or REJECT).

       <b>--log-level </b><i>level</i>
              Level of logging, which can be (system-specific) numeric
              or a mnemonic.  Possible values are (in decreasing order
              of priority): <b>emerg</b>, <b>alert</b>, <b>crit</b>, <b>error</b>, <b>warning</b>, <b>notice</b>,
              <b>info </b>or <b>debug</b>.

       <b>--log-prefix </b><i>prefix</i>
              Prefix log messages with the specified prefix; up to 29
              letters long, and useful for distinguishing messages in
              the logs.

       <b>--log-tcp-sequence</b>
              Log TCP sequence numbers. This is a security risk if the
              log is readable by users.

       <b>--log-tcp-options</b>
              Log options from the TCP packet header.

       <b>--log-ip-options</b>
              Log options from the IP/IPv6 packet header.

       <b>--log-uid</b>
              Log the userid of the process which generated the packet.

       <b>--log-macdecode</b>
              Log MAC addresses and protocol.

   <b>MARK</b>
       This target is used to set the Netfilter mark value associated
       with the packet.  It can, for example, be used in conjunction
       with routing based on fwmark (needs iproute2). If you plan on
       doing so, note that the mark needs to be set in either the
       PREROUTING or the OUTPUT chain of the mangle table to affect
       routing.  The mark field is 32 bits wide.

       <b>--set-xmark </b><i>value</i>[<b>/</b><i>mask</i>]
              Zeroes out the bits given by <i>mask</i> and XORs <i>value</i> into the
              packet mark ("nfmark"). If <i>mask</i> is omitted, 0xFFFFFFFF is
              assumed.

       <b>--set-mark </b><i>value</i>[<b>/</b><i>mask</i>]
              Zeroes out the bits given by <i>mask</i> and ORs <i>value</i> into the
              packet mark. If <i>mask</i> is omitted, 0xFFFFFFFF is assumed.

       The following mnemonics are available:

       <b>--and-mark </b><i>bits</i>
              Binary AND the nfmark with <i>bits</i>. (Mnemonic for <b>--set-xmark</b>
              <b>0/</b><i>invbits</i>, where <i>invbits</i> is the binary negation of <i>bits</i>.)

       <b>--or-mark </b><i>bits</i>
              Binary OR the nfmark with <i>bits</i>. (Mnemonic for <b>--set-xmark</b>
              <i>bits</i><b>/</b><i>bits</i>.)

       <b>--xor-mark </b><i>bits</i>
              Binary XOR the nfmark with <i>bits</i>. (Mnemonic for <b>--set-xmark</b>
              <i>bits</i><b>/0</b>.)

   <b>MASQUERADE</b>
       This target is only valid in the <b>nat </b>table, in the <b>POSTROUTING</b>
       chain.  It should only be used with dynamically assigned IP
       (dialup) connections: if you have a static IP address, you should
       use the SNAT target.  Masquerading is equivalent to specifying a
       mapping to the IP address of the interface the packet is going
       out, but also has the effect that connections are <i>forgotten</i> when
       the interface goes down.  This is the correct behavior when the
       next dialup is unlikely to have the same interface address (and
       hence any established connections are lost anyway).

       <b>--to-ports </b><i>port</i>[<b>-</b><i>port</i>]
              This specifies a range of source ports to use, overriding
              the default <b>SNAT </b>source port selection heuristics (see
              above). This is only valid if the rule also specifies one
              of the following protocols: <b>tcp</b>, <b>udp</b>, <b>dccp </b>or <b>sctp</b>.

       <b>--random</b>
              Randomize source port mapping (kernel &gt;= 2.6.21).  Since
              kernel 5.0, <b>--random </b>is identical to <b>--random-fully</b>.

       <b>--random-fully</b>
              Fully randomize source port mapping (kernel &gt;= 3.13).

       IPv6 support available since Linux kernels &gt;= 3.7.

   <b>NETMAP</b>
       This target allows you to statically map a whole network of
       addresses onto another network of addresses.  It can only be used
       from rules in the <b>nat </b>table.

       <b>--to </b><i>address</i>[<b>/</b><i>mask</i>]
              Network address to map to.  The resulting address will be
              constructed in the following way: All 'one' bits in the
              mask are filled in from the new `address'.  All bits that
              are zero in the mask are filled in from the original
              address.

       IPv6 support available since Linux kernels &gt;= 3.7.

   <b>NFLOG</b>
       This target provides logging of matching packets. When this
       target is set for a rule, the Linux kernel will pass the packet
       to the loaded logging backend to log the packet. This is usually
       used in combination with nfnetlink_log as logging backend, which
       will multicast the packet through a <i>netlink</i> socket to the
       specified multicast group. One or more userspace processes may
       subscribe to the group to receive the packets. Like LOG, this is
       a non-terminating target, i.e. rule traversal continues at the
       next rule.

       <b>--nflog-group </b><i>nlgroup</i>
              The netlink group (0–2^16-1) to which packets are (only
              applicable for nfnetlink_log). The default value is 0.

       <b>--nflog-prefix </b><i>prefix</i>
              A prefix string to include in the log message, up to 64
              characters long, useful for distinguishing messages in the
              logs.

       <b>--nflog-range </b><i>size</i>
              This option has never worked, use --nflog-size instead

       <b>--nflog-size </b><i>size</i>
              The number of bytes to be copied to userspace (only
              applicable for nfnetlink_log). nfnetlink_log instances may
              specify their own range, this option overrides it.

       <b>--nflog-threshold </b><i>size</i>
              Number of packets to queue inside the kernel before
              sending them to userspace (only applicable for
              nfnetlink_log). Higher values result in less overhead per
              packet, but increase delay until the packets reach
              userspace. The default value is 1.

   <b>NFQUEUE</b>
       This target passes the packet to userspace using the
       <b>nfnetlink_queue </b>handler.  The packet is put into the queue
       identified by its 16-bit queue number.  Userspace can inspect and
       modify the packet if desired. Userspace must then drop or
       reinject the packet into the kernel.  Please see
       libnetfilter_queue for details.  <b>nfnetlink_queue </b>was added in
       Linux 2.6.14. The <b>queue-balance </b>option was added in Linux 2.6.31,
       <b>queue-bypass </b>in 2.6.39.

       <b>--queue-num </b><i>value</i>
              This specifies the QUEUE number to use. Valid queue
              numbers are 0 to 65535. The default value is 0.

       <b>--queue-balance </b><i>value</i><b>:</b><i>value</i>
              This specifies a range of queues to use. Packets are then
              balanced across the given queues.  This is useful for
              multicore systems: start multiple instances of the
              userspace program on queues x, x+1, .. x+n and use
              "--queue-balance <i>x</i><b>:</b><i>x+n</i>".  Packets belonging to the same
              connection are put into the same nfqueue.  Due to
              implementation details, a lower range value of 0 limits
              the higher range value to 65534, i.e. one can only balance
              between at most 65535 queues.

       <b>--queue-bypass</b>
              By default, if no userspace program is listening on an
              NFQUEUE, then all packets that are to be queued are
              dropped.  When this option is used, the NFQUEUE rule
              behaves like ACCEPT instead, and the packet will move on
              to the next table.

       <b>--queue-cpu-fanout</b>
              Available starting Linux kernel 3.10. When used together
              with <b>--queue-balance </b>this will use the CPU ID as an index
              to map packets to the queues. The idea is that you can
              improve performance if there's a queue per CPU. This
              requires <b>--queue-balance </b>to be specified.

   <b>NOTRACK</b>
       This extension disables connection tracking for all packets
       matching that rule.  It is equivalent with -j CT --notrack. Like
       CT, NOTRACK can only be used in the <b>raw </b>table.

   <b>RATEEST</b>
       The RATEEST target collects statistics, performs rate estimation
       calculation and saves the results for later evaluation using the
       <b>rateest </b>match.

       <b>--rateest-name </b><i>name</i>
              Count matched packets into the pool referred to by <i>name</i>,
              which is freely choosable.

       <b>--rateest-interval </b><i>amount</i>{<b>s</b>|<b>ms</b>|<b>us</b>}
              Rate measurement interval, in seconds, milliseconds or
              microseconds.

       <b>--rateest-ewmalog </b><i>value</i>
              Rate measurement averaging time constant.

   <b>REDIRECT</b>
       This target is only valid in the <b>nat </b>table, in the <b>PREROUTING </b>and
       <b>OUTPUT </b>chains, and user-defined chains which are only called from
       those chains.  It redirects the packet to the machine itself by
       changing the destination IP to the primary address of the
       incoming interface (locally-generated packets are mapped to the
       localhost address, 127.0.0.1 for IPv4 and ::1 for IPv6, and
       packets arriving on interfaces that don't have an IP address
       configured are dropped).

       <b>--to-ports </b><i>port</i>[<b>-</b><i>port</i>]
              This specifies a destination port or range of ports to
              use: without this, the destination port is never altered.
              This is only valid if the rule also specifies one of the
              following protocols: <b>tcp</b>, <b>udp</b>, <b>dccp </b>or <b>sctp</b>.  For a single
              port, a service name as listed in <b>/etc/services </b>may be
              used.

       <b>--random</b>
              Randomize source port mapping (kernel &gt;= 2.6.22).

       IPv6 support available starting Linux kernels &gt;= 3.7.

   <b>REJECT (IPv6-specific)</b>
       This is used to send back an error packet in response to the
       matched packet: otherwise it is equivalent to <b>DROP </b>so it is a
       terminating TARGET, ending rule traversal.  This target is only
       valid in the <b>INPUT</b>, <b>FORWARD </b>and <b>OUTPUT </b>chains, and user-defined
       chains which are only called from those chains.  The following
       option controls the nature of the error packet returned:

       <b>--reject-with </b><i>type</i>
              The type given can be <b>icmp6-no-route</b>, <b>no-route</b>,
              <b>icmp6-adm-prohibited</b>, <b>adm-prohibited</b>,
              <b>icmp6-addr-unreachable</b>, <b>addr-unreach</b>, or
              <b>icmp6-port-unreachable</b>, which return the appropriate
              ICMPv6 error message (<b>icmp6-port-unreachable </b>is the
              default). Finally, the option <b>tcp-reset </b>can be used on
              rules which only match the TCP protocol: this causes a TCP
              RST packet to be sent back.  This is mainly useful for
              blocking <i>ident</i> (113/tcp) probes which frequently occur
              when sending mail to broken mail hosts (which won't accept
              your mail otherwise).  <b>tcp-reset </b>can only be used with
              kernel versions 2.6.14 or later.

       <i>Warning:</i> You should not indiscriminately apply the REJECT target
       to packets whose connection state is classified as INVALID;
       instead, you should only DROP these.

       Consider a source host transmitting a packet P, with P
       experiencing so much delay along its path that the source host
       issues a retransmission, P_2, with P_2 being successful in
       reaching its destination and advancing the connection state
       normally. It is conceivable that the late-arriving P may be
       considered not to be associated with any connection tracking
       entry. Generating a reject response for a packet so classed would
       then terminate the healthy connection.

       So, instead of:

       -A INPUT ... -j REJECT

       do consider using:

       -A INPUT ... -m conntrack --ctstate INVALID -j DROP
       -A INPUT ... -j REJECT

   <b>REJECT (IPv4-specific)</b>
       This is used to send back an error packet in response to the
       matched packet: otherwise it is equivalent to <b>DROP </b>so it is a
       terminating TARGET, ending rule traversal.  This target is only
       valid in the <b>INPUT</b>, <b>FORWARD </b>and <b>OUTPUT </b>chains, and user-defined
       chains which are only called from those chains.  The following
       option controls the nature of the error packet returned:

       <b>--reject-with </b><i>type</i>
              The type given can be <b>icmp-net-unreachable</b>,
              <b>icmp-host-unreachable</b>, <b>icmp-port-unreachable</b>,
              <b>icmp-proto-unreachable</b>, <b>icmp-net-prohibited</b>,
              <b>icmp-host-prohibited</b>, or <b>icmp-admin-prohibited </b>(*), which
              return the appropriate ICMP error message
              (<b>icmp-port-unreachable </b>is the default).  The option
              <b>tcp-reset </b>can be used on rules which only match the TCP
              protocol: this causes a TCP RST packet to be sent back.
              This is mainly useful for blocking <i>ident</i> (113/tcp) probes
              which frequently occur when sending mail to broken mail
              hosts (which won't accept your mail otherwise).

              (*) Using icmp-admin-prohibited with kernels that do not
              support it will result in a plain DROP instead of REJECT

       <i>Warning:</i> You should not indiscriminately apply the REJECT target
       to packets whose connection state is classified as INVALID;
       instead, you should only DROP these.

       Consider a source host transmitting a packet P, with P
       experiencing so much delay along its path that the source host
       issues a retransmission, P_2, with P_2 being successful in
       reaching its destination and advancing the connection state
       normally. It is conceivable that the late-arriving P may be
       considered not to be associated with any connection tracking
       entry. Generating a reject response for a packet so classed would
       then terminate the healthy connection.

       So, instead of:

       -A INPUT ... -j REJECT

       do consider using:

       -A INPUT ... -m conntrack --ctstate INVALID -j DROP
       -A INPUT ... -j REJECT

   <b>SECMARK</b>
       This is used to set the security mark value associated with the
       packet for use by security subsystems such as SELinux.  It is
       valid in the <b>security </b>table (for backwards compatibility with
       older kernels, it is also valid in the <b>mangle </b>table). The mark is
       32 bits wide.

       <b>--selctx </b><i>security_context</i>

   <b>SET</b>
       This module adds and/or deletes entries from IP sets which can be
       defined by ipset(8).

       <b>--add-set </b><i>setname flag</i>[<b>,</b><i>flag</i>...]
              add the address(es)/port(s) of the packet to the set

       <b>--del-set </b><i>setname flag</i>[<b>,</b><i>flag</i>...]
              delete the address(es)/port(s) of the packet from the set

       <b>--map-set </b><i>setname flag</i>[<b>,</b><i>flag</i>...]
              [--map-mark] [--map-prio] [--map-queue] map packet
              properties (firewall mark, tc priority, hardware queue)

              where <i>flag</i>(s) are <b>src </b>and/or <b>dst </b>specifications and there
              can be no more than six of them.

       <b>--timeout </b><i>value</i>
              when adding an entry, the timeout value to use instead of
              the default one from the set definition

       <b>--exist</b>
              when adding an entry if it already exists, reset the
              timeout value to the specified one or to the default from
              the set definition

       <b>--map-set </b><i>set-name</i>
              the set-name should be created with --skbinfo option
              <b>--map-mark </b>map firewall mark to packet by lookup of value
              in the set <b>--map-prio </b>map traffic control priority to
              packet by lookup of value in the set <b>--map-queue </b>map
              hardware NIC queue to packet by lookup of value in the set

              The <b>--map-set </b>option can be used from the mangle table
              only. The <b>--map-prio </b>and <b>--map-queue </b>flags can be used in
              the OUTPUT, FORWARD and POSTROUTING chains.

       Use of -j SET requires that ipset kernel support is provided,
       which, for standard kernels, is the case since Linux 2.6.39.

   <b>SNAT</b>
       This target is only valid in the <b>nat </b>table, in the <b>POSTROUTING</b>
       and <b>INPUT </b>chains, and user-defined chains which are only called
       from those chains.  It specifies that the source address of the
       packet should be modified (and all future packets in this
       connection will also be mangled), and rules should cease being
       examined.  It takes the following options:

       <b>--to-source </b>[<i>ipaddr</i>[<b>-</b><i>ipaddr</i>]][<b>:</b><i>port</i>[<b>-</b><i>port</i>]]
              which can specify a single new source IP address, an
              inclusive range of IP addresses. Optionally a port range,
              if the rule also specifies one of the following protocols:
              <b>tcp</b>, <b>udp</b>, <b>dccp </b>or <b>sctp</b>.  If no port range is specified,
              then source ports below 512 will be mapped to other ports
              below 512: those between 512 and 1023 inclusive will be
              mapped to ports below 1024, and other ports will be mapped
              to 1024 or above. Where possible, no port alteration will
              occur.

       <b>--random</b>
              Randomize source port mapping through a hash-based
              algorithm (kernel &gt;= 2.6.21).

       <b>--random-fully</b>
              Fully randomize source port mapping through a PRNG (kernel
              &gt;= 3.14).

       <b>--persistent</b>
              Gives a client the same source-/destination-address for
              each connection.  This supersedes the SAME target. Support
              for persistent mappings is available from 2.6.29-rc2.

       Kernels prior to 2.6.36-rc1 don't have the ability to <b>SNAT </b>in the
       <b>INPUT </b>chain.

       IPv6 support available since Linux kernels &gt;= 3.7.

   <b>SNPT (IPv6-specific)</b>
       Provides stateless source IPv6-to-IPv6 Network Prefix Translation
       (as described by RFC 6296).

       You have to use this target in the <b>mangle </b>table, not in the <b>nat</b>
       table. It takes the following options:

       <b>--src-pfx </b>[<i>prefix/length]</i>
              Set source prefix that you want to translate and length

       <b>--dst-pfx </b>[<i>prefix/length]</i>
              Set destination prefix that you want to use in the
              translation and length

       You have to use the DNPT target to undo the translation. Example:

              ip6tables -t mangle -I POSTROUTING -s fd00::/64 ! -o
              vboxnet0 -j SNPT --src-pfx fd00::/64 --dst-pfx
              2001:e20:2000:40f::/64

              ip6tables -t mangle -I PREROUTING -i wlan0 -d
              2001:e20:2000:40f::/64 -j DNPT --src-pfx
              2001:e20:2000:40f::/64 --dst-pfx fd00::/64

       You may need to enable IPv6 neighbor proxy:

              sysctl -w net.ipv6.conf.all.proxy_ndp=1

       You also have to use the <b>NOTRACK </b>target to disable connection
       tracking for translated flows.

   <b>SYNPROXY</b>
       This target will process TCP three-way-handshake parallel in
       netfilter context to protect either local or backend system. This
       target requires connection tracking because sequence numbers need
       to be translated.  The kernels ability to absorb SYNFLOOD was
       greatly improved starting with Linux 4.4, so this target should
       not be needed anymore to protect Linux servers.

       <b>--mss </b><i>maximum segment size</i>
              Maximum segment size announced to clients. This must match
              the backend.

       <b>--wscale </b><i>window scale</i>
              Window scale announced to clients. This must match the
              backend.

       <b>--sack-perm</b>
              Pass client selective acknowledgement option to backend
              (will be disabled if not present).

       <b>--timestamps</b>
              Pass client timestamp option to backend (will be disabled
              if not present, also needed for selective acknowledgement
              and window scaling).

       Example:

       Determine tcp options used by backend, from an external system

              tcpdump -pni eth0 -c 1 'tcp[tcpflags] ==
              (tcp-syn|tcp-ack)'
                  port 80 &amp;
              telnet 192.0.2.42 80
              18:57:24.693307 IP 192.0.2.42.80 &gt; 192.0.2.43.48757:
                  Flags [S.], seq 360414582, ack 788841994, win 14480,
                  options [mss 1460,sackOK,
                  TS val 1409056151 ecr 9690221,
                  nop,wscale 9],
                  length 0

       Switch tcp_loose mode off, so conntrack will mark out-of-flow
       packets as state INVALID.

              echo 0 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_loose

       Make SYN packets untracked

              iptables -t raw -A PREROUTING -i eth0 -p tcp --dport 80
                  --syn -j CT --notrack

       Catch UNTRACKED (SYN packets) and INVALID (3WHS ACK packets)
       states and send them to SYNPROXY. This rule will respond to SYN
       packets with SYN+ACK syncookies, create ESTABLISHED for valid
       client response (3WHS ACK packets) and drop incorrect cookies.
       Flags combinations not expected during 3WHS will not match and
       continue (e.g. SYN+FIN, SYN+ACK).

              iptables -A INPUT -i eth0 -p tcp --dport 80
                  -m state --state UNTRACKED,INVALID -j SYNPROXY
                  --sack-perm --timestamp --mss 1460 --wscale 9

       Drop invalid packets, this will be out-of-flow packets that were
       not matched by SYNPROXY.

              iptables -A INPUT -i eth0 -p tcp --dport 80 -m state
              --state INVALID -j DROP

   <b>TCPMSS</b>
       This target alters the MSS value of TCP SYN packets, to control
       the maximum size for that connection (usually limiting it to your
       outgoing interface's MTU minus 40 for IPv4 or 60 for IPv6,
       respectively).  Of course, it can only be used in conjunction
       with <b>-p tcp</b>.

       This target is used to overcome criminally braindead ISPs or
       servers which block "ICMP Fragmentation Needed" or "ICMPv6 Packet
       Too Big" packets.  The symptoms of this problem are that
       everything works fine from your Linux firewall/router, but
       machines behind it can never exchange large packets:

       1.  Web browsers connect, then hang with no data received.

       2.  Small mail works fine, but large emails hang.

       3.  ssh works fine, but scp hangs after initial handshaking.

       Workaround: activate this option and add a rule to your firewall
       configuration like:

               iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST
              SYN
                           -j TCPMSS --clamp-mss-to-pmtu

       <b>--set-mss </b><i>value</i>
              Explicitly sets MSS option to specified value. If the MSS
              of the packet is already lower than <i>value</i>, it will <b>not </b>be
              increased (from Linux 2.6.25 onwards) to avoid more
              problems with hosts relying on a proper MSS.

       <b>--clamp-mss-to-pmtu</b>
              Automatically clamp MSS value to (path_MTU - 40 for IPv4;
              -60 for IPv6).  This may not function as desired where
              asymmetric routes with differing path MTU exist — the
              kernel uses the path MTU which it would use to send
              packets from itself to the source and destination IP
              addresses. Prior to Linux 2.6.25, only the path MTU to the
              destination IP address was considered by this option;
              subsequent kernels also consider the path MTU to the
              source IP address.

       These options are mutually exclusive.

   <b>TCPOPTSTRIP</b>
       This target will strip TCP options off a TCP packet. (It will
       actually replace them by NO-OPs.) As such, you will need to add
       the <b>-p tcp </b>parameters.

       <b>--strip-options </b><i>option</i>[<b>,</b><i>option</i>...]
              Strip the given option(s). The options may be specified by
              TCP option number or by symbolic name. The list of
              recognized options can be obtained by calling iptables
              with <b>-j TCPOPTSTRIP -h</b>.

   <b>TEE</b>
       The <b>TEE </b>target will clone a packet and redirect this clone to
       another machine on the <b>local </b>network segment. In other words, the
       nexthop must be the target, or you will have to configure the
       nexthop to forward it further if so desired.

       <b>--gateway </b><i>ipaddr</i>
              Send the cloned packet to the host reachable at the given
              IP address.  Use of 0.0.0.0 (for IPv4 packets) or ::
              (IPv6) is invalid.

       To forward all incoming traffic on eth0 to an Network Layer
       logging box:

       -t mangle -A PREROUTING -i eth0 -j TEE --gateway 2001:db8::1

   <b>TOS</b>
       This module sets the Type of Service field in the IPv4 header
       (including the "precedence" bits) or the Priority field in the
       IPv6 header. Note that TOS shares the same bits as DSCP and ECN.
       The TOS target is only valid in the <b>mangle </b>table.

       <b>--set-tos </b><i>value</i>[<b>/</b><i>mask</i>]
              Zeroes out the bits given by <i>mask</i> (see NOTE below) and
              XORs <i>value</i> into the TOS/Priority field. If <i>mask</i> is
              omitted, 0xFF is assumed.

       <b>--set-tos </b><i>symbol</i>
              You can specify a symbolic name when using the TOS target
              for IPv4. It implies a mask of 0xFF (see NOTE below). The
              list of recognized TOS names can be obtained by calling
              iptables with <b>-j TOS -h</b>.

       The following mnemonics are available:

       <b>--and-tos </b><i>bits</i>
              Binary AND the TOS value with <i>bits</i>. (Mnemonic for
              <b>--set-tos 0/</b><i>invbits</i>, where <i>invbits</i> is the binary negation
              of <i>bits</i>.  See NOTE below.)

       <b>--or-tos </b><i>bits</i>
              Binary OR the TOS value with <i>bits</i>. (Mnemonic for <b>--set-tos</b>
              <i>bits</i><b>/</b><i>bits</i>. See NOTE below.)

       <b>--xor-tos </b><i>bits</i>
              Binary XOR the TOS value with <i>bits</i>. (Mnemonic for
              <b>--set-tos </b><i>bits</i><b>/0</b>. See NOTE below.)

       NOTE: In Linux kernels up to and including 2.6.38, with the
       exception of longterm releases 2.6.32 (&gt;=.42), 2.6.33 (&gt;=.15),
       and 2.6.35 (&gt;=.14), there is a bug whereby IPv6 TOS mangling does
       not behave as documented and differs from the IPv4 version. The
       TOS mask indicates the bits one wants to zero out, so it needs to
       be inverted before applying it to the original TOS field.
       However, the aforementioned kernels forgo the inversion which
       breaks --set-tos and its mnemonics.

   <b>TPROXY</b>
       This target is only valid in the <b>mangle </b>table, in the <b>PREROUTING</b>
       chain and user-defined chains which are only called from this
       chain. It redirects the packet to a local socket without changing
       the packet header in any way. It can also change the mark value
       which can then be used in advanced routing rules.  It takes three
       options:

       <b>--on-port </b><i>port</i>
              This specifies a destination port to use. It is a required
              option, 0 means the new destination port is the same as
              the original. This is only valid if the rule also
              specifies <b>-p tcp </b>or <b>-p udp</b>.

       <b>--on-ip </b><i>address</i>
              This specifies a destination address to use. By default
              the address is the IP address of the incoming interface.
              This is only valid if the rule also specifies <b>-p tcp </b>or <b>-p</b>
              <b>udp</b>.

       <b>--tproxy-mark </b><i>value</i>[<b>/</b><i>mask</i>]
              Marks packets with the given value/mask. The fwmark value
              set here can be used by advanced routing. (Required for
              transparent proxying to work: otherwise these packets will
              get forwarded, which is probably not what you want.)

   <b>TRACE</b>
       This target marks packets so that the kernel will log every rule
       which match the packets as those traverse the tables, chains,
       rules. It can only be used in the <b>raw </b>table.

       With iptables-legacy, a logging backend, such as ip(6)t_LOG or
       nfnetlink_log, must be loaded for this to be visible.  The
       packets are logged with the string prefix: "TRACE:
       tablename:chainname:type:rulenum " where type can be "rule" for
       plain rule, "return" for implicit rule at the end of a user
       defined chain and "policy" for the policy of the built in chains.

       With iptables-nft, the target is translated into nftables' <b>meta</b>
       <b>nftrace </b>expression. Hence the kernel sends trace events via
       netlink to userspace where they may be displayed using
       <b>xtables-monitor --trace </b>command. For details, refer to
       <a href="xtables-monitor.8.html">xtables-monitor(8)</a>.

   <b>TTL (IPv4-specific)</b>
       This is used to modify the IPv4 TTL header field.  The TTL field
       determines how many hops (routers) a packet can traverse until
       it's time to live is exceeded.

       Setting or incrementing the TTL field can potentially be very
       dangerous, so it should be avoided at any cost. This target is
       only valid in <b>mangle </b>table.

       <b>Don't ever set or increment the value on packets that leave your</b>
       <b>local network!</b>

       <b>--ttl-set </b><i>value</i>
              Set the TTL value to `value'.

       <b>--ttl-dec </b><i>value</i>
              Decrement the TTL value `value' times.

       <b>--ttl-inc </b><i>value</i>
              Increment the TTL value `value' times.

   <b>ULOG (IPv4-specific)</b>
       This is the deprecated IPv4-only predecessor of the NFLOG target.
       It provides userspace logging of matching packets.  When this
       target is set for a rule, the Linux kernel will multicast this
       packet through a <i>netlink</i> socket. One or more userspace processes
       may then subscribe to various multicast groups and receive the
       packets.  Like LOG, this is a "non-terminating target", i.e. rule
       traversal continues at the next rule.

       <b>--ulog-nlgroup </b><i>nlgroup</i>
              This specifies the netlink group (1–32) to which the
              packet is sent.  Default value is 1.

       <b>--ulog-prefix </b><i>prefix</i>
              Prefix log messages with the specified prefix; up to 32
              characters long, and useful for distinguishing messages in
              the logs.

       <b>--ulog-cprange </b><i>size</i>
              Number of bytes to be copied to userspace.  A value of 0
              always copies the entire packet, regardless of its size.
              Default is 0.

       <b>--ulog-qthreshold </b><i>size</i>
              Number of packet to queue inside kernel.  Setting this
              value to, e.g. 10 accumulates ten packets inside the
              kernel and transmits them as one netlink multipart message
              to userspace.  Default is 1 (for backwards compatibility).
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>iptables</i> (administer and maintain packet
       filter rules) project.  Information about the project can be
       found at ⟨<a href="http://www.netfilter.org/">http://www.netfilter.org/</a>⟩.  If you have a bug report
       for this manual page, see ⟨<a href="http://bugzilla.netfilter.org/">http://bugzilla.netfilter.org/</a>⟩.  This
       page was obtained from the project's upstream Git repository
       ⟨git://git.netfilter.org/iptables⟩ on 2024-06-14.  (At that time,
       the date of the most recent commit that was found in the
       repository was 2024-06-12.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">iptables 1.8.10                                   <i>iptables-extensions</i>(8)</span>
</pre>  <p>Pages that refer to this page: <a href="../man5/proc_pid_net.5.html">proc_pid_net(5)</a>, <a href="iptables.8.html">iptables(8)</a>, <a href="tc-fw.8.html">tc-fw(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man8/iptables-extensions.8.html" class="_attribution-link">https://man7.org/linux/man-pages/man8/iptables-extensions.8.html</a>
  </p>
</div>
