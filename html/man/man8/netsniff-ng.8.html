<h1>netsniff-ng(8) — Linux manual page</h1>   <pre>
<span class="headline"><i>NETSNIFF-NG</i>(8)             netsniff-ng toolkit            <i>NETSNIFF-NG</i>(8)</span>
</pre> <h2>
NAME </h2>
<pre>
       netsniff-ng - the packet sniffing beast
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>netsniff-ng </b>{ [<i>options</i>] [<i>filter-expression</i>] }
</pre> <h2>
DESCRIPTION </h2>
<pre>
       netsniff-ng is a fast, minimal tool to analyze network packets,
       capture pcap files, replay pcap files, and redirect traffic
       between interfaces with the help of zero-copy packet(7) sockets.
       netsniff-ng uses both Linux specific RX_RING and TX_RING
       interfaces to perform zero-copy. This is to avoid copy and system
       call overhead between kernel and user address space. When we
       started working on netsniff-ng, the pcap(3) library did not use
       this zero-copy facility.

       netsniff-ng is Linux specific, meaning there is no support for
       other operating systems. Therefore we can keep the code footprint
       quite minimal and to the point. Linux packet(7) sockets and its
       RX_RING and TX_RING interfaces bypass the normal packet
       processing path through the networking stack.  This is the
       fastest capturing or transmission performance one can get from
       user space out of the box, without having to load unsupported or
       non-mainline third-party kernel modules. We explicitly refuse to
       build netsniff-ng on top of ntop/PF_RING. Not because we do not
       like it (we do find it interesting), but because of the fact that
       it is not part of the mainline kernel. Therefore, the ntop
       project has to maintain and sync out-of-tree drivers to adapt
       them to their DNA. Eventually, we went for untainted Linux
       kernel, since its code has a higher rate of review, maintenance,
       security and bug fixes.

       netsniff-ng also supports early packet filtering in the kernel.
       It has support for low-level and high-level packet filters that
       are translated into Berkeley Packet Filter instructions.

       netsniff-ng can capture pcap files in several different pcap
       formats that are interoperable with other tools. The following
       pcap I/O methods are supported for efficient to-disc capturing:
       scatter-gather, <a href="../man2/mmap.2.html">mmap(2)</a>, <a href="../man2/read.2.html">read(2)</a>, and <a href="../man2/write.2.html">write(2)</a>.  netsniff-ng is
       also able to rotate pcap files based on data size or time
       intervals, thus, making it a useful backend tool for subsequent
       traffic analysis.

       netsniff-ng itself also supports analysis, replaying, and dumping
       of raw 802.11 frames. For online or offline analysis, netsniff-ng
       has a built-in packet dissector for the current 802.3 (Ethernet),
       802.11* (WLAN), ARP, MPLS, 802.1Q (VLAN), 802.1QinQ, LLDP, IPv4,
       IPv6, ICMPv4, ICMPv6, IGMP, TCP and UDP, including GeoIP location
       analysis. Since netsniff-ng does not establish any state or
       perform reassembly during packet dissection, its memory footprint
       is quite low, thus, making netsniff-ng quite efficient for
       offline analysis of large pcap files as well.

       Note that netsniff-ng is currently not multithreaded. However,
       this does not prevent you from starting multiple netsniff-ng
       instances that are pinned to different, non-overlapping CPUs and
       f.e. have different BPF filters attached.  Likely that at some
       point in time your harddisc might become a bottleneck assuming
       you do not rotate such pcaps in ram (and from there periodically
       scheduled move to slower medias). You can then use <b>mergecap</b>(1) to
       transform all pcap files into a single large pcap file. Thus,
       netsniff-ng then works multithreaded eventually.

       netsniff-ng can also be used to debug netlink traffic.
</pre> <h2>
OPTIONS </h2>
<pre>
       <b>-i &lt;dev|pcap|-&gt;, -d &lt;dev|pcap|-&gt;, --in &lt;dev|pcap|-&gt;, --dev</b>
       <b>&lt;dev|pcap|-&gt;</b>
              Defines an input device. This can either be a networking
              device, a pcap file or stdin (“-”). In case of a pcap
              file, the pcap type (<b>-D </b>option) is determined
              automatically by the pcap file magic. In case of stdin, it
              is assumed that the input stream is a pcap file. If the
              pcap link type is Netlink and pcap type is default format
              (usec or nsec), then each packet will be wrapped with pcap
              cooked header [2].

       <b>-o &lt;dev|pcap|dir|cfg|-&gt;, --out &lt;dev|pcap|dir|cfg|-&gt;</b>
              Defines the output device. This can either be a networking
              device, a pcap file, a folder, a <a href="trafgen.8.html">trafgen(8)</a> configuration
              file or stdout (“-”). If the output device is a pcap or
              <a href="trafgen.8.html">trafgen(8)</a> configuration file, it may include a time
              format as defined by <b>strfime</b>(3).  If used in conjunction
              with the <b>-F </b>option, each rotated file will have a unique
              time stamp. In the case of a pcap file that should not
              have the default pcap type (0xa1b2c3d4), the additional
              option <b>-T </b>must be provided. If a directory is given, then,
              instead of a single pcap file, multiple pcap files are
              generated with rotation based on maximum file size or a
              given interval (<b>-F </b>option). Optionally, sending the SIGHUP
              signal to the netsniff-ng process causes a premature
              rotation of the file. A trafgen configuration file can
              currently only be specified if the input device is a pcap
              file. To specify a pcap file as the output device, the
              file name must have “.pcap” as its extension. If stdout is
              given as a device, then a trafgen configuration will be
              written to stdout if the input device is a pcap file, or a
              pcap file if the input device is a networking device. If
              the input device is a Netlink monitor device and pcap type
              is default (usec or nsec) then each packet will be wrapped
              with pcap cooked header [2] to keep Netlink family number
              (Kuznetzov's and netsniff-ng pcap types already contain
              family number in protocol number field).

       <b>-C &lt;id&gt;, --fanout-group &lt;id&gt;</b>
              If multiple netsniff-ng instances are being started that
              all have the same packet fanout group id, then the ingress
              network traffic being captured is being distributed/load-
              balanced among these group participants. This gives a much
              better scaling than running multiple netsniff-ng processes
              without a fanout group parameter in parallel, but only
              with a BPF filter attached as a packet would otherwise
              need to be delivered to all such capturing processes,
              instead of only once to such a fanout member. Naturally,
              each fanout member can have its own BPF filters attached.

       <b>-K &lt;hash|lb|cpu|rnd|roll|qm&gt;, --fanout-type</b>
       <b>&lt;hash|lb|cpu|rnd|roll|qm&gt;</b>
              This parameter specifies the fanout discipline, in other
              words, how the captured network traffic is dispatched to
              the fanout group members. Options are to distribute
              traffic by the packet hash (“hash”), in a round-robin
              manner (“lb”), by CPU the packet arrived on (“cpu”), by
              random (“rnd”), by rolling over sockets (“roll”) which
              means if one socket's queue is full, we move on to the
              next one, or by NIC hardware queue mapping (“qm”).

       <b>-L &lt;defrag|roll&gt;, --fanout-opts &lt;defrag|roll&gt;</b>
              Defines some auxiliary fanout options to be used in
              addition to a given fanout type.  These options apply to
              any fanout type. In case of “defrag”, the kernel is being
              told to defragment packets before delivering to user
              space, and “roll” provides the same roll-over option as
              the “roll” fanout type, so that on any different fanout
              type being used (e.g. “qm”) the socket may temporarily
              roll over to the next fanout group member in case the
              original one's queue is full.

       <b>-f, --filter &lt;bpf-file|-|expr&gt;</b>
              Specifies to not dump all traffic, but to filter the
              network packet haystack.  As a filter, either a <a href="bpfc.8.html">bpfc(8)</a>
              compiled file/stdin can be passed as a parameter or a
              <a href="../man1/tcpdump.1.html">tcpdump(1)</a>-like filter expression in quotes. For details
              regarding the bpf-file have a look at <a href="bpfc.8.html">bpfc(8)</a>, for details
              regarding a <a href="../man1/tcpdump.1.html">tcpdump(1)</a>-like filter have a look at section
              “filter example” or at <b>pcap-filter</b>(7).  A filter
              expression may also be passed to netsniff-ng without
              option <b>-f </b>in case there is no subsequent option following
              after the command-line filter expression.

       <b>-t, --type &lt;type&gt;</b>
              This defines some sort of filtering mechanisms in terms of
              addressing. Possible values for type are “host” (to us),
              “broadcast” (to all), “multicast” (to group), “others”
              (promiscuous mode) or “outgoing” (from us).

       <b>-F, --interval &lt;size|time&gt;</b>
              If the output device is a folder, with “-F”, it is
              possible to define the pcap file rotation interval either
              in terms of size or time. Thus, when the interval limit
              has been reached, a new pcap file will be started. As size
              parameter, the following values are accepted
              “&lt;num&gt;KiB/MiB/GiB”; As time parameter, it can be
              “&lt;num&gt;s/sec/min/hrs”.

       <b>-J, --jumbo-support</b>
              By default, in pcap replay or redirect mode, netsniff-ng's
              ring buffer frames are a fixed size of 2048 bytes. This
              means that if you are expecting jumbo frames or even super
              jumbo frames to pass through your network, then you need
              to enable support for that by using this option. However,
              this has the disadvantage of performance degradation and a
              bigger memory footprint for the ring buffer. Note that
              this doesn't affect (pcap) capturing mode, since tpacket
              in version 3 is used!

       <b>-R, --rfraw</b>
              In case the input or output networking device is a
              wireless device, it is possible with netsniff-ng to turn
              this into monitor mode and create a mon&lt;X&gt; device that
              netsniff-ng will be listening on instead of wlan&lt;X&gt;, for
              instance.  This enables netsniff-ng to analyze, dump, or
              even replay raw 802.11 frames.

       <b>-n &lt;0|uint&gt;, --num &lt;0|uint&gt;</b>
              Process a number of packets and then exit. If the number
              of packets is 0, then this is equivalent to infinite
              packets resp. processing until interrupted.  Otherwise, a
              number given as an unsigned integer will limit processing.

       <b>-O &lt;N&gt;, --overwrite &lt;N&gt;</b>
              A number from 0 to N-1 will be used in the file name
              instead of a Unix timestamp. The previous file will be
              overwritten when number wraps around. The maximum value is
              2^32 - 1. Intended for rotating capture files when used
              with options <b>-F </b>and <b>-P</b>.

       <b>-P &lt;name&gt;, --prefix &lt;name&gt;</b>
              When dumping pcap files into a folder, a file name prefix
              can be defined with this option. If not otherwise
              specified, the default prefix is “dump-” followed by a
              Unix timestamp. Use “--prefex ""” to set filename as
              seconds since the Unix Epoch e.g. 1369179203.pcap

       <b>-T &lt;pcap-magic&gt;, --magic &lt;pcap-magic&gt;</b>
              Specify a pcap type for storage. Different pcap types with
              their various meta data capabilities are shown with option
              <b>-D</b>. If not otherwise specified, the pcap-magic 0xa1b2c3d4,
              also known as a standard tcpdump-capable pcap format, is
              used. Pcap files with swapped endianness are also
              supported.

       <b>-D, --dump-pcap-types</b>
              Dump all available pcap types with their capabilities and
              magic numbers that can be used with option “-T” to stdout
              and exit.

       <b>-B, --dump-bpf</b>
              If a Berkeley Packet Filter is given, for example via
              option “-f”, then dump the BPF disassembly to stdout
              during ring setup. This only serves for informative or
              verification purposes.

       <b>-r, --rand</b>
              If the input and output device are both networking
              devices, then this option will randomize packet order in
              the output ring buffer.

       <b>-M, --no-promisc</b>
              The networking interface will not be put into promiscuous
              mode. By default, promiscuous mode is turned on.

       <b>-N, --no-hwtimestamp</b>
              Disable taking hardware time stamps for RX packets. By
              default, if the network device supports hardware time
              stamping, the hardware time stamps will be used when
              writing packets to pcap files. This option disables this
              behavior and forces (kernel based) software time stamps to
              be used, even if hardware time stamps are available.

       <b>-A, --no-sock-mem</b>
              On startup and shutdown, netsniff-ng tries to increase
              socket read and write buffers if appropriate. This option
              will prevent netsniff-ng from doing so.

       <b>-m, --mmap</b>
              Use <a href="../man2/mmap.2.html">mmap(2)</a> as pcap file I/O. This is the default when
              replaying pcap files.

       <b>-G, --sg</b>
              Use scatter-gather as pcap file I/O. This is the default
              when capturing pcap files.

       <b>-c, --clrw</b>
              Use slower <a href="../man2/read.2.html">read(2)</a> and <a href="../man2/write.2.html">write(2)</a> I/O. This is not the
              default case anywhere, but in some situations it could be
              preferred as it has a lower latency on write-back to disc.

       <b>-S &lt;size&gt;, --ring-size &lt;size&gt;</b>
              Manually define the RX_RING resp. TX_RING size in
              “&lt;num&gt;KiB/MiB/GiB”. By default, the size is determined
              based on the network connectivity rate.

       <b>-k &lt;uint&gt;, --kernel-pull &lt;uint&gt;</b>
              Manually define the interval in micro-seconds where the
              kernel should be triggered to batch process the ring
              buffer frames. By default, it is every 10us, but it can
              manually be prolonged, for instance.

       <b>-b &lt;cpu&gt;, --bind-cpu &lt;cpu&gt;</b>
              Pin netsniff-ng to a specific CPU and also pin resp.
              migrate the NIC's IRQ CPU affinity to this CPU. This
              option should be preferred in combination with <b>-s </b>in case
              a middle to high packet rate is expected.

       <b>-u &lt;uid&gt;, --user &lt;uid&gt; resp. -g &lt;gid&gt;, --group &lt;gid&gt;</b>
              After ring setup drop privileges to a non-root user/group
              combination.

       <b>-H, --prio-high</b>
              Set this process as a high priority process in order to
              achieve a higher scheduling rate resp. CPU time. This is
              however not the default setting, since it could lead to
              starvation of other processes, for example low priority
              kernel threads.

       <b>-Q, --notouch-irq</b>
              Do not reassign the NIC's IRQ CPU affinity settings.

       <b>-s, --silent</b>
              Do not enter the packet dissector at all and do not print
              any packet information to the terminal. Just shut up and
              be silent. This option should be preferred in combination
              with pcap recording or replay, since it will not flood
              your terminal which causes a significant performance
              degradation.

       <b>-q, --less</b>
              Print a less verbose one-line information for each packet
              to the terminal.

       <b>-X, --hex</b>
              Only dump packets in hex format to the terminal.

       <b>-l, --ascii</b>
              Only display ASCII printable characters.

       <b>-U, --update</b>
              If geographical IP location is used, the built-in database
              update mechanism will be invoked to get Maxmind's latest
              database. To configure search locations for databases, the
              file /etc/netsniff-ng/geoip.conf contains possible
              addresses. Thus, to save bandwidth or for mirroring of
              Maxmind's databases (to bypass their traffic limit
              policy), different hosts or IP addresses can be placed
              into geoip.conf, separated by a newline.

       <b>-w, --cooked</b>
              Replace each frame link header with Linux "cooked" header
              [3] which keeps info about link type and protocol. It
              allows to dump and dissect frames captured from different
              link types when -i "any" was specified, for example.

       <b>-V, --verbose</b>
              Be more verbose during startup i.e. show detailed ring
              setup information.

       <b>-v, --version</b>
              Show version information and exit.

       <b>-h, --help</b>
              Show user help and exit.
</pre> <h2>
USAGE EXAMPLE </h2>
<pre>
       <b>netsniff-ng</b>
              The most simple command is to just run “netsniff-ng”. This
              will start listening on all available networking devices
              in promiscuous mode and dump the packet dissector output
              to the terminal. No files will be recorded.

       <b>netsniff-ng --in eth0 --out dump.pcap -s -T 0xa1e2cb12 -b 0 tcp</b>
       <b>or udp</b>
              Capture TCP or UDP traffic from the networking device eth0
              into the pcap file named dump.pcap, which has netsniff-ng
              specific pcap extensions (see “netsniff-ng -D” for
              capabilities). Also, do not print the content to the
              terminal and pin the process and NIC IRQ affinity to CPU
              0. The pcap write method is scatter-gather I/O.

       <b>netsniff-ng --in wlan0 --rfraw --out dump.pcap --silent --bind-</b>
       <b>cpu 0</b>
              Put the wlan0 device into monitoring mode and capture all
              raw 802.11 frames into the file dump.pcap. Do not dissect
              and print the content to the terminal and pin the process
              and NIC IRQ affinity to CPU 0. The pcap write method is
              scatter-gather I/O.

       <b>netsniff-ng --in dump.pcap --mmap --out eth0 -k1000 --silent</b>
       <b>--bind-cpu 0</b>
              Replay the pcap file dump.pcap which is read through
              <a href="../man2/mmap.2.html">mmap(2)</a> I/O and send the packets out via the eth0
              networking device. Do not dissect and print the content to
              the terminal and pin the process and NIC IRQ affinity to
              CPU 0.  Also, trigger the kernel every 1000us to traverse
              the TX_RING instead of every 10us. Note that the pcap
              magic type is detected automatically from the pcap file
              header.

       <b>netsniff-ng --in eth0 --out eth1 --silent --bind-cpu 0 --type</b>
       <b>host -r</b>
              Redirect network traffic from the networking device eth0
              to eth1 for traffic that is destined for our host, thus
              ignore broadcast, multicast and promiscuous traffic.
              Randomize the order of packets for the outgoing device and
              do not print any packet contents to the terminal. Also,
              pin the process and NIC IRQ affinity to CPU 0.

       <b>netsniff-ng --in team0 --out /opt/probe/ -s -m --interval 100MiB</b>
       <b>-b 0</b>
              Capture on an aggregated team0 networking device and dump
              packets into multiple pcap files that are split into
              100MiB each. Use <a href="../man2/mmap.2.html">mmap(2)</a> I/O as a pcap write method,
              support for super jumbo frames is built-in (does not need
              to be configured here), and do not print the captured data
              to the terminal.  Pin netsniff-ng and NIC IRQ affinity to
              CPU 0. The default pcap magic type is 0xa1b2c3d4 (tcpdump-
              capable pcap).

       <b>netsniff-ng --in vlan0 --out dump.pcap -c -u `id -u bob` -g `id</b>
       <b>-g bob`</b>
              Capture network traffic on device vlan0 into a pcap file
              called dump.pcap by using normal <a href="../man2/read.2.html">read(2)</a>, <a href="../man2/write.2.html">write(2)</a> I/O for
              the pcap file (slower but less latency). Also, after
              setting up the RX_RING for capture, drop privileges from
              root to the user and group “bob”. Invoke the packet
              dissector and print packet contents to the terminal for
              further analysis.

       <b>netsniff-ng --in any --filter http.bpf -B --ascii -V</b>
              Capture from all available networking interfaces and
              install a low-level filter that was previously compiled by
              <a href="bpfc.8.html">bpfc(8)</a> into http.bpf in order to filter HTTP traffic.
              Super jumbo frame support is automatically enabled and
              only print human readable packet data to the terminal, and
              also be more verbose during setup phase. Moreover, dump a
              BPF disassembly of http.bpf.

       <b>netsniff-ng --in dump.pcap --out dump.cfg --silent</b>
              Convert the pcap file dump.pcap into a <a href="trafgen.8.html">trafgen(8)</a>
              configuration file dump.cfg. Do not print pcap contents to
              the terminal.

       <b>netsniff-ng -i dump.pcap -f beacon.bpf -o -</b>
              Convert the pcap file dump.pcap into a <a href="trafgen.8.html">trafgen(8)</a>
              configuration file and write it to stdout. However, do not
              dump all of its content, but only the one that passes the
              low-level filter for raw 802.11 from beacon.bpf. The BPF
              engine here is invoked in user space inside of netsniff-
              ng, so Linux extensions are not available.

       <b>cat foo.pcap | netsniff-ng -i - -o -</b>
              Read a pcap file from stdin and convert it into a
              <a href="trafgen.8.html">trafgen(8)</a> configuration file to stdout.

       <b>netsniff-ng -i nlmon0 -o dump.pcap -s</b>
              Capture netlink traffic to a pcap file. This command needs
              a netlink monitoring device to be set up beforehand using
              the follwing commands using <b>ip</b>(1) from the iproute2
              utility collection:

                modprobe nlmon
                ip link add type nlmon
                ip link set nlmon0 up

              To tear down the <b>nlmon0 </b>device, use the following
              commands:

                ip link set nlmon0 down
                ip link del dev nlmon0
                rmmod nlmon

       <b>netsniff-ng --fanout-group 1 --fanout-type cpu --fanout-opts</b>
       <b>defrag --bind-cpu 0 --notouch-irq --silent --in em1 --out</b>
       <b>/var/cap/cpu0/ --interval 120sec</b>
              Start two netsniff-ng fanout instances. Both are assigned
              into the same fanout group membership and traffic is
              splitted among them by incoming cpu. Furthermore, the
              kernel is supposed to defragment possible incoming
              fragments. First instance is assigned to CPU 0 and the
              second one to CPU 1, IRQ bindings are not altered as they
              might have been adapted to this scenario by the user a-
              priori, and traffic is captured on interface em1, and
              written out in 120 second intervals as pcap files into
              /var/cap/cpu0/. Tools like mergecap(1) will be able to
              merge the cpu0/1 split back together if needed.
</pre> <h2>
CONFIG FILES </h2>
<pre>
       Files under /etc/netsniff-ng/ can be modified to extend netsniff-
       ng's functionality:

           * oui.conf - OUI/MAC vendor database
           * ether.conf - Ethernet type descriptions
           * tcp.conf - TCP port/services map
           * udp.conf - UDP port/services map
           * geoip.conf - GeoIP database mirrors
</pre> <h2>
FILTER EXAMPLE </h2>
<pre>
       netsniff-ng supports both, low-level and high-level filters that
       are attached to its <a href="../man7/packet.7.html">packet(7)</a> socket. Low-level filters are
       described in the <a href="bpfc.8.html">bpfc(8)</a> man page.

       Low-level filters can be used with netsniff-ng in the following
       way:

           1. bpfc foo &gt; bar
           2. netsniff-ng -f bar
           3. bpfc foo | netsniff-ng -i nlmon0 -f -

       Here, foo is the bpfc program that will be translated into a
       netsniff-ng readable “opcodes” file and passed to netsniff-ng
       through the -f option.

       Similarly, high-level filter can be either passed through the <b>-f</b>
       option, e.g. -f "tcp or udp" or at the end of all options without
       the “-f”.

       The filter syntax is the same as in <a href="tcpdump.8.html">tcpdump(8)</a>, which is
       described in the man page <b>pcap-filter</b>(7).  Just to quote some
       examples:

       <b>host sundown</b>
              To select all packets arriving at or departing from
              sundown.

       <b>host helios and (hot or ace)</b>
              To select traffic between helios and either hot or ace.

       <b>ip host ace and not helios</b>
              To select all IP packets between ace and any host except
              helios.

       <b>net ucb-ether</b>
              To select all traffic between local hosts and hosts at
              Berkeley.

       <b>gateway snup and (port ftp or ftp-data)</b>
              To select all FTP traffic through Internet gateway snup.

       <b>ip and not net localnet</b>
              To select traffic neither sourced from, nor destined for,
              local hosts. If you have a gateway to another network,
              this traffic should never make it onto your local network.

       <b>tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net</b>
       <b>localnet</b>
              To select the start and end packets (the SYN and FIN
              packets) of each TCP conversation that involve a non-local
              host.

       <b>tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) -</b>
       <b>((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)</b>
              To select all IPv4 HTTP packets to and from port 80, that
              is to say, print only packets that contain data, not, for
              example, SYN and FIN packets and ACK-only packets.  (IPv6
              is left as an exercise for the reader.)

       <b>gateway snup and ip[2:2] &gt; 576</b>
              To select IP packets longer than 576 bytes sent through
              gateway snup.

       <b>ether[0] &amp; 1 = 0 and ip[16] &gt;= 224</b>
              To select IP broadcast or multicast packets that were not
              sent via Ethernet broadcast or multicast.

       <b>icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply</b>
              To select all ICMP packets that are not echo requests or
              replies (that is to say, not "ping" packets).
</pre> <h2>
PCAP FORMATS: </h2>
<pre>
       netsniff-ng supports a couple of pcap formats, visible through
       ``netsniff-ng -D'':

       <b>tcpdump-capable pcap (default)</b>
              Pcap magic number is encoded as 0xa1b2c3d4 resp.
              0xd4c3b2a1. As packet meta data this format contains the
              timeval in microseconds, the original packet length and
              the captured packet length.

       <b>tcpdump-capable pcap with ns resolution</b>
              Pcap magic number is encoded as 0xa1b23c4d resp.
              0x4d3cb2a1. As packet meta data this format contains the
              timeval in nanoseconds, the original packet length and the
              captured packet length.

       <b>Alexey Kuznetzov's pcap</b>
              Pcap magic number is encoded as 0xa1b2cd34 resp.
              0x34cdb2a1. As packet meta data this format contains the
              timeval in microseconds, the original packet length, the
              captured packet length, the interface index (sll_ifindex),
              the packet's protocol (sll_protocol), and the packet type
              (sll_pkttype).

       <b>netsniff-ng pcap</b>
              Pcap magic number is encoded as 0xa1e2cb12 resp.
              0x12cbe2a1. As packet meta data this format contains the
              timeval in nanoseconds, the original packet length, the
              captured packet length, the timestamp hw/sw source, the
              interface index (sll_ifindex), the packet's protocol
              (sll_protocol), the packet type (sll_pkttype) and the
              hardware type (sll_hatype).

       For further implementation details or format support in your
       application, have a look at pcap_io.h in the netsniff-ng sources.
</pre> <h2>
NOTE </h2>
<pre>
       To avoid confusion, it should be noted that there is another
       network analyzer with a similar name, called NetSniff, that is
       unrelated to the netsniff-ng project.

       For introducing bit errors, delays with random variation and more
       while replaying pcaps, make use of <a href="tc.8.html">tc(8)</a> with its disciplines
       such as netem.

       netsniff-ng does only some basic, architecture generic tuning on
       startup. If you are considering to do high performance capturing,
       you need to carefully tune your machine, both hardware and
       software.  Simply letting netsniff-ng run without thinking about
       your underlying system might not necessarily give you the desired
       performance. Note that tuning your system is always a tradeoff
       and fine-grained balancing act (throughput versus latency). You
       should know what you are doing!

       One recommendation for software-based tuning is <b>tuned</b>(8).
       Besides that, there are many other things to consider. Just to
       throw you a few things that you might want to look at: NAPI
       networking drivers, tickless kernel, I/OAT DMA engine, Direct
       Cache Access, RAM-based file systems, multi-queues, and many more
       things. Also, you might want to read the kernel's
       Documentation/networking/scaling.txt file regarding technologies
       such as RSS, RPS, RFS, aRFS and XPS. Also check your ethtool(8)
       settings, for example regarding offloading or Ethernet pause
       frames.

       Moreover, to get a deeper understanding of netsniff-ng internals
       and how it interacts with the Linux kernel, the kernel
       documentation under Documentation/networking/{packet_mmap.txt,
       filter.txt, multiqueue.txt} might be of interest.

       How do you sniff in a switched environment? I rudely refer to
       dSniff's documentation that says:

       The easiest route is simply to impersonate the local gateway,
       stealing client traffic en route to some remote destination. Of
       course, the traffic must be forwarded by your attacking machine,
       either by enabling kernel IP forwarding or with a userland
       program that accomplishes the same (fragrouter -B1).

       Several people have reportedly destroyed connectivity on their
       LAN to the outside world by ARP spoofing the gateway, and
       forgetting to enable IP forwarding on the attacking machine. Do
       not do this. You have been warned.

       A safer option than ARP spoofing would be to use a "port mirror"
       function if your switch hardware supports it and if you have
       access to the switch.

       If you do not need to dump all possible traffic, you have to
       consider running netsniff-ng with a BPF filter for the ingress
       path. For that purpose, read the <a href="bpfc.8.html">bpfc(8)</a> man page.

       Also, to aggregate multiple NICs that you want to capture on, you
       should consider using team devices, further explained in libteam
       resp.  <b>teamd</b>(8).

       The following netsniff-ng pcap magic numbers are compatible with
       other tools, at least tcpdump or Wireshark:

           0xa1b2c3d4 (tcpdump-capable pcap)
           0xa1b23c4d (tcpdump-capable pcap with ns resolution)
           0xa1b2cd34 (Alexey Kuznetzov's pcap)

       Pcap files with different meta data endianness are supported by
       netsniff-ng as well.
</pre> <h2>
BUGS </h2>
<pre>
       When replaying pcap files, the timing information from the pcap
       packet header is currently ignored.

       Also, when replaying pcap files, demultiplexing traffic among
       multiple networking interfaces does not work. Currently, it is
       only sent via the interface that is given by the --out parameter.

       When performing traffic capture on the Ethernet interface, the
       pcap file is created and packets are received but without a
       802.1Q header. When one uses tshark, all headers are visible, but
       netsniff-ng removes 802.1Q headers. Is that normal behavior?

       Yes and no. The way VLAN headers are handled in PF_PACKET sockets
       by the kernel is somewhat “problematic” [1]. The problem in the
       Linux kernel is that some drivers already handle VLANs, others do
       not. Those who handle it can have different implementations, such
       as hardware acceleration and so on.  So in some cases the VLAN
       tag is even stripped before entering the protocol stack, in some
       cases probably not. The bottom line is that a "hack" was
       introduced in PF_PACKET so that a VLAN ID is visible in some
       helper data structure that is accessible from the RX_RING.

       Then it gets really messy in the user space to artificially put
       the VLAN header back into the right place. Not to mention the
       resulting performance implications on all of libpcap(3) tools
       since parts of the packet need to be copied for reassembly via
       memmove(3).

       A user reported the following, just to demonstrate this mess:
       some tests were made with two machines, and it seems that results
       depend on the driver ...

           AR8131:
             ethtool -k eth0 gives "rx-vlan-offload: on"
             - wireshark gets the vlan header
             - netsniff-ng doesn't get the vlan header
             ethtool -K eth0 rxvlan off
             - wireshark gets a QinQ header even though no one sent QinQ
             - netsniff-ng gets the vlan header

           RTL8111/8168B:
             ethtool -k eth0 gives "rx-vlan-offload: on"
             - wireshark gets the vlan header
             - netsniff-ng doesn't get the vlan header
             ethtool -K eth0 rxvlan off
             - wireshark gets the vlan header
             - netsniff-ng doesn't get the vlan header

       Even if we agreed on doing the same workaround as libpcap, we
       still will not be able to see QinQ, for instance, due to the fact
       that only one VLAN tag is stored in the kernel helper data
       structure. We think that there should be a good consensus on the
       kernel space side about what gets transferred to userland first.

       Update (28.11.2012): the Linux kernel and also <a href="bpfc.8.html">bpfc(8)</a> has built-
       in support for hardware accelerated VLAN filtering, even though
       tags might not be visible in the payload itself as reported here.
       However, the filtering for VLANs works reliable if your NIC
       supports it. See <a href="bpfc.8.html">bpfc(8)</a> for an example.

          [1]
       <a href="http://lkml.indiana.edu/hypermail/linux/kernel/0710.3/3816.html">http://lkml.indiana.edu/hypermail/linux/kernel/0710.3/3816.html</a>
          [2] <a href="http://www.tcpdump.org/linktypes/LINKTYPE_NETLINK.html">http://www.tcpdump.org/linktypes/LINKTYPE_NETLINK.html</a>
          [3] <a href="http://www.tcpdump.org/linktypes/LINKTYPE_LINUX_SLL.html">http://www.tcpdump.org/linktypes/LINKTYPE_LINUX_SLL.html</a>
</pre> <h2>
LEGAL </h2>
<pre>
       netsniff-ng is licensed under the GNU GPL version 2.0.
</pre> <h2>
HISTORY </h2>
<pre>
       <b>netsniff-ng </b>was originally written for the netsniff-ng toolkit by
       Daniel Borkmann. Bigger contributions were made by Emmanuel
       Roullit, Markus Amend, Tobias Klauser and Christoph Jaeger. It is
       currently maintained by Tobias Klauser &lt;tklauser@distanz.ch&gt; and
       Daniel Borkmann &lt;dborkma@tik.ee.ethz.ch&gt;.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="trafgen.8.html">trafgen(8)</a>, <a href="mausezahn.8.html">mausezahn(8)</a>, <a href="ifpps.8.html">ifpps(8)</a>, <a href="bpfc.8.html">bpfc(8)</a>, <a href="flowtop.8.html">flowtop(8)</a>,
       <a href="astraceroute.8.html">astraceroute(8)</a>, <a href="curvetun.8.html">curvetun(8)</a>
</pre> <h2>
AUTHOR </h2>
<pre>
       Manpage was written by Daniel Borkmann.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the Linux netsniff-ng toolkit project. A
       description of the project, and information about reporting bugs,
       can be found at <a href="http://netsniff-ng.org/">http://netsniff-ng.org/</a>.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>netsniff-ng</i> (a free Linux networking
       toolkit) project.  Information about the project can be found at
       ⟨<a href="http://netsniff-ng.org/">http://netsniff-ng.org/</a>⟩.  If you have a bug report for this
       manual page, send it to netsniff-ng@googlegroups.com.  This page
       was obtained from the project's upstream Git repository
       ⟨<a href="https://github.com/netsniff-ng/netsniff-ng">https://github.com/netsniff-ng/netsniff-ng</a>⟩ on 2024-06-14.  (At
       that time, the date of the most recent commit that was found in
       the repository was 2023-02-01.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux                         03 March 2013               <i>NETSNIFF-NG</i>(8)</span>
</pre>  <p>Pages that refer to this page: <a href="astraceroute.8.html">astraceroute(8)</a>, <a href="bpfc.8.html">bpfc(8)</a>, <a href="curvetun.8.html">curvetun(8)</a>, <a href="flowtop.8.html">flowtop(8)</a>, <a href="ifpps.8.html">ifpps(8)</a>, <a href="mausezahn.8.html">mausezahn(8)</a>, <a href="trafgen.8.html">trafgen(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man8/netsniff-ng.8.html" class="_attribution-link">https://man7.org/linux/man-pages/man8/netsniff-ng.8.html</a>
  </p>
</div>
