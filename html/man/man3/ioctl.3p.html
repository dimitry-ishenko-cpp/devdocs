<h1>ioctl(3p) — Linux manual page</h1>   <pre>
<span class="headline"><i>IOCTL</i>(3P)               POSIX Programmer's Manual              <i>IOCTL</i>(3P)</span>
</pre> <h2>
PROLOG </h2>
<pre>
       This manual page is part of the POSIX Programmer's Manual.  The
       Linux implementation of this interface may differ (consult the
       corresponding Linux manual page for details of Linux behavior),
       or the interface may not be implemented on Linux.
</pre> <h2>
NAME </h2>
<pre>
       ioctl — control a STREAMS device (<b>STREAMS</b>)
</pre> <h2>
SYNOPSIS </h2>
<pre>
       #include &lt;stropts.h&gt;

       int ioctl(int <i>fildes</i>, int <i>request</i>, ... /* arg */);
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <i>ioctl</i>() function shall perform a variety of control functions
       on STREAMS devices. For non-STREAMS devices, the functions
       performed by this call are unspecified. The <i>request</i> argument and
       an optional third argument (with varying type) shall be passed to
       and interpreted by the appropriate part of the STREAM associated
       with <i>fildes</i>.

       The <i>fildes</i> argument is an open file descriptor that refers to a
       device.

       The <i>request</i> argument selects the control function to be performed
       and shall depend on the STREAMS device being addressed.

       The <i>arg</i> argument represents additional information that is needed
       by this specific STREAMS device to perform the requested
       function. The type of <i>arg</i> depends upon the particular control
       request, but it shall be either an integer or a pointer to a
       device-specific data structure.

       The <i>ioctl</i>() commands applicable to STREAMS, their arguments, and
       error conditions that apply to each individual command are
       described below.

       The following <i>ioctl</i>() commands, with error values indicated, are
       applicable to all STREAMS files:

       I_PUSH      Pushes the module whose name is pointed to by <i>arg</i>
                   onto the top of the current STREAM, just below the
                   STREAM head. It then calls the <i>open</i>() function of the
                   newly-pushed module.

                   The <i>ioctl</i>() function with the I_PUSH command shall
                   fail if:

                   <b>EINVAL </b>Invalid module name.

                   <b>ENXIO  </b>Open function of new module failed.

                   <b>ENXIO  </b>Hangup received on <i>fildes</i>.

       I_POP       Removes the module just below the STREAM head of the
                   STREAM pointed to by <i>fildes</i>.  The <i>arg</i> argument should
                   be 0 in an I_POP request.

                   The <i>ioctl</i>() function with the I_POP command shall
                   fail if:

                   <b>EINVAL </b>No module present in the STREAM.

                   <b>ENXIO  </b>Hangup received on <i>fildes</i>.

       I_LOOK      Retrieves the name of the module just below the
                   STREAM head of the STREAM pointed to by <i>fildes</i>, and
                   places it in a character string pointed to by <i>arg</i>.
                   The buffer pointed to by <i>arg</i> should be at least
                   FMNAMESZ+1 bytes long, where FMNAMESZ is defined in
                   <i>&lt;stropts.h&gt;</i>.

                   The <i>ioctl</i>() function with the I_LOOK command shall
                   fail if:

                   <b>EINVAL </b>No module present in the STREAM.

       I_FLUSH     Flushes read and/or write queues, depending on the
                   value of <i>arg</i>.  Valid <i>arg</i> values are:

                   FLUSHR      Flush all read queues.

                   FLUSHW      Flush all write queues.

                   FLUSHRW     Flush all read and all write queues.

                   The <i>ioctl</i>() function with the I_FLUSH command shall
                   fail if:

                   <b>EINVAL </b>Invalid <i>arg</i> value.

                   <b>EAGAIN </b>or <b>ENOSR</b>
                          Unable to allocate buffers for flush message.

                   <b>ENXIO  </b>Hangup received on <i>fildes</i>.

       I_FLUSHBAND Flushes a particular band of messages. The <i>arg</i>
                   argument points to a <b>bandinfo </b>structure. The <i>bi_flag</i>
                   member may be one of FLUSHR, FLUSHW, or FLUSHRW as
                   described above. The <i>bi_pri</i> member determines the
                   priority band to be flushed.

       I_SETSIG    Requests that the STREAMS implementation send the
                   SIGPOLL signal to the calling process when a
                   particular event has occurred on the STREAM
                   associated with <i>fildes</i>.  I_SETSIG supports an
                   asynchronous processing capability in STREAMS. The
                   value of <i>arg</i> is a bitmask that specifies the events
                   for which the process should be signaled. It is the
                   bitwise-inclusive OR of any combination of the
                   following constants:

                   S_RDNORM    A normal (priority band set to 0) message
                               has arrived at the head of a STREAM head
                               read queue. A signal shall be generated
                               even if the message is of zero length.

                   S_RDBAND    A message with a non-zero priority band
                               has arrived at the head of a STREAM head
                               read queue. A signal shall be generated
                               even if the message is of zero length.

                   S_INPUT     A message, other than a high-priority
                               message, has arrived at the head of a
                               STREAM head read queue. A signal shall be
                               generated even if the message is of zero
                               length.

                   S_HIPRI     A high-priority message is present on a
                               STREAM head read queue. A signal shall be
                               generated even if the message is of zero
                               length.

                   S_OUTPUT    The write queue for normal data (priority
                               band 0) just below the STREAM head is no
                               longer full. This notifies the process
                               that there is room on the queue for
                               sending (or writing) normal data
                               downstream.

                   S_WRNORM    Equivalent to S_OUTPUT.

                   S_WRBAND    The write queue for a non-zero priority
                               band just below the STREAM head is no
                               longer full. This notifies the process
                               that there is room on the queue for
                               sending (or writing) priority data
                               downstream.

                   S_MSG       A STREAMS signal message that contains
                               the SIGPOLL signal has reached the front
                               of the STREAM head read queue.

                   S_ERROR     Notification of an error condition has
                               reached the STREAM head.

                   S_HANGUP    Notification of a hangup has reached the
                               STREAM head.

                   S_BANDURG   When used in conjunction with S_RDBAND,
                               SIGURG is generated instead of SIGPOLL
                               when a priority message reaches the front
                               of the STREAM head read queue.

                   If <i>arg</i> is 0, the calling process shall be
                   unregistered and shall not receive further SIGPOLL
                   signals for the stream associated with <i>fildes</i>.

                   Processes that wish to receive SIGPOLL signals shall
                   ensure that they explicitly register to receive them
                   using I_SETSIG. If several processes register to
                   receive this signal for the same event on the same
                   STREAM, each process shall be signaled when the event
                   occurs.

                   The <i>ioctl</i>() function with the I_SETSIG command shall
                   fail if:

                   <b>EINVAL </b>The value of <i>arg</i> is invalid.

                   <b>EINVAL </b>The value of <i>arg</i> is 0 and the calling process
                          is not registered to receive the SIGPOLL
                          signal.

                   <b>EAGAIN </b>There were insufficient resources to store the
                          signal request.

       I_GETSIG    Returns the events for which the calling process is
                   currently registered to be sent a SIGPOLL signal. The
                   events are returned as a bitmask in an <b>int </b>pointed to
                   by <i>arg</i>, where the events are those specified in the
                   description of I_SETSIG above.

                   The <i>ioctl</i>() function with the I_GETSIG command shall
                   fail if:

                   <b>EINVAL </b>Process is not registered to receive the
                          SIGPOLL signal.

       I_FIND      Compares the names of all modules currently present
                   in the STREAM to the name pointed to by <i>arg</i>, and
                   returns 1 if the named module is present in the
                   STREAM, or returns 0 if the named module is not
                   present.

                   The <i>ioctl</i>() function with the I_FIND command shall
                   fail if:

                   <b>EINVAL </b><i>arg</i> does not contain a valid module name.

       I_PEEK      Retrieves the information in the first message on the
                   STREAM head read queue without taking the message off
                   the queue. It is analogous to <i>getmsg</i>() except that
                   this command does not remove the message from the
                   queue.  The <i>arg</i> argument points to a <b>strpeek</b>
                   structure.

                   The application shall ensure that the <i>maxlen</i> member
                   in the <b>ctlbuf </b>and <b>databuf strbuf </b>structures is set to
                   the number of bytes of control information and/or
                   data information, respectively, to retrieve. The
                   <i>flags</i> member may be marked RS_HIPRI or 0, as
                   described by <i>getmsg</i>().  If the process sets <i>flags</i> to
                   RS_HIPRI, for example, I_PEEK shall only look for a
                   high-priority message on the STREAM head read queue.

                   I_PEEK returns 1 if a message was retrieved, and
                   returns 0 if no message was found on the STREAM head
                   read queue, or if the RS_HIPRI flag was set in <i>flags</i>
                   and a high-priority message was not present on the
                   STREAM head read queue. It does not wait for a
                   message to arrive. On return, <b>ctlbuf </b>specifies
                   information in the control buffer, <b>databuf </b>specifies
                   information in the data buffer, and <i>flags</i> contains
                   the value RS_HIPRI or 0.

       I_SRDOPT    Sets the read mode using the value of the argument
                   <i>arg</i>.  Read modes are described in <i>read</i>().  Valid <i>arg</i>
                   flags are:

                   RNORM       Byte-stream mode, the default.

                   RMSGD       Message-discard mode.

                   RMSGN       Message-nondiscard mode.

                   The bitwise-inclusive OR of RMSGD and RMSGN shall
                   return <b>[EINVAL]</b>.  The bitwise-inclusive OR of RNORM
                   and either RMSGD or RMSGN shall result in the other
                   flag overriding RNORM which is the default.

                   In addition, treatment of control messages by the
                   STREAM head may be changed by setting any of the
                   following flags in <i>arg</i>:

                   RPROTNORM   Fail <i>read</i>() with <b>[EBADMSG] </b>if a message
                               containing a control part is at the front
                               of the STREAM head read queue.

                   RPROTDAT    Deliver the control part of a message as
                               data when a process issues a <i>read</i>().

                   RPROTDIS    Discard the control part of a message,
                               delivering any data portion, when a
                               process issues a <i>read</i>().

                   The <i>ioctl</i>() function with the I_SRDOPT command shall
                   fail if:

                   <b>EINVAL </b>The <i>arg</i> argument is not valid.

       I_GRDOPT    Returns the current read mode setting, as described
                   above, in an <b>int </b>pointed to by the argument <i>arg</i>.
                   Read modes are described in <i>read</i>().

       I_NREAD     Counts the number of data bytes in the data part of
                   the first message on the STREAM head read queue and
                   places this value in the <b>int </b>pointed to by <i>arg</i>.  The
                   return value for the command shall be the number of
                   messages on the STREAM head read queue. For example,
                   if 0 is returned in <i>arg</i>, but the <i>ioctl</i>() return value
                   is greater than 0, this indicates that a zero-length
                   message is next on the queue.

       I_FDINSERT  Creates a message from specified buffer(s), adds
                   information about another STREAM, and sends the
                   message downstream. The message contains a control
                   part and an optional data part. The data and control
                   parts to be sent are distinguished by placement in
                   separate buffers, as described below. The <i>arg</i>
                   argument points to a <b>strfdinsert </b>structure.

                   The application shall ensure that the <i>len</i> member in
                   the <b>ctlbuf strbuf </b>structure is set to the size of a
                   <b>t_uscalar_t </b>plus the number of bytes of control
                   information to be sent with the message. The <i>fildes</i>
                   member specifies the file descriptor of the other
                   STREAM, and the <i>offset</i> member, which must be suitably
                   aligned for use as a <b>t_uscalar_t</b>, specifies the
                   offset from the start of the control buffer where
                   I_FDINSERT shall store a <b>t_uscalar_t </b>whose
                   interpretation is specific to the STREAM end. The
                   application shall ensure that the <i>len</i> member in the
                   <b>databuf strbuf </b>structure is set to the number of
                   bytes of data information to be sent with the
                   message, or to 0 if no data part is to be sent.

                   The <i>flags</i> member specifies the type of message to be
                   created. A normal message is created if <i>flags</i> is set
                   to 0, and a high-priority message is created if <i>flags</i>
                   is set to RS_HIPRI. For non-priority messages,
                   I_FDINSERT shall block if the STREAM write queue is
                   full due to internal flow control conditions.  For
                   priority messages, I_FDINSERT does not block on this
                   condition. For non-priority messages, I_FDINSERT does
                   not block when the write queue is full and O_NONBLOCK
                   is set. Instead, it fails and sets <i><a href="errno.3.html">errno</a></i> to <b>[EAGAIN]</b>.

                   I_FDINSERT also blocks, unless prevented by lack of
                   internal resources, waiting for the availability of
                   message blocks in the STREAM, regardless of priority
                   or whether O_NONBLOCK has been specified. No partial
                   message is sent.

                   The <i>ioctl</i>() function with the I_FDINSERT command
                   shall fail if:

                   <b>EAGAIN </b>A non-priority message is specified, the
                          O_NONBLOCK flag is set, and the STREAM write
                          queue is full due to internal flow control
                          conditions.

                   <b>EAGAIN </b>or <b>ENOSR</b>
                          Buffers cannot be allocated for the message
                          that is to be created.

                   <b>EINVAL </b>One of the following:

                               --  The <i>fildes</i> member of the <b>strfdinsert</b>
                                   structure is not a valid, open STREAM
                                   file descriptor.

                               --  The size of a <b>t_uscalar_t </b>plus <i>offset</i>
                                   is greater than the <i>len</i> member for
                                   the buffer specified through <b>ctlbuf</b>.

                               --  The <i>offset</i> member does not specify a
                                   properly-aligned location in the data
                                   buffer.

                               --  An undefined value is stored in
                                   <i>flags</i>.

                   <b>ENXIO  </b>Hangup received on the STREAM identified by
                          either the <i>fildes</i> argument or the <i>fildes</i>
                          member of the <b>strfdinsert </b>structure.

                   <b>ERANGE </b>The <i>len</i> member for the buffer specified
                          through <b>databuf </b>does not fall within the range
                          specified by the maximum and minimum packet
                          sizes of the topmost STREAM module; or the <i>len</i>
                          member for the buffer specified through
                          <b>databuf </b>is larger than the maximum configured
                          size of the data part of a message; or the <i>len</i>
                          member for the buffer specified through <b>ctlbuf</b>
                          is larger than the maximum configured size of
                          the control part of a message.

       I_STR       Constructs an internal STREAMS <i>ioctl</i>() message from
                   the data pointed to by <i>arg</i>, and sends that message
                   downstream.

                   This mechanism is provided to send <i>ioctl</i>() requests
                   to downstream modules and drivers. It allows
                   information to be sent with <i>ioctl</i>(), and returns to
                   the process any information sent upstream by the
                   downstream recipient. I_STR shall block until the
                   system responds with either a positive or negative
                   acknowledgement message, or until the request times
                   out after some period of time. If the request times
                   out, it shall fail with <i><a href="errno.3.html">errno</a></i> set to <b>[ETIME]</b>.

                   At most, one I_STR can be active on a STREAM. Further
                   I_STR calls shall block until the active I_STR
                   completes at the STREAM head. The default timeout
                   interval for these requests is 15 seconds. The
                   O_NONBLOCK flag has no effect on this call.

                   To send requests downstream, the application shall
                   ensure that <i>arg</i> points to a <b>strioctl </b>structure.

                   The <i>ic_cmd</i> member is the internal <i>ioctl</i>() command
                   intended for a downstream module or driver and
                   <i>ic_timout</i> is the number of seconds (-1=infinite,
                   0=use implementation-defined timeout interval, &gt;0=as
                   specified) an I_STR request shall wait for
                   acknowledgement before timing out.  <i>ic_len</i> is the
                   number of bytes in the data argument, and <i>ic_dp</i> is a
                   pointer to the data argument. The <i>ic_len</i> member has
                   two uses: on input, it contains the length of the
                   data argument passed in, and on return from the
                   command, it contains the number of bytes being
                   returned to the process (the buffer pointed to by
                   <i>ic_dp</i> should be large enough to contain the maximum
                   amount of data that any module or the driver in the
                   STREAM can return).

                   The STREAM head shall convert the information pointed
                   to by the <b>strioctl </b>structure to an internal <i>ioctl</i>()
                   command message and send it downstream.

                   The <i>ioctl</i>() function with the I_STR command shall
                   fail if:

                   <b>EAGAIN </b>or <b>ENOSR</b>
                          Unable to allocate buffers for the <i>ioctl</i>()
                          message.

                   <b>EINVAL </b>The <i>ic_len</i> member is less than 0 or larger
                          than the maximum configured size of the data
                          part of a message, or <i>ic_timout</i> is less than
                          -1.

                   <b>ENXIO  </b>Hangup received on <i>fildes</i>.

                   <b>ETIME  </b>A downstream <i>ioctl</i>() timed out before
                          acknowledgement was received.

                   An I_STR can also fail while waiting for an
                   acknowledgement if a message indicating an error or a
                   hangup is received at the STREAM head.  In addition,
                   an error code can be returned in the positive or
                   negative acknowledgement message, in the event the
                   <i>ioctl</i>() command sent downstream fails. For these
                   cases, I_STR shall fail with <i><a href="errno.3.html">errno</a></i> set to the value
                   in the message.

       I_SWROPT    Sets the write mode using the value of the argument
                   <i>arg</i>.  Valid bit settings for <i>arg</i> are:

                   SNDZERO     Send a zero-length message downstream
                               when a <i>write</i>() of 0 bytes occurs. To not
                               send a zero-length message when a <i>write</i>()
                               of 0 bytes occurs, the application shall
                               ensure that this bit is not set in <i>arg</i>
                               (for example, <i>arg</i> would be set to 0).

                   The <i>ioctl</i>() function with the I_SWROPT command shall
                   fail if:

                   <b>EINVAL </b><i>arg</i> is not the above value.

       I_GWROPT    Returns the current write mode setting, as described
                   above, in the <b>int </b>that is pointed to by the argument
                   <i>arg</i>.

       I_SENDFD    Creates a new reference to the open file description
                   associated with the file descriptor <i>arg</i>, and writes a
                   message on the STREAMS-based pipe <i>fildes</i> containing
                   this reference, together with the user ID and group
                   ID of the calling process.

                   The <i>ioctl</i>() function with the I_SENDFD command shall
                   fail if:

                   <b>EAGAIN </b>The sending STREAM is unable to allocate a
                          message block to contain the file pointer; or
                          the read queue of the receiving STREAM head is
                          full and cannot accept the message sent by
                          I_SENDFD.

                   <b>EBADF  </b>The <i>arg</i> argument is not a valid, open file
                          descriptor.

                   <b>EINVAL </b>The <i>fildes</i> argument is not connected to a
                          STREAM pipe.

                   <b>ENXIO  </b>Hangup received on <i>fildes</i>.

                   The <i>ioctl</i>() function with the I_SENDFD command may
                   fail if:

                   <b>EINVAL </b>The <i>arg</i> argument is equal to the <i>fildes</i>
                          argument.

       I_RECVFD    Retrieves the reference to an open file description
                   from a message written to a STREAMS-based pipe using
                   the I_SENDFD command, and allocates a new file
                   descriptor in the calling process that refers to this
                   open file description. The <i>arg</i> argument is a pointer
                   to a <b>strrecvfd </b>data structure as defined in
                   <i>&lt;stropts.h&gt;</i>.

                   The <i>fd</i> member is a file descriptor. The <i>uid</i> and <i>gid</i>
                   members are the effective user ID and effective group
                   ID, respectively, of the sending process.

                   If O_NONBLOCK is not set, I_RECVFD shall block until
                   a message is present at the STREAM head. If
                   O_NONBLOCK is set, I_RECVFD shall fail with <i><a href="errno.3.html">errno</a></i> set
                   to <b>[EAGAIN] </b>if no message is present at the STREAM
                   head.

                   If the message at the STREAM head is a message sent
                   by an I_SENDFD, a new file descriptor shall be
                   allocated for the open file descriptor referenced in
                   the message. The new file descriptor is placed in the
                   <i>fd</i> member of the <b>strrecvfd </b>structure pointed to by
                   <i>arg</i>.

                   The <i>ioctl</i>() function with the I_RECVFD command shall
                   fail if:

                   <b>EAGAIN </b>A message is not present at the STREAM head
                          read queue and the O_NONBLOCK flag is set.

                   <b>EBADMSG</b>
                          The message at the STREAM head read queue is
                          not a message containing a passed file
                          descriptor.

                   <b>EMFILE </b>All file descriptors available to the process
                          are currently open.

                   <b>ENXIO  </b>Hangup received on <i>fildes</i>.

       I_LIST      Allows the process to list all the module names on
                   the STREAM, up to and including the topmost driver
                   name. If <i>arg</i> is a null pointer, the return value
                   shall be the number of modules, including the driver,
                   that are on the STREAM pointed to by <i>fildes</i>.  This
                   lets the process allocate enough space for the module
                   names.  Otherwise, it should point to a <b>str_list</b>
                   structure.

                   The <i>sl_nmods</i> member indicates the number of entries
                   the process has allocated in the array. Upon return,
                   the <i>sl_modlist</i> member of the <b>str_list </b>structure shall
                   contain the list of module names, and the number of
                   entries that have been filled into the <i>sl_modlist</i>
                   array is found in the <i>sl_nmods</i> member (the number
                   includes the number of modules including the driver).
                   The return value from <i>ioctl</i>() shall be 0. The entries
                   are filled in starting at the top of the STREAM and
                   continuing downstream until either the end of the
                   STREAM is reached, or the number of requested modules
                   (<i>sl_nmods</i>) is satisfied.

                   The <i>ioctl</i>() function with the I_LIST command shall
                   fail if:

                   <b>EINVAL </b>The <i>sl_nmods</i> member is less than 1.

                   <b>EAGAIN </b>or <b>ENOSR</b>
                          Unable to allocate buffers.

       I_ATMARK    Allows the process to see if the message at the head
                   of the STREAM head read queue is marked by some
                   module downstream. The <i>arg</i> argument determines how
                   the checking is done when there may be multiple
                   marked messages on the STREAM head read queue. It may
                   take on the following values:

                   ANYMARK     Check if the message is marked.

                   LASTMARK    Check if the message is the last one
                               marked on the queue.

                   The bitwise-inclusive OR of the flags ANYMARK and
                   LASTMARK is permitted.

                   The return value shall be 1 if the mark condition is
                   satisfied; otherwise, the value shall be 0.

                   The <i>ioctl</i>() function with the I_ATMARK command shall
                   fail if:

                   <b>EINVAL </b>Invalid <i>arg</i> value.

       I_CKBAND    Checks if the message of a given priority band exists
                   on the STREAM head read queue. This shall return 1 if
                   a message of the given priority exists, 0 if no such
                   message exists, or -1 on error.  <i>arg</i> should be of
                   type <b>int</b>.

                   The <i>ioctl</i>() function with the I_CKBAND command shall
                   fail if:

                   <b>EINVAL </b>Invalid <i>arg</i> value.

       I_GETBAND   Returns the priority band of the first message on the
                   STREAM head read queue in the integer referenced by
                   <i>arg</i>.

                   The <i>ioctl</i>() function with the I_GETBAND command shall
                   fail if:

                   <b>ENODATA</b>
                          No message on the STREAM head read queue.

       I_CANPUT    Checks if a certain band is writable.  <i>arg</i> is set to
                   the priority band in question. The return value shall
                   be 0 if the band is flow-controlled, 1 if the band is
                   writable, or -1 on error.

                   The <i>ioctl</i>() function with the I_CANPUT command shall
                   fail if:

                   <b>EINVAL </b>Invalid <i>arg</i> value.

       I_SETCLTIME This request allows the process to set the time the
                   STREAM head shall delay when a STREAM is closing and
                   there is data on the write queues.  Before closing
                   each module or driver, if there is data on its write
                   queue, the STREAM head shall delay for the specified
                   amount of time to allow the data to drain. If, after
                   the delay, data is still present, it shall be
                   flushed. The <i>arg</i> argument is a pointer to an integer
                   specifying the number of milliseconds to delay,
                   rounded up to the nearest valid value. If I_SETCLTIME
                   is not performed on a STREAM, an implementation-
                   defined default timeout interval is used.

                   The <i>ioctl</i>() function with the I_SETCLTIME command
                   shall fail if:

                   <b>EINVAL </b>Invalid <i>arg</i> value.

       I_GETCLTIME Returns the close time delay in the integer pointed
                   to by <i>arg</i>.

   <b>Multiplexed STREAMS Configurations</b>
       The following commands are used for connecting and disconnecting
       multiplexed STREAMS configurations. These commands use an
       implementation-defined default timeout interval.

       I_LINK      Connects two STREAMs, where <i>fildes</i> is the file
                   descriptor of the STREAM connected to the
                   multiplexing driver, and <i>arg</i> is the file descriptor
                   of the STREAM connected to another driver. The STREAM
                   designated by <i>arg</i> is connected below the multiplexing
                   driver. I_LINK requires the multiplexing driver to
                   send an acknowledgement message to the STREAM head
                   regarding the connection. This call shall return a
                   multiplexer ID number (an identifier used to
                   disconnect the multiplexer; see I_UNLINK) on success,
                   and -1 on failure.

                   The <i>ioctl</i>() function with the I_LINK command shall
                   fail if:

                   <b>ENXIO  </b>Hangup received on <i>fildes</i>.

                   <b>ETIME  </b>Timeout before acknowledgement message was
                          received at STREAM head.

                   <b>EAGAIN </b>or <b>ENOSR</b>
                          Unable to allocate STREAMS storage to perform
                          the I_LINK.

                   <b>EBADF  </b>The <i>arg</i> argument is not a valid, open file
                          descriptor.

                   <b>EINVAL </b>The <i>fildes</i> argument does not support
                          multiplexing; or <i>arg</i> is not a STREAM or is
                          already connected downstream from a
                          multiplexer; or the specified I_LINK operation
                          would connect the STREAM head in more than one
                          place in the multiplexed STREAM.

                   An I_LINK can also fail while waiting for the
                   multiplexing driver to acknowledge the request, if a
                   message indicating an error or a hangup is received
                   at the STREAM head of <i>fildes</i>.  In addition, an error
                   code can be returned in the positive or negative
                   acknowledgement message. For these cases, I_LINK
                   fails with <i><a href="errno.3.html">errno</a></i> set to the value in the message.

       I_UNLINK    Disconnects the two STREAMs specified by <i>fildes</i> and
                   <i>arg</i>.  <i>fildes</i> is the file descriptor of the STREAM
                   connected to the multiplexing driver. The <i>arg</i>
                   argument is the multiplexer ID number that was
                   returned by the I_LINK <i>ioctl</i>() command when a STREAM
                   was connected downstream from the multiplexing
                   driver. If <i>arg</i> is MUXID_ALL, then all STREAMs that
                   were connected to <i>fildes</i> shall be disconnected. As in
                   I_LINK, this command requires acknowledgement.

                   The <i>ioctl</i>() function with the I_UNLINK command shall
                   fail if:

                   <b>ENXIO  </b>Hangup received on <i>fildes</i>.

                   <b>ETIME  </b>Timeout before acknowledgement message was
                          received at STREAM head.

                   <b>EAGAIN </b>or <b>ENOSR</b>
                          Unable to allocate buffers for the
                          acknowledgement message.

                   <b>EINVAL </b>Invalid multiplexer ID number.

                   An I_UNLINK can also fail while waiting for the
                   multiplexing driver to acknowledge the request if a
                   message indicating an error or a hangup is received
                   at the STREAM head of <i>fildes</i>.  In addition, an error
                   code can be returned in the positive or negative
                   acknowledgement message. For these cases, I_UNLINK
                   shall fail with <i><a href="errno.3.html">errno</a></i> set to the value in the
                   message.

       I_PLINK     Creates a <i>persistent connection</i> between two STREAMs,
                   where <i>fildes</i> is the file descriptor of the STREAM
                   connected to the multiplexing driver, and <i>arg</i> is the
                   file descriptor of the STREAM connected to another
                   driver. This call shall create a persistent
                   connection which can exist even if the file
                   descriptor <i>fildes</i> associated with the upper STREAM to
                   the multiplexing driver is closed.  The STREAM
                   designated by <i>arg</i> gets connected via a persistent
                   connection below the multiplexing driver. I_PLINK
                   requires the multiplexing driver to send an
                   acknowledgement message to the STREAM head. This call
                   shall return a multiplexer ID number (an identifier
                   that may be used to disconnect the multiplexer; see
                   I_PUNLINK) on success, and -1 on failure.

                   The <i>ioctl</i>() function with the I_PLINK command shall
                   fail if:

                   <b>ENXIO  </b>Hangup received on <i>fildes</i>.

                   <b>ETIME  </b>Timeout before acknowledgement message was
                          received at STREAM head.

                   <b>EAGAIN </b>or <b>ENOSR</b>
                          Unable to allocate STREAMS storage to perform
                          the I_PLINK.

                   <b>EBADF  </b>The <i>arg</i> argument is not a valid, open file
                          descriptor.

                   <b>EINVAL </b>The <i>fildes</i> argument does not support
                          multiplexing; or <i>arg</i> is not a STREAM or is
                          already connected downstream from a
                          multiplexer; or the specified I_PLINK
                          operation would connect the STREAM head in
                          more than one place in the multiplexed STREAM.

                   An I_PLINK can also fail while waiting for the
                   multiplexing driver to acknowledge the request, if a
                   message indicating an error or a hangup is received
                   at the STREAM head of <i>fildes</i>.  In addition, an error
                   code can be returned in the positive or negative
                   acknowledgement message. For these cases, I_PLINK
                   shall fail with <i><a href="errno.3.html">errno</a></i> set to the value in the
                   message.

       I_PUNLINK   Disconnects the two STREAMs specified by <i>fildes</i> and
                   <i>arg</i> from a persistent connection. The <i>fildes</i> argument
                   is the file descriptor of the STREAM connected to the
                   multiplexing driver. The <i>arg</i> argument is the
                   multiplexer ID number that was returned by the
                   I_PLINK <i>ioctl</i>() command when a STREAM was connected
                   downstream from the multiplexing driver. If <i>arg</i> is
                   MUXID_ALL, then all STREAMs which are persistent
                   connections to <i>fildes</i> shall be disconnected. As in
                   I_PLINK, this command requires the multiplexing
                   driver to acknowledge the request.

                   The <i>ioctl</i>() function with the I_PUNLINK command shall
                   fail if:

                   <b>ENXIO  </b>Hangup received on <i>fildes</i>.

                   <b>ETIME  </b>Timeout before acknowledgement message was
                          received at STREAM head.

                   <b>EAGAIN </b>or <b>ENOSR</b>
                          Unable to allocate buffers for the
                          acknowledgement message.

                   <b>EINVAL </b>Invalid multiplexer ID number.

                   An I_PUNLINK can also fail while waiting for the
                   multiplexing driver to acknowledge the request if a
                   message indicating an error or a hangup is received
                   at the STREAM head of <i>fildes</i>.  In addition, an error
                   code can be returned in the positive or negative
                   acknowledgement message. For these cases, I_PUNLINK
                   shall fail with <i><a href="errno.3.html">errno</a></i> set to the value in the
                   message.
</pre> <h2>
RETURN VALUE </h2>
<pre>
       Upon successful completion, <i>ioctl</i>() shall return a value other
       than -1 that depends upon the STREAMS device control function.
       Otherwise, it shall return -1 and set <i><a href="errno.3.html">errno</a></i> to indicate the
       error.
</pre> <h2>
ERRORS </h2>
<pre>
       Under the following general conditions, <i>ioctl</i>() shall fail if:

       <b>EBADF  </b>The <i>fildes</i> argument is not a valid open file descriptor.

       <b>EINTR  </b>A signal was caught during the <i>ioctl</i>() operation.

       <b>EINVAL </b>The STREAM or multiplexer referenced by <i>fildes</i> is linked
              (directly or indirectly) downstream from a multiplexer.

       If an underlying device driver detects an error, then <i>ioctl</i>()
       shall fail if:

       <b>EINVAL </b>The <i>request</i> or <i>arg</i> argument is not valid for this device.

       <b>EIO    </b>Some physical I/O error has occurred.

       <b>ENOTTY </b>The file associated with the <i>fildes</i> argument is not a
              STREAMS device that accepts control functions.

       <b>ENXIO  </b>The <i>request</i> and <i>arg</i> arguments are valid for this device
              driver, but the service requested cannot be performed on
              this particular sub-device.

       <b>ENODEV </b>The <i>fildes</i> argument refers to a valid STREAMS device, but
              the corresponding device driver does not support the
              <i>ioctl</i>() function.

       If a STREAM is connected downstream from a multiplexer, any
       <i>ioctl</i>() command except I_UNLINK and I_PUNLINK shall set <i><a href="errno.3.html">errno</a></i> to
       <b>[EINVAL]</b>.

       <i>The following sections are informative.</i>
</pre> <h2>
EXAMPLES </h2>
<pre>
       None.
</pre> <h2>
APPLICATION USAGE </h2>
<pre>
       The implementation-defined timeout interval for STREAMS has
       historically been 15 seconds.
</pre> <h2>
RATIONALE </h2>
<pre>
       None.
</pre> <h2>
FUTURE DIRECTIONS </h2>
<pre>
       The <i>ioctl</i>() function may be removed in a future version.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <i>Section 2.6</i>, <i>STREAMS</i>, <a href="close.3p.html">close(3p)</a>, <a href="fcntl.3p.html">fcntl(3p)</a>, <a href="getmsg.3p.html">getmsg(3p)</a>, <a href="open.3p.html">open(3p)</a>,
       <a href="pipe.3p.html">pipe(3p)</a>, <a href="poll.3p.html">poll(3p)</a>, <a href="putmsg.3p.html">putmsg(3p)</a>, <a href="read.3p.html">read(3p)</a>, <a href="sigaction.3p.html">sigaction(3p)</a>,
       <a href="write.3p.html">write(3p)</a>

       The Base Definitions volume of POSIX.1‐2017, <a href="../man0/stropts.h.0p.html">stropts.h(0p)</a>
</pre> <h2>
COPYRIGHT </h2>
<pre>
       Portions of this text are reprinted and reproduced in electronic
       form from IEEE Std 1003.1-2017, Standard for Information
       Technology -- Portable Operating System Interface (POSIX), The
       Open Group Base Specifications Issue 7, 2018 Edition, Copyright
       (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any
       discrepancy between this version and the original IEEE and The
       Open Group Standard, the original IEEE and The Open Group
       Standard is the referee document. The original Standard can be
       obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page
       are most likely to have been introduced during the conversion of
       the source files to man page format. To report such errors, see
       <a href="https://www.kernel.org/doc/man-pages/reporting_bugs.html">https://www.kernel.org/doc/man-pages/reporting_bugs.html</a> .

<span class="footline">IEEE/The Open Group               2017                         <i>IOCTL</i>(3P)</span>
</pre>  <p>Pages that refer to this page: <a href="../man0/signal.h.0p.html">signal.h(0p)</a>, <a href="../man0/stropts.h.0p.html">stropts.h(0p)</a>, <a href="close.3p.html">close(3p)</a>, <a href="read.3p.html">read(3p)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man3/ioctl.3p.html" class="_attribution-link">https://man7.org/linux/man-pages/man3/ioctl.3p.html</a>
  </p>
</div>
