<h1>rpc(3) — Linux manual page</h1>   <pre>
<span class="headline"><i>rpc</i>(3)                  Library Functions Manual                  <i>rpc</i>(3)</span>
</pre> <h2>
NAME </h2>
<pre>
       rpc - library routines for remote procedure calls
</pre> <h2>
LIBRARY </h2>
<pre>
       Standard C library (<i>libc</i>, <i>-lc</i>)
</pre> <h2>
SYNOPSIS AND DESCRIPTION </h2>
<pre>
       These routines allow C programs to make procedure calls on other
       machines across the network.  First, the client calls a procedure
       to send a data packet to the server.  Upon receipt of the packet,
       the server calls a dispatch routine to perform the requested
       service, and then sends back a reply.  Finally, the procedure
       call returns to the client.

       To take use of these routines, include the header file
       <i>&lt;rpc/rpc.h&gt;</i>.

       The prototypes below make use of the following types:

           <b>typedef int </b><i>bool_t</i><b>;</b>

           <b>typedef bool_t (*</b><i>xdrproc_t</i><b>)(XDR *, void *, ...);</b>

           <b>typedef bool_t (*</b><i>resultproc_t</i><b>)(caddr_t </b><i>resp</i><b>,</b>
                                          <b>struct sockaddr_in *</b><i>raddr</i><b>);</b>

       See the header files for the declarations of the <i>AUTH</i>, <i>CLIENT</i>,
       <i>SVCXPRT</i>, and <i>XDR</i> types.

       <b>void auth_destroy(AUTH *</b><i>auth</i><b>);</b>

              A macro that destroys the authentication information
              associated with <i>auth</i>.  Destruction usually involves
              deallocation of private data structures.  The use of <i>auth</i>
              is undefined after calling <b>auth_destroy</b>().

       <b>AUTH *authnone_create(void);</b>

              Create and return an RPC authentication handle that passes
              nonusable authentication information with each remote
              procedure call.  This is the default authentication used
              by RPC.

       <b>AUTH *authunix_create(char *</b><i>host</i><b>, uid_t </b><i>uid</i><b>, gid_t </b><i>gid</i><b>,</b>
                             <b>int </b><i>len</i><b>, gid_t </b><i>aup_gids</i><b>[.</b><i>len</i><b>]);</b>

              Create and return an RPC authentication handle that
              contains authentication information.  The parameter <i>host</i>
              is the name of the machine on which the information was
              created; <i>uid</i> is the user's user ID; <i>gid</i> is the user's
              current group ID; <i>len</i> and <i>aup_gids</i> refer to a counted
              array of groups to which the user belongs.  It is easy to
              impersonate a user.

       <b>AUTH *authunix_create_default(void);</b>

              Calls <b>authunix_create</b>() with the appropriate parameters.

       <b>int callrpc(char *</b><i>host</i><b>, unsigned long </b><i>prognum</i><b>,</b>
                   <b>unsigned long </b><i>versnum</i><b>, unsigned long </b><i>procnum</i><b>,</b>
                   <b>xdrproc_t </b><i>inproc</i><b>, const char *</b><i>in</i><b>,</b>
                   <b>xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>);</b>

              Call the remote procedure associated with <i>prognum</i>,
              <i>versnum</i>, and <i>procnum</i> on the machine, <i>host</i>.  The parameter
              <i>in</i> is the address of the procedure's argument(s), and <i>out</i>
              is the address of where to place the result(s); <i>inproc</i> is
              used to encode the procedure's parameters, and <i>outproc</i> is
              used to decode the procedure's results.  This routine
              returns zero if it succeeds, or the value of <b>enum</b>
              <b>clnt_stat </b>cast to an integer if it fails.  The routine
              <b>clnt_perrno</b>() is handy for translating failure statuses
              into messages.

              Warning: calling remote procedures with this routine uses
              UDP/IP as a transport; see <b>clntudp_create</b>() for
              restrictions.  You do not have control of timeouts or
              authentication using this routine.

       <b>enum clnt_stat clnt_broadcast(unsigned long </b><i>prognum</i><b>,</b>
                            <b>unsigned long </b><i>versnum</i><b>, unsigned long </b><i>procnum</i><b>,</b>
                            <b>xdrproc_t </b><i>inproc</i><b>, char *</b><i>in</i><b>,</b>
                            <b>xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>,</b>
                            <b>resultproc_t </b><i>eachresult</i><b>);</b>

              Like <b>callrpc</b>(), except the call message is broadcast to
              all locally connected broadcast nets.  Each time it
              receives a response, this routine calls <b>eachresult</b>(),
              whose form is:

                  <b>eachresult(char *</b><i>out</i><b>, struct sockaddr_in *</b><i>addr</i><b>);</b>

              where <i>out</i> is the same as <i>out</i> passed to <b>clnt_broadcast</b>(),
              except that the remote procedure's output is decoded
              there; <i>addr</i> points to the address of the machine that sent
              the results.  If <b>eachresult</b>() returns zero,
              <b>clnt_broadcast</b>() waits for more replies; otherwise it
              returns with appropriate status.

              Warning: broadcast sockets are limited in size to the
              maximum transfer unit of the data link.  For ethernet,
              this value is 1500 bytes.

       <b>enum clnt_stat clnt_call(CLIENT *</b><i>clnt</i><b>, unsigned long </b><i>procnum</i><b>,</b>
                           <b>xdrproc_t </b><i>inproc</i><b>, char *</b><i>in</i><b>,</b>
                           <b>xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>,</b>
                           <b>struct timeval </b><i>tout</i><b>);</b>

              A macro that calls the remote procedure <i>procnum</i> associated
              with the client handle, <i>clnt</i>, which is obtained with an
              RPC client creation routine such as <b>clnt_create</b>().  The
              parameter <i>in</i> is the address of the procedure's
              argument(s), and <i>out</i> is the address of where to place the
              result(s); <i>inproc</i> is used to encode the procedure's
              parameters, and <i>outproc</i> is used to decode the procedure's
              results; <i>tout</i> is the time allowed for results to come
              back.

       <b>clnt_destroy(CLIENT *</b><i>clnt</i><b>);</b>

              A macro that destroys the client's RPC handle.
              Destruction usually involves deallocation of private data
              structures, including <i>clnt</i> itself.  Use of <i>clnt</i> is
              undefined after calling <b>clnt_destroy</b>().  If the RPC
              library opened the associated socket, it will close it
              also.  Otherwise, the socket remains open.

       <b>CLIENT *clnt_create(const char *</b><i>host</i><b>, unsigned long </b><i>prog</i><b>,</b>
                           <b>unsigned long </b><i>vers</i><b>, const char *</b><i>proto</i><b>);</b>

              Generic client creation routine.  <i>host</i> identifies the name
              of the remote host where the server is located.  <i>proto</i>
              indicates which kind of transport protocol to use.  The
              currently supported values for this field are “udp” and
              “tcp”.  Default timeouts are set, but can be modified
              using <b>clnt_control</b>().

              Warning: using UDP has its shortcomings.  Since UDP-based
              RPC messages can hold only up to 8 Kbytes of encoded data,
              this transport cannot be used for procedures that take
              large arguments or return huge results.

       <b>bool_t clnt_control(CLIENT *</b><i>cl</i><b>, int </b><i>req</i><b>, char *</b><i>info</i><b>);</b>

              A macro used to change or retrieve various information
              about a client object.  <i>req</i> indicates the type of
              operation, and <i>info</i> is a pointer to the information.  For
              both UDP and TCP, the supported values of <i>req</i> and their
              argument types and what they do are:

                  <b>CLSET_TIMEOUT  </b><i>struct timeval</i> // set total timeout
                  <b>CLGET_TIMEOUT  </b><i>struct timeval</i> // get total timeout

              Note: if you set the timeout using <b>clnt_control</b>(), the
              timeout parameter passed to <b>clnt_call</b>() will be ignored in
              all future calls.

                  <b>CLGET_SERVER_ADDR  </b><i>struct sockaddr_in</i>
                                  // get server's address

              The following operations are valid for UDP only:

                  <b>CLSET_RETRY_TIMEOUT  </b><i>struct timeval</i> // set the retry timeout
                  <b>CLGET_RETRY_TIMEOUT  </b><i>struct timeval</i> // get the retry timeout

              The retry timeout is the time that "UDP RPC" waits for the
              server to reply before retransmitting the request.

       <b>clnt_freeres(CLIENT * </b><i>clnt</i><b>, xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>);</b>

              A macro that frees any data allocated by the RPC/XDR
              system when it decoded the results of an RPC call.  The
              parameter <i>out</i> is the address of the results, and <i>outproc</i>
              is the XDR routine describing the results.  This routine
              returns one if the results were successfully freed, and
              zero otherwise.

       <b>void clnt_geterr(CLIENT *</b><i>clnt</i><b>, struct rpc_err *</b><i>errp</i><b>);</b>

              A macro that copies the error structure out of the client
              handle to the structure at address <i>errp</i>.

       <b>void clnt_pcreateerror(const char *</b><i>s</i><b>);</b>

              Print a message to standard error indicating why a client
              RPC handle could not be created.  The message is prepended
              with string <i>s</i> and a colon.  Used when a <b>clnt_create</b>(),
              <b>clntraw_create</b>(), <b>clnttcp_create</b>(), or <b>clntudp_create</b>()
              call fails.

       <b>void clnt_perrno(enum clnt_stat </b><i>stat</i><b>);</b>

              Print a message to standard error corresponding to the
              condition indicated by <i>stat</i>.  Used after <b>callrpc</b>().

       <b>clnt_perror(CLIENT *</b><i>clnt</i><b>, const char *</b><i>s</i><b>);</b>

              Print a message to standard error indicating why an RPC
              call failed; <i>clnt</i> is the handle used to do the call.  The
              message is prepended with string <i>s</i> and a colon.  Used
              after <b>clnt_call</b>().

       <b>char *clnt_spcreateerror(const char *</b><i>s</i><b>);</b>

              Like <b>clnt_pcreateerror</b>(), except that it returns a string
              instead of printing to the standard error.

              Bugs: returns pointer to static data that is overwritten
              on each call.

       <b>char *clnt_sperrno(enum clnt_stat </b><i>stat</i><b>);</b>

              Take the same arguments as <b>clnt_perrno</b>(), but instead of
              sending a message to the standard error indicating why an
              RPC call failed, return a pointer to a string which
              contains the message.  The string ends with a NEWLINE.

              <b>clnt_sperrno</b>() is used instead of <b>clnt_perrno</b>() if the
              program does not have a standard error (as a program
              running as a server quite likely does not), or if the
              programmer does not want the message to be output with
              <a href="printf.3.html">printf(3)</a>, or if a message format different than that
              supported by <b>clnt_perrno</b>() is to be used.  Note: unlike
              <b>clnt_sperror</b>() and <b>clnt_spcreateerror</b>(), <b>clnt_sperrno</b>()
              returns pointer to static data, but the result will not
              get overwritten on each call.

       <b>char *clnt_sperror(CLIENT *</b><i>rpch</i><b>, const char *</b><i>s</i><b>);</b>

              Like <b>clnt_perror</b>(), except that (like <b>clnt_sperrno</b>()) it
              returns a string instead of printing to standard error.

              Bugs: returns pointer to static data that is overwritten
              on each call.

       <b>CLIENT *clntraw_create(unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>);</b>

              This routine creates a toy RPC client for the remote
              program <i>prognum</i>, version <i>versnum</i>.  The transport used to
              pass messages to the service is actually a buffer within
              the process's address space, so the corresponding RPC
              server should live in the same address space; see
              <b>svcraw_create</b>().  This allows simulation of RPC and
              acquisition of RPC overheads, such as round trip times,
              without any kernel interference.  This routine returns
              NULL if it fails.

       <b>CLIENT *clnttcp_create(struct sockaddr_in *</b><i>addr</i><b>,</b>
                       <b>unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b>
                       <b>int *</b><i>sockp</i><b>, unsigned int </b><i>sendsz</i><b>, unsigned int </b><i>recvsz</i><b>);</b>

              This routine creates an RPC client for the remote program
              <i>prognum</i>, version <i>versnum</i>; the client uses TCP/IP as a
              transport.  The remote program is located at Internet
              address <i>*addr</i>.  If <i>addr-&gt;sin_port</i> is zero, then it is set
              to the actual port that the remote program is listening on
              (the remote <b>portmap </b>service is consulted for this
              information).  The parameter <i>sockp</i> is a socket; if it is
              <b>RPC_ANYSOCK</b>, then this routine opens a new one and sets
              <i>sockp</i>.  Since TCP-based RPC uses buffered I/O, the user
              may specify the size of the send and receive buffers with
              the parameters <i>sendsz</i> and <i>recvsz</i>; values of zero choose
              suitable defaults.  This routine returns NULL if it fails.

       <b>CLIENT *clntudp_create(struct sockaddr_in *</b><i>addr</i><b>,</b>
                       <b>unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b>
                       <b>struct timeval </b><i>wait</i><b>, int *</b><i>sockp</i><b>);</b>

              This routine creates an RPC client for the remote program
              <i>prognum</i>, version <i>versnum</i>; the client uses use UDP/IP as a
              transport.  The remote program is located at Internet
              address <i>addr</i>.  If <i>addr-&gt;sin_port</i> is zero, then it is set
              to actual port that the remote program is listening on
              (the remote <b>portmap </b>service is consulted for this
              information).  The parameter <i>sockp</i> is a socket; if it is
              <b>RPC_ANYSOCK</b>, then this routine opens a new one and sets
              <i>sockp</i>.  The UDP transport resends the call message in
              intervals of <i>wait</i> time until a response is received or
              until the call times out.  The total time for the call to
              time out is specified by <b>clnt_call</b>().

              Warning: since UDP-based RPC messages can hold only up to
              8 Kbytes of encoded data, this transport cannot be used
              for procedures that take large arguments or return huge
              results.

       <b>CLIENT *clntudp_bufcreate(struct sockaddr_in *</b><i>addr</i><b>,</b>
                   <b>unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b>
                   <b>struct timeval </b><i>wait</i><b>, int *</b><i>sockp</i><b>,</b>
                   <b>unsigned int </b><i>sendsize</i><b>, unsigned int </b><i>recosize</i><b>);</b>

              This routine creates an RPC client for the remote program
              <i>prognum</i>, on <i>versnum</i>; the client uses use UDP/IP as a
              transport.  The remote program is located at Internet
              address <i>addr</i>.  If <i>addr-&gt;sin_port</i> is zero, then it is set
              to actual port that the remote program is listening on
              (the remote <b>portmap </b>service is consulted for this
              information).  The parameter <i>sockp</i> is a socket; if it is
              <b>RPC_ANYSOCK</b>, then this routine opens a new one and sets
              <i>sockp</i>.  The UDP transport resends the call message in
              intervals of <i>wait</i> time until a response is received or
              until the call times out.  The total time for the call to
              time out is specified by <b>clnt_call</b>().

              This allows the user to specify the maximum packet size
              for sending and receiving UDP-based RPC messages.

       <b>void get_myaddress(struct sockaddr_in *</b><i>addr</i><b>);</b>

              Stuff the machine's IP address into <i>*addr</i>, without
              consulting the library routines that deal with <i>/etc/hosts</i>.
              The port number is always set to <b>htons(PMAPPORT)</b>.

       <b>struct pmaplist *pmap_getmaps(struct sockaddr_in *</b><i>addr</i><b>);</b>

              A user interface to the <b>portmap </b>service, which returns a
              list of the current RPC program-to-port mappings on the
              host located at IP address <i>*addr</i>.  This routine can return
              NULL.  The command <i>rpcinfo -p</i> uses this routine.

       <b>unsigned short pmap_getport(struct sockaddr_in *</b><i>addr</i><b>,</b>
                           <b>unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b>
                           <b>unsigned int </b><i>protocol</i><b>);</b>

              A user interface to the <b>portmap </b>service, which returns the
              port number on which waits a service that supports program
              number <i>prognum</i>, version <i>versnum</i>, and speaks the transport
              protocol associated with <i>protocol</i>.  The value of <i>protocol</i>
              is most likely <b>IPPROTO_UDP </b>or <b>IPPROTO_TCP</b>.  A return value
              of zero means that the mapping does not exist or that the
              RPC system failed to contact the remote <b>portmap </b>service.
              In the latter case, the global variable <i>rpc_createerr</i>
              contains the RPC status.

       <b>enum clnt_stat pmap_rmtcall(struct sockaddr_in *</b><i>addr</i><b>,</b>
                           <b>unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b>
                           <b>unsigned long </b><i>procnum</i><b>,</b>
                           <b>xdrproc_t </b><i>inproc</i><b>, char *</b><i>in</i><b>,</b>
                           <b>xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>,</b>
                           <b>struct timeval </b><i>tout</i><b>, unsigned long *</b><i>portp</i><b>);</b>

              A user interface to the <b>portmap </b>service, which instructs
              <b>portmap </b>on the host at IP address <i>*addr</i> to make an RPC
              call on your behalf to a procedure on that host.  The
              parameter <i>*portp</i> will be modified to the program's port
              number if the procedure succeeds.  The definitions of
              other parameters are discussed in <b>callrpc</b>() and
              <b>clnt_call</b>().  This procedure should be used for a “ping”
              and nothing else.  See also <b>clnt_broadcast</b>().

       <b>bool_t pmap_set(unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b>
                       <b>int </b><i>protocol</i><b>, unsigned short </b><i>port</i><b>);</b>

              A user interface to the <b>portmap </b>service, which establishes
              a mapping between the triple [<i>prognum</i>,<i>versnum</i>,<i>protocol</i>]
              and <i>port</i> on the machine's <b>portmap </b>service.  The value of
              <i>protocol</i> is most likely <b>IPPROTO_UDP </b>or <b>IPPROTO_TCP</b>.  This
              routine returns one if it succeeds, zero otherwise.
              Automatically done by <b>svc_register</b>().

       <b>bool_t pmap_unset(unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>);</b>

              A user interface to the <b>portmap </b>service, which destroys
              all mapping between the triple [<i>prognum</i>,<i>versnum</i>,<i>*</i>] and
              <b>ports </b>on the machine's <b>portmap </b>service.  This routine
              returns one if it succeeds, zero otherwise.

       <b>int registerrpc(unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b>
                       <b>unsigned long </b><i>procnum</i><b>, char *(*</b><i>procname</i><b>)(char *),</b>
                       <b>xdrproc_t </b><i>inproc</i><b>, xdrproc_t </b><i>outproc</i><b>);</b>

              Register procedure <i>procname</i> with the RPC service package.
              If a request arrives for program <i>prognum</i>, version <i>versnum</i>,
              and procedure <i>procnum</i>, <i>procname</i> is called with a pointer
              to its parameter(s); <i>procname</i> should return a pointer to
              its static result(s); <i>inproc</i> is used to decode the
              parameters while <i>outproc</i> is used to encode the results.
              This routine returns zero if the registration succeeded,
              -1 otherwise.

              Warning: remote procedures registered in this form are
              accessed using the UDP/IP transport; see <b>svcudp_create</b>()
              for restrictions.

       <b>struct rpc_createerr </b><i>rpc_createerr</i><b>;</b>

              A global variable whose value is set by any RPC client
              creation routine that does not succeed.  Use the routine
              <b>clnt_pcreateerror</b>() to print the reason why.

       <b>void svc_destroy(SVCXPRT *</b><i>xprt</i><b>);</b>

              A macro that destroys the RPC service transport handle,
              <i>xprt</i>.  Destruction usually involves deallocation of
              private data structures, including <i>xprt</i> itself.  Use of
              <i>xprt</i> is undefined after calling this routine.

       <b>fd_set </b><i>svc_fdset</i><b>;</b>

              A global variable reflecting the RPC service side's read
              file descriptor bit mask; it is suitable as a parameter to
              the <a href="../man2/select.2.html">select(2)</a> system call.  This is of interest only if a
              service implementor does their own asynchronous event
              processing, instead of calling <b>svc_run</b>().  This variable
              is read-only (do not pass its address to <a href="../man2/select.2.html">select(2)</a>!), yet
              it may change after calls to <b>svc_getreqset</b>() or any
              creation routines.

       <b>int </b><i>svc_fds</i><b>;</b>

              Similar to <b>svc_fdset</b>, but limited to 32 file descriptors.
              This interface is obsoleted by <b>svc_fdset</b>.

       <b>svc_freeargs(SVCXPRT *</b><i>xprt</i><b>, xdrproc_t </b><i>inproc</i><b>, char *</b><i>in</i><b>);</b>

              A macro that frees any data allocated by the RPC/XDR
              system when it decoded the arguments to a service
              procedure using <b>svc_getargs</b>().  This routine returns 1 if
              the results were successfully freed, and zero otherwise.

       <b>svc_getargs(SVCXPRT *</b><i>xprt</i><b>, xdrproc_t </b><i>inproc</i><b>, char *</b><i>in</i><b>);</b>

              A macro that decodes the arguments of an RPC request
              associated with the RPC service transport handle, <i>xprt</i>.
              The parameter <i>in</i> is the address where the arguments will
              be placed; <i>inproc</i> is the XDR routine used to decode the
              arguments.  This routine returns one if decoding succeeds,
              and zero otherwise.

       <b>struct sockaddr_in *svc_getcaller(SVCXPRT *</b><i>xprt</i><b>);</b>

              The approved way of getting the network address of the
              caller of a procedure associated with the RPC service
              transport handle, <i>xprt</i>.

       <b>void svc_getreqset(fd_set *</b><i>rdfds</i><b>);</b>

              This routine is of interest only if a service implementor
              does not call <b>svc_run</b>(), but instead implements custom
              asynchronous event processing.  It is called when the
              <a href="../man2/select.2.html">select(2)</a> system call has determined that an RPC request
              has arrived on some RPC socket(s); <i>rdfds</i> is the resultant
              read file descriptor bit mask.  The routine returns when
              all sockets associated with the value of <i>rdfds</i> have been
              serviced.

       <b>void svc_getreq(int </b><i>rdfds</i><b>);</b>

              Similar to <b>svc_getreqset</b>(), but limited to 32 file
              descriptors.  This interface is obsoleted by
              <b>svc_getreqset</b>().

       <b>bool_t svc_register(SVCXPRT *</b><i>xprt</i><b>, unsigned long </b><i>prognum</i><b>,</b>
                           <b>unsigned long </b><i>versnum</i><b>,</b>
                           <b>void (*</b><i>dispatch</i><b>)(struct svc_req *, SVCXPRT *),</b>
                           <b>unsigned long </b><i>protocol</i><b>);</b>

              Associates <i>prognum</i> and <i>versnum</i> with the service dispatch
              procedure, <i>dispatch</i>.  If <i>protocol</i> is zero, the service is
              not registered with the <b>portmap </b>service.  If <i>protocol</i> is
              nonzero, then a mapping of the triple
              [<i>prognum</i>,<i>versnum</i>,<i>protocol</i>] to <i>xprt-&gt;xp_port</i> is established
              with the local <b>portmap </b>service (generally <i>protocol</i> is
              zero, <b>IPPROTO_UDP </b>or <b>IPPROTO_TCP</b>).  The procedure <i>dispatch</i>
              has the following form:

                  dispatch(struct svc_req *request, SVCXPRT *xprt);

              The <b>svc_register</b>() routine returns one if it succeeds, and
              zero otherwise.

       <b>void svc_run(void);</b>

              This routine never returns.  It waits for RPC requests to
              arrive, and calls the appropriate service procedure using
              <b>svc_getreq</b>() when one arrives.  This procedure is usually
              waiting for a <a href="../man2/select.2.html">select(2)</a> system call to return.

       <b>bool_t svc_sendreply(SVCXPRT *</b><i>xprt</i><b>, xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>);</b>

              Called by an RPC service's dispatch routine to send the
              results of a remote procedure call.  The parameter <i>xprt</i> is
              the request's associated transport handle; <i>outproc</i> is the
              XDR routine which is used to encode the results; and <i>out</i>
              is the address of the results.  This routine returns one
              if it succeeds, zero otherwise.

       <b>void svc_unregister(unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>);</b>

              Remove all mapping of the double [<i>prognum</i>,<i>versnum</i>] to
              dispatch routines, and of the triple [<i>prognum</i>,<i>versnum</i>,<i>*</i>]
              to port number.

       <b>void svcerr_auth(SVCXPRT *</b><i>xprt</i><b>, enum auth_stat </b><i>why</i><b>);</b>

              Called by a service dispatch routine that refuses to
              perform a remote procedure call due to an authentication
              error.

       <b>void svcerr_decode(SVCXPRT *</b><i>xprt</i><b>);</b>

              Called by a service dispatch routine that cannot
              successfully decode its parameters.  See also
              <b>svc_getargs</b>().

       <b>void svcerr_noproc(SVCXPRT *</b><i>xprt</i><b>);</b>

              Called by a service dispatch routine that does not
              implement the procedure number that the caller requests.

       <b>void svcerr_noprog(SVCXPRT *</b><i>xprt</i><b>);</b>

              Called when the desired program is not registered with the
              RPC package.  Service implementors usually do not need
              this routine.

       <b>void svcerr_progvers(SVCXPRT *</b><i>xprt</i><b>, unsigned long </b><i>low_vers</i><b>,</b>
                            <b>unsigned long </b><i>high_vers</i><b>);</b>

              Called when the desired version of a program is not
              registered with the RPC package.  Service implementors
              usually do not need this routine.

       <b>void svcerr_systemerr(SVCXPRT *</b><i>xprt</i><b>);</b>

              Called by a service dispatch routine when it detects a
              system error not covered by any particular protocol.  For
              example, if a service can no longer allocate storage, it
              may call this routine.

       <b>void svcerr_weakauth(SVCXPRT *</b><i>xprt</i><b>);</b>

              Called by a service dispatch routine that refuses to
              perform a remote procedure call due to insufficient
              authentication parameters.  The routine calls
              <b>svcerr_auth(xprt, AUTH_TOOWEAK)</b>.

       <b>SVCXPRT *svcfd_create(int </b><i>fd</i><b>, unsigned int </b><i>sendsize</i><b>,</b>
                             <b>unsigned int </b><i>recvsize</i><b>);</b>

              Create a service on top of any open file descriptor.
              Typically, this file descriptor is a connected socket for
              a stream protocol such as TCP.  <i>sendsize</i> and <i>recvsize</i>
              indicate sizes for the send and receive buffers.  If they
              are zero, a reasonable default is chosen.

       <b>SVCXPRT *svcraw_create(void);</b>

              This routine creates a toy RPC service transport, to which
              it returns a pointer.  The transport is really a buffer
              within the process's address space, so the corresponding
              RPC client should live in the same address space; see
              <b>clntraw_create</b>().  This routine allows simulation of RPC
              and acquisition of RPC overheads (such as round trip
              times), without any kernel interference.  This routine
              returns NULL if it fails.

       <b>SVCXPRT *svctcp_create(int </b><i>sock</i><b>, unsigned int </b><i>send_buf_size</i><b>,</b>
                              <b>unsigned int </b><i>recv_buf_size</i><b>);</b>

              This routine creates a TCP/IP-based RPC service transport,
              to which it returns a pointer.  The transport is
              associated with the socket <i>sock</i>, which may be <b>RPC_ANYSOCK</b>,
              in which case a new socket is created.  If the socket is
              not bound to a local TCP port, then this routine binds it
              to an arbitrary port.  Upon completion, <i>xprt-&gt;xp_sock</i> is
              the transport's socket descriptor, and <i>xprt-&gt;xp_port</i> is
              the transport's port number.  This routine returns NULL if
              it fails.  Since TCP-based RPC uses buffered I/O, users
              may specify the size of buffers; values of zero choose
              suitable defaults.

       <b>SVCXPRT *svcudp_bufcreate(int </b><i>sock</i><b>, unsigned int </b><i>sendsize</i><b>,</b>
                                 <b>unsigned int </b><i>recosize</i><b>);</b>

              This routine creates a UDP/IP-based RPC service transport,
              to which it returns a pointer.  The transport is
              associated with the socket <i>sock</i>, which may be <b>RPC_ANYSOCK</b>,
              in which case a new socket is created.  If the socket is
              not bound to a local UDP port, then this routine binds it
              to an arbitrary port.  Upon completion, <i>xprt-&gt;xp_sock</i> is
              the transport's socket descriptor, and <i>xprt-&gt;xp_port</i> is
              the transport's port number.  This routine returns NULL if
              it fails.

              This allows the user to specify the maximum packet size
              for sending and receiving UDP-based RPC messages.

       <b>SVCXPRT *svcudp_create(int </b><i>sock</i><b>);</b>

              This call is equivalent to <i>svcudp_bufcreate(sock,SZ,SZ)</i>
              for some default size <i>SZ</i>.

       <b>bool_t xdr_accepted_reply(XDR *</b><i>xdrs</i><b>, struct accepted_reply *</b><i>ar</i><b>);</b>

              Used for encoding RPC reply messages.  This routine is
              useful for users who wish to generate RPC-style messages
              without using the RPC package.

       <b>bool_t xdr_authunix_parms(XDR *</b><i>xdrs</i><b>, struct authunix_parms *</b><i>aupp</i><b>);</b>

              Used for describing UNIX credentials.  This routine is
              useful for users who wish to generate these credentials
              without using the RPC authentication package.

       <b>void xdr_callhdr(XDR *</b><i>xdrs</i><b>, struct rpc_msg *</b><i>chdr</i><b>);</b>

              Used for describing RPC call header messages.  This
              routine is useful for users who wish to generate RPC-style
              messages without using the RPC package.

       <b>bool_t xdr_callmsg(XDR *</b><i>xdrs</i><b>, struct rpc_msg *</b><i>cmsg</i><b>);</b>

              Used for describing RPC call messages.  This routine is
              useful for users who wish to generate RPC-style messages
              without using the RPC package.

       <b>bool_t xdr_opaque_auth(XDR *</b><i>xdrs</i><b>, struct opaque_auth *</b><i>ap</i><b>);</b>

              Used for describing RPC authentication information
              messages.  This routine is useful for users who wish to
              generate RPC-style messages without using the RPC package.

       <b>bool_t xdr_pmap(XDR *</b><i>xdrs</i><b>, struct pmap *</b><i>regs</i><b>);</b>

              Used for describing parameters to various <b>portmap</b>
              procedures, externally.  This routine is useful for users
              who wish to generate these parameters without using the
              <b>pmap </b>interface.

       <b>bool_t xdr_pmaplist(XDR *</b><i>xdrs</i><b>, struct pmaplist **</b><i>rp</i><b>);</b>

              Used for describing a list of port mappings, externally.
              This routine is useful for users who wish to generate
              these parameters without using the <b>pmap </b>interface.

       <b>bool_t xdr_rejected_reply(XDR *</b><i>xdrs</i><b>, struct rejected_reply *</b><i>rr</i><b>);</b>

              Used for describing RPC reply messages.  This routine is
              useful for users who wish to generate RPC-style messages
              without using the RPC package.

       <b>bool_t xdr_replymsg(XDR *</b><i>xdrs</i><b>, struct rpc_msg *</b><i>rmsg</i><b>);</b>

              Used for describing RPC reply messages.  This routine is
              useful for users who wish to generate RPC style messages
              without using the RPC package.

       <b>void xprt_register(SVCXPRT *</b><i>xprt</i><b>);</b>

              After RPC service transport handles are created, they
              should register themselves with the RPC service package.
              This routine modifies the global variable <i>svc_fds</i>.
              Service implementors usually do not need this routine.

       <b>void xprt_unregister(SVCXPRT *</b><i>xprt</i><b>);</b>

              Before an RPC service transport handle is destroyed, it
              should unregister itself with the RPC service package.
              This routine modifies the global variable <i>svc_fds</i>.
              Service implementors usually do not need this routine.
</pre> <h2>
ATTRIBUTES </h2>
<pre>
       For an explanation of the terms used in this section, see
       <a href="../man7/attributes.7.html">attributes(7)</a>.
       ┌─────────────────────────────────────┬───────────────┬─────────┐
       │ <b>Interface                           </b>│ <b>Attribute     </b>│ <b>Value   </b>│
       ├─────────────────────────────────────┼───────────────┼─────────┤
       │ <b>auth_destroy</b>(), <b>authnone_create</b>(),  │ Thread safety │ MT-Safe │
       │ <b>authunix_create</b>(),                  │               │         │
       │ <b>authunix_create_default</b>(),          │               │         │
       │ <b>callrpc</b>(), <b>clnt_broadcast</b>(),        │               │         │
       │ <b>clnt_call</b>(), <b>clnt_destroy</b>(),        │               │         │
       │ <b>clnt_create</b>(), <b>clnt_control</b>(),      │               │         │
       │ <b>clnt_freeres</b>(), <b>clnt_geterr</b>(),      │               │         │
       │ <b>clnt_pcreateerror</b>(), <b>clnt_perrno</b>(), │               │         │
       │ <b>clnt_perror</b>(),                      │               │         │
       │ <b>clnt_spcreateerror</b>(),               │               │         │
       │ <b>clnt_sperrno</b>(), <b>clnt_sperror</b>(),     │               │         │
       │ <b>clntraw_create</b>(), <b>clnttcp_create</b>(), │               │         │
       │ <b>clntudp_create</b>(),                   │               │         │
       │ <b>clntudp_bufcreate</b>(),                │               │         │
       │ <b>get_myaddress</b>(), <b>pmap_getmaps</b>(),    │               │         │
       │ <b>pmap_getport</b>(), <b>pmap_rmtcall</b>(),     │               │         │
       │ <b>pmap_set</b>(), <b>pmap_unset</b>(),           │               │         │
       │ <b>registerrpc</b>(), <b>svc_destroy</b>(),       │               │         │
       │ <b>svc_freeargs</b>(), <b>svc_getargs</b>(),      │               │         │
       │ <b>svc_getcaller</b>(), <b>svc_getreqset</b>(),   │               │         │
       │ <b>svc_getreq</b>(), <b>svc_register</b>(),       │               │         │
       │ <b>svc_run</b>(), <b>svc_sendreply</b>(),         │               │         │
       │ <b>svc_unregister</b>(), <b>svcerr_auth</b>(),    │               │         │
       │ <b>svcerr_decode</b>(), <b>svcerr_noproc</b>(),   │               │         │
       │ <b>svcerr_noprog</b>(), <b>svcerr_progvers</b>(), │               │         │
       │ <b>svcerr_systemerr</b>(),                 │               │         │
       │ <b>svcerr_weakauth</b>(), <b>svcfd_create</b>(),  │               │         │
       │ <b>svcraw_create</b>(), <b>svctcp_create</b>(),   │               │         │
       │ <b>svcudp_bufcreate</b>(),                 │               │         │
       │ <b>svcudp_create</b>(),                    │               │         │
       │ <b>xdr_accepted_reply</b>(),               │               │         │
       │ <b>xdr_authunix_parms</b>(),               │               │         │
       │ <b>xdr_callhdr</b>(), <b>xdr_callmsg</b>(),       │               │         │
       │ <b>xdr_opaque_auth</b>(), <b>xdr_pmap</b>(),      │               │         │
       │ <b>xdr_pmaplist</b>(),                     │               │         │
       │ <b>xdr_rejected_reply</b>(),               │               │         │
       │ <b>xdr_replymsg</b>(), <b>xprt_register</b>(),    │               │         │
       │ <b>xprt_unregister</b>()                   │               │         │
       └─────────────────────────────────────┴───────────────┴─────────┘
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="xdr.3.html">xdr(3)</a>

       The following manuals:
              Remote Procedure Calls: Protocol Specification
              Remote Procedure Call Programming Guide
              rpcgen Programming Guide

       <i>RPC: Remote Procedure Call Protocol Specification</i>, RFC 1050, Sun
       Microsystems, Inc., USC-ISI.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       ⟨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>⟩.  If you have a bug report
       for this manual page, see
       ⟨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>⟩.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       ⟨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>⟩ on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-05-02                         <i>rpc</i>(3)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/autofsd-probe.1.html">autofsd-probe(1)</a>, <a href="xdr.3.html">xdr(3)</a>, <a href="../man8/rpc.rquotad.8.html">rpc.rquotad(8)</a> </p> <hr> <p class="page-copyright"><a href="rpc.3.license.html">Copyright and license for this manual page</a></p>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man3/xdr_opaque_auth.3.html" class="_attribution-link">https://man7.org/linux/man-pages/man3/xdr_opaque_auth.3.html</a>
  </p>
</div>
