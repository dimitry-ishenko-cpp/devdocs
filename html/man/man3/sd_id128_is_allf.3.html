<h1>sd-id128(3) — Linux manual page</h1>   <pre>
<span class="headline"><i>SD-ID128</i>(3)                     sd-id128                     <i>SD-ID128</i>(3)</span>
</pre> <h2>
NAME </h2>
<pre>
       sd-id128, SD_ID128_ALLF, SD_ID128_CONST_STR, SD_ID128_FORMAT_STR,
       SD_ID128_FORMAT_VAL, SD_ID128_MAKE, SD_ID128_MAKE_STR,
       SD_ID128_MAKE_UUID_STR, SD_ID128_NULL, SD_ID128_UUID_FORMAT_STR,
       sd_id128_equal, sd_id128_string_equal, sd_id128_in_set,
       sd_id128_in_set_sentinel, sd_id128_in_setv, sd_id128_is_allf,
       sd_id128_is_null, sd_id128_t - APIs for processing 128-bit IDs
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;systemd/sd-id128.h&gt;</b>

       <b>SD_ID128_ALLF</b>

       <b>SD_ID128_NULL</b>

       <b>SD_ID128_CONST_STR(</b><i>id</i><b>)</b>

       <b>SD_ID128_FORMAT_STR</b>

       <b>SD_ID128_FORMAT_VAL(</b><i>id</i><b>)</b>

       <b>SD_ID128_MAKE(</b><i>v0</i><b>, </b><i>v1</i><b>, </b><i>v2</i><b>, </b><i>v3</i><b>, </b><i>v4</i><b>, </b><i>v5</i><b>, </b><i>v6</i><b>, </b><i>v7</i><b>, </b><i>v8</i><b>, </b><i>v9</i><b>, </b><i>vA</i><b>, </b><i>vB</i><b>, </b><i>vC</i><b>,</b>
       <i>vD</i><b>, </b><i>vE</i><b>, </b><i>vF</i><b>)</b>

       <b>SD_ID128_MAKE_STR(</b><i>v0</i><b>, </b><i>v1</i><b>, </b><i>v2</i><b>, </b><i>v3</i><b>, </b><i>v4</i><b>, </b><i>v5</i><b>, </b><i>v6</i><b>, </b><i>v7</i><b>, </b><i>v8</i><b>, </b><i>v9</i><b>, </b><i>vA</i><b>, </b><i>vB</i><b>,</b>
       <i>vC</i><b>, </b><i>vD</i><b>, </b><i>vE</i><b>, </b><i>vF</i><b>)</b>

       <b>SD_ID128_MAKE_UUID_STR(</b><i>v0</i><b>, </b><i>v1</i><b>, </b><i>v2</i><b>, </b><i>v3</i><b>, </b><i>v4</i><b>, </b><i>v5</i><b>, </b><i>v6</i><b>, </b><i>v7</i><b>, </b><i>v8</i><b>, </b><i>v9</i><b>,</b>
       <i>vA</i><b>, </b><i>vB</i><b>, </b><i>vC</i><b>, </b><i>vD</i><b>, </b><i>vE</i><b>, </b><i>vF</i><b>)</b>

       <b>SD_ID128_UUID_FORMAT_STR</b>

       <b>int sd_id128_equal(sd_id128_t </b><i>a</i><b>, sd_id128_t </b><i>b</i><b>);</b>

       <b>int sd_id128_string_equal(const char *</b><i>a</i><b>, sd_id128_t </b><i>b</i><b>);</b>

       <b>int sd_id128_is_null(sd_id128_t </b><i>id</i><b>);</b>

       <b>int sd_id128_is_allf(sd_id128_t </b><i>id</i><b>);</b>

       <b>int sd_id128_in_setv(sd_id128_t </b><i>id</i><b>, va_list </b><i>ap</i><b>);</b>

       <b>int sd_id128_in_set_sentinel(sd_id128_t </b><i>id</i><b>, ..., SD_ID128_NULL);</b>

       <b>int sd_id128_in_set(sd_id128_t </b><i>id</i><b>, ...);</b>

       <b>pkg-config --cflags --libs libsystemd</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       sd-id128.h is part of <a href="libsystemd.3.html">libsystemd(3)</a> and provides APIs to
       generate, convert, and compare 128-bit ID values. The 128-bit ID
       values processed and generated by these APIs are a generalization
       of OSF UUIDs as defined by <b>RFC 4122</b>[1] but use a simpler string
       format. These functions impose no structure on the used IDs, much
       unlike OSF UUIDs or Microsoft GUIDs, but are mostly compatible
       with those types of IDs.

       A 128-bit ID is implemented as the following union type:

           typedef union sd_id128 {
             uint8_t bytes[16];
             uint64_t qwords[2];
           } sd_id128_t;

       This union type allows accessing the 128-bit ID as 16 separate
       bytes or two 64-bit words. It is generally safer to access the ID
       components by their 8-bit array to avoid endianness issues. This
       union is intended to be passed by value (as opposed to
       pass-by-reference) and may be directly manipulated by clients.

       A couple of macros are defined to denote and decode 128-bit IDs:

       <b>SD_ID128_MAKE() </b>is used to write a constant ID in source code. A
       commonly used idiom is to assign a name to an ID using this
       macro:

           #define SD_MESSAGE_COREDUMP SD_ID128_MAKE(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)

       <b>SD_ID128_NULL </b>defines an ID consisting of only <b>NUL </b>bytes (i.e.
       all bits off).

       <b>SD_ID128_ALLF </b>defines an ID consisting of only <b>0xFF </b>bytes (i.e.
       all bits on).

       <b>SD_ID128_MAKE_STR() </b>is similar to <b>SD_ID128_MAKE()</b>, but creates a
       <b>const char* </b>expression that can be conveniently used in message
       formats and such:

           #include &lt;stdio.h&gt;
           #define SD_MESSAGE_COREDUMP_STR SD_ID128_MAKE_STR(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)

           int main(int argc, char **argv) {
             puts("Match for coredumps: MESSAGE_ID=" SD_MESSAGE_COREDUMP_STR);
           }

       <b>SD_ID128_CONST_STR() </b>converts constant IDs into constant strings
       for output. The following example code will output the string
       "fc2e22bc6ee647b6b90729ab34a250b1":

           int main(int argc, char *argv[]) {
             puts("Match for coredumps: %s", SD_ID128_CONST_STR(SD_MESSAGE_COREDUMP));
           }

       <b>SD_ID128_FORMAT_STR </b>and <b>SD_ID128_FORMAT_VAL() </b>is used to format
       an ID in a <a href="printf.3.html">printf(3)</a> format string, as shown in the following
       example:

           int main(int argc, char *argv[]) {
             sd_id128_t id;
             id = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
             printf("The ID encoded in this C file is " SD_ID128_FORMAT_STR ".\n", SD_ID128_FORMAT_VAL(id));
             return 0;
           }

       <b>SD_ID128_UUID_FORMAT_STR </b>and <b>SD_ID128_MAKE_UUID_STR() </b>are similar
       to <b>SD_ID128_FORMAT_STR </b>and <b>SD_ID128_MAKE_STR()</b>, but include
       separating hyphens to conform to the "<b>UUID canonical</b>
       <b>representation</b>[2]". They format the string based on <b>RFC4122</b>[1]
       Variant 1 rules, i.e. converting from Big Endian byte order. This
       matches behaviour of most other Linux userspace infrastructure.
       It's probably best to avoid UUIDs of other variants, in order to
       avoid unnecessary ambiguities. All 128-bit IDs generated by the
       sd-id128 APIs strictly conform to Variant 1 Version 4 UUIDs, as
       per RFC 4122.

       <b>sd_id128_equal() </b>compares two 128-bit IDs:

           int main(int argc, char *argv[]) {
             sd_id128_t a, b, c;
             a = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
             b = SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e);
             c = a;
             assert(sd_id128_equal(a, c));
             assert(!sd_id128_equal(a, b));
             return 0;
           }

       <b>sd_id128_string_equal() </b>is similar to <b>sd_id128_equal()</b>, but the
       first ID is formatted as <b>const char*</b>. The same restrictions apply
       as to the first argument of <b>sd_id128_from_string()</b>.

       <b>sd_id128_is_null() </b>checks if an ID consists of only <b>NUL </b>bytes:

           assert(sd_id128_is_null(SD_ID128_NULL));

       Similarly, <b>sd_id128_is_allf() </b>checks if an ID consists of only
       <b>0xFF </b>bytes (all bits on):

           assert(sd_id128_is_allf(SD_ID128_ALLF));

       <b>sd_id128_in_set_sentinel() </b>takes a list of IDs and returns true
       if the first argument is equal to any of the subsequent
       arguments. The argument list is terminated by an <b>SD_ID128_NULL</b>
       sentinel, which must be present.

       <b>sd_id128_in_set() </b>is a convenience function that takes a list of
       IDs and returns true if the first argument is equal to any of the
       subsequent arguments:

           int main(int argc, char *argv[]) {
             sd_id12_t a = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
             assert(sd_id128_in_set(a, a));
             assert(sd_id128_in_set(a, a, a));
             assert(!sd_id128_in_set(a));
             assert(!sd_id128_in_set(a,
                                     SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e)
                                     SD_ID128_MAKE(2f,88,28,5f,9c,44,09,9d,d7,15,77,04,bc,85,7e,e3)
                                     SD_ID128_ALLF));
             return 0;
           }

       <b>sd_id128_in_set() </b>is defined as a macro over
       <b>sd_id128_in_set_sentinel()</b>, adding the <b>SD_ID128_NULL </b>sentinel
       automatically. Since <b>sd_id128_in_set_sentinel() </b>uses
       <b>SD_ID128_NULL </b>as the sentinel, <b>SD_ID128_NULL </b>cannot be otherwise
       placed in the argument list.

       <b>sd_id128_in_setv() </b>is similar to <b>sd_id128_in_set_sentinel()</b>, but
       takes a struct varargs argument.

       New randomized IDs may be generated with <a href="../man1/systemd-id128.1.html">systemd-id128(1)</a>'s <b>new</b>
       command.

       See <a href="sd_id128_to_string.3.html">sd_id128_to_string(3)</a>, <a href="sd_id128_randomize.3.html">sd_id128_randomize(3)</a> and
       <a href="sd_id128_get_machine.3.html">sd_id128_get_machine(3)</a> for information about other implemented
       functions.
</pre> <h2>
NOTES </h2>
<pre>
       Functions described here are available as a shared library, which
       can be compiled against and linked to with the
       <b>libsystemd pkg-config</b>(1) file.

       The code described here uses <a href="getenv.3.html">getenv(3)</a>, which is declared to be
       not multi-thread-safe. This means that the code calling the
       functions described here must not call <a href="setenv.3.html">setenv(3)</a> from a parallel
       thread. It is recommended to only do calls to <b>setenv() </b>from an
       early phase of the program when no other threads have been
       started.
</pre> <h2>
HISTORY </h2>
<pre>
       <b>sd_id128_equal()</b>, <b>sd_id128_string_equal()</b>, <b>sd_id128_is_null()</b>,
       <b>sd_id128_is_allf()</b>, <b>sd_id128_in_setv()</b>,
       <b>sd_id128_in_set_sentinel()</b>, and <b>sd_id128_in_set() </b>were added in
       version 252.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man1/systemd.1.html">systemd(1)</a>, <a href="sd_id128_to_string.3.html">sd_id128_to_string(3)</a>, <a href="sd_id128_randomize.3.html">sd_id128_randomize(3)</a>,
       <a href="sd_id128_get_machine.3.html">sd_id128_get_machine(3)</a>, <a href="printf.3.html">printf(3)</a>, <a href="../man1/journalctl.1.html">journalctl(1)</a>, <b>sd-journal</b>(7),
       <b>pkg-config</b>(1), <a href="../man5/machine-id.5.html">machine-id(5)</a>
</pre> <h2>
NOTES </h2>
<pre>
        1. RFC 4122
           <a href="https://tools.ietf.org/html/rfc4122">https://tools.ietf.org/html/rfc4122</a>

        2. UUID canonical representation
           <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Format">https://en.wikipedia.org/wiki/Universally_unique_identifier#Format</a>
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>systemd</i> (systemd system and service
       manager) project.  Information about the project can be found at
       ⟨<a href="http://www.freedesktop.org/wiki/Software/systemd">http://www.freedesktop.org/wiki/Software/systemd</a>⟩.  If you have
       a bug report for this manual page, see
       ⟨<a href="http://www.freedesktop.org/wiki/Software/systemd/#bugreports">http://www.freedesktop.org/wiki/Software/systemd/#bugreports</a>⟩.
       This page was obtained from the project's upstream Git repository
       ⟨<a href="https://github.com/systemd/systemd.git">https://github.com/systemd/systemd.git</a>⟩ on 2024-06-14.  (At that
       time, the date of the most recent commit that was found in the
       repository was 2024-06-13.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">systemd 257~devel                                            <i>SD-ID128</i>(3)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/systemd-id128.1.html">systemd-id128(1)</a>, <a href="libsystemd.3.html">libsystemd(3)</a>, <a href="sd_id128_get_machine.3.html">sd_id128_get_machine(3)</a>, <a href="sd_id128_randomize.3.html">sd_id128_randomize(3)</a>, <a href="sd_id128_to_string.3.html">sd_id128_to_string(3)</a>, <a href="sd-journal.3.html">sd-journal(3)</a>, <a href="../man5/machine-id.5.html">machine-id(5)</a>, <a href="../man5/systemd.network.5.html">systemd.network(5)</a>, <a href="../man7/systemd.directives.7.html">systemd.directives(7)</a>, <a href="../man7/systemd.index.7.html">systemd.index(7)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man3/sd_id128_is_allf.3.html" class="_attribution-link">https://man7.org/linux/man-pages/man3/sd_id128_is_allf.3.html</a>
  </p>
</div>
