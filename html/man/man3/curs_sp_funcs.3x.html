<h1>curs_sp_funcs(3x) — Linux manual page</h1>   <pre>
<span class="headline"><i>curs_sp_funcs</i>(3X)                                      <i>curs_sp_funcs</i>(3X)</span>
</pre> <h2>
NAME </h2>
<pre>
       curs_sp_funcs - <b>curses </b>screen-pointer extension
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;curses.h&gt;</b>

       <b>int alloc_pair_sp(SCREEN* </b><i>sp</i><b>, int </b><i>fg</i><b>, int </b><i>bg</i><b>);</b>
       <b>int assume_default_colors_sp(SCREEN* </b><i>sp</i><b>, int </b><i>fg</i><b>, int </b><i>bg</i><b>);</b>
       <b>int baudrate_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int beep_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>bool can_change_color_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int cbreak_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int color_content_sp(SCREEN* </b><i>sp</i><b>, short </b><i>color</i><b>, short* </b><i>r</i><b>, short* </b><i>g</i><b>, short* </b><i>b</i><b>);</b>
       <b>int curs_set_sp(SCREEN* </b><i>sp</i><b>, int </b><i>visibility</i>);
       <b>int def_prog_mode_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int def_shell_mode_sp(SCREEN* </b><i>sp</i><b>);</b>

       <b>int define_key_sp(SCREEN* </b><i>sp</i><b>, const char * </b><i>definition</i><b>, int </b><i>keycode</i><b>);</b>
       <b>int delay_output_sp(SCREEN* </b><i>sp</i><b>, int </b><i>ms</i><b>);</b>
       <b>int doupdate_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int echo_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int endwin_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>char erasechar_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int erasewchar_sp(SCREEN* </b><i>sp</i><b>, wchar_t *</b><i>ch</i><b>);</b>
       <b>int extended_color_content_sp(SCREEN * </b><i>sp</i><b>, int </b><i>color</i><b>, int * </b><i>r</i><b>, int * </b><i>g</i><b>, int * </b><i>b</i><b>);</b>
       <b>int extended_pair_content_sp(SCREEN* </b><i>sp</i><b>, int </b><i>pair</i><b>, int * </b><i>fg</i><b>, int * </b><i>bg</i><b>);</b>
       <b>int extended_slk_color_sp(SCREEN* </b><i>sp</i><b>, int </b><i>pair</i><b>);</b>

       <b>void filter_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int find_pair_sp(SCREEN* </b><i>sp</i><b>, int </b><i>fg</i><b>, int </b><i>bg</i><b>);</b>
       <b>int flash_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int flushinp_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int free_pair_sp(SCREEN* </b><i>sp</i><b>, int </b><i>pair</i><b>);</b>
       <b>int get_escdelay_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int getmouse_sp(SCREEN* </b><i>sp</i><b>, MEVENT* event);</b>
       <b>WINDOW* getwin_sp(SCREEN* </b><i>sp</i><b>, FILE* </b><i>filep</i><b>);</b>
       <b>int halfdelay_sp(SCREEN* </b><i>sp</i><b>, int </b><i>tenths</i><b>);</b>
       <b>bool has_colors_sp(SCREEN* </b><i>sp</i><b>);</b>

       <b>bool has_ic_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>bool has_il_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int has_key_sp(SCREEN* </b><i>sp</i><b>, int </b><i>ch</i><b>);</b>
       <b>bool has_mouse_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int init_color_sp(SCREEN* </b><i>sp</i><b>, short </b><i>color</i><b>, short </b><i>r</i><b>, short </b><i>g</i><b>, short </b><i>b</i><b>);</b>
       <b>int init_extended_color_sp(SCREEN* </b><i>sp</i><b>, int </b><i>color</i><b>, int </b><i>r</i><b>, int </b><i>g</i><b>, int </b><i>b</i><b>);</b>
       <b>int init_extended_pair_sp(SCREEN* </b><i>sp</i><b>, int </b><i>pair</i><b>, int </b><i>fg</i><b>, int </b><i>bg</i><b>);</b>
       <b>int init_pair_sp(SCREEN* </b><i>sp</i><b>, short </b><i>pair</i><b>, short </b><i>fg</i><b>, short </b><i>bg</i><b>);</b>
       <b>int intrflush_sp(SCREEN* </b><i>sp</i><b>, WINDOW* </b><i>win</i><b>, bool </b><i>bf</i><b>);</b>
       <b>bool is_term_resized_sp(SCREEN* </b><i>sp</i><b>, int </b><i>lines</i><b>, int </b><i>columns</i><b>);</b>

       <b>bool isendwin_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int key_defined_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>definition</i><b>);</b>
       <b>char* keybound_sp(SCREEN* </b><i>sp</i><b>, int </b><i>keycode</i><b>, int </b><i>count</i><b>);</b>
       <b>NCURSES_CONST char * keyname_sp(SCREEN* </b><i>sp</i><b>, int </b><i>c</i><b>);</b>
       <b>int keyok_sp(SCREEN* </b><i>sp</i><b>, int </b><i>keycode</i><b>, bool </b><i>enable</i><b>);</b>
       <b>char killchar_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int killwchar_sp(SCREEN* </b><i>sp</i><b>, wchar_t *</b><i>ch</i><b>);</b>
       <b>char* longname_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int mcprint_sp(SCREEN* </b><i>sp</i><b>, char *</b><i>data</i><b>, int </b><i>len</i><b>);</b>
       <b>int mouseinterval_sp(SCREEN* </b><i>sp</i><b>, int </b><i>erval</i><b>);</b>

       <b>mmask_t mousemask_sp(SCREEN* </b><i>sp</i><b>, mmask_t </b><i>newmask</i><b>, mmask_t *</b><i>oldmask</i><b>);</b>
       <b>int mvcur_sp(SCREEN* </b><i>sp</i><b>, int </b><i>oldrow</i><b>, int </b><i>oldcol</i><b>, int </b><i>newrow</i><b>, int </b><i>newcol</i><b>);</b>
       <b>int napms_sp(SCREEN* </b><i>sp</i><b>, int </b><i>ms</i><b>);</b>
       <b>WINDOW* newpad_sp(SCREEN* </b><i>sp</i><b>, int </b><i>nrows</i><b>, int </b><i>ncols</i><b>);</b>
       <b>SCREEN* new_prescr(void);</b>
       <b>SCREEN* newterm_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>type</i><b>, FILE *</b><i>outfd</i><b>, FILE *</b><i>infd</i><b>);</b>
       <b>WINDOW* newwin_sp(SCREEN* </b><i>sp</i><b>, int </b><i>nlines</i><b>, int </b><i>ncols</i><b>, int </b><i>begin_y</i><b>, int </b><i>begin_x</i><b>);</b>
       <b>int nl_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int nocbreak_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int noecho_sp(SCREEN* </b><i>sp</i><b>);</b>

       <b>void nofilter_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int nonl_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>void noqiflush_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int noraw_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int pair_content_sp(SCREEN* </b><i>sp</i><b>, short </b><i>pair</i><b>, short* </b><i>fg</i><b>, short* </b><i>bg</i><b>);</b>
       <b>void qiflush_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int raw_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int reset_prog_mode_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>void reset_color_pairs_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int reset_shell_mode_sp(SCREEN* </b><i>sp</i><b>);</b>

       <b>int resetty_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int resize_term_sp(SCREEN* </b><i>sp</i><b>, int </b><i>lines</i><b>, int </b><i>columns</i><b>);</b>
       <b>int resizeterm_sp(SCREEN* </b><i>sp</i><b>, int </b><i>lines</i><b>, int </b><i>columns</i><b>);</b>
       <b>int ripoffline_sp(SCREEN* </b><i>sp</i><b>, int </b><i>line</i><b>, int (*</b><i>init</i><b>)(WINDOW* </b><i>win</i><b>, int </b><i>fmt</i><b>));</b>
       <b>int savetty_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int scr_init_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>filename</i><b>);</b>
       <b>int scr_restore_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>filename</i><b>);</b>
       <b>int scr_set_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>filename</i><b>);</b>
       <b>int set_escdelay_sp(SCREEN* </b><i>sp</i><b>, int </b><i>ms</i><b>);</b>
       <b>int set_tabsize_sp(SCREEN* </b><i>sp</i><b>, int </b><i>cols</i><b>);</b>

       <b>int slk_attr_set_sp(SCREEN* </b><i>sp</i><b>, const attr_t </b><i>attrs</i><b>, short </b><i>pair</i><b>, void*</b><i>opts</i><b>);</b>
       <b>int slk_attrset_sp(SCREEN* </b><i>sp</i><b>, const chtype </b><i>a</i><b>);</b>
       <b>int slk_attroff_sp(SCREEN* </b><i>sp</i><b>, const chtype </b><i>a</i><b>);</b>
       <b>int slk_attron_sp(SCREEN* </b><i>sp</i><b>, const chtype </b><i>a</i><b>);</b>
       <b>attr_t slk_attr_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int slk_clear_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int slk_color_sp(SCREEN* </b><i>sp</i><b>, short </b><i>pair</i><b>);</b>
       <b>int slk_init_sp(SCREEN* </b><i>sp</i><b>, int </b><i>fmt</i><b>);</b>
       <b>char* slk_label_sp(SCREEN* </b><i>sp</i><b>, int </b><i>labnum</i><b>);</b>
       <b>int slk_noutrefresh_sp(SCREEN* </b><i>sp</i><b>);</b>

       <b>int slk_refresh_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int slk_restore_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int slk_set_sp(SCREEN* </b><i>sp</i><b>, int </b><i>labnum</i><b>, const char * </b><i>label</i><b>, int </b><i>fmt</i><b>);</b>
       <b>int slk_touch_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int start_color_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>attr_t term_attrs_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>chtype termattrs_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>char* termname_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>int typeahead_sp(SCREEN* </b><i>sp</i><b>, int </b><i>fd</i><b>);</b>
       <b>int unget_wch_sp(SCREEN* </b><i>sp</i><b>, const wchar_t </b><i>wch</i><b>);</b>

       <b>int ungetch_sp(SCREEN* </b><i>sp</i><b>, int </b><i>ch</i><b>);</b>
       <b>int ungetmouse_sp(SCREEN* </b><i>sp</i><b>,MEVENT * event);</b>
       <b>int use_default_colors_sp(SCREEN* </b><i>sp</i><b>);</b>
       <b>void use_env_sp(SCREEN* </b><i>sp</i><b>, bool </b><i>bf</i><b>);</b>
       <b>int use_legacy_coding_sp(SCREEN* </b><i>sp</i><b>, int </b><i>level</i><b>);</b>
       <b>void use_tioctl_sp(SCREEN *</b><i>sp</i><b>, bool </b><i>bf</i><b>);</b>
       <b>int vid_attr_sp(SCREEN* </b><i>sp</i><b>, attr_t </b><i>attrs</i><b>, short </b><i>pair</i><b>, void * </b><i>opts</i><b>);</b>
       <b>int vid_puts_sp(SCREEN* </b><i>sp</i><b>, attr_t </b><i>attrs</i><b>, short </b><i>pair</i><b>, void * </b><i>opts</i><b>, NCURSES_SP_OUTC </b><i>putc</i><b>);</b>
       <b>int vidattr_sp(SCREEN* </b><i>sp</i><b>, chtype </b><i>attrs</i><b>);</b>
       <b>int vidputs_sp(SCREEN* </b><i>sp</i><b>, chtype </b><i>attrs</i><b>, NCURSES_SP_OUTC </b><i>putc</i><b>);</b>
       <b>wchar_t* wunctrl_sp(SCREEN* </b><i>sp</i><b>, cchar_t *</b><i>ch</i><b>);</b>

       <b>#include &lt;form.h&gt;</b>

       <b>FORM* new_form_sp(SCREEN* </b><i>sp</i><b>, FIELD **</b><i>fields</i><b>);</b>

       <b>#include &lt;menu.h&gt;</b>

       <b>MENU* new_menu_sp(SCREEN* </b><i>sp</i><b>, ITEM **</b><i>items</i><b>);</b>

       <b>#include &lt;panel.h&gt;</b>

       <b>PANEL* ceiling_panel(SCREEN* </b><i>sp</i><b>);</b>
       <b>PANEL* ground_panel(SCREEN* </b><i>sp</i><b>);</b>
       <b>void update_panels_sp(SCREEN* </b><i>sp</i><b>);</b>

       <b>#include &lt;term.h&gt;</b>

       <b>int del_curterm_sp(SCREEN* </b><i>sp</i><b>, TERMINAL *</b><i>oterm</i><b>);</b>
       <b>int putp_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>str</i><b>);</b>
       <b>int restartterm_sp(SCREEN* </b><i>sp</i><b>, NCURSES_CONST char*</b><i>term</i><b>, int </b><i>filedes</i><b>, int *</b><i>errret</i><b>);</b>
       <b>TERMINAL* set_curterm_sp(SCREEN* </b><i>sp</i><b>, TERMINAL*</b><i>nterm</i><b>);</b>
       <b>int tgetent_sp(SCREEN* </b><i>sp</i><b>, char *</b><i>bp</i><b>, const char *</b><i>name</i><b>);</b>
       <b>int tgetflag_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>capname</i><b>);</b>
       <b>int tgetnum_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>capname</i><b>);</b>
       <b>char* tgetstr_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>capname</i><b>, char **</b><i>area</i><b>);</b>
       <b>char* tgoto_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>capname</i><b>, int </b><i>col</i><b>, int </b><i>row</i><b>);</b>
       <b>int tigetflag_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>capname</i><b>);</b>
       <b>int tigetnum_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>capname</i><b>);</b>
       <b>char* tigetstr_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>capname</i><b>);</b>
       /* may instead use 9 long parameters */
       <b>char* tparm_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>str</i><b>, ...);</b>
       <b>int tputs_sp(SCREEN* </b><i>sp</i><b>, const char *</b><i>str</i><b>, int </b><i>affcnt</i><b>, NCURSES_SP_OUTC </b><i>putc</i><b>);</b>

       <b>#include &lt;unctrl.h&gt;</b>

       <b>NCURSES_CONST char* unctrl_sp(SCREEN* </b><i>sp</i><b>, chtype </b><i>c</i><b>);</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       This  implementation  can be configured to provide a set of func‐
       tions which improve the ability to manage multiple screens.  This
       feature can be added to any of the  configurations  supported  by
       ncurses;  it adds new entrypoints without changing the meaning of
       any of the existing ones.

   <b>IMPROVED FUNCTIONS</b>
       Most of the functions are new versions of existing functions.   A
       parameter  is  added at the front of the parameter list.  It is a
       SCREEN pointer.

       The existing functions all use the current  screen,  which  is  a
       static  variable.   The  extended  functions  use  the  specified
       screen, thereby reducing the number of variables  which  must  be
       modified to update multiple screens.

   <b>NEW FUNCTIONS</b>
       Here are the new functions:

       ceiling_panel
            this returns a pointer to the topmost panel in the given
            screen.

       ground_panel
            this returns a pointer to the lowest panel in the given
            screen.

       new_prescr
            when creating a new screen, the library uses static vari‐
            ables which have been preset, e.g., by <b>use_env</b>(3X), <b>fil‐</b>
            <b>ter</b>(3X), etc.  With the screen-pointer extension, there are
            situations where it must create a current screen before the
            unextended library does.  The <b>new_prescr </b>function is used
            internally to handle these cases.  It is also provided as an
            entrypoint to allow applications to customize the library
            initialization.
</pre> <h2>
NOTES </h2>
<pre>
       This extension introduces some new names:

       NCURSES_SP_FUNCS
            This is set to the library patch-level number.  In the unex‐
            tended library, this is zero (0), to make it useful for
            checking if the extension is provided.

       NCURSES_SP_NAME
            The new functions are named using the macro <i>NCURSES_SP_NAME</i>,
            which hides the actual implementation.  Currently this adds
            a “_sp” suffix to the name of the unextended function.  This
            manual page indexes the extensions showing the full name.
            However the proper usage of these functions uses the macro,
            to provide for the possibility of changing the naming con‐
            vention for specific library configurations.

       NCURSES_SP_OUTC
            This is a new function-pointer type to use in the screen-
            pointer functions where an <i>NCURSES_OUTC</i> is used in the unex‐
            tended library.

       NCURSES_OUTC
            This is a function-pointer type used for the cases where a
            function passes characters to the output stream, e.g., <b>vid‐</b>
            <b>puts</b>(3X).
</pre> <h2>
PORTABILITY </h2>
<pre>
       These routines are specific to ncurses.  They were not supported
       on Version 7, BSD or System V implementations.  It is recommended
       that any code depending on ncurses extensions be conditioned us‐
       ing <i>NCURSES_SP_FUNCS</i>.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <b>curses</b>(3X), <b>curs_opaque</b>(3X), <b>curs_threads</b>(3X).
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>ncurses</i> (new curses) project.  Informa‐
       tion about the project can be found at 
       ⟨<a href="https://www.gnu.org/software/ncurses/ncurses.html">https://www.gnu.org/software/ncurses/ncurses.html</a>⟩.  If you have
       a bug report for this manual page, send it to
       bug-ncurses-request@gnu.org.  This page was obtained from the
       project's upstream Git mirror of the CVS repository
       ⟨<a href="https://github.com/mirror/ncurses.git">https://github.com/mirror/ncurses.git</a>⟩ on 2024-06-14.  (At that
       time, the date of the most recent commit that was found in the
       repository was 2023-03-12.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">                                                       <i>curs_sp_funcs</i>(3X)</span>
</pre>          <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man3/curs_sp_funcs.3x.html" class="_attribution-link">https://man7.org/linux/man-pages/man3/curs_sp_funcs.3x.html</a>
  </p>
</div>
