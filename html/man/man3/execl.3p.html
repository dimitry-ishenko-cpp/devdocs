<h1>exec(3p) — Linux manual page</h1>   <pre>
<span class="headline"><i>EXEC</i>(3P)                POSIX Programmer's Manual               <i>EXEC</i>(3P)</span>
</pre> <h2>
PROLOG </h2>
<pre>
       This manual page is part of the POSIX Programmer's Manual.  The
       Linux implementation of this interface may differ (consult the
       corresponding Linux manual page for details of Linux behavior),
       or the interface may not be implemented on Linux.
</pre> <h2>
NAME </h2>
<pre>
       environ, execl, execle, execlp, execv, execve, execvp, fexecve —
       execute a file
</pre> <h2>
SYNOPSIS </h2>
<pre>
       #include &lt;unistd.h&gt;

       extern char **environ;
       int execl(const char *<i>path</i>, const char *<i>arg0</i>, ... /*, (char *)0 */);
       int execle(const char *<i>path</i>, const char *<i>arg0</i>, ... /*,
           (char *)0, char *const <i>envp</i>[]*/);
       int execlp(const char *<i>file</i>, const char *<i>arg0</i>, ... /*, (char *)0 */);
       int execv(const char *<i>path</i>, char *const <i>argv</i>[]);
       int execve(const char *<i>path</i>, char *const <i>argv</i>[], char *const <i>envp</i>[]);
       int execvp(const char *<i>file</i>, char *const <i>argv</i>[]);
       int fexecve(int <i>fd</i>, char *const <i>argv</i>[], char *const <i>envp</i>[]);
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <i>exec</i> family of functions shall replace the current process
       image with a new process image. The new image shall be
       constructed from a regular, executable file called the <i>new</i>
       <i>process image file</i>.  There shall be no return from a successful
       <i>exec</i>, because the calling process image is overlaid by the new
       process image.

       The <i>fexecve</i>() function shall be equivalent to the <i>execve</i>()
       function except that the file to be executed is determined by the
       file descriptor <i>fd</i> instead of a pathname. The file offset of <i>fd</i>
       is ignored.

       When a C-language program is executed as a result of a call to
       one of the <i>exec</i> family of functions, it shall be entered as a C-
       language function call as follows:

           int main (<i>int argc, char *argv</i>[]);

       where <i>argc</i> is the argument count and <i>argv</i> is an array of
       character pointers to the arguments themselves.  In addition, the
       following variable, which must be declared by the user if it is
       to be used directly:

           extern char **environ;

       is initialized as a pointer to an array of character pointers to
       the environment strings. The <i>argv</i> and <i>environ</i> arrays are each
       terminated by a null pointer. The null pointer terminating the
       <i>argv</i> array is not counted in <i>argc</i>.

       Applications can change the entire environment in a single
       operation by assigning the <i>environ</i> variable to point to an array
       of character pointers to the new environment strings. After
       assigning a new value to <i>environ</i>, applications should not rely on
       the new environment strings remaining part of the environment, as
       a call to <i>getenv</i>(), <i>putenv</i>(), <i>setenv</i>(), <i>unsetenv</i>(), or any
       function that is dependent on an environment variable may, on
       noticing that <i>environ</i> has changed, copy the environment strings
       to a new array and assign <i>environ</i> to point to it.

       Any application that directly modifies the pointers to which the
       <i>environ</i> variable points has undefined behavior.

       Conforming multi-threaded applications shall not use the <i>environ</i>
       variable to access or modify any environment variable while any
       other thread is concurrently modifying any environment variable.
       A call to any function dependent on any environment variable
       shall be considered a use of the <i>environ</i> variable to access that
       environment variable.

       The arguments specified by a program with one of the <i>exec</i>
       functions shall be passed on to the new process image in the
       corresponding <i>main</i>() arguments.

       The argument <i>path</i> points to a pathname that identifies the new
       process image file.

       The argument <i>file</i> is used to construct a pathname that identifies
       the new process image file. If the <i>file</i> argument contains a
       &lt;slash&gt; character, the <i>file</i> argument shall be used as the
       pathname for this file. Otherwise, the path prefix for this file
       is obtained by a search of the directories passed as the
       environment variable <i>PATH</i> (see the Base Definitions volume of
       POSIX.1‐2017, <i>Chapter 8</i>, <i>Environment Variables</i>).  If this
       environment variable is not present, the results of the search
       are implementation-defined.

       There are two distinct ways in which the contents of the process
       image file may cause the execution to fail, distinguished by the
       setting of <i><a href="errno.3.html">errno</a></i> to either <b>[ENOEXEC] </b>or <b>[EINVAL] </b>(see the ERRORS
       section). In the cases where the other members of the <i>exec</i> family
       of functions would fail and set <i><a href="errno.3.html">errno</a></i> to <b>[ENOEXEC]</b>, the <i>execlp</i>()
       and <i>execvp</i>() functions shall execute a command interpreter and
       the environment of the executed command shall be as if the
       process invoked the <i>sh</i> utility using <i>execl</i>() as follows:

           execl(&lt;shell path&gt;, arg0, file, arg1, ..., (char *)0);

       where &lt;<i>shell path</i>&gt; is an unspecified pathname for the <i>sh</i> utility,
       <i>file</i> is the process image file, and for <i>execvp</i>(), where <i>arg</i>0,
       <i>arg</i>1, and so on correspond to the values passed to <i>execvp</i>() in
       <i>argv</i>[0], <i>argv</i>[1], and so on.

       The arguments represented by <i>arg0</i>,...  are pointers to null-
       terminated character strings. These strings shall constitute the
       argument list available to the new process image. The list is
       terminated by a null pointer. The argument <i>arg0</i> should point to a
       filename string that is associated with the process being started
       by one of the <i>exec</i> functions.

       The argument <i>argv</i> is an array of character pointers to null-
       terminated strings. The application shall ensure that the last
       member of this array is a null pointer. These strings shall
       constitute the argument list available to the new process image.
       The value in <i>argv</i>[0] should point to a filename string that is
       associated with the process being started by one of the <i>exec</i>
       functions.

       The argument <i>envp</i> is an array of character pointers to null-
       terminated strings. These strings shall constitute the
       environment for the new process image.  The <i>envp</i> array is
       terminated by a null pointer.

       For those forms not containing an <i>envp</i> pointer (<i>execl</i>(), <i>execv</i>(),
       <i>execlp</i>(), and <i>execvp</i>()), the environment for the new process
       image shall be taken from the external variable <i>environ</i> in the
       calling process.

       The number of bytes available for the new process' combined
       argument and environment lists is {ARG_MAX}.  It is
       implementation-defined whether null terminators, pointers, and/or
       any alignment bytes are included in this total.

       File descriptors open in the calling process image shall remain
       open in the new process image, except for those whose close-on-
       <i>exec</i> flag FD_CLOEXEC is set.  For those file descriptors that
       remain open, all attributes of the open file description remain
       unchanged. For any file descriptor that is closed for this
       reason, file locks are removed as a result of the close as
       described in <i>close</i>().  Locks that are not removed by closing of
       file descriptors remain unchanged.

       If file descriptor 0, 1, or 2 would otherwise be closed after a
       successful call to one of the <i>exec</i> family of functions,
       implementations may open an unspecified file for the file
       descriptor in the new process image. If a standard utility or a
       conforming application is executed with file descriptor 0 not
       open for reading or with file descriptor 1 or 2 not open for
       writing, the environment in which the utility or application is
       executed shall be deemed non-conforming, and consequently the
       utility or application might not behave as described in this
       standard.

       Directory streams open in the calling process image shall be
       closed in the new process image.

       The state of the floating-point environment in the initial thread
       of the new process image shall be set to the default.

       The state of conversion descriptors and message catalog
       descriptors in the new process image is undefined.

       For the new process image, the equivalent of:

           setlocale(LC_ALL, "C")

       shall be executed at start-up.

       Signals set to the default action (SIG_DFL) in the calling
       process image shall be set to the default action in the new
       process image.  Except for SIGCHLD, signals set to be ignored
       (SIG_IGN) by the calling process image shall be set to be ignored
       by the new process image. Signals set to be caught by the calling
       process image shall be set to the default action in the new
       process image (see <i>&lt;signal.h&gt;</i>).

       If the SIGCHLD signal is set to be ignored by the calling process
       image, it is unspecified whether the SIGCHLD signal is set to be
       ignored or to the default action in the new process image.

       After a successful call to any of the <i>exec</i> functions, alternate
       signal stacks are not preserved and the SA_ONSTACK flag shall be
       cleared for all signals.

       After a successful call to any of the <i>exec</i> functions, any
       functions previously registered by the <i>atexit</i>() or
       <i>pthread_atfork</i>() functions are no longer registered.

       If the ST_NOSUID bit is set for the file system containing the
       new process image file, then the effective user ID, effective
       group ID, saved set-user-ID, and saved set-group-ID are unchanged
       in the new process image. Otherwise, if the set-user-ID mode bit
       of the new process image file is set, the effective user ID of
       the new process image shall be set to the user ID of the new
       process image file. Similarly, if the set-group-ID mode bit of
       the new process image file is set, the effective group ID of the
       new process image shall be set to the group ID of the new process
       image file. The real user ID, real group ID, and supplementary
       group IDs of the new process image shall remain the same as those
       of the calling process image. The effective user ID and effective
       group ID of the new process image shall be saved (as the saved
       set-user-ID and the saved set-group-ID) for use by <i>setuid</i>().

       Any shared memory segments attached to the calling process image
       shall not be attached to the new process image.

       Any named semaphores open in the calling process shall be closed
       as if by appropriate calls to <i>sem_close</i>().

       Any blocks of typed memory that were mapped in the calling
       process are unmapped, as if <i>munmap</i>() was implicitly called to
       unmap them.

       Memory locks established by the calling process via calls to
       <i>mlockall</i>() or <i>mlock</i>() shall be removed. If locked pages in the
       address space of the calling process are also mapped into the
       address spaces of other processes and are locked by those
       processes, the locks established by the other processes shall be
       unaffected by the call by this process to the <i>exec</i> function. If
       the <i>exec</i> function fails, the effect on memory locks is
       unspecified.

       Memory mappings created in the process are unmapped before the
       address space is rebuilt for the new process image.

       When the calling process image does not use the SCHED_FIFO,
       SCHED_RR, or SCHED_SPORADIC scheduling policies, the scheduling
       policy and parameters of the new process image and the initial
       thread in that new process image are implementation-defined.

       When the calling process image uses the SCHED_FIFO, SCHED_RR, or
       SCHED_SPORADIC scheduling policies, the process policy and
       scheduling parameter settings shall not be changed by a call to
       an <i>exec</i> function.  The initial thread in the new process image
       shall inherit the process scheduling policy and parameters. It
       shall have the default system contention scope, but shall inherit
       its allocation domain from the calling process image.

       Per-process timers created by the calling process shall be
       deleted before replacing the current process image with the new
       process image.

       All open message queue descriptors in the calling process shall
       be closed, as described in <i>mq_close</i>().

       Any outstanding asynchronous I/O operations may be canceled.
       Those asynchronous I/O operations that are not canceled shall
       complete as if the <i>exec</i> function had not yet occurred, but any
       associated signal notifications shall be suppressed. It is
       unspecified whether the <i>exec</i> function itself blocks awaiting such
       I/O completion. In no event, however, shall the new process image
       created by the <i>exec</i> function be affected by the presence of
       outstanding asynchronous I/O operations at the time the <i>exec</i>
       function is called. Whether any I/O is canceled, and which I/O
       may be canceled upon <i>exec</i>, is implementation-defined.

       The new process image shall inherit the CPU-time clock of the
       calling process image. This inheritance means that the process
       CPU-time clock of the process being <i>exec</i>-ed shall not be
       reinitialized or altered as a result of the <i>exec</i> function other
       than to reflect the time spent by the process executing the <i>exec</i>
       function itself.

       The initial value of the CPU-time clock of the initial thread of
       the new process image shall be set to zero.

       If the calling process is being traced, the new process image
       shall continue to be traced into the same trace stream as the
       original process image, but the new process image shall not
       inherit the mapping of trace event names to trace event type
       identifiers that was defined by calls to the
       <i>posix_trace_eventid_open</i>() or the <i>posix_trace_trid_eventid_open</i>()
       functions in the calling process image.

       If the calling process is a trace controller process, any trace
       streams that were created by the calling process shall be shut
       down as described in the <i>posix_trace_shutdown</i>() function.

       The thread ID of the initial thread in the new process image is
       unspecified.

       The size and location of the stack on which the initial thread in
       the new process image runs is unspecified.

       The initial thread in the new process image shall have its
       cancellation type set to PTHREAD_CANCEL_DEFERRED and its
       cancellation state set to PTHREAD_CANCEL_ENABLED.

       The initial thread in the new process image shall have all
       thread-specific data values set to NULL and all thread-specific
       data keys shall be removed by the call to <i>exec</i> without running
       destructors.

       The initial thread in the new process image shall be joinable, as
       if created with the <i>detachstate</i> attribute set to
       PTHREAD_CREATE_JOINABLE.

       The new process shall inherit at least the following attributes
       from the calling process image:

        *  Nice value (see <i>nice</i>())

        *  <i>semadj</i> values (see <i>semop</i>())

        *  Process ID

        *  Parent process ID

        *  Process group ID

        *  Session membership

        *  Real user ID

        *  Real group ID

        *  Supplementary group IDs

        *  Time left until an alarm clock signal (see <i>alarm</i>())

        *  Current working directory

        *  Root directory

        *  File mode creation mask (see <i>umask</i>())

        *  File size limit (see <i>getrlimit</i>() and <i>setrlimit</i>())

        *  Process signal mask (see <i>pthread_sigmask</i>())

        *  Pending signal (see <i>sigpending</i>())

        *  <i>tms_utime</i>, <i>tms_stime</i>, <i>tms_cutime</i>, and <i>tms_cstime</i> (see
           <i>times</i>())

        *  Resource limits

        *  Controlling terminal

        *  Interval timers

       The initial thread of the new process shall inherit at least the
       following attributes from the calling thread:

        *  Signal mask (see <i>sigprocmask</i>() and <i>pthread_sigmask</i>())

        *  Pending signals (see <i>sigpending</i>())

       All other process attributes defined in this volume of
       POSIX.1‐2017 shall be inherited in the new process image from the
       old process image. All other thread attributes defined in this
       volume of POSIX.1‐2017 shall be inherited in the initial thread
       in the new process image from the calling thread in the old
       process image.  The inheritance of process or thread attributes
       not defined by this volume of POSIX.1‐2017 is implementation-
       defined.

       A call to any <i>exec</i> function from a process with more than one
       thread shall result in all threads being terminated and the new
       executable image being loaded and executed. No destructor
       functions or cleanup handlers shall be called.

       Upon successful completion, the <i>exec</i> functions shall mark for
       update the last data access timestamp of the file. If an <i>exec</i>
       function failed but was able to locate the process image file,
       whether the last data access timestamp is marked for update is
       unspecified. Should the <i>exec</i> function succeed, the process image
       file shall be considered to have been opened with <i>open</i>().  The
       corresponding <i>close</i>() shall be considered to occur at a time
       after this open, but before process termination or successful
       completion of a subsequent call to one of the <i>exec</i> functions,
       <i>posix_spawn</i>(), or <i>posix_spawnp</i>().  The <i>argv</i>[] and <i>envp</i>[] arrays
       of pointers and the strings to which those arrays point shall not
       be modified by a call to one of the <i>exec</i> functions, except as a
       consequence of replacing the process image.

       The saved resource limits in the new process image are set to be
       a copy of the process' corresponding hard and soft limits.
</pre> <h2>
RETURN VALUE </h2>
<pre>
       If one of the <i>exec</i> functions returns to the calling process
       image, an error has occurred; the return value shall be -1, and
       <i><a href="errno.3.html">errno</a></i> shall be set to indicate the error.
</pre> <h2>
ERRORS </h2>
<pre>
       The <i>exec</i> functions shall fail if:

       <b>E2BIG  </b>The number of bytes used by the new process image's
              argument list and environment list is greater than the
              system-imposed limit of {ARG_MAX} bytes.

       <b>EACCES </b>The new process image file is not a regular file and the
              implementation does not support execution of files of its
              type.

       <b>EINVAL </b>The new process image file has appropriate privileges and
              has a recognized executable binary format, but the system
              does not support execution of a file with this format.

       The <i>exec</i> functions, except for <i>fexecve</i>(), shall fail if:

       <b>EACCES </b>Search permission is denied for a directory listed in the
              new process image file's path prefix, or the new process
              image file denies execution permission.

       <b>ELOOP  </b>A loop exists in symbolic links encountered during
              resolution of the <i>path</i> or <i>file</i> argument.

       <b>ENAMETOOLONG</b>
              The length of a component of a pathname is longer than
              {NAME_MAX}.

       <b>ENOENT </b>A component of <i>path</i> or <i>file</i> does not name an existing file
              or <i>path</i> or <i>file</i> is an empty string.

       <b>ENOTDIR</b>
              A component of the new process image file's path prefix
              names an existing file that is neither a directory nor a
              symbolic link to a directory, or the new process image
              file's pathname contains at least one non-&lt;slash&gt;
              character and ends with one or more trailing &lt;slash&gt;
              characters and the last pathname component names an
              existing file that is neither a directory nor a symbolic
              link to a directory.

       The <i>exec</i> functions, except for <i>execlp</i>() and <i>execvp</i>(), shall fail
       if:

       <b>ENOEXEC</b>
              The new process image file has the appropriate access
              permission but has an unrecognized format.

       The <i>fexecve</i>() function shall fail if:

       <b>EBADF  </b>The <i>fd</i> argument is not a valid file descriptor open for
              executing.

       The <i>exec</i> functions may fail if:

       <b>ENOMEM </b>The new process image requires more memory than is allowed
              by the hardware or system-imposed memory management
              constraints.

       The <i>exec</i> functions, except for <i>fexecve</i>(), may fail if:

       <b>ELOOP  </b>More than {SYMLOOP_MAX} symbolic links were encountered
              during resolution of the <i>path</i> or <i>file</i> argument.

       <b>ENAMETOOLONG</b>
              The length of the <i>path</i> argument or the length of the
              pathname constructed from the <i>file</i> argument exceeds
              {PATH_MAX}, or pathname resolution of a symbolic link
              produced an intermediate result with a length that exceeds
              {PATH_MAX}.

       <b>ETXTBSY</b>
              The new process image file is a pure procedure (shared
              text) file that is currently open for writing by some
              process.

       <i>The following sections are informative.</i>
</pre> <h2>
EXAMPLES </h2>
<pre>
   <b>Using execl()</b>
       The following example executes the <i>ls</i> command, specifying the
       pathname of the executable (<b>/bin/ls</b>) and using arguments supplied
       directly to the command to produce single-column output.

           #include &lt;unistd.h&gt;

           int ret;
           ...
           ret = execl ("/bin/ls", "ls", "-1", (char *)0);

   <b>Using execle()</b>
       The following example is similar to <i>Using execl()</i>.  In addition,
       it specifies the environment for the new process image using the
       <i>env</i> argument.

           #include &lt;unistd.h&gt;

           int ret;
           char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
           ...
           ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);

   <b>Using execlp()</b>
       The following example searches for the location of the <i>ls</i> command
       among the directories specified by the <i>PATH</i> environment variable.

           #include &lt;unistd.h&gt;

           int ret;
           ...
           ret = execlp ("ls", "ls", "-l", (char *)0);

   <b>Using execv()</b>
       The following example passes arguments to the <i>ls</i> command in the
       <i>cmd</i> array.

           #include &lt;unistd.h&gt;

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           ...
           ret = execv ("/bin/ls", cmd);

   <b>Using execve()</b>
       The following example passes arguments to the <i>ls</i> command in the
       <i>cmd</i> array, and specifies the environment for the new process
       image using the <i>env</i> argument.

           #include &lt;unistd.h&gt;

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
           ...
           ret = execve ("/bin/ls", cmd, env);

   <b>Using execvp()</b>
       The following example searches for the location of the <i>ls</i> command
       among the directories specified by the <i>PATH</i> environment variable,
       and passes arguments to the <i>ls</i> command in the <i>cmd</i> array.

           #include &lt;unistd.h&gt;

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           ...
           ret = execvp ("ls", cmd);
</pre> <h2>
APPLICATION USAGE </h2>
<pre>
       As the state of conversion descriptors and message catalog
       descriptors in the new process image is undefined, conforming
       applications should not rely on their use and should close them
       prior to calling one of the <i>exec</i> functions.

       Applications that require other than the default POSIX locale as
       the global locale in the new process image should call
       <i>setlocale</i>() with the appropriate parameters.

       When assigning a new value to the <i>environ</i> variable, applications
       should ensure that the environment to which it will point
       contains at least the following:

        1. Any implementation-defined variables required by the
           implementation to provide a conforming environment. See the
           _CS_V7_ENV entry in <i>&lt;unistd.h&gt;</i> and <i>confstr</i>() for details.

        2. A value for <i>PATH</i> which finds conforming versions of all
           standard utilities before any other versions.

       The same constraint applies to the <i>envp</i> array passed to <i>execle</i>()
       or <i>execve</i>(), in order to ensure that the new process image is
       invoked in a conforming environment.

       Applications should not execute programs with file descriptor 0
       not open for reading or with file descriptor 1 or 2 not open for
       writing, as this might cause the executed program to misbehave.
       In order not to pass on these file descriptors to an executed
       program, applications should not just close them but should
       reopen them on, for example, <b>/dev/null</b>.  Some implementations may
       reopen them automatically, but applications should not rely on
       this being done.

       If an application wants to perform a checksum test of the file
       being executed before executing it, the file will need to be
       opened with read permission to perform the checksum test.

       Since execute permission is checked by <i>fexecve</i>(), the file
       description <i>fd</i> need not have been opened with the O_EXEC flag.
       However, if the file to be executed denies read and write
       permission for the process preparing to do the <i>exec</i>, the only way
       to provide the <i>fd</i> to <i>fexecve</i>() will be to use the O_EXEC flag
       when opening <i>fd</i>.  In this case, the application will not be able
       to perform a checksum test since it will not be able to read the
       contents of the file.

       Note that when a file descriptor is opened with O_RDONLY, O_RDWR,
       or O_WRONLY mode, the file descriptor can be used to read, read
       and write, or write the file, respectively, even if the mode of
       the file changes after the file was opened. Using the O_EXEC open
       mode is different; <i>fexecve</i>() will ignore the mode that was used
       when the file descriptor was opened and the <i>exec</i> will fail if the
       mode of the file associated with <i>fd</i> does not grant execute
       permission to the calling process at the time <i>fexecve</i>() is
       called.
</pre> <h2>
RATIONALE </h2>
<pre>
       Early proposals required that the value of <i>argc</i> passed to <i>main</i>()
       be ``one or greater''. This was driven by the same requirement in
       drafts of the ISO C standard.  In fact, historical
       implementations have passed a value of zero when no arguments are
       supplied to the caller of the <i>exec</i> functions. This requirement
       was removed from the ISO C standard and subsequently removed from
       this volume of POSIX.1‐2017 as well. The wording, in particular
       the use of the word <i>should</i>, requires a Strictly Conforming POSIX
       Application to pass at least one argument to the <i>exec</i> function,
       thus guaranteeing that <i>argc</i> be one or greater when invoked by
       such an application. In fact, this is good practice, since many
       existing applications reference <i>argv</i>[0] without first checking
       the value of <i>argc</i>.

       The requirement on a Strictly Conforming POSIX Application also
       states that the value passed as the first argument be a filename
       string associated with the process being started. Although some
       existing applications pass a pathname rather than a filename
       string in some circumstances, a filename string is more generally
       useful, since the common usage of <i>argv</i>[0] is in printing
       diagnostics. In some cases the filename passed is not the actual
       filename of the file; for example, many implementations of the
       <i>login</i> utility use a convention of prefixing a &lt;hyphen-minus&gt;
       (<b>'‐'</b>) to the actual filename, which indicates to the command
       interpreter being invoked that it is a ``login shell''.

       Also, note that the <i>test</i> and <i>[</i> utilities require specific strings
       for the <i>argv</i>[0] argument to have deterministic behavior across
       all implementations.

       Historically, there have been two ways that implementations can
       <i>exec</i> shell scripts.

       One common historical implementation is that the <i>execl</i>(),
       <i>execv</i>(), <i>execle</i>(), and <i>execve</i>() functions return an <b>[ENOEXEC]</b>
       error for any file not recognizable as executable, including a
       shell script. When the <i>execlp</i>() and <i>execvp</i>() functions encounter
       such a file, they assume the file to be a shell script and invoke
       a known command interpreter to interpret such files.  This is now
       required by POSIX.1‐2008. These implementations of <i>execvp</i>() and
       <i>execlp</i>() only give the <b>[ENOEXEC] </b>error in the rare case of a
       problem with the command interpreter's executable file. Because
       of these implementations, the <b>[ENOEXEC] </b>error is not mentioned
       for <i>execlp</i>() or <i>execvp</i>(), although implementations can still give
       it.

       Another way that some historical implementations handle shell
       scripts is by recognizing the first two bytes of the file as the
       character string <b>"#!" </b>and using the remainder of the first line
       of the file as the name of the command interpreter to execute.

       One potential source of confusion noted by the standard
       developers is over how the contents of a process image file
       affect the behavior of the <i>exec</i> family of functions. The
       following is a description of the actions taken:

        1. If the process image file is a valid executable (in a format
           that is executable and valid and having appropriate
           privileges) for this system, then the system executes the
           file.

        2. If the process image file has appropriate privileges and is
           in a format that is executable but not valid for this system
           (such as a recognized binary for another architecture), then
           this is an error and <i><a href="errno.3.html">errno</a></i> is set to <b>[EINVAL] </b>(see later
           RATIONALE on <b>[EINVAL]</b>).

        3. If the process image file has appropriate privileges but is
           not otherwise recognized:

            a. If this is a call to <i>execlp</i>() or <i>execvp</i>(), then they
               invoke a command interpreter assuming that the process
               image file is a shell script.

            b. If this is not a call to <i>execlp</i>() or <i>execvp</i>(), then an
               error occurs and <i><a href="errno.3.html">errno</a></i> is set to <b>[ENOEXEC]</b>.

       Applications that do not require to access their arguments may
       use the form:

           main(void)

       as specified in the ISO C standard. However, the implementation
       will always provide the two arguments <i>argc</i> and <i>argv</i>, even if they
       are not used.

       Some implementations provide a third argument to <i>main</i>() called
       <i>envp</i>.  This is defined as a pointer to the environment. The ISO C
       standard specifies invoking <i>main</i>() with two arguments, so
       implementations must support applications written this way. Since
       this volume of POSIX.1‐2017 defines the global variable <i>environ</i>,
       which is also provided by historical implementations and can be
       used anywhere that <i>envp</i> could be used, there is no functional
       need for the <i>envp</i> argument. Applications should use the <i>getenv</i>()
       function rather than accessing the environment directly via
       either <i>envp</i> or <i>environ</i>.  Implementations are required to support
       the two-argument calling sequence, but this does not prohibit an
       implementation from supporting <i>envp</i> as an optional third
       argument.

       This volume of POSIX.1‐2017 specifies that signals set to SIG_IGN
       remain set to SIG_IGN, and that the new process image inherits
       the signal mask of the thread that called <i>exec</i> in the old process
       image. This is consistent with historical implementations, and it
       permits some useful functionality, such as the <i>nohup</i> command.
       However, it should be noted that many existing applications
       wrongly assume that they start with certain signals set to the
       default action and/or unblocked. In particular, applications
       written with a simpler signal model that does not include
       blocking of signals, such as the one in the ISO C standard, may
       not behave properly if invoked with some signals blocked.
       Therefore, it is best not to block or ignore signals across <i>exec</i>s
       without explicit reason to do so, and especially not to block
       signals across <i>exec</i>s of arbitrary (not closely cooperating)
       programs.

       The <i>exec</i> functions always save the value of the effective user ID
       and effective group ID of the process at the completion of the
       <i>exec</i>, whether or not the set-user-ID or the set-group-ID bit of
       the process image file is set.

       The statement about <i>argv</i>[] and <i>envp</i>[] being constants is included
       to make explicit to future writers of language bindings that
       these objects are completely constant. Due to a limitation of the
       ISO C standard, it is not possible to state that idea in standard
       C. Specifying two levels of <i>const</i>-<i>qualification</i> for the <i>argv</i>[]
       and <i>envp</i>[] parameters for the <i>exec</i> functions may seem to be the
       natural choice, given that these functions do not modify either
       the array of pointers or the characters to which the function
       points, but this would disallow existing correct code.  Instead,
       only the array of pointers is noted as constant. The table of
       assignment compatibility for <i>dst</i>=<i>src</i> derived from the ISO C
       standard summarizes the compatibility:
┌─────────────────────┬──────────┬────────────────┬───────────────┬─────────────────────┐
│                <i>dst</i>: │ <b>char *[] </b>│ <b>const char *[] </b>│ <b>char *const[] </b>│ <b>const char *const[] </b>│
├─────────────────────┼──────────┼────────────────┼───────────────┼─────────────────────┤
│ <i>src</i><b>:                </b>│          │                │               │                     │
│ <b>char *[]            </b>│  VALID   │       —        │     VALID     │          —          │
│ <b>const char *[]      </b>│    —     │     VALID      │       —       │        VALID        │
│ <b>char * const []     </b>│    —     │       —        │     VALID     │          —          │
│ <b>const char *const[] </b>│    —     │       —        │       —       │        VALID        │
└─────────────────────┴──────────┴────────────────┴───────────────┴─────────────────────┘

       Since all existing code has a source type matching the first row,
       the column that gives the most valid combinations is the third
       column. The only other possibility is the fourth column, but
       using it would require a cast on the <i>argv</i> or <i>envp</i> arguments. It
       is unfortunate that the fourth column cannot be used, because the
       declaration a non-expert would naturally use would be that in the
       second row.

       The ISO C standard and this volume of POSIX.1‐2017 do not
       conflict on the use of <i>environ</i>, but some historical
       implementations of <i>environ</i> may cause a conflict. As long as
       <i>environ</i> is treated in the same way as an entry point (for
       example, <i>fork</i>()), it conforms to both standards. A library can
       contain <i>fork</i>(), but if there is a user-provided <i>fork</i>(), that
       <i>fork</i>() is given precedence and no problem ensues. The situation
       is similar for <i>environ</i>: the definition in this volume of
       POSIX.1‐2017 is to be used if there is no user-provided <i>environ</i>
       to take precedence. At least three implementations are known to
       exist that solve this problem.

       <b>E2BIG  </b>The limit {ARG_MAX} applies not just to the size of the
              argument list, but to the sum of that and the size of the
              environment list.

       <b>EFAULT </b>Some historical systems return <b>[EFAULT] </b>rather than
              <b>[ENOEXEC] </b>when the new process image file is corrupted.
              They are non-conforming.

       <b>EINVAL </b>This error condition was added to POSIX.1‐2008 to allow an
              implementation to detect executable files generated for
              different architectures, and indicate this situation to
              the application. Historical implementations of shells,
              <i>execvp</i>(), and <i>execlp</i>() that encounter an <b>[ENOEXEC] </b>error
              will execute a shell on the assumption that the file is a
              shell script. This will not produce the desired effect
              when the file is a valid executable for a different
              architecture. An implementation may now choose to avoid
              this problem by returning <b>[EINVAL] </b>when a valid executable
              for a different architecture is encountered.  Some
              historical implementations return <b>[EINVAL] </b>to indicate
              that the <i>path</i> argument contains a character with the high
              order bit set. The standard developers chose to deviate
              from historical practice for the following reasons:

                    1. The new utilization of <b>[EINVAL] </b>will provide some
                       measure of utility to the user community.

                    2. Historical use of <b>[EINVAL] </b>is not acceptable in
                       an internationalized operating environment.

       <b>ENAMETOOLONG</b>
              Since the file pathname may be constructed by taking
              elements in the <i>PATH</i> variable and putting them together
              with the filename, the <b>[ENAMETOOLONG] </b>error condition
              could also be reached this way.

       <b>ETXTBSY</b>
              System V returns this error when the executable file is
              currently open for writing by some process. This volume of
              POSIX.1‐2017 neither requires nor prohibits this behavior.

       Other systems (such as System V) may return <b>[EINTR] </b>from <i>exec</i>.
       This is not addressed by this volume of POSIX.1‐2017, but
       implementations may have a window between the call to <i>exec</i> and
       the time that a signal could cause one of the <i>exec</i> calls to
       return with <b>[EINTR]</b>.

       An explicit statement regarding the floating-point environment
       (as defined in the <i>&lt;fenv.h&gt;</i> header) was added to make it clear
       that the floating-point environment is set to its default when a
       call to one of the <i>exec</i> functions succeeds. The requirements for
       inheritance or setting to the default for other process and
       thread start-up functions is covered by more generic statements
       in their descriptions and can be summarized as follows:

       <i>posix_spawn (3p) 14</i>
              Set to default.

       <i>fork (3p) 14</i>
              Inherit.

       <i>pthread_create (3p) 14</i>
              Inherit.

       The purpose of the <i>fexecve</i>() function is to enable executing a
       file which has been verified to be the intended file. It is
       possible to actively check the file by reading from the file
       descriptor and be sure that the file is not exchanged for another
       between the reading and the execution. Alternatively, a function
       like <i>openat</i>() can be used to open a file which has been found by
       reading the content of a directory using <i>readdir</i>().
</pre> <h2>
FUTURE DIRECTIONS </h2>
<pre>
       None.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="alarm.3p.html">alarm(3p)</a>, <a href="atexit.3p.html">atexit(3p)</a>, <a href="chmod.3p.html">chmod(3p)</a>, <a href="close.3p.html">close(3p)</a>, <a href="confstr.3p.html">confstr(3p)</a>,
       <a href="exit.3p.html">exit(3p)</a>, <a href="fcntl.3p.html">fcntl(3p)</a>, <a href="fork.3p.html">fork(3p)</a>, <a href="fstatvfs.3p.html">fstatvfs(3p)</a>, <a href="getenv.3p.html">getenv(3p)</a>,
       <a href="getitimer.3p.html">getitimer(3p)</a>, <a href="getrlimit.3p.html">getrlimit(3p)</a>, <a href="mknod.3p.html">mknod(3p)</a>, <a href="mmap.3p.html">mmap(3p)</a>, <a href="nice.3p.html">nice(3p)</a>,
       <a href="open.3p.html">open(3p)</a>, <a href="posix_spawn.3p.html">posix_spawn(3p)</a>, <a href="posix_trace_create.3p.html">posix_trace_create(3p)</a>,
       <a href="posix_trace_event.3p.html">posix_trace_event(3p)</a>, <a href="posix_trace_eventid_equal.3p.html">posix_trace_eventid_equal(3p)</a>,
       <a href="pthread_atfork.3p.html">pthread_atfork(3p)</a>, <a href="pthread_sigmask.3p.html">pthread_sigmask(3p)</a>, <a href="putenv.3p.html">putenv(3p)</a>, <a href="readdir.3p.html">readdir(3p)</a>,
       <a href="semop.3p.html">semop(3p)</a>, <a href="setlocale.3p.html">setlocale(3p)</a>, <a href="shmat.3p.html">shmat(3p)</a>, <a href="sigaction.3p.html">sigaction(3p)</a>,
       <a href="sigaltstack.3p.html">sigaltstack(3p)</a>, <a href="sigpending.3p.html">sigpending(3p)</a>, <a href="system.3p.html">system(3p)</a>, <a href="times.3p.html">times(3p)</a>,
       <a href="ulimit.3p.html">ulimit(3p)</a>, <a href="umask.3p.html">umask(3p)</a>

       The   Base   Definitions   volume  of  POSIX.1‐2017,  <i>Chapter</i>  <i>8</i>,
       <i>Environment Variables</i>, <a href="../man0/unistd.h.0p.html">unistd.h(0p)</a>

       The Shell and Utilities volume of POSIX.1‐2017, <a href="../man1/test.1p.html">test(1p)</a>
</pre> <h2>
COPYRIGHT </h2>
<pre>
       Portions of this text are reprinted and reproduced in  electronic
       form   from   IEEE  Std  1003.1-2017,  Standard  for  Information
       Technology -- Portable Operating System  Interface  (POSIX),  The
       Open  Group  Base Specifications Issue 7, 2018 Edition, Copyright
       (C)  2018  by  the  Institute  of  Electrical   and   Electronics
       Engineers,  Inc  and  The  Open  Group.   In  the  event  of  any
       discrepancy between this version and the original  IEEE  and  The
       Open  Group  Standard,  the  original  IEEE  and  The  Open Group
       Standard is the referee document. The original  Standard  can  be
       obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page
       are most likely to have been introduced during the conversion  of
       the  source  files to man page format. To report such errors, see
       <a href="https://www.kernel.org/doc/man-pages/reporting_bugs.html">https://www.kernel.org/doc/man-pages/reporting_bugs.html</a> .

<span class="footline">IEEE/The Open Group               2017                          <i>EXEC</i>(3P)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/env.1.html">env(1)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man3/execl.3p.html" class="_attribution-link">https://man7.org/linux/man-pages/man3/execl.3p.html</a>
  </p>
</div>
