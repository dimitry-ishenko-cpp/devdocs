<h1>sd_notify(3) — Linux manual page</h1>   <pre>
<span class="headline"><i>SD_NOTIFY</i>(3)                    sd_notify                   <i>SD_NOTIFY</i>(3)</span>
</pre> <h2>
NAME </h2>
<pre>
       sd_notify, sd_notifyf, sd_pid_notify, sd_pid_notifyf,
       sd_pid_notify_with_fds, sd_pid_notifyf_with_fds,
       sd_notify_barrier, sd_pid_notify_barrier - Notify service manager
       about start-up completion and other service status changes
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;systemd/sd-daemon.h&gt;</b>

       <b>int sd_notify(int </b><i>unset_environment</i><b>, const char *</b><i>state</i><b>);</b>

       <b>int sd_notifyf(int </b><i>unset_environment</i><b>, const char *</b><i>format</i><b>, ...);</b>

       <b>int sd_pid_notify(pid_t </b><i>pid</i><b>, int </b><i>unset_environment</i><b>,</b>
                         <b>const char *</b><i>state</i><b>);</b>

       <b>int sd_pid_notifyf(pid_t </b><i>pid</i><b>, int </b><i>unset_environment</i><b>,</b>
                          <b>const char *</b><i>format</i><b>, ...);</b>

       <b>int sd_pid_notify_with_fds(pid_t </b><i>pid</i><b>, int </b><i>unset_environment</i><b>,</b>
                                  <b>const char *</b><i>state</i><b>, const int *</b><i>fds</i><b>,</b>
                                  <b>unsigned </b><i>n_fds</i><b>);</b>

       <b>int sd_pid_notifyf_with_fds(pid_t </b><i>pid</i><b>, int </b><i>unset_environment</i><b>,</b>
                                   <b>const int *</b><i>fds</i><b>, size_t </b><i>n_fds</i><b>,</b>
                                   <b>const char *</b><i>format</i><b>, ...);</b>

       <b>int sd_notify_barrier(int </b><i>unset_environment</i><b>, uint64_t </b><i>timeout</i><b>);</b>

       <b>int sd_pid_notify_barrier(pid_t </b><i>pid</i><b>, int </b><i>unset_environment</i><b>,</b>
                                 <b>uint64_t </b><i>timeout</i><b>);</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       <b>sd_notify() </b>may be called by a service to notify the service
       manager about state changes. It can be used to send arbitrary
       information, encoded in an environment-block-like string. Most
       importantly, it can be used for start-up or reload completion
       notifications.

       If the <i>unset_environment</i> parameter is non-zero, <b>sd_notify() </b>will
       unset the <i>$NOTIFY_SOCKET</i> environment variable before returning
       (regardless of whether the function call itself succeeded or
       not). Further calls to <b>sd_notify() </b>will then silently do nothing,
       and the variable is no longer inherited by child processes.

       The <i>state</i> parameter should contain a newline-separated list of
       variable assignments, similar in style to an environment block. A
       trailing newline is implied if none is specified. The string may
       contain any kind of variable assignments, but see the next
       section for a list of assignments understood by the service
       manager.

       Note that systemd will accept status data sent from a service
       only if the <i>NotifyAccess=</i> option is correctly set in the service
       definition file. See <a href="../man5/systemd.service.5.html">systemd.service(5)</a> for details.

       Note that <b>sd_notify() </b>notifications may be attributed to units
       correctly only if either the sending process is still around at
       the time PID 1 processes the message, or if the sending process
       is explicitly runtime-tracked by the service manager. The latter
       is the case if the service manager originally forked off the
       process, i.e. on all processes that match <i>NotifyAccess=</i><b>main </b>or
       <i>NotifyAccess=</i><b>exec</b>. Conversely, if an auxiliary process of the
       unit sends an <b>sd_notify() </b>message and immediately exits, the
       service manager might not be able to properly attribute the
       message to the unit, and thus will ignore it, even if
       <i>NotifyAccess=</i><b>all </b>is set for it.

       Hence, to eliminate all race conditions involving lookup of the
       client's unit and attribution of notifications to units
       correctly, <b>sd_notify_barrier() </b>may be used. This call acts as a
       synchronization point and ensures all notifications sent before
       this call have been picked up by the service manager when it
       returns successfully. Use of <b>sd_notify_barrier() </b>is needed for
       clients which are not invoked by the service manager, otherwise
       this synchronization mechanism is unnecessary for attribution of
       notifications to the unit.

       <b>sd_notifyf() </b>is similar to <b>sd_notify() </b>but takes a <b>printf()</b>-like
       format string plus arguments.

       <b>sd_pid_notify() </b>and <b>sd_pid_notifyf() </b>are similar to <b>sd_notify()</b>
       and <b>sd_notifyf() </b>but take a process ID (PID) to use as
       originating PID for the message as first argument. This is useful
       to send notification messages on behalf of other processes,
       provided the appropriate privileges are available. If the PID
       argument is specified as 0, the process ID of the calling process
       is used, in which case the calls are fully equivalent to
       <b>sd_notify() </b>and <b>sd_notifyf()</b>.

       <b>sd_pid_notify_with_fds() </b>is similar to <b>sd_pid_notify() </b>but takes
       an additional array of file descriptors. These file descriptors
       are sent along the notification message to the service manager.
       This is particularly useful for sending "FDSTORE=1" messages, as
       described above. The additional arguments are a pointer to the
       file descriptor array plus the number of file descriptors in the
       array. If the number of file descriptors is passed as 0, the call
       is fully equivalent to <b>sd_pid_notify()</b>, i.e. no file descriptors
       are passed. Note that file descriptors sent to the service
       manager on a message without "FDSTORE=1" are immediately closed
       on reception.

       <b>sd_pid_notifyf_with_fds() </b>is a combination of
       <b>sd_pid_notify_with_fds() </b>and <b>sd_notifyf()</b>, i.e. it accepts both a
       PID and a set of file descriptors as input, and processes a
       format string to generate the state string.

       <b>sd_notify_barrier() </b>allows the caller to synchronize against
       reception of previously sent notification messages and uses the
       <i>BARRIER=1</i> command. It takes a relative <i>timeout</i> value in
       microseconds which is passed to <a href="../man2/ppoll.2.html">ppoll(2)</a>. A value of UINT64_MAX
       is interpreted as infinite timeout.

       <b>sd_pid_notify_barrier() </b>is just like <b>sd_notify_barrier()</b>, but
       allows specifying the originating PID for the notification
       message.
</pre> <h2>
WELL-KNOWN ASSIGNMENTS </h2>
<pre>
       The following assignments have a defined meaning:

       READY=1
           Tells the service manager that service startup is finished,
           or the service finished re-loading its configuration. This is
           only used by systemd if the service definition file has
           <i>Type=notify</i> or <i>Type=notify-reload</i> set. Since there is little
           value in signaling non-readiness, the only value services
           should send is "READY=1" (i.e.  "READY=0" is not defined).

       RELOADING=1
           Tells the service manager that the service is beginning to
           reload its configuration. This is useful to allow the service
           manager to track the service's internal state, and present it
           to the user. Note that a service that sends this notification
           must also send a "READY=1" notification when it completed
           reloading its configuration. Reloads the service manager is
           notified about with this mechanisms are propagated in the
           same way as they are when originally initiated through the
           service manager. This message is particularly relevant for
           <i>Type=notify-reload</i> services, to inform the service manager
           that the request to reload the service has been received and
           is now being processed.

           Added in version 217.

       STOPPING=1
           Tells the service manager that the service is beginning its
           shutdown. This is useful to allow the service manager to
           track the service's internal state, and present it to the
           user.

           Added in version 217.

       MONOTONIC_USEC=...
           A field carrying the monotonic timestamp (as per
           <b>CLOCK_MONOTONIC</b>) formatted in decimal in μs, when the
           notification message was generated by the client. This is
           typically used in combination with "RELOADING=1", to allow
           the service manager to properly synchronize reload cycles.
           See <a href="../man5/systemd.service.5.html">systemd.service(5)</a> for details, specifically
           "Type=notify-reload".

           Added in version 253.

       STATUS=...
           Passes a single-line UTF-8 status string back to the service
           manager that describes the service state. This is free-form
           and can be used for various purposes: general state feedback,
           fsck-like programs could pass completion percentages and
           failing programs could pass a human-readable error message.
           Example: "STATUS=Completed 66% of file system check..."

           Added in version 233.

       NOTIFYACCESS=...
           Reset the access to the service status notification socket
           during runtime, overriding <i>NotifyAccess=</i> setting in the
           service unit file. See <a href="../man5/systemd.service.5.html">systemd.service(5)</a> for details,
           specifically "NotifyAccess=" for a list of accepted values.

           Added in version 254.

       ERRNO=...
           If a service fails, the errno-style error code, formatted as
           string. Example: "ERRNO=2" for ENOENT.

           Added in version 233.

       BUSERROR=...
           If a service fails, the D-Bus error-style error code.
           Example: "BUSERROR=org.freedesktop.DBus.Error.TimedOut". Note
           that this assignment is currently not used by <b>systemd</b>.

           Added in version 233.

       EXIT_STATUS=...
           The exit status of a service or the manager itself. Note that
           <b>systemd </b>currently does not consume this value when sent by
           services, so this assignment is only informational. The
           manager will send this notification to <i>its</i> notification
           socket, which may be used to collect an exit status from the
           system (a container or VM) as it shuts down. For example,
           <b>mkosi</b>(1) makes use of this. The value to return may be set
           via the <a href="../man1/systemctl.1.html">systemctl(1)</a> <b>exit </b>verb.

           Added in version 254.

       MAINPID=...
           The main process ID (PID) of the service, in case the service
           manager did not fork off the process itself. Example:
           "MAINPID=4711".

           Added in version 233.

       WATCHDOG=1
           Tells the service manager to update the watchdog timestamp.
           This is the keep-alive ping that services need to issue in
           regular intervals if <i>WatchdogSec=</i> is enabled for it. See
           <a href="../man5/systemd.service.5.html">systemd.service(5)</a> for information how to enable this
           functionality and <a href="sd_watchdog_enabled.3.html">sd_watchdog_enabled(3)</a> for the details of
           how the service can check whether the watchdog is enabled.

       WATCHDOG=trigger
           Tells the service manager that the service detected an
           internal error that should be handled by the configured
           watchdog options. This will trigger the same behaviour as if
           <i>WatchdogSec=</i> is enabled and the service did not send
           "WATCHDOG=1" in time. Note that <i>WatchdogSec=</i> does not need to
           be enabled for "WATCHDOG=trigger" to trigger the watchdog
           action. See <a href="../man5/systemd.service.5.html">systemd.service(5)</a> for information about the
           watchdog behavior.

           Added in version 243.

       WATCHDOG_USEC=...
           Reset <i>watchdog_usec</i> value during runtime. Notice that this is
           not available when using <b>sd_event_set_watchdog() </b>or
           <b>sd_watchdog_enabled()</b>. Example : "WATCHDOG_USEC=20000000"

           Added in version 233.

       EXTEND_TIMEOUT_USEC=...
           Tells the service manager to extend the startup, runtime or
           shutdown service timeout corresponding the current state. The
           value specified is a time in microseconds during which the
           service must send a new message. A service timeout will occur
           if the message isn't received, but only if the runtime of the
           current state is beyond the original maximum times of
           <i>TimeoutStartSec=</i>, <i>RuntimeMaxSec=</i>, and <i>TimeoutStopSec=</i>. See
           <a href="../man5/systemd.service.5.html">systemd.service(5)</a> for effects on the service timeouts.

           Added in version 236.

       FDSTORE=1
           Store file descriptors in the service manager. File
           descriptors sent this way will be held for the service by the
           service manager and will later be handed back using the usual
           file descriptor passing logic at the next start or restart of
           the service, see <a href="sd_listen_fds.3.html">sd_listen_fds(3)</a>. Any open sockets and other
           file descriptors which should not be closed during a restart
           may be stored this way. When a service is stopped, its file
           descriptor store is discarded and all file descriptors in it
           are closed, except when overridden with
           <i>FileDescriptorStorePreserve=</i>, see <a href="../man5/systemd.service.5.html">systemd.service(5)</a>.

           The service manager will accept messages for a service only
           if its <i>FileDescriptorStoreMax=</i> setting is non-zero (defaults
           to zero, see <a href="../man5/systemd.service.5.html">systemd.service(5)</a>). The service manager will
           set the <i>$FDSTORE</i> environment variable for services that have
           the file descriptor store enabled, see <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>.

           If <i>FDPOLL=0</i> is not set and the file descriptors are pollable
           (see <a href="../man2/epoll_ctl.2.html">epoll_ctl(2)</a>), then any <b>EPOLLHUP </b>or <b>EPOLLERR </b>event seen
           on them will result in their automatic removal from the
           store.

           Multiple sets of file descriptors may be sent in separate
           messages, in which case the sets are combined. The service
           manager removes duplicate file descriptors (those pointing to
           the same object) before passing them to the service.

           This functionality should be used to implement services that
           can restart after an explicit request or a crash without
           losing state. Application state can either be serialized to a
           file in /run/, or better, stored in a <a href="../man2/memfd_create.2.html">memfd_create(2)</a> memory
           file descriptor. Use <b>sd_pid_notify_with_fds() </b>to send
           messages with "FDSTORE=1". It is recommended to combine
           <i>FDSTORE=</i> with <i>FDNAME=</i> to make it easier to manage the stored
           file descriptors.

           For further information on the file descriptor store see the
           <b>File Descriptor Store</b>[1] overview.

           Added in version 219.

       FDSTOREREMOVE=1
           Removes file descriptors from the file descriptor store. This
           field needs to be combined with <i>FDNAME=</i> to specify the name
           of the file descriptors to remove.

           Added in version 236.

       FDNAME=...
           When used in combination with <i>FDSTORE=1</i>, specifies a name for
           the submitted file descriptors. When used with
           <i>FDSTOREREMOVE=1</i>, specifies the name for the file descriptors
           to remove. This name is passed to the service during
           activation, and may be queried using
           <a href="sd_listen_fds_with_names.3.html">sd_listen_fds_with_names(3)</a>. File descriptors submitted
           without this field will be called "stored".

           The name may consist of arbitrary ASCII characters except
           control characters or ":". It may not be longer than 255
           characters. If a submitted name does not follow these
           restrictions, it is ignored.

           Note that if multiple file descriptors are submitted in a
           single message, the specified name will be used for all of
           them. In order to assign different names to submitted file
           descriptors, submit them in separate messages.

           Added in version 233.

       FDPOLL=0
           When used in combination with <i>FDSTORE=1</i>, disables polling of
           the submitted file descriptors regardless of whether or not
           they are pollable. As this option disables automatic cleanup
           of the submitted file descriptors on EPOLLERR and EPOLLHUP,
           care must be taken to ensure proper manual cleanup. Use of
           this option is not generally recommended except for when
           automatic cleanup has unwanted behavior such as prematurely
           discarding file descriptors from the store.

           Added in version 246.

       BARRIER=1
           Tells the service manager that the client is explicitly
           requesting synchronization by means of closing the file
           descriptor sent with this command. The service manager
           guarantees that the processing of a <i>BARRIER=1</i> command will
           only happen after all previous notification messages sent
           before this command have been processed. Hence, this command
           accompanied with a single file descriptor can be used to
           synchronize against reception of all previous status
           messages. Note that this command cannot be mixed with other
           notifications, and has to be sent in a separate message to
           the service manager, otherwise all assignments will be
           ignored. Note that sending 0 or more than 1 file descriptor
           with this command is a violation of the protocol.

           Added in version 246.

       The notification messages sent by services are interpreted by the
       service manager. Unknown assignments are ignored. Thus, it is
       safe (but often without effect) to send assignments which are not
       in this list. The protocol is extensible, but care should be
       taken to ensure private extensions are recognizable as such.
       Specifically, it is recommend to prefix them with "X_" followed
       by some namespace identifier. The service manager also sends some
       messages to <i>its</i> notification socket, which may then consumed by a
       supervising machine or container manager further up the stack.
       The service manager sends a number of extension fields, for
       example <i>X_SYSTEMD_UNIT_ACTIVE=</i>, for details see <a href="../man1/systemd.1.html">systemd(1)</a>.
</pre> <h2>
RETURN VALUE </h2>
<pre>
       On failure, these calls return a negative errno-style error code.
       If <i>$NOTIFY_SOCKET</i> was not set and hence no status message could
       be sent, 0 is returned. If the status was sent, these functions
       return a positive value. In order to support both service
       managers that implement this scheme and those which do not, it is
       generally recommended to ignore the return value of this call.
       Note that the return value simply indicates whether the
       notification message was enqueued properly, it does not reflect
       whether the message could be processed successfully.
       Specifically, no error is returned when a file descriptor is
       attempted to be stored using <i>FDSTORE=1</i> but the service is not
       actually configured to permit storing of file descriptors (see
       above).
</pre> <h2>
NOTES </h2>
<pre>
       Functions described here are available as a shared library, which
       can be compiled against and linked to with the
       <b>libsystemd pkg-config</b>(1) file.

       The code described here uses <a href="getenv.3.html">getenv(3)</a>, which is declared to be
       not multi-thread-safe. This means that the code calling the
       functions described here must not call <a href="setenv.3.html">setenv(3)</a> from a parallel
       thread. It is recommended to only do calls to <b>setenv() </b>from an
       early phase of the program when no other threads have been
       started.

       These functions send a single datagram with the state string as
       payload to the socket referenced in the <i>$NOTIFY_SOCKET</i>
       environment variable. If the first character of <i>$NOTIFY_SOCKET</i> is
       "/" or "@", the string is understood as an <b>AF_UNIX </b>or Linux
       abstract namespace socket (respectively), and in both cases the
       datagram is accompanied by the process credentials of the sending
       service, using SCM_CREDENTIALS. If the string starts with
       "vsock:" then the string is understood as an <b>AF_VSOCK </b>address,
       which is useful for hypervisors/VMMs or other processes on the
       host to receive a notification when a virtual machine has
       finished booting. Note that in case the hypervisor does not
       support <b>SOCK_DGRAM </b>over <b>AF_VSOCK</b>, <b>SOCK_SEQPACKET </b>will be used
       instead.  "vsock-stream", "vsock-dgram" and "vsock-seqpacket" can
       be used instead of "vsock" to force usage of the corresponding
       socket type. The address should be in the form: "vsock:CID:PORT".
       Note that unlike other uses of vsock, the CID is mandatory and
       cannot be "VMADDR_CID_ANY". Note that PID1 will send the VSOCK
       packets from a privileged port (i.e.: lower than 1024), as an
       attempt to address concerns that unprivileged processes in the
       guest might try to send malicious notifications to the host,
       driving it to make destructive decisions based on them.

   <b>Standalone Implementations</b>
       Note that, while using this library should be preferred in order
       to avoid code duplication, it is also possible to reimplement the
       simple readiness notification protocol without external
       dependencies, as demonstrated in the following self-contained
       examples from several languages:

       <b>C</b>

               /* SPDX-License-Identifier: MIT-0 */

               /* Implement the systemd notify protocol without external dependencies.
                * Supports both readiness notification on startup and on reloading,
                * according to the protocol defined at:
                * <a href="https://www.freedesktop.org/software/systemd/man/latest/sd_notify.html">https://www.freedesktop.org/software/systemd/man/latest/sd_notify.html</a>
                * This protocol is guaranteed to be stable as per:
                * <a href="https://systemd.io/PORTABILITY_AND_STABILITY/">https://systemd.io/PORTABILITY_AND_STABILITY/</a> */

               #define _GNU_SOURCE 1
               #include &lt;errno.h&gt;
               #include &lt;inttypes.h&gt;
               #include &lt;signal.h&gt;
               #include &lt;stdbool.h&gt;
               #include &lt;stddef.h&gt;
               #include &lt;stdlib.h&gt;
               #include &lt;stdio.h&gt;
               #include &lt;sys/socket.h&gt;
               #include &lt;sys/un.h&gt;
               #include &lt;time.h&gt;
               #include &lt;unistd.h&gt;

               #define _cleanup_(f) __attribute__((cleanup(f)))

               static void closep(int *fd) {
                 if (!fd || *fd &lt; 0)
                   return;

                 close(*fd);
                 *fd = -1;
               }

               static int notify(const char *message) {
                 union sockaddr_union {
                   struct sockaddr sa;
                   struct sockaddr_un sun;
                 } socket_addr = {
                   .sun.sun_family = AF_UNIX,
                 };
                 size_t path_length, message_length;
                 _cleanup_(closep) int fd = -1;
                 const char *socket_path;

                 /* Verify the argument first */
                 if (!message)
                   return -EINVAL;

                 message_length = strlen(message);
                 if (message_length == 0)
                   return -EINVAL;

                 /* If the variable is not set, the protocol is a noop */
                 socket_path = getenv("NOTIFY_SOCKET");
                 if (!socket_path)
                   return 0; /* Not set? Nothing to do */

                 /* Only AF_UNIX is supported, with path or abstract sockets */
                 if (socket_path[0] != '/' &amp;&amp; socket_path[0] != '@')
                   return -EAFNOSUPPORT;

                 path_length = strlen(socket_path);
                 /* Ensure there is room for NUL byte */
                 if (path_length &gt;= sizeof(socket_addr.sun.sun_path))
                   return -E2BIG;

                 memcpy(socket_addr.sun.sun_path, socket_path, path_length);

                 /* Support for abstract socket */
                 if (socket_addr.sun.sun_path[0] == '@')
                   socket_addr.sun.sun_path[0] = 0;

                 fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0);
                 if (fd &lt; 0)
                   return -errno;

                 if (connect(fd, &amp;socket_addr.sa, offsetof(struct sockaddr_un, sun_path) + path_length) != 0)
                   return -errno;

                 ssize_t written = write(fd, message, message_length);
                 if (written != (ssize_t) message_length)
                   return written &lt; 0 ? -errno : -EPROTO;

                 return 1; /* Notified! */
               }

               static int notify_ready(void) {
                 return notify("READY=1");
               }

               static int notify_reloading(void) {
                 /* A buffer with length sufficient to format the maximum UINT64 value. */
                 char reload_message[sizeof("RELOADING=1\nMONOTONIC_USEC=18446744073709551615")];
                 struct timespec ts;
                 uint64_t now;

                 /* Notify systemd that we are reloading, including a CLOCK_MONOTONIC timestamp in usec
                  * so that the program is compatible with a Type=notify-reload service. */

                 if (clock_gettime(CLOCK_MONOTONIC, &amp;ts) &lt; 0)
                   return -errno;

                 if (ts.tv_sec &lt; 0 || ts.tv_nsec &lt; 0 ||
                     (uint64_t) ts.tv_sec &gt; (UINT64_MAX - (ts.tv_nsec / 1000ULL)) / 1000000ULL)
                   return -EINVAL;

                 now = (uint64_t) ts.tv_sec * 1000000ULL + (uint64_t) ts.tv_nsec / 1000ULL;

                 if (snprintf(reload_message, sizeof(reload_message), "RELOADING=1\nMONOTONIC_USEC=%" PRIu64, now) &lt; 0)
                   return -EINVAL;

                 return notify(reload_message);
               }

               static int notify_stopping(void) {
                 return notify("STOPPING=1");
               }

               static volatile sig_atomic_t reloading = 0;
               static volatile sig_atomic_t terminating = 0;

               static void signal_handler(int sig) {
                 if (sig == SIGHUP)
                   reloading = 1;
                 else if (sig == SIGINT || sig == SIGTERM)
                   terminating = 1;
               }

               int main(int argc, char **argv) {
                 struct sigaction sa = {
                   .sa_handler = signal_handler,
                   .sa_flags = SA_RESTART,
                 };
                 int r;

                 /* Setup signal handlers */
                 sigemptyset(&amp;sa.sa_mask);
                 sigaction(SIGHUP, &amp;sa, NULL);
                 sigaction(SIGINT, &amp;sa, NULL);
                 sigaction(SIGTERM, &amp;sa, NULL);

                 /* Do more service initialization work here ... */

                 /* Now that all the preparations steps are done, signal readiness */

                 r = notify_ready();
                 if (r &lt; 0) {
                   fprintf(stderr, "Failed to notify readiness to $NOTIFY_SOCKET: %s\n", strerror(-r));
                   return EXIT_FAILURE;
                 }

                 while (!terminating) {
                   if (reloading) {
                     reloading = false;

                     /* As a separate but related feature, we can also notify the manager
                      * when reloading configuration. This allows accurate state-tracking,
                      * and also automated hook-in of 'systemctl reload' without having to
                      * specify manually an ExecReload= line in the unit file. */

                     r = notify_reloading();
                     if (r &lt; 0) {
                       fprintf(stderr, "Failed to notify reloading to $NOTIFY_SOCKET: %s\n", strerror(-r));
                       return EXIT_FAILURE;
                     }

                     /* Do some reconfiguration work here ... */

                     r = notify_ready();
                     if (r &lt; 0) {
                       fprintf(stderr, "Failed to notify readiness to $NOTIFY_SOCKET: %s\n", strerror(-r));
                       return EXIT_FAILURE;
                     }
                   }

                   /* Do some daemon work here ... */
                   sleep(5);
                 }

                 r = notify_stopping();
                 if (r &lt; 0) {
                   fprintf(stderr, "Failed to report termination to $NOTIFY_SOCKET: %s\n", strerror(-r));
                   return EXIT_FAILURE;
                 }

                 /* Do some shutdown work here ... */

                 return EXIT_SUCCESS;
               }

       <b>Python</b>

               #!/usr/bin/env python3
               # SPDX-License-Identifier: MIT-0
               #
               # Implement the systemd notify protocol without external dependencies.
               # Supports both readiness notification on startup and on reloading,
               # according to the protocol defined at:
               # <a href="https://www.freedesktop.org/software/systemd/man/latest/sd_notify.html">https://www.freedesktop.org/software/systemd/man/latest/sd_notify.html</a>
               # This protocol is guaranteed to be stable as per:
               # <a href="https://systemd.io/PORTABILITY_AND_STABILITY/">https://systemd.io/PORTABILITY_AND_STABILITY/</a>

               import errno
               import os
               import signal
               import socket
               import sys
               import time

               reloading = False
               terminating = False

               def notify(message):
                   if not message:
                       raise ValueError("notify() requires a message")

                   socket_path = os.environ.get("NOTIFY_SOCKET")
                   if not socket_path:
                       return

                   if socket_path[0] not in ("/", "@"):
                       raise OSError(errno.EAFNOSUPPORT, "Unsupported socket type")

                   # Handle abstract socket.
                   if socket_path[0] == "@":
                       socket_path = "\0" + socket_path[1:]

                   with socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM | socket.SOCK_CLOEXEC) as sock:
                       sock.connect(socket_path)
                       sock.sendall(message)

               def notify_ready():
                   notify(b"READY=1")

               def notify_reloading():
                   microsecs = time.clock_gettime_ns(time.CLOCK_MONOTONIC) // 1000
                   notify(f"RELOADING=1\nMONOTONIC_USEC={microsecs}".encode())

               def notify_stopping():
                   notify(b"STOPPING=1")

               def reload(signum, frame):
                   global reloading
                   reloading = True

               def terminate(signum, frame):
                   global terminating
                   terminating = True

               def main():
                   print("Doing initial setup")
                   global reloading, terminating

                   # Set up signal handlers.
                   print("Setting up signal handlers")
                   signal.signal(signal.SIGHUP, reload)
                   signal.signal(signal.SIGINT, terminate)
                   signal.signal(signal.SIGTERM, terminate)

                   # Do any other setup work here.

                   # Once all setup is done, signal readiness.
                   print("Done setting up")
                   notify_ready()

                   print("Starting loop")
                   while not terminating:
                       if reloading:
                           print("Reloading")
                           reloading = False

                           # Support notifying the manager when reloading configuration.
                           # This allows accurate state tracking as well as automatically
                           # enabling 'systemctl reload' without needing to manually
                           # specify an ExecReload= line in the unit file.

                           notify_reloading()

                           # Do some reconfiguration work here.

                           print("Done reloading")
                           notify_ready()

                       # Do the real work here ...

                       print("Sleeping for five seconds")
                       time.sleep(5)

                   print("Terminating")
                   notify_stopping()

               if __name__ == "__main__":
                   sys.stdout.reconfigure(line_buffering=True)
                   print("Starting app")
                   main()
                   print("Stopped app")
</pre> <h2>
ENVIRONMENT </h2>
<pre>
       <i>$NOTIFY_SOCKET</i>
           Set by the service manager for supervised processes for
           status and start-up completion notification. This environment
           variable specifies the socket <b>sd_notify() </b>talks to. See above
           for details.
</pre> <h2>
EXAMPLES </h2>
<pre>
       <b>Example 1. Start-up Notification</b>

       When a service finished starting up, it might issue the following
       call to notify the service manager:

           sd_notify(0, "READY=1");

       <b>Example 2. Extended Start-up Notification</b>

       A service could send the following after completing
       initialization:

           sd_notifyf(0, "READY=1\n"
                         "STATUS=Processing requests...\n"
                         "MAINPID=%lu",
                      (unsigned long) getpid());

       <b>Example 3. Error Cause Notification</b>

       A service could send the following shortly before exiting, on
       failure:

           sd_notifyf(0, "STATUS=Failed to start up: %s\n"
                         "ERRNO=%i",
                      strerror_r(errnum, (char[1024]){}, 1024),
                      errnum);

       <b>Example 4. Store a File Descriptor in the Service Manager</b>

       To store an open file descriptor in the service manager, in order
       to continue operation after a service restart without losing
       state, use "FDSTORE=1":

           sd_pid_notify_with_fds(0, 0, "FDSTORE=1\nFDNAME=foobar", &amp;fd, 1);

       <b>Example 5. Eliminating race conditions</b>

       When the client sending the notifications is not spawned by the
       service manager, it may exit too quickly and the service manager
       may fail to attribute them correctly to the unit. To prevent such
       races, use <b>sd_notify_barrier() </b>to synchronize against reception
       of all notifications sent before this call is made.

           sd_notify(0, "READY=1");
           /* set timeout to 5 seconds */
           sd_notify_barrier(0, 5 * 1000000);
</pre> <h2>
HISTORY </h2>
<pre>
       <b>sd_pid_notify()</b>, <b>sd_pid_notifyf()</b>, and <b>sd_pid_notify_with_fds()</b>
       were added in version 219.

       <b>sd_notify_barrier() </b>was added in version 246.

       <b>sd_pid_notifyf_with_fds() </b>and <b>sd_pid_notify_barrier() </b>were added
       in version 254.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man1/systemd.1.html">systemd(1)</a>, <a href="sd-daemon.3.html">sd-daemon(3)</a>, <a href="sd_listen_fds.3.html">sd_listen_fds(3)</a>,
       <a href="sd_listen_fds_with_names.3.html">sd_listen_fds_with_names(3)</a>, <a href="sd_watchdog_enabled.3.html">sd_watchdog_enabled(3)</a>, <a href="../man7/daemon.7.html">daemon(7)</a>,
       <a href="../man5/systemd.service.5.html">systemd.service(5)</a>
</pre> <h2>
NOTES </h2>
<pre>
        1. File Descriptor Store
           <a href="https://systemd.io/FILE_DESCRIPTOR_STORE">https://systemd.io/FILE_DESCRIPTOR_STORE</a>
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>systemd</i> (systemd system and service
       manager) project.  Information about the project can be found at
       ⟨<a href="http://www.freedesktop.org/wiki/Software/systemd">http://www.freedesktop.org/wiki/Software/systemd</a>⟩.  If you have
       a bug report for this manual page, see
       ⟨<a href="http://www.freedesktop.org/wiki/Software/systemd/#bugreports">http://www.freedesktop.org/wiki/Software/systemd/#bugreports</a>⟩.
       This page was obtained from the project's upstream Git repository
       ⟨<a href="https://github.com/systemd/systemd.git">https://github.com/systemd/systemd.git</a>⟩ on 2024-06-14.  (At that
       time, the date of the most recent commit that was found in the
       repository was 2024-06-13.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">systemd 257~devel                                           <i>SD_NOTIFY</i>(3)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/systemd.1.html">systemd(1)</a>, <a href="../man1/systemd-notify.1.html">systemd-notify(1)</a>, <a href="../man1/systemd-nspawn.1.html">systemd-nspawn(1)</a>, <a href="__pmservernotifyservicemanagerready.3.html">__pmServerNotifyServiceManagerReady(3)</a>, <a href="sd-daemon.3.html">sd-daemon(3)</a>, <a href="sd_event_set_watchdog.3.html">sd_event_set_watchdog(3)</a>, <a href="sd_listen_fds.3.html">sd_listen_fds(3)</a>, <a href="sd_watchdog_enabled.3.html">sd_watchdog_enabled(3)</a>, <a href="../man5/org.freedesktop.systemd1.5.html">org.freedesktop.systemd1(5)</a>, <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>, <a href="../man5/systemd.service.5.html">systemd.service(5)</a>, <a href="../man7/daemon.7.html">daemon(7)</a>, <a href="../man7/systemd.directives.7.html">systemd.directives(7)</a>, <a href="../man7/systemd.index.7.html">systemd.index(7)</a>, <a href="../man7/systemd.system-credentials.7.html">systemd.system-credentials(7)</a>, <a href="../man8/start-stop-daemon.8.html">start-stop-daemon(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man3/sd_pid_notify_barrier.3.html" class="_attribution-link">https://man7.org/linux/man-pages/man3/sd_pid_notify_barrier.3.html</a>
  </p>
</div>
