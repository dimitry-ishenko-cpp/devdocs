<h1>numa(3) — Linux manual page</h1>   <pre>
<span class="headline"><i>NUMA</i>(3)                 Linux Programmer's Manual                <i>NUMA</i>(3)</span>
</pre> <h2>
NAME </h2>
<pre>
       numa - NUMA policy library
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;numa.h&gt;</b>

       <b>cc ... -lnuma</b>

       <b>int numa_available(void);</b>

       <b>int numa_max_possible_node(void);</b>
       <b>int numa_num_possible_nodes();</b>

       <b>int numa_max_node(void);</b>
       <b>int numa_num_configured_nodes();</b>
       <b>struct bitmask *numa_get_mems_allowed(void);</b>

       <b>int numa_num_configured_cpus(void);</b>
       <b>struct bitmask *numa_all_nodes_ptr;</b>
       <b>struct bitmask *numa_no_nodes_ptr;</b>
       <b>struct bitmask *numa_all_cpus_ptr;</b>

       <b>int numa_num_task_cpus();</b>
       <b>int numa_num_task_nodes();</b>

       <b>int numa_parse_bitmap(char *</b><i>line</i> <b>, struct bitmask *</b><i>mask</i><b>);</b>
       <b>struct bitmask *numa_parse_nodestring(const char *</b><i>string</i><b>);</b>
       <b>struct bitmask *numa_parse_nodestring_all(const char *</b><i>string</i><b>);</b>
       <b>struct bitmask *numa_parse_cpustring(const char *</b><i>string</i><b>);</b>
       <b>struct bitmask *numa_parse_cpustring_all(const char *</b><i>string</i><b>);</b>

       <b>long long numa_node_size(int </b><i>node</i><b>, long long*</b><i>freep</i><b>);</b>
       <b>long long numa_node_size64(int </b><i>node</i><b>, long long *</b><i>freep</i><b>);</b>

       <b>int numa_preferred(void);</b>
       <b>int numa_has_preferred_many(void);</b>
       <b>struct bitmask *numa_preferred_many(void);</b>
       <b>void numa_set_preferred(int </b><i>node</i><b>);</b>
       <b>void numa_set_preferred_many(struct bitmask *</b><i>nodemask</i><b>);</b>
       <b>int numa_has_home_node(void);</b>
       <b>int numa_set_mempolicy_home_node(void *start, unsigned long len,</b>
       <b>int home_node, int flags);</b>
       <b>int numa_get_interleave_node(void);</b>
       <b>struct bitmask *numa_get_interleave_mask(void);</b>
       <b>void numa_set_interleave_mask(struct bitmask *</b><i>nodemask</i><b>);</b>
       <b>void numa_interleave_memory(void *</b><i>start</i><b>, size_t </b><i>size</i><b>, struct</b>
       <b>bitmask *</b><i>nodemask</i><b>);</b>
       <b>void numa_bind(struct bitmask *</b><i>nodemask</i><b>);</b>
       <b>void numa_set_localalloc(void);</b>
       <b>void numa_set_membind(struct bitmask *</b><i>nodemask</i><b>);</b>
       <b>void numa_set_membind_balancing(struct bitmask *</b><i>nodemask</i><b>);</b>
       <b>struct bitmask *numa_get_membind(void);</b>

       <b>void *numa_alloc_onnode(size_t </b><i>size</i><b>, int </b><i>node</i><b>);</b>
       <b>void *numa_alloc_local(size_t </b><i>size</i><b>);</b>
       <b>void *numa_alloc_interleaved(size_t </b><i>size</i><b>);</b>
       <b>void *numa_alloc_interleaved_subset(size_t </b><i>size</i><b>,  struct bitmask</b>
       <b>*</b><i>nodemask</i><b>); void *numa_alloc(size_t </b><i>size</i><b>);</b>
       <b>void *numa_realloc(void *</b><i>old_addr</i><b>, size_t </b><i>old_size</i><b>, size_t</b>
       <i>new_size</i><b>);</b>
       <b>void numa_free(void *</b><i>start</i><b>, size_t </b><i>size</i><b>);</b>

       <b>int numa_run_on_node(int </b><i>node</i><b>);</b>
       <b>int numa_run_on_node_mask(struct bitmask *</b><i>nodemask</i><b>);</b>
       <b>int numa_run_on_node_mask_all(struct bitmask *</b><i>nodemask</i><b>);</b>
       <b>struct bitmask *numa_get_run_node_mask(void);</b>

       <b>void numa_tonode_memory(void *</b><i>start</i><b>, size_t </b><i>size</i><b>, int </b><i>node</i><b>);</b>
       <b>void numa_tonodemask_memory(void *</b><i>start</i><b>, size_t </b><i>size</i><b>, struct</b>
       <b>bitmask *</b><i>nodemask</i><b>);</b>
       <b>void numa_setlocal_memory(void *</b><i>start</i><b>, size_t </b><i>size</i><b>);</b>
       <b>void numa_police_memory(void *</b><i>start</i><b>, size_t </b><i>size</i><b>);</b>
       <b>void numa_set_bind_policy(int </b><i>strict</i><b>);</b>
       <b>void numa_set_strict(int </b><i>strict</i><b>);</b>

       <b>int numa_distance(int </b><i>node1</i><b>, int </b><i>node2</i><b>);</b>

       <b>int numa_sched_getaffinity(pid_t </b><i>pid</i><b>, struct bitmask *</b><i>mask</i><b>);</b>
       <b>int numa_sched_setaffinity(pid_t </b><i>pid</i><b>, struct bitmask *</b><i>mask</i><b>);</b>
       <b>int numa_node_to_cpus(int </b><i>node</i><b>, struct bitmask *</b><i>mask</i><b>);</b>
       <b>void numa_node_to_cpu_update();</b>
       <b>int numa_node_of_cpu(int </b><i>cpu</i><b>);</b>

       <b>struct bitmask *numa_allocate_cpumask();</b>

       <b>void numa_free_cpumask();</b>
       <b>struct bitmask *numa_allocate_nodemask();</b>

       <b>void numa_free_nodemask();</b>
       <b>struct bitmask *numa_bitmask_alloc(unsigned int </b><i>n</i><b>);</b>
       <b>struct bitmask *numa_bitmask_clearall(struct bitmask *</b><i>bmp</i><b>);</b>
       <b>struct bitmask *numa_bitmask_clearbit(struct bitmask *</b><i>bmp</i><b>,</b>
       <b>unsigned int </b><i>n</i><b>);</b>
       <b>int numa_bitmask_equal(const struct bitmask *</b><i>bmp1</i><b>, const struct</b>
       <b>bitmask *</b><i>bmp2</i><b>);</b>
       <b>void numa_bitmask_free(struct bitmask *</b><i>bmp</i><b>);</b>
       <b>int numa_bitmask_isbitset(const struct bitmask *</b><i>bmp</i><b>, unsigned int</b>
       <i>n</i><b>);</b>
       <b>unsigned int numa_bitmask_nbytes(struct bitmask *</b><i>bmp</i><b>);</b>
       <b>struct bitmask *numa_bitmask_setall(struct bitmask *</b><i>bmp</i><b>);</b>
       <b>struct bitmask *numa_bitmask_setbit(struct bitmask *</b><i>bmp</i><b>, unsigned</b>
       <b>int </b><i>n</i><b>);</b>
       <b>void copy_bitmask_to_nodemask(struct bitmask *</b><i>bmp</i><b>, nodemask_t</b>
       <b>*</b><i>nodemask</i><b>)</b>
       <b>void copy_nodemask_to_bitmask(nodemask_t *</b><i>nodemask</i><b>, struct</b>
       <b>bitmask *</b><i>bmp</i><b>)</b>
       <b>void copy_bitmask_to_bitmask(struct bitmask *</b><i>bmpfrom</i><b>, struct</b>
       <b>bitmask *</b><i>bmpto</i><b>)</b>
       <b>unsigned int numa_bitmask_weight(const struct bitmask *bmp )</b>

       <b>int numa_move_pages(int </b><i>pid</i><b>, unsigned long </b><i>count</i><b>, void **</b><i>pages</i><b>,</b>
       <b>const int *</b><i>nodes</i><b>, int *</b><i>status</i><b>, int </b><i>flags</i><b>);</b>
       <b>int numa_migrate_pages(int </b><i>pid</i><b>, struct bitmask *</b><i>fromnodes</i><b>, struct</b>
       <b>bitmask *</b><i>tonodes</i><b>);</b>

       <b>void numa_error(char *</b><i>where</i><b>);</b>

       <b>extern int </b><i>numa_exit_on_error</i><b>;</b>
       <b>extern int </b><i>numa_exit_on_warn</i><b>;</b>
       <b>void numa_warn(int </b><i>number</i><b>, char *</b><i>where</i><b>, ...);</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <i>libnuma</i> library offers a simple programming interface to the
       NUMA (Non Uniform Memory Access) policy supported by the Linux
       kernel. On a NUMA architecture some memory areas have different
       latency or bandwidth than others.

       Available policies are page interleaving (i.e., allocate in a
       round-robin fashion from all, or a subset, of the nodes on the
       system), preferred node allocation (i.e., preferably allocate on
       a particular node), local allocation (i.e., allocate on the node
       on which the task is currently executing), or allocation only on
       specific nodes (i.e., allocate on some subset of the available
       nodes).  It is also possible to bind tasks to specific nodes.

       Numa memory allocation policy may be specified as a per-task
       attribute, that is inherited by children tasks and processes, or
       as an attribute of a range of process virtual address space.
       Numa memory policies specified for a range of virtual address
       space are shared by all tasks in the process.  Furthermore,
       memory policies specified for a range of a shared memory attached
       using <a href="../man2/shmat.2.html">shmat(2)</a> or <a href="../man2/mmap.2.html">mmap(2)</a> from shmfs/hugetlbfs are shared by all
       processes that attach to that region.  Memory policies for shared
       disk backed file mappings are currently ignored.

       The default memory allocation policy for tasks and all memory
       range is local allocation.  This assumes that no ancestor has
       installed a non-default policy.

       For setting a specific policy globally for all memory allocations
       in a process and its children it is easiest to start it with the
       <a href="../man8/numactl.8.html">numactl(8)</a> utility. For more finegrained policy inside an
       application this library can be used.

       All numa memory allocation policy only takes effect when a page
       is actually faulted into the address space of a process by
       accessing it. The <b>numa_alloc_* </b>functions take care of this
       automatically.

       A <i>node</i> is defined as an area where all memory has the same speed
       as seen from a particular CPU.  A node can contain multiple CPUs.
       Caches are ignored for this definition.

       Most functions in this library are only concerned about numa
       nodes and their memory.  The exceptions to this are:
       <i>numa_node_to_cpus</i>(), <i>numa_node_to_cpu_update</i>(),
       <i>numa_node_of_cpu</i>(), <i>numa_bind</i>(), <i>numa_run_on_node</i>(),
       <i>numa_run_on_node_mask</i>(), <i>numa_run_on_node_mask_all</i>(), and
       <i>numa_get_run_node_mask</i>().  These functions deal with the CPUs
       associated with numa nodes.  See the descriptions below for more
       information.

       Some of these functions accept or return a pointer to struct
       bitmask.  A struct bitmask controls a bit map of arbitrary length
       containing a bit representation of nodes.  The predefined
       variable <i>numa_all_nodes_ptr</i> points to a bit mask that has all
       available nodes set; <i>numa_no_nodes_ptr</i> points to the empty set.

       Before any other calls in this library can be used
       <b>numa_available</b>() must be called. If it returns -1, all other
       functions in this library are undefined.

       <b>numa_max_possible_node() </b>returns the number of the highest
       possible node in a system.  In other words, the size of a kernel
       type nodemask_t (in bits) minus 1.  This number can be gotten by
       calling <b>numa_num_possible_nodes() </b>and subtracting 1.

       <b>numa_num_possible_nodes() </b>returns the size of kernel's node mask
       (kernel type nodemask_t).  In other words, large enough to
       represent the maximum number of nodes that the kernel can handle.
       This will match the kernel's MAX_NUMNODES value.  This count is
       derived from /proc/self/status, field Mems_allowed.

       <b>numa_max_node</b>() returns the highest node number available on the
       current system.  (See the node numbers in
       /sys/devices/system/node/ ).  Also see
       <b>numa_num_configured_nodes().</b>

       <b>numa_num_configured_nodes() </b>returns the number of memory nodes in
       the system. This count includes any nodes that are currently
       disabled. This count is derived from the node numbers in
       /sys/devices/system/node. (Depends on the kernel being configured
       with /sys (CONFIG_SYSFS)).

       <b>numa_get_mems_allowed() </b>returns the mask of nodes from which the
       process is allowed to allocate memory in it's current cpuset
       context.  Any nodes that are not included in the returned bitmask
       will be ignored in any of the following libnuma memory policy
       calls.

       <b>numa_num_configured_cpus() </b>returns the number of cpus in the
       system.  This count includes any cpus that are currently
       disabled. This count is derived from the cpu numbers in
       /sys/devices/system/cpu. If the kernel is configured without /sys
       (CONFIG_SYSFS=n) then it falls back to using the number of online
       cpus.

       <b>numa_all_nodes_ptr </b>points to a bitmask that is allocated by the
       library with bits representing all nodes on which the calling
       task may allocate memory.  This set may be up to all nodes on the
       system, or up to the nodes in the current cpuset.  The bitmask is
       allocated by a call to <b>numa_allocate_nodemask() </b>using size
       <b>numa_max_possible_node().  </b>The set of nodes to record is derived
       from /proc/self/status, field "Mems_allowed".  The user should
       not alter this bitmask.

       <b>numa_no_nodes_ptr </b>points to a bitmask that is allocated by the
       library and left all zeroes.  The bitmask is allocated by a call
       to <b>numa_allocate_nodemask() </b>using size <b>numa_max_possible_node().</b>
       The user should not alter this bitmask.

       <b>numa_all_cpus_ptr </b>points to a bitmask that is allocated by the
       library with bits representing all cpus on which the calling task
       may execute.  This set may be up to all cpus on the system, or up
       to the cpus in the current cpuset.  The bitmask is allocated by a
       call to <b>numa_allocate_cpumask() </b>using size
       <b>numa_num_possible_cpus().  </b>The set of cpus to record is derived
       from /proc/self/status, field "Cpus_allowed".  The user should
       not alter this bitmask.

       <b>numa_num_task_cpus() </b>returns the number of cpus that the calling
       task is allowed to use.  This count is derived from the map
       /proc/self/status, field "Cpus_allowed". Also see the bitmask
       <b>numa_all_cpus_ptr.</b>

       <b>numa_num_task_nodes() </b>returns the number of nodes on which the
       calling task is allowed to allocate memory.  This count is
       derived from the map /proc/self/status, field "Mems_allowed".
       Also see the bitmask <b>numa_all_nodes_ptr.</b>

       <b>numa_parse_bitmap() </b>parses <i>line</i> , which is a character string
       such as found in /sys/devices/system/node/nodeN/cpumap into a
       bitmask structure.  The string contains the hexadecimal
       representation of a bit map.  The bitmask may be allocated with
       <b>numa_allocate_cpumask().  </b>Returns  0 on success.  Returns -1 on
       failure.  This function is probably of little use to a user
       application, but it is used by <i>libnuma</i> internally.

       <b>numa_parse_nodestring() </b>parses a character string list of nodes
       into a bit mask.  The bit mask is allocated by
       <b>numa_allocate_nodemask().  </b>The string is a comma-separated list
       of node numbers or node ranges.  A leading ! can be used to
       indicate "not" this list (in other words, all nodes except this
       list), and a leading + can be used to indicate that the node
       numbers in the list are relative to the task's cpuset.  The
       string can be "all" to specify all ( <b>numa_num_task_nodes() </b>)
       nodes.  Node numbers are limited by the number in the system.
       See <b>numa_max_node() </b>and <b>numa_num_configured_nodes().</b>
       Examples:  1-5,7,10   !4-5   +0-3
       If the string is of 0 length, bitmask <b>numa_no_nodes_ptr </b>is
       returned.  Returns 0 if the string is invalid.

       <b>numa_parse_nodestring_all() </b>is similar to <b>numa_parse_nodestring </b>,
       but can parse all possible nodes, not only current nodeset.

       <b>numa_parse_cpustring() </b>parses a character string list of cpus
       into a bit mask.  The bit mask is allocated by
       <b>numa_allocate_cpumask().  </b>The string is a comma-separated list of
       cpu numbers or cpu ranges.  A leading ! can be used to indicate
       "not" this list (in other words, all cpus except this list), and
       a leading + can be used to indicate that the cpu numbers in the
       list are relative to the task's cpuset.  The string can be "all"
       to specify all ( <b>numa_num_task_cpus() </b>) cpus.  Cpu numbers are
       limited by the number in the system.  See <b>numa_num_task_cpus()</b>
       and <b>numa_num_configured_cpus().</b>
       Examples:  1-5,7,10   !4-5   +0-3
       Returns 0 if the string is invalid.

       <b>numa_parse_cpustring_all() </b>is similar to <b>numa_parse_cpustring </b>,
       but can parse all possible cpus, not only current cpuset.

       <b>numa_node_size</b>() returns the memory size of a node. If the
       argument <i>freep</i> is not NULL, it used to return the amount of free
       memory on the node.  On error it returns -1.

       <b>numa_node_size64</b>() works the same as <b>numa_node_size</b>().  This is
       useful on 32-bit architectures with large nodes.

       <b>numa_preferred</b>() returns the preferred node of the current task.
       This is the node on which the kernel preferably allocates memory,
       unless some other policy overrides this.

       <b>numa_has_preferred_many</b>() Returns &gt; 0 if the system supports
       multiple preferred nodes.

       <b>numa_preferred_many</b>() Returns the current set of preferred nodes.
       This implies the empty set when the policy isn't one used for
       preference <i>(PREFERRED, PREFERRED_MANY, BIND).</i>  The caller is
       responsible for freeing the mask with <b>numa_bitmask_free</b>().

       <b>numa_set_preferred</b>() sets the preferred node for the current task
       to <i>node</i>.  The system will attempt to allocate memory from the
       preferred node, but will fall back to other nodes if no memory is
       available on the the preferred node.  Passing a <i>node</i> of -1
       argument specifies local allocation and is equivalent to calling
       <b>numa_set_localalloc</b>().

       <b>numa_set_preferred_many</b>() sets the preferred set of nodes for the
       current task to <i>nodemask</i>.  This is similar to
       <b>numa_set_preferred</b>() with the exception that it utilizes a
       different kernel interface to specify multiple preferred nodes.
       The caller is responsible for freeing the mask with
       <b>numa_bitmask_free</b>().

       <b>numa_has_home_node() </b>Returns 1 if the system supports setting
       home_node for mbind and preferred_many.

       <b>numa_set_mempolicy_home_node() </b>set the home node for a VMA policy
       present in the task's address range.  A home node is the NUMA
       node closest to which page allocation will come from.  Users
       should use it after setting up a mbind or perfered_many memory
       policy for the specified range.

       <b>numa_get_interleave_mask</b>() returns the current interleave mask if
       the task's memory allocation policy is page interleaved.
       Otherwise, this function returns an empty mask.

       <b>numa_set_interleave_mask</b>() sets the memory interleave mask for
       the current task to <i>nodemask</i>.  All new memory allocations are
       page interleaved over all nodes in the interleave mask.
       Interleaving can be turned off again by passing an empty mask
       (<i>numa_no_nodes</i>).  The page interleaving only occurs on the actual
       page fault that puts a new page into the current address space.
       It is also only a hint: the kernel will fall back to other nodes
       if no memory is available on the interleave target.

       <b>numa_interleave_memory</b>() interleaves <i>size</i> bytes of memory page by
       page from <i>start</i> on nodes specified in <i>nodemask</i>.  The <i>size</i>
       argument will be rounded up to a multiple of the system page
       size.  If <i>nodemask</i> contains nodes that are externally denied to
       this process, this call will fail.  This is a lower level
       function to interleave allocated but not yet faulted in memory.
       Not yet faulted in means the memory is allocated using <a href="../man2/mmap.2.html">mmap(2)</a> or
       <a href="../man2/shmat.2.html">shmat(2)</a>, but has not been accessed by the current process yet.
       The memory is page interleaved to all nodes specified in
       <i>nodemask</i>.  Normally <b>numa_alloc_interleaved</b>() should be used for
       private memory instead, but this function is useful to handle
       shared memory areas. To be useful the memory area should be
       several megabytes at least (or tens of megabytes of hugetlbfs
       mappings) If the <b>numa_set_strict</b>() flag is true then the
       operation will cause a numa_error if there were already pages in
       the mapping that do not follow the policy.

       <b>numa_bind</b>() binds the current task and its children to the nodes
       specified in <i>nodemask</i>.  They will only run on the CPUs of the
       specified nodes and only be able to allocate memory from them.
       This function is equivalent to calling
       <i>numa_run_on_node_mask(nodemask)</i> followed by
       <i>numa_set_membind(nodemask)</i>.  If tasks should be bound to
       individual CPUs inside nodes consider using <i>numa_node_to_cpus</i> and
       the <a href="../man2/sched_setaffinity.2.html">sched_setaffinity(2)</a> syscall.

       <b>numa_set_localalloc</b>() sets the memory allocation policy for the
       calling task to local allocation.  In this mode, the preferred
       node for memory allocation is effectively the node where the task
       is executing at the time of a page allocation.

       <b>numa_set_membind</b>() sets the memory allocation mask.  The task
       will only allocate memory from the nodes set in <i>nodemask</i>.
       Passing an empty <i>nodemask</i> or a <i>nodemask</i> that contains nodes other
       than those in the mask returned by <i>numa_get_mems_allowed</i>() will
       result in an error.

       <b>numa_set_membind_balancing</b>() sets the memory allocation mask and
       enable the Linux kernel NUMA balancing for the task if the
       feature is supported by the kernel.  The task will only allocate
       memory from the nodes set in <i>nodemask</i>.  Passing an empty <i>nodemask</i>
       or a <i>nodemask</i> that contains nodes other than those in the mask
       returned by <i>numa_get_mems_allowed</i>() will result in an error.

       <b>numa_get_membind</b>() returns the mask of nodes from which memory
       can currently be allocated.  If the returned mask is equal to
       <i>numa_all_nodes</i>, then memory allocation is allowed from all nodes.

       <b>numa_alloc_onnode</b>() allocates memory on a specific node.  The
       <i>size</i> argument will be rounded up to a multiple of the system page
       size.  if the specified <i>node</i> is externally denied to this
       process, this call will fail.  This function is relatively slow
       compared to the <a href="malloc.3.html">malloc(3)</a> family of functions.  The memory must
       be freed with <b>numa_free</b>().  On errors NULL is returned.

       <b>numa_alloc_local</b>() allocates <i>size</i> bytes of memory on the local
       node.  The <i>size</i> argument will be rounded up to a multiple of the
       system page size.  This function is relatively slow compared to
       the <a href="malloc.3.html">malloc(3)</a> family of functions.  The memory must be freed with
       <b>numa_free</b>().  On errors NULL is returned.

       <b>numa_alloc_interleaved</b>() allocates <i>size</i> bytes of memory page
       interleaved on all nodes. This function is relatively slow and
       should only be used for large areas consisting of multiple pages.
       The interleaving works at page level and will only show an effect
       when the area is large.  The allocated memory must be freed with
       <b>numa_free</b>().  On error, NULL is returned.

       <b>numa_alloc_interleaved_subset</b>() attempts to allocate <i>size</i> bytes
       of memory page interleaved on all nodes.  The <i>size</i> argument will
       be rounded up to a multiple of the system page size.  The nodes
       on which a process is allowed to allocate memory may be
       constrained externally.  If this is the case, this function may
       fail.  This function is relatively slow compared to the <a href="malloc.3.html">malloc(3)</a>
       family of functions and should only be used for large areas
       consisting of multiple pages.  The interleaving works at page
       level and will only show an effect when the area is large.  The
       allocated memory must be freed with <b>numa_free</b>().  On error, NULL
       is returned.

       <b>numa_alloc</b>() allocates <i>size</i> bytes of memory with the current NUMA
       policy.  The <i>size</i> argument will be rounded up to a multiple of
       the system page size.  This function is relatively slow compared
       to the <a href="malloc.3.html">malloc(3)</a> family of functions.  The memory must be freed
       with <b>numa_free</b>().  On errors NULL is returned.

       <b>numa_realloc</b>() changes the size of the memory area pointed to by
       <i>old_addr</i> from <i>old_size</i> to <i>new_size.</i>  The memory area pointed to
       by <i>old_addr</i> must have been allocated with one of the <b>numa_alloc*</b>
       functions.  The <i>new_size</i> will be rounded up to a multiple of the
       system page size. The contents of the memory area will be
       unchanged to the minimum of the old and new sizes; newly
       allocated memory will be uninitialized. The memory policy (and
       node bindings) associated with the original memory area will be
       preserved in the resized area. For example, if the initial area
       was allocated with a call to <b>numa_alloc_onnode(), </b>then the new
       pages (if the area is enlarged) will be allocated on the same
       node.  However, if no memory policy was set for the original
       area, then <b>numa_realloc</b>() cannot guarantee that the new pages
       will be allocated on the same node. On success, the address of
       the resized area is returned (which might be different from that
       of the initial area), otherwise NULL is returned and <i><a href="errno.3.html">errno</a></i> is set
       to indicate the error. The pointer returned by <b>numa_realloc</b>() is
       suitable for passing to <b>numa_free</b>().

       <b>numa_free</b>() frees <i>size</i> bytes of memory starting at <i>start</i>,
       allocated by the <b>numa_alloc_* </b>functions above.  The <i>size</i> argument
       will be rounded up to a multiple of the system page size.

       <b>numa_run_on_node</b>() runs the current task and its children on a
       specific node. They will not migrate to CPUs of other nodes until
       the node affinity is reset with a new call to
       <b>numa_run_on_node_mask</b>().  Passing -1 permits the kernel to
       schedule on all nodes again.  On success, 0 is returned; on error
       -1 is returned, and <i><a href="errno.3.html">errno</a></i> is set to indicate the error.

       <b>numa_run_on_node_mask</b>() runs the current task and its children
       only on nodes specified in <i>nodemask</i>.  They will not migrate to
       CPUs of other nodes until the node affinity is reset with a new
       call to <b>numa_run_on_node_mask</b>() or <b>numa_run_on_node</b>().  Passing
       <i>numa_all_nodes</i> permits the kernel to schedule on all nodes again.
       On success, 0 is returned; on error -1 is returned, and <i><a href="errno.3.html">errno</a></i> is
       set to indicate the error.

       <b>numa_run_on_node_mask_all</b>() runs the current task and its
       children only on nodes specified in <i>nodemask</i> like
       <i>numa_run_on_node_mask</i> but without any cpuset awareness.

       <b>numa_get_run_node_mask</b>() returns a mask of CPUs on which the
       current task is allowed to run.

       <b>numa_tonode_memory</b>() put memory on a specific node. The
       constraints described for <b>numa_interleave_memory</b>() apply here
       too.

       <b>numa_tonodemask_memory</b>() put memory on a specific set of nodes.
       The constraints described for <b>numa_interleave_memory</b>() apply here
       too.

       <b>numa_setlocal_memory</b>() locates memory on the current node. The
       constraints described for <b>numa_interleave_memory</b>() apply here
       too.

       <b>numa_police_memory</b>() locates memory with the current NUMA policy.
       The constraints described for <b>numa_interleave_memory</b>() apply here
       too. The function will read-modify-write parts of the memory, and
       it's the callers responsibility to avoid data races with parallel
       threads.

       <b>numa_distance</b>() reports the distance in the machine topology
       between two nodes.  The factors are a multiple of 10. It returns
       0 when the distance cannot be determined. A node has distance 10
       to itself.  Reporting the distance requires a Linux kernel
       version of <i>2.6.10</i> or newer.

       <b>numa_set_bind_policy</b>() specifies whether calls that bind memory
       to a specific node should use the preferred policy or a strict
       policy.  The preferred policy allows the kernel to allocate
       memory on other nodes when there isn't enough free on the target
       node. strict will fail the allocation in that case.  Setting the
       argument to specifies strict, 0 preferred.  Note that specifying
       more than one node non strict may only use the first node in some
       kernel versions.

       <b>numa_set_strict</b>() sets a flag that says whether the functions
       allocating on specific nodes should use use a strict policy.
       Strict means the allocation will fail if the memory cannot be
       allocated on the target node.  Default operation is to fall back
       to other nodes.  This doesn't apply to interleave and default.

       <b>numa_get_interleave_node() </b>is used by <i>libnuma</i> internally. It is
       probably not useful for user applications.  It uses the
       MPOL_F_NODE flag of the get_mempolicy system call, which is not
       intended for application use (its operation may change or be
       removed altogether in future kernel versions). See
       get_mempolicy(2).

       <b>numa_pagesize() </b>returns the number of bytes in page. This
       function is simply a fast alternative to repeated calls to the
       getpagesize system call.  See getpagesize(2).

       <b>numa_sched_getaffinity() </b>retrieves a bitmask of the cpus on which
       a task may run.  The task is specified by <i>pid.</i>  Returns the
       return value of the sched_getaffinity system call.  See
       sched_getaffinity(2).  The bitmask must be at least the size of
       the kernel's cpu mask structure. Use <b>numa_allocate_cpumask() </b>to
       allocate it.  Test the bits in the mask by calling
       <b>numa_bitmask_isbitset().</b>

       <b>numa_sched_setaffinity() </b>sets a task's allowed cpu's to those
       cpu's specified in <i>mask.</i>  The task is specified by <i>pid.</i>  Returns
       the return value of the sched_setaffinity system call.  See
       sched_setaffinity(2).  You may allocate the bitmask with
       <b>numa_allocate_cpumask().  </b>Or the bitmask may be smaller than the
       kernel's cpu mask structure. For example, call
       <b>numa_bitmask_alloc() </b>using a maximum number of cpus from
       <b>numa_num_configured_cpus().  </b>Set the bits in the mask by calling
       <b>numa_bitmask_setbit().</b>

       <b>numa_node_to_cpus</b>() converts a node number to a bitmask of CPUs.
       The user must pass a bitmask structure with a mask buffer long
       enough to represent all possible cpu's.  Use
       numa_allocate_cpumask() to create it.  If the bitmask is not long
       enough <i><a href="errno.3.html">errno</a></i> will be set to <i>ERANGE</i> and -1 returned. On success 0
       is returned.

       <b>numa_node_to_cpu_update</b>() Mark cpus bitmask of all nodes stale,
       then get the latest bitmask by calling <b>numa_node_to_cpus</b>() This
       allows to update the libnuma state after a CPU hotplug event. The
       application is in charge of detecting CPU hotplug events.

       <b>numa_node_of_cpu</b>() returns the node that a cpu belongs to. If the
       user supplies an invalid cpu <i><a href="errno.3.html">errno</a></i> will be set to <i>EINVAL</i> and -1
       will be returned.

       <b>numa_allocate_cpumask </b>() returns a bitmask of a size equal to the
       kernel's cpu mask (kernel type cpumask_t).  In other words, large
       enough to represent NR_CPUS cpus.  This number of cpus can be
       gotten by calling <b>numa_num_possible_cpus().  </b>The bitmask is zero-
       filled.

       <b>numa_free_cpumask </b>frees a cpumask previously allocate by
       <i>numa_allocate_cpumask.</i>

       <b>numa_allocate_nodemask() </b>returns a bitmask of a size equal to the
       kernel's node mask (kernel type nodemask_t).  In other words,
       large enough to represent MAX_NUMNODES nodes.  This number of
       nodes can be gotten by calling <b>numa_num_possible_nodes().  </b>The
       bitmask is zero-filled.

       <b>numa_free_nodemask() </b>frees a nodemask previous allocated by
       <i>numa_allocate_nodemask().</i>

       <b>numa_bitmask_alloc() </b>allocates a bitmask structure and its
       associated bit mask.  The memory allocated for the bit mask
       contains enough words (type unsigned long) to contain <i>n</i> bits.
       The bit mask is zero-filled.  The bitmask structure points to the
       bit mask and contains the <i>n</i> value.

       <b>numa_bitmask_clearall() </b>sets all bits in the bit mask to 0.  The
       bitmask structure points to the bit mask and contains its size (
       <i>bmp</i> -&gt;size).  The value of <i>bmp</i> is always returned.  Note that
       <b>numa_bitmask_alloc() </b>creates a zero-filled bit mask.

       <b>numa_bitmask_clearbit() </b>sets a specified bit in a bit mask to 0.
       Nothing is done if the <i>n</i> value is greater than the size of the
       bitmask (and no error is returned). The value of <i>bmp</i> is always
       returned.

       <b>numa_bitmask_equal() </b>returns 1 if two bitmasks are equal.  It
       returns 0 if they are not equal.  If the bitmask structures
       control bit masks of different sizes, the "missing" trailing bits
       of the smaller bit mask are considered to be 0.

       <b>numa_bitmask_free() </b>deallocates the memory of both the bitmask
       structure pointed to by <i>bmp</i> and the bit mask.  It is an error to
       attempt to free this bitmask twice.

       <b>numa_bitmask_isbitset() </b>returns the value of a specified bit in a
       bit mask.  If the <i>n</i> value is greater than the size of the bit
       map, 0 is returned.

       <b>numa_bitmask_nbytes() </b>returns the size (in bytes) of the bit mask
       controlled by <i>bmp.</i>  The bit masks are always full words (type
       unsigned long), and the returned size is the actual size of all
       those words.

       <b>numa_bitmask_setall() </b>sets all bits in the bit mask to 1.  The
       bitmask structure points to the bit mask and contains its size (
       <i>bmp</i> -&gt;size).  The value of <i>bmp</i> is always returned.

       <b>numa_bitmask_setbit() </b>sets a specified bit in a bit mask to 1.
       Nothing is done if <i>n</i> is greater than the size of the bitmask (and
       no error is returned). The value of <i>bmp</i> is always returned.

       <b>copy_bitmask_to_nodemask() </b>copies the body (the bit map itself)
       of the bitmask structure pointed to by <i>bmp</i> to the nodemask_t
       structure pointed to by the <i>nodemask</i> pointer. If the two areas
       differ in size, the copy is truncated to the size of the
       receiving field or zero-filled.

       <b>copy_nodemask_to_bitmask() </b>copies the nodemask_t structure
       pointed to by the <i>nodemask</i> pointer to the body (the bit map
       itself) of the bitmask structure pointed to by the <i>bmp</i> pointer.
       If the two areas differ in size, the copy is truncated to the
       size of the receiving field or zero-filled.

       <b>copy_bitmask_to_bitmask() </b>copies the body (the bit map itself) of
       the bitmask structure pointed to by the <i>bmpfrom</i> pointer to the
       body of the bitmask structure pointed to by the <i>bmpto</i> pointer. If
       the two areas differ in size, the copy is truncated to the size
       of the receiving field or zero-filled.

       <b>numa_bitmask_weight() </b>returns a count of the bits that are set in
       the body of the bitmask pointed to by the <i>bmp</i> argument.

       <b>numa_move_pages() </b>moves a list of pages in the address space of
       the currently executing or current process.  It simply uses the
       move_pages system call.
       <i>pid</i> - ID of task.  If not valid, use the current task.
       <i>count</i> - Number of pages.
       <i>pages</i> - List of pages to move.
       <i>nodes</i> - List of nodes to which pages can be moved.
       <i>status</i> - Field to which status is to be returned.
       <i>flags</i> - MPOL_MF_MOVE or MPOL_MF_MOVE_ALL
       See move_pages(2).

       <b>numa_migrate_pages() </b>simply uses the migrate_pages system call to
       cause the pages of the calling task, or a specified task, to be
       migated from one set of nodes to another.  See migrate_pages(2).
       The bit masks representing the nodes should be allocated with
       <b>numa_allocate_nodemask() </b>, or with <b>numa_bitmask_alloc() </b>using an
       <i>n</i> value returned from <b>numa_num_possible_nodes().  </b>A task's
       current node set can be gotten by calling <b>numa_get_membind().</b>
       Bits in the <i>tonodes</i> mask can be set by calls to
       <b>numa_bitmask_setbit().</b>

       <b>numa_error</b>() is a <i>libnuma</i> internal function that can be
       overridden by the user program.  This function is called with a
       <i>char *</i> argument when a <i>libnuma</i> function fails.  Overriding the
       library internal definition makes it possible to specify a
       different error handling strategy when a <i>libnuma</i> function fails.
       It does not affect <b>numa_available</b>().  The <b>numa_error</b>() function
       defined in <i>libnuma</i> prints an error on <i>stderr</i> and terminates the
       program if <i>numa_exit_on_error</i> is set to a non-zero value.  The
       default value of <i>numa_exit_on_error</i> is zero.

       <b>numa_warn</b>() is a <i>libnuma</i> internal function that can be also
       overridden by the user program.  It is called to warn the user
       when a <i>libnuma</i> function encounters a non-fatal error.  The
       default implementation prints a warning to <i>stderr</i>.  The first
       argument is a unique number identifying each warning. After that
       there is a <a href="printf.3.html">printf(3)</a>-style format string and a variable number of
       arguments.  <i>numa_warn</i> exits the program when <i>numa_exit_on_warn</i> is
       set to a non-zero value.  The default value of <i>numa_exit_on_warn</i>
       is zero.
</pre> <h2>
Compatibility with libnuma version 1 </h2>
<pre>
       Binaries that were compiled for libnuma version 1 need not be re-
       compiled to run with libnuma version 2.
       Source codes written for libnuma version 1 may be re-compiled
       without change with version 2 installed. To do so, in the code's
       Makefile add this option to CFLAGS:
       -DNUMA_VERSION1_COMPATIBILITY
</pre> <h2>
THREAD SAFETY </h2>
<pre>
       <i>numa_set_bind_policy</i> and <i>numa_exit_on_error</i> are process global.
       The other calls are thread safe.
</pre> <h2>
COPYRIGHT </h2>
<pre>
       Copyright 2002, 2004, 2007, 2008 Andi Kleen, SuSE Labs.  <i>libnuma</i>
       is under the GNU Lesser General Public License, v2.1.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man2/get_mempolicy.2.html">get_mempolicy(2)</a>, <a href="../man2/set_mempolicy.2.html">set_mempolicy(2)</a>, <a href="../man2/getpagesize.2.html">getpagesize(2)</a>, <a href="../man2/mbind.2.html">mbind(2)</a>,
       <a href="../man2/mmap.2.html">mmap(2)</a>, <a href="../man2/shmat.2.html">shmat(2)</a>, <a href="../man8/numactl.8.html">numactl(8)</a>, <a href="../man2/sched_getaffinity.2.html">sched_getaffinity(2)</a>
       <a href="../man2/sched_setaffinity.2.html">sched_setaffinity(2)</a> <a href="../man2/move_pages.2.html">move_pages(2)</a> <a href="../man2/migrate_pages.2.html">migrate_pages(2)</a>
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>numactl</i> (NUMA commands) project.
       Information about the project can be found at 
       ⟨<a href="http://oss.sgi.com/projects/libnuma/">http://oss.sgi.com/projects/libnuma/</a>⟩.  If you have a bug report
       for this manual page, send it to linux-numa@vger.kernel.org.
       This page was obtained from the project's upstream Git repository
       ⟨<a href="https://github.com/numactl/numactl.git">https://github.com/numactl/numactl.git</a>⟩ on 2024-06-14.  (At that
       time, the date of the most recent commit that was found in the
       repository was 2024-06-10.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">SuSE Labs                     December 2007                      <i>NUMA</i>(3)</span>
</pre>  <p>Pages that refer to this page: <a href="../man2/get_mempolicy.2.html">get_mempolicy(2)</a>, <a href="../man2/mbind.2.html">mbind(2)</a>, <a href="../man2/migrate_pages.2.html">migrate_pages(2)</a>, <a href="../man2/move_pages.2.html">move_pages(2)</a>, <a href="../man2/set_mempolicy.2.html">set_mempolicy(2)</a>, <a href="../man7/numa.7.html">numa(7)</a>, <a href="../man8/numastat.8.html">numastat(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man3/numa.3.html" class="_attribution-link">https://man7.org/linux/man-pages/man3/numa.3.html</a>
  </p>
</div>
