<h1>lttng-ust(3) — Linux manual page</h1>   <pre>
<span class="headline"><i>LTTNG-UST</i>(3)                  LTTng Manual                  <i>LTTNG-UST</i>(3)</span>
</pre> <h2>
NAME </h2>
<pre>
       lttng-ust - LTTng user space tracing
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;lttng/tracepoint.h&gt;</b>

       #define <b>LTTNG_UST_TP_ARGS</b>(<i>args</i>...)
       #define <b>LTTNG_UST_TP_ENUM_VALUES</b>(<i>values</i>...)
       #define <b>LTTNG_UST_TP_FIELDS</b>(<i>fields</i>...)
       #define <b>LTTNG_UST_TRACEPOINT_ENUM</b>(<i>prov_name</i>, <i>enum_name</i>, <i>mappings</i>)
       #define <b>LTTNG_UST_TRACEPOINT_EVENT</b>(<i>prov_name</i>, <i>t_name</i>, <i>args</i>, <i>fields</i>)
       #define <b>LTTNG_UST_TRACEPOINT_EVENT_CLASS</b>(<i>cls_prov_name</i>, <i>cls_name</i>,
                                                <i>args</i>, <i>fields</i>)
       #define <b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE</b>(<i>cls_prov_name</i>, <i>cls_name</i>,
                                                   <i>inst_prov_name</i>, <i>t_name</i>, <i>args</i>)
       #define <b>LTTNG_UST_TRACEPOINT_LOGLEVEL</b>(<i>prov_name</i>, <i>t_name</i>, <i>level</i>)
       #define <b>lttng_ust_do_tracepoint</b>(<i>prov_name</i>, <i>t_name</i>, ...)
       #define <b>lttng_ust_field_array</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>count</i>)
       #define <b>lttng_ust_field_array_nowrite</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>count</i>)
       #define <b>lttng_ust_field_array_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>count</i>)
       #define <b>lttng_ust_field_array_nowrite_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                                 <i>count</i>)
       #define <b>lttng_ust_field_array_network</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>count</i>)
       #define <b>lttng_ust_field_array_network_nowrite</b>(<i>int_type</i>, <i>field_name</i>,
                                                     <i>expr</i>, <i>count</i>)
       #define <b>lttng_ust_field_array_network_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                                 <i>count</i>)
       #define <b>lttng_ust_field_array_network_nowrite_hex</b>(<i>int_type</i>, <i>field_name</i>,
                                                         <i>expr</i>, <i>count</i>)
       #define <b>lttng_ust_field_array_text</b>(char, <i>field_name</i>, <i>expr</i>, <i>count</i>)
       #define <b>lttng_ust_field_array_text_nowrite</b>(char, <i>field_name</i>, <i>expr</i>,
                                                  <i>count</i>)
       #define <b>lttng_ust_field_enum</b>(<i>prov_name</i>, <i>enum_name</i>, <i>int_type</i>, <i>field_name</i>,
                                    <i>expr</i>)
       #define <b>lttng_ust_field_enum_nowrite</b>(<i>prov_name</i>, <i>enum_name</i>, <i>int_type</i>,
                                            <i>field_name</i>, <i>expr</i>)
       #define <b>lttng_ust_field_enum_value</b>(<i>label</i>, <i>value</i>)
       #define <b>lttng_ust_field_enum_range</b>(<i>label</i>, <i>start</i>, <i>end</i>)
       #define <b>lttng_ust_field_float</b>(<i>float_type</i>, <i>field_name</i>, <i>expr</i>)
       #define <b>lttng_ust_field_float_nowrite</b>(<i>float_type</i>, <i>field_name</i>, <i>expr</i>)
       #define <b>lttng_ust_field_integer</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>)
       #define <b>lttng_ust_field_integer_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>)
       #define <b>lttng_ust_field_integer_network</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>)
       #define <b>lttng_ust_field_integer_network_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>)
       #define <b>lttng_ust_field_integer_nowrite</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>)
       #define <b>lttng_ust_field_sequence</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                        <i>len_type</i>, <i>len_expr</i>)
       #define <b>lttng_ust_field_sequence_nowrite</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                                <i>len_type</i>, <i>len_expr</i>)
       #define <b>lttng_ust_field_sequence_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                            <i>len_type</i>, <i>len_expr</i>)
       #define <b>lttng_ust_field_sequence_nowrite_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                                    <i>len_type</i>, <i>len_expr</i>)
       #define <b>lttng_ust_field_sequence_network</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                                <i>len_type</i>, <i>len_expr</i>)
       #define <b>lttng_ust_field_sequence_network_nowrite</b>(<i>int_type</i>, <i>field_name</i>,
                                                        <i>expr</i>, <i>len_type</i>,
                                                        <i>len_expr</i>)
       #define <b>lttng_ust_field_sequence_network_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                                    <i>len_type</i>, <i>len_expr</i>)
       #define <b>lttng_ust_field_sequence_network_nowrite_hex</b>(<i>int_type</i>,
                                                            <i>field_name</i>,
                                                            <i>expr</i>, <i>len_type</i>,
                                                            <i>len_expr</i>)
       #define <b>lttng_ust_field_sequence_text</b>(char, <i>field_name</i>, <i>expr</i>, <i>len_type</i>,
                                             <i>len_expr</i>)
       #define <b>lttng_ust_field_sequence_text_nowrite</b>(char, <i>field_name</i>, <i>expr</i>,
                                                     <i>len_type</i>, <i>len_expr</i>)
       #define <b>lttng_ust_field_string</b>(<i>field_name</i>, <i>expr</i>)
       #define <b>lttng_ust_field_string_nowrite</b>(<i>field_name</i>, <i>expr</i>)
       #define <b>lttng_ust_tracepoint</b>(<i>prov_name</i>, <i>t_name</i>, ...)
       #define <b>lttng_ust_tracepoint_enabled</b>(<i>prov_name</i>, <i>t_name</i>)

       Link with, following this manual page:

       •   <b>-llttng-ust -ldl</b>

       •   If you define <b>_LGPL_SOURCE </b>before including
           <b>&lt;lttng/tracepoint.h&gt; </b>(directly or indirectly): <b>-llttng-ust-</b>
           <b>common</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <i>Linux Trace Toolkit: next generation</i> &lt;<a href="http://lttng.org/">http://lttng.org/</a>&gt; is
       an open source software package used for correlated tracing of
       the Linux kernel, user applications, and user libraries.

       LTTng-UST is the user space tracing component of the LTTng
       project. It is a port to user space of the low-overhead tracing
       capabilities of the LTTng Linux kernel tracer. The <b>liblttng-ust</b>
       library is used to trace user applications and libraries.

           <b>Note</b>

           This man page is about the <b>liblttng-ust </b>library. The
           LTTng-UST project also provides Java and Python packages to
           trace applications written in those languages. How to
           instrument and trace Java and Python applications is
           documented in the online LTTng documentation
           &lt;<a href="http://lttng.org/docs/">http://lttng.org/docs/</a>&gt;.

       There are three ways to use <b>liblttng-ust</b>:

       •   Using the <a href="lttng_ust_tracef.3.html">lttng_ust_tracef(3)</a> API, which is similar to
           <a href="printf.3.html">printf(3)</a>.

       •   Using the <a href="lttng_ust_tracelog.3.html">lttng_ust_tracelog(3)</a> API, which is
           <a href="lttng_ust_tracef.3.html">lttng_ust_tracef(3)</a> with a log level parameter.

       •   Defining your own tracepoints. See the <i>Creating a tracepoint</i>
           <i>provider</i> section below.

   <b>Compatibility with previous APIs</b>
       Since LTTng-UST 2.13, the <b>LTTNG_UST_COMPAT_API_VERSION </b>definition
       controls which LTTng-UST APIs are available (compiled):

       Undefined
           All APIs are available.

       <i>N</i> (0 or positive integer)
           API version <i>N</i>, and all the following existing APIs, are
           available. Previous APIs are not available (not compiled).

       The following table shows the mapping from LTTng-UST versions (up
       to LTTng-UST 2.14.0-pre) to available API versions:
       ┌───────────────────┬────────────────────────┐
       │ <b>LTTng-UST version </b>│ <b>Available API versions </b>│
       ├───────────────────┼────────────────────────┤
       │                   │                        │
       │ 2.0 to 2.12       │ 0                      │
       ├───────────────────┼────────────────────────┤
       │                   │                        │
       │ 2.13              │ 0 and 1                │
       └───────────────────┴────────────────────────┘

       This manual page <b>only </b>documents version 1 of the API.

       If you wish to have access to version 0 of the API (for example,
       the <b>tracepoint()</b>, <b>ctf_integer()</b>, and <b>TRACEPOINT_EVENT() </b>macros),
       then either don’t define <b>LTTNG_UST_COMPAT_API_VERSION</b>, or define
       it to <b>0 </b>before including any LTTng-UST header.

   <b>Creating a tracepoint provider</b>
       Creating a tracepoint provider is the first step of using
       <b>liblttng-ust</b>. The next steps are:

       •   <i>Instrumenting your application with</i> <b>lttng_ust_tracepoint()</b>
           calls

       •   Building your application with LTTng-UST support, either
           <i>statically</i> or <i>dynamically</i>.

       A <b>tracepoint provider </b>is a compiled object containing the event
       probes corresponding to your custom tracepoint definitions. A
       tracepoint provider contains the code to get the size of an event
       and to serialize it, amongst other things.

       To create a tracepoint provider, start with the following
       <i>tracepoint provider header</i> template:

           #undef LTTNG_UST_TRACEPOINT_PROVIDER
           #define LTTNG_UST_TRACEPOINT_PROVIDER my_provider

           #undef LTTNG_UST_TRACEPOINT_INCLUDE
           #define LTTNG_UST_TRACEPOINT_INCLUDE "./tp.h"

           #if !defined(_TP_H) || \
               defined(LTTNG_UST_TRACEPOINT_HEADER_MULTI_READ)
           #define _TP_H

           #include &lt;lttng/tracepoint.h&gt;

           /*
            * LTTNG_UST_TRACEPOINT_EVENT(), LTTNG_UST_TRACEPOINT_EVENT_CLASS(),
            * LTTNG_UST_TRACEPOINT_EVENT_INSTANCE(),
            * LTTNG_UST_TRACEPOINT_LOGLEVEL(), and `LTTNG_UST_TRACEPOINT_ENUM()`
            * are used here.
            */

           #endif /* _TP_H */

           #include &lt;lttng/tracepoint-event.h&gt;

       In this template, the tracepoint provider is named <b>my_provider</b>
       (<b>LTTNG_UST_TRACEPOINT_PROVIDER </b>definition). The file needs to
       bear the name of the <b>LTTNG_UST_TRACEPOINT_INCLUDE </b>definition
       (<b>tp.h </b>in this case). Between <b>#include &lt;lttng/tracepoint.h&gt; </b>and
       <b>#endif </b>go the invocations of the <b>LTTNG_UST_TRACEPOINT_EVENT()</b>,
       <b>LTTNG_UST_TRACEPOINT_EVENT_CLASS()</b>,
       <b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE()</b>,
       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL()</b>, and <b>LTTNG_UST_TRACEPOINT_ENUM()</b>
       macros.

           <b>Note</b>

           You can avoid writing the prologue and epilogue boilerplate
           in the template file above by using the <a href="../man1/lttng-gen-tp.1.html">lttng-gen-tp(1)</a> tool
           shipped with LTTng-UST.

       The tracepoint provider header file needs to be included in a
       source file which looks like this:

           #define LTTNG_UST_TRACEPOINT_CREATE_PROBES

           #include "tp.h"

       Together, those two files (let’s call them <b>tp.h </b>and <b>tp.c</b>) form
       the tracepoint provider sources, ready to be compiled.

       You can create multiple tracepoint providers to be used in a
       single application, but each one must have its own header file.

       The <b>LTTNG_UST_TRACEPOINT_EVENT() </b>usage section below shows how to
       use the <b>LTTNG_UST_TRACEPOINT_EVENT() </b>macro to define the actual
       tracepoints in the tracepoint provider header file.

       See the <i>EXAMPLE</i> section below for a complete example.

   <b>LTTNG_UST_TRACEPOINT_EVENT() </b>usage
       The <b>LTTNG_UST_TRACEPOINT_EVENT() </b>macro is used in a template
       provider header file (see the <i>Creating a tracepoint provider</i>
       section above) to define LTTng-UST tracepoints.

       The <b>LTTNG_UST_TRACEPOINT_EVENT() </b>usage template is as follows:

           LTTNG_UST_TRACEPOINT_EVENT(
               /* Tracepoint provider name */
               my_provider,

               /* Tracepoint/event name */
               my_tracepoint,

               /* List of tracepoint arguments (input) */
               LTTNG_UST_TP_ARGS(
                   ...
               ),

               /* List of fields of eventual event (output) */
               LTTNG_UST_TP_FIELDS(
                   ...
               )
           )

       The <b>LTTNG_UST_TP_ARGS() </b>macro contains the input arguments of the
       tracepoint. Those arguments can be used in the argument
       expressions of the output fields defined in
       <b>LTTNG_UST_TP_FIELDS()</b>.

       The format of the <b>LTTNG_UST_TP_ARGS() </b>parameters is: C type, then
       argument name; repeat as needed, up to ten times. For example:

           LTTNG_UST_TP_ARGS(
               int, my_int,
               const char *, my_string,
               FILE *, my_file,
               double, my_float,
               struct my_data *, my_data
           )

       The <b>LTTNG_UST_TP_FIELDS() </b>macro contains the output fields of the
       tracepoint, that is, the actual data that can be recorded in the
       payload of an event emitted by this tracepoint.

       The <b>LTTNG_UST_TP_FIELDS() </b>macro contains a list of
       <b>lttng_ust_field_*() </b>macros NOT separated by commas. The available
       macros are documented in the <i>Available</i> <b>lttng_ust_field_*() </b>field
       type macros section below.

   <b>Available field macros</b>
       This section documents the available <b>lttng_ust_field_*() </b>macros
       that can be inserted in the <b>LTTNG_UST_TP_FIELDS() </b>macro of the
       <b>LTTNG_UST_TRACEPOINT_EVENT() </b>macro.

       Standard integer, displayed in base 10:

           <b>lttng_ust_field_integer</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>)
           <b>lttng_ust_field_integer_nowrite</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>)

       Standard integer, displayed in base 16:

           <b>lttng_ust_field_integer_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>)

       Integer in network byte order (big endian), displayed in base 10:

           <b>lttng_ust_field_integer_network</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>)

       Integer in network byte order, displayed in base 16:

           <b>lttng_ust_field_integer_network_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>)

       Floating point number:

           <b>lttng_ust_field_float</b>(<i>float_type</i>, <i>field_name</i>, <i>expr</i>)
           <b>lttng_ust_field_float_nowrite</b>(<i>float_type</i>, <i>field_name</i>, <i>expr</i>)

       Null-terminated string:

           <b>lttng_ust_field_string</b>(<i>field_name</i>, <i>expr</i>)
           <b>lttng_ust_field_string_nowrite</b>(<i>field_name</i>, <i>expr</i>)

       Statically-sized array of integers (<b>_hex </b>versions displayed in
       hexadecimal, <b>_network </b>versions in network byte order):

           <b>lttng_ust_field_array</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>count</i>)
           <b>lttng_ust_field_array_nowrite</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>count</i>)
           <b>lttng_ust_field_array_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>count</i>)
           <b>lttng_ust_field_array_nowrite_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>count</i>)
           <b>lttng_ust_field_array_network</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>count</i>)
           <b>lttng_ust_field_array_network_nowrite</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                                 <i>count</i>)
           <b>lttng_ust_field_array_network_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>count</i>)
           <b>lttng_ust_field_array_network_nowrite_hex</b>(<i>int_type</i>, <i>field_name</i>,
                                                     <i>expr</i>, <i>count</i>)

       Statically-sized array, printed as text; no need to be
       null-terminated:

           <b>lttng_ust_field_array_text</b>(char, <i>field_name</i>, <i>expr</i>, <i>count</i>)
           <b>lttng_ust_field_array_text_nowrite</b>(char, <i>field_name</i>, <i>expr</i>, <i>count</i>)

       Dynamically-sized array of integers (<b>_hex </b>versions displayed in
       hexadecimal, <b>_network </b>versions in network byte order):

           <b>lttng_ust_field_sequence</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>len_type</i>,
                                    <i>len_expr</i>)
           <b>lttng_ust_field_sequence_nowrite</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                            <i>len_type</i>, <i>len_expr</i>)
           <b>lttng_ust_field_sequence_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>, <i>len_type</i>,
                                        <i>len_expr</i>)
           <b>lttng_ust_field_sequence_nowrite_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                                <i>len_type</i>, <i>len_expr</i>)
           <b>lttng_ust_field_sequence_network</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                            <i>len_type</i>, <i>len_expr</i>)
           <b>lttng_ust_field_sequence_network_nowrite</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                                    <i>len_type</i>, <i>len_expr</i>)
           <b>lttng_ust_field_sequence_network_hex</b>(<i>int_type</i>, <i>field_name</i>, <i>expr</i>,
                                                <i>len_type</i>, <i>len_expr</i>)
           <b>lttng_ust_field_sequence_network_nowrite_hex</b>(<i>int_type</i>, <i>field_name</i>,
                                                        <i>expr</i>, <i>len_type</i>,
                                                        <i>len_expr</i>)

       Dynamically-sized array, displayed as text; no need to be
       null-terminated:

           <b>lttng_ust_field_sequence_text</b>(char, <i>field_name</i>, <i>expr</i>, <i>len_type</i>,
                                         <i>len_expr</i>)
           <b>lttng_ust_field_sequence_text_nowrite</b>(char, <i>field_name</i>, <i>expr</i>,
                                                 <i>len_type</i>, <i>len_expr</i>)

       Enumeration. The enumeration field must be defined before using
       this macro with the <b>LTTNG_UST_TRACEPOINT_ENUM() </b>macro. See the
       <b>LTTNG_UST_TRACEPOINT_ENUM() </b>usage section for more information.

           <b>lttng_ust_field_enum</b>(<i>prov_name</i>, <i>enum_name</i>, <i>int_type</i>, <i>field_name</i>,
                                <i>expr</i>)
           <b>lttng_ust_field_enum_nowrite</b>(<i>prov_name</i>, <i>enum_name</i>, <i>int_type</i>,
                                        <i>field_name</i>, <i>expr</i>)

       The parameters are:

       <i>count</i>
           Number of elements in array/sequence. This must be known at
           compile time.

       <i>enum_name</i>
           Name of an enumeration field previously defined with the
           <b>LTTNG_UST_TRACEPOINT_ENUM() </b>macro. See the
           <b>LTTNG_UST_TRACEPOINT_ENUM() </b>usage section for more
           information.

       <i>expr</i>
           C expression resulting in the field’s value. This expression
           can use one or more arguments passed to the tracepoint. The
           arguments of a given tracepoint are defined in the
           <b>LTTNG_UST_TP_ARGS() </b>macro (see the <i>Creating a tracepoint</i>
           <i>provider</i> section above).

       <i>field_name</i>
           Event field name (C identifier syntax, NOT a literal string).

       <i>float_type</i>
           Float C type (<b>float </b>or <b>double</b>). The size of this type
           determines the size of the floating point number field.

       <i>int_type</i>
           Integer C type. The size of this type determines the size of
           the integer/enumeration field.

       <i>len_expr</i>
           C expression resulting in the sequence’s length. This
           expression can use one or more arguments passed to the
           tracepoint.

       <i>len_type</i>
           Unsigned integer C type of sequence’s length.

       <i>prov_name</i>
           Tracepoint provider name. This must be the same as the
           tracepoint provider name used in a previous field definition.

       The <b>_nowrite </b>versions omit themselves from the recorded trace,
       but are otherwise identical. Their primary purpose is to make
       some of the event context available to the event filters without
       having to commit the data to sub-buffers. See
       <a href="../man1/lttng-enable-event.1.html">lttng-enable-event(1)</a> to learn more about dynamic event
       filtering.

       See the <i>EXAMPLE</i> section below for a complete example.

   <b>LTTNG_UST_TRACEPOINT_ENUM() </b>usage
       An enumeration field is a list of mappings between an integers,
       or a range of integers, and strings (sometimes called <i>labels</i> or
       <i>enumerators</i>). Enumeration fields can be used to have a more
       compact trace when the possible values for a field are limited.

       An enumeration field is defined with the
       <b>LTTNG_UST_TRACEPOINT_ENUM() </b>macro:

           LTTNG_UST_TRACEPOINT_ENUM(
               /* Tracepoint provider name */
               my_provider,

               /* Enumeration name (unique in the whole tracepoint provider) */
               my_enum,

               /* Enumeration mappings */
               LTTNG_UST_TP_ENUM_VALUES(
                   ...
               )
           )

       <b>LTTNG_UST_TP_ENUM_VALUES() </b>contains a list of enumeration
       mappings, NOT separated by commas. Two macros can be used in the
       <b>LTTNG_UST_TP_ENUM_VALUES()</b>: <b>lttng_ust_field_enum_value() </b>and
       <b>lttng_ust_field_enum_range()</b>.

       <b>lttng_ust_field_enum_value() </b>is a single value mapping:

           <b>lttng_ust_field_enum_value</b>(<i>label</i>, <i>value</i>)

       This macro maps the given <i>label</i> string to the value <i>value</i>.

       <b>lttng_ust_field_enum_range() </b>is a range mapping:

           <b>lttng_ust_field_enum_range</b>(<i>label</i>, <i>start</i>, <i>end</i>)

       This macro maps the given <i>label</i> string to the range of integers
       from <i>start</i> to <i>end</i>, inclusively. Range mappings may overlap, but
       the behaviour is implementation-defined: each trace reader
       handles overlapping ranges as it wishes.

       See the <i>EXAMPLE</i> section below for a complete example.

   <b>LTTNG_UST_TRACEPOINT_EVENT_CLASS() </b>usage
       A <b>tracepoint class </b>is a class of tracepoints sharing the same
       field types and names. A tracepoint instance is one instance of
       such a declared tracepoint class, with its own event name.

       LTTng-UST creates one event serialization function per tracepoint
       class. Using <b>LTTNG_UST_TRACEPOINT_EVENT() </b>creates one tracepoint
       class per tracepoint definition, whereas using
       <b>LTTNG_UST_TRACEPOINT_EVENT_CLASS() </b>and
       <b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE() </b>creates one tracepoint
       class, and one or more tracepoint instances of this class. In
       other words, many tracepoints can reuse the same serialization
       code. Reusing the same code, when possible, can reduce cache
       pollution, thus improve performance.

       The <b>LTTNG_UST_TRACEPOINT_EVENT_CLASS() </b>macro accepts the same
       parameters as the <b>LTTNG_UST_TRACEPOINT_EVENT() </b>macro, except that
       instead of an event name, its second parameter is the <i>tracepoint</i>
       <i>class name</i>:

           #define LTTNG_UST_TRACEPOINT_PROVIDER my_provider

           /* ... */

           LTTNG_UST_TRACEPOINT_EVENT_CLASS(
               /* Tracepoint class provider name */
               my_provider,

               /* Tracepoint class name */
               my_tracepoint_class,

               /* List of tracepoint arguments (input) */
               LTTNG_UST_TP_ARGS(
                   ...
               ),

               /* List of fields of eventual event (output) */
               LTTNG_UST_TP_FIELDS(
                   ...
               )
           )

       Once the tracepoint class is defined, you can create as many
       tracepoint instances as needed:

           #define LTTNG_UST_TRACEPOINT_PROVIDER natality

           /* ... */

           LTTNG_UST_TRACEPOINT_EVENT_INSTANCE(
               /* Name of the tracepoint class provider */
               my_provider,

               /* Tracepoint class name */
               my_tracepoint_class,

               /* Name of the local (instance) tracepoint provider */
               natality,

               /* Tracepoint/event name */
               my_tracepoint,

               /* List of tracepoint arguments (input) */
               LTTNG_UST_TP_ARGS(
                   ...
               )
           )

       As you can see, the <b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE() </b>does
       not contain the <b>LTTNG_UST_TP_FIELDS() </b>macro, because they are
       defined at the <b>LTTNG_UST_TRACEPOINT_EVENT_CLASS() </b>level.

       Note that the <b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE() </b>macro
       requires two provider names:

       •   The name of the tracepoint class provider (<b>my_provider </b>in the
           example above).

           This is the same as the first argument of the
           <b>LTTNG_UST_TRACEPOINT_EVENT_CLASS() </b>expansion to refer to.

       •   The name of the local, or instance, provider (<b>natality </b>in the
           example above).

           This is the provider name which becomes the prefix part of
           the name of the events which such a tracepoint creates.

       The two provider names may be different if the tracepoint class
       and the tracepoint instance macros are in two different
       translation units.

       See the <i>EXAMPLE</i> section below for a complete example.

   <b>LTTNG_UST_TRACEPOINT_LOGLEVEL() </b>usage
       Optionally, a <b>log level </b>can be assigned to a defined tracepoint.
       Assigning different levels of severity to tracepoints can be
       useful: when controlling tracing sessions, you can choose to only
       enable events falling into a specific log level range using the
       <b>--loglevel </b>and <b>--loglevel-only </b>options of the
       <a href="../man1/lttng-enable-event.1.html">lttng-enable-event(1)</a> command.

       Log levels are assigned to tracepoints that are already defined
       using the <b>LTTNG_UST_TRACEPOINT_LOGLEVEL() </b>macro. The latter must
       be used after having used <b>LTTNG_UST_TRACEPOINT_EVENT() </b>or
       <b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE() </b>for a given tracepoint. The
       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL() </b>macro is used as follows:

           LTTNG_UST_TRACEPOINT_LOGLEVEL(
               /* Tracepoint provider name */
               my_provider,

               /* Tracepoint/event name */
               my_tracepoint,

               /* Log level */
               LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO
           )

       The available log level definitions are:

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_EMERG</b>
           System is unusable.

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_ALERT</b>
           Action must be taken immediately.

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_CRIT</b>
           Critical conditions.

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_ERR</b>
           Error conditions.

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_WARNING</b>
           Warning conditions.

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_NOTICE</b>
           Normal, but significant, condition.

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO</b>
           Informational message.

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_SYSTEM</b>
           Debug information with system-level scope (set of programs).

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_PROGRAM</b>
           Debug information with program-level scope (set of
           processes).

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_PROCESS</b>
           Debug information with process-level scope (set of modules).

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_MODULE</b>
           Debug information with module (executable/library) scope (set
           of units).

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_UNIT</b>
           Debug information with compilation unit scope (set of
           functions).

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_FUNCTION</b>
           Debug information with function-level scope.

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_LINE</b>
           Debug information with line-level scope (default log level).

       <b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG</b>
           Debug-level message.

       See the <i>EXAMPLE</i> section below for a complete example.

   <b>Instrumenting your application</b>
       Once the tracepoint provider is created (see the <i>Creating a</i>
       <i>tracepoint provider</i> section above), you can instrument your
       application with the defined tracepoints thanks to the
       <b>lttng_ust_tracepoint() </b>macro:

           #define <b>lttng_ust_tracepoint</b>(<i>prov_name</i>, <i>t_name</i>, ...)

       With:

       <i>prov_name</i>
           Tracepoint provider name.

       <i>t_name</i>
           Tracepoint/event name.

       <b>...</b>
           Tracepoint arguments, if any.

       Make sure to include the tracepoint provider header file anywhere
       you use <b>lttng_ust_tracepoint() </b>for this provider.

           <b>Note</b>

           Even though LTTng-UST supports <b>lttng_ust_tracepoint() </b>call
           site duplicates having the same provider and tracepoint
           names, it is recommended to use a provider/tracepoint name
           pair only once within the application source code to help map
           events back to their call sites when analyzing the trace.

       Sometimes, arguments to the tracepoint are expensive to compute
       (take call stack, for example). To avoid the computation when the
       tracepoint is disabled, you can use the
       <b>lttng_ust_tracepoint_enabled() </b>and <b>lttng_ust_do_tracepoint()</b>
       macros:

           #define <b>lttng_ust_tracepoint_enabled</b>(<i>prov_name</i>, <i>t_name</i>)
           #define <b>lttng_ust_do_tracepoint</b>(<i>prov_name</i>, <i>t_name</i>, ...)

       <b>lttng_ust_tracepoint_enabled() </b>returns a non-zero value if the
       tracepoint named <i>t_name</i> from the provider named <i>prov_name</i> is
       enabled at run time.

       <b>lttng_ust_do_tracepoint() </b>is like <b>lttng_ust_tracepoint()</b>, except
       that it doesn’t check if the tracepoint is enabled. Using
       <b>lttng_ust_tracepoint() </b>with <b>lttng_ust_tracepoint_enabled() </b>is
       dangerous since <b>lttng_ust_tracepoint() </b>also contains the
       <b>lttng_ust_tracepoint_enabled() </b>check, thus a race condition is
       possible in this situation:

           if (lttng_ust_tracepoint_enabled(my_provider, my_tracepoint)) {
               stuff = prepare_stuff();
           }

           lttng_ust_tracepoint(my_provider, my_tracepoint, stuff);

       If the tracepoint is enabled after the condition, then <b>stuff </b>is
       not prepared: the emitted event will either contain wrong data,
       or the whole application could crash (segmentation fault, for
       example).

           <b>Note</b>

           Neither <b>lttng_ust_tracepoint_enabled() </b>nor
           <b>lttng_ust_do_tracepoint() </b>have a <b>STAP_PROBEV() </b>call, so if
           you need it, you should emit this call yourself.

       <b>Tracing in C/C++ constructors and destructors</b>

           As of LTTng-UST 2.13, tracepoint definitions are implemented
           using compound literals. In the following cases, those
           compound literals are allocated on the heap:

           •   g++ ⟨= 4.8 is used as the compiler or,

           •   <b>LTTNG_UST_ALLOCATE_COMPOUND_LITERAL_ON_HEAP </b>is defined in
               the C pre-processor flags and the application is compiled
               with a C++ compiler

           When the compound literals are heap-allocated, there are some
           cases in which both C-style and C++ constructors and
           destructors will not be traced.

            1. C-style constructors and destructors in statically linked
               archives

            2. C-style constructors and destructors in the application
               itself

            3. Some C++-style constructors and destructors in the
               application and statically linked archives

           In the 3rd case above, which C++-style constructors and
           destructors will not be traced depends on the initialization
           order within each translation unit and across the entire
           program when all translation units are linked together.

   <b>Statically linking the tracepoint provider</b>
       With the static linking method, compiled tracepoint providers are
       copied into the target application.

       Define <b>LTTNG_UST_TRACEPOINT_DEFINE </b>definition below the
       <b>LTTNG_UST_TRACEPOINT_CREATE_PROBES </b>definition in the tracepoint
       provider source:

           #define LTTNG_UST_TRACEPOINT_CREATE_PROBES
           #define LTTNG_UST_TRACEPOINT_DEFINE

           #include "tp.h"

       Create the tracepoint provider object file:

           $ cc -c -I. tp.c

           <b>Note</b>

           Although an application instrumented with LTTng-UST
           tracepoints can be compiled with a C++ compiler, tracepoint
           probes should be compiled with a C compiler.

       At this point, you <i>can</i> archive this tracepoint provider object
       file, possibly with other object files of your application or
       with other tracepoint provider object files, as a static library:

           $ ar rc tp.a tp.o

       Using a static library does have the advantage of centralising
       the tracepoint providers objects so they can be shared between
       multiple applications. This way, when the tracepoint provider is
       modified, the source code changes don’t have to be patched into
       each application’s source code tree. The applications need to be
       relinked after each change, but need not to be otherwise
       recompiled (unless the tracepoint provider’s API changes).

       Then, link your application with this object file (or with the
       static library containing it) and with <b>liblttng-ust </b>and <b>libdl</b>
       (<b>libc </b>on a BSD system):

           $ cc -o app tp.o app.o -llttng-ust -ldl

   <b>Dynamically loading the tracepoint provider</b>
       The second approach to package the tracepoint provider is to use
       the dynamic loader: the library and its member functions are
       explicitly sought, loaded at run time.

       In this scenario, the tracepoint provider is compiled as a shared
       object.

       The process to create the tracepoint provider shared object is
       pretty much the same as the <i>static linking method</i>, except that:

       •   Since the tracepoint provider is not part of the application,
           <b>LTTNG_UST_TRACEPOINT_DEFINE </b>must be defined, for each
           tracepoint provider, in exactly one source file of the
           <i>application</i>

       •   <b>LTTNG_UST_TRACEPOINT_PROBE_DYNAMIC_LINKAGE </b>must be defined
           next to <b>LTTNG_UST_TRACEPOINT_DEFINE</b>

       Regarding <b>LTTNG_UST_TRACEPOINT_DEFINE </b>and
       <b>LTTNG_UST_TRACEPOINT_PROBE_DYNAMIC_LINKAGE</b>, the recommended
       practice is to use a separate C source file in your application
       to define them, then include the tracepoint provider header files
       afterwards. For example, as <b>tp-define.c</b>:

           #define LTTNG_UST_TRACEPOINT_DEFINE
           #define LTTNG_UST_TRACEPOINT_PROBE_DYNAMIC_LINKAGE

           #include "tp.h"

       The tracepoint provider object file used to create the shared
       library is built like it is using the static linking method, but
       with the <b>-fpic </b>option:

           $ cc -c -fpic -I. tp.c

       It is then linked as a shared library like this:

           $ cc -shared -Wl,--no-as-needed -o tp.so tp.o -llttng-ust

       This tracepoint provider shared object isn’t linked with the user
       application: it must be loaded manually. This is why the
       application is built with no mention of this tracepoint provider,
       but still needs libdl:

           $ cc -o app app.o tp-define.o -ldl

       There are two ways to dynamically load the tracepoint provider
       shared object:

       •   Load it manually from the application using <a href="dlopen.3.html">dlopen(3)</a>

       •   Make the dynamic loader load it with the <b>LD_PRELOAD</b>
           environment variable (see <a href="../man8/ld.so.8.html">ld.so(8)</a>)

       If the application does not dynamically load the tracepoint
       provider shared object using one of the methods above, tracing is
       disabled for this application, and the events are not listed in
       the output of <a href="../man1/lttng-list.1.html">lttng-list(1)</a>.

       Note that it is not safe to use <a href="dlclose.3.html">dlclose(3)</a> on a tracepoint
       provider shared object that is being actively used for tracing,
       due to a lack of reference counting from LTTng-UST to the shared
       object.

       For example, statically linking a tracepoint provider to a shared
       object which is to be dynamically loaded by an application (a
       plugin, for example) is not safe: the shared object, which
       contains the tracepoint provider, could be dynamically closed (‐
       <a href="dlclose.3.html">dlclose(3)</a>) at any time by the application.

       To instrument a shared object, either:

       •   Statically link the tracepoint provider to the application,
           or

       •   Build the tracepoint provider as a shared object (following
           the procedure shown in this section), and preload it when
           tracing is needed using the <b>LD_PRELOAD </b>environment variable.

   <b>Using LTTng-UST with daemons</b>
       Some extra care is needed when using <b>liblttng-ust </b>with daemon
       applications that call <a href="../man2/fork.2.html">fork(2)</a>, <a href="../man2/clone.2.html">clone(2)</a>, or BSD’s <b>rfork</b>(2)
       without a following <a href="exec.3.html">exec(3)</a> family system call. The library
       <b>liblttng-ust-fork.so </b>needs to be preloaded before starting the
       application with the <b>LD_PRELOAD </b>environment variable (see
       <a href="../man8/ld.so.8.html">ld.so(8)</a>).

       To use <b>liblttng-ust </b>with a daemon application which closes file
       descriptors that were not opened by it, preload the <b>liblttng-ust-</b>
       <b>fd.so </b>library before you start the application. Typical use cases
       include daemons closing all file descriptors after <a href="../man2/fork.2.html">fork(2)</a>, and
       buggy applications doing “double-closes”.

   <b>Context information</b>
       Context information can be prepended by the LTTng-UST tracer
       before each event, or before specific events.

       Context fields can be added to specific channels using
       <a href="../man1/lttng-add-context.1.html">lttng-add-context(1)</a>.

       The following context fields are supported by LTTng-UST:

       General context fields

           <b>cpu_id</b>
               CPU ID.

                   <b>Note</b>
                   This context field is always enabled, and it cannot
                   be added with <a href="../man1/lttng-add-context.1.html">lttng-add-context(1)</a>. Its main purpose
                   is to be used for dynamic event filtering. See
                   <a href="../man1/lttng-enable-event.1.html">lttng-enable-event(1)</a> for more information about
                   event filtering.

           <b>ip</b>
               Instruction pointer: enables recording the exact address
               from which an event was emitted. This context field can
               be used to reverse-lookup the source location that caused
               the event to be emitted.

           <b>pthread_id</b>
               POSIX thread identifier.

               Can be used on architectures where <b>pthread_t </b>maps nicely
               to an <b>unsigned long </b>type.

       Process context fields

           <b>procname</b>
               Thread name, as set by <a href="exec.3.html">exec(3)</a> or <a href="../man2/prctl.2.html">prctl(2)</a>. It is
               recommended that programs set their thread name with
               <a href="../man2/prctl.2.html">prctl(2)</a> before hitting the first tracepoint for that
               thread.

           <b>vpid</b>
               Virtual process ID: process ID as seen from the point of
               view of the current process ID namespace (see
               <a href="../man7/pid_namespaces.7.html">pid_namespaces(7)</a>).

           <b>vtid</b>
               Virtual thread ID: thread ID as seen from the point of
               view of the current process ID namespace (see
               <a href="../man7/pid_namespaces.7.html">pid_namespaces(7)</a>).

       perf context fields

           <b>perf:thread:COUNTER</b>
               perf counter named <i>COUNTER</i>. Use <b>lttng add-context --list</b>
               to list the available perf counters.

               Only available on IA-32 and x86-64 architectures.

           <b>perf:thread:raw:rN:NAME</b>
               perf counter with raw ID <i>N</i> and custom name <i>NAME</i>. See
               <a href="../man1/lttng-add-context.1.html">lttng-add-context(1)</a> for more details.

       Namespace context fields (see <a href="../man7/namespaces.7.html">namespaces(7)</a>)

           <b>cgroup_ns</b>
               Inode number of the current control group namespace (see
               <a href="../man7/cgroup_namespaces.7.html">cgroup_namespaces(7)</a>) in the proc file system.

           <b>ipc_ns</b>
               Inode number of the current IPC namespace (see
               <a href="../man7/ipc_namespaces.7.html">ipc_namespaces(7)</a>) in the proc file system.

           <b>mnt_ns</b>
               Inode number of the current mount point namespace (see
               <a href="../man7/mount_namespaces.7.html">mount_namespaces(7)</a>) in the proc file system.

           <b>net_ns</b>
               Inode number of the current network namespace (see
               <a href="../man7/network_namespaces.7.html">network_namespaces(7)</a>) in the proc file system.

           <b>pid_ns</b>
               Inode number of the current process ID namespace (see
               <a href="../man7/pid_namespaces.7.html">pid_namespaces(7)</a>) in the proc file system.

           <b>time_ns</b>
               Inode number of the current clock namespace (see
               <a href="../man7/time_namespaces.7.html">time_namespaces(7)</a>) in the proc file system.

           <b>user_ns</b>
               Inode number of the current user namespace (see
               <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>) in the proc file system.

           <b>uts_ns</b>
               Inode number of the current UTS namespace (see
               <a href="../man7/uts_namespaces.7.html">uts_namespaces(7)</a>) in the proc file system.

       Credential context fields (see <a href="../man7/credentials.7.html">credentials(7)</a>)

           <b>vuid</b>
               Virtual real user ID: real user ID as seen from the point
               of view of the current user namespace (see
               <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>).

           <b>vgid</b>
               Virtual real group ID: real group ID as seen from the
               point of view of the current user namespace (see
               <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>).

           <b>veuid</b>
               Virtual effective user ID: effective user ID as seen from
               the point of view of the current user namespace (see
               <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>).

           <b>vegid</b>
               Virtual effective group ID: effective group ID as seen
               from the point of view of the current user namespace (see
               <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>).

           <b>vsuid</b>
               Virtual saved set-user ID: saved set-user ID as seen from
               the point of view of the current user namespace (see
               <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>).

           <b>vsgid</b>
               Virtual saved set-group ID: saved set-group ID as seen
               from the point of view of the current user namespace (see
               <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>).

   <b>LTTng-UST state dump</b>
       If an application that uses <b>liblttng-ust </b>becomes part of a
       tracing session, information about its currently loaded shared
       objects, their build IDs, and their debug link information are
       emitted as events by the tracer.

       The following LTTng-UST state dump events exist and must be
       enabled to record application state dumps. Note that, during the
       state dump phase, LTTng-UST can also emit <i>shared library</i>
       <i>load/unload</i> events (see <i>Shared library load/unload tracking</i>
       below).

       <b>lttng_ust_statedump:start</b>
           Emitted when the state dump begins.

           This event has no fields.

       <b>lttng_ust_statedump:end</b>
           Emitted when the state dump ends. Once this event is emitted,
           it is guaranteed that, for a given process, the state dump is
           complete.

           This event has no fields.

       <b>lttng_ust_statedump:bin_info</b>
           Emitted when information about a currently loaded executable
           or shared object is found.

           Fields:
           ┌────────────────┬────────────────────────────────┐
           │ <b>Field name     </b>│ <b>Description                    </b>│
           ├────────────────┼────────────────────────────────┤
           │ <b>baddr          </b>│ Base address of loaded         │
           │                │ executable.                    │
           ├────────────────┼────────────────────────────────┤
           │ <b>memsz          </b>│ Size of loaded                 │
           │                │ executable in memory.          │
           ├────────────────┼────────────────────────────────┤
           │ <b>path           </b>│ Path to loaded                 │
           │                │ executable file.               │
           ├────────────────┼────────────────────────────────┤
           │ <b>is_pic         </b>│ Whether or not the             │
           │                │ executable is                  │
           │                │ position-independent           │
           │                │ code.                          │
           ├────────────────┼────────────────────────────────┤
           │ <b>has_build_id   </b>│ Whether or not the             │
           │                │ executable has a build         │
           │                │ ID. If this field is 1,        │
           │                │ you can expect that an         │
           │                │ <b>lttng_ust_statedump:build_id   </b>│
           │                │ event record follows           │
           │                │ this one (not                  │
           │                │ necessarily immediately        │
           │                │ after).                        │
           ├────────────────┼────────────────────────────────┤
           │ <b>has_debug_link </b>│ Whether or not the             │
           │                │ executable has debug link      │
           │                │ information. If this field     │
           │                │ is 1, you can expect that an   │
           │                │ <b>lttng_ust_statedump:debug_link </b>│
           │                │ event record follows this      │
           │                │ one (not necessarily           │
           │                │ immediately after).            │
           └────────────────┴────────────────────────────────┘

       <b>lttng_ust_statedump:build_id</b>
           Emitted when a build ID is found in a currently loaded shared
           library. See Debugging Information in Separate Files
           &lt;https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-
           Files.html&gt; for more information about build IDs.

           Fields:
           ┌────────────┬────────────────────────┐
           │ <b>Field name </b>│ <b>Description            </b>│
           ├────────────┼────────────────────────┤
           │ <b>baddr      </b>│ Base address of loaded │
           │            │ library.               │
           ├────────────┼────────────────────────┤
           │ <b>build_id   </b>│ Build ID.              │
           └────────────┴────────────────────────┘

       <b>lttng_ust_statedump:debug_link</b>
           Emitted when debug link information is found in a currently
           loaded shared library. See Debugging Information in Separate
           Files &lt;https://sourceware.org/gdb/onlinedocs/gdb/Separate-
           Debug-Files.html&gt; for more information about debug links.

           Fields:
           ┌────────────┬────────────────────────┐
           │ <b>Field name </b>│ <b>Description            </b>│
           ├────────────┼────────────────────────┤
           │ <b>baddr      </b>│ Base address of loaded │
           │            │ library.               │
           ├────────────┼────────────────────────┤
           │ <b>crc        </b>│ Debug link file’s CRC. │
           ├────────────┼────────────────────────┤
           │ <b>filename   </b>│ Debug link file name.  │
           └────────────┴────────────────────────┘

       <b>lttng_ust_statedump:procname</b>
           The process procname at process start.

           Fields:
           ┌────────────┬───────────────────┐
           │ <b>Field name </b>│ <b>Description       </b>│
           ├────────────┼───────────────────┤
           │ <b>procname   </b>│ The process name. │
           └────────────┴───────────────────┘

   <b>Shared library load/unload tracking</b>
       The <i>LTTng-UST state dump</i> and the LTTng-UST helper library to
       instrument the dynamic linker (see <b>liblttng-ust-dl</b>(3)) can emit
       <b>shared library load/unload tracking </b>events.

       The following shared library load/unload tracking events exist
       and must be enabled to track the loading and unloading of shared
       libraries:

       <b>lttng_ust_lib:load</b>
           Emitted when a shared library (shared object) is loaded.

           Fields:
           ┌────────────────┬──────────────────────────┐
           │ <b>Field name     </b>│ <b>Description              </b>│
           ├────────────────┼──────────────────────────┤
           │ <b>baddr          </b>│ Base address of loaded   │
           │                │ library.                 │
           ├────────────────┼──────────────────────────┤
           │ <b>memsz          </b>│ Size of loaded library   │
           │                │ in memory.               │
           ├────────────────┼──────────────────────────┤
           │ <b>path           </b>│ Path to loaded library   │
           │                │ file.                    │
           ├────────────────┼──────────────────────────┤
           │ <b>has_build_id   </b>│ Whether or not the       │
           │                │ library has a build ID.  │
           │                │ If this field is 1, you  │
           │                │ can expect that an       │
           │                │ <b>lttng_ust_lib:build_id   </b>│
           │                │ event record follows     │
           │                │ this one (not            │
           │                │ necessarily immediately  │
           │                │ after).                  │
           ├────────────────┼──────────────────────────┤
           │ <b>has_debug_link </b>│ Whether or not the       │
           │                │ library has debug link   │
           │                │ information. If this     │
           │                │ field is 1, you can      │
           │                │ expect that an           │
           │                │ <b>lttng_ust_lib:debug_link </b>│
           │                │ event record follows     │
           │                │ this one (not            │
           │                │ necessarily immediately  │
           │                │ after).                  │
           └────────────────┴──────────────────────────┘

       <b>lttng_ust_lib:unload</b>
           Emitted when a shared library (shared object) is unloaded.

           Fields:
           ┌────────────┬──────────────────────────┐
           │ <b>Field name </b>│ <b>Description              </b>│
           ├────────────┼──────────────────────────┤
           │ <b>baddr      </b>│ Base address of unloaded │
           │            │ library.                 │
           └────────────┴──────────────────────────┘

       <b>lttng_ust_lib:build_id</b>
           Emitted when a build ID is found in a loaded shared library
           (shared object). See Debugging Information in Separate Files
           &lt;https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-
           Files.html&gt; for more information about build IDs.

           Fields:
           ┌────────────┬────────────────────────┐
           │ <b>Field name </b>│ <b>Description            </b>│
           ├────────────┼────────────────────────┤
           │ <b>baddr      </b>│ Base address of loaded │
           │            │ library.               │
           ├────────────┼────────────────────────┤
           │ <b>build_id   </b>│ Build ID.              │
           └────────────┴────────────────────────┘

       <b>lttng_ust_lib:debug_link</b>
           Emitted when debug link information is found in a loaded
           shared library (shared object). See Debugging Information in
           Separate Files
           &lt;https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-
           Files.html&gt; for more information about debug links.

           Fields:
           ┌────────────┬────────────────────────┐
           │ <b>Field name </b>│ <b>Description            </b>│
           ├────────────┼────────────────────────┤
           │ <b>baddr      </b>│ Base address of loaded │
           │            │ library.               │
           ├────────────┼────────────────────────┤
           │ <b>crc        </b>│ Debug link file’s CRC. │
           ├────────────┼────────────────────────┤
           │ <b>filename   </b>│ Debug link file name.  │
           └────────────┴────────────────────────┘

   <b>Detect if LTTng-UST is loaded</b>
       To detect if <b>liblttng-ust </b>is loaded from an application:

        1. Define the <b>lttng_ust_loaded </b>weak symbol globally:

               int lttng_ust_loaded __attribute__((weak));

           This weak symbol is set by the constructor of <b>liblttng-ust</b>.

        2. Test <b>lttng_ust_loaded </b>where needed:

               /* ... */

               if (lttng_ust_loaded) {
                   /* LTTng-UST is loaded */
               } else {
                   /* LTTng-UST is NOT loaded */
               }

               /* ... */
</pre> <h2>
EXAMPLE </h2>
<pre>
           <b>Note</b>

           A few examples are available in the <b>doc/examples</b>
           &lt;https://github.com/lttng/lttng-
           ust/tree/stable-2.14/doc/examples&gt; directory of LTTng-UST’s
           source tree.

       This example shows all the features documented in the previous
       sections. The <i>static linking</i> method is chosen here to link the
       application with the tracepoint provider.

       You can compile the source files and link them together
       statically like this:

           $ cc -c -I. tp.c
           $ cc -c app.c
           $ cc -o app tp.o app.o -llttng-ust -ldl

       Using the <a href="../man1/lttng.1.html">lttng(1)</a> tool, create an LTTng tracing session, enable
       all the events of this tracepoint provider, and start tracing:

           $ lttng create my-session
           $ lttng enable-event --userspace 'my_provider:*'
           $ lttng start

       You may also enable specific events:

           $ lttng enable-event --userspace my_provider:big_event
           $ lttng enable-event --userspace my_provider:event_instance2

       Run the application:

           $ ./app some arguments

       Stop the current tracing session and inspect the recorded events:

           $ lttng stop
           $ lttng view

   <b>Tracepoint provider header file</b>
       <b>tp.h</b>:

           #undef LTTNG_UST_TRACEPOINT_PROVIDER
           #define LTTNG_UST_TRACEPOINT_PROVIDER my_provider

           #undef LTTNG_USTTRACEPOINT_INCLUDE
           #define LTTNG_USTTRACEPOINT_INCLUDE "./tp.h"

           #if !defined(_TP_H) || \
               defined(LTTNG_UST_TRACEPOINT_HEADER_MULTI_READ)
           #define _TP_H

           #include &lt;lttng/tracepoint.h&gt;
           #include &lt;stdio.h&gt;

           #include "app.h"

           LTTNG_UST_TRACEPOINT_EVENT(
               my_provider,
               simple_event,
               LTTNG_UST_TP_ARGS(
                   int, my_integer_arg,
                   const char *, my_string_arg
               ),
               LTTNG_UST_TP_FIELDS(
                   lttng_ust_field_string(argc, my_string_arg)
                   lttng_ust_field_integer(int, argv, my_integer_arg)
               )
           )

           LTTNG_UST_TRACEPOINT_ENUM(
               my_provider,
               my_enum,
               LTTNG_UST_TP_ENUM_VALUES(
                   lttng_ust_field_enum_value("ZERO", 0)
                   lttng_ust_field_enum_value("ONE", 1)
                   lttng_ust_field_enum_value("TWO", 2)
                   lttng_ust_field_enum_range("A RANGE", 52, 125)
                   lttng_ust_field_enum_value("ONE THOUSAND", 1000)
               )
           )

           LTTNG_UST_TRACEPOINT_EVENT(
               my_provider,
               big_event,
               LTTNG_UST_TP_ARGS(
                   int, my_integer_arg,
                   const char *, my_string_arg,
                   FILE *, stream,
                   double, flt_arg,
                   int *, array_arg
               ),
               LTTNG_UST_TP_FIELDS(
                   lttng_ust_field_integer(int, int_field1, my_integer_arg * 2)
                   lttng_ust_field_integer_hex(long int, stream_pos,
                                               ftell(stream))
                   lttng_ust_field_float(double, float_field, flt_arg)
                   lttng_ust_field_string(string_field, my_string_arg)
                   lttng_ust_field_array(int, array_field, array_arg, 7)
                   lttng_ust_field_array_text(char, array_text_field,
                                              array_arg, 5)
                   lttng_ust_field_sequence(int, seq_field, array_arg, unsigned int,
                                            my_integer_arg / 10)
                   lttng_ust_field_sequence_text(char, seq_text_field,
                                                 array_arg, unsigned int,
                                                 my_integer_arg / 5)
                   lttng_ust_field_enum(my_provider, my_enum, int,
                                        enum_field, array_arg[1])
               )
           )

           LTTNG_UST_TRACEPOINT_LOGLEVEL(my_provider, big_event,
                                         LTTNG_UST_TRACEPOINT_LOGLEVEL_WARNING)

           LTTNG_UST_TRACEPOINT_EVENT_CLASS(
               my_provider,
               my_tracepoint_class,
               LTTNG_UST_TP_ARGS(
                   int, my_integer_arg,
                   struct app_struct *, app_struct_arg
               ),
               LTTNG_UST_TP_FIELDS(
                   lttng_ust_field_integer(int, a, my_integer_arg)
                   lttng_ust_field_integer(unsigned long, b, app_struct_arg-&gt;b)
                   lttng_ust_field_string(c, app_struct_arg-&gt;c)
               )
           )

           LTTNG_UST_TRACEPOINT_EVENT_INSTANCE(
               my_provider,
               my_tracepoint_class,
               my_provider,
               event_instance1,
               LTTNG_UST_TP_ARGS(
                   int, my_integer_arg,
                   struct app_struct *, app_struct_arg
               )
           )

           LTTNG_UST_TRACEPOINT_EVENT_INSTANCE(
               my_provider,
               my_tracepoint_class,
               my_provider,
               event_instance2,
               LTTNG_UST_TP_ARGS(
                   int, my_integer_arg,
                   struct app_struct *, app_struct_arg
               )
           )

           LTTNG_UST_TRACEPOINT_LOGLEVEL(my_provider, event_instance2,
                                         LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO)

           LTTNG_UST_TRACEPOINT_EVENT_INSTANCE(
               my_provider,
               my_tracepoint_class,
               my_provider,
               event_instance3,
               LTTNG_UST_TP_ARGS(
                   int, my_integer_arg,
                   struct app_struct *, app_struct_arg
               )
           )

           #endif /* _TP_H */

           #include &lt;lttng/tracepoint-event.h&gt;

   <b>Tracepoint provider source file</b>
       <b>tp.c</b>:

           #define LTTNG_UST_TRACEPOINT_CREATE_PROBES
           #define LTTNG_UST_TRACEPOINT_DEFINE

           #include "tp.h"

   <b>Application header file</b>
       <b>app.h</b>:

           #ifndef _APP_H
           #define _APP_H

           struct app_struct {
               unsigned long b;
               const char *c;
               double d;
           };

           #endif /* _APP_H */

   <b>Application source file</b>
       <b>app.c</b>:

           #include &lt;stdlib.h&gt;
           #include &lt;stdio.h&gt;

           #include "tp.h"
           #include "app.h"

           static int array_of_ints[] = {
               100, -35, 1, 23, 14, -6, 28, 1001, -3000,
           };

           int main(int argc, char* argv[])
           {
               FILE *stream;
               struct app_struct app_struct;

               lttng_ust_tracepoint(my_provider, simple_event, argc, argv[0]);
               stream = fopen("/tmp/app.txt", "w");

               if (!stream) {
                   fprintf(stderr,
                           "Error: Cannot open /tmp/app.txt for writing\n");
                   return EXIT_FAILURE;
               }

               if (fprintf(stream, "0123456789") != 10) {
                   fclose(stream);
                   fprintf(stderr, "Error: Cannot write to /tmp/app.txt\n");
                   return EXIT_FAILURE;
               }

               lttng_ust_tracepoint(my_provider, big_event, 35,
                                    "hello tracepoint", stream, -3.14,
                                    array_of_ints);
               fclose(stream);
               app_struct.b = argc;
               app_struct.c = "[the string]";
               lttng_ust_tracepoint(my_provider, event_instance1, 23,
                                    &amp;app_struct);
               app_struct.b = argc * 5;
               app_struct.c = "[other string]";
               lttng_ust_tracepoint(my_provider, event_instance2, 17,
                                    &amp;app_struct);
               app_struct.b = 23;
               app_struct.c = "nothing";
               lttng_ust_tracepoint(my_provider, event_instance3, -52,
                                    &amp;app_struct);
               return EXIT_SUCCESS;
           }
</pre> <h2>
ENVIRONMENT VARIABLES </h2>
<pre>
       <b>LTTNG_UST_APP_PATH</b>
           Path under which unix sockets used for the communication
           between the application (tracee) instrumented with <b>liblttng-</b>
           <b>ust </b>and the LTTng session and consumer daemons (part of the
           LTTng-tools project) are located. When <b>$LTTNG_UST_APP_PATH </b>is
           specified, only this path is considered for connecting to a
           session daemon. The <b>$LTTNG_UST_APP_PATH </b>target directory must
           exist and be accessible by the user before the application is
           executed for tracing to work. Setting this environment
           variable disables connection to root and per-user session
           daemons.

       <b>LTTNG_HOME</b>
           Alternative user’s home directory. This variable is useful
           when the user running the instrumented application has a
           non-writable home directory. This path is where unix sockets
           for communication with the per-user session daemon are
           located.

       <b>LTTNG_UST_ALLOW_BLOCKING</b>
           If set, allow the application to retry event tracing when
           there’s no space left for the event record in the sub-buffer,
           therefore effectively blocking the application until space is
           made available or the configured timeout is reached.

           To allow an application to block during tracing, you also
           need to specify a blocking timeout when you create a channel
           with the <b>--blocking-timeout </b>option of the
           <a href="../man1/lttng-enable-channel.1.html">lttng-enable-channel(1)</a> command.

           This option can be useful in workloads generating very large
           trace data throughput, where blocking the application is an
           acceptable trade-off to prevent discarding event records.

               <b>Warning</b>
               Setting this environment variable may significantly
               affect application timings.

       <b>LTTNG_UST_ABORT_ON_CRITICAL</b>
           If set, abort the instrumented application on a critical
           error message.

       <b>LTTNG_UST_CLOCK_PLUGIN</b>
           Path to the shared object which acts as the clock override
           plugin. An example of such a plugin can be found in the
           LTTng-UST documentation under <b>examples/clock-override</b>
           &lt;https://github.com/lttng/lttng-
           ust/tree/stable-2.14/doc/examples/clock-override&gt;.

       <b>LTTNG_UST_DEBUG</b>
           If set, enable <b>liblttng-ust</b>'s debug and error output.

       <b>LTTNG_UST_GETCPU_PLUGIN</b>
           Path to the shared object which acts as the <b>getcpu() </b>override
           plugin. An example of such a plugin can be found in the
           LTTng-UST documentation under <b>examples/getcpu-override</b>
           &lt;https://github.com/lttng/lttng-
           ust/tree/stable-2.14/doc/examples/getcpu-override&gt;.

       <b>LTTNG_UST_MAP_POPULATE_POLICY</b>
           If set, override the policy used to populate shared memory
           pages within the application. The expected values are:

           <b>none</b>
               Do not pre-populate any pages, take minor faults on first
               access while tracing.

           <b>cpu_possible</b>
               Pre-populate pages for all possible CPUs in the system,
               as listed by <b>/sys/devices/system/cpu/possible</b>.

           Default: <b>none</b>. If the policy is unknown, use the default.

       <b>LTTNG_UST_REGISTER_TIMEOUT</b>
           Waiting time for the <i>registration done</i> session daemon command
           before proceeding to execute the main program (milliseconds).

           The value <b>0 </b>means <i>do not wait</i>. The value <b>-1 </b>means <i>wait</i>
           <i>forever</i>. Setting this environment variable to <b>0 </b>is
           recommended for applications with time constraints on the
           process startup time.

           Default: 3000.

       <b>LTTNG_UST_WITHOUT_BADDR_STATEDUMP</b>
           If set, prevents <b>liblttng-ust </b>from performing a base address
           state dump (see the <i>LTTng-UST state dump</i> section above).

       <b>LTTNG_UST_WITHOUT_PROCNAME_STATEDUMP</b>
           If set, prevents <b>liblttng-ust </b>from performing a procname
           state dump (see the <i>LTTng-UST state dump</i> section above).
</pre> <h2>
BUGS </h2>
<pre>
       If you encounter any issue or usability problem, please report it
       on the LTTng bug tracker &lt;https://bugs.lttng.org/projects/lttng-
       ust&gt;.
</pre> <h2>
RESOURCES </h2>
<pre>
       •   LTTng project website &lt;<a href="http://lttng.org">http://lttng.org</a>&gt;

       •   LTTng documentation &lt;<a href="http://lttng.org/docs">http://lttng.org/docs</a>&gt;

       •   Git repositories &lt;<a href="http://git.lttng.org">http://git.lttng.org</a>&gt;

       •   GitHub organization &lt;<a href="http://github.com/lttng">http://github.com/lttng</a>&gt;

       •   Continuous integration &lt;<a href="http://ci.lttng.org/">http://ci.lttng.org/</a>&gt;

       •   Mailing list &lt;<a href="http://lists.lttng.org">http://lists.lttng.org</a>&gt; for support and
           development: <b>lttng-dev@lists.lttng.org</b>

       •   IRC channel &lt;irc://irc.oftc.net/lttng&gt;: <b>#lttng </b>on
           <b>irc.oftc.net</b>
</pre> <h2>
COPYRIGHTS </h2>
<pre>
       This library is part of the LTTng-UST project.

       This library is distributed under the GNU Lesser General Public
       License, version 2.1 &lt;http://www.gnu.org/licenses/old-
       licenses/lgpl-2.1.en.html&gt;. See the <b>COPYING</b>
       &lt;<a href="https://github.com/lttng/lttng-ust/blob/v2.14/COPYING">https://github.com/lttng/lttng-ust/blob/v2.14/COPYING</a>&gt; file for
       more details.
</pre> <h2>
THANKS </h2>
<pre>
       Thanks to Ericsson for funding this work, providing real-life use
       cases, and testing.

       Special thanks to Michel Dagenais and the DORSAL laboratory
       &lt;<a href="http://www.dorsal.polymtl.ca/">http://www.dorsal.polymtl.ca/</a>&gt; at École Polytechnique de
       Montréal for the LTTng journey.
</pre> <h2>
AUTHORS </h2>
<pre>
       LTTng-UST was originally written by Mathieu Desnoyers, with
       additional contributions from various other people. It is
       currently maintained by Mathieu Desnoyers
       &lt;mailto:mathieu.desnoyers@efficios.com&gt;.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="lttng_ust_tracef.3.html">lttng_ust_tracef(3)</a>, <a href="lttng_ust_tracelog.3.html">lttng_ust_tracelog(3)</a>, <a href="../man1/lttng-gen-tp.1.html">lttng-gen-tp(1)</a>,
       <a href="lttng-ust-dl.3.html">lttng-ust-dl(3)</a>, <a href="lttng-ust-cyg-profile.3.html">lttng-ust-cyg-profile(3)</a>, <a href="../man1/lttng.1.html">lttng(1)</a>,
       <a href="../man1/lttng-enable-event.1.html">lttng-enable-event(1)</a>, <a href="../man1/lttng-list.1.html">lttng-list(1)</a>, <a href="../man1/lttng-add-context.1.html">lttng-add-context(1)</a>,
       <b>babeltrace</b>(1), <a href="dlopen.3.html">dlopen(3)</a>, <a href="../man8/ld.so.8.html">ld.so(8)</a>
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>LTTng-UST</i> (LTTng Userspace Tracer)
       project.  Information about the project can be found at 
       ⟨<a href="http://lttng.org/">http://lttng.org/</a>⟩.  It is not known how to report bugs for this
       man page; if you know, please send a mail to man-pages@man7.org.
       This page was obtained from the tarball fetched from
       ⟨<a href="https://lttng.org/files/lttng-ust/">https://lttng.org/files/lttng-ust/</a>⟩ on 2024-06-14.  If you
       discover any rendering problems in this HTML version of the page,
       or you believe there is a better or more up-to-date source for
       the page, or you have corrections or improvements to the
       information in this COLOPHON (which is <i>not</i> part of the original
       manual page), send a mail to man-pages@man7.org

<span class="footline">LTTng 2.14.0-pre               06/07/2024                   <i>LTTNG-UST</i>(3)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/lttng.1.html">lttng(1)</a>, <a href="../man1/lttng-crash.1.html">lttng-crash(1)</a>, <a href="../man1/lttng-enable-channel.1.html">lttng-enable-channel(1)</a>, <a href="../man1/lttng-gen-tp.1.html">lttng-gen-tp(1)</a>, <a href="lttng-health-check.3.html">lttng-health-check(3)</a>, <a href="lttng-ust-cyg-profile.3.html">lttng-ust-cyg-profile(3)</a>, <a href="lttng-ust-dl.3.html">lttng-ust-dl(3)</a>, <a href="lttng_ust_tracef.3.html">lttng_ust_tracef(3)</a>, <a href="lttng_ust_tracelog.3.html">lttng_ust_tracelog(3)</a>, <a href="tracef.3.html">tracef(3)</a>, <a href="tracelog.3.html">tracelog(3)</a>, <a href="../man7/babeltrace2-filter.lttng-utils.debug-info.7.html">babeltrace2-filter.lttng-utils.debug-info(7)</a>, <a href="../man8/lttng-relayd.8.html">lttng-relayd(8)</a>, <a href="../man8/lttng-sessiond.8.html">lttng-sessiond(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man3/lttng_ust_do_tracepoint.3.html" class="_attribution-link">https://man7.org/linux/man-pages/man3/lttng_ust_do_tracepoint.3.html</a>
  </p>
</div>
