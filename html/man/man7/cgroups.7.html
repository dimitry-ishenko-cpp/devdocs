<h1>cgroups(7) â€” Linux manual page</h1>   <pre>
<span class="headline"><i>cgroups</i>(7)          Miscellaneous Information Manual          <i>cgroups</i>(7)</span>
</pre> <h2>
NAME </h2>
<pre>
       cgroups - Linux control groups
</pre> <h2>
DESCRIPTION </h2>
<pre>
       Control groups, usually referred to as cgroups, are a Linux
       kernel feature which allow processes to be organized into
       hierarchical groups whose usage of various types of resources can
       then be limited and monitored.  The kernel's cgroup interface is
       provided through a pseudo-filesystem called cgroupfs.  Grouping
       is implemented in the core cgroup kernel code, while resource
       tracking and limits are implemented in a set of per-resource-type
       subsystems (memory, CPU, and so on).

   <b>Terminology</b>
       A <i>cgroup</i> is a collection of processes that are bound to a set of
       limits or parameters defined via the cgroup filesystem.

       A <i>subsystem</i> is a kernel component that modifies the behavior of
       the processes in a cgroup.  Various subsystems have been
       implemented, making it possible to do things such as limiting the
       amount of CPU time and memory available to a cgroup, accounting
       for the CPU time used by a cgroup, and freezing and resuming
       execution of the processes in a cgroup.  Subsystems are sometimes
       also known as <i>resource controllers</i> (or simply, controllers).

       The cgroups for a controller are arranged in a <i>hierarchy</i>.  This
       hierarchy is defined by creating, removing, and renaming
       subdirectories within the cgroup filesystem.  At each level of
       the hierarchy, attributes (e.g., limits) can be defined.  The
       limits, control, and accounting provided by cgroups generally
       have effect throughout the subhierarchy underneath the cgroup
       where the attributes are defined.  Thus, for example, the limits
       placed on a cgroup at a higher level in the hierarchy cannot be
       exceeded by descendant cgroups.

   <b>Cgroups version 1 and version 2</b>
       The initial release of the cgroups implementation was in Linux
       2.6.24.  Over time, various cgroup controllers have been added to
       allow the management of various types of resources.  However, the
       development of these controllers was largely uncoordinated, with
       the result that many inconsistencies arose between controllers
       and management of the cgroup hierarchies became rather complex.
       A longer description of these problems can be found in the kernel
       source file <i>Documentation/admin-guide/cgroup-v2.rst</i> (or
       <i>Documentation/cgroup-v2.txt</i> in Linux 4.17 and earlier).

       Because of the problems with the initial cgroups implementation
       (cgroups version 1), starting in Linux 3.10, work began on a new,
       orthogonal implementation to remedy these problems.  Initially
       marked experimental, and hidden behind the
       <i>-o __DEVEL__sane_behavior</i> mount option, the new version (cgroups
       version 2) was eventually made official with the release of Linux
       4.5.  Differences between the two versions are described in the
       text below.  The file <i>cgroup.sane_behavior</i>, present in cgroups
       v1, is a relic of this mount option.  The file always reports "0"
       and is only retained for backward compatibility.

       Although cgroups v2 is intended as a replacement for cgroups v1,
       the older system continues to exist (and for compatibility
       reasons is unlikely to be removed).  Currently, cgroups v2
       implements only a subset of the controllers available in cgroups
       v1.  The two systems are implemented so that both v1 controllers
       and v2 controllers can be mounted on the same system.  Thus, for
       example, it is possible to use those controllers that are
       supported under version 2, while also using version 1 controllers
       where version 2 does not yet support those controllers.  The only
       restriction here is that a controller can't be simultaneously
       employed in both a cgroups v1 hierarchy and in the cgroups v2
       hierarchy.
</pre> <h2>
CGROUPS VERSION 1 </h2>
<pre>
       Under cgroups v1, each controller may be mounted against a
       separate cgroup filesystem that provides its own hierarchical
       organization of the processes on the system.  It is also possible
       to comount multiple (or even all) cgroups v1 controllers against
       the same cgroup filesystem, meaning that the comounted
       controllers manage the same hierarchical organization of
       processes.

       For each mounted hierarchy, the directory tree mirrors the
       control group hierarchy.  Each control group is represented by a
       directory, with each of its child control cgroups represented as
       a child directory.  For instance, <i>/user/joe/1.session</i> represents
       control group <i>1.session</i>, which is a child of cgroup <i>joe</i>, which is
       a child of <i>/user</i>.  Under each cgroup directory is a set of files
       which can be read or written to, reflecting resource limits and a
       few general cgroup properties.

   <b>Tasks (threads) versus processes</b>
       In cgroups v1, a distinction is drawn between <i>processes</i> and
       <i>tasks</i>.  In this view, a process can consist of multiple tasks
       (more commonly called threads, from a user-space perspective, and
       called such in the remainder of this man page).  In cgroups v1,
       it is possible to independently manipulate the cgroup memberships
       of the threads in a process.

       The cgroups v1 ability to split threads across different cgroups
       caused problems in some cases.  For example, it made no sense for
       the <i>memory</i> controller, since all of the threads of a process
       share a single address space.  Because of these problems, the
       ability to independently manipulate the cgroup memberships of the
       threads in a process was removed in the initial cgroups v2
       implementation, and subsequently restored in a more limited form
       (see the discussion of "thread mode" below).

   <b>Mounting v1 controllers</b>
       The use of cgroups requires a kernel built with the <b>CONFIG_CGROUP</b>
       option.  In addition, each of the v1 controllers has an
       associated configuration option that must be set in order to
       employ that controller.

       In order to use a v1 controller, it must be mounted against a
       cgroup filesystem.  The usual place for such mounts is under a
       <a href="../man5/tmpfs.5.html">tmpfs(5)</a> filesystem mounted at <i>/sys/fs/cgroup</i>.  Thus, one might
       mount the <i>cpu</i> controller as follows:

           mount -t cgroup -o cpu none /sys/fs/cgroup/cpu

       It is possible to comount multiple controllers against the same
       hierarchy.  For example, here the <i>cpu</i> and <i>cpuacct</i> controllers are
       comounted against a single hierarchy:

           mount -t cgroup -o cpu,cpuacct none /sys/fs/cgroup/cpu,cpuacct

       Comounting controllers has the effect that a process is in the
       same cgroup for all of the comounted controllers.  Separately
       mounting controllers allows a process to be in cgroup <i>/foo1</i> for
       one controller while being in <i>/foo2/foo3</i> for another.

       It is possible to comount all v1 controllers against the same
       hierarchy:

           mount -t cgroup -o all cgroup /sys/fs/cgroup

       (One can achieve the same result by omitting <i>-o all</i>, since it is
       the default if no controllers are explicitly specified.)

       It is not possible to mount the same controller against multiple
       cgroup hierarchies.  For example, it is not possible to mount
       both the <i>cpu</i> and <i>cpuacct</i> controllers against one hierarchy, and
       to mount the <i>cpu</i> controller alone against another hierarchy.  It
       is possible to create multiple mount with exactly the same set of
       comounted controllers.  However, in this case all that results is
       multiple mount points providing a view of the same hierarchy.

       Note that on many systems, the v1 controllers are automatically
       mounted under <i>/sys/fs/cgroup</i>; in particular, <a href="../man1/systemd.1.html">systemd(1)</a>
       automatically creates such mounts.

   <b>Unmounting v1 controllers</b>
       A mounted cgroup filesystem can be unmounted using the <a href="../man8/umount.8.html">umount(8)</a>
       command, as in the following example:

           umount /sys/fs/cgroup/pids

       <i>But note well</i>: a cgroup filesystem is unmounted only if it is not
       busy, that is, it has no child cgroups.  If this is not the case,
       then the only effect of the <a href="../man8/umount.8.html">umount(8)</a> is to make the mount
       invisible.  Thus, to ensure that the mount is really removed, one
       must first remove all child cgroups, which in turn can be done
       only after all member processes have been moved from those
       cgroups to the root cgroup.

   <b>Cgroups version 1 controllers</b>
       Each of the cgroups version 1 controllers is governed by a kernel
       configuration option (listed below).  Additionally, the
       availability of the cgroups feature is governed by the
       <b>CONFIG_CGROUPS </b>kernel configuration option.

       <i>cpu</i> (since Linux 2.6.24; <b>CONFIG_CGROUP_SCHED</b>)
              Cgroups can be guaranteed a minimum number of "CPU shares"
              when a system is busy.  This does not limit a cgroup's CPU
              usage if the CPUs are not busy.  For further information,
              see <i>Documentation/scheduler/sched-design-CFS.rst</i> (or
              <i>Documentation/scheduler/sched-design-CFS.txt</i> in Linux 5.2
              and earlier).

              In Linux 3.2, this controller was extended to provide CPU
              "bandwidth" control.  If the kernel is configured with
              <b>CONFIG_CFS_BANDWIDTH</b>, then within each scheduling period
              (defined via a file in the cgroup directory), it is
              possible to define an upper limit on the CPU time
              allocated to the processes in a cgroup.  This upper limit
              applies even if there is no other competition for the CPU.
              Further information can be found in the kernel source file
              <i>Documentation/scheduler/sched-bwc.rst</i> (or
              <i>Documentation/scheduler/sched-bwc.txt</i> in Linux 5.2 and
              earlier).

       <i>cpuacct</i> (since Linux 2.6.24; <b>CONFIG_CGROUP_CPUACCT</b>)
              This provides accounting for CPU usage by groups of
              processes.

              Further information can be found in the kernel source file
              <i>Documentation/admin-guide/cgroup-v1/cpuacct.rst</i> (or
              <i>Documentation/cgroup-v1/cpuacct.txt</i> in Linux 5.2 and
              earlier).

       <i>cpuset</i> (since Linux 2.6.24; <b>CONFIG_CPUSETS</b>)
              This cgroup can be used to bind the processes in a cgroup
              to a specified set of CPUs and NUMA nodes.

              Further information can be found in the kernel source file
              <i>Documentation/admin-guide/cgroup-v1/cpusets.rst</i> (or
              <i>Documentation/cgroup-v1/cpusets.txt</i> in Linux 5.2 and
              earlier).

       <i>memory</i> (since Linux 2.6.25; <b>CONFIG_MEMCG</b>)
              The memory controller supports reporting and limiting of
              process memory, kernel memory, and swap used by cgroups.

              Further information can be found in the kernel source file
              <i>Documentation/admin-guide/cgroup-v1/memory.rst</i> (or
              <i>Documentation/cgroup-v1/memory.txt</i> in Linux 5.2 and
              earlier).

       <i>devices</i> (since Linux 2.6.26; <b>CONFIG_CGROUP_DEVICE</b>)
              This supports controlling which processes may create
              (mknod) devices as well as open them for reading or
              writing.  The policies may be specified as allow-lists and
              deny-lists.  Hierarchy is enforced, so new rules must not
              violate existing rules for the target or ancestor cgroups.

              Further information can be found in the kernel source file
              <i>Documentation/admin-guide/cgroup-v1/devices.rst</i> (or
              <i>Documentation/cgroup-v1/devices.txt</i> in Linux 5.2 and
              earlier).

       <i>freezer</i> (since Linux 2.6.28; <b>CONFIG_CGROUP_FREEZER</b>)
              The <i>freezer</i> cgroup can suspend and restore (resume) all
              processes in a cgroup.  Freezing a cgroup <i>/A</i> also causes
              its children, for example, processes in <i>/A/B</i>, to be
              frozen.

              Further information can be found in the kernel source file
              <i>Documentation/admin-guide/cgroup-v1/freezer-subsystem.rst</i>
              (or <i>Documentation/cgroup-v1/freezer-subsystem.txt</i> in Linux
              5.2 and earlier).

       <i>net_cls</i> (since Linux 2.6.29; <b>CONFIG_CGROUP_NET_CLASSID</b>)
              This places a classid, specified for the cgroup, on
              network packets created by a cgroup.  These classids can
              then be used in firewall rules, as well as used to shape
              traffic using <a href="../man8/tc.8.html">tc(8)</a>.  This applies only to packets leaving
              the cgroup, not to traffic arriving at the cgroup.

              Further information can be found in the kernel source file
              <i>Documentation/admin-guide/cgroup-v1/net_cls.rst</i> (or
              <i>Documentation/cgroup-v1/net_cls.txt</i> in Linux 5.2 and
              earlier).

       <i>blkio</i> (since Linux 2.6.33; <b>CONFIG_BLK_CGROUP</b>)
              The <i>blkio</i> cgroup controls and limits access to specified
              block devices by applying IO control in the form of
              throttling and upper limits against leaf nodes and
              intermediate nodes in the storage hierarchy.

              Two policies are available.  The first is a proportional-
              weight time-based division of disk implemented with CFQ.
              This is in effect for leaf nodes using CFQ.  The second is
              a throttling policy which specifies upper I/O rate limits
              on a device.

              Further information can be found in the kernel source file
              <i>Documentation/admin-guide/cgroup-v1/blkio-controller.rst</i>
              (or <i>Documentation/cgroup-v1/blkio-controller.txt</i> in Linux
              5.2 and earlier).

       <i>perf_event</i> (since Linux 2.6.39; <b>CONFIG_CGROUP_PERF</b>)
              This controller allows <i>perf</i> monitoring of the set of
              processes grouped in a cgroup.

              Further information can be found in the kernel source
              files

       <i>net_prio</i> (since Linux 3.3; <b>CONFIG_CGROUP_NET_PRIO</b>)
              This allows priorities to be specified, per network
              interface, for cgroups.

              Further information can be found in the kernel source file
              <i>Documentation/admin-guide/cgroup-v1/net_prio.rst</i> (or
              <i>Documentation/cgroup-v1/net_prio.txt</i> in Linux 5.2 and
              earlier).

       <i>hugetlb</i> (since Linux 3.5; <b>CONFIG_CGROUP_HUGETLB</b>)
              This supports limiting the use of huge pages by cgroups.

              Further information can be found in the kernel source file
              <i>Documentation/admin-guide/cgroup-v1/hugetlb.rst</i> (or
              <i>Documentation/cgroup-v1/hugetlb.txt</i> in Linux 5.2 and
              earlier).

       <i>pids</i> (since Linux 4.3; <b>CONFIG_CGROUP_PIDS</b>)
              This controller permits limiting the number of process
              that may be created in a cgroup (and its descendants).

              Further information can be found in the kernel source file
              <i>Documentation/admin-guide/cgroup-v1/pids.rst</i> (or
              <i>Documentation/cgroup-v1/pids.txt</i> in Linux 5.2 and
              earlier).

       <i>rdma</i> (since Linux 4.11; <b>CONFIG_CGROUP_RDMA</b>)
              The RDMA controller permits limiting the use of RDMA/IB-
              specific resources per cgroup.

              Further information can be found in the kernel source file
              <i>Documentation/admin-guide/cgroup-v1/rdma.rst</i> (or
              <i>Documentation/cgroup-v1/rdma.txt</i> in Linux 5.2 and
              earlier).

   <b>Creating cgroups and moving processes</b>
       A cgroup filesystem initially contains a single root cgroup, '/',
       which all processes belong to.  A new cgroup is created by
       creating a directory in the cgroup filesystem:

           mkdir /sys/fs/cgroup/cpu/cg1

       This creates a new empty cgroup.

       A process may be moved to this cgroup by writing its PID into the
       cgroup's <i>cgroup.procs</i> file:

           echo $$ &gt; /sys/fs/cgroup/cpu/cg1/cgroup.procs

       Only one PID at a time should be written to this file.

       Writing the value 0 to a <i>cgroup.procs</i> file causes the writing
       process to be moved to the corresponding cgroup.

       When writing a PID into the <i>cgroup.procs</i>, all threads in the
       process are moved into the new cgroup at once.

       Within a hierarchy, a process can be a member of exactly one
       cgroup.  Writing a process's PID to a <i>cgroup.procs</i> file
       automatically removes it from the cgroup of which it was
       previously a member.

       The <i>cgroup.procs</i> file can be read to obtain a list of the
       processes that are members of a cgroup.  The returned list of
       PIDs is not guaranteed to be in order.  Nor is it guaranteed to
       be free of duplicates.  (For example, a PID may be recycled while
       reading from the list.)

       In cgroups v1, an individual thread can be moved to another
       cgroup by writing its thread ID (i.e., the kernel thread ID
       returned by <a href="../man2/clone.2.html">clone(2)</a> and <a href="../man2/gettid.2.html">gettid(2)</a>) to the <i>tasks</i> file in a cgroup
       directory.  This file can be read to discover the set of threads
       that are members of the cgroup.

   <b>Removing cgroups</b>
       To remove a cgroup, it must first have no child cgroups and
       contain no (nonzombie) processes.  So long as that is the case,
       one can simply remove the corresponding directory pathname.  Note
       that files in a cgroup directory cannot and need not be removed.

   <b>Cgroups v1 release notification</b>
       Two files can be used to determine whether the kernel provides
       notifications when a cgroup becomes empty.  A cgroup is
       considered to be empty when it contains no child cgroups and no
       member processes.

       A special file in the root directory of each cgroup hierarchy,
       <i>release_agent</i>, can be used to register the pathname of a program
       that may be invoked when a cgroup in the hierarchy becomes empty.
       The pathname of the newly empty cgroup (relative to the cgroup
       mount point) is provided as the sole command-line argument when
       the <i>release_agent</i> program is invoked.  The <i>release_agent</i> program
       might remove the cgroup directory, or perhaps repopulate it with
       a process.

       The default value of the <i>release_agent</i> file is empty, meaning
       that no release agent is invoked.

       The content of the <i>release_agent</i> file can also be specified via a
       mount option when the cgroup filesystem is mounted:

           mount -o release_agent=pathname ...

       Whether or not the <i>release_agent</i> program is invoked when a
       particular cgroup becomes empty is determined by the value in the
       <i>notify_on_release</i> file in the corresponding cgroup directory.  If
       this file contains the value 0, then the <i>release_agent</i> program is
       not invoked.  If it contains the value 1, the <i>release_agent</i>
       program is invoked.  The default value for this file in the root
       cgroup is 0.  At the time when a new cgroup is created, the value
       in this file is inherited from the corresponding file in the
       parent cgroup.

   <b>Cgroup v1 named hierarchies</b>
       In cgroups v1, it is possible to mount a cgroup hierarchy that
       has no attached controllers:

           mount -t cgroup -o none,name=somename none /some/mount/point

       Multiple instances of such hierarchies can be mounted; each
       hierarchy must have a unique name.  The only purpose of such
       hierarchies is to track processes.  (See the discussion of
       release notification below.)  An example of this is the
       <i>name=systemd</i> cgroup hierarchy that is used by <a href="../man1/systemd.1.html">systemd(1)</a> to track
       services and user sessions.

       Since Linux 5.0, the <i>cgroup_no_v1</i> kernel boot option (described
       below) can be used to disable cgroup v1 named hierarchies, by
       specifying <i>cgroup_no_v1=named</i>.
</pre> <h2>
CGROUPS VERSION 2 </h2>
<pre>
       In cgroups v2, all mounted controllers reside in a single unified
       hierarchy.  While (different) controllers may be simultaneously
       mounted under the v1 and v2 hierarchies, it is not possible to
       mount the same controller simultaneously under both the v1 and
       the v2 hierarchies.

       The new behaviors in cgroups v2 are summarized here, and in some
       cases elaborated in the following subsections.

       â€¢  Cgroups v2 provides a unified hierarchy against which all
          controllers are mounted.

       â€¢  "Internal" processes are not permitted.  With the exception of
          the root cgroup, processes may reside only in leaf nodes
          (cgroups that do not themselves contain child cgroups).  The
          details are somewhat more subtle than this, and are described
          below.

       â€¢  Active cgroups must be specified via the files
          <i>cgroup.controllers</i> and <i>cgroup.subtree_control</i>.

       â€¢  The <i>tasks</i> file has been removed.  In addition, the
          <i>cgroup.clone_children</i> file that is employed by the <i>cpuset</i>
          controller has been removed.

       â€¢  An improved mechanism for notification of empty cgroups is
          provided by the <i>cgroup.events</i> file.

       For more changes, see the <i>Documentation/admin-guide/cgroup-v2.rst</i>
       file in the kernel source (or <i>Documentation/cgroup-v2.txt</i> in
       Linux 4.17 and earlier).

       Some of the new behaviors listed above saw subsequent
       modification with the addition in Linux 4.14 of "thread mode"
       (described below).

   <b>Cgroups v2 unified hierarchy</b>
       In cgroups v1, the ability to mount different controllers against
       different hierarchies was intended to allow great flexibility for
       application design.  In practice, though, the flexibility turned
       out to be less useful than expected, and in many cases added
       complexity.  Therefore, in cgroups v2, all available controllers
       are mounted against a single hierarchy.  The available
       controllers are automatically mounted, meaning that it is not
       necessary (or possible) to specify the controllers when mounting
       the cgroup v2 filesystem using a command such as the following:

           mount -t cgroup2 none /mnt/cgroup2

       A cgroup v2 controller is available only if it is not currently
       in use via a mount against a cgroup v1 hierarchy.  Or, to put
       things another way, it is not possible to employ the same
       controller against both a v1 hierarchy and the unified v2
       hierarchy.  This means that it may be necessary first to unmount
       a v1 controller (as described above) before that controller is
       available in v2.  Since <a href="../man1/systemd.1.html">systemd(1)</a> makes heavy use of some v1
       controllers by default, it can in some cases be simpler to boot
       the system with selected v1 controllers disabled.  To do this,
       specify the <i>cgroup_no_v1=list</i> option on the kernel boot command
       line; <i>list</i> is a comma-separated list of the names of the
       controllers to disable, or the word <i>all</i> to disable all v1
       controllers.  (This situation is correctly handled by <a href="../man1/systemd.1.html">systemd(1)</a>,
       which falls back to operating without the specified controllers.)

       Note that on many modern systems, <a href="../man1/systemd.1.html">systemd(1)</a> automatically mounts
       the <i>cgroup2</i> filesystem at <i>/sys/fs/cgroup/unified</i> during the boot
       process.

   <b>Cgroups v2 mount options</b>
       The following options (<i>mount -o</i>) can be specified when mounting
       the group v2 filesystem:

       <i>nsdelegate</i> (since Linux 4.15)
              Treat cgroup namespaces as delegation boundaries.  For
              details, see below.

       <i>memory_localevents</i> (since Linux 5.2)
              The <i>memory.events</i> should show statistics only for the
              cgroup itself, and not for any descendant cgroups.  This
              was the behavior before Linux 5.2.  Starting in Linux 5.2,
              the default behavior is to include statistics for
              descendant cgroups in <i>memory.events</i>, and this mount option
              can be used to revert to the legacy behavior.  This option
              is system wide and can be set on mount or modified through
              remount only from the initial mount namespace; it is
              silently ignored in noninitial namespaces.

   <b>Cgroups v2 controllers</b>
       The following controllers, documented in the kernel source file
       <i>Documentation/admin-guide/cgroup-v2.rst</i> (or
       <i>Documentation/cgroup-v2.txt</i> in Linux 4.17 and earlier), are
       supported in cgroups version 2:

       <i>cpu</i> (since Linux 4.15)
              This is the successor to the version 1 <i>cpu</i> and <i>cpuacct</i>
              controllers.

       <i>cpuset</i> (since Linux 5.0)
              This is the successor of the version 1 <i>cpuset</i> controller.

       <i>freezer</i> (since Linux 5.2)
              This is the successor of the version 1 <i>freezer</i> controller.

       <i>hugetlb</i> (since Linux 5.6)
              This is the successor of the version 1 <i>hugetlb</i> controller.

       <i>io</i> (since Linux 4.5)
              This is the successor of the version 1 <i>blkio</i> controller.

       <i>memory</i> (since Linux 4.5)
              This is the successor of the version 1 <i>memory</i> controller.

       <i>perf_event</i> (since Linux 4.11)
              This is the same as the version 1 <i>perf_event</i> controller.

       <i>pids</i> (since Linux 4.5)
              This is the same as the version 1 <i>pids</i> controller.

       <i>rdma</i> (since Linux 4.11)
              This is the same as the version 1 <i>rdma</i> controller.

       There is no direct equivalent of the <i>net_cls</i> and <i>net_prio</i>
       controllers from cgroups version 1.  Instead, support has been
       added to <a href="../man8/iptables.8.html">iptables(8)</a> to allow eBPF filters that hook on cgroup v2
       pathnames to make decisions about network traffic on a per-cgroup
       basis.

       The v2 <i>devices</i> controller provides no interface files; instead,
       device control is gated by attaching an eBPF (<b>BPF_CGROUP_DEVICE</b>)
       program to a v2 cgroup.

   <b>Cgroups v2 subtree control</b>
       Each cgroup in the v2 hierarchy contains the following two files:

       <i>cgroup.controllers</i>
              This read-only file exposes a list of the controllers that
              are <i>available</i> in this cgroup.  The contents of this file
              match the contents of the <i>cgroup.subtree_control</i> file in
              the parent cgroup.

       <i>cgroup.subtree_control</i>
              This is a list of controllers that are <i>active</i> (<i>enabled</i>) in
              the cgroup.  The set of controllers in this file is a
              subset of the set in the <i>cgroup.controllers</i> of this
              cgroup.  The set of active controllers is modified by
              writing strings to this file containing space-delimited
              controller names, each preceded by '+' (to enable a
              controller) or '-' (to disable a controller), as in the
              following example:

                  echo '+pids -memory' &gt; x/y/cgroup.subtree_control

              An attempt to enable a controller that is not present in
              <i>cgroup.controllers</i> leads to an <b>ENOENT </b>error when writing
              to the <i>cgroup.subtree_control</i> file.

       Because the list of controllers in <i>cgroup.subtree_control</i> is a
       subset of those <i>cgroup.controllers</i>, a controller that has been
       disabled in one cgroup in the hierarchy can never be re-enabled
       in the subtree below that cgroup.

       A cgroup's <i>cgroup.subtree_control</i> file determines the set of
       controllers that are exercised in the <i>child</i> cgroups.  When a
       controller (e.g., <i>pids</i>) is present in the <i>cgroup.subtree_control</i>
       file of a parent cgroup, then the corresponding controller-
       interface files (e.g., <i>pids.max</i>) are automatically created in the
       children of that cgroup and can be used to exert resource control
       in the child cgroups.

   <b>Cgroups v2 "no internal processes" rule</b>
       Cgroups v2 enforces a so-called "no internal processes" rule.
       Roughly speaking, this rule means that, with the exception of the
       root cgroup, processes may reside only in leaf nodes (cgroups
       that do not themselves contain child cgroups).  This avoids the
       need to decide how to partition resources between processes which
       are members of cgroup A and processes in child cgroups of A.

       For instance, if cgroup <i>/cg1/cg2</i> exists, then a process may
       reside in <i>/cg1/cg2</i>, but not in <i>/cg1</i>.  This is to avoid an
       ambiguity in cgroups v1 with respect to the delegation of
       resources between processes in <i>/cg1</i> and its child cgroups.  The
       recommended approach in cgroups v2 is to create a subdirectory
       called <i>leaf</i> for any nonleaf cgroup which should contain
       processes, but no child cgroups.  Thus, processes which
       previously would have gone into <i>/cg1</i> would now go into <i>/cg1/leaf</i>.
       This has the advantage of making explicit the relationship
       between processes in <i>/cg1/leaf</i> and <i>/cg1</i>'s other children.

       The "no internal processes" rule is in fact more subtle than
       stated above.  More precisely, the rule is that a (nonroot)
       cgroup can't both (1) have member processes, and (2) distribute
       resources into child cgroupsâ€”that is, have a nonempty
       <i>cgroup.subtree_control</i> file.  Thus, it <i>is</i> possible for a cgroup
       to have both member processes and child cgroups, but before
       controllers can be enabled for that cgroup, the member processes
       must be moved out of the cgroup (e.g., perhaps into the child
       cgroups).

       With the Linux 4.14 addition of "thread mode" (described below),
       the "no internal processes" rule has been relaxed in some cases.

   <b>Cgroups v2 cgroup.events file</b>
       Each nonroot cgroup in the v2 hierarchy contains a read-only
       file, <i>cgroup.events</i>, whose contents are key-value pairs
       (delimited by newline characters, with the key and value
       separated by spaces) providing state information about the
       cgroup:

           $ <b>cat mygrp/cgroup.events</b>
           populated 1
           frozen 0

       The following keys may appear in this file:

       <i>populated</i>
              The value of this key is either 1, if this cgroup or any
              of its descendants has member processes, or otherwise 0.

       <i>frozen</i> (since Linux 5.2)
              The value of this key is 1 if this cgroup is currently
              frozen, or 0 if it is not.

       The <i>cgroup.events</i> file can be monitored, in order to receive
       notification when the value of one of its keys changes.  Such
       monitoring can be done using <a href="inotify.7.html">inotify(7)</a>, which notifies changes
       as <b>IN_MODIFY </b>events, or <a href="../man2/poll.2.html">poll(2)</a>, which notifies changes by
       returning the <b>POLLPRI </b>and <b>POLLERR </b>bits in the <i>revents</i> field.

   <b>Cgroup v2 release notification</b>
       Cgroups v2 provides a new mechanism for obtaining notification
       when a cgroup becomes empty.  The cgroups v1 <i>release_agent</i> and
       <i>notify_on_release</i> files are removed, and replaced by the
       <i>populated</i> key in the <i>cgroup.events</i> file.  This key either has the
       value 0, meaning that the cgroup (and its descendants) contain no
       (nonzombie) member processes, or 1, meaning that the cgroup (or
       one of its descendants) contains member processes.

       The cgroups v2 release-notification mechanism offers the
       following advantages over the cgroups v1 <i>release_agent</i> mechanism:

       â€¢  It allows for cheaper notification, since a single process can
          monitor multiple <i>cgroup.events</i> files (using the techniques
          described earlier).  By contrast, the cgroups v1 mechanism
          requires the expense of creating a process for each
          notification.

       â€¢  Notification for different cgroup subhierarchies can be
          delegated to different processes.  By contrast, the cgroups v1
          mechanism allows only one release agent for an entire
          hierarchy.

   <b>Cgroups v2 cgroup.stat file</b>
       Each cgroup in the v2 hierarchy contains a read-only <i>cgroup.stat</i>
       file (first introduced in Linux 4.14) that consists of lines
       containing key-value pairs.  The following keys currently appear
       in this file:

       <i>nr_descendants</i>
              This is the total number of visible (i.e., living)
              descendant cgroups underneath this cgroup.

       <i>nr_dying_descendants</i>
              This is the total number of dying descendant cgroups
              underneath this cgroup.  A cgroup enters the dying state
              after being deleted.  It remains in that state for an
              undefined period (which will depend on system load) while
              resources are freed before the cgroup is destroyed.  Note
              that the presence of some cgroups in the dying state is
              normal, and is not indicative of any problem.

              A process can't be made a member of a dying cgroup, and a
              dying cgroup can't be brought back to life.

   <b>Limiting the number of descendant cgroups</b>
       Each cgroup in the v2 hierarchy contains the following files,
       which can be used to view and set limits on the number of
       descendant cgroups under that cgroup:

       <i>cgroup.max.depth</i> (since Linux 4.14)
              This file defines a limit on the depth of nesting of
              descendant cgroups.  A value of 0 in this file means that
              no descendant cgroups can be created.  An attempt to
              create a descendant whose nesting level exceeds the limit
              fails (<i>mkdir</i>(2) fails with the error <b>EAGAIN</b>).

              Writing the string <i>"max"</i> to this file means that no limit
              is imposed.  The default value in this file is <i>"max"</i>.

       <i>cgroup.max.descendants</i> (since Linux 4.14)
              This file defines a limit on the number of live descendant
              cgroups that this cgroup may have.  An attempt to create
              more descendants than allowed by the limit fails (<i>mkdir</i>(2)
              fails with the error <b>EAGAIN</b>).

              Writing the string <i>"max"</i> to this file means that no limit
              is imposed.  The default value in this file is <i>"max"</i>.

<b>CGROUPS DELEGATION: DELEGATING A HIERARCHY TO A LESS PRIVILEGED USER</b>
       <b>%%%SH%%%</b>
       In the context of cgroups, delegation means passing management of
       some subtree of the cgroup hierarchy to a nonprivileged user.
       Cgroups v1 provides support for delegation based on file
       permissions in the cgroup hierarchy but with less strict
       containment rules than v2 (as noted below).  Cgroups v2 supports
       delegation with containment by explicit design.  The focus of the
       discussion in this section is on delegation in cgroups v2, with
       some differences for cgroups v1 noted along the way.

       Some terminology is required in order to describe delegation.  A
       <i>delegater</i> is a privileged user (i.e., root) who owns a parent
       cgroup.  A <i>delegatee</i> is a nonprivileged user who will be granted
       the permissions needed to manage some subhierarchy under that
       parent cgroup, known as the <i>delegated subtree</i>.

       To perform delegation, the delegater makes certain directories
       and files writable by the delegatee, typically by changing the
       ownership of the objects to be the user ID of the delegatee.
       Assuming that we want to delegate the hierarchy rooted at (say)
       <i>/dlgt_grp</i> and that there are not yet any child cgroups under that
       cgroup, the ownership of the following is changed to the user ID
       of the delegatee:

       <i>/dlgt_grp</i>
              Changing the ownership of the root of the subtree means
              that any new cgroups created under the subtree (and the
              files they contain) will also be owned by the delegatee.

       <i>/dlgt_grp/cgroup.procs</i>
              Changing the ownership of this file means that the
              delegatee can move processes into the root of the
              delegated subtree.

       <i>/dlgt_grp/cgroup.subtree_control</i> (cgroups v2 only)
              Changing the ownership of this file means that the
              delegatee can enable controllers (that are present in
              <i>/dlgt_grp/cgroup.controllers</i>) in order to further
              redistribute resources at lower levels in the subtree.
              (As an alternative to changing the ownership of this file,
              the delegater might instead add selected controllers to
              this file.)

       <i>/dlgt_grp/cgroup.threads</i> (cgroups v2 only)
              Changing the ownership of this file is necessary if a
              threaded subtree is being delegated (see the description
              of "thread mode", below).  This permits the delegatee to
              write thread IDs to the file.  (The ownership of this file
              can also be changed when delegating a domain subtree, but
              currently this serves no purpose, since, as described
              below, it is not possible to move a thread between domain
              cgroups by writing its thread ID to the <i>cgroup.threads</i>
              file.)

              In cgroups v1, the corresponding file that should instead
              be delegated is the <i>tasks</i> file.

       The delegater should <i>not</i> change the ownership of any of the
       controller interfaces files (e.g., <i>pids.max</i>, <i>memory.high</i>) in
       <i>dlgt_grp</i>.  Those files are used from the next level above the
       delegated subtree in order to distribute resources into the
       subtree, and the delegatee should not have permission to change
       the resources that are distributed into the delegated subtree.

       See also the discussion of the <i>/sys/kernel/cgroup/delegate</i> file
       in NOTES for information about further delegatable files in
       cgroups v2.

       After the aforementioned steps have been performed, the delegatee
       can create child cgroups within the delegated subtree (the cgroup
       subdirectories and the files they contain will be owned by the
       delegatee) and move processes between cgroups in the subtree.  If
       some controllers are present in <i>dlgt_grp/cgroup.subtree_control</i>,
       or the ownership of that file was passed to the delegatee, the
       delegatee can also control the further redistribution of the
       corresponding resources into the delegated subtree.

   <b>Cgroups v2 delegation: nsdelegate and cgroup namespaces</b>
       Starting with Linux 4.13, there is a second way to perform cgroup
       delegation in the cgroups v2 hierarchy.  This is done by mounting
       or remounting the cgroup v2 filesystem with the <i>nsdelegate</i> mount
       option.  For example, if the cgroup v2 filesystem has already
       been mounted, we can remount it with the <i>nsdelegate</i> option as
       follows:

           mount -t cgroup2 -o remount,nsdelegate \
                            none /sys/fs/cgroup/unified

       The effect of this mount option is to cause cgroup namespaces to
       automatically become delegation boundaries.  More specifically,
       the following restrictions apply for processes inside the cgroup
       namespace:

       â€¢  Writes to controller interface files in the root directory of
          the namespace will fail with the error <b>EPERM</b>.  Processes
          inside the cgroup namespace can still write to delegatable
          files in the root directory of the cgroup namespace such as
          <i>cgroup.procs</i> and <i>cgroup.subtree_control</i>, and can create
          subhierarchy underneath the root directory.

       â€¢  Attempts to migrate processes across the namespace boundary
          are denied (with the error <b>ENOENT</b>).  Processes inside the
          cgroup namespace can still (subject to the containment rules
          described below) move processes between cgroups <i>within</i> the
          subhierarchy under the namespace root.

       The ability to define cgroup namespaces as delegation boundaries
       makes cgroup namespaces more useful.  To understand why, suppose
       that we already have one cgroup hierarchy that has been delegated
       to a nonprivileged user, <i>cecilia</i>, using the older delegation
       technique described above.  Suppose further that <i>cecilia</i> wanted
       to further delegate a subhierarchy under the existing delegated
       hierarchy.  (For example, the delegated hierarchy might be
       associated with an unprivileged container run by <i>cecilia</i>.)  Even
       if a cgroup namespace was employed, because both hierarchies are
       owned by the unprivileged user <i>cecilia</i>, the following
       illegitimate actions could be performed:

       â€¢  A process in the inferior hierarchy could change the resource
          controller settings in the root directory of that hierarchy.
          (These resource controller settings are intended to allow
          control to be exercised from the <i>parent</i> cgroup; a process
          inside the child cgroup should not be allowed to modify them.)

       â€¢  A process inside the inferior hierarchy could move processes
          into and out of the inferior hierarchy if the cgroups in the
          superior hierarchy were somehow visible.

       Employing the <i>nsdelegate</i> mount option prevents both of these
       possibilities.

       The <i>nsdelegate</i> mount option only has an effect when performed in
       the initial mount namespace; in other mount namespaces, the
       option is silently ignored.

       <i>Note</i>: On some systems, <a href="../man1/systemd.1.html">systemd(1)</a> automatically mounts the cgroup
       v2 filesystem.  In order to experiment with the <i>nsdelegate</i>
       operation, it may be useful to boot the kernel with the following
       command-line options:

           cgroup_no_v1=all systemd.legacy_systemd_cgroup_controller

       These options cause the kernel to boot with the cgroups v1
       controllers disabled (meaning that the controllers are available
       in the v2 hierarchy), and tells <a href="../man1/systemd.1.html">systemd(1)</a> not to mount and use
       the cgroup v2 hierarchy, so that the v2 hierarchy can be manually
       mounted with the desired options after boot-up.

   <b>Cgroup delegation containment rules</b>
       Some delegation <i>containment rules</i> ensure that the delegatee can
       move processes between cgroups within the delegated subtree, but
       can't move processes from outside the delegated subtree into the
       subtree or vice versa.  A nonprivileged process (i.e., the
       delegatee) can write the PID of a "target" process into a
       <i>cgroup.procs</i> file only if all of the following are true:

       â€¢  The writer has write permission on the <i>cgroup.procs</i> file in
          the destination cgroup.

       â€¢  The writer has write permission on the <i>cgroup.procs</i> file in
          the nearest common ancestor of the source and destination
          cgroups.  Note that in some cases, the nearest common ancestor
          may be the source or destination cgroup itself.  This
          requirement is not enforced for cgroups v1 hierarchies, with
          the consequence that containment in v1 is less strict than in
          v2.  (For example, in cgroups v1 the user that owns two
          distinct delegated subhierarchies can move a process between
          the hierarchies.)

       â€¢  If the cgroup v2 filesystem was mounted with the <i>nsdelegate</i>
          option, the writer must be able to see the source and
          destination cgroups from its cgroup namespace.

       â€¢  In cgroups v1: the effective UID of the writer (i.e., the
          delegatee) matches the real user ID or the saved set-user-ID
          of the target process.  Before Linux 4.11, this requirement
          also applied in cgroups v2 (This was a historical requirement
          inherited from cgroups v1 that was later deemed unnecessary,
          since the other rules suffice for containment in cgroups v2.)

       <i>Note</i>: one consequence of these delegation containment rules is
       that the unprivileged delegatee can't place the first process
       into the delegated subtree; instead, the delegater must place the
       first process (a process owned by the delegatee) into the
       delegated subtree.
</pre> <h2>
CGROUPS VERSION 2 THREAD MODE </h2>
<pre>
       Among the restrictions imposed by cgroups v2 that were not
       present in cgroups v1 are the following:

       â€¢  <i>No thread-granularity control</i>: all of the threads of a process
          must be in the same cgroup.

       â€¢  <i>No internal processes</i>: a cgroup can't both have member
          processes and exercise controllers on child cgroups.

       Both of these restrictions were added because the lack of these
       restrictions had caused problems in cgroups v1.  In particular,
       the cgroups v1 ability to allow thread-level granularity for
       cgroup membership made no sense for some controllers.  (A notable
       example was the <i>memory</i> controller: since threads share an address
       space, it made no sense to split threads across different <i>memory</i>
       cgroups.)

       Notwithstanding the initial design decision in cgroups v2, there
       were use cases for certain controllers, notably the <i>cpu</i>
       controller, for which thread-level granularity of control was
       meaningful and useful.  To accommodate such use cases, Linux 4.14
       added <i>thread mode</i> for cgroups v2.

       Thread mode allows the following:

       â€¢  The creation of <i>threaded subtrees</i> in which the threads of a
          process may be spread across cgroups inside the tree.  (A
          threaded subtree may contain multiple multithreaded
          processes.)

       â€¢  The concept of <i>threaded controllers</i>, which can distribute
          resources across the cgroups in a threaded subtree.

       â€¢  A relaxation of the "no internal processes rule", so that,
          within a threaded subtree, a cgroup can both contain member
          threads and exercise resource control over child cgroups.

       With the addition of thread mode, each nonroot cgroup now
       contains a new file, <i>cgroup.type</i>, that exposes, and in some
       circumstances can be used to change, the "type" of a cgroup.
       This file contains one of the following type values:

       <i>domain</i> This is a normal v2 cgroup that provides process-
              granularity control.  If a process is a member of this
              cgroup, then all threads of the process are (by
              definition) in the same cgroup.  This is the default
              cgroup type, and provides the same behavior that was
              provided for cgroups in the initial cgroups v2
              implementation.

       <i>threaded</i>
              This cgroup is a member of a threaded subtree.  Threads
              can be added to this cgroup, and controllers can be
              enabled for the cgroup.

       <i>domain threaded</i>
              This is a domain cgroup that serves as the root of a
              threaded subtree.  This cgroup type is also known as
              "threaded root".

       <i>domain invalid</i>
              This is a cgroup inside a threaded subtree that is in an
              "invalid" state.  Processes can't be added to the cgroup,
              and controllers can't be enabled for the cgroup.  The only
              thing that can be done with this cgroup (other than
              deleting it) is to convert it to a <i>threaded</i> cgroup by
              writing the string <i>"threaded"</i> to the <i>cgroup.type</i> file.

              The rationale for the existence of this "interim" type
              during the creation of a threaded subtree (rather than the
              kernel simply immediately converting all cgroups under the
              threaded root to the type <i>threaded</i>) is to allow for
              possible future extensions to the thread mode model

   <b>Threaded versus domain controllers</b>
       With the addition of threads mode, cgroups v2 now distinguishes
       two types of resource controllers:

       â€¢  <i>Threaded</i> controllers: these controllers support thread-
          granularity for resource control and can be enabled inside
          threaded subtrees, with the result that the corresponding
          controller-interface files appear inside the cgroups in the
          threaded subtree.  As at Linux 4.19, the following controllers
          are threaded: <i>cpu</i>, <i>perf_event</i>, and <i>pids</i>.

       â€¢  <i>Domain</i> controllers: these controllers support only process
          granularity for resource control.  From the perspective of a
          domain controller, all threads of a process are always in the
          same cgroup.  Domain controllers can't be enabled inside a
          threaded subtree.

   <b>Creating a threaded subtree</b>
       There are two pathways that lead to the creation of a threaded
       subtree.  The first pathway proceeds as follows:

       (1)  We write the string <i>"threaded"</i> to the <i>cgroup.type</i> file of a
            cgroup <i>y/z</i> that currently has the type <i>domain</i>.  This has the
            following effects:

            â€¢  The type of the cgroup <i>y/z</i> becomes <i>threaded</i>.

            â€¢  The type of the parent cgroup, <i>y</i>, becomes <i>domain</i>
               <i>threaded</i>.  The parent cgroup is the root of a threaded
               subtree (also known as the "threaded root").

            â€¢  All other cgroups under <i>y</i> that were not already of type
               <i>threaded</i> (because they were inside already existing
               threaded subtrees under the new threaded root) are
               converted to type <i>domain invalid</i>.  Any subsequently
               created cgroups under <i>y</i> will also have the type <i>domain</i>
               <i>invalid</i>.

       (2)  We write the string <i>"threaded"</i> to each of the <i>domain invalid</i>
            cgroups under <i>y</i>, in order to convert them to the type
            <i>threaded</i>.  As a consequence of this step, all threads under
            the threaded root now have the type <i>threaded</i> and the
            threaded subtree is now fully usable.  The requirement to
            write <i>"threaded"</i> to each of these cgroups is somewhat
            cumbersome, but allows for possible future extensions to the
            thread-mode model.

       The second way of creating a threaded subtree is as follows:

       (1)  In an existing cgroup, <i>z</i>, that currently has the type
            <i>domain</i>, we (1.1) enable one or more threaded controllers and
            (1.2) make a process a member of <i>z</i>.  (These two steps can be
            done in either order.)  This has the following consequences:

            â€¢  The type of <i>z</i> becomes <i>domain threaded</i>.

            â€¢  All of the descendant cgroups of <i>z</i> that were not already
               of type <i>threaded</i> are converted to type <i>domain invalid</i>.

       (2)  As before, we make the threaded subtree usable by writing
            the string <i>"threaded"</i> to each of the <i>domain invalid</i> cgroups
            under <i>z</i>, in order to convert them to the type <i>threaded</i>.

       One of the consequences of the above pathways to creating a
       threaded subtree is that the threaded root cgroup can be a parent
       only to <i>threaded</i> (and <i>domain invalid</i>) cgroups.  The threaded root
       cgroup can't be a parent of a <i>domain</i> cgroups, and a <i>threaded</i>
       cgroup can't have a sibling that is a <i>domain</i> cgroup.

   <b>Using a threaded subtree</b>
       Within a threaded subtree, threaded controllers can be enabled in
       each subgroup whose type has been changed to <i>threaded</i>; upon doing
       so, the corresponding controller interface files appear in the
       children of that cgroup.

       A process can be moved into a threaded subtree by writing its PID
       to the <i>cgroup.procs</i> file in one of the cgroups inside the tree.
       This has the effect of making all of the threads in the process
       members of the corresponding cgroup and makes the process a
       member of the threaded subtree.  The threads of the process can
       then be spread across the threaded subtree by writing their
       thread IDs (see <a href="../man2/gettid.2.html">gettid(2)</a>) to the <i>cgroup.threads</i> files in
       different cgroups inside the subtree.  The threads of a process
       must all reside in the same threaded subtree.

       As with writing to <i>cgroup.procs</i>, some containment rules apply
       when writing to the <i>cgroup.threads</i> file:

       â€¢  The writer must have write permission on the cgroup.threads
          file in the destination cgroup.

       â€¢  The writer must have write permission on the <i>cgroup.procs</i> file
          in the common ancestor of the source and destination cgroups.
          (In some cases, the common ancestor may be the source or
          destination cgroup itself.)

       â€¢  The source and destination cgroups must be in the same
          threaded subtree.  (Outside a threaded subtree, an attempt to
          move a thread by writing its thread ID to the <i>cgroup.threads</i>
          file in a different <i>domain</i> cgroup fails with the error
          <b>EOPNOTSUPP</b>.)

       The <i>cgroup.threads</i> file is present in each cgroup (including
       <i>domain</i> cgroups) and can be read in order to discover the set of
       threads that is present in the cgroup.  The set of thread IDs
       obtained when reading this file is not guaranteed to be ordered
       or free of duplicates.

       The <i>cgroup.procs</i> file in the threaded root shows the PIDs of all
       processes that are members of the threaded subtree.  The
       <i>cgroup.procs</i> files in the other cgroups in the subtree are not
       readable.

       Domain controllers can't be enabled in a threaded subtree; no
       controller-interface files appear inside the cgroups underneath
       the threaded root.  From the point of view of a domain
       controller, threaded subtrees are invisible: a multithreaded
       process inside a threaded subtree appears to a domain controller
       as a process that resides in the threaded root cgroup.

       Within a threaded subtree, the "no internal processes" rule does
       not apply: a cgroup can both contain member processes (or thread)
       and exercise controllers on child cgroups.

   <b>Rules for writing to cgroup.type and creating threaded subtrees</b>
       A number of rules apply when writing to the <i>cgroup.type</i> file:

       â€¢  Only the string <i>"threaded"</i> may be written.  In other words,
          the only explicit transition that is possible is to convert a
          <i>domain</i> cgroup to type <i>threaded</i>.

       â€¢  The effect of writing <i>"threaded"</i> depends on the current value
          in <i>cgroup.type</i>, as follows:

          â€¢  <i>domain</i> or <i>domain threaded</i>: start the creation of a threaded
             subtree (whose root is the parent of this cgroup) via the
             first of the pathways described above;

          â€¢  <i>domain invalid</i>: convert this cgroup (which is inside a
             threaded subtree) to a usable (i.e., <i>threaded</i>) state;

          â€¢  <i>threaded</i>: no effect (a "no-op").

       â€¢  We can't write to a <i>cgroup.type</i> file if the parent's type is
          <i>domain invalid</i>.  In other words, the cgroups of a threaded
          subtree must be converted to the <i>threaded</i> state in a top-down
          manner.

       There are also some constraints that must be satisfied in order
       to create a threaded subtree rooted at the cgroup <i>x</i>:

       â€¢  There can be no member processes in the descendant cgroups of
          <i>x</i>.  (The cgroup <i>x</i> can itself have member processes.)

       â€¢  No domain controllers may be enabled in <i>x</i>'s
          <i>cgroup.subtree_control</i> file.

       If any of the above constraints is violated, then an attempt to
       write <i>"threaded"</i> to a <i>cgroup.type</i> file fails with the error
       <b>ENOTSUP</b>.

   <b>The "domain threaded" cgroup type</b>
       According to the pathways described above, the type of a cgroup
       can change to <i>domain threaded</i> in either of the following cases:

       â€¢  The string <i>"threaded"</i> is written to a child cgroup.

       â€¢  A threaded controller is enabled inside the cgroup and a
          process is made a member of the cgroup.

       A <i>domain threaded</i> cgroup, <i>x</i>, can revert to the type <i>domain</i> if the
       above conditions no longer hold trueâ€”that is, if all <i>threaded</i>
       child cgroups of <i>x</i> are removed and either <i>x</i> no longer has
       threaded controllers enabled or no longer has member processes.

       When a <i>domain threaded</i> cgroup <i>x</i> reverts to the type <i>domain</i>:

       â€¢  All <i>domain invalid</i> descendants of <i>x</i> that are not in lower-
          level threaded subtrees revert to the type <i>domain</i>.

       â€¢  The root cgroups in any lower-level threaded subtrees revert
          to the type <i>domain threaded</i>.

   <b>Exceptions for the root cgroup</b>
       The root cgroup of the v2 hierarchy is treated exceptionally: it
       can be the parent of both <i>domain</i> and <i>threaded</i> cgroups.  If the
       string <i>"threaded"</i> is written to the <i>cgroup.type</i> file of one of
       the children of the root cgroup, then

       â€¢  The type of that cgroup becomes <i>threaded</i>.

       â€¢  The type of any descendants of that cgroup that are not part
          of lower-level threaded subtrees changes to <i>domain invalid</i>.

       Note that in this case, there is no cgroup whose type becomes
       <i>domain threaded</i>.  (Notionally, the root cgroup can be considered
       as the threaded root for the cgroup whose type was changed to
       <i>threaded</i>.)

       The aim of this exceptional treatment for the root cgroup is to
       allow a threaded cgroup that employs the <i>cpu</i> controller to be
       placed as high as possible in the hierarchy, so as to minimize
       the (small) cost of traversing the cgroup hierarchy.

   <b>The cgroups v2 "cpu" controller and realtime threads</b>
       As at Linux 4.19, the cgroups v2 <i>cpu</i> controller does not support
       control of realtime threads (specifically threads scheduled under
       any of the policies <b>SCHED_FIFO</b>, <b>SCHED_RR</b>, described
       <b>SCHED_DEADLINE</b>; see <a href="sched.7.html">sched(7)</a>).  Therefore, the <i>cpu</i> controller can
       be enabled in the root cgroup only if all realtime threads are in
       the root cgroup.  (If there are realtime threads in nonroot
       cgroups, then a <a href="../man2/write.2.html">write(2)</a> of the string <i>"+cpu"</i> to the
       <i>cgroup.subtree_control</i> file fails with the error <b>EINVAL</b>.)

       On some systems, <a href="../man1/systemd.1.html">systemd(1)</a> places certain realtime threads in
       nonroot cgroups in the v2 hierarchy.  On such systems, these
       threads must first be moved to the root cgroup before the <i>cpu</i>
       controller can be enabled.
</pre> <h2>
ERRORS </h2>
<pre>
       The following errors can occur for <a href="../man2/mount.2.html">mount(2)</a>:

       <b>EBUSY  </b>An attempt to mount a cgroup version 1 filesystem
              specified neither the <i>name=</i> option (to mount a named
              hierarchy) nor a controller name (or <i>all</i>).
</pre> <h2>
NOTES </h2>
<pre>
       A child process created via <a href="../man2/fork.2.html">fork(2)</a> inherits its parent's cgroup
       memberships.  A process's cgroup memberships are preserved across
       <a href="../man2/execve.2.html">execve(2)</a>.

       The <a href="../man2/clone3.2.html">clone3(2)</a> <b>CLONE_INTO_CGROUP </b>flag can be used to create a
       child process that begins its life in a different version 2
       cgroup from the parent process.

   <b>/proc files</b>
       <i>/proc/cgroups</i> (since Linux 2.6.24)
              This file contains information about the controllers that
              are compiled into the kernel.  An example of the contents
              of this file (reformatted for readability) is the
              following:

                  #subsys_name    hierarchy      num_cgroups    enabled
                  cpuset          4              1              1
                  cpu             8              1              1
                  cpuacct         8              1              1
                  blkio           6              1              1
                  memory          3              1              1
                  devices         10             84             1
                  freezer         7              1              1
                  net_cls         9              1              1
                  perf_event      5              1              1
                  net_prio        9              1              1
                  hugetlb         0              1              0
                  pids            2              1              1

              The fields in this file are, from left to right:

              [1]  The name of the controller.

              [2]  The unique ID of the cgroup hierarchy on which this
                   controller is mounted.  If multiple cgroups v1
                   controllers are bound to the same hierarchy, then
                   each will show the same hierarchy ID in this field.
                   The value in this field will be 0 if:

                   â€¢  the controller is not mounted on a cgroups v1
                      hierarchy;

                   â€¢  the controller is bound to the cgroups v2 single
                      unified hierarchy; or

                   â€¢  the controller is disabled (see below).

              [3]  The number of control groups in this hierarchy using
                   this controller.

              [4]  This field contains the value 1 if this controller is
                   enabled, or 0 if it has been disabled (via the
                   <i>cgroup_disable</i> kernel command-line boot parameter).

       <i>/proc/</i>pid<i>/cgroup</i> (since Linux 2.6.24)
              This file describes control groups to which the process
              with the corresponding PID belongs.  The displayed
              information differs for cgroups version 1 and version 2
              hierarchies.

              For each cgroup hierarchy of which the process is a
              member, there is one entry containing three colon-
              separated fields:

                  hierarchy-ID:controller-list:cgroup-path

              For example:

                  5:cpuacct,cpu,cpuset:/daemons

              The colon-separated fields are, from left to right:

              [1]  For cgroups version 1 hierarchies, this field
                   contains a unique hierarchy ID number that can be
                   matched to a hierarchy ID in <i>/proc/cgroups</i>.  For the
                   cgroups version 2 hierarchy, this field contains the
                   value 0.

              [2]  For cgroups version 1 hierarchies, this field
                   contains a comma-separated list of the controllers
                   bound to the hierarchy.  For the cgroups version 2
                   hierarchy, this field is empty.

              [3]  This field contains the pathname of the control group
                   in the hierarchy to which the process belongs.  This
                   pathname is relative to the mount point of the
                   hierarchy.

   <b>/sys/kernel/cgroup files</b>
       <i>/sys/kernel/cgroup/delegate</i> (since Linux 4.15)
              This file exports a list of the cgroups v2 files (one per
              line) that are delegatable (i.e., whose ownership should
              be changed to the user ID of the delegatee).  In the
              future, the set of delegatable files may change or grow,
              and this file provides a way for the kernel to inform
              user-space applications of which files must be delegated.
              As at Linux 4.15, one sees the following when inspecting
              this file:

                  $ <b>cat /sys/kernel/cgroup/delegate</b>
                  cgroup.procs
                  cgroup.subtree_control
                  cgroup.threads

       <i>/sys/kernel/cgroup/features</i> (since Linux 4.15)
              Over time, the set of cgroups v2 features that are
              provided by the kernel may change or grow, or some
              features may not be enabled by default.  This file
              provides a way for user-space applications to discover
              what features the running kernel supports and has enabled.
              Features are listed one per line:

                  $ <b>cat /sys/kernel/cgroup/features</b>
                  nsdelegate
                  memory_localevents

              The entries that can appear in this file are:

              <i>memory_localevents</i> (since Linux 5.2)
                     The kernel supports the <i>memory_localevents</i> mount
                     option.

              <i>nsdelegate</i> (since Linux 4.15)
                     The kernel supports the <i>nsdelegate</i> mount option.

              <i>memory_recursiveprot</i> (since Linux 5.7)
                     The kernel supports the <i>memory_recursiveprot</i> mount
                     option.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man1/prlimit.1.html">prlimit(1)</a>, <a href="../man1/systemd.1.html">systemd(1)</a>, <a href="../man1/systemd-cgls.1.html">systemd-cgls(1)</a>, <a href="../man1/systemd-cgtop.1.html">systemd-cgtop(1)</a>,
       <a href="../man2/clone.2.html">clone(2)</a>, <a href="../man2/ioprio_set.2.html">ioprio_set(2)</a>, <a href="../man2/perf_event_open.2.html">perf_event_open(2)</a>, <a href="../man2/setrlimit.2.html">setrlimit(2)</a>,
       <a href="cgroup_namespaces.7.html">cgroup_namespaces(7)</a>, <a href="cpuset.7.html">cpuset(7)</a>, <a href="namespaces.7.html">namespaces(7)</a>, <a href="sched.7.html">sched(7)</a>,
       <a href="user_namespaces.7.html">user_namespaces(7)</a>

       The kernel source file <i>Documentation/admin-guide/cgroup-v2.rst</i>.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       âŸ¨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>âŸ©.  If you have a bug report
       for this manual page, see
       âŸ¨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>âŸ©.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       âŸ¨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>âŸ© on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-06-15                     <i>cgroups</i>(7)</span>
</pre>  <p>Pages that refer to this page: <a href="../man2/clone.2.html">clone(2)</a>, <a href="../man2/getrlimit.2.html">getrlimit(2)</a>, <a href="../man2/ioprio_set.2.html">ioprio_set(2)</a>, <a href="../man2/poll.2.html">poll(2)</a>, <a href="../man5/proc_cgroups.5.html">proc_cgroups(5)</a>, <a href="../man5/proc_pid_cgroup.5.html">proc_pid_cgroup(5)</a>, <a href="../man5/sysfs.5.html">sysfs(5)</a>, <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>, <a href="bpf-helpers.7.html">bpf-helpers(7)</a>, <a href="cgroup_namespaces.7.html">cgroup_namespaces(7)</a>, <a href="cpuset.7.html">cpuset(7)</a>, <a href="namespaces.7.html">namespaces(7)</a>, <a href="sched.7.html">sched(7)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man7/cgroups.7.html" class="_attribution-link">https://man7.org/linux/man-pages/man7/cgroups.7.html</a>
  </p>
</div>
