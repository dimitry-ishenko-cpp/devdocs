<h1>unix(7) — Linux manual page</h1>   <pre>
<span class="headline"><i>UNIX</i>(7)             Miscellaneous Information Manual             <i>UNIX</i>(7)</span>
</pre> <h2>
NAME </h2>
<pre>
       unix - sockets for local interprocess communication
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;sys/socket.h&gt;</b>
       <b>#include &lt;sys/un.h&gt;</b>

       <i>unix_socket</i> <b>= socket(AF_UNIX, type, 0);</b>
       <i>error</i> <b>= socketpair(AF_UNIX, type, 0, int *</b><i>sv</i><b>);</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <b>AF_UNIX </b>(also known as <b>AF_LOCAL</b>) socket family is used to
       communicate between processes on the same machine efficiently.
       Traditionally, UNIX domain sockets can be either unnamed, or
       bound to a filesystem pathname (marked as being of type socket).
       Linux also supports an abstract namespace which is independent of
       the filesystem.

       Valid socket types in the UNIX domain are: <b>SOCK_STREAM</b>, for a
       stream-oriented socket; <b>SOCK_DGRAM</b>, for a datagram-oriented
       socket that preserves message boundaries (as on most UNIX
       implementations, UNIX domain datagram sockets are always reliable
       and don't reorder datagrams); and (since Linux 2.6.4)
       <b>SOCK_SEQPACKET</b>, for a sequenced-packet socket that is connection-
       oriented, preserves message boundaries, and delivers messages in
       the order that they were sent.

       UNIX domain sockets support passing file descriptors or process
       credentials to other processes using ancillary data.

   <b>Address format</b>
       A UNIX domain socket address is represented in the following
       structure:

           struct sockaddr_un {
               sa_family_t sun_family;               /* AF_UNIX */
               char        sun_path[108];            /* Pathname */
           };

       The <i>sun_family</i> field always contains <b>AF_UNIX</b>.  On Linux, <i>sun_path</i>
       is 108 bytes in size; see also BUGS, below.

       Various system calls (for example, <a href="../man2/bind.2.html">bind(2)</a>, <a href="../man2/connect.2.html">connect(2)</a>, and
       <a href="../man2/sendto.2.html">sendto(2)</a>) take a <i>sockaddr_un</i> argument as input.  Some other
       system calls (for example, <a href="../man2/getsockname.2.html">getsockname(2)</a>, <a href="../man2/getpeername.2.html">getpeername(2)</a>,
       <a href="../man2/recvfrom.2.html">recvfrom(2)</a>, and <a href="../man2/accept.2.html">accept(2)</a>) return an argument of this type.

       Three types of address are distinguished in the <i>sockaddr_un</i>
       structure:

       pathname
              a UNIX domain socket can be bound to a null-terminated
              filesystem pathname using <a href="../man2/bind.2.html">bind(2)</a>.  When the address of a
              pathname socket is returned (by one of the system calls
              noted above), its length is

                  offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1

              and <i>sun_path</i> contains the null-terminated pathname.  (On
              Linux, the above <b>offsetof</b>() expression equates to the same
              value as <i>sizeof(sa_family_t)</i>, but some other
              implementations include other fields before <i>sun_path</i>, so
              the <b>offsetof</b>() expression more portably describes the size
              of the address structure.)

              For further details of pathname sockets, see below.

       unnamed
              A stream socket that has not been bound to a pathname
              using <a href="../man2/bind.2.html">bind(2)</a> has no name.  Likewise, the two sockets
              created by <a href="../man2/socketpair.2.html">socketpair(2)</a> are unnamed.  When the address of
              an unnamed socket is returned, its length is
              <i>sizeof(sa_family_t)</i>, and <i>sun_path</i> should not be inspected.

       abstract
              an abstract socket address is distinguished (from a
              pathname socket) by the fact that <i>sun_path[0]</i> is a null
              byte ('\0').  The socket's address in this namespace is
              given by the additional bytes in <i>sun_path</i> that are covered
              by the specified length of the address structure.  (Null
              bytes in the name have no special significance.)  The name
              has no connection with filesystem pathnames.  When the
              address of an abstract socket is returned, the returned
              <i>addrlen</i> is greater than <i>sizeof(sa_family_t)</i> (i.e., greater
              than 2), and the name of the socket is contained in the
              first <i>(addrlen - sizeof(sa_family_t))</i> bytes of <i>sun_path</i>.

   <b>Pathname sockets</b>
       When binding a socket to a pathname, a few rules should be
       observed for maximum portability and ease of coding:

       •  The pathname in <i>sun_path</i> should be null-terminated.

       •  The length of the pathname, including the terminating null
          byte, should not exceed the size of <i>sun_path</i>.

       •  The <i>addrlen</i> argument that describes the enclosing <i>sockaddr_un</i>
          structure should have a value of at least:

              offsetof(struct sockaddr_un, sun_path)+strlen(addr.sun_path)+1

          or, more simply, <i>addrlen</i> can be specified as <i>sizeof(struct</i>
          <i>sockaddr_un)</i>.

       There is some variation in how implementations handle UNIX domain
       socket addresses that do not follow the above rules.  For
       example, some (but not all) implementations append a null
       terminator if none is present in the supplied <i>sun_path</i>.

       When coding portable applications, keep in mind that some
       implementations have <i>sun_path</i> as short as 92 bytes.

       Various system calls (<a href="../man2/accept.2.html">accept(2)</a>, <a href="../man2/recvfrom.2.html">recvfrom(2)</a>, <a href="../man2/getsockname.2.html">getsockname(2)</a>,
       <a href="../man2/getpeername.2.html">getpeername(2)</a>) return socket address structures.  When applied
       to UNIX domain sockets, the value-result <i>addrlen</i> argument
       supplied to the call should be initialized as above.  Upon
       return, the argument is set to indicate the <i>actual</i> size of the
       address structure.  The caller should check the value returned in
       this argument: if the output value exceeds the input value, then
       there is no guarantee that a null terminator is present in
       <i>sun_path</i>.  (See BUGS.)

   <b>Pathname socket ownership and permissions</b>
       In the Linux implementation, pathname sockets honor the
       permissions of the directory they are in.  Creation of a new
       socket fails if the process does not have write and search
       (execute) permission on the directory in which the socket is
       created.

       On Linux, connecting to a stream socket object requires write
       permission on that socket; sending a datagram to a datagram
       socket likewise requires write permission on that socket.  POSIX
       does not make any statement about the effect of the permissions
       on a socket file, and on some systems (e.g., older BSDs), the
       socket permissions are ignored.  Portable programs should not
       rely on this feature for security.

       When creating a new socket, the owner and group of the socket
       file are set according to the usual rules.  The socket file has
       all permissions enabled, other than those that are turned off by
       the process <a href="../man2/umask.2.html">umask(2)</a>.

       The owner, group, and permissions of a pathname socket can be
       changed (using <a href="../man2/chown.2.html">chown(2)</a> and <a href="../man2/chmod.2.html">chmod(2)</a>).

   <b>Abstract sockets</b>
       Socket permissions have no meaning for abstract sockets: the
       process <a href="../man2/umask.2.html">umask(2)</a> has no effect when binding an abstract socket,
       and changing the ownership and permissions of the object (via
       <a href="../man2/fchown.2.html">fchown(2)</a> and <a href="../man2/fchmod.2.html">fchmod(2)</a>) has no effect on the accessibility of
       the socket.

       Abstract sockets automatically disappear when all open references
       to the socket are closed.

       The abstract socket namespace is a nonportable Linux extension.

   <b>Socket options</b>
       For historical reasons, these socket options are specified with a
       <b>SOL_SOCKET </b>type even though they are <b>AF_UNIX </b>specific.  They can
       be set with <a href="../man2/setsockopt.2.html">setsockopt(2)</a> and read with <a href="../man2/getsockopt.2.html">getsockopt(2)</a> by
       specifying <b>SOL_SOCKET </b>as the socket family.

       <b>SO_PASSCRED</b>
              Enabling this socket option causes receipt of the
              credentials of the sending process in an <b>SCM_CREDENTIALS</b>
              <b>ancillary </b>message in each subsequently received message.
              The returned credentials are those specified by the sender
              using <b>SCM_CREDENTIALS</b>, or a default that includes the
              sender's PID, real user ID, and real group ID, if the
              sender did not specify <b>SCM_CREDENTIALS </b>ancillary data.

              When this option is set and the socket is not yet
              connected, a unique name in the abstract namespace will be
              generated automatically.

              The value given as an argument to <a href="../man2/setsockopt.2.html">setsockopt(2)</a> and
              returned as the result of <a href="../man2/getsockopt.2.html">getsockopt(2)</a> is an integer
              boolean flag.

       <b>SO_PASSSEC</b>
              Enables receiving of the SELinux security label of the
              peer socket in an ancillary message of type <b>SCM_SECURITY</b>
              (see below).

              The value given as an argument to <a href="../man2/setsockopt.2.html">setsockopt(2)</a> and
              returned as the result of <a href="../man2/getsockopt.2.html">getsockopt(2)</a> is an integer
              boolean flag.

              The <b>SO_PASSSEC </b>option is supported for UNIX domain
              datagram sockets since Linux 2.6.18; support for UNIX
              domain stream sockets was added in Linux 4.2.

       <b>SO_PEEK_OFF</b>
              See <a href="socket.7.html">socket(7)</a>.

       <b>SO_PEERCRED</b>
              This read-only socket option returns the credentials of
              the peer process connected to this socket.  The returned
              credentials are those that were in effect at the time of
              the call to <a href="../man2/connect.2.html">connect(2)</a>, <a href="../man2/listen.2.html">listen(2)</a>, or <a href="../man2/socketpair.2.html">socketpair(2)</a>.

              The argument to <a href="../man2/getsockopt.2.html">getsockopt(2)</a> is a pointer to a <i>ucred</i>
              structure; define the <b>_GNU_SOURCE </b>feature test macro to
              obtain the definition of that structure from
              <i>&lt;sys/socket.h&gt;</i>.

              The use of this option is possible only for connected
              <b>AF_UNIX </b>stream sockets and for <b>AF_UNIX </b>stream and datagram
              socket pairs created using <a href="../man2/socketpair.2.html">socketpair(2)</a>.

       <b>SO_PEERSEC</b>
              This read-only socket option returns the security context
              of the peer socket connected to this socket.  By default,
              this will be the same as the security context of the
              process that created the peer socket unless overridden by
              the policy or by a process with the required permissions.

              The argument to <a href="../man2/getsockopt.2.html">getsockopt(2)</a> is a pointer to a buffer of
              the specified length in bytes into which the security
              context string will be copied.  If the buffer length is
              less than the length of the security context string, then
              <a href="../man2/getsockopt.2.html">getsockopt(2)</a> returns -1, sets <i><a href="../man3/errno.3.html">errno</a></i> to <b>ERANGE</b>, and
              returns the required length via <i>optlen</i>.  The caller should
              allocate at least <b>NAME_MAX </b>bytes for the buffer initially,
              although this is not guaranteed to be sufficient.
              Resizing the buffer to the returned length and retrying
              may be necessary.

              The security context string may include a terminating null
              character in the returned length, but is not guaranteed to
              do so: a security context "foo" might be represented as
              either {'f','o','o'} of length 3 or {'f','o','o','\0'} of
              length 4, which are considered to be interchangeable.  The
              string is printable, does not contain non-terminating null
              characters, and is in an unspecified encoding (in
              particular, it is not guaranteed to be ASCII or UTF-8).

              The use of this option for sockets in the <b>AF_UNIX </b>address
              family is supported since Linux 2.6.2 for connected stream
              sockets, and since Linux 4.18 also for stream and datagram
              socket pairs created using <a href="../man2/socketpair.2.html">socketpair(2)</a>.

   <b>Autobind feature</b>
       If a <a href="../man2/bind.2.html">bind(2)</a> call specifies <i>addrlen</i> as <i>sizeof(sa_family_t)</i>, or
       the <b>SO_PASSCRED </b>socket option was specified for a socket that was
       not explicitly bound to an address, then the socket is autobound
       to an abstract address.  The address consists of a null byte
       followed by 5 bytes in the character set <i>[0-9a-f]</i>.  Thus, there
       is a limit of 2^20 autobind addresses.  (From Linux 2.1.15, when
       the autobind feature was added, 8 bytes were used, and the limit
       was thus 2^32 autobind addresses.  The change to 5 bytes came in
       Linux 2.3.15.)

   <b>Sockets API</b>
       The following paragraphs describe domain-specific details and
       unsupported features of the sockets API for UNIX domain sockets
       on Linux.

       UNIX domain sockets do not support the transmission of out-of-
       band data (the <b>MSG_OOB </b>flag for <a href="../man2/send.2.html">send(2)</a> and <a href="../man2/recv.2.html">recv(2)</a>).

       The <a href="../man2/send.2.html">send(2)</a> <b>MSG_MORE </b>flag is not supported by UNIX domain
       sockets.

       Before Linux 3.4, the use of <b>MSG_TRUNC </b>in the <i>flags</i> argument of
       <a href="../man2/recv.2.html">recv(2)</a> was not supported by UNIX domain sockets.

       The <b>SO_SNDBUF </b>socket option does have an effect for UNIX domain
       sockets, but the <b>SO_RCVBUF </b>option does not.  For datagram
       sockets, the <b>SO_SNDBUF </b>value imposes an upper limit on the size
       of outgoing datagrams.  This limit is calculated as the doubled
       (see <a href="socket.7.html">socket(7)</a>) option value less 32 bytes used for overhead.

   <b>Ancillary messages</b>
       Ancillary data is sent and received using <a href="../man2/sendmsg.2.html">sendmsg(2)</a> and
       <a href="../man2/recvmsg.2.html">recvmsg(2)</a>.  For historical reasons, the ancillary message types
       listed below are specified with a <b>SOL_SOCKET </b>type even though
       they are <b>AF_UNIX </b>specific.  To send them, set the <i>cmsg_level</i>
       field of the struct <i>cmsghdr</i> to <b>SOL_SOCKET </b>and the <i>cmsg_type</i> field
       to the type.  For more information, see <a href="../man3/cmsg.3.html">cmsg(3)</a>.

       <b>SCM_RIGHTS</b>
              Send or receive a set of open file descriptors from
              another process.  The data portion contains an integer
              array of the file descriptors.

              Commonly, this operation is referred to as "passing a file
              descriptor" to another process.  However, more accurately,
              what is being passed is a reference to an open file
              description (see <a href="../man2/open.2.html">open(2)</a>), and in the receiving process it
              is likely that a different file descriptor number will be
              used.  Semantically, this operation is equivalent to
              duplicating (<a href="../man2/dup.2.html">dup(2)</a>) a file descriptor into the file
              descriptor table of another process.

              If the buffer used to receive the ancillary data
              containing file descriptors is too small (or is absent),
              then the ancillary data is truncated (or discarded) and
              the excess file descriptors are automatically closed in
              the receiving process.

              If the number of file descriptors received in the
              ancillary data would cause the process to exceed its
              <b>RLIMIT_NOFILE </b>resource limit (see <a href="../man2/getrlimit.2.html">getrlimit(2)</a>), the
              excess file descriptors are automatically closed in the
              receiving process.

              The kernel constant <b>SCM_MAX_FD </b>defines a limit on the
              number of file descriptors in the array.  Attempting to
              send an array larger than this limit causes <a href="../man2/sendmsg.2.html">sendmsg(2)</a> to
              fail with the error <b>EINVAL</b>.  <b>SCM_MAX_FD </b>has the value 253
              (or 255 before Linux 2.6.38).

       <b>SCM_CREDENTIALS</b>
              Send or receive UNIX credentials.  This can be used for
              authentication.  The credentials are passed as a <i>struct</i>
              <i>ucred</i> ancillary message.  This structure is defined in
              <i>&lt;sys/socket.h&gt;</i> as follows:

                  struct ucred {
                      pid_t pid;    /* Process ID of the sending process */
                      uid_t uid;    /* User ID of the sending process */
                      gid_t gid;    /* Group ID of the sending process */
                  };

              Since glibc 2.8, the <b>_GNU_SOURCE </b>feature test macro must
              be defined (before including <i>any</i> header files) in order to
              obtain the definition of this structure.

              The credentials which the sender specifies are checked by
              the kernel.  A privileged process is allowed to specify
              values that do not match its own.  The sender must specify
              its own process ID (unless it has the capability
              <b>CAP_SYS_ADMIN</b>, in which case the PID of any existing
              process may be specified), its real user ID, effective
              user ID, or saved set-user-ID (unless it has <b>CAP_SETUID</b>),
              and its real group ID, effective group ID, or saved set-
              group-ID (unless it has <b>CAP_SETGID</b>).

              To receive a <i>struct ucred</i> message, the <b>SO_PASSCRED </b>option
              must be enabled on the socket.

       <b>SCM_SECURITY</b>
              Receive the SELinux security context (the security label)
              of the peer socket.  The received ancillary data is a
              null-terminated string containing the security context.
              The receiver should allocate at least <b>NAME_MAX </b>bytes in
              the data portion of the ancillary message for this data.

              To receive the security context, the <b>SO_PASSSEC </b>option
              must be enabled on the socket (see above).

       When sending ancillary data with <a href="../man2/sendmsg.2.html">sendmsg(2)</a>, only one item of
       each of the above types may be included in the sent message.

       At least one byte of real data should be sent when sending
       ancillary data.  On Linux, this is required to successfully send
       ancillary data over a UNIX domain stream socket.  When sending
       ancillary data over a UNIX domain datagram socket, it is not
       necessary on Linux to send any accompanying real data.  However,
       portable applications should also include at least one byte of
       real data when sending ancillary data over a datagram socket.

       When receiving from a stream socket, ancillary data forms a kind
       of barrier for the received data.  For example, suppose that the
       sender transmits as follows:

              (1)  <a href="../man2/sendmsg.2.html">sendmsg(2)</a> of four bytes, with no ancillary data.
              (2)  <a href="../man2/sendmsg.2.html">sendmsg(2)</a> of one byte, with ancillary data.
              (3)  <a href="../man2/sendmsg.2.html">sendmsg(2)</a> of four bytes, with no ancillary data.

       Suppose that the receiver now performs <a href="../man2/recvmsg.2.html">recvmsg(2)</a> calls each with
       a buffer size of 20 bytes.  The first call will receive five
       bytes of data, along with the ancillary data sent by the second
       <a href="../man2/sendmsg.2.html">sendmsg(2)</a> call.  The next call will receive the remaining four
       bytes of data.

       If the space allocated for receiving incoming ancillary data is
       too small then the ancillary data is truncated to the number of
       headers that will fit in the supplied buffer (or, in the case of
       an <b>SCM_RIGHTS </b>file descriptor list, the list of file descriptors
       may be truncated).  If no buffer is provided for incoming
       ancillary data (i.e., the <i>msg_control</i> field of the <i>msghdr</i>
       structure supplied to <a href="../man2/recvmsg.2.html">recvmsg(2)</a> is NULL), then the incoming
       ancillary data is discarded.  In both of these cases, the
       <b>MSG_CTRUNC </b>flag will be set in the <i>msg.msg_flags</i> value returned
       by <a href="../man2/recvmsg.2.html">recvmsg(2)</a>.

   <b>Ioctls</b>
       The following <a href="../man2/ioctl.2.html">ioctl(2)</a> calls return information in <i>value</i>.  The
       correct syntax is:

              <b>int </b><i>value</i><b>;</b>
              <i>error</i> <b>= ioctl(</b><i>unix_socket</i><b>, </b><i>ioctl_type</i><b>, &amp;</b><i>value</i><b>);</b>

       <i>ioctl_type</i> can be:

       <b>SIOCINQ</b>
              For <b>SOCK_STREAM </b>sockets, this call returns the number of
              unread bytes in the receive buffer.  The socket must not
              be in LISTEN state, otherwise an error (<b>EINVAL</b>) is
              returned.  <b>SIOCINQ </b>is defined in <i>&lt;linux/sockios.h&gt;</i>.
              Alternatively, you can use the synonymous <b>FIONREAD</b>,
              defined in <i>&lt;sys/ioctl.h&gt;</i>.  For <b>SOCK_DGRAM </b>sockets, the
              returned value is the same as for Internet domain datagram
              sockets; see <a href="udp.7.html">udp(7)</a>.
</pre> <h2>
ERRORS </h2>
<pre>
       <b>EADDRINUSE</b>
              The specified local address is already in use or the
              filesystem socket object already exists.

       <b>EBADF  </b>This error can occur for <a href="../man2/sendmsg.2.html">sendmsg(2)</a> when sending a file
              descriptor as ancillary data over a UNIX domain socket
              (see the description of <b>SCM_RIGHTS</b>, above), and indicates
              that the file descriptor number that is being sent is not
              valid (e.g., it is not an open file descriptor).

       <b>ECONNREFUSED</b>
              The remote address specified by <a href="../man2/connect.2.html">connect(2)</a> was not a
              listening socket.  This error can also occur if the target
              pathname is not a socket.

       <b>ECONNRESET</b>
              Remote socket was unexpectedly closed.

       <b>EFAULT </b>User memory address was not valid.

       <b>EINVAL </b>Invalid argument passed.  A common cause is that the value
              <b>AF_UNIX </b>was not specified in the <i>sun_type</i> field of passed
              addresses, or the socket was in an invalid state for the
              applied operation.

       <b>EISCONN</b>
              <a href="../man2/connect.2.html">connect(2)</a> called on an already connected socket or a
              target address was specified on a connected socket.

       <b>ENFILE </b>The system-wide limit on the total number of open files
              has been reached.

       <b>ENOENT </b>The pathname in the remote address specified to <a href="../man2/connect.2.html">connect(2)</a>
              did not exist.

       <b>ENOMEM </b>Out of memory.

       <b>ENOTCONN</b>
              Socket operation needs a target address, but the socket is
              not connected.

       <b>EOPNOTSUPP</b>
              Stream operation called on non-stream oriented socket or
              tried to use the out-of-band data option.

       <b>EPERM  </b>The sender passed invalid credentials in the <i>struct ucred</i>.

       <b>EPIPE  </b>Remote socket was closed on a stream socket.  If enabled,
              a <b>SIGPIPE </b>is sent as well.  This can be avoided by passing
              the <b>MSG_NOSIGNAL </b>flag to <a href="../man2/send.2.html">send(2)</a> or <a href="../man2/sendmsg.2.html">sendmsg(2)</a>.

       <b>EPROTONOSUPPORT</b>
              Passed protocol is not <b>AF_UNIX</b>.

       <b>EPROTOTYPE</b>
              Remote socket does not match the local socket type
              (<b>SOCK_DGRAM </b>versus <b>SOCK_STREAM</b>).

       <b>ESOCKTNOSUPPORT</b>
              Unknown socket type.

       <b>ESRCH  </b>While sending an ancillary message containing credentials
              (<b>SCM_CREDENTIALS</b>), the caller specified a PID that does
              not match any existing process.

       <b>ETOOMANYREFS</b>
              This error can occur for <a href="../man2/sendmsg.2.html">sendmsg(2)</a> when sending a file
              descriptor as ancillary data over a UNIX domain socket
              (see the description of <b>SCM_RIGHTS</b>, above).  It occurs if
              the number of "in-flight" file descriptors exceeds the
              <b>RLIMIT_NOFILE </b>resource limit and the caller does not have
              the <b>CAP_SYS_RESOURCE </b>capability.  An in-flight file
              descriptor is one that has been sent using <a href="../man2/sendmsg.2.html">sendmsg(2)</a> but
              has not yet been accepted in the recipient process using
              <a href="../man2/recvmsg.2.html">recvmsg(2)</a>.

              This error is diagnosed since mainline Linux 4.5 (and in
              some earlier kernel versions where the fix has been
              backported).  In earlier kernel versions, it was possible
              to place an unlimited number of file descriptors in
              flight, by sending each file descriptor with <a href="../man2/sendmsg.2.html">sendmsg(2)</a>
              and then closing the file descriptor so that it was not
              accounted against the <b>RLIMIT_NOFILE </b>resource limit.

       Other errors can be generated by the generic socket layer or by
       the filesystem while generating a filesystem socket object.  See
       the appropriate manual pages for more information.
</pre> <h2>
VERSIONS </h2>
<pre>
       <b>SCM_CREDENTIALS </b>and the abstract namespace were introduced with
       Linux 2.2 and should not be used in portable programs.  (Some
       BSD-derived systems also support credential passing, but the
       implementation details differ.)
</pre> <h2>
NOTES </h2>
<pre>
       Binding to a socket with a filename creates a socket in the
       filesystem that must be deleted by the caller when it is no
       longer needed (using <a href="../man2/unlink.2.html">unlink(2)</a>).  The usual UNIX close-behind
       semantics apply; the socket can be unlinked at any time and will
       be finally removed from the filesystem when the last reference to
       it is closed.

       To pass file descriptors or credentials over a <b>SOCK_STREAM</b>
       socket, you must send or receive at least one byte of
       nonancillary data in the same <a href="../man2/sendmsg.2.html">sendmsg(2)</a> or <a href="../man2/recvmsg.2.html">recvmsg(2)</a> call.

       UNIX domain stream sockets do not support the notion of out-of-
       band data.
</pre> <h2>
BUGS </h2>
<pre>
       When binding a socket to an address, Linux is one of the
       implementations that append a null terminator if none is supplied
       in <i>sun_path</i>.  In most cases this is unproblematic: when the
       socket address is retrieved, it will be one byte longer than that
       supplied when the socket was bound.  However, there is one case
       where confusing behavior can result: if 108 non-null bytes are
       supplied when a socket is bound, then the addition of the null
       terminator takes the length of the pathname beyond
       <i>sizeof(sun_path)</i>.  Consequently, when retrieving the socket
       address (for example, via <a href="../man2/accept.2.html">accept(2)</a>), if the input <i>addrlen</i>
       argument for the retrieving call is specified as <i>sizeof(struct</i>
       <i>sockaddr_un)</i>, then the returned address structure <i>won't</i> have a
       null terminator in <i>sun_path</i>.

       In addition, some implementations don't require a null terminator
       when binding a socket (the <i>addrlen</i> argument is used to determine
       the length of <i>sun_path</i>) and when the socket address is retrieved
       on these implementations, there is no null terminator in
       <i>sun_path</i>.

       Applications that retrieve socket addresses can (portably) code
       to handle the possibility that there is no null terminator in
       <i>sun_path</i> by respecting the fact that the number of valid bytes in
       the pathname is:

           strnlen(addr.sun_path, addrlen - offsetof(sockaddr_un, sun_path))

       Alternatively, an application can retrieve the socket address by
       allocating a buffer of size <i>sizeof(struct sockaddr_un)+1</i> that is
       zeroed out before the retrieval.  The retrieving call can specify
       <i>addrlen</i> as <i>sizeof(struct sockaddr_un)</i>, and the extra zero byte
       ensures that there will be a null terminator for the string
       returned in <i>sun_path</i>:

           void *addrp;

           addrlen = sizeof(struct sockaddr_un);
           addrp = malloc(addrlen + 1);
           if (addrp == NULL)
               /* Handle error */ ;
           memset(addrp, 0, addrlen + 1);

           if (getsockname(sfd, (struct sockaddr *) addrp, &amp;addrlen)) == -1)
               /* handle error */ ;

           printf("sun_path = %s\n", ((struct sockaddr_un *) addrp)-&gt;sun_path);

       This sort of messiness can be avoided if it is guaranteed that
       the applications that <i>create</i> pathname sockets follow the rules
       outlined above under <i>Pathname sockets</i>.
</pre> <h2>
EXAMPLES </h2>
<pre>
       The following code demonstrates the use of sequenced-packet
       sockets for local interprocess communication.  It consists of two
       programs.  The server program waits for a connection from the
       client program.  The client sends each of its command-line
       arguments in separate messages.  The server treats the incoming
       messages as integers and adds them up.  The client sends the
       command string "END".  The server sends back a message containing
       the sum of the client's integers.  The client prints the sum and
       exits.  The server waits for the next client to connect.  To stop
       the server, the client is called with the command-line argument
       "DOWN".

       The following output was recorded while running the server in the
       background and repeatedly executing the client.  Execution of the
       server program ends when it receives the "DOWN" command.

   <b>Example output</b>
           $ <b>./server &amp;</b>
           [1] 25887
           $ <b>./client 3 4</b>
           Result = 7
           $ <b>./client 11 -5</b>
           Result = 6
           $ <b>./client DOWN</b>
           Result = 0
           [1]+  Done                    ./server
           $

   <b>Program source</b>

       /*
        * File connection.h
        */
       #ifndef CONNECTION_H
       #define CONNECTION_H

       #define SOCKET_NAME "/tmp/9Lq7BNBnBycd6nxy.socket"
       #define BUFFER_SIZE 12

       #endif  // include guard

       /*
        * File server.c
        */

       #include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;string.h&gt;
       #include &lt;sys/socket.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;sys/un.h&gt;
       #include &lt;unistd.h&gt;

       #include "connection.h"

       int
       main(void)
       {
           int                 down_flag = 0;
           int                 ret;
           int                 connection_socket;
           int                 data_socket;
           int                 result;
           ssize_t             r, w;
           struct sockaddr_un  name;
           char                buffer[BUFFER_SIZE];

           /* Create local socket. */

           connection_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);
           if (connection_socket == -1) {
               perror("socket");
               exit(EXIT_FAILURE);
           }

           /*
            * For portability clear the whole structure, since some
            * implementations have additional (nonstandard) fields in
            * the structure.
            */

           memset(&amp;name, 0, sizeof(name));

           /* Bind socket to socket name. */

           name.sun_family = AF_UNIX;
           strncpy(name.sun_path, SOCKET_NAME, sizeof(name.sun_path) - 1);

           ret = bind(connection_socket, (const struct sockaddr *) &amp;name,
                      sizeof(name));
           if (ret == -1) {
               perror("bind");
               exit(EXIT_FAILURE);
           }

           /*
            * Prepare for accepting connections. The backlog size is set
            * to 20. So while one request is being processed other requests
            * can be waiting.
            */

           ret = listen(connection_socket, 20);
           if (ret == -1) {
               perror("listen");
               exit(EXIT_FAILURE);
           }

           /* This is the main loop for handling connections. */

           for (;;) {

               /* Wait for incoming connection. */

               data_socket = accept(connection_socket, NULL, NULL);
               if (data_socket == -1) {
                   perror("accept");
                   exit(EXIT_FAILURE);
               }

               result = 0;
               for (;;) {

                   /* Wait for next data packet. */

                   r = read(data_socket, buffer, sizeof(buffer));
                   if (r == -1) {
                       perror("read");
                       exit(EXIT_FAILURE);
                   }

                   /* Ensure buffer is 0-terminated. */

                   buffer[sizeof(buffer) - 1] = 0;

                   /* Handle commands. */

                   if (!strncmp(buffer, "DOWN", sizeof(buffer))) {
                       down_flag = 1;
                       continue;
                   }

                   if (!strncmp(buffer, "END", sizeof(buffer))) {
                       break;
                   }

                   if (down_flag) {
                       continue;
                   }

                   /* Add received summand. */

                   result += atoi(buffer);
               }

               /* Send result. */

               sprintf(buffer, "%d", result);
               w = write(data_socket, buffer, sizeof(buffer));
               if (w == -1) {
                   perror("write");
                   exit(EXIT_FAILURE);
               }

               /* Close socket. */

               close(data_socket);

               /* Quit on DOWN command. */

               if (down_flag) {
                   break;
               }
           }

           close(connection_socket);

           /* Unlink the socket. */

           unlink(SOCKET_NAME);

           exit(EXIT_SUCCESS);
       }

       /*
        * File client.c
        */

       #include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;string.h&gt;
       #include &lt;sys/socket.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;sys/un.h&gt;
       #include &lt;unistd.h&gt;

       #include "connection.h"

       int
       main(int argc, char *argv[])
       {
           int                 ret;
           int                 data_socket;
           ssize_t             r, w;
           struct sockaddr_un  addr;
           char                buffer[BUFFER_SIZE];

           /* Create local socket. */

           data_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);
           if (data_socket == -1) {
               perror("socket");
               exit(EXIT_FAILURE);
           }

           /*
            * For portability clear the whole structure, since some
            * implementations have additional (nonstandard) fields in
            * the structure.
            */

           memset(&amp;addr, 0, sizeof(addr));

           /* Connect socket to socket address. */

           addr.sun_family = AF_UNIX;
           strncpy(addr.sun_path, SOCKET_NAME, sizeof(addr.sun_path) - 1);

           ret = connect(data_socket, (const struct sockaddr *) &amp;addr,
                          sizeof(addr));
           if (ret == -1) {
               fprintf(stderr, "The server is down.\n");
               exit(EXIT_FAILURE);
           }

           /* Send arguments. */

           for (int i = 1; i &lt; argc; ++i) {
               w = write(data_socket, argv[i], strlen(argv[i]) + 1);
               if (w == -1) {
                   perror("write");
                   break;
               }
           }

           /* Request result. */

           strcpy(buffer, "END");
           w = write(data_socket, buffer, strlen(buffer) + 1);
           if (w == -1) {
               perror("write");
               exit(EXIT_FAILURE);
           }

           /* Receive result. */

           r = read(data_socket, buffer, sizeof(buffer));
           if (r == -1) {
               perror("read");
               exit(EXIT_FAILURE);
           }

           /* Ensure buffer is 0-terminated. */

           buffer[sizeof(buffer) - 1] = 0;

           printf("Result = %s\n", buffer);

           /* Close socket. */

           close(data_socket);

           exit(EXIT_SUCCESS);
       }

       For examples of the use of <b>SCM_RIGHTS</b>, see <a href="../man3/cmsg.3.html">cmsg(3)</a> and
       <a href="../man2/seccomp_unotify.2.html">seccomp_unotify(2)</a>.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man2/recvmsg.2.html">recvmsg(2)</a>, <a href="../man2/sendmsg.2.html">sendmsg(2)</a>, <a href="../man2/socket.2.html">socket(2)</a>, <a href="../man2/socketpair.2.html">socketpair(2)</a>, <a href="../man3/cmsg.3.html">cmsg(3)</a>,
       <a href="capabilities.7.html">capabilities(7)</a>, <a href="credentials.7.html">credentials(7)</a>, <a href="socket.7.html">socket(7)</a>, <a href="udp.7.html">udp(7)</a>
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       ⟨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>⟩.  If you have a bug report
       for this manual page, see
       ⟨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>⟩.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       ⟨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>⟩ on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-06-15                        <i>UNIX</i>(7)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/pmdaroot.1.html">pmdaroot(1)</a>, <a href="../man1/systemd-ssh-proxy.1.html">systemd-ssh-proxy(1)</a>, <a href="../man2/bind.2.html">bind(2)</a>, <a href="../man2/getpeername.2.html">getpeername(2)</a>, <a href="../man2/getrlimit.2.html">getrlimit(2)</a>, <a href="../man2/getsockname.2.html">getsockname(2)</a>, <a href="../man2/getsockopt.2.html">getsockopt(2)</a>, <a href="../man2/kcmp.2.html">kcmp(2)</a>, <a href="../man2/memfd_create.2.html">memfd_create(2)</a>, <a href="../man2/open.2.html">open(2)</a>, <a href="../man2/pidfd_getfd.2.html">pidfd_getfd(2)</a>, <a href="../man2/recv.2.html">recv(2)</a>, <a href="../man2/seccomp_unotify.2.html">seccomp_unotify(2)</a>, <a href="../man2/send.2.html">send(2)</a>, <a href="../man2/setns.2.html">setns(2)</a>, <a href="../man2/signalfd.2.html">signalfd(2)</a>, <a href="../man2/socket.2.html">socket(2)</a>, <a href="../man2/socketpair.2.html">socketpair(2)</a>, <a href="../man2/umask.2.html">umask(2)</a>, <a href="../man3/io_uring_prep_cmd.3.html">io_uring_prep_cmd(3)</a>, <a href="../man3/pmdarootconnect.3.html">pmdarootconnect(3)</a>, <a href="../man3/sd_is_fifo.3.html">sd_is_fifo(3)</a>, <a href="../man5/crypttab.5.html">crypttab(5)</a>, <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>, <a href="../man5/systemd.socket.5.html">systemd.socket(5)</a>, <a href="address_families.7.html">address_families(7)</a>, <a href="capabilities.7.html">capabilities(7)</a>, <a href="credentials.7.html">credentials(7)</a>, <a href="network_namespaces.7.html">network_namespaces(7)</a>, <a href="pid_namespaces.7.html">pid_namespaces(7)</a>, <a href="socket.7.html">socket(7)</a>, <a href="user_namespaces.7.html">user_namespaces(7)</a>, <a href="../man8/systemd-ssh-generator.8.html">systemd-ssh-generator(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man7/unix.7.html" class="_attribution-link">https://man7.org/linux/man-pages/man7/unix.7.html</a>
  </p>
</div>
