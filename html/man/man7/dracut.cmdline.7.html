<h1>dracut.cmdline(7) — Linux manual page</h1>   <pre>
<span class="headline"><i>DRACUT.CMDLINE</i>(7)                dracut                <i>DRACUT.CMDLINE</i>(7)</span>
</pre> <h2>
NAME </h2>
<pre>
       dracut.cmdline - dracut kernel command line options
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The root device used by the kernel is specified in the boot
       configuration file on the kernel command line, as always.

       The traditional <i>root=/dev/sda1</i> style device specification is
       allowed, but not encouraged. The root device should better be
       identified by LABEL or UUID. If a label is used, as in
       <i>root=LABEL=&lt;label_of_root&gt;</i> the initramfs will search all
       available devices for a filesystem with the appropriate label,
       and mount that device as the root filesystem.
       <i>root=UUID=&lt;uuidnumber&gt;</i> will mount the partition with that UUID as
       the root filesystem.

       In the following all kernel command line parameters, which are
       processed by dracut, are described.

       "rd.*" parameters mentioned without "=" are boolean parameters.
       They can be turned on/off by setting them to {0|1}. If the
       assignment with "=" is missing "=1" is implied. For example
       <i>rd.info</i> can be turned off with <i>rd.info=0</i> or turned on with
       <i>rd.info=1</i> or <i>rd.info</i>. The last value in the kernel command line
       is the value, which is honored.

   <b>Standard</b>
       <b>init=</b><i>&lt;path to real init&gt;</i>
           specify the path to the init program to be started after the
           initramfs has finished

       <b>root=</b><i>&lt;path to blockdevice&gt;</i>
           specify the block device to use as the root filesystem.

           <b>Example</b>.

               root=/dev/sda1
               root=/dev/disk/by-path/pci-0000:00:1f.1-scsi-0:0:1:0-part1
               root=/dev/disk/by-label/Root
               root=LABEL=Root
               root=/dev/disk/by-uuid/3f5ad593-4546-4a94-a374-bcfb68aa11f7
               root=UUID=3f5ad593-4546-4a94-a374-bcfb68aa11f7
               root=PARTUUID=3f5ad593-4546-4a94-a374-bcfb68aa11f7

       <b>rootfstype=</b><i>&lt;filesystem type&gt;</i>
           "auto" if not specified.

           <b>Example</b>.

               rootfstype=ext4

       <b>rootflags=</b><i>&lt;mount options&gt;</i>
           specify additional mount options for the root filesystem. If
           not set, <i>/etc/fstab</i> of the real root will be parsed for
           special mount options and mounted accordingly.

       <b>ro</b>
           force mounting <i>/</i> and <i>/usr</i> (if it is a separate device)
           read-only. If none of ro and rw is present, both are mounted
           according to <i>/etc/fstab</i>.

       <b>rw</b>
           force mounting <i>/</i> and <i>/usr</i> (if it is a separate device)
           read-write. See also ro option.

       <b>rootfallback=</b><i>&lt;path to blockdevice&gt;</i>
           specify the block device to use as the root filesystem, if
           the normal root cannot be found. This can only be a simple
           block device with a simple file system, for which the
           filesystem driver is either compiled in, or added manually to
           the initramfs. This parameter can be specified multiple
           times.

       <b>rd.auto rd.auto=1</b>
           enable autoassembly of special devices like cryptoLUKS,
           dmraid, mdraid or lvm. Default is off as of dracut version &gt;=
           024.

       <b>rd.hostonly=0</b>
           removes all compiled in configuration of the host system the
           initramfs image was built on. This helps booting, if any disk
           layout changed, especially in combination with rd.auto or
           other parameters specifying the layout.

       <b>rd.cmdline=ask</b>
           prompts the user for additional kernel command line
           parameters

       <b>rd.fstab=0</b>
           do not honor special mount options for the root filesystem
           found in <i>/etc/fstab</i> of the real root.

       <b>resume=</b><i>&lt;path to resume partition&gt;</i>
           resume from a swap partition

           <b>Example</b>.

               resume=/dev/disk/by-path/pci-0000:00:1f.1-scsi-0:0:1:0-part1
               resume=/dev/disk/by-uuid/3f5ad593-4546-4a94-a374-bcfb68aa11f7
               resume=UUID=3f5ad593-4546-4a94-a374-bcfb68aa11f7

       <b>rd.skipfsck</b>
           skip fsck for rootfs and <i>/usr</i>. If you’re mounting <i>/usr</i>
           read-only and the init system performs fsck before remount,
           you might want to use this option to avoid duplication.

   <b>iso-scan/filename</b>
       Mount all mountable devices and search for ISO pointed by the
       argument. When the ISO is found set it up as a loop device.
       Device containing this ISO image will stay mounted at
       /run/initramfs/isoscandev. Using iso-scan/filename with a
       Fedora/Red Hat/CentOS Live iso should just work by copying the
       original kernel cmdline parameters.

       <b>Example</b>.

           menuentry 'Live Fedora 20' --class fedora --class gnu-linux --class gnu --class os {
               set isolabel=Fedora-Live-LXDE-x86_64-20-1
               set isofile="/boot/iso/Fedora-Live-LXDE-x86_64-20-1.iso"
               loopback loop $isofile
               linux (loop)/isolinux/vmlinuz0 boot=isolinux iso-scan/filename=$isofile root=live:LABEL=$isolabel ro rd.live.image quiet rhgb
               initrd (loop)/isolinux/initrd0.img
           }

   <b>Misc</b>
       <b>rd.emergency=</b><i>[reboot|poweroff|halt]</i>
           specify, what action to execute in case of a critical
           failure. rd.shell=0 must also be specified.

       <b>rd.driver.blacklist=</b><i>&lt;drivername&gt;</i>[,<i>&lt;drivername&gt;</i>,...]
           do not load kernel module &lt;drivername&gt;. This parameter can be
           specified multiple times.

       <b>rd.driver.pre=</b><i>&lt;drivername&gt;</i>[,<i>&lt;drivername&gt;</i>,...]
           force loading kernel module &lt;drivername&gt;. This parameter can
           be specified multiple times.

       <b>rd.driver.post=</b><i>&lt;drivername&gt;</i>[,<i>&lt;drivername&gt;</i>,...]
           force loading kernel module &lt;drivername&gt; after all automatic
           loading modules have been loaded. This parameter can be
           specified multiple times.

       <b>rd.retry=</b><i>&lt;seconds&gt;</i>
           specify how long dracut should retry the initqueue to
           configure devices. The default is 180 seconds. After 2/3 of
           the time, degraded raids are force started. If you have
           hardware, which takes a very long time to announce its
           drives, you might want to extend this value.

       <b>rd.timeout=</b><i>&lt;seconds&gt;</i>
           specify how long dracut should wait for devices to appear.
           The default is <i>0</i>, which means <i>forever</i>. Note that this timeout
           should be longer than rd.retry to allow for proper
           configuration.

       <b>rd.noverifyssl</b>
           accept self-signed certificates for ssl downloads.

       <b>rd.ctty=</b><i>&lt;terminal device&gt;</i>
           specify the controlling terminal for the console. This is
           useful, if you have multiple "console=" arguments.

       <b>rd.shutdown.timeout.umount=</b><i>&lt;seconds&gt;</i>
           specify how long dracut should wait for an individual umount
           to finish during shutdown. This avoids the system from
           blocking when unmounting a file system cannot complete and
           waits indefinitely. Value <i>0</i> means to wait <i>forever</i>. The
           default is 90 seconds.

   <b>Debug</b>
       If you are dropped to an emergency shell, the file
       <i>/run/initramfs/rdsosreport.txt</i> is created, which can be saved to
       a (to be mounted by hand) partition (usually /boot) or a USB
       stick. Additional debugging info can be produced by adding
       <b>rd.debug </b>to the kernel command line.
       <i>/run/initramfs/rdsosreport.txt</i> contains all logs and the output
       of some tools. It should be attached to any report about dracut
       problems.

       <b>rd.info</b>
           print informational output though "quiet" is set

       <b>rd.shell</b>
           allow dropping to a shell, if root mounting fails

       <b>rd.debug</b>
           set -x for the dracut shell. If systemd is active in the
           initramfs, all output is logged to the systemd journal, which
           you can inspect with "journalctl -ab". If systemd is not
           active, the logs are written to dmesg and
           <i>/run/initramfs/init.log</i>. If "quiet" is set, it also logs to
           the console.

       <b>rd.memdebug=[0-5]</b>
           Print memory usage info at various points, set the verbose
           level from 0 to 5.

               Higher level means more debugging output:

                   0 - no output
                   1 - partial /proc/meminfo
                   2 - /proc/meminfo
                   3 - /proc/meminfo + /proc/slabinfo
                   4 - /proc/meminfo + /proc/slabinfo + memstrack summary
                       NOTE: memstrack is a memory tracing tool that tracks the total memory
                             consumption, and peak memory consumption of each kernel modules
                             and userspace progress during the whole initramfs runtime, report
                             is generated and the end of initramsfs run.
                   5 - /proc/meminfo + /proc/slabinfo + memstrack (with top memory stacktrace)
                       NOTE: memstrack (with top memory stacktrace) will print top memory
                             allocation stack traces during the whole initramfs runtime.

       <b>rd.break</b>
           drop to a shell at the end

       <b>rd.break=</b><i>{cmdline|pre-udev|pre-trigger|initqueue|pre-mount|mount|pre-pivot|cleanup}</i>
           drop to a shell before the defined breakpoint starts

       <b>rd.udev.info</b>
           set udev to loglevel info

       <b>rd.udev.debug</b>
           set udev to loglevel debug

   <b>I18N</b>
       <b>rd.vconsole.keymap=</b><i>&lt;keymap base file name&gt;</i>
           keyboard translation table loaded by loadkeys; taken from
           keymaps directory; will be written as KEYMAP to
           <i>/etc/vconsole.conf</i> in the initramfs.

           <b>Example</b>.

               rd.vconsole.keymap=de-latin1-nodeadkeys

       <b>rd.vconsole.keymap.ext=</b><i>&lt;list of keymap base file names&gt;</i>
           list of extra keymaps to bo loaded (sep. by space); will be
           written as EXT_KEYMAP to <i>/etc/vconsole.conf</i> in the initramfs

       <b>rd.vconsole.unicode</b>
           boolean, indicating UTF-8 mode; will be written as UNICODE to
           <i>/etc/vconsole.conf</i> in the initramfs

       <b>rd.vconsole.font=</b><i>&lt;font base file name&gt;</i>
           console font; taken from consolefonts directory; will be
           written as FONT to <i>/etc/vconsole.conf</i> in the initramfs.

           <b>Example</b>.

               rd.vconsole.font=eurlatgr

       <b>rd.vconsole.font.map=</b><i>&lt;console map base file name&gt;</i>
           see description of <i>-m</i> parameter in setfont manual; taken from
           consoletrans directory; will be written as FONT_MAP to
           <i>/etc/vconsole.conf</i> in the initramfs

       <b>rd.vconsole.font.unimap=</b><i>&lt;unicode table base file name&gt;</i>
           see description of <i>-u</i> parameter in setfont manual; taken from
           unimaps directory; will be written as FONT_UNIMAP to
           <i>/etc/vconsole.conf</i> in the initramfs

       <b>rd.locale.LANG=</b><i>&lt;locale&gt;</i>
           taken from the environment; if no UNICODE is defined we set
           its value in basis of LANG value (whether it ends with
           ".utf8" (or similar) or not); will be written as LANG to
           <i>/etc/locale.conf</i> in the initramfs.

           <b>Example</b>.

               rd.locale.LANG=pl_PL.utf8

       <b>rd.locale.LC_ALL=</b><i>&lt;locale&gt;</i>
           taken from the environment; will be written as LC_ALL to
           <i>/etc/locale.conf</i> in the initramfs

   <b>LVM</b>
       <b>rd.lvm=0</b>
           disable LVM detection

       <b>rd.lvm.vg=</b><i>&lt;volume group name&gt;</i>
           only activate all logical volumes in the the volume groups
           with the given name. rd.lvm.vg can be specified multiple
           times on the kernel command line.

       <b>rd.lvm.lv=</b><i>&lt;volume group name&gt;/&lt;logical volume name&gt;</i>
           only activate the logical volumes with the given name.
           rd.lvm.lv can be specified multiple times on the kernel
           command line.

       <b>rd.lvm.conf=0</b>
           remove any <i>/etc/lvm/lvm.conf</i>, which may exist in the
           initramfs

   <b>crypto LUKS</b>
       <b>rd.luks=0</b>
           disable crypto LUKS detection

       <b>rd.luks.uuid=</b><i>&lt;luks uuid&gt;</i>
           only activate the LUKS partitions with the given UUID. Any
           "luks-" of the LUKS UUID is removed before comparing to <i>&lt;luks</i>
           <i>uuid&gt;</i>. The comparisons also matches, if <i>&lt;luks uuid&gt;</i> is only
           the beginning of the LUKS UUID, so you don’t have to specify
           the full UUID. This parameter can be specified multiple
           times.  <i>&lt;luks uuid&gt;</i> may be prefixed by the keyword
           keysource:, see <i>rd.luks.key</i> below.

       <b>rd.luks.allow-discards=</b><i>&lt;luks uuid&gt;</i>
           Allow using of discards (TRIM) requests for LUKS partitions
           with the given UUID. Any "luks-" of the LUKS UUID is removed
           before comparing to <i>&lt;luks uuid&gt;</i>. The comparisons also
           matches, if <i>&lt;luks uuid&gt;</i> is only the beginning of the LUKS
           UUID, so you don’t have to specify the full UUID. This
           parameter can be specified multiple times.

       <b>rd.luks.allow-discards</b>
           Allow using of discards (TRIM) requests on all LUKS
           partitions.

       <b>rd.luks.crypttab=0</b>
           do not check, if LUKS partition is in <i>/etc/crypttab</i>

       <b>rd.luks.timeout=</b><i>&lt;seconds&gt;</i>
           specify how long dracut should wait when waiting for the user
           to enter the password. This avoid blocking the boot if no
           password is entered. It does not apply to luks key. The
           default is <i>0</i>, which means <i>forever</i>.

   <b>crypto LUKS - key on removable device support</b>
       NB: If systemd is included in the dracut initrd, dracut’s built
       in removable device keying support won’t work. systemd will
       prompt for a password from the console even if you’ve supplied
       <b>rd.luks.key</b>. You may be able to use standard systemd <a href="../man5/fstab.5.html">fstab(5)</a>
       syntax to get the same effect. If you do need <b>rd.luks.key </b>to
       work, you will have to exclude the "systemd" dracut module and
       any modules that depend on it. See <a href="../man5/dracut.conf.5.html">dracut.conf(5)</a> and
       <b>https://bugzilla.redhat.com/show_bug.cgi?id=905683 </b>for more
       information.

       <b>rd.luks.key=</b><i>&lt;keypath&gt;[:&lt;keydev&gt;[:&lt;luksdev&gt;]]</i>
           <i>&lt;keypath&gt;</i> is the pathname of a key file, relative to the root
           of the filesystem on some device. It’s REQUIRED. When
           <i>&lt;keypath&gt;</i> ends with <i>.gpg</i> it’s considered to be key encrypted
           symmetrically with GPG. You will be prompted for the GPG
           password on boot. GPG support comes with the <i>crypt-gpg</i>
           module, which needs to be added explicitly.

           <i>&lt;keydev&gt;</i> identifies the device on which the key file resides.
           It may be the kernel name of the device (should start with
           "/dev/"), a UUID (prefixed with "UUID=") or a label (prefix
           with "LABEL="). You don’t have to specify a full UUID. Just
           its beginning will suffice, even if its ambiguous. All
           matching devices will be probed. This parameter is
           recommended, but not required. If it’s not present, all block
           devices will be probed, which may significantly increase boot
           time.

           If <i>&lt;luksdev&gt;</i> is given, the specified key will only be used
           for the specified LUKS device. Possible values are the same
           as for <i>&lt;keydev&gt;</i>. Unless you have several LUKS devices, you
           don’t have to specify this parameter. The simplest usage is:

           <b>Example</b>.

               rd.luks.key=/foo/bar.key

           As you see, you can skip colons in such a case.

           <b>Note</b>

           Your LUKS partition must match your key file.

           dracut provides keys to cryptsetup with <i>-d</i> (an older alias
           for <i>--key-file</i>). This uses the entire binary content of the
           key file as part of the secret. If you pipe a password into
           cryptsetup <b>without </b><i>-d</i> or <i>--key-file</i>, it will be treated as
           text user input, and only characters before the first newline
           will be used. Therefore, when you’re creating an encrypted
           partition for dracut to mount, and you pipe a key into
           <i>cryptsetup luksFormat</i>,you must use <i>-d -</i>.

           Here is an example for a key encrypted with GPG (warning:
           <i>--batch-mode</i> will overwrite the device without asking for
           confirmation):

               gpg --quiet --decrypt rootkey.gpg | \
               cryptsetup --batch-mode --key-file - \
                          luksFormat /dev/sda47

           If you use unencrypted key files, just use the key file
           pathname instead of the standard input. For a random key with
           256 bits of entropy, you might use:

               head -32c /dev/urandom &gt; rootkey.key
               cryptsetup --batch-mode --key-file rootkey.key \
                          luksFormat /dev/sda47

           You can also use regular key files on an encrypted <i>keydev</i>.

           Compared to using GPG encrypted keyfiles on an unencrypted
           device this provides the following advantages:

           •   you can unlock your disk(s) using multiple passphrases

           •   better security by not losing the key stretching
               mechanism

           To use an encrypted <i>keydev</i> you <b>must </b>ensure that it becomes
           available by using the keyword keysource, e.g.
           rd.luks.uuid=keysource:aaaa <i>aaaa</i> being the uuid of the
           encrypted <i>keydev</i>.

           Example:

           Lets assume you have three disks <i>A</i>, <i>B</i> and <i>C</i> with the uuids
           <i>aaaa</i>, <i>bbbb</i> and <i>cccc</i>. You want to unlock <i>A</i> and <i>B</i> using keyfile
           <i>keyfile</i>. The unlocked volumes be <i>A'</i>, <i>B'</i> and <i>C'</i> with the uuids
           <i>AAAA</i>, <i>BBBB</i> and <i>CCCC</i>. <i>keyfile</i> is saved on <i>C'</i> as <i>/keyfile</i>.

           One luks keyslot of each <i>A</i>, <i>B</i> and <i>C</i> is setup with a
           passphrase. Another luks keyslot of each <i>A</i> and <i>B</i> is setup
           with <i>keyfile</i>.

           To boot this configuration you could use:

               rd.luks.uuid=aaaa
               rd.luks.uuid=bbbb
               rd.luks.uuid=keysource:cccc
               rd.luks.key=/keyfile:UUID=CCCC

           Dracut asks for the passphrase for <i>C</i> and uses the keyfile to
           unlock <i>A</i> and <i>B</i>. If getting the passphrase for <i>C</i> fails it
           falls back to asking for the passphrases for <i>A</i> and <i>B</i>.

           If you want <i>C'</i> to stay unlocked, specify a luks name for it,
           e.g. rd.luks.name=cccc=mykeys, otherwise it gets closed when
           not needed anymore.

       <b>rd.luks.key.tout=0</b>
           specify how many times dracut will try to read the keys
           specified in in rd.luk.key. This gives a chance to the
           removable device containing the key to initialise.

   <b>MD RAID</b>
       <b>rd.md=0</b>
           disable MD RAID detection

       <b>rd.md.imsm=0</b>
           disable MD RAID for imsm/isw raids, use DM RAID instead

       <b>rd.md.ddf=0</b>
           disable MD RAID for SNIA ddf raids, use DM RAID instead

       <b>rd.md.conf=0</b>
           ignore mdadm.conf included in initramfs

       <b>rd.md.waitclean=1</b>
           wait for any resync, recovery, or reshape activity to finish
           before continuing

       <b>rd.md.uuid=</b><i>&lt;md raid uuid&gt;</i>
           only activate the raid sets with the given UUID. This
           parameter can be specified multiple times.

   <b>DM RAID</b>
       <b>rd.dm=0</b>
           disable DM RAID detection

       <b>rd.dm.uuid=</b><i>&lt;dm raid uuid&gt;</i>
           only activate the raid sets with the given UUID. This
           parameter can be specified multiple times.

   <b>MULTIPATH</b>
       <b>rd.multipath=0</b>
           disable multipath detection

       <b>rd.multipath=default</b>
           use default multipath settings

   <b>FIPS</b>
       <b>rd.fips</b>
           enable FIPS

       <b>boot=</b><i>&lt;boot device&gt;</i>
           specify the device, where /boot is located.

           <b>Example</b>.

               boot=/dev/sda1
               boot=/dev/disk/by-path/pci-0000:00:1f.1-scsi-0:0:1:0-part1
               boot=UUID=&lt;uuid&gt;
               boot=LABEL=&lt;label&gt;

       <b>rd.fips.skipkernel</b>
           skip checksum check of the kernel image. Useful, if the
           kernel image is not in a separate boot partition.

   <b>Network</b>
           <b>Important</b>

           It is recommended to either bind an interface to a MAC with
           the <b>ifname </b>argument, or to use the systemd-udevd predictable
           network interface names.

           Predictable network interface device names based on:

           •   firmware/bios-provided index numbers for on-board devices

           •   firmware-provided pci-express hotplug slot index number

           •   physical/geographical location of the hardware

           •   the interface’s MAC address

           See:
           <b><a href="http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames">http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames</a> </b>

           Two character prefixes based on the type of interface:

           en
               ethernet

           wl
               wlan

           ww
               wwan

           Type of names:

           o&lt;index&gt;
               on-board device index number

           s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_id&gt;]
               hotplug slot index number

           x&lt;MAC&gt;
               MAC address

           [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_id&gt;]
               PCI geographical location

           [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][u&lt;port&gt;][..][c&lt;config&gt;][i&lt;interface&gt;]
               USB port number chain

           All multi-function PCI devices will carry the [f&lt;function&gt;]
           number in the device name, including the function 0 device.

           When using PCI geography, The PCI domain is only prepended
           when it is not 0.

           For USB devices the full chain of port numbers of hubs is
           composed. If the name gets longer than the maximum number of
           15 characters, the name is not exported. The usual USB
           configuration == 1 and interface == 0 values are suppressed.

           PCI ethernet card with firmware index "1"

               •   eno1

           PCI ethernet card in hotplug slot with firmware index number

               •   ens1

           PCI ethernet multi-function card with 2 ports

               •   enp2s0f0

               •   enp2s0f1

           PCI wlan card

               •   wlp3s0

           USB built-in 3G modem

               •   wwp0s29u1u4i6

           USB Android phone

               •   enp0s29u1u2

       The following options are supported by the <i>network-legacy</i> dracut
       module. Other network modules might support a slightly different
       set of options; refer to the documentation of the specific
       network module in use. For NetworkManager, see
       <b>nm-initrd-generator</b>(8).

       <b>ip=</b><i>{dhcp|on|any|dhcp6|auto6|either6|link6|single-dhcp}</i>

           dhcp|on|any
               get ip from dhcp server from all interfaces. If
               netroot=dhcp, loop sequentially through all interfaces
               (eth0, eth1, ...) and use the first with a valid DHCP
               root-path.

           single-dhcp
               Send DHCP on all available interfaces in parallel, as
               opposed to one after another. After the first DHCP
               response is received, stop DHCP on all other interfaces.
               This gives the fastest boot time by using the IP on
               interface for which DHCP succeeded first during early
               boot. Caveat: Does not apply to Network Manager.

           auto6
               IPv6 autoconfiguration

           dhcp6
               IPv6 DHCP

           either6
               if auto6 fails, then dhcp6

           link6
               bring up interface for IPv6 link-local addressing

       <b>ip=</b><i>&lt;interface&gt;</i>:<i>{dhcp|on|any|dhcp6|auto6|link6}</i>[:[<i>&lt;mtu&gt;</i>][:<i>&lt;macaddr&gt;</i>]]
           This parameter can be specified multiple times.

           dhcp|on|any|dhcp6
               get ip from dhcp server on a specific interface

           auto6
               do IPv6 autoconfiguration

           link6
               bring up interface for IPv6 link local address

           &lt;macaddr&gt;
               optionally <b>set </b>&lt;macaddr&gt; on the &lt;interface&gt;. This cannot
               be used in conjunction with the <b>ifname </b>argument for the
               same &lt;interface&gt;.

       <b>ip=</b><i>&lt;client-IP&gt;</i>:[<i>&lt;peer&gt;</i>]:<i>&lt;gateway-IP&gt;</i>:<i>&lt;netmask&gt;</i>:<i>&lt;client_hostname&gt;</i>:<i>&lt;interface&gt;</i>:<i>{none|off|dhcp|on|any|dhcp6|auto6|ibft}</i>[:[<i>&lt;mtu&gt;</i>][:<i>&lt;macaddr&gt;</i>]]
           explicit network configuration. If you want do define a IPv6
           address, put it in brackets (e.g. [2001:DB8::1]). This
           parameter can be specified multiple times.  <i>&lt;peer&gt;</i> is
           optional and is the address of the remote endpoint for
           pointopoint interfaces and it may be followed by a slash and
           a decimal number, encoding the network prefix length.

           &lt;macaddr&gt;
               optionally <b>set </b>&lt;macaddr&gt; on the &lt;interface&gt;. This cannot
               be used in conjunction with the <b>ifname </b>argument for the
               same &lt;interface&gt;.

       <b>ip=</b><i>&lt;client-IP&gt;</i>:[<i>&lt;peer&gt;</i>]:<i>&lt;gateway-IP&gt;</i>:<i>&lt;netmask&gt;</i>:<i>&lt;client_hostname&gt;</i>:<i>&lt;interface&gt;</i>:<i>{none|off|dhcp|on|any|dhcp6|auto6|ibft}</i>[:[<i>&lt;dns1&gt;</i>][:<i>&lt;dns2&gt;</i>]]
           explicit network configuration. If you want do define a IPv6
           address, put it in brackets (e.g. [2001:DB8::1]). This
           parameter can be specified multiple times.  <i>&lt;peer&gt;</i> is
           optional and is the address of the remote endpoint for
           pointopoint interfaces and it may be followed by a slash and
           a decimal number, encoding the network prefix length.

       <b>ifname=</b><i>&lt;interface&gt;</i>:<i>&lt;MAC&gt;</i>
           Assign network device name &lt;interface&gt; (i.e. "bootnet") to
           the NIC with MAC &lt;MAC&gt;.

               <b>Warning</b>
               Do <b>not </b>use the default kernel naming scheme for the
               interface name, as it can conflict with the kernel names.
               So, don’t use "eth[0-9]+" for the interface name. Better
               name it "bootnet" or "bluesocket".

       <b>rd.route=</b><i>&lt;net&gt;</i>/<i>&lt;netmask&gt;</i>:<i>&lt;gateway&gt;</i>[:<i>&lt;interface&gt;</i>]
           Add a static route with route options, which are separated by
           a colon. IPv6 addresses have to be put in brackets.

           <b>Example</b>.

                   rd.route=192.168.200.0/24:192.168.100.222:ens10
                   rd.route=192.168.200.0/24:192.168.100.222
                   rd.route=192.168.200.0/24::ens10
                   rd.route=[2001:DB8:3::/8]:[2001:DB8:2::1]:ens10

       <b>bootdev=</b><i>&lt;interface&gt;</i>
           specify network interface to use routing and netroot
           information from. Required if multiple ip= lines are used.

       <b>BOOTIF=</b><i>&lt;MAC&gt;</i>
           specify network interface to use routing and netroot
           information from.

       <b>rd.bootif=0</b>
           Disable BOOTIF parsing, which is provided by PXE

       <b>nameserver=</b><i>&lt;IP&gt;</i> [<b>nameserver=</b><i>&lt;IP&gt;</i> ...]
           specify nameserver(s) to use

       <b>rd.peerdns=0</b>
           Disable DNS setting of DHCP parameters.

       <b>biosdevname=0</b>
           boolean, turn off biosdevname network interface renaming

       <b>rd.neednet=1</b>
           boolean, bring up network even without netroot set

       <b>vlan=</b><i>&lt;vlanname&gt;</i>:<i>&lt;phydevice&gt;</i>
           Setup vlan device named &lt;vlanname&gt; on &lt;phydevice&gt;. We support
           the four styles of vlan names: VLAN_PLUS_VID (vlan0005),
           VLAN_PLUS_VID_NO_PAD (vlan5), DEV_PLUS_VID (eth0.0005),
           DEV_PLUS_VID_NO_PAD (eth0.5)

       <b>bond=</b><i>&lt;bondname&gt;</i>[:<i>&lt;bondslaves&gt;</i>:[:<i>&lt;options&gt;</i>[:&lt;mtu&gt;]]]
           Setup bonding device &lt;bondname&gt; on top of &lt;bondslaves&gt;.
           &lt;bondslaves&gt; is a comma-separated list of physical (ethernet)
           interfaces. &lt;options&gt; is a comma-separated list on bonding
           options (modinfo bonding for details) in format compatible
           with initscripts. If &lt;options&gt; includes multi-valued
           arp_ip_target option, then its values should be separated by
           semicolon. if the mtu is specified, it will be set on the
           bond master. Bond without parameters assumes
           bond=bond0:eth0,eth1:mode=balance-rr

       <b>team=</b><i>&lt;teammaster&gt;</i>:<i>&lt;teamslaves&gt;</i>[:<i>&lt;teamrunner&gt;</i>]
           Setup team device &lt;teammaster&gt; on top of &lt;teamslaves&gt;.
           &lt;teamslaves&gt; is a comma-separated list of physical (ethernet)
           interfaces. &lt;teamrunner&gt; is the runner type to be used (see
           <b>teamd.conf</b>(5)); defaults to activebackup. Team without
           parameters assumes team=team0:eth0,eth1:activebackup

       <b>bridge=</b><i>&lt;bridgename&gt;</i>:<i>&lt;ethnames&gt;</i>
           Setup bridge &lt;bridgename&gt; with &lt;ethnames&gt;. &lt;ethnames&gt; is a
           comma-separated list of physical (ethernet) interfaces.
           Bridge without parameters assumes bridge=br0:eth0

   <b>NFS</b>
       <b>root=</b>[<i>&lt;server-ip&gt;</i>:]<i>&lt;root-dir&gt;</i>[:<i>&lt;nfs-options&gt;</i>]
           mount nfs share from &lt;server-ip&gt;:/&lt;root-dir&gt;, if no server-ip
           is given, use dhcp next_server. If server-ip is an IPv6
           address it has to be put in brackets, e.g. [2001:DB8::1]. NFS
           options can be appended with the prefix ":" or "," and are
           separated by ",".

       <b>root=</b>nfs:[<i>&lt;server-ip&gt;</i>:]<i>&lt;root-dir&gt;</i>[:<i>&lt;nfs-options&gt;</i>],
       <b>root=</b>nfs4:[<i>&lt;server-ip&gt;</i>:]<i>&lt;root-dir&gt;</i>[:<i>&lt;nfs-options&gt;</i>],
       <b>root=</b><i>{dhcp|dhcp6}</i>
           netroot=dhcp alone directs initrd to look at the DHCP
           root-path where NFS options can be specified.

           <b>Example</b>.

                   root-path=&lt;server-ip&gt;:&lt;root-dir&gt;[,&lt;nfs-options&gt;]
                   root-path=nfs:&lt;server-ip&gt;:&lt;root-dir&gt;[,&lt;nfs-options&gt;]
                   root-path=nfs4:&lt;server-ip&gt;:&lt;root-dir&gt;[,&lt;nfs-options&gt;]

       <b>root=</b><i>/dev/nfs</i> nfsroot=[<i>&lt;server-ip&gt;</i>:]<i>&lt;root-dir&gt;</i>[:<i>&lt;nfs-options&gt;</i>]
           <i>Deprecated!</i>  kernel Documentation_/filesystems/nfsroot.txt_
           defines this method. This is supported by dracut, but not
           recommended.

       <b>rd.nfs.domain=</b><i>&lt;NFSv4 domain name&gt;</i>
           Set the NFSv4 domain name. Will override the settings in
           <i>/etc/idmap.conf</i>.

       <b>rd.net.dhcp.retry=</b><i>&lt;cnt&gt;</i>
           If this option is set, dracut will try to connect via dhcp
           &lt;cnt&gt; times before failing. Default is 1.

       <b>rd.net.timeout.dhcp=</b><i>&lt;arg&gt;</i>
           If this option is set, dhclient is called with "--timeout
           &lt;arg&gt;".

       <b>rd.net.timeout.iflink=</b><i>&lt;seconds&gt;</i>
           Wait &lt;seconds&gt; until link shows up. Default is 60 seconds.

       <b>rd.net.timeout.ifup=</b><i>&lt;seconds&gt;</i>
           Wait &lt;seconds&gt; until link has state "UP". Default is 20
           seconds.

       <b>rd.net.timeout.route=</b><i>&lt;seconds&gt;</i>
           Wait &lt;seconds&gt; until route shows up. Default is 20 seconds.

       <b>rd.net.timeout.ipv6dad=</b><i>&lt;seconds&gt;</i>
           Wait &lt;seconds&gt; until IPv6 DAD is finished. Default is 50
           seconds.

       <b>rd.net.timeout.ipv6auto=</b><i>&lt;seconds&gt;</i>
           Wait &lt;seconds&gt; until IPv6 automatic addresses are assigned.
           Default is 40 seconds.

       <b>rd.net.timeout.carrier=</b><i>&lt;seconds&gt;</i>
           Wait &lt;seconds&gt; until carrier is recognized. Default is 10
           seconds.

   <b>CIFS</b>
       <b>root=</b>cifs://[<i>&lt;username&gt;</i>[:<i>&lt;password&gt;</i>]@]<i>&lt;server-ip&gt;</i>:<i>&lt;root-dir&gt;</i>
           mount cifs share from &lt;server-ip&gt;:/&lt;root-dir&gt;, if no
           server-ip is given, use dhcp next_server. if server-ip is an
           IPv6 address it has to be put in brackets, e.g.
           [2001:DB8::1]. If a username or password are not specified as
           part of the root, then they must be passed on the command
           line through cifsuser/cifspass.

               <b>Warning</b>
               Passwords specified on the kernel command line are
               visible for all users via the file <i>/proc/cmdline</i> and via
               dmesg or can be sniffed on the network, when using DHCP
               with DHCP root-path.

       <b>cifsuser</b>=<i>&lt;username&gt;</i>
           Set the cifs username, if not specified as part of the root.

       <b>cifspass</b>=<i>&lt;password&gt;</i>
           Set the cifs password, if not specified as part of the root.

               <b>Warning</b>
               Passwords specified on the kernel command line are
               visible for all users via the file <i>/proc/cmdline</i> and via
               dmesg or can be sniffed on the network, when using DHCP
               with DHCP root-path.

   <b>iSCSI</b>
       <b>root=</b>iscsi:[<i>&lt;username&gt;</i>:<i>&lt;password&gt;</i>[:<i>&lt;reverse&gt;</i>:<i>&lt;password&gt;</i>]@][<i>&lt;servername&gt;</i>]:[<i>&lt;protocol&gt;</i>]:[<i>&lt;port&gt;</i>][:[<i>&lt;iscsi_iface_name&gt;</i>]:[<i>&lt;netdev_name&gt;</i>]]:[<i>&lt;LUN&gt;</i>]:<i>&lt;targetname&gt;</i>
           protocol defaults to "6", LUN defaults to "0". If the
           "servername" field is provided by BOOTP or DHCP, then that
           field is used in conjunction with other associated fields to
           contact the boot server in the Boot stage. However, if the
           "servername" field is not provided, then the "targetname"
           field is then used in the Discovery Service stage in
           conjunction with other associated fields. See <b>rfc4173</b>[1].

               <b>Warning</b>
               Passwords specified on the kernel command line are
               visible for all users via the file <i>/proc/cmdline</i> and via
               dmesg or can be sniffed on the network, when using DHCP
               with DHCP root-path.

           <b>Example</b>.

               root=iscsi:192.168.50.1::::iqn.2009-06.dracut:target0

           If servername is an IPv6 address, it has to be put in
           brackets:

           <b>Example</b>.

               root=iscsi:[2001:DB8::1]::::iqn.2009-06.dracut:target0

       <b>root=</b><i>???</i>
       <b>netroot=</b>iscsi:[<i>&lt;username&gt;</i>:<i>&lt;password&gt;</i>[:<i>&lt;reverse&gt;</i>:<i>&lt;password&gt;</i>]@][<i>&lt;servername&gt;</i>]:[<i>&lt;protocol&gt;</i>]:[<i>&lt;port&gt;</i>][:[<i>&lt;iscsi_iface_name&gt;</i>]:[<i>&lt;netdev_name&gt;</i>]]:[<i>&lt;LUN&gt;</i>]:<i>&lt;targetname&gt;</i>
       ...
           multiple netroot options allow setting up multiple iscsi
           disks:

           <b>Example</b>.

               root=UUID=12424547
               netroot=iscsi:192.168.50.1::::iqn.2009-06.dracut:target0
               netroot=iscsi:192.168.50.1::::iqn.2009-06.dracut:target1

           If servername is an IPv6 address, it has to be put in
           brackets:

           <b>Example</b>.

               netroot=iscsi:[2001:DB8::1]::::iqn.2009-06.dracut:target0

               <b>Warning</b>
               Passwords specified on the kernel command line are
               visible for all users via the file <i>/proc/cmdline</i> and via
               dmesg or can be sniffed on the network, when using DHCP
               with DHCP root-path. You may want to use
               rd.iscsi.firmware.

       <b>root=</b><i>???</i> <b>rd.iscsi.initiator=</b><i>&lt;initiator&gt;</i>
       <b>rd.iscsi.target.name=</b><i>&lt;target name&gt;</i> <b>rd.iscsi.target.ip=</b><i>&lt;target ip&gt;</i>
       <b>rd.iscsi.target.port=</b><i>&lt;target port&gt;</i> <b>rd.iscsi.target.group=</b><i>&lt;target</i>
       <i>group&gt;</i> <b>rd.iscsi.username=</b><i>&lt;username&gt;</i> <b>rd.iscsi.password=</b><i>&lt;password&gt;</i>
       <b>rd.iscsi.in.username=</b><i>&lt;in username&gt;</i> <b>rd.iscsi.in.password=</b><i>&lt;in</i>
       <i>password&gt;</i>
           manually specify all iscsistart parameter (see
           <b>iscsistart --help</b>)

               <b>Warning</b>
               Passwords specified on the kernel command line are
               visible for all users via the file <i>/proc/cmdline</i> and via
               dmesg or can be sniffed on the network, when using DHCP
               with DHCP root-path. You may want to use
               rd.iscsi.firmware.

       <b>root=</b><i>???</i> <b>netroot=</b>iscsi <b>rd.iscsi.firmware=1</b>
           will read the iscsi parameter from the BIOS firmware

       <b>rd.iscsi.login_retry_max=</b><i>&lt;num&gt;</i>
           maximum number of login retries

       <b>rd.iscsi.param=</b><i>&lt;param&gt;</i>
           &lt;param&gt; will be passed as "--param &lt;param&gt;" to iscsistart.
           This parameter can be specified multiple times.

           <b>Example</b>.

               "netroot=iscsi rd.iscsi.firmware=1 rd.iscsi.param=node.session.timeo.replacement_timeout=30"

           will result in

               iscsistart -b --param node.session.timeo.replacement_timeout=30

       <b>rd.iscsi.ibft rd.iscsi.ibft=1</b>: Turn on iBFT autoconfiguration for
       the interfaces

       <b>rd.iscsi.mp rd.iscsi.mp=1</b>: Configure all iBFT interfaces, not
       only used for booting (multipath)

       <b>rd.iscsi.waitnet=0</b>: Turn off waiting for all interfaces to be up
       before trying to login to the iSCSI targets.

       <b>rd.iscsi.testroute=0</b>: Turn off checking, if the route to the
       iSCSI target IP is possible before trying to login.

   <b>FCoE</b>
       <b>rd.fcoe=0</b>
           disable FCoE and lldpad

       <b>fcoe=</b><i>&lt;edd|interface|MAC&gt;</i>:<i>{dcb|nodcb}</i>:<i>{fabric|vn2vn}</i>
           Try to connect to a FCoE SAN through the NIC specified by
           <i>&lt;interface&gt;</i> or <i>&lt;MAC&gt;</i> or EDD settings. The second argument
           specifies if DCB should be used. The optional third argument
           specifies whether fabric or VN2VN mode should be used. This
           parameter can be specified multiple times.

               <b>Note</b>
               letters in the MAC-address must be lowercase!

   <b>NVMf</b>
       <b>rd.nonvmf</b>
           Disable NVMf

       <b>rd.nvmf.nonbft</b>
           Disable connecting to targets from the NVMe Boot Firmware
           Table. Without this parameter, NBFT connections will take
           precedence over <i>rd.nvmf.discover</i>.

       <b>rd.nvmf.nostatic</b>
           Disable connecting to targets that have been statically
           configured when the initramfs was built. Targets specified
           with rd.nvmf.discover on the kernel command line will still
           be tried.

       <b>rd.nvmf.hostnqn=</b><i>&lt;hostNQN&gt;</i>
           NVMe host NQN to use

       <b>rd.nvmf.hostid=</b><i>&lt;hostID&gt;</i>
           NVMe host id to use

       <b>rd.nvmf.discover=</b><i>{rdma|fc|tcp}</i>,<i>&lt;traddr&gt;</i>,[<i>&lt;host_traddr&gt;</i>],[<i>&lt;trsvcid&gt;</i>]
           Discover and connect to a NVMe-over-Fabric controller
           specified by <i>&lt;traddr&gt;</i> and the optionally <i>&lt;host_traddr&gt;</i> or
           <i>&lt;trsvcid&gt;</i>. The first argument specifies the transport to use;
           currently only <i>rdma</i>, <i>fc</i>, or <i>tcp</i> are supported. This parameter
           can be specified multiple times.

           <b>Examples</b>.

               rd.nvmf.discover=tcp,192.168.10.10,,4420
               rd.nvmf.discover=fc,nn-0x201700a05634f5bf:pn-0x201900a05634f5bf,nn-0x200000109b579ef3:pn-0x100000109b579ef3

       <b>rd.nvmf.discover=fc,auto</b>
           This special syntax determines that Fibre Channel
           autodiscovery is to be used rather than regular NVMe
           discovery. It takes precedence over all other
           <i>rd.nvmf.discover=</i> arguments.

   <b>NBD</b>
       <b>root=</b>???
       <b>netroot=</b>nbd:<i>&lt;server&gt;</i>:<i>&lt;port/exportname&gt;</i>[:<i>&lt;fstype&gt;</i>[:<i>&lt;mountopts&gt;</i>[:<i>&lt;nbdopts&gt;</i>]]]
           mount nbd share from &lt;server&gt;.

           NOTE: If "exportname" instead of "port" is given the standard
           port is used. Newer versions of nbd are only supported with
           "exportname".

       <b>root=/dev/root netroot=dhcp </b>with <b>dhcp</b>
       <b>root-path=</b>nbd:<i>&lt;server&gt;</i>:<i>&lt;port/exportname&gt;</i>[:<i>&lt;fstype&gt;</i>[:<i>&lt;mountopts&gt;</i>[:<i>&lt;nbdopts&gt;</i>]]]
           netroot=dhcp alone directs initrd to look at the DHCP
           root-path where NBD options can be specified. This syntax is
           only usable in cases where you are directly mounting the
           volume as the rootfs.

           NOTE: If "exportname" instead of "port" is given the standard
           port is used. Newer versions of nbd are only supported with
           "exportname".

   <b>VIRTIOFS</b>
       <b>root=</b>virtiofs:<i>&lt;mount-tag&gt;</i>
           mount virtiofs share using the tag &lt;mount-tag&gt;. The tag name
           is arbitrary and must match the tag given in the qemu <i>-device</i>
           command.

       <b>rootfstype=</b>virtiofs <b>root=</b><i>&lt;mount-tag&gt;</i>
           mount virtiofs share using the tag &lt;mount-tag&gt;. The tag name
           is arbitrary and must match the tag given in the qemu <i>-device</i>
           command.

       Both formats are supported by the <i>virtiofs</i> dracut module. See
       <b>https://gitlab.com/virtio-fs/virtiofsd </b>for more information.

       <b>Example</b>.

           root=virtiofs:host rw

   <b>DASD</b>
       <b>rd.dasd=</b>....
           same syntax as the kernel module parameter (s390 only)

   <b>ZFCP</b>
       <b>rd.zfcp=</b><i>&lt;zfcp adaptor device bus ID&gt;</i>,<i>&lt;WWPN&gt;</i>,<i>&lt;FCPLUN&gt;</i>
           rd.zfcp can be specified multiple times on the kernel command
           line.

       <b>rd.zfcp=</b><i>&lt;zfcp adaptor device bus ID&gt;</i>
           If NPIV is enabled and the <i>allow_lun_scan</i> parameter to the
           zfcp module is set to <i>Y</i> then the zfcp adaptor will be
           initiating a scan internally and the &lt;WWPN&gt; and &lt;FCPLUN&gt;
           parameters can be omitted.

           <b>Example</b>.

               rd.zfcp=0.0.4000,0x5005076300C213e9,0x5022000000000000
               rd.zfcp=0.0.4000

       <b>rd.zfcp.conf=0</b>
           ignore zfcp.conf included in the initramfs

   <b>ZNET</b>
       <b>rd.znet=</b><i>&lt;nettype&gt;</i>,<i>&lt;subchannels&gt;</i>,<i>&lt;options&gt;</i>
           The whole parameter is appended to /etc/ccw.conf, which is
           used on RHEL/Fedora with ccw_init, which is called from udev
           for certain devices on z-series. rd.znet can be specified
           multiple times on the kernel command line.

       <b>rd.znet_ifname=</b><i>&lt;ifname&gt;</i>:<i>&lt;subchannels&gt;</i>
           Assign network device name &lt;interface&gt; (i.e. "bootnet") to
           the NIC corresponds to the subchannels. This is useful when
           dracut’s default "ifname=" doesn’t work due to device having
           a changing MAC address.

           <b>Example</b>.

               rd.znet=qeth,0.0.0600,0.0.0601,0.0.0602,layer2=1,portname=foo
               rd.znet=ctc,0.0.0600,0.0.0601,protocol=bar

   <b>Booting live images</b>
       Dracut offers multiple options for live booted images:

       SquashFS with read-only filesystem image
           The system will boot with a read-only filesystem from the
           SquashFS and apply a writable Device-mapper snapshot or an
           OverlayFS overlay mount for the read-only base filesystem.
           This method ensures a relatively fast boot and lower RAM
           usage. Users <b>must be careful </b>to avoid writing too many blocks
           to a snapshot volume. Once the blocks of the snapshot overlay
           are exhausted, the root filesystem becomes read-only and may
           cause application failures. The snapshot overlay file is
           marked <i>Overflow</i>, and a difficult recovery is required to
           repair and enlarge the overlay offline. Non-persistent
           overlays are sparse files in RAM that only consume content
           space as required blocks are allocated. They default to an
           apparent size of 32 GiB in RAM. The size can be adjusted with
           the <b>rd.live.overlay.size= </b>kernel command line option.

           The filesystem structure is traditionally expected to be:

               squashfs.img          |  SquashFS from LiveCD .iso
                  !(mount)
                  /LiveOS
                      |- rootfs.img  |  Filesystem image to mount read-only
                           !(mount)
                           /bin      |  Live filesystem
                           /boot     |
                           /dev      |
                           ...       |

           For OverlayFS mount overlays, the filesystem structure may
           also be a direct compression of the root filesystem:

               squashfs.img          |  SquashFS from LiveCD .iso
                  !(mount)
                  /bin               |  Live filesystem
                  /boot              |
                  /dev               |
                  ...                |

           Dracut uses one of the overlay methods of live booting by
           default. No additional command line options are required
           other than <b>root=live:&lt;URL&gt; </b>to specify the location of your
           squashed filesystem.

           •   The compressed SquashFS image can be copied during boot
               to RAM at /run/initramfs/squashed.img by using the
               <b>rd.live.ram=1 </b>option.

           •   A device with a persistent overlay can be booted
               read-only by using the <b>rd.live.overlay.readonly </b>option on
               the kernel command line. This will either cause a
               temporary, writable overlay to be stacked over a
               read-only snapshot of the root filesystem or the
               OverlayFS mount will use an additional lower layer with
               the root filesystem.

       Uncompressed live filesystem image
           When the live system was installed with the <i>--skipcompress</i>
           option of the <i>livecd-iso-to-disk</i> installation script for Live
           USB devices, the root filesystem image, <i>rootfs.img</i>, is
           expanded on installation and no SquashFS is involved during
           boot.

           •   If <b>rd.live.ram=1 </b>is used in this situation, the full,
               uncompressed root filesystem is copied during boot to
               /run/initramfs/rootfs.img in the /run tmpfs.

           •   If <b>rd.live.overlay=none </b>is provided as a kernel command
               line option, a writable, linear Device-mapper target is
               created on boot with no overlay.

       Writable filesystem image
           The system will retrieve a compressed filesystem image,
           extract it to /run/initramfs/fsimg/rootfs.img, connect it to
           a loop device, create a writable, linear Device-mapper target
           at /dev/mapper/live-rw, and mount that as a writable volume
           at /. More RAM is required during boot but the live
           filesystem is easier to manage if it becomes full. Users can
           make a filesystem image of any size and that size will be
           maintained when the system boots. There is no persistence of
           root filesystem changes between boots with this option.

           The filesystem structure is expected to be:

               rootfs.tgz            |  Compressed tarball containing filesystem image
                  !(unpack)
                  /rootfs.img        |  Filesystem image at /run/initramfs/fsimg/
                     !(mount)
                     /bin            |  Live filesystem
                     /boot           |
                     /dev            |
                     ...             |

           To use this boot option, ensure that <b>rd.writable.fsimg=1 </b>is
           in your kernel command line and add the <b>root=live:&lt;URL&gt; </b>to
           specify the location of your compressed filesystem image
           tarball or SquashFS image.

       <b>rd.writable.fsimg=</b>1
           Enables writable filesystem support. The system will boot
           with a fully writable (but non-persistent) filesystem without
           snapshots <i>(see notes above about available live boot</i>
           <i>options)</i>. You can use the <b>rootflags </b>option to set mount
           options for the live filesystem as well <i>(see documentation</i>
           <i>about rootflags in the</i> <b>Standard </b><i>section above)</i>. This implies
           that the whole image is copied to RAM before the boot
           continues.

               <b>Note</b>
               There must be enough free RAM available to hold the
               complete image.
           This method is very suitable for diskless boots.

       <b>rd.minmem=</b><i>&lt;megabyte&gt;</i>
           Specify minimum free RAM in MB after copying a live disk
           image into memory. The default is 1024.

           This parameter only applies together with the parameters
           rd.writable.fsimg or rd.live.ram.

       <b>root=</b>live:<i>&lt;url&gt;</i>
           Boots a live image retrieved from <i>&lt;url&gt;</i>. Requires the dracut
           <i>livenet</i> module. Valid handlers: <i>http, https, ftp, torrent,</i>
           <i>tftp</i>.

           <b>Examples</b>.

               root=live:http://example.com/liveboot.img
               root=live:ftp://ftp.example.com/liveboot.img
               root=live:torrent://example.com/liveboot.img.torrent

       <b>rd.live.debug=</b>1
           Enables debug output from the live boot process.

       <b>rd.live.dir=</b><i>&lt;path&gt;</i>
           Specifies the directory within the boot device where the
           squashfs.img or rootfs.img can be found. By default, this is
           /LiveOS.

       <b>rd.live.squashimg=</b><i>&lt;filename of SquashFS image&gt;</i>
           Specifies the filename for a SquashFS image of the root
           filesystem. By default, this is <i>squashfs.img</i>.

       <b>rd.live.ram=</b>1
           Copy the complete image to RAM and use this for booting. This
           is useful when the image resides on, e.g., a DVD which needs
           to be ejected later on.

       <b>rd.live.overlay={</b><i>&lt;devspec&gt;</i>[:<i>{&lt;pathspec&gt;|auto}</i>]|<i>none</i>}
           Manage the usage of a permanent overlay.

           •   <i>&lt;devspec&gt;</i> specifies the path to a device with a mountable
               filesystem.

           •   <i>&lt;pathspec&gt;</i> is the path to a file within that filesystem,
               which shall be used to persist the changes made to the
               device specified by the <b>root=live:</b><i>&lt;url&gt;</i> option.

               The default <i>pathspec</i>, when <i>auto</i> or no <i>:&lt;pathspec&gt;</i> is
               given, is /&lt;rd.live.dir&gt;/overlay-&lt;label&gt;-&lt;uuid&gt;, where
               <i>&lt;label&gt;</i> is the device LABEL, and <i>&lt;uuid&gt;</i> is the device
               UUID. * <i>none</i> (the word itself) specifies that no overlay
               will be used, such as when an uncompressed, writable live
               root filesystem is available.

               If a persistent overlay <i>is detected</i> at the standard
               LiveOS path, the overlay &amp; overlay type detected, whether
               Device-mapper or OverlayFS, will be used.

           <b>Examples</b>.

               rd.live.overlay=/dev/sdb1:persistent-overlay.img
               rd.live.overlay=UUID=99440c1f-8daa-41bf-b965-b7240a8996f4

       <b>rd.live.overlay.cowfs=</b><i>[btrfs|ext4|xfs]</i>
           Specifies the filesystem to use when formatting the overlay
           partition. The default is ext4.

       <b>rd.live.overlay.size=</b><i>&lt;size_MiB&gt;</i>
           Specifies a non-persistent Device-mapper overlay size in MiB.
           The default is <i>32768</i>.

       <b>rd.live.overlay.readonly=</b>1
           This is used to boot with a normally read-write persistent
           overlay in a read-only mode. With this option, either an
           additional, non-persistent, writable snapshot overlay will be
           stacked over a read-only snapshot, /dev/mapper/live-ro, of
           the base filesystem with the persistent overlay, or a
           read-only loop device, in the case of a writable <i>rootfs.img</i>,
           or an OverlayFS mount will use the persistent overlay
           directory linked at /run/overlayfs-r as an additional lower
           layer along with the base root filesystem and apply a
           transient, writable upper directory overlay, in order to
           complete the booted root filesystem.

       <b>rd.live.overlay.reset=</b>1
           Specifies that a persistent overlay should be reset on boot.
           All previous root filesystem changes are vacated by this
           action.

       <b>rd.live.overlay.thin=</b>1
           Enables the usage of thin snapshots instead of classic dm
           snapshots. The advantage of thin snapshots is that they
           support discards, and will free blocks that are not claimed
           by the filesystem. In this use case, this means that memory
           is given back to the kernel when the filesystem does not
           claim it anymore.

       <b>rd.live.overlay.overlayfs=</b>1
           Enables the use of the <b>OverlayFS </b>kernel module, if available,
           to provide a copy-on-write union directory for the root
           filesystem. OverlayFS overlays are directories of the files
           that have changed on the read-only base (lower) filesystem.
           The root filesystem is provided through a special overlay
           type mount that merges the lower and upper directories. If an
           OverlayFS upper directory is not present on the boot device,
           a tmpfs directory will be created at /run/overlayfs to
           provide temporary storage. Persistent storage can be provided
           on vfat or msdos formatted devices by supplying the OverlayFS
           upper directory within an embedded filesystem that supports
           the creation of trusted.* extended attributes and provides a
           valid d_type in readdir responses, such as with ext4 and xfs.
           On non-vfat-formatted devices, a persistent OverlayFS overlay
           can extend the available root filesystem storage up to the
           capacity of the LiveOS disk device.

           If a persistent overlay is detected at the standard LiveOS
           path, the overlay &amp; overlay type detected, whether OverlayFS
           or Device-mapper, will be used.

           The <b>rd.live.overlay.readonly </b>option, which allows a
           persistent overlayfs to be mounted read-only through a higher
           level transient overlay directory, has been implemented
           through the multiple lower layers feature of OverlayFS.

   <b>ZIPL</b>
       <b>rd.zipl=</b><i>&lt;path to blockdevice&gt;</i>
           Update the dracut commandline with the values found in the
           <i>dracut-cmdline.conf</i> file on the given device. The values are
           merged into the existing commandline values and the udev
           events are regenerated.

           <b>Example</b>.

               rd.zipl=UUID=0fb28157-99e3-4395-adef-da3f7d44835a

   <b>CIO_IGNORE</b>
       <b>rd.cio_accept=</b><i>&lt;device-ids&gt;</i>
           Remove the devices listed in &lt;device-ids&gt; from the default
           cio_ignore kernel command-line settings. &lt;device-ids&gt; is a
           list of comma-separated CCW device ids. The default for this
           value is taken from the <i>/boot/zipl/active_devices.txt</i> file.

           <b>Example</b>.

               rd.cio_accept=0.0.0180,0.0.0800,0.0.0801,0.0.0802

   <b>Plymouth Boot Splash</b>
       <b>plymouth.enable=0</b>
           disable the plymouth bootsplash completely.

       <b>rd.plymouth=0</b>
           disable the plymouth bootsplash only for the initramfs.

   <b>Kernel keys</b>
       <b>masterkey=</b><i>&lt;kernel master key path name&gt;</i>
           Set the path name of the kernel master key.

           <b>Example</b>.

               masterkey=/etc/keys/kmk-trusted.blob

       <b>masterkeytype=</b><i>&lt;kernel master key type&gt;</i>
           Set the type of the kernel master key.

           <b>Example</b>.

               masterkeytype=trusted

       <b>evmkey=</b><i>&lt;EVM HMAC key path name&gt;</i>
           Set the path name of the EVM HMAC key.

           <b>Example</b>.

               evmkey=/etc/keys/evm-trusted.blob

       <b>evmx509=</b><i>&lt;EVM X.509 cert path name&gt;</i>
           Set the path name of the EVM X.509 certificate.

           <b>Example</b>.

               evmx509=/etc/keys/x509_evm.der

       <b>ecryptfskey=</b><i>&lt;eCryptfs key path name&gt;</i>
           Set the path name of the eCryptfs key.

           <b>Example</b>.

               ecryptfskey=/etc/keys/ecryptfs-trusted.blob

   <b>Deprecated, renamed Options</b>
       Here is a list of options, which were used in dracut prior to
       version 008, and their new replacement.

       rdbreak
           rd.break

       rd.ccw
           rd.znet

       rd_CCW
           rd.znet

       rd_DASD_MOD
           rd.dasd

       rd_DASD
           rd.dasd

       rdinitdebug rdnetdebug
           rd.debug

       rd_NO_DM
           rd.dm=0

       rd_DM_UUID
           rd.dm.uuid

       rdblacklist
           rd.driver.blacklist

       rdinsmodpost
           rd.driver.post

       rdloaddriver
           rd.driver.pre

       rd_NO_FSTAB
           rd.fstab=0

       rdinfo
           rd.info

       check
           rd.live.check

       rdlivedebug
           rd.live.debug

       live_dir
           rd.live.dir

       liveimg
           rd.live.image

       overlay
           rd.live.overlay

       readonly_overlay
           rd.live.overlay.readonly

       reset_overlay
           rd.live.overlay.reset

       live_ram
           rd.live.ram

       rd_NO_CRYPTTAB
           rd.luks.crypttab=0

       rd_LUKS_KEYDEV_UUID
           rd.luks.keydev.uuid

       rd_LUKS_KEYPATH
           rd.luks.keypath

       rd_NO_LUKS
           rd.luks=0

       rd_LUKS_UUID
           rd.luks.uuid

       rd_NO_LVMCONF
           rd.lvm.conf

       rd_LVM_LV
           rd.lvm.lv

       rd_NO_LVM
           rd.lvm=0

       rd_LVM_VG
           rd.lvm.vg

       rd_NO_MDADMCONF
           rd.md.conf=0

       rd_NO_MDIMSM
           rd.md.imsm=0

       rd_NO_MD
           rd.md=0

       rd_MD_UUID
           rd.md.uuid

       rd_NO_MULTIPATH: rd.multipath=0

       rd_NFS_DOMAIN
           rd.nfs.domain

       iscsi_initiator
           rd.iscsi.initiator

       iscsi_target_name
           rd.iscsi.target.name

       iscsi_target_ip
           rd.iscsi.target.ip

       iscsi_target_port
           rd.iscsi.target.port

       iscsi_target_group
           rd.iscsi.target.group

       iscsi_username
           rd.iscsi.username

       iscsi_password
           rd.iscsi.password

       iscsi_in_username
           rd.iscsi.in.username

       iscsi_in_password
           rd.iscsi.in.password

       iscsi_firmware
           rd.iscsi.firmware=0

       rd_NO_PLYMOUTH
           rd.plymouth=0

       rd_retry
           rd.retry

       rdshell
           rd.shell

       rd_NO_SPLASH
           rd.splash

       rdudevdebug
           rd.udev.debug

       rdudevinfo
           rd.udev.info

       rd_NO_ZFCPCONF
           rd.zfcp.conf=0

       rd_ZFCP
           rd.zfcp

       rd_ZNET
           rd.znet

       KEYMAP
           vconsole.keymap

       KEYTABLE
           vconsole.keymap

       SYSFONT
           vconsole.font

       CONTRANS
           vconsole.font.map

       UNIMAP
           vconsole.font.unimap

       UNICODE
           vconsole.unicode

       EXT_KEYMAP
           vconsole.keymap.ext

   <b>Configuration in the Initramfs</b>
       <i>/etc/conf.d/</i>
           Any files found in <i>/etc/conf.d/</i> will be sourced in the
           initramfs to set initial values. Command line options will
           override these values set in the configuration files.

       <i>/etc/cmdline</i>
           Can contain additional command line options. Deprecated,
           better use /etc/cmdline.d/*.conf.

       <i>/etc/cmdline.d/*.conf</i>
           Can contain additional command line options.
</pre> <h2>
AUTHOR </h2>
<pre>
       Harald Hoyer
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man8/dracut.8.html">dracut(8)</a> <a href="../man5/dracut.conf.5.html">dracut.conf(5)</a>
</pre> <h2>
NOTES </h2>
<pre>
        1. rfc4173
           <a href="http://tools.ietf.org/html/rfc4173#section-5">http://tools.ietf.org/html/rfc4173#section-5</a>
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>dracut</i> (event driven initramfs
       infrastructure) project.  Information about the project can be
       found at ⟨<a href="https://dracut.wiki.kernel.org/index.php/Main_Page">https://dracut.wiki.kernel.org/index.php/Main_Page</a>⟩.
       If you have a bug report for this manual page, send it to
       initramfs@vger.kernel.org.  This page was obtained from the
       project's upstream Git repository
       ⟨<a href="https://github.com/dracutdevs/dracut.git">https://github.com/dracutdevs/dracut.git</a>⟩ on 2024-06-14.  (At
       that time, the date of the most recent commit that was found in
       the repository was 2024-03-21.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">dracut 059-204-g6acfecae       09/13/2023              <i>DRACUT.CMDLINE</i>(7)</span>
</pre>  <p>Pages that refer to this page: <a href="../man5/dracut.conf.5.html">dracut.conf(5)</a>, <a href="../man8/dracut.8.html">dracut(8)</a>, <a href="../man8/systemd-network-generator.service.8.html">systemd-network-generator.service(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man7/dracut.cmdline.7.html" class="_attribution-link">https://man7.org/linux/man-pages/man7/dracut.cmdline.7.html</a>
  </p>
</div>
