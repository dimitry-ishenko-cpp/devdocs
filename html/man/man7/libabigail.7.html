<h1>libabigail(7) — Linux manual page</h1>   <pre>
<span class="headline"><i>LIBABIGAIL</i>(7)                  Libabigail                  <i>LIBABIGAIL</i>(7)</span>
</pre> <h2>
NAME </h2>
<pre>
       libabigail - Library to analyze and compare ELF ABIs
</pre> <h2>
OVERVIEW OF THE ABIGAIL FRAMEWORK </h2>
<pre>
       <b>ABIGAIL </b>stands for the Application Binary Interface Generic
       Analysis and Instrumentation Library.

       It's a framework which aims at helping developers and software
       distributors to spot some ABI-related issues like interface
       incompatibility in <i>ELF</i> shared libraries by performing a static
       analysis of the <i>ELF</i> binaries at hand.

       The type of interface incompatibilities that <b>Abigail </b>focuses on
       is related to changes on the exported ELF functions and variables
       symbols, as well as layout and size changes of data types of the
       functions and variables exported by shared libraries.

       In other words, if the return type of a function exported by a
       shared library changes in an incompatible way from one version of
       a given shared library to another, we want <b>Abigail </b>to help people
       catch that.

       In more concrete terms, the Abigail framwork provides a shared
       library named <b>libabigail </b>which exposes an API to parse a shared
       library in <i>ELF</i> format (accompanied with its associated debug
       information in <i>DWARF</i> format) build an internal representation of
       all the functions and variables it exports, along with their
       types.  <b>Libabigail </b>also builds an internal representation of the
       <i>ELF symbols</i> of these functions and variables.  That information
       about these exported functions and variables is roughly what we
       consider as being the ABI of the shared library, at least, in the
       scope of <b>Libabigail</b>.

       Aside of this internal representation, <b>libabigail </b>provides
       facilities to perform deep comparisons of two ABIs.  That is, it
       can compare the types of two sets of functions or variables and
       represents the result in a way that allows it to emit textual
       reports about the differences.

       This allows us to write tools like <i>abidiff</i> that can compare the
       ABI of two shared libraries and represent the result in a
       meaningful enough way to help us spot ABI incompatibilities.
       There are several <i>other tools</i> that are built using the <b>Abigail</b>
       framwork.
</pre> <h2>
TOOLS </h2>
<pre>
   <b>Overview</b>
       The upstream code repository of Libabigail contains several tools
       written using the library.  They are maintained and released as
       part of the project.  All tools come with a bash-completion
       script.

   <b>Tools manuals</b>
   <b>abidiff</b>
       abidiff compares the Application Binary Interfaces (ABI) of two
       shared libraries in <i>ELF</i> format.  It emits a meaningful report
       describing the differences between the two ABIs.

       This tool can also compare the textual representations of the ABI
       of two ELF binaries (as emitted by <b>abidw</b>) or an ELF binary
       against a textual representation of another ELF binary.

       For a comprehensive ABI change report between two input shared
       libraries that includes changes about function and variable
       sub-types, <b>abidiff </b>uses by default, debug information in <i>DWARF</i>
       format, if present, otherwise it compares interfaces using debug
       information in <i>CTF</i> or <i>BTF</i> formats, if present. Finally, if no
       debug info in these formats is found, it only considers <i>ELF</i>
       symbols and report about their addition or removal.

       This tool uses the libabigail library to analyze the binary as
       well as its associated debug information.  Here is its general
       mode of operation.

       When instructed to do so, a binary and its associated debug
       information is read and analyzed.  To that effect, libabigail
       analyzes by default the descriptions of the types reachable by
       the interfaces (functions and variables) that are visible outside
       of their translation unit.  Once that analysis is done, an
       Application Binary Interface Corpus is constructed by only
       considering the subset of types reachable from interfaces
       associated to <i>ELF</i> symbols that are defined and exported by the
       binary.  It's that final ABI corpus which libabigail considers as
       representing the ABI of the analyzed binary.

       Libabigail then has capabilities to generate textual
       representations of ABI Corpora, compare them, analyze their
       changes and report about them.

   <b>Invocation</b>
          abidiff [options] &lt;first-shared-library&gt; &lt;second-shared-library&gt;

   <b>Environment</b>
       abidiff loads two default <i>suppression specifications files</i>,
       merges their content and use it to filter out ABI change reports
       that might be considered as false positives to users.

       • Default system-wide suppression specification file

         It's located by the optional environment variable
         LIBABIGAIL_DEFAULT_SYSTEM_SUPPRESSION_FILE.  If that
         environment variable is not set, then abidiff tries to load the
         suppression file
         $libdir/libabigail/libabigail-default.abignore.  If that file
         is not present, then no default system-wide suppression
         specification file is loaded.

       • Default user suppression specification file.

         It's located by the optional environment
         LIBABIGAIL_DEFAULT_USER_SUPPRESSION_FILE.  If that environment
         variable is not set, then abidiff tries to load the suppression
         file $HOME/.abignore.  If that file is not present, then no
         default user suppression specification is loaded.

   <b>Options</b>
          • <b>--help | -h</b>

            Display a short help about the command and exit.

          • <b>--debug-self-comparison</b>

            In this mode, error messages are emitted for types which
            fail type canonicalization, in some circumstances, when
            comparing a binary against itself.

            When comparing a binary against itself, canonical types of
            the second binary should be equal (as much as possible) to
            canonical types of the first binary.  When some
            discrepancies are detected in this mode, an abort signal is
            emitted and execution is halted.  This option should be used
            while executing the tool in a debugger, for troubleshooting
            purposes.

            This is an optional debugging and sanity check option.  To
            enable it the libabigail package needs to be configured with
            the --enable-debug-self-comparison configure option.

          • <b>--debug-tc</b>

            In this mode, the process of type canonicalization is put
            under heavy scrutiny.  Basically, during type
            canonicalization, each type comparison is performed twice:
            once in a structural mode (comparing every sub-type
            member-wise), and once using canonical comparison.  The two
            comparisons should yield the same result.  Otherwise, an
            abort signal is emitted and the process can be debugged to
            understand why the two kinds of comparison yield different
            results.

            This is an optional debugging and sanity check option.  To
            enable it the libabigail package needs to be configured with
            the --enable-debug-type-canonicalization configure option.

          • <b>--version | -v</b>

            Display the version of the program and exit.

          • <b>--debug-info-dir1 | --d1 </b>&lt;<i>di-path1</i>&gt;

            For cases where the debug information for
            <i>first-shared-library</i> is split out into a separate file,
            tells <b>abidiff </b>where to find that separate debug information
            file.

            Note that <i>di-path</i> must point to the root directory under
            which the debug information is arranged in a tree-like
            manner.  Under Red Hat based systems, that directory is
            usually <b>&lt;root&gt;/usr/lib/debug</b>.

            This option can be provided several times with different
            root directories.  In that case, <b>abidiff </b>will potentially
            look into all those root directories to find the split debug
            info for <i>first-shared-library</i>.

            Note also that this option is not mandatory for split debug
            information installed by your system's package manager
            because then <b>abidiff </b>knows where to find it.

          • <b>--debug-info-dir2 | --d2 </b>&lt;<i>di-path2</i>&gt;

            Like <b>--debug-info-dir1</b>, this options tells <b>abidiff </b>where to
            find the split debug information for the
            <i>second-shared-library</i> file.

            This option can be provided several times with different
            root directories.  In that case, <b>abidiff </b>will potentially
            look into all those root directories to find the split debug
            info for <i>second-shared-library</i>.

          • <b>--headers-dir1 | --hd1 </b>&lt;headers-directory-path-1&gt;

            Specifies where to find the public headers of the first
            shared library (or binary in general) that the tool has to
            consider.  The tool will thus filter out ABI changes on
            types that are not defined in public headers.

            Note that several public header directories can be specified
            for the first shared library.  In that case the
            <b>--headers-dir1 </b>option should be present several times on the
            command line, like in the following example:

                $ abidiff --headers-dir1 /some/path       \
                          --headers-dir1 /some/other/path \
                          binary-version-1 binary-version-2

          • <b>--header-file1 | --hf1 </b>&lt;header-file-path-1&gt;

            Specifies where to find one public header of the first
            shared library that the tool has to consider.  The tool will
            thus filter out ABI changes on types that are not defined in
            public headers.

          • <b>--headers-dir2 | --hd2 </b>&lt;headers-directory-path-2&gt;

            Specifies where to find the public headers of the second
            shared library that the tool has to consider.  The tool will
            thus filter out ABI changes on types that are not defined in
            public headers.

            Note that several public header directories can be specified
            for the second shared library.  In that case the
            <b>--headers-dir2 </b>option should be present several times like
            in the following example:

                $ abidiff --headers-dir2 /some/path       \
                          --headers-dir2 /some/other/path \
                          binary-version-1 binary-version-2

          • <b>--header-file2 | --hf2 </b>&lt;header-file-path-2&gt;

            Specifies where to find one public header of the second
            shared library that the tool has to consider.  The tool will
            thus filter out ABI changes on types that are not defined in
            public headers.

          • <b>--add-binaries1 </b>&lt;<i>bin1,bin2,bin3,..</i>&gt;

            For each of the comma-separated binaries given in argument
            to this option, if the binary is found in the directory
            specified by the <b>--added-binaries-dir1 </b>option, then <b>abidiff</b>
            loads the ABI corpus of the binary and adds it to a set of
            corpora (called an ABI Corpus Group) that includes the first
            argument of <b>abidiff</b>.

            That ABI corpus group is then compared against the second
            corpus group given in argument to <b>abidiff</b>.

          • <b>--add-binaries2 </b>&lt;<i>bin1,bin2,bin3,..</i>&gt;

            For each of the comma-separated binaries given in argument
            to this option, if the binary is found in the directory
            specified by the <b>--added-binaries-dir2 </b>option, then <b>abidiff</b>
            loads the ABI corpus of the binary and adds it to a set of
            corpora(called an ABI Corpus Group) that includes the second
            argument of <b>abidiff</b>.

            That ABI corpus group is then compared against the first
            corpus group given in argument to <b>abidiff</b>.

          • <b>--follow-dependencies | --fdeps</b>

            For each dependency of the first argument of <b>abidiff</b>, if
            it's found in the directory specified by the
            <b>--added-binaries-dir1 </b>option, then construct an ABI corpus
            out of the dependency, add it to a set of corpora (called an
            ABI Corpus Group) that includes the first argument of
            <b>abidiff</b>.

            Similarly, for each dependency of the second argument of
            <b>abidiff</b>, if it's found in the directory specified by the
            <b>--added-binaries-dir2 </b>option, then construct an ABI corpus
            out of the dependency, add it to an ABI corpus group that
            includes the second argument of <b>abidiff</b>.

            These two ABI corpus groups are then compared against each
            other.

            Said otherwise, this makes <b>abidiff </b>compare the set of its
            first input and its dependencies against the set of its
            second input and its dependencies.

          • <b>list-dependencies | --ldeps</b>

            This option lists all the dependencies of the input
            arguments of <b>abidiff </b>that are found in the directories
            specified by the options <b>--added-binaries-dir1 </b>and
            <b>--added-binaries-dir2</b>

          • <b>--added-binaries-dir1 | --abd1 </b>&lt;added-binaries-directory-1&gt;

            This option is to be used in conjunction with the
            <b>--add-binaries1</b>, <b>--follow-dependencies </b>and
            <b>--list-dependencies </b>options.  Binaries referred to by these
            options, if found in the directory
            <i>added-binaries-directory-1</i>, are loaded as ABI corpus and are
            added to the first ABI corpus group that is to be used in
            the comparison.

          • <b>--added-binaries-dir2 | --abd2 </b>&lt;added-binaries-directory-2&gt;

            This option is to be used in conjunction with the
            <b>--add-binaries2</b>, <b>--follow-dependencies </b>and
            <b>--list-dependencies </b>options.  Binaries referred to by these
            options, if found in the directory
            <i>added-binaries-directory-2</i>, are loaded as ABI corpus and are
            added to the second ABI corpus group to be used in the
            comparison.

          • <b>--no-linux-kernel-mode</b>

            Without this option, if abidiff detects that the binaries it
            is looking at are Linux Kernel binaries (either vmlinux or
            modules) then it only considers functions and variables
            which ELF symbols are listed in the __ksymtab and
            __ksymtab_gpl sections.

            With this option, abidiff considers the binary as a
            non-special ELF binary.  It thus considers functions and
            variables which are defined and exported in the ELF sense.

          • <b>--kmi-whitelist | -kaw </b>&lt;<i>path-to-whitelist</i>&gt;

            When analyzing a Linux kernel binary, this option points to
            the white list of names of ELF symbols of functions and
            variables which ABI must be considered.  That white list is
            called a "Kernel Module Interface white list".  This is
            because for the Kernel, we don't talk about <b>ABI</b>; we rather
            talk about the interface between the Kernel and its module.
            Hence the term <b>KMI </b>rather than <b>ABI</b>.

            Any other function or variable which ELF symbol are not
            present in that white list will not be considered by this
            tool.

            If this option is not provided -- thus if no white list is
            provided -- then the entire KMI, that is, the set of all
            publicly defined and exported functions and global variables
            by the Linux Kernel binaries, is considered.

          • <b>--drop-private-types</b>

            This option is to be used with the <b>--headers-dir1</b>,
            <b>header-file1</b>, <b>header-file2 </b>and <b>--headers-dir2 </b>options.  With
            this option, types that are <i>NOT</i> defined in the headers are
            entirely dropped from the internal representation build by
            Libabigail to represent the ABI.  They thus don't have to be
            filtered out from the final ABI change report because they
            are not even present in Libabigail's representation.

            Without this option however, those private types are kept in
            the internal representation and later filtered out from the
            report.

            This options thus potentially makes Libabigail consume less
            memory.  It's meant to be mainly used to optimize the memory
            consumption of the tool on binaries with a lot of publicly
            defined and exported types.

          • <b>--exported-interfaces-only</b>

            By default, when looking at the debug information
            accompanying a binary, this tool analyzes the descriptions
            of the types reachable by the interfaces (functions and
            variables) that are visible outside of their translation
            unit.  Once that analysis is done, an ABI corpus is
            constructed by only considering the subset of types
            reachable from interfaces associated to <i>ELF</i> symbols that are
            defined and exported by the binary.  It's those final ABI
            Corpora that are compared by this tool.

            The problem with that approach however is that analyzing all
            the interfaces that are visible from outside their
            translation unit can amount to a lot of data, especially
            when those binaries are applications, as opposed to shared
            libraries.  One example of such applications is the <i>Linux</i>
            <i>Kernel</i>.  Analyzing massive ABI corpora like these can be
            extremely slow.

            To mitigate that performance issue, this option allows
            libabigail to only analyze types that are reachable from
            interfaces associated with defined and exported <i>ELF</i> symbols.

            Note that this option is turned on by default when analyzing
            the <i>Linux Kernel</i>.  Otherwise, it's turned off by default.

          • <b>--allow-non-exported-interfaces</b>

            When looking at the debug information accompanying a binary,
            this tool analyzes the descriptions of the types reachable
            by the interfaces (functions and variables) that are visible
            outside of their translation unit.  Once that analysis is
            done, an ABI corpus is constructed by only considering the
            subset of types reachable from interfaces associated to <i>ELF</i>
            symbols that are defined and exported by the binary.  It's
            those final ABI Corpora that are compared by this tool.

            The problem with that approach however is that analyzing all
            the interfaces that are visible from outside their
            translation unit can amount to a lot of data, especially
            when those binaries are applications, as opposed to shared
            libraries.  One example of such applications is the <i>Linux</i>
            <i>Kernel</i>.  Analyzing massive ABI Corpora like these can be
            extremely slow.

            In the presence of an "average sized" binary however one can
            afford having libabigail analyze all interfaces that are
            visible outside of their translation unit, using this
            option.

            Note that this option is turned on by default, unless we are
            in the presence of the <i>Linux Kernel</i>.

          • <b>--stat</b>

            Rather than displaying the detailed ABI differences between
            <i>first-shared-library</i> and <i>second-shared-library</i>, just display
            some summary statistics about these differences.

          • <b>--symtabs</b>

            Only display the symbol tables of the <i>first-shared-library</i>
            and <i>second-shared-library</i>.

          • <b>--deleted-fns</b>

            In the resulting report about the differences between
            <i>first-shared-library</i> and <i>second-shared-library</i>, only display
            the globally defined functions that got deleted from
            <i>first-shared-library</i>.

          • <b>--changed-fns</b>

            In the resulting report about the differences between
            <i>first-shared-library</i> and <i>second-shared-library</i>, only display
            the changes in sub-types of the global functions defined in
            <i>first-shared-library</i>.

          • <b>--added-fns</b>

            In the resulting report about the differences between
            <i>first-shared-library</i> and <i>second-shared-library</i>, only display
            the globally defined functions that were added to
            <i>second-shared-library</i>.

          • <b>--deleted-vars</b>

            In the resulting report about the differences between
            <i>first-shared-library</i> and <i>second-shared-library</i>, only display
            the globally defined variables that were deleted from
            <i>first-shared-library</i>.

          • <b>--changed-vars</b>

            In the resulting report about the differences between
            <i>first-shared-library</i> and <i>second-shared-library</i>, only display
            the changes in the sub-types of the global variables defined
            in <i>first-shared-library</i>

          • <b>--added-vars</b>

            In the resulting report about the differences between
            <i>first-shared-library</i> and <i>second-shared-library</i>, only display
            the global variables that were added (defined) to
            <i>second-shared-library</i>.

          • <b>--non-reachable-types|-t</b>

            Analyze and emit change reports for all the types of the
            binary, including those that are not reachable from global
            functions and variables.

            This option might incur some serious performance degradation
            as the number of types analyzed can be huge.  However, if
            paired with the <b>--headers-dir{1,2} </b>and/or <b>header-file{1,2}</b>
            options, the additional non-reachable types analyzed are
            restricted to those defined in public headers files, thus
            hopefully making the performance hit acceptable.

            Also, using this option alongside suppression specifications
            (by also using the <b>--suppressions </b>option) might help keep
            the number of analyzed types (and the potential performance
            degradation) in control.

            Note that without this option, only types that are reachable
            from global functions and variables are analyzed, so the
            tool detects and reports changes on these reachable types
            only.

          • <b>--no-added-syms</b>

            In the resulting report about the differences between
            <i>first-shared-library</i> and <i>second-shared-library</i>, do not
            display added functions or variables.  Do not display added
            functions or variables ELF symbols either.  All other kinds
            of changes are displayed unless they are explicitely
            forbidden by other options on the command line.

          • <b>--no-linkage-name</b>

            In the resulting report, do not display the linkage names of
            the added, removed, or changed functions or variables.

          • <b>--no-show-locs</b>
              Do not show information about where in the <i>second shared</i>
              <i>library</i> the respective type was changed.

          • <b>--show-bytes</b>

            Show sizes and offsets in bytes, not bits.  By default,
            sizes and offsets are shown in bits.

          • <b>--show-bits</b>

            Show sizes and offsets in bits, not bytes.  This option is
            activated by default.

          • <b>--show-hex</b>

            Show sizes and offsets in hexadecimal base.

          • <b>--show-dec</b>

            Show sizes and offsets in decimal base.  This option is
            activated by default.

          • <b>--ignore-soname</b>

            Ignore differences in the SONAME when doing a comparison

          • <b>--no-show-relative-offset-changes</b>

            Without this option, when the offset of a data member
            changes, the change report not only mentions the older and
            newer offset, but it also mentions by how many bits the data
            member changes.  With this option, the latter is not shown.

          • <b>--no-unreferenced-symbols</b>

            In the resulting report, do not display change information
            about function and variable symbols that are not referenced
            by any debug information.  Note that for these symbols not
            referenced by any debug information, the change information
            displayed is either added or removed symbols.

          • <b>--no-default-suppression</b>

            Do not load the <i>default suppression specification files</i>.

          • <b>--suppressions | --suppr </b>&lt;<i>path-to-suppressions</i>&gt;

            Use a <i>suppression specification</i> file located at
            <i>path-to-suppressions</i>.  Note that this option can appear
            multiple times on the command line.  In that case, all of
            the provided suppression specification files are taken into
            account.

            Please note that, by default, if this option is not
            provided, then the <i>default suppression specification files</i>
            are loaded .

          • <b>--drop </b>&lt;<i>regex</i>&gt;

            When reading the <i>first-shared-library</i> and
            <i>second-shared-library</i> ELF input files, drop the globally
            defined functions and variables which name match the regular
            expression <i>regex</i>.  As a result, no change involving these
            functions or variables will be emitted in the diff report.

          • <b>--drop-fn </b>&lt;<i>regex</i>&gt;

            When reading the <i>first-shared-library</i> and
            <i>second-shared-library</i> ELF input files, drop the globally
            defined functions which name match the regular expression
            <i>regex</i>.  As a result, no change involving these functions
            will be emitted in the diff report.

          • <b>--drop-var </b>&lt;<i>regex</i>&gt;

            When reading the <i>first-shared-library</i> and
            <i>second-shared-library</i> ELF input files, drop the globally
            defined variables matching a the regular expression <i>regex</i>.

          • <b>--keep </b>&lt;<i>regex</i>&gt;

            When reading the <i>first-shared-library</i> and
            <i>second-shared-library</i> ELF input files, keep the globally
            defined functions and variables which names match the
            regular expression <i>regex</i>.  All other functions and variables
            are dropped on the floor and will thus not appear in the
            resulting diff report.

          • <b>--keep-fn </b>&lt;<i>regex</i>&gt;

            When reading the <i>first-shared-library</i> and
            <i>second-shared-library</i> ELF input files, keep the globally
            defined functions which name match the regular expression
            <i>regex</i>.  All other functions are dropped on the floor and
            will thus not appear in the resulting diff report.

          • <b>--keep-var </b>&lt;<i>regex</i>&gt;

            When reading the <i>first-shared-library</i> and
            <i>second-shared-library</i> ELF input files, keep the globally
            defined which names match the regular expression <i>regex</i>.  All
            other variables are dropped on the floor and will thus not
            appear in the resulting diff report.

          • <b>--harmless</b>

            In the diff report, display only the <i>harmless</i> changes.  By
            default, the harmless changes are filtered out of the diff
            report keep the clutter to a minimum and have a greater
            chance to spot real ABI issues.

          • <b>--no-harmful</b>

            In the diff report, do not display the <i>harmful</i> changes.  By
            default, only the harmful changes are displayed in diff
            report.

          • <b>--redundant</b>

            In the diff report, do display redundant changes.  A
            redundant change is a change that has been displayed
            elsewhere in the report.

          • <b>--no-redundant</b>

            In the diff report, do <i>NOT</i> display redundant changes.  A
            redundant change is a change that has been displayed
            elsewhere in the report.  This option is switched on by
            default.

          • <b>--no-architecture</b>

            Do not take architecture in account when comparing ABIs.

          • <b>--no-corpus-path</b>

            Do not emit the path attribute for the ABI corpus.

          • <b>--fail-no-debug-info</b>

            If no debug info was found, then this option makes the
            program to fail.  Otherwise, without this option, the
            program will attempt to compare properties of the binaries
            that are not related to debug info, like pure ELF
            properties.

          • <b>--leaf-changes-only|-l </b>only show leaf changes, so don't show
            impact analysis report.  This option implies <b>--redundant</b>.

            The typical output of abidiff when comparing two binaries
            looks like this

                $ abidiff libtest-v0.so libtest-v1.so
                Functions changes summary: 0 Removed, 1 Changed, 0 Added function
                Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

                1 function with some indirect sub-type change:

                  [C]'function void fn(C&amp;)' at test-v1.cc:13:1 has some indirect sub-type changes:
                    parameter 1 of type 'C&amp;' has sub-type changes:
                      in referenced type 'struct C' at test-v1.cc:7:1:
                        type size hasn't changed
                        1 data member change:
                         type of 'leaf* C::m0' changed:
                           in pointed to type 'struct leaf' at test-v1.cc:1:1:
                             type size changed from 32 to 64 bits
                             1 data member insertion:
                               'char leaf::m1', at offset 32 (in bits) at test-v1.cc:4:1

                $

            So in that example the report emits information about how
            the data member insertion change of "struct leaf" is
            reachable from function "void fn(C&amp;)".  In other words, the
            report not only shows the data member change on "struct
            leaf", but it also shows the impact of that change on the
            function "void fn(C&amp;)".

            In abidiff parlance, the change on "struct leaf" is called a
            leaf change.  So the <b>--leaf-changes-only</b>
            <b>--impacted-interfaces </b>options show, well, only the leaf
            change.  And it goes like this:

                $ abidiff -l libtest-v0.so libtest-v1.so
                'struct leaf' changed:
                  type size changed from 32 to 64 bits
                  1 data member insertion:
                    'char leaf::m1', at offset 32 (in bits) at test-v1.cc:4:1

                  one impacted interface:
                    function void fn(C&amp;)
                $

            Note how the report ends by showing the list of interfaces
            impacted by the leaf change.

            Now if you don't want to see that list of impacted
            interfaces, then you can just avoid using the
            <b>--impacted-interface </b>option.  You can learn about that
            option below, in any case.

          • <b>--impacted-interfaces</b>

            When showing leaf changes, this option instructs abidiff to
            show the list of impacted interfaces.  This option is thus
            to be used in addition the <b>--leaf-changes-only </b>option,
            otherwise, it's ignored.

          • <b>--dump-diff-tree</b>
              After the diff report, emit a textual representation of
              the diff nodes tree used by the comparison engine to
              represent the changed functions and variables.  That
              representation is emitted to the error output for
              debugging purposes.  Note that this diff tree is relevant
              only to functions and variables that have some sub-type
              changes.  Added or removed functions and variables do not
              have any diff nodes tree associated to them.

          • <b>--no-assume-odr-for-cplusplus</b>

            When analysing a binary originating from C++ code using
            <i>DWARF</i> debug information, libabigail assumes the <i>One</i>
            <i>Definition Rule</i> to speed-up the analysis.  In that case,
            when several types have the same name in the binary, they
            are assumed to all be equal.

            This option disables that assumption and instructs
            libabigail to actually actually compare the types to
            determine if they are equal.

          • <b>--no-leverage-dwarf-factorization</b>

            When analysing a binary which <i>DWARF</i> debug information was
            processed with the <i>DWZ</i> tool, the type information is
            supposed to be already factorized.  That context is used by
            libabigail to perform some speed optimizations.

            This option disables those optimizations.

          • <b>--no-change-categorization | -x</b>

            This option disables the categorization of changes into
            harmless and harmful changes.  Note that this categorization
            is a pre-requisite for the filtering of changes so this
            option disables that filtering.  The goal of this option is
            to speed-up the execution of the program for cases where the
            graph of changes is huge and where the user is just
            interested in looking at, for instance, leaf node changes
            without caring about their possible impact on interfaces.
            In that case, this option would be used along with the
            <b>--leaf-changes-only </b>one.

          • <b>--ctf</b>

            When comparing binaries, extract ABI information from <i>CTF</i>
            debug information, if present.

          • <b>--btf</b>

            When comparing binaries, extract ABI information from <i>BTF</i>
            debug information, if present.

          • <b>--stats</b>

            Emit statistics about various internal things.

          • <b>--verbose</b>

            Emit verbose logs about the progress of miscellaneous
            internal things.

   <b>Return values</b>
       The exit code of the <b>abidiff </b>command is either 0 if the ABI of
       the binaries being compared are equal, or non-zero if they differ
       or if the tool encountered an error.

       In the later case, the exit code is a 8-bits-wide bit field in
       which each bit has a specific meaning.

       The first bit, of value 1, named <b>ABIDIFF_ERROR </b>means there was an
       error.

       The second bit, of value 2, named <b>ABIDIFF_USAGE_ERROR </b>means there
       was an error in the way the user invoked the tool.  It might be
       set, for instance, if the user invoked the tool with an unknown
       command line switch, with a wrong number or argument, etc.  If
       this bit is set, then the <b>ABIDIFF_ERROR </b>bit must be set as well.

       The third bit, of value 4, named <b>ABIDIFF_ABI_CHANGE </b>means the ABI
       of the binaries being compared are different.

       The fourth bit, of value 8, named <b>ABIDIFF_ABI_INCOMPATIBLE_CHANGE</b>
       means the ABI of the binaries compared are different in an
       incompatible way.  If this bit is set, then the
       <b>ABIDIFF_ABI_CHANGE </b>bit must be set as well.  If the
       <b>ABIDIFF_ABI_CHANGE </b>is set and the <b>ABIDIFF_INCOMPATIBLE_CHANGE </b>is
       <i>NOT</i> set, then it means that the ABIs being compared might or
       might not be compatible.  In that case, a human being needs to
       review the ABI changes to decide if they are compatible or not.

       Note that, at the moment, there are only a few kinds of ABI
       changes that would result in setting the flag
       <b>ABIDIFF_ABI_INCOMPATIBLE_CHANGE</b>.  Those ABI changes are either:

          • the removal of the symbol of a function or variable that has
            been defined and exported.

          • the modification of the index of a member of a virtual
            function table (for C++ programs and libraries).

       With time, when more ABI change patterns are found to <i>always</i>
       constitute incompatible ABI changes, we will adapt the code to
       recognize those cases and set the <b>ABIDIFF_ABI_INCOMPATIBLE_CHANGE</b>
       accordingly.  So, if you find such patterns, please let us know.

       The remaining bits are not used for the moment.

   <b>Usage examples</b>
          1. Detecting a change in a sub-type of a function:

                 $ cat -n test-v0.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                          3
                          4      struct S0
                          5      {
                          6        int m0;
                          7      };
                          8
                          9      void
                         10      foo(S0* /*parameter_name*/)
                         11      {
                         12        // do something with parameter_name.
                         13      }
                 $
                 $ cat -n test-v1.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                          3
                          4      struct type_base
                          5      {
                          6        int inserted;
                          7      };
                          8
                          9      struct S0 : public type_base
                         10      {
                         11        int m0;
                         12      };
                         13
                         14      void
                         15      foo(S0* /*parameter_name*/)
                         16      {
                         17        // do something with parameter_name.
                         18      }
                 $
                 $ g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                 $ g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                 $
                 $ ../build/tools/abidiff libtest-v0.so libtest-v1.so
                 Functions changes summary: 0 Removed, 1 Changed, 0 Added function
                 Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

                 1 function with some indirect sub-type change:

                   [C]'function void foo(S0*)' has some indirect sub-type changes:
                         parameter 0 of type 'S0*' has sub-type changes:
                           in pointed to type 'struct S0':
                             size changed from 32 to 64 bits
                             1 base class insertion:
                               struct type_base
                             1 data member change:
                              'int S0::m0' offset changed from 0 to 32
                 $

          2. Detecting another change in a sub-type of a function:

                 $ cat -n test-v0.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                          3
                          4      struct S0
                          5      {
                          6        int m0;
                          7      };
                          8
                          9      void
                         10      foo(S0&amp; /*parameter_name*/)
                         11      {
                         12        // do something with parameter_name.
                         13      }
                 $
                 $ cat -n test-v1.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                          3
                          4      struct S0
                          5      {
                          6        char inserted_member;
                          7        int m0;
                          8      };
                          9
                         10      void
                         11      foo(S0&amp; /*parameter_name*/)
                         12      {
                         13        // do something with parameter_name.
                         14      }
                 $
                 $ g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                 $ g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                 $
                 $ ../build/tools/abidiff libtest-v0.so libtest-v1.so
                 Functions changes summary: 0 Removed, 1 Changed, 0 Added function
                 Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

                 1 function with some indirect sub-type change:

                   [C]'function void foo(S0&amp;)' has some indirect sub-type changes:
                         parameter 0 of type 'S0&amp;' has sub-type changes:
                           in referenced type 'struct S0':
                             size changed from 32 to 64 bits
                             1 data member insertion:
                               'char S0::inserted_member', at offset 0 (in bits)
                             1 data member change:
                              'int S0::m0' offset changed from 0 to 32

                 $

          3. Detecting that functions got removed or added to a library:

                 $ cat -n test-v0.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                          3
                          4      struct S0
                          5      {
                          6        int m0;
                          7      };
                          8
                          9      void
                         10      foo(S0&amp; /*parameter_name*/)
                         11      {
                         12        // do something with parameter_name.
                         13      }
                 $
                 $ cat -n test-v1.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                          3
                          4      struct S0
                          5      {
                          6        char inserted_member;
                          7        int m0;
                          8      };
                          9
                         10      void
                         11      bar(S0&amp; /*parameter_name*/)
                         12      {
                         13        // do something with parameter_name.
                         14      }
                 $
                 $ g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                 $ g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                 $
                 $ ../build/tools/abidiff libtest-v0.so libtest-v1.so
                 Functions changes summary: 1 Removed, 0 Changed, 1 Added functions
                 Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

                 1 Removed function:
                   'function void foo(S0&amp;)'    {_Z3fooR2S0}

                 1 Added function:
                   'function void bar(S0&amp;)'    {_Z3barR2S0}

                 $

          4. Comparing two sets of binaries that are passed on the
             command line:

                 $ abidiff --add-binaries1=file2-v1              \
                           --add-binaries2=file2-v2,file2-v1     \
                           --added-binaries-dir1 dir1            \
                           --added-binaries-dir2 dir2            \
                           file1-v1 file1-v2

             Note that the files <b>file2-v1</b>, and <b>file2-v2 </b>are to be found
             in <b>dir1 </b>and <b>dir2 </b>or in the current directory.

          5. Compare two libraries and their dependencies:

                 $ abidiff --follow-dependencies                      \
                           --added-binaries-dir1 /some/where          \
                           --added-binaries-dir2 /some/where/else     \
                           foo bar

             This compares the set of binaries comprised by <b>foo </b>and its
             dependencies against the set of binaries comprised by <b>bar</b>
             and its dependencies.

   <b>abipkgdiff</b>
       <b>abipkgdiff </b>compares the Application Binary Interfaces (ABI) of
       the <i>ELF</i> binaries contained in two software packages.  The
       software package formats currently supported are <i>Deb</i>, <i>RPM</i>, <i>tar</i>
       archives (either compressed or not) and plain directories that
       contain binaries.

       For a comprehensive ABI change report that includes changes about
       function and variable sub-types, the two input packages must be
       accompanied with their debug information packages that contain
       debug information either in <i>DWARF</i>, <i>CTF</i> or in <i>BTF</i> formats.  Please
       note however that some packages contain binaries that embed the
       debug information directly in a section of said binaries.  In
       those cases, obviously, no separate debug information package is
       needed as the tool will find the debug information inside the
       binaries.

       By default, <b>abipkgdiff </b>uses debug information in <i>DWARF</i> format, if
       present, otherwise it compares binaries interfaces using debug
       information in <i>CTF</i> or in <i>BTF</i> formats, if present. Finally, if no
       debug info in these formats is found, it only considers <i>ELF</i>
       symbols and report about their addition or removal.

       This tool uses the libabigail library to analyze the binary as
       well as its associated debug information.  Here is its general
       mode of operation.

       When instructed to do so, a binary and its associated debug
       information is read and analyzed.  To that effect, libabigail
       analyzes by default the descriptions of the types reachable by
       the interfaces (functions and variables) that are visible outside
       of their translation unit.  Once that analysis is done, an
       Application Binary Interface Corpus is constructed by only
       considering the subset of types reachable from interfaces
       associated to <i>ELF</i> symbols that are defined and exported by the
       binary.  It's that final ABI corpus which libabigail considers as
       representing the ABI of the analyzed binary.

       Libabigail then has capabilities to generate textual
       representations of ABI Corpora, compare them, analyze their
       changes and report about them.

   <b>Invocation</b>
          abipkgdiff [option] &lt;package1&gt; &lt;package2&gt;

       <b>package1 </b>and <b>package2 </b>are the packages that contain the binaries
       to be compared.

   <b>Environment</b>
       abipkgdiff loads two default <i>suppression specifications files</i>,
       merges their content and use it to filter out ABI change reports
       that might be considered as false positives to users.

       • Default system-wide suppression specification file

         It's located by the optional environment variable
         LIBABIGAIL_DEFAULT_SYSTEM_SUPPRESSION_FILE.  If that
         environment variable is not set, then abipkgdiff tries to load
         the suppression file
         $libdir/libabigail/libabigail-default.abignore.  If that file
         is not present, then no default system-wide suppression
         specification file is loaded.

       • Default user suppression specification file.

         It's located by the optional environment
         LIBABIGAIL_DEFAULT_USER_SUPPRESSION_FILE.  If that environment
         variable is not set, then abipkgdiff tries to load the
         suppression file $HOME/.abignore.  If that file is not present,
         then no default user suppression specification is loaded.

       In addition to those default suppression specification files,
       abipkgdiff will also look inside the packages being compared and
       if it sees a file that ends with the extension <b>.abignore</b>, then it
       will consider it as a suppression specification and it will
       combine it to the default suppression specification that might be
       already loaded.

       The user might as well use the <b>--suppressions </b>option (that is
       documented further below) to provide a suppression specification.

   <b>Options</b>
          • <b>--help | -h</b>

            Display a short help about the command and exit.

          • <i>--version | -v</i>

            Display the version of the program and exit.

          • <b>--debug-info-pkg1 | --d1 </b>&lt;path&gt;

            For cases where the debug information for <i>package1</i> is split
            out into a separate file, tells <b>abipkgdiff </b>where to find
            that separate debug information package.

            Note that the debug info for <i>package1</i> can have been split
            into several different debug info packages.  In that case,
            several instances of this options can be provided, along
            with those several different debug info packages.

          • <b>--debug-info-pkg2 | --d2 </b>&lt;path&gt;

            For cases where the debug information for <i>package2</i> is split
            out into a separate file, tells <b>abipkgdiff </b>where to find
            that separate debug information package.

            Note that the debug info for <i>package2</i> can have been split
            into several different debug info packages.  In that case,
            several instances of this options can be provided, along
            with those several different debug info packages.

          • <b>--devel-pkg1 | --devel1 </b>&lt;path&gt;

            Specifies where to find the <i>Development Package</i> associated
            with the first package to be compared.  That <i>Development</i>
            <i>Package</i> at <b>path </b>should at least contain header files in
            which public types exposed by the libraries (of the first
            package to be compared) are defined.  When this option is
            provided, the tool filters out reports about ABI changes to
            types that are <i>NOT</i> defined in these header files.

          • <b>--devel-pkg2 | --devel2 </b>&lt;path&gt;

            Specifies where to find the <i>Development Package</i> associated
            with the second package to be compared.  That <i>Development</i>
            <i>Package</i> at <b>path </b>should at least contains header files in
            which public types exposed by the libraries (of the second
            package to be compared) are defined.  When this option is
            provided, the tool filters out reports about ABI changes to
            types that are <i>NOT</i> defined in these header files.

          • <b>--drop-private-types</b>

            This option is to be used with the <b>--devel-pkg1 </b>and
            <b>--devel-pkg2 </b>options.  With this option, types that are <i>NOT</i>
            defined in the headers are entirely dropped from the
            internal representation build by Libabigail to represent the
            ABI.  They thus don't have to be filtered out from the final
            ABI change report because they are not even present in
            Libabigail's representation.

            Without this option however, those private types are kept in
            the internal representation and later filtered out from the
            report.

            This options thus potentially makes Libabigail consume less
            memory.  It's meant to be mainly used to optimize the memory
            consumption of the tool on binaries with a lot of publicly
            defined and exported types.

          • <b>--dso-only</b>

            Compare ELF files that are shared libraries, only.  Do not
            compare executable files, for instance.

          • <b>--private-dso</b>

            By default, <b>abipkgdiff </b>does not compare DSOs that are
            private to the RPM package.  A private DSO is a DSO which
            SONAME is <i>NOT</i> advertised in the "provides" property of the
            RPM.

            This option instructs <b>abipkgdiff </b>to <i>also</i> compare DSOs that
            are <i>NOT</i> advertised in the "provides" property of the RPM.

            Please note that the fact that (by default) <b>abipkgdiff </b>skips
            private DSO is a feature that is available only for RPMs, at
            the moment.  We would happily accept patches adding that
            feature for other package formats.

          • <b>--leaf-changes-only|-l </b>only show leaf changes, so don't show
            impact analysis report.  This option implies <b>--redundant</b>

            The typical output of <b>abipkgdiff </b>and <b>abidiff </b>when comparing
            two binaries, that we shall call <b>full impact report</b>, looks
            like this

                $ abidiff libtest-v0.so libtest-v1.so
                Functions changes summary: 0 Removed, 1 Changed, 0 Added function
                Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

                1 function with some indirect sub-type change:

                  [C]'function void fn(C&amp;)' at test-v1.cc:13:1 has some indirect sub-type changes:
                    parameter 1 of type 'C&amp;' has sub-type changes:
                      in referenced type 'struct C' at test-v1.cc:7:1:
                        type size hasn't changed
                        1 data member change:
                         type of 'leaf* C::m0' changed:
                           in pointed to type 'struct leaf' at test-v1.cc:1:1:
                             type size changed from 32 to 64 bits
                             1 data member insertion:
                               'char leaf::m1', at offset 32 (in bits) at test-v1.cc:4:1

                $

            So in that example the report emits information about how
            the data member insertion change of "struct leaf" is
            reachable from function "void fn(C&amp;)".  In other words, the
            report not only shows the data member change on "struct
            leaf", but it also shows the impact of that change on the
            function "void fn(C&amp;)".

            In abidiff (and abipkgdiff) parlance, the change on "struct
            leaf" is called a leaf change.  So the <b>--leaf-changes-only</b>
            <b>--impacted-interfaces </b>options show, well, only the leaf
            change.  And it goes like this:

                $ abidiff -l libtest-v0.so libtest-v1.so
                'struct leaf' changed:
                  type size changed from 32 to 64 bits
                  1 data member insertion:
                    'char leaf::m1', at offset 32 (in bits) at test-v1.cc:4:1

                  one impacted interface:
                    function void fn(C&amp;)
                $

            Note how the report ends up by showing the list of
            interfaces impacted by the leaf change.  That's the effect
            of the additional <b>--impacted-interfaces </b>option.

            Now if you don't want to see that list of impacted
            interfaces, then you can just avoid using the
            <b>--impacted-interface </b>option.  You can learn about that
            option below, in any case.

            Please note that when comparing two Linux Kernel packages,
            it's this <b>leaf changes report </b>that is emitted, by default.
            The normal so-called <b>full impact report </b>can be emitted with
            the option <b>--full-impact </b>which is documented later below.

          • <b>--impacted-interfaces</b>

            When showing leaf changes, this option instructs abipkgdiff
            to show the list of impacted interfaces.  This option is
            thus to be used in addition to the <b>--leaf-changes-only</b>
            option, or, when comparing two Linux Kernel packages.
            Otherwise, it's simply ignored.

          • <b>--full-impact|-f</b>

            When comparing two Linux Kernel packages, this function
            instructs <b>abipkgdiff </b>to emit the so-called <b>full impact</b>
            <b>report</b>, which is the default report kind emitted by the
            <b>abidiff </b>tool:

                $ abidiff libtest-v0.so libtest-v1.so
                Functions changes summary: 0 Removed, 1 Changed, 0 Added function
                Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

                1 function with some indirect sub-type change:

                  [C]'function void fn(C&amp;)' at test-v1.cc:13:1 has some indirect sub-type changes:
                    parameter 1 of type 'C&amp;' has sub-type changes:
                      in referenced type 'struct C' at test-v1.cc:7:1:
                        type size hasn't changed
                        1 data member change:
                         type of 'leaf* C::m0' changed:
                           in pointed to type 'struct leaf' at test-v1.cc:1:1:
                             type size changed from 32 to 64 bits
                             1 data member insertion:
                               'char leaf::m1', at offset 32 (in bits) at test-v1.cc:4:1

                $

          • <b>--non-reachable-types|-t</b>

            Analyze and emit change reports for all the types of the
            binary, including those that are not reachable from global
            functions and variables.

            This option might incur some serious performance degradation
            as the number of types analyzed can be huge.  However, if
            paired with the <b>--devel-pkg{1,2} </b>options, the additional
            non-reachable types analyzed are restricted to those defined
            in the public headers files carried by the referenced
            development packages, thus hopefully making the performance
            hit acceptable.

            Also, using this option alongside suppression specifications
            (by also using the <b>--suppressions </b>option) might help keep
            the number of analyzed types (and the potential performance
            degradation) in control.

            Note that without this option, only types that are reachable
            from global functions and variables are analyzed, so the
            tool detects and reports changes on these reachable types
            only.

          • <b>--exported-interfaces-only</b>

            By default, when looking at the debug information
            accompanying a binary, this tool analyzes the descriptions
            of the types reachable by the interfaces (functions and
            variables) that are visible outside of their translation
            unit.  Once that analysis is done, an ABI corpus is
            constructed by only considering the subset of types
            reachable from interfaces associated to <i>ELF</i> symbols that are
            defined and exported by the binary.  It's those final ABI
            Corpora that are compared by this tool.

            The problem with that approach however is that analyzing all
            the interfaces that are visible from outside their
            translation unit can amount to a lot of data, especially
            when those binaries are applications, as opposed to shared
            libraries.  One example of such applications is the <i>Linux</i>
            <i>Kernel</i>.  Analyzing massive ABI corpora like these can be
            extremely slow.

            To mitigate that performance issue, this option allows
            libabigail to only analyze types that are reachable from
            interfaces associated with defined and exported <i>ELF</i> symbols.

            Note that this option is turned on by default when analyzing
            the <i>Linux Kernel</i>.  Otherwise, it's turned off by default.

          • <b>--allow-non-exported-interfaces</b>

            When looking at the debug information accompanying a binary,
            this tool analyzes the descriptions of the types reachable
            by the interfaces (functions and variables) that are visible
            outside of their translation unit.  Once that analysis is
            done, an ABI corpus is constructed by only considering the
            subset of types reachable from interfaces associated to <i>ELF</i>
            symbols that are defined and exported by the binary.  It's
            those final ABI Corpora that are compared by this tool.

            The problem with that approach however is that analyzing all
            the interfaces that are visible from outside their
            translation unit can amount to a lot of data, especially
            when those binaries are applications, as opposed to shared
            libraries.  One example of such applications is the <i>Linux</i>
            <i>Kernel</i>.  Analyzing massive ABI Corpora like these can be
            extremely slow.

            In the presence of an "average sized" binary however one can
            afford having libabigail analyze all interfaces that are
            visible outside of their translation unit, using this
            option.

            Note that this option is turned on by default, unless we are
            in the presence of the <i>Linux Kernel</i>.

          • <b>--redundant</b>
              In the diff reports, do display redundant changes.  A
              redundant change is a change that has been displayed
              elsewhere in a given report.

          • <b>--harmless</b>

            In the diff report, display only the <i>harmless</i> changes.  By
            default, the harmless changes are filtered out of the diff
            report keep the clutter to a minimum and have a greater
            chance to spot real ABI issues.

          • <b>--no-linkage-name</b>

            In the resulting report, do not display the linkage names of
            the added, removed, or changed functions or variables.

          • <b>--no-added-syms</b>

            Do not show the list of functions, variables, or any symbol
            that was added.

          • <b>--no-added-binaries</b>

            Do not show the list of binaries that got added to the
            second package.

            Please note that the presence of such added binaries is not
            considered like an ABI change by this tool; as such, it
            doesn't have any impact on the exit code of the tool.  It
            does only have an informational value.  Removed binaries
            are, however, considered as an ABI change.

          • <b>--no-abignore</b>

            Do not search the package for the presence of suppression
            files.

          • <b>--no-parallel</b>

            By default, <b>abipkgdiff </b>will use all the processors it has
            available to execute concurrently.  This option tells it not
            to extract packages or run comparisons in parallel.

          • <b>--no-default-suppression</b>

            Do not load the <i>default suppression specification files</i>.

          • <b>--suppressions | --suppr </b>&lt;<i>path-to-suppressions</i>&gt;

            Use a <i>suppression specification</i> file located at
            <i>path-to-suppressions</i>.  Note that this option can appear
            multiple times on the command line.  In that case, all of
            the suppression specification files are taken into account.

            Please note that, by default, if this option is not
            provided, then the <i>default suppression specification files</i>
            are loaded .

          • <b>--linux-kernel-abi-whitelist | -w </b>&lt;<i>path-to-whitelist</i>&gt;

            When comparing two Linux kernel RPM packages, this option
            points to the white list of names of ELF symbols of
            functions and variables that must be compared for ABI
            changes.  That white list is called a "Linux kernel ABI
            white list".

            Any other function or variable which ELF symbol are not
            present in that white list will not be considered by the ABI
            comparison process.

            If this option is not provided -- thus if no white list is
            provided -- then the ABI of all publicly defined and
            exported functions and global variables by the Linux Kernel
            binaries are compared.

            Please note that if a white list package is given in
            parameter, this option handles it just fine, like if the
            --wp option was used.

          • <b>--wp </b>&lt;<i>path-to-whitelist-package</i>&gt;

            When comparing two Linux kernel RPM packages, this option
            points an RPM package containining several white lists of
            names of ELF symbols of functions and variables that must be
            compared for ABI changes.  Those white lists are called
            "Linux kernel ABI white lists".

            From the content of that white list package, this program
            then chooses the appropriate Linux kernel ABI white list to
            consider when comparing the ABI of Linux kernel binaries
            contained in the Linux kernel packages provided on the
            command line.

            That choosen Linux kernel ABI white list contains the list
            of names of ELF symbols of functions and variables that must
            be compared for ABI changes.

            Any other function or variable which ELF symbol are not
            present in that white list will not be considered by the ABI
            comparison process.

            Note that this option can be provided twice (not mor than
            twice), specifying one white list package for each Linux
            Kernel package that is provided on the command line.

            If this option is not provided -- thus if no white list is
            provided -- then the ABI of all publicly defined and
            exported functions and global variables by the Linux Kernel
            binaries are compared.

          • <b>--no-unreferenced-symbols</b>

            In the resulting report, do not display change information
            about function and variable symbols that are not referenced
            by any debug information.  Note that for these symbols not
            referenced by any debug information, the change information
            displayed is either added or removed symbols.

          • <b>--no-show-locs</b>
              Do not show information about where in the <i>second shared</i>
              <i>library</i> the respective type was changed.

          • <b>--show-bytes</b>

            Show sizes and offsets in bytes, not bits.  By default,
            sizes and offsets are shown in bits.

          • <b>--show-bits</b>

            Show sizes and offsets in bits, not bytes.  This option is
            activated by default.

          • <b>--show-hex</b>

            Show sizes and offsets in hexadecimal base.

          • <b>--show-dec</b>

            Show sizes and offsets in decimal base.  This option is
            activated by default.

          • <b>--no-show-relative-offset-changes</b>

            Without this option, when the offset of a data member
            changes, the change report not only mentions the older and
            newer offset, but it also mentions by how many bits the data
            member changes.  With this option, the latter is not shown.

          • <b>--show-identical-binaries</b>
              Show the names of the all binaries compared, including the
              binaries whose ABI compare equal.  By default, when this
              option is not provided, only binaries with ABI changes are
              mentionned in the output.

          • <b>--fail-no-dbg</b>

            Make the program fail and return a non-zero exit code if
            couldn't read any of the debug information that comes from
            the debug info packages that were given on the command line.
            If no debug info package were provided on the command line
            then this option is not active.

            Note that the non-zero exit code returned by the program as
            a result of this option is the constant <b>ABIDIFF_ERROR</b>.  To
            know the numerical value of that constant, please refer to
            the <i>exit code documentation</i>.

          • <b>--keep-tmp-files</b>

            Do not erase the temporary directory files that are created
            during the execution of the tool.

          • <b>--verbose</b>

            Emit verbose progress messages.

          • <b>--self-check</b>

            This is used to test the underlying Libabigail library.
            When in used, the command expects only on input package,
            along with its associated debug info packages.  The command
            then compares each binary inside the package against its own
            ABIXML representation. The result of the comparison should
            yield the empty set if Libabigail behaves correctly.
            Otherwise, it means there is an issue that ought to be
            fixed.  This option is used by people interested in
            Libabigail development for regression testing purposes.
            Here is an example of the use of this option:

                $ abipkgdiff --self-check --d1 mesa-libGLU-debuginfo-9.0.1-3.fc33.x86_64.rpm  mesa-libGLU-9.0.1-3.fc33.x86_64.rpm
                 ==== SELF CHECK SUCCEEDED for 'libGLU.so.1.3.1' ====
                $

          • <b>--no-assume-odr-for-cplusplus</b>

            When analysing a binary originating from C++ code using
            <i>DWARF</i> debug information, libabigail assumes the <i>One</i>
            <i>Definition Rule</i> to speed-up the analysis.  In that case,
            when several types have the same name in the binary, they
            are assumed to all be equal.

            This option disables that assumption and instructs
            libabigail to actually actually compare the types to
            determine if they are equal.

          • <b>--no-leverage-dwarf-factorization</b>

            When analysing a binary which <i>DWARF</i> debug information was
            processed with the <i>DWZ</i> tool, the type information is
            supposed to be already factorized.  That context is used by
            libabigail to perform some speed optimizations.

            This option disables those optimizations.

          • <b>--ctf</b>
                This is used to compare packages with <i>CTF</i> debug
                information, if present.

          • <b>--btf</b>
                This is used to compare packages with <i>BTF</i> debug
                information, if present.

   <b>Return value</b>
       The exit code of the <b>abipkgdiff </b>command is either 0 if the ABI of
       the binaries compared are equal, or non-zero if they differ or if
       the tool encountered an error.

       In the later case, the value of the exit code is the same as for
       the <i>abidiff tool</i>.

   <b>kmidiff</b>
       <b>kmidiff </b>compares the binary Kernel Module Interfaces of two Linux
       Kernel trees.  The binary KMI is the interface that the Linux
       Kernel exposes to its modules.  The trees we are interested in
       here are the result of the build of the Linux Kernel source tree.

   <b>General approach</b>
       And example of how to build your kernel if you want to compare it
       to another one using kmidiff is:

          git clone -b v4.5 git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git linux/v4.5
          cd linux/v4.5
          make allyesconfig all

       Then install the modules into a directory, for instance, the
       build/modules sub-directory of the your kernel source tree:

          mkdir build/modules
          make modules_install INSTALL_MOD_DIR=build/modules

       Then construct a list of interfaces exported by the kernel, that
       you want to compare:

          cat &gt; kmi-whitelist &lt;&lt; EOF
          [kernel_4.5_kmi_whitelist]
           init_task
           schedule
           dev_queue_xmit
           __kmalloc
           printk
          EOF

       Suppose you've done something similar for the v4.6 branch of the
       Linux kernel, you now have these two directories: <b>linux/v4.5 </b>and
       <b>linux/v4.6</b>.  Their modules are present under the directories
       <b>linux/v4.5/build/modules </b>and <b>linux/v4.6/build/modules</b>.

       To Comparing their KMI <b>kmidiff </b>needs to know where to find the
       vmlinux binaries and their associated modules.  Here would be
       what the command line looks like:

          kmidiff                                     \
            --kmi-whitelist  linux/v4.6/kmi-whitelist \
            --vmlinux1       linux/v4.5/vmlinux       \
            --vmlinux2       linux/v4.6/vmlinux       \
                             linux/v4.5/build/modules \
                             linux/v4.6/build/modules

       This tool uses the libabigail library to analyze the binary as
       well as its associated debug information.  Here is its general
       mode of operation.

       When instructed to do so, a binary and its associated debug
       information is read and analyzed.  To that effect, libabigail
       analyzes by default the descriptions of the types reachable by
       the interfaces (functions and variables) that are visible outside
       of their translation unit.  Once that analysis is done, an
       Application Binary Interface Corpus is constructed by only
       considering the subset of types reachable from interfaces
       associated to <i>ELF</i> symbols that are defined and exported by the
       binary.  It's that final ABI corpus which libabigail considers as
       representing the ABI of the analyzed binary.

       Libabigail then has capabilities to generate textual
       representations of ABI Corpora, compare them, analyze their
       changes and report about them.

   <b>Invocation</b>
       More generally, <b>kmidiff </b>is invoked under the form:

          kmidiff [options] &lt;first-modules-dir&gt; &lt;second-modules-dir&gt;

   <b>Environment</b>
       By default, <b>kmidiff </b>compares all the interfaces (exported
       functions and variables) between the Kernel and its modules.  In
       practice, though, some users might want to compare a subset of
       the those interfaces.

       By default, <b>kmidiff </b>uses debug information in the <i>DWARF</i> debug
       info format, if present, otherwise it compares interfaces using
       <i>CTF</i> or <i>BTF</i> debug info formats, if present.  Finally, if no debug
       info in these formats is found, it only considers <i>ELF</i> symbols and
       report about their addition or removal.

       Users can then define a "white list" of the interfaces to
       compare.  Such a white list is a just a file in the "INI" format
       that looks like:

          [kernel_version_x86_64_whitelist]
            function1_name
            function2_name
            global_variable1_name
            ....

       Note that the name of the section (the name that is between the
       two brackets) of that INI file just has to end with the string
       "whitelist".  So you can define the name you want, for instance
       <b>[kernel_46_x86_64_whitelist]</b>.

       Then each line of that whitelist file is the name of an exported
       function or variable.  Only those interfaces along with the types
       reachable from their signatures are going to be compared by
       <b>kmidiff </b>recursively.

       Note that by default kmidiff analyzes the types reachable from
       the interfaces associated with <i>ELF</i> symbols that are defined and
       exported by the <i>Linux Kernel</i> as being the union of the <b>vmlinux</b>
       binary and all its compiled modules.  It then compares those
       interfaces (along with their types).

   <b>Options</b>
          • <b>--help | -h</b>

            Display a short help about the command and exit.

          • <b>--version | -v</b>

            Display the version of the program and exit.

          • <b>--verbose</b>

            Display some verbose messages while executing.

          • <b>--debug-info-dir1 | --d1 </b>&lt;<i>di-path1</i>&gt;

            For cases where the debug information for the binaries of
            the first Linux kernel is split out into separate files,
            tells <b>kmidiff </b>where to find those separate debug information
            files.

            Note that <i>di-path</i> must point to the root directory under
            which the debug information is arranged in a tree-like
            manner.  Under Red Hat based systems, that directory is
            usually <b>&lt;root&gt;/usr/lib/debug</b>.

          • <b>--debug-info-dir2 | --d2 </b>&lt;<i>di-path2</i>&gt;

            Like <b>--debug-info-dir1</b>, this options tells <b>kmidiff </b>where to
            find the split debug information for the binaries of the
            second Linux kernel.

          • <b>--vmlinux1 | --l1 </b>&lt;<i>path-to-first-vmlinux</i>&gt;

            Sets the path to the first <b>vmlinux </b>binary to consider.  This
            has to be the uncompressed vmlinux binary compiled with
            debug info.

          • <b>--vmlinux2 | --l2 </b>&lt;<i>path-to-first-vmlinux</i>&gt;

            Sets the path to the second <b>vmlinux </b>binary to consider.
            This has to be the uncompressed vmlinux binary compiled with
            debug info.

          • <b>--kmi-whitelist | -w </b>&lt;<i>path-to-interface-whitelist</i>&gt;

            Set the path to the white list of interfaces to compare
            while comparing the Kernel Module Interface of the first
            kernel against the one of the second kernel.

            If this option is not provided, <i>all</i> the exported interfaces
            of the two kernels are compared.  That takes a lot of times
            and is not necessarily meaningful because many interface are
            probably meant to see their reachable types change.

            So please, make sure you always use this option unless you
            really know what you  are doing.

          • <b>--suppressions | --suppr </b>&lt;<i>path-to-suppressions</i>&gt;

            Use a <i>suppression specification</i> file located at
            <i>path-to-suppressions</i>.  Note that this option can appear
            multiple times on the command line.  In that case, all of
            the provided suppression specification files are taken into
            account.

            Please note that, by default, if this option is not
            provided, then the <i>default suppression specification files</i>
            are loaded .

          • <b>--no-change-categorization | -x</b>

            This option disables the categorization of changes into
            harmless and harmful changes.  Note that this categorization
            is a pre-requisite for the filtering of changes so this
            option disables that filtering.  The goal of this option is
            to speed-up the execution of the program for cases where the
            graph of changes is huge and where the user is just
            interested in looking at, for instance, leaf node changes
            without caring about their possible impact on interfaces.

          • <b>--ctf</b>

            Extract ABI information from <i>CTF</i> debug information, if
            present, in the Kernel and Modules.

          • <b>--btf</b>

            Extract ABI information from <i>BTF</i> debug information, if
            present, in the Kernel and Modules.

          • <b>--impacted-interfaces | -i</b>

            Tell what interfaces got impacted by each individual ABI
            change.

          • <b>--full-impact | -f</b>

            Emit a change report that shows the full impact of each
            change on exported interfaces.  This is the default kind of
            report emitted by tools like <b>abidiff </b>or <b>abipkgdiff</b>.

          • <b>--exported-interfaces-only</b>

            When using this option, this tool analyzes the descriptions
            of the types reachable by the interfaces (functions and
            variables) associated with <i>ELF</i> symbols that are defined and
            exported by the <i>Linux Kernel</i>.

            Otherwise, the tool also has the ability to analyze the
            descriptions of the types reachable by the interfaces
            associated with <i>ELF</i> symbols that are visible outside their
            translation unit.  This later possibility is however much
            more resource intensive and results in much slower
            operations.

            That is why this option is enabled by default.

          • <b>--allow-non-exported-interfaces</b>

            When using this option, this tool analyzes the descriptions
            of the types reachable by the interfaces (functions and
            variables) that are visible outside of their translation
            unit.  Once that analysis is done, an ABI Corpus is
            constructed by only considering the subset of types
            reachable from interfaces associated to <i>ELF</i> symbols that are
            defined and exported by the binary.  It's that final ABI
            corpus which is compared against another one.

            The problem with that approach however is that analyzing all
            the interfaces that are visible from outside their
            translation unit can amount to a lot of data, leading to
            very slow operations.

            Note that this option is turned off by default.

          • <b>--show-bytes</b>

            Show sizes and offsets in bytes, not bits.  This option is
            activated by default.

          • <b>--show-bits</b>

            Show sizes and offsets in bits, not bytes.  By default,
            sizes and offsets are shown in bytes.

          • <b>--show-hex</b>

            Show sizes and offsets in hexadecimal base.  This option is
            activated by default.

          • <b>--show-dec</b>

            Show sizes and offsets in decimal base.

   <b>abidw</b>
       abidw reads a shared library in <i>ELF</i> format and emits an XML
       representation of its ABI to standard output.  The emitted
       representation format, named <b>ABIXML</b>, includes all the globally
       defined functions and variables, along with a complete
       representation of their types.  It also includes a representation
       of the globally defined ELF symbols of the file.

       When given the <b>--linux-tree </b>option, this program can also handle
       a <i>Linux kernel</i> tree.  That is, a directory tree that contains
       both the vmlinux binary and <i>Linux Kernel</i> modules.  It analyses
       those <i>Linux Kernel</i> binaries and emits an XML representation of
       the interface between the kernel and its module, to standard
       output.  In this case, we don't call it an ABI, but a KMI (Kernel
       Module Interface).  The emitted KMI includes all the globally
       defined functions and variables, along with a complete
       representation of their types.

       To generate either ABI or KMI representation, by default <b>abidw</b>
       uses debug information in the <i>DWARF</i> format, if present, otherwise
       it looks for debug information in <i>CTF</i> or <i>BTF</i> formats, if present.
       Finally, if no debug info in these formats is found, it only
       considers <i>ELF</i> symbols and report about their addition or removal.

       This tool uses the libabigail library to analyze the binary as
       well as its associated debug information.  Here is its general
       mode of operation.

       When instructed to do so, a binary and its associated debug
       information is read and analyzed.  To that effect, libabigail
       analyzes by default the descriptions of the types reachable by
       the interfaces (functions and variables) that are visible outside
       of their translation unit.  Once that analysis is done, an
       Application Binary Interface Corpus is constructed by only
       considering the subset of types reachable from interfaces
       associated to <i>ELF</i> symbols that are defined and exported by the
       binary.  It's that final ABI corpus which libabigail considers as
       representing the ABI of the analyzed binary.

       Libabigail then has capabilities to generate textual
       representations of ABI Corpora, compare them, analyze their
       changes and report about them.

   <b>Invocation</b>
          abidw [options] [&lt;path-to-elf-file&gt;]

   <b>Options</b>
          • <b>--help | -h</b>

            Display a short help about the command and exit.

          • <b>--version | -v</b>

            Display the version of the program and exit.

          • <b>--abixml-version</b>

            Display the version of the ABIXML format emitted by this
            program and exit.

          • <b>--add-binaries </b>&lt;<i>bin1,bin2,...</i>&gt;

            For each of the comma-separated binaries given in argument
            to this option, if the binary is found in the directory
            specified by the <i>--added-binaries-dir</i> option, then load the
            ABI corpus of the binary and add it to a set of ABI corpora
            (called a ABI Corpus Group) made of the binary denoted by
            the Argument of <b>abidw</b>.  That corpus group is then serialized
            out.

          • <b>--follow-dependencies</b>

            For each dependency of the input binary of <b>abidw</b>, if it is
            found in the directory specified by the <b>--added-binaries-dir</b>
            option, then construct an ABI corpus out of the dependency
            and add it to a set of ABI corpora (called an ABI Corpus
            Group) along with the ABI corpus of the input binary of the
            program.  The ABI Corpus Group is then serialized out.

          • <b>--list-dependencies</b>

            For each dependency of the input binary of``abidw``, if it's
            found in the directory specified by the <b>--added-binaries-dir</b>
            option, then the name of the dependency is printed out.

          • <b>--added-binaries-dir | --abd </b>&lt;<i>dir-path</i>&gt;

            This option is to be used in conjunction with the
            <b>--add-binaries</b>, the <b>--follow-dependencies </b>or the
            <b>--list-dependencies </b>option.  Binaries listed as arguments of
            the <b>--add-binaries </b>option or being dependencies of the input
            binary in the case of the <b>--follow-dependencies </b>option and
            found in the directory &lt;<i>dir-path</i>&gt; are going to be loaded as
            ABI corpus and added to the set of ABI corpora (called an
            ABI corpus group) built and serialized.

          • <b>--debug-info-dir | -d </b>&lt;<i>dir-path</i>&gt;

            In cases where the debug info for <i>path-to-elf-file</i> is in a
            separate file that is located in a non-standard place, this
            tells <b>abidw </b>where to look for that debug info file.

            Note that <i>dir-path</i> must point to the root directory under
            which the debug information is arranged in a tree-like
            manner.  Under Red Hat based systems, that directory is
            usually <b>&lt;root&gt;/usr/lib/debug</b>.

            This option can be provided several times with different
            root directories.  In that case, <b>abidw </b>will potentially look
            into all those root directories to find the split debug info
            for the elf file.

            Note that this option is not mandatory for split debug
            information installed by your system's package manager
            because then <b>abidw </b>knows where to find it.

          • <b>--out-file | -o </b>&lt;<i>file-path</i>&gt;

            This option instructs <b>abidw </b>to emit the XML representation
            of <i>path-to-elf-file</i> into the file <i>file-path</i>, rather than
            emitting it to its standard output.

          • <b>--noout</b>

            This option instructs <b>abidw </b>to not emit the XML
            representation of the ABI.  So it only reads the ELF and
            debug information, builds the internal representation of the
            ABI and exits.  This option is usually useful for debugging
            purposes.

          • <b>--no-corpus-path</b>

            Do not emit the path attribute for the ABI corpus.

          • <b>--suppressions | suppr</b>
            &lt;<i>path-to-suppression-specifications-file</i>&gt;

            Use a <i>suppression specification</i> file located at
            <i>path-to-suppression-specifications-file</i>.  Note that this
            option can appear multiple times on the command line.  In
            that case, all of the provided suppression specification
            files are taken into account.  ABI artifacts matched by the
            suppression specifications are suppressed from the output of
            this tool.

          • <b>--kmi-whitelist | -kaw </b>&lt;<i>path-to-whitelist</i>&gt;

            When analyzing a <i>Linux Kernel</i> binary, this option points to
            the white list of names of ELF symbols of functions and
            variables which ABI must be written out.  That white list is
            called a " Kernel Module Interface white list".  This is
            because for the Kernel, we don't talk about the ABI; we
            rather talk about the interface between the Kernel and its
            module. Hence the term <b>KMI </b>rather than <b>ABI</b>

            Any other function or variable which ELF symbol are not
            present in that white list will not be considered by the KMI
            writing process.

            If this option is not provided -- thus if no white list is
            provided -- then the entire KMI, that is, all publicly
            defined and exported functions and global variables by the
            <i>Linux Kernel</i> binaries is emitted.

          • <b>--linux-tree | --lt</b>

            Make <b>abidw </b>to consider the input path as a path to a
            directory containing the vmlinux binary as several kernel
            modules binaries.  In that case, this program emits the
            representation of the Kernel Module Interface (KMI) on the
            standard output.

            Below is an example of usage of <b>abidw </b>on a <i>Linux Kernel</i>
            tree.

            First, checkout a <i>Linux Kernel</i> source tree and build it.
            Then install the kernel modules in a directory somewhere.
            Copy the vmlinux binary into that directory too.  And then
            serialize the KMI of that kernel to disk, using <b>abidw</b>:

                $ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
                $ cd linux &amp;&amp; git checkout v4.5
                $ make allyesconfig all
                $ mkdir build-output
                $ make INSTALL_MOD_PATH=./build-output modules_install
                $ cp vmlinux build-output/modules/4.5.0
                $ abidw --linux-tree build-output/modules/4.5.0 &gt; build-output/linux-4.5.0.kmi

          • <b>--headers-dir | --hd </b>&lt;headers-directory-path-1&gt;

            Specifies where to find the public headers of the binary
            that the tool has to consider.  The tool will thus filter
            out types that are not defined in public headers.

            Note that several public header directories can be specified
            for the binary to consider.  In that case the <b>--header-dir</b>
            option should be present several times on the command line,
            like in the following example:

                $ abidw --header-dir /some/path       \
                        --header-dir /some/other/path \
                        binary &gt; binary.abi

          • <b>--header-file | --hf </b>&lt;header-file-path&gt;

            Specifies where to find one of the public headers of the abi
            file that the tool has to consider.  The tool will thus
            filter out types that are not defined in public headers.

          • <b>--drop-private-types</b>

            This option is to be used with the <b>--headers-dir </b>and/or
            <b>header-file </b>options.  With this option, types that are <i>NOT</i>
            defined in the headers are entirely dropped from the
            internal representation build by Libabigail to represent the
            ABI and will not end up in the abi XML file.

          • <b>--no-elf-needed</b>

            Do not include the list of DT_NEEDED dependency names in the
            corpus.

          • <b>--drop-undefined-syms</b>

            With this option functions or variables for which the
            (exported) ELF symbol is undefined are dropped from the
            internal representation build by Libabigail to represent the
            ABI and will not end up in the abi XML file.

          • <b>--exported-interfaces-only</b>

            By default, when looking at the debug information
            accompanying a binary, this tool analyzes the descriptions
            of the types reachable by the interfaces (functions and
            variables) that are visible outside of their translation
            unit.  Once that analysis is done, an ABI corpus is
            constructed by only considering the subset of types
            reachable from interfaces associated to <i>ELF</i> symbols that are
            defined and exported by the binary.  It's that final ABI
            corpus which textual representation is saved as <b>ABIXML</b>.

            The problem with that approach however is that analyzing all
            the interfaces that are visible from outside their
            translation unit can amount to a lot of data, especially
            when those binaries are applications, as opposed to shared
            libraries.  One example of such applications is the <i>Linux</i>
            <i>Kernel</i>.  Analyzing massive ABI corpora like these can be
            extremely slow.

            To mitigate that performance issue, this option allows
            libabigail to only analyze types that are reachable from
            interfaces associated with defined and exported <i>ELF</i> symbols.

            Note that this option is turned on by default when analyzing
            the <i>Linux Kernel</i>.  Otherwise, it's turned off by default.

          • <b>--allow-non-exported-interfaces</b>

            When looking at the debug information accompanying a binary,
            this tool analyzes the descriptions of the types reachable
            by the interfaces (functions and variables) that are visible
            outside of their translation unit.  Once that analysis is
            done, an ABI corpus is constructed by only considering the
            subset of types reachable from interfaces associated to <i>ELF</i>
            symbols that are defined and exported by the binary.  It's
            that final ABI corpus which textual representation is saved
            as <b>ABIXML</b>.

            The problem with that approach however is that analyzing all
            the interfaces that are visible from outside their
            translation unit can amount to a lot of data, especially
            when those binaries are applications, as opposed to shared
            libraries.  One example of such applications is the <i>Linux</i>
            <i>Kernel</i>.  Analyzing massive ABI corpora like these can be
            extremely slow.

            In the presence of an "average sized" binary however one can
            afford having libabigail analyze all interfaces that are
            visible outside of their translation unit, using this
            option.

            Note that this option is turned on by default, unless we are
            in the presence of the <i>Linux Kernel</i>.

          • <b>--no-linux-kernel-mode</b>

            Without this option, if abipkgiff detects that the binaries
            it is looking at are Linux Kernel binaries (either vmlinux
            or modules) then it only considers functions and variables
            which ELF symbols are listed in the __ksymtab and
            __ksymtab_gpl sections.

            With this option, abipkgdiff considers the binary as a
            non-special ELF binary.  It thus considers functions and
            variables which are defined and exported in the ELF sense.

          • <b>--check-alternate-debug-info </b>&lt;<i>elf-path</i>&gt;

            If the debug info for the file <i>elf-path</i> contains a reference
            to an <i>alternate debug info</i> file, <b>abidw </b>checks that it can
            find that alternate debug info file.  In that case, it emits
            a meaningful success message mentioning the full path to the
            alternate debug info file found.  Otherwise, it emits an
            error code.

          • <b>--no-show-locs</b>
              In the emitted ABI representation, do not show file, line
              or column where ABI artifacts are defined.

          • <b>--no-parameter-names</b>

            In the emitted ABI representation, do not show names of
            function parameters, just the types.

          • <b>--no-write-default-sizes</b>

            In the XML ABI representation, do not write the size-in-bits
            for pointer type definitions, reference type definitions,
            function declarations and function types when they are equal
            to the default address size of the translation unit.  Note
            that libabigail before 1.8 will not set the default size and
            will interpret types without a size-in-bits attribute as
            zero sized.

          • <b>--type-id-style </b>&lt;<b>sequence``|``hash</b>&gt;

            This option controls how types are idenfied in the generated
            XML files.  The default <b>sequence </b>style just numbers (with
            <b>type-id- </b>as prefix) the types in the order they are
            encountered.  The <b>hash </b>style uses a (stable, portable) hash
            of libabigail's internal type names and is intended to make
            the XML files easier to diff.

          • <b>--check-alternate-debug-info-base-name </b>&lt;<i>elf-path</i>&gt;

            Like <b>--check-alternate-debug-info</b>, but in the success
            message, only mention the base name of the debug info file;
            not its full path.

          • <b>--load-all-types</b>

            By default, <b>libabigail </b>(and thus <b>abidw</b>) only loads types
            that are reachable from functions and variables declarations
            that are publicly defined and exported by the binary.  So
            only those types are present in the output of <b>abidw</b>.  This
            option however makes <b>abidw </b>load <i>all</i> the types defined in the
            binaries, even those that are not reachable from public
            declarations.

            • <b>--no-load-undefined-interfaces</b>

            By default, <b>libabigail </b>(and thus <b>abidw</b>) loads information
            about undefined function and variable symbols as well as
            functions and variables that are associated with those
            undefined symbols.  Those are called undefined interfaces.
            This option however makes makes <b>abidw </b>avoid loading
            information about undefined interfaces.  The resulting XML
            file thus doesn't contain information about those undefined
            interfaces.

          • <b>--abidiff</b>
              Load the ABI of the ELF binary given in argument, save it
              in libabigail's XML format in a temporary file; read the
              ABI from the temporary XML file and compare the ABI that
              has been read back against the ABI of the ELF binary given
              in argument.  The ABIs should compare equal.  If they
              don't, the program emits a diagnostic and exits with a
              non-zero code.

              This is a debugging and sanity check option.

              • <b>--debug-abidiff</b>

              Same as <b>--abidiff </b>but in debug mode.  In this mode, error
              messages are emitted for types which fail type
              canonicalization.

              This is an optional debugging and sanity check option.  To
              enable it the libabigail package needs to be configured
              with the --enable-debug-self-comparison option.

              • <b>--debug-type-canonicalization | --debug-tc</b>

              Debug the type canonicalization process.  This is done by
              using structural and canonical equality when
              canonicalizing every single type.  Structural and
              canonical equality should yield the same result.  If they
              don't yield the same result for a given type, then it
              means that the canonicalization of that type went wrong.
              In that case, an error message is emitted and the
              execution of the program is aborted.

              This option is available only if the package was
              configured with the --enable-debug-type-canonicalization
              option.

          • <b>--no-assume-odr-for-cplusplus</b>

            When analysing a binary originating from C++ code using
            <i>DWARF</i> debug information, libabigail assumes the <i>One</i>
            <i>Definition Rule</i> to speed-up the analysis.  In that case,
            when several types have the same name in the binary, they
            are assumed to all be equal.

            This option disables that assumption and instructs
            libabigail to actually actually compare the types to
            determine if they are equal.

          • <b>--no-leverage-dwarf-factorization</b>

            When analysing a binary which <i>DWARF</i> debug information was
            processed with the <i>DWZ</i> tool, the type information is
            supposed to be already factorized.  That context is used by
            libabigail to perform some speed optimizations.

            This option disables those optimizations.

          • <b>--ctf</b>

            Extract ABI information from <i>CTF</i> debug information, if
            present in the given object.

          • <b>--annotate</b>
              Annotate the ABIXML output with comments above most
              elements.  The comments are made of the pretty-printed
              form types, declaration or even ELF symbols.  The purpose
              is to make the ABIXML output more human-readable for
              debugging or documenting purposes.

          • <b>--stats</b>

            Emit statistics about various internal things.

          • <b>--verbose</b>

            Emit verbose logs about the progress of miscellaneous
            internal things.

   <b>Usage examples</b>
          1. Emitting an <b>ABIXML </b>representation of a binary:

                 $ abidw binary &gt; binary.abi

          2. Emitting an <b>ABIXML </b>representation of a set of binaries
             specified on the command line:

                 $ abidw --added-binaries=bin1,bin2,bin3  \
                         --added-binaries-dir /some/where \
                         binary &gt; binaries.abi

             Note that the binaries bin1, bin2 and bin3 are to be found
             in the directory <b>/some/where</b>.  A representation of the ABI
             of the set of binaries <b>binary, bin1, bin2 </b>and <b>bin3 </b>called
             an <b>ABI corpus group </b>is serialized in the file binaries.abi.

          3. Emitting an <b>ABIXML </b>representation of a binary and its
             dependencies:

                 $ abidw --follow-dependencies              \
                         --added-binaries-dir /some/where   \
                         binary &gt; binary.abi

             Note that only the dependencies that are found in the
             directory <b>/some/where </b>are analysed.  Their ABIs, along with
             the ABI the binary named <b>binary </b>are represented as an ABI
             corpus group and serialized in the file <b>binary.abi</b>, in the
             ABIXML format.

   <b>Notes</b>
   <b>Alternate debug info files</b>
       As of the version 4 of the DWARF specification, <i>Alternate debug</i>
       <i>information</i> is a <i>GNU</i> extension to the DWARF specification.  It
       has however been proposed for inclusion into the upcoming version
       5 of the DWARF standard.  You can read more about the GNU
       extensions to the DWARF standard <i>here</i>.

   <b>abidb</b>
       <b>abidb </b>manages a git repository of abixml files describing shared
       libraries, and checks binaries against them.  <b>elfutils </b>and
       <b>libabigail </b>programs are used to query and process the binaries.
       <b>abidb </b>works well with <b>debuginfod </b>to fetch needed DWARF content
       automatically.

   <b>Invocation</b>
          abidb [OPTIONS] [--submit PATH1 PATH2 ...] [--check PATH1 PATH2 ...]

   <b>Common Options</b>
          • <b>--abicompat PATH</b>

            Specify the path to the <b>abicompat </b>program to use.  By
            default, in the absence of this option, the <b>abicompat</b>
            program found in directories listed in the $PATH environment
            is used.

          • <b>--abidw PATH</b>

            Specify the path to the <b>abidw </b>program to use.  By default,
            in the absence of this option, the <b>abidw </b>program found in
            directories listed in the $PATH environment is used.

          • <b>--distrobranch BRANCH</b>

            Specify the git branch for the abixml files in the git repo.
            The default is a string like DISTRO/VERSION/ARCHITECTURE,
            computed from the running environment.

          • <b>--git REPO</b>

            Specify the preexisting git working tree for abidb to submit
            to or check against.  The default is the current working
            directory.  It may be used concurrently by multiple "check"
            operations, but only one "submit" operation.

          • <b>--help | -h</b>

            Display a short help about the command and exit.

          • <b>--loglevel LOGLEVEL</b>

            Specify the diagnostic level for messages to stderr.  One of
            <b>debug</b>, <b>info</b>, <b>warning</b>, <b>error</b>, or <b>critical</b>; case-insensitive.
            The default is <b>info</b>.

          • <b>--timeout SECONDS</b>

            Specify a maximum limit to the execution time (in seconds)
            allowed for the <b>abidw </b>and <b>abicompat </b>programs that are
            executed.  By default, no limit is set for the execution
            time of these programs.

   <b>Submit Options</b>
          • <b>--archive | -Z .EXT[=CMD]</b>

            Designate PATH names with a <b>.EXT </b>suffix to be treated as
            archives.  If <b>CMD </b>is present, pipe the PATH through the
            given shell command, otherwise pass as if through <b>cat</b>.  The
            resulting stream is then opened by <b>libarchive</b>, to enumerate
            the contents of a wide variety of possible archive file
            format.  Process each file in the archive individually into
            abixml.

            For example, <b>-Z .zip </b>will process each file in a zip file,
            and <b>-Z .deb='dpkg-deb --fsys-tarfile' </b>will process each
            payload file in a Debian archive.

          • <b>--filter REGEX</b>

            Limit files selected for abixml extraction to those that
            match the given regular expression.  The default is
            <b>/lib.*\.so</b>, as a heuristic to identify shared libraries.

          • <b>--submit PATH1 PATH2 ...</b>

            Using <b>abidw</b>, extract abixml for each of the listed files,
            generally shared libraries, subject to the filename filter
            and the archive decoding options.  Save the output of each
            <b>abidw </b>run into the selected distrobranch of the selected git
            repo.  If <b>--submit </b>and <b>--check </b>are both given, do submit
            operations first.

          • <b>--sysroot PREFIX </b>Specify the a prefix path that is to be
            removed from submitted file names.

   <b>Check Options</b>
          • <b>--check PATH1 PATH2 ...</b>

            Using <b>abidiff</b>, compare each of the listed file, generally
            executables, against abixml documents for selected versions
            for all shared libraries needed by the executable.  These
            are listed by enumerating the dynamic segment tags <b>DT_NEEDED</b>
            of the executable.

          • <b>--ld-library-path DIR1:DIR2:DIR3...</b>

            Select the search paths for abixml documents used to locate
            any particular <b>SONAME </b>.  The first given directory wins.
            However, all versions of the same <b>SONAME </b>in that directory
            are selected for comparison.  The default is unspecified,
            which means to search for all matching <b>SONAME </b>entries in the
            distrobranch, regardless of specific directory.

   <b>Exit Code</b>
       In case of successful submission and/or checking of all paths,
       the exit code is 0.

       In case of error, the exit code of <b>abidb </b>is nonzero, and a brief
       listing of the binaries unable to be submitted and/or checked is
       printed.

   <b>Git Repository Schema</b>
       <b>abidb </b>stores abixml documents in a git repo with the following
       naming schema within the distrobranch:

       1. The directory path leading to the shared library file

       2. The SONAME of the shared library file, as a subdirectory name

       3. A file named BUILDID.xml, where <b>BUILDID </b>is the hexadecimal ELF
          build-id note of the shared library.

       For example:
┌───────────────────────────┬───────────────────────────────────────────────────────────────────┐
│ shared library file name  │ abixml path in git                                                │
├───────────────────────────┼───────────────────────────────────────────────────────────────────┤
│ /usr/lib64/libc.so.6.2.32 │ /usr/lib64/libc.so.6/788cdd41a15985bf8e0a48d213a46e07d58822df.xml │
│ /usr/lib64/libc.so.6.2.33 │ /usr/lib64/libc.so.6/e2ca832f1c2112aea9d7b9bc639e97e873a6b516.xml │
│ /lib/ld-linux.so.2        │ /lib/ld-linux.so.2/b65f3c15b129f33f44f504da1719926aec03c07d.xml   │
└───────────────────────────┴───────────────────────────────────────────────────────────────────┘

       The intent of including the buildid in the name is so that as a
       distro is updated with multiple versions of a given shared
       library, they can be represented nearby but non-conflicting.  The
       <b>SONAME </b>is used in the second-last name component, inspired the
       behavior of <b>ld.so </b>and <b>ldconfig</b>, which rely on symbolic links to
       map references from the <b>SONAME </b>to an actual file.

   <b>See Also</b>
          • ELF:
            <i><a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">http://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a> </i>

          • DWARF: <i><a href="https://www.dwarfstd.org">https://www.dwarfstd.org</a> </i>

          • Debuginfod: <i><a href="https://sourceware.org/elfutils/Debuginfod.html">https://sourceware.org/elfutils/Debuginfod.html</a> </i>

          • Git: <i><a href="https://git-scm.com/">https://git-scm.com/</a> </i>

          • Libarchive: <i><a href="https://www.libarchive.org/">https://www.libarchive.org/</a> </i>

   <b>abicompat</b>
       abicompat checks that an application that links against a given
       shared library is still ABI compatible with a subsequent version
       of that library.  If the new version of the library introduces an
       ABI incompatibility, then abicompat hints the user at what
       exactly that incompatibility is.

   <b>Invocation</b>
          abicompat [options] [&lt;application&gt; &lt;shared-library-first-version&gt; &lt;shared-library-second-version&gt;]

   <b>Options</b>
          • <b>--help</b>

            Display a short help about the command and exit.

          • <i>--version | -v</i>

            Display the version of the program and exit.

          • <b>--list-undefined-symbols | -u</b>

            Display the list of undefined symbols of the application and
            exit.

          • <b>--show-base-names | -b</b>

            In the resulting report emitted by the tool, this option
            makes the application and libraries be referred to by their
            base names only; not by a full absolute name.  This can be
            useful for use in scripts that wants to compare names of the
            application and libraries independently of what their
            directory names are.

          • <b>--app-debug-info-dir | --appd</b>
            &lt;path-to-app-debug-info-directory&gt;

            Set the path to the directory under which the debug
            information of the application is supposed to be laid out.
            This is useful for application binaries for which the debug
            info is in a separate set of files.

          • <b>--lib-debug-info-dir1 | --libd1 </b>&lt;path-to-lib1-debug-info&gt;

            Set the path to the directory under which the debug
            information of the first version of the shared library is
            supposed to be laid out.  This is useful for shared library
            binaries for which the debug info is in a separate set of
            files.

          • <b>--lib-debug-info-dir2 | --libd2 </b>&lt;path-to-lib1-debug-info&gt;

            Set the path to the directory under which the debug
            information of the second version of the shared library is
            supposed to be laid out.  This is useful for shared library
            binaries for which the debug info is in a separate set of
            files.

          • <b>--suppressions | --suppr </b>&lt;<i>path-to-suppressions</i>&gt;

            Use a <i>suppression specification</i> file located at
            <i>path-to-suppressions</i>.  Note that this option can appear
            multiple times on the command line; all the suppression
            specification files are then taken into account.

          • <b>--no-show-locs</b>
              Do not show information about where in the <i>second shared</i>
              <i>library</i> the respective type was changed.

          • <b>--btf</b>

            When comparing binaries, extract ABI information from BTF
            debug information, if present.

          • <b>--ctf</b>

            When comparing binaries, extract ABI information from CTF
            debug information, if present.

          • <b>--fail-no-debug-info</b>

            If no debug info was found, then this option makes the
            program to fail.  Otherwise, without this option, the
            program will attempt to compare properties of the binaries
            that are not related to debug info, like pure ELF
            properties.

          • <b>--ignore-soname</b>

            Ignore differences in the SONAME when doing a comparison

          • <b>--weak-mode</b>

            This triggers the weak mode of <b>abicompat</b>.  In this mode,
            only one version of the library is required.  That is,
            abicompat is invoked like this:

                abicompat --weak-mode &lt;the-application&gt; &lt;the-library&gt;

            Note that the <b>--weak-mode </b>option can even be omitted if only
            one version of the library is given, along with the
            application; in that case, <b>abicompat </b>automatically switches
            to operate in weak mode:

                abicompat &lt;the-application&gt; &lt;the-library&gt;

            In this weak mode, the types of functions and variables
            exported by the library and consumed by the application (as
            in, the symbols of the these functions and variables are
            undefined in the application and are defined and exported by
            the library) are compared to the version of these types as
            expected by the application.  And if these two versions of
            types are different, <b>abicompat </b>tells the user what the
            differences are.

            In other words, in this mode, <b>abicompat </b>checks that the
            types of the functions and variables exported by the library
            mean the same thing as what the application expects, as far
            as the ABI is concerned.

            Note that in this mode, <i>abicompat</i> doesn't detect exported
            functions or variables (symbols) that are expected by the
            application but that are removed from the library.  That is
            why it is called <b>weak </b>mode.

   <b>Return values</b>
       The exit code of the <b>abicompat </b>command is either 0 if the ABI of
       the binaries being compared are equal, or non-zero if they differ
       or if the tool encountered an error.

       In the later case, the exit code is a 8-bits-wide bit field in
       which each bit has a specific meaning.

       The first bit, of value 1, named <b>ABIDIFF_ERROR </b>means there was an
       error.

       The second bit, of value 2, named <b>ABIDIFF_USAGE_ERROR </b>means there
       was an error in the way the user invoked the tool.  It might be
       set, for instance, if the user invoked the tool with an unknown
       command line switch, with a wrong number or argument, etc.  If
       this bit is set, then the <b>ABIDIFF_ERROR </b>bit must be set as well.

       The third bit, of value 4, named <b>ABIDIFF_ABI_CHANGE </b>means the ABI
       of the binaries being compared are different.

       The fourth bit, of value 8, named <b>ABIDIFF_ABI_INCOMPATIBLE_CHANGE</b>
       means the ABI of the binaries compared are different in an
       incompatible way.  If this bit is set, then the
       <b>ABIDIFF_ABI_CHANGE </b>bit must be set as well.  If the
       <b>ABIDIFF_ABI_CHANGE </b>is set and the <b>ABIDIFF_INCOMPATIBLE_CHANGE </b>is
       <i>NOT</i> set, then it means that the ABIs being compared might or
       might not be compatible.  In that case, a human being needs to
       review the ABI changes to decide if they are compatible or not.

       The remaining bits are not used for the moment.

   <b>Usage examples</b>
          • Detecting a possible ABI incompatibility in a new shared
            library version:

                $ cat -n test0.h
                     1  struct foo
                     2  {
                     3    int m0;
                     4
                     5    foo()
                     6      : m0()
                     7    {}
                     8  };
                     9
                    10  foo*
                    11  first_func();
                    12
                    13  void
                    14  second_func(foo&amp;);
                    15
                    16  void
                    17  third_func();
                $

                $ cat -n test-app.cc
                     1  // Compile with:
                     2  //  g++ -g -Wall -o test-app -L. -ltest-0 test-app.cc
                     3
                     4  #include "test0.h"
                     5
                     6  int
                     7  main()
                     8  {
                     9    foo* f = first_func();
                    10    second_func(*f);
                    11    return 0;
                    12  }
                $

                $ cat -n test0.cc
                     1  // Compile this with:
                     2  //  g++ -g -Wall -shared -o libtest-0.so test0.cc
                     3
                     4  #include "test0.h"
                     5
                     6  foo*
                     7  first_func()
                     8  {
                     9    foo* f = new foo();
                    10    return f;
                    11  }
                    12
                    13  void
                    14  second_func(foo&amp;)
                    15  {
                    16  }
                    17
                    18  void
                    19  third_func()
                    20  {
                    21  }
                $

                $ cat -n test1.h
                     1  struct foo
                     2  {
                     3    int  m0;
                     4    char m1; /* &lt;-- a new member got added here! */
                     5
                     6    foo()
                     7    : m0(),
                     8      m1()
                     9    {}
                    10  };
                    11
                    12  foo*
                    13  first_func();
                    14
                    15  void
                    16  second_func(foo&amp;);
                    17
                    18  void
                    19  third_func();
                $

                $ cat -n test1.cc
                     1  // Compile this with:
                     2  //  g++ -g -Wall -shared -o libtest-1.so test1.cc
                     3
                     4  #include "test1.h"
                     5
                     6  foo*
                     7  first_func()
                     8  {
                     9    foo* f = new foo();
                    10    return f;
                    11  }
                    12
                    13  void
                    14  second_func(foo&amp;)
                    15  {
                    16  }
                    17
                    18  /* Let's comment out the definition of third_func()
                    19     void
                    20     third_func()
                    21     {
                    22     }
                    23  */
                $

            • Compile the first and second versions of the libraries:
              <b>libtest-0.so </b>and <b>libtest-1.so</b>:

                  $ g++ -g -Wall -shared -o libtest-0.so test0.cc
                  $ g++ -g -Wall -shared -o libtest-1.so test1.cc

            • Compile the application and link it against the first
              version of the library, creating the <b>test-app </b>binary:

                  $ g++ -g -Wall -o test-app -L. -ltest-0.so test-app.cc

            • Now, use <b>abicompat </b>to see if libtest-1.so is ABI
              compatible with app, with respect to the ABI of
              libtest-0.so:

                  $ abicompat test-app libtest-0.so libtest-1.so
                  ELF file 'test-app' might not be ABI compatible with 'libtest-1.so' due to differences with 'libtest-0.so' below:
                  Functions changes summary: 0 Removed, 2 Changed, 0 Added functions
                  Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

                  2 functions with some indirect sub-type change:

                    [C]'function foo* first_func()' has some indirect sub-type changes:
                      return type changed:
                        in pointed to type 'struct foo':
                          size changed from 32 to 64 bits
                          1 data member insertion:
                            'char foo::m1', at offset 32 (in bits)
                    [C]'function void second_func(foo&amp;)' has some indirect sub-type changes:
                      parameter 0 of type 'foo&amp;' has sub-type changes:
                        referenced type 'struct foo' changed, as reported earlier

                  $

            • Now use the weak mode of abicompat, that is, providing
              just the application and the new version of the library:

                  $ abicompat --weak-mode test-app libtest-1.so
                  functions defined in library
                      'libtest-1.so'
                  have sub-types that are different from what application
                      'test-app'
                  expects:

                    function foo* first_func():
                      return type changed:
                        in pointed to type 'struct foo':
                          size changed from 32 to 64 bits
                          1 data member insertion:
                            'char foo::m1', at offset 32 (in bits)

                  $

   <b>abilint</b>
       abilint parses the native XML representation of an ABI as emitted
       by <i>abidw</i>.  Once it has parsed the XML representation of the ABI,
       <b>abilint </b>builds and in-memory model from it.  It then tries to
       save it back to an XML form, to standard output.  If that
       read-write operation succeeds chances are the input XML ABI
       representation is meaningful.

       Note that the main intent of this tool to help debugging issues
       in the underlying Libabigail library.

       Note also that <b>abilint </b>can also read an <i>ELF</i> input file, build the
       in-memory model for its ABI, and serialize that model back into
       XML to standard output.  In that case, the <i>ELF</i> input file must be
       accompanied with its debug information in the <i>DWARF</i> format.

   <b>Invocation</b>
          abilint [options] [&lt;abi-file1&gt;]

   <b>Options</b>
          • <b>--annotate</b>

            Annotate the ABIXML output with comments above most
            elements.  The comments are made of the pretty-printed form
            of types, declaration or even ELF symbols.  The purpose is
            to make the ABIXML output more human-readable for debugging
            or documenting purposes.

          • <b>--ctf</b>

            Extract ABI information from CTF debug information, if
            present in the given object.

          • <b>--debug-info-dir </b>&lt;<i>path</i>&gt;

            When reading an <i>ELF</i> input file which debug information is
            split out into a separate file, this options tells <b>abilint</b>
            where to find that separate debug information file.

            Note that <i>path</i> must point to the root directory under which
            the debug information is arranged in a tree-like manner.
            Under Red Hat based systems, that directory is usually
            <b>&lt;root&gt;/usr/lib/debug</b>.

            Note also that this option is not mandatory for split debug
            information installed by your system's package manager
            because then <b>abidiff </b>knows where to find it.

          • <b>--diff</b>

            For XML inputs, perform a text diff between the input and
            the memory model saved back to disk.  This can help to spot
            issues in the handling of the XML format by the underlying
            Libabigail library.

          • <b>--header-file | --hf </b>&lt;header-file-path&gt;

            Specifies where to find one of the public headers of the abi
            file that the tool has to consider.  The tool will thus
            filter out types that are not defined in public headers.

          • <b>--headers-dir | --hd </b>&lt;headers-directory-path-1&gt;

            Specifies where to find the public headers of the first
            shared library that the tool has to consider.  The tool will
            thus filter out types that are not defined in public
            headers.

          • <b>--help</b>

            Display a short help message and exits.

          • <b>--noout</b>

            Do not display anything on standard output.  The return code
            of the command is the only way to know if the command
            succeeded.

          • <b>--suppressions | suppr</b>
            &lt;<i>path-to-suppression-specifications-file</i>&gt;

            Use a <i>suppression specification</i> file located at
            <i>path-to-suppression-specifications-file</i>.  Note that this
            option can appear multiple times on the command line.  In
            that case, all of the provided suppression specification
            files are taken into account.  ABI artifacts matched by the
            suppression specifications are suppressed from the output of
            this tool.

          • <b>--stdin | --</b>

            Read the input content from standard input.

          • <b>--tu</b>

            Expect the input XML to represent a single translation unit.

          • <i>--version | -v</i>

            Display the version of the program and exit.

   <b>fedabipkgdiff</b>
       <b>fedabipkgdiff </b>compares the ABI of shared libraries in <i>Fedora</i>
       packages.  It's a convenient way to do so without having to
       manually download packages from the <i>Fedora Build System</i>.

       <b>fedabipkgdiff </b>knows how to talk with the <i>Fedora Build System</i> to
       find the right packages versions, their associated debug
       information and development packages, download them, compare
       their ABI locally, and report about the possible ABI changes.

       Note that by default, this tool reports ABI changes about types
       that are defined in public header files found in the development
       packages associated with the packages being compared.  It also
       reports ABI changes about functions and global variables whose
       symbols are defined and exported in the ELF binaries found in the
       packages being compared.

   <b>Invocation</b>
          fedabipkgdiff [option] &lt;NVR&gt; ...

   <b>Environment</b>
       fedabipkgdiff loads two default <i>suppression specifications files</i>,
       merges their content and use it to filter out ABI change reports
       that might be considered as false positives to users.

       • Default system-wide suppression specification file

         It's located by the optional environment variable
         LIBABIGAIL_DEFAULT_SYSTEM_SUPPRESSION_FILE.  If that
         environment variable is not set, then fedabipkgdiff tries to
         load the suppression file
         $libdir/libabigail/libabigail-default.abignore.  If that file
         is not present, then no default system-wide suppression
         specification file is loaded.

       • Default user suppression specification file.

         It's located by the optional environment
         LIBABIGAIL_DEFAULT_USER_SUPPRESSION_FILE.  If that environment
         variable is not set, then fedabipkgdiff tries to load the
         suppression file $HOME/.abignore.  If that file is not present,
         then no default user suppression specification is loaded.

   <b>Options</b>
          • <b>--help | -h</b>

            Display a short help about the command and exit.

          • <b>--dry-run</b>

            Don't actually perform the ABI comparison.  Details about
            what is going to be done are emitted on standard output.

          • <b>--debug</b>

            Emit debugging messages about the execution of the program.
            Details about each method invocation, including input
            parameters and returned values, are emitted.

          • <b>--traceback</b>

            Show traceback when an exception raised. This is useful for
            developers of the tool itself to know more exceptional
            errors.

          • <b>--server </b>&lt;URL&gt;

            Specifies the URL of the <i>Koji</i> XMLRPC service the tool talks
            to.  The default value of this option is
            <i><a href="http://koji.fedoraproject.org/kojihub">http://koji.fedoraproject.org/kojihub</a> </i>.

          • <b>--topurl </b>&lt;URL&gt;

            Specifies the URL of the package store the tool downloads
            RPMs from.  The default value of this option is
            <i><a href="https://kojipkgs.fedoraproject.org">https://kojipkgs.fedoraproject.org</a> </i>.

          • <b>--from </b>&lt;distro&gt;

            Specifies the name of the baseline <i>Fedora</i> distribution in
            which to find the first <i>build</i> that is used for comparison.
            The <b>distro </b>value can be any valid value of the RPM macro
            <b>%{?dist} </b>for <i>Fedora</i>, for example, <b>fc4</b>, <b>fc23</b>, <b>fc25</b>.

          • <b>--to </b>&lt;distro&gt;

            Specifies the name of the <i>Fedora</i> distribution in which to
            find the <i>build</i> that is compared against the baseline
            specified by option <b>--from</b>.  The <b>distro </b>value could be any
            valid value of the RPM macro <b>%{?dist} </b>for <i>Fedora</i>, for
            example, <b>fc4</b>, <b>fc23</b>.

          • <b>--all-subpackages</b>

            Instructs the tool to also compare the ABI of the binaries
            in the sub-packages of the packages specified.

          • <b>--dso-only</b>

            Compares the ABI of shared libraries only.  If this option
            is not provided, the tool compares the ABI of all ELF
            binaries found in the packages.

          • <b>--suppressions </b>&lt;<i>path-to-suppresions</i>&gt;

            Use a <i>suppression specification</i> file located at
            <i>path-to-suppressions</i>.

          • <b>--no-default-suppression</b>

            Do not load the <i>default suppression specification files</i>.

          • <b>--no-devel-pkg</b>

            Do not take associated development packages into account
            when performing the ABI comparison.  This makes the tool
            report ABI changes about all types that are reachable from
            functions and global variables which symbols are defined and
            publicly exported in the binaries being compared, even if
            those types are not defined in public header files available
            from the packages being compared.

          • <b>--show-identical-binaries</b>
              Show the names of the all binaries compared, including the
              binaries whose ABI compare equal.  By default, when this
              option is not provided, only binaries with ABI changes are
              mentionned in the output.

          • <b>--abipkgdiff </b>&lt;path/to/abipkgdiff&gt;

            Specify an alternative abipkgdiff instead of the one
            installed in system.

          • <b>--clean-cache-before</b>

            Clean cache before ABI comparison.

          • <b>--clean-cache-after</b>

            Clean cache after ABI comparison.

          • <b>--clean-cache</b>

            If you want to clean cache both before and after ABI
            comparison, <b>--clean-cache </b>is the convenient way for you to
            save typing of two options at same time.

       Note that a build is a specific version and release of an RPM
       package.  It's specified by its the package name, version and
       release. These are specified by the <i>Fedora Naming Guidelines</i>

   <b>Return value</b>
       The exit code of the <b>abipkgdiff </b>command is either 0 if the ABI of
       the binaries compared are equivalent, or non-zero if they differ
       or if the tool encountered an error.

       In the later case, the value of the exit code is the same as for
       the <i>abidiff tool</i>.

   <b>Use cases</b>
       Below are some usage examples currently supported by
       <b>fedabipkgdiff</b>.

          1. Compare the ABI of binaries in a local package against the
             ABI of the latest stable package in <i>Fedora</i> 23.

             Suppose you have built just built the <b>httpd </b>package and you
             want to compare the ABI of the binaries in this locally
             built package against the ABI of the binaries in the latest
             <b>http </b>build from <i>Fedora</i> 23.  The command line invocation
             would be:

                 $ fedabipkgdiff --from fc23 ./httpd-2.4.18-2.fc24.x86_64.rpm

          2. Compare the ABI of binaries in two local packages.

             Suppose you have built two versions of package httpd, and
             you want to see what ABI differences between these two
             versions of RPM files. The command line invocation would
             be:

                 $ fedabipkgdiff path/to/httpd-2.4.23-3.fc23.x86_64.rpm another/path/to/httpd-2.4.23-4.fc24.x86_64.rpm

             All what fedabipkgdiff does happens on local machine
             without the need of querying or downloading RPMs from Koji.

          3. Compare the ABI of binaries in the latest build of the
             <b>httpd </b>package in <b>Fedora 23 </b>against the ABI of the binaries
             in the latest build of the same package in 24.

             In this case, note that neither of the two packages are
             available locally.  The tool is going to talk with the
             <i>Fedora Build System</i>, determine what the versions and
             releases of the latest packages are, download them and
             perform the comparison locally.  The command line
             invocation would be:

                 $ fedabipkgdiff --from fc23 --to fc24 httpd

          4. Compare the ABI of binaries of two builds of the <b>httpd</b>
             package, designated their versions and releases.

             If we want to do perform the ABI comparison for all the
             processor architectures supported by <i>Fedora</i> the command
             line invocation would be:

                 $ fedabipkgdiff httpd-2.8.14.fc23 httpd-2.8.14.fc24

             But if we want to perform the ABI comparison for a specific
             architecture, say, x86_64, then the command line invocation
             would be:

                 $ fedabipkgdiff httpd-2.8.14.fc23.x86_64 httpd-2.8.14.fc24.x86_64

          5. If the use wants to also compare the sub-packages of a
             given package, she can use the --all-subpackages option.
             The first command of the previous example would thus look
             like:

                 $ fedabipkgdiff --all-subpackages httpd-2.8.14.fc23 httpd-2.8.14.fc24
</pre> <h2>
CONCEPTS </h2>
<pre>
   <b>ABI artifacts</b>
       An ABI artifact is a relevant part of the ABI of a shared library
       or program.  Examples of ABI artifacts are exported types,
       variables, functions, or <i>ELF</i> symbols exported by a shared
       library.

       The set of ABI artifact for a binary is called an ABI Corpus.

   <b>Harmful changes</b>
       A change in the diff report is considered harmful if it might
       cause ABI compatibility issues.  That is, it might prevent an
       application dynamically linked against a given version of a
       library to keep working with the changed subsequent versions of
       the same library.

   <b>Harmless changes</b>
       A change in the diff report is considered harmless if it will not
       cause any ABI compatibility issue.  That is, it will not prevent
       an application dynamically linked against given version of a
       library to keep working with the changed subsequent versions of
       the same library.

       By default, <b>abidiff </b>filters harmless changes from the diff
       report.

   <b>Suppression specifications</b>
   <b>Definition</b>
       A suppression specification file is a way for a user to instruct
       <i>abidiff</i>, <i>abipkgdiff</i> or any other relevant libabigail tool to
       avoid emitting reports for changes involving certain <i>ABI</i>
       <i>artifacts</i>.

       It contains directives (or specifications) that describe the set
       of ABI artifacts to avoid emitting change reports about.

   <b>Introductory examples</b>
       Its syntax is based on a simplified and customized form of <i>Ini</i>
       <i>File Syntax</i>.  For instance, to specify that change reports on a
       type named FooPrivateType should be suppressed, one could write
       this suppression specification:

          [suppress_type]
            name = FooPrivateType

       If we want to ensure that only change reports about structures
       named FooPrivateType should be suppressed, we could write:

          [suppress_type]
            type_kind = struct
            name = FooPrivateType

       But we could also want to suppress change reports avoid typedefs
       named FooPrivateType.  In that case we would write:

          [suppress_type]
            type_kind = typedef
            name = FooPrivateType

       Or, we could want to suppress change reports about all struct
       which names end with the string "PrivateType":

          [suppress_type]
            type_kind = struct
            name_regexp = ^.*PrivateType

       Let's now look at the generic syntax of suppression specification
       files.

   <b>Syntax</b>
   <b>Properties</b>
       More generally, the format of suppression lists is organized
       around the concept of <i>property</i>.  Every property has a name and a
       value, delimited by the <b>= </b>sign.  E.g:

          name = value

       Leading and trailing white spaces are ignored around property
       names and values.

   <b>Regular expressions</b>
       The value of some properties might be a regular expression.  In
       that case, they must comply with the syntax of <i>extended POSIX</i>
       <i>regular expressions</i>.  Note that Libabigail uses the regular
       expression engine of the <i>GNU C Library</i>.

   <b>Escaping a character in a regular expression</b>
       When trying to match a string that contains a <b>* </b>character, like
       in the pointer type <b>int*</b>, one must be careful to notice that the
       character <b>* </b>is a special character in the extended POSIX regular
       expression syntax.  And that character must be escaped for the
       regular expression engine.  Thus the regular expression that
       would match the string <b>int* </b>in a suppression file should be

          int\\*

       Wait; but then why the two <b>\ </b>characters?  Well, because the <b>\</b>
       character is a special character in the <i>Ini File Syntax</i> used for
       specifying suppressions.  So it must be escaped as well, so that
       the Ini File parser leaves a <b>\ </b>character intact in the data
       stream that is handed to the regular expression engine.  Hence
       the <b>\\ </b>targeted at the Ini File parser.

       So, in short, to escape a character in a regular expression,
       always prefix the character with the <b>\\ </b>sequence.

   <b>Modus operandi</b>
       Suppression specifications can be applied at two different points
       of the processing pipeline of libabigail.

       In the default operating mode called "late suppression mode",
       suppression specifications are applied to the result of comparing
       the in-memory internal representations of two ABIs.  In this
       mode, if an ABI artifact matches a suppression specification, its
       changes are not mentioned in the ABI change report.  The internal
       representation of the "suppressed" changed ABI artifact is still
       present in memory; it is just not mentioned in the ABI change
       report.  The change report can still mention statistics about the
       number of changed ABI artifacts that were suppressed.

       There is another operating mode called the "early suppression
       mode" where suppression specifications are applied during the
       construction of the in-memory internal representation of a given
       ABI.  In that mode, if an ABI artifact matches a suppression
       specification, no in-memory internal representation is built for
       it.  As a result, no change about the matched ABI artifact is
       going to be mentioned in the ABI change report and no statistic
       about the number of suppressed ABI changes is available.  Also,
       please note that because suppressed ABI artifacts are removed
       from the in-memory internal representation in this mode, the
       amount memory used by the internal representation is potentially
       smaller than the memory consumption in the late suppression mode.

   <b>Sections</b>
       Properties are then grouped into arbitrarily named sections that
       shall not be nested.  The name of the section is on a line by
       itself and is surrounded by square brackets, i.e:

          [section_name]
          property1_name = property1_value
          property2_name = property2_value

       A section might or might not have properties.  Sections that
       expect to have properties and which are found nonetheless empty
       are just ignored.  Properties that are not recognized by the
       reader are ignored as well.

   <b>Section names</b>
       Each different section can be thought of as being a directive to
       suppress ABI change reports for a particular kind of ABI
       artifact.

   <b>[suppress_file]</b>
       This directive prevents a given tool from loading a file (binary
       or abixml file) if its file name or other properties match
       certain properties.  Thus, if the tool is meant to compare the
       ABIs of two files, and if the directive prevents it from loading
       either one of the files, then no comparison is performed.

       Note that for the <b>[suppress_file] </b>directive to work, at least one
       of the following properties must be provided:
          <b>file_name_regexp</b>, <b>file_name_not_regexp</b>, <b>soname_regexp</b>,
          <b>soname_not_regexp</b>.

       If none of the above properties are provided, then the
       <b>[suppress_file] </b>directive is simply ignored.

       The potential properties of this sections are listed below:

       • <b>file_name_not_regexp</b>

         Usage:
            <b>file_name_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Prevents the system from loading the file which name does not
         match the regular expression specified as value of this
         property.

       • <b>file_name_regexp</b>

         Usage:
            <b>file_name_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Prevents the system from loading the file which name matches
         the regular expression specified as value of this property.

       • <b>label</b>
          Usage:
              <b>label = </b>&lt;some-value&gt;

          Define a label for the section.  A label is just an
          informative string that might be used by the tool to refer to
          a type suppression in error messages.  There can also be some
          special label names that make the suppression system behave a
          certain way.

       • <b>soname_regexp</b>

         Usage:
            <b>soname_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Prevents the system from loading the file which contains a
         SONAME property that matches the regular expression of this
         property.  Note that this property also works on an abixml file
         if it contains a SONAME property.

       • <b>soname_not_regexp</b>

         Usage:
            <b>soname_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Prevents the system from loading the file which contains a
         SONAME property that does <i>NOT</i> match the regular expression of
         this property.  Note that this property also works on an abixml
         file if it contains a SONAME property.

   <b>[suppress_type]</b>
       This directive suppresses report messages about a type change.

       Note that for the <b>[suppress_type] </b>directive to work, at least one
       of the following properties must be provided:
          <b>file_name_regexp</b>, <b>file_name_not_regexp</b>, <b>soname_regexp</b>,
          <b>soname_not_regexp</b>, <b>name</b>, <b>name_regexp</b>, <b>name_not_regexp</b>,
          <b>source_location_not_in</b>, <b>source_location_not_regexp</b>, <b>type_kind</b>.

       If none of the above properties are provided, then the
       <b>[suppress_type] </b>directive is simply ignored.

       The potential properties of this sections are listed below:

       • <b>accessed_through</b>
          Usage:
              <b>accessed_through = </b>&lt;some-predefined-values&gt;

          Suppress change reports involving a type which is referred to
          either directly or through a pointer or a reference.  The
          potential values of this property are the predefined keywords
          below:

              • <b>direct</b>

                So if the <b>[suppress_type] </b>contains the property
                description:

                   accessed_through = direct

                then changes about a type that is referred-to directly
                (i.e, not through a pointer or a reference) are going to
                be suppressed.

              • <b>pointer</b>

                If the <b>accessed_through </b>property is set to the value
                <b>pointer </b>then changes about a type that is referred-to
                through a pointer are going to be suppressed.

              • <b>reference</b>

                If the <b>accessed_through </b>property is set to the value
                <b>reference </b>then changes about a type that is referred-to
                through a reference are going to be suppressed.

              • <b>reference-or-pointer</b>

                If the <b>accessed_through </b>property is set to the value
                <b>reference-or-pointer </b>then changes about a type that is
                referred-to through either a reference or a pointer are
                going to be suppressed.

          For an extensive example of how to use this property, please
          check out the example below about <i>suppressing change reports</i>
          <i>about types accessed either directly or through pointers</i>.

       • <b>changed_enumerators</b>

         Usage:
            <b>changed_enumerators = </b>&lt;list-of-enumerators&gt;

         Suppresses change reports involving changes in the value of
         enumerators of a given enum type.  This property is applied if
         the <b>type_kind </b>property is set to the value <b>enum</b>, at least.  The
         value of the <b>changed_enumerators </b>is a comma-separated list of
         the enumerators that the user expects to change.  For instance:

            changed_enumerators = LAST_ENUMERATORS0, LAST_ENUMERATOR1

       • <b>changed_enumerators_regexp</b>

         Usage:
            <b>changed_enumerators_regexp =</b>
            &lt;list-of-enumerator-regular-expressions&gt;

         Suppresses change reports involving changes in the value of
         enumerators of a given enum type.  This property is applied if
         the <b>type_kind </b>property is set to the value <b>enum</b>, at least.  The
         value of the <b>changed_enumerators_regexp </b>property is a
         comma-separated list of regular expressions that should match
         the names of the enumerators that the user expects to change.
         For instance:

            changed_enumerators_regexp = .*_MAX$, .*_LAST$, .*_NUM$, .*_NBITS$

         In the example above, change reports to any enumerator which
         name ends with _MAX, _LAST, _NUM or _NBITS will be suppressed.

         Note that for this property to be applied to changes to an enum
         type, the size of the enum type must <i>NOT</i> have changed.

       • <b>drop</b>
          Usage:
              <b>drop = </b>yes | no

          If a type is matched by a suppression specification which
          contains the "drop" property set to "yes" (or to "true") then
          the type is not even going to be represented in the internal
          representation of the ABI being analyzed.  This property makes
          its enclosing suppression specification to be applied in the
          <i>early suppression specification mode</i>.  The net effect is that
          it potentially reduces the amount of memory used to represent
          the ABI being analyzed.

          Please note that for <b>struct</b>, <b>class </b>or``enum`` types matching a
          suppression specification with this property having a value
          set to "yes" (or to "true"), if the specification also has a
          <b>label </b>property with a value set to
          <b>libabigail::OPAQUE_TYPE_LABEL</b>, then the type is transformed
          into an opaque type, rather than being just dropped on the
          floor.  That also reduces the amount of memory used to
          represent the ABI being analyzed, but with potentially less
          disruption in the resulting ABI representation.

          Please note that for this property to be effective, the
          enclosing suppression specification must have at least one of
          the following properties specified: <b>name_regexp</b>, <b>name</b>,
          <b>name_regexp</b>, <b>source_location_not_in </b>or
          <b>source_location_not_regexp</b>.

       • <b>file_name_not_regexp</b>

         Usage:
            <b>file_name_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a binary file which name does not match the regular
         expression specified as value of this property.

       • <b>file_name_regexp</b>

         Usage:
            <b>file_name_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a binary file which name matches the regular expression
         specified as value of this property.

       • <b>has_data_member</b>

         Usage:
            <b>has_data_member = </b>&lt;<b>list-of-data-member-names</b>&gt;

       Suppresses change reports involving a type which contains data
       members whose names are provided in the list value of this
       property.

       A usage examples of this property would be:

          has_data_member = {private_data_member0, private_data_member1}

       The property above would match any type which contains at least
       two data members whose names are <b>private_data_member0 </b>and
       <b>private_data_member1</b>.

       Another usage examples of this property would be:

          has_data_member = another_private_data_member

       The property above would match any type which contains a data
       member which name is <b>another_private_data_member0</b>.

       • <b>has_data_member_regexp</b>

         Usage:
            <b>has_data_member_regexp = </b>&lt;<b>a-regular-expression</b>&gt;

       Suppresses change reports involving a type which contains data
       members whose names match the regular expression provided as the
       value of this property.

       A usage examples of this property would be:

          has_data_member_regexp = ^private_data_member

       The property above would match any type which contains data
       members whose names match the regular expression
       <b>^private_data_member</b>.  In other words, it would match any type
       which contains data members whose names start with the string
       "private_data_member".

       • <b>has_data_member_inserted_at</b>
          Usage:
              <b>has_data_member_inserted_at = </b>&lt;<b>offset-in-bit</b>&gt;

          Suppresses change reports involving a type which has at least
          one data member inserted at an offset specified by the
          property value <b>offset-in-bit</b>.  Please note that if the size of
          the type changed, then the type change will <i>NOT</i> be suppressed
          by the evaluation of this property, unless the <i>has_size_change</i>
          property is present and set to <b>yes</b>.

          The value <b>offset-in-bit </b>is either:

              • an integer value, expressed in bits, which denotes the
                offset of the insertion point of the data member,
                starting from the beginning of the relevant structure or
                class.

              • data member offset selector expressions, such as:

                   • the keyword <b>end </b>which is a named constant which
                     value equals the offset of the end of the structure
                     or class.

                   • the keyword <b>offset_of_flexible_array_data_member</b>
                     which is a named constant that evaluates to the
                     offset of the flexible array data member contained
                     in the relevant structure.

                   • the function call expression
                     <b>offset_of(data-member-name) </b>where <i>data-member-name</i>
                     is the name of a given data member of the relevant
                     structure or class.  The value of this function
                     call expression is an integer that represents the
                     offset of the data member denoted by
                     <b>data-member-name</b>.

                   • the function call expression
                     <b>offset_after(data-member-name) </b>where
                     <i>data-member-name</i> is the name of a given data member
                     of the relevant structure or class.  The value of
                     this function call expression is an integer that
                     represents the offset of the point that comes right
                     after the region occupied by the data member
                     denoted by <b>data-member-name</b>.

                   • the function call expression
                     <b>offset_of_first_data_member_regexp(data-member-name-regexp)</b>
                     where <i>data-member-name-regexp</i> is a regular
                     expression matching a data member.  The value of
                     this function call expression is an integer that
                     represents the offset of the first data member
                     which name matches the regular expression argument.
                     If no data member of a given class type matches the
                     regular expression, then the class type won't match
                     the current directive.

                   • the function call expression
                     <b>offset_of_last_data_member_regexp(data-member-name-regexp)</b>
                     where <i>data-member-name-regexp</i> is a regular
                     expression matching a data member.  The value of
                     this function call expression is an integer that
                     represents the offset of the last data member which
                     name matches the regular expression argument.  If
                     no data member of a given class type matches the
                     regular expression, then the class type won't match
                     the current directive.

       • <b>has_data_member_inserted_between</b>
          Usage:
              <b>has_data_member_inserted_between = </b>{&lt;<b>range-begin</b>&gt;,
              &lt;<b>range-end</b>&gt;}

          Suppresses change reports involving a type which has at least
          one data member inserted at an offset that is comprised in the
          range between <b>range-begin </b>and <b>range-end</b>.  Please note that
          each of the values <b>range-begin </b>and <b>range-end </b>can be of the
          same form as the <i>has_data_member_inserted_at</i> property above.
          Please also note that if the size of the type changed, then
          the type change will <i>NOT</i> be suppressed by the evaluation of
          this property, unless the <i>has_size_change</i> property is present
          and set to <b>yes</b>.  Note that data member deletions happening in
          the range between <b>range-begin </b>and <b>range-end </b>won't prevent the
          type change from being suppressed by the evaluation of this
          property if the size of the type doesn't change or if the
          <i>has_size_change</i> property is present and set to <b>yes</b>.

          Usage examples of this properties are:

              has_data_member_inserted_between = {8, 64}

          or:

              has_data_member_inserted_between = {16, end}

          or:

              has_data_member_inserted_between = {offset_after(member1), end}

       • <b>has_data_members_inserted_between</b>
          Usage:
              <b>has_data_members_inserted_between = </b>{&lt;sequence-of-ranges&gt;}

          Suppresses change reports involving a type which has multiple
          data member inserted in various offset ranges.  A usage
          example of this property is, for instance:

              has_data_members_inserted_between = {{8, 31}, {72, 95}}

          This usage example suppresses change reports involving a type
          which has data members inserted in bit offset ranges [8 31]
          and [72 95].  The length of the sequence of ranges or this
          <b>has_data_members_inserted_between </b>is not bounded; it can be as
          long as the system can cope with.  The values of the
          boundaries of the ranges are of the same kind as for the
          <i>has_data_member_inserted_at</i> property above.  Please also note
          that if the size of the type changed, then the type will <i>NOT</i>
          be suppressed by the evaluation of this property, unless the
          <i>has_size_change</i> property is present and set to <b>yes</b>.  Note that
          data member deletions happening in the defined ranges won't
          prevent the type change from being suppressed by the
          evaluation of this property if the size of the type doesn't
          change or if the <i>has_size_change</i> property is present and set
          to <b>yes</b>.

          Another usage example of this property is thus:

              has_data_members_inserted_between =
                {
                     {offset_after(member0), offset_of(member1)},
                     {72, end}
                }

       • <b>has_strict_flexible_array_data_member_conversion</b>
          Usage:
              <b>has_strict_flexible_array_data_member_conversion = </b>yes |
              no

          Suppresses change reports involving a type which has a "fake"
          flexible array member at the end of the struct which is
          converted to a real flexible array member. This would be a
          member like <b>data[1] </b>being converted to <b>data[]</b>.

          Please note that if the size of the type changed, then the
          type change will <i>NOT</i> be suppressed by the evaluation of this
          property, unless the <i>has_size_change</i> property is present and
          set to <b>yes</b>.

       • <b>has_size_change</b>
          Usage:
              <b>has_size_change = </b>yes | no

       This property is to be used in conjunction with the properties
       <i>has_data_member_inserted_between</i>,
       <i>has_data_members_inserted_between</i>, and
       <i>has_strict_flexible_array_data_member_conversion</i> Those properties
       will not match a type change if the size of the type changes,
       unless the <b>has_size_changes </b>property is set to <b>yes</b>.

       • <b>label</b>
          Usage:
              <b>label = </b>&lt;some-value&gt;

          Define a label for the section.  In general, a label is just
          an informative string that might be used by a tool to refer to
          a type suppression in error messages.

          Note however that there are some special label values that can
          trigger a special kind of behavior.  Below are those special
          label values:

              • <b>libabigail::OPAQUE_TYPE_LABEL</b>: A struct, class or enum
                type that matches a <b>[suppress_type] </b>section with this
                label property value is going to be replaced by an
                opaque type of the same kind.  Note that an opaque type
                is essentially a declaration-only type, thus with no
                member.  Also note that for a <b>[suppress_type] </b>section
                with this label to trigger the transformation of a type
                into an opaque type, the section must have the <b>drop</b>
                property value set to <b>yes|true</b>.

       • <b>name</b>
          Usage:
              <b>name = </b>&lt;a-value&gt;

          Suppresses change reports involving types whose name equals
          the value of this property.

       • <b>name_not_regexp</b>
          Usage:
              <b>name_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving types whose name does <i>NOT</i>
          match the regular expression specified as value of this
          property.  Said otherwise, this property specifies which types
          to keep, rather than types to suppress from reports.

       • <b>name_regexp</b>
          Usage:
              <b>name_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving types whose name matches
          the regular expression specified as value of this property.

       • <b>soname_not_regexp</b>

         Usage:
            <b>soname_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a shared library which SONAME property does not match the
         regular expression specified as value of this property.

       • <b>soname_regexp</b>

         Usage:
            <b>soname_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a shared library which SONAME property matches the regular
         expression specified as value of this property.

       • <b>source_location_not_in</b>
          Usage:
              <b>source_location_not_in = </b>&lt;<b>list-of-file-paths</b>&gt;

          Suppresses change reports involving a type which is defined in
          a file which path is <i>NOT</i> listed in the value
          <b>list-of-file-paths</b>.  Note that the value is a comma-separated
          list of file paths e.g, this property

              source_location_not_in = libabigail/abg-ir.h, libabigail/abg-dwarf-reader.h

          suppresses change reports about all the types that are <i>NOT</i>
          defined in header files whose path end up with the strings
          libabigail/abg-ir.h or libabigail/abg-dwarf-reader.h.

       • <b>source_location_not_regexp</b>
          Usage:
              <b>source_location_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving a type which is defined in
          a file which path does <i>NOT</i> match the <i>regular expression</i>
          provided as value of the property. E.g, this property

              source_location_not_regexp = libabigail/abg-.*\\.h

          suppresses change reports involving all the types that are <i>NOT</i>
          defined in header files whose path match the regular
          expression provided a value of the property.

       • <b>type_kind</b>
          Usage:

              <b>type_kind = class | struct | union | enum |</b>
                     <b>array </b>| <b>typedef </b>| <b>builtin</b>

          Suppresses change reports involving a certain kind of type.
          The kind of type to suppress change reports for is specified
          by the possible values listed above:

              •

                <b>class: suppress change reports for class types. Note</b>
                <b>that</b>
                       even if class types don't exist for C, this value
                       still triggers the suppression of change reports
                       for struct types, in C.  In C++ however, it
                       should do what it suggests.

              •

                <b>struct: suppress change reports for struct types in C or</b>
                <b>C++.</b>
                       Note that the value <b>class </b>above is a super-set of
                       this one.

              • <b>union</b>: suppress change reports for union types.

              • <b>enum</b>: suppress change reports for enum types.

              • <b>array</b>: suppress change reports for array types.

              • <b>typedef</b>: suppress change reports for typedef types.

              • <b>builtin</b>: suppress change reports for built-in (or
                native) types.  Example of built-in types are char, int,
                unsigned int, etc.

   <b>[suppress_function]</b>
       This directive suppresses report messages about changes on a set
       of functions.

       Note that for the <b>[suppress_function] </b>directive to work, at least
       one of the following properties must be provided:
          <b>label</b>, <b>file_name_regexp</b>, <b>file_name_not_regexp</b>, <b>soname_regexp</b>,
          <b>soname_not_regexp</b>, <b>name</b>, <b>name_regexp</b>, <b>name_not_regexp</b>,
          <b>parameter</b>, <b>return_type_name</b>, <b>return_type_regexp</b>, <b>symbol_name</b>,
          <b>symbol_name_regexp</b>, <b>symbol_name_not_regexp</b>, <b>symbol_version</b>,
          <b>symbol_version_regexp</b>.

       If none of the above properties are provided, then the
       <b>[suppress_function] </b>directive is simply ignored.

       The potential properties of this sections are:

       • <b>change_kind</b>
          Usage:
              <b>change_kind = </b>&lt;predefined-possible-values&gt;

          Specifies the kind of changes this suppression specification
          should apply to.  The possible values of this property as well
          as their meaning are listed below:

              • <b>function-subtype-change</b>

                This suppression specification applies to functions that
                which have at least one sub-type that has changed.

              • <b>added-function</b>

                This suppression specification applies to functions that
                have been added to the binary.

              • <b>deleted-function</b>

                This suppression specification applies to functions that
                have been removed from the binary.

              • <b>all</b>

                This suppression specification applies to functions that
                have all of the changes above.  Note that not providing
                the <b>change_kind </b>property at all is equivalent to setting
                it to the value <b>all</b>.

       • <b>drop</b>
          Usage:
              <b>drop = </b>yes | no

          If a function is matched by a suppression specification which
          contains the "drop" property set to "yes" (or to "true") then
          the function is not even going to be represented in the
          internal representation of the ABI being analyzed.  This
          property makes its enclosing suppression specification to be
          applied in the <i>early suppression specification mode</i>.  The net
          effect is that it potentially reduces the memory used to
          represent the ABI being analyzed.

          Please note that for this property to be effective, the
          enclosing suppression specification must have at least one of
          the following properties specified: <b>name_regexp</b>, <b>name</b>,
          <b>name_regexp</b>, <b>source_location_not_in </b>or
          <b>source_location_not_regexp</b>.

       • <b>file_name_not_regexp</b>

         Usage:
            <b>file_name_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a binary file which name does not match the regular
         expression specified as value of this property.

       • <b>file_name_regexp</b>

         Usage:

         <b>file_name_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a binary file which name matches the regular expression
         specified as value of this property.

       • <b>label</b>
          Usage:
              <b>label = </b>&lt;some-value&gt;

          This property is the same as the <i>label property</i> defined above.

       • <b>name</b>
          Usage:
              <b>name = </b>&lt;some-value&gt;

          Suppresses change reports involving functions whose name
          equals the value of this property.

       • <b>name_not_regexp</b>
          Usage:
              <b>name_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving functions whose names
          don't match the regular expression specified as value of this
          property.

          The rules for functions that have several symbol names are the
          same rules as for the <b>name_regexp </b>property above.

       • <b>name_regexp</b>
          Usage:
              <b>name_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving functions whose name
          matches the regular expression specified as value of this
          property.

          Let's consider the case of functions that have several symbol
          names.  This happens when the underlying symbol for the
          function has aliases.  Each symbol name is actually one alias
          name.

          In this case, if the regular expression matches the name of at
          least one of the aliases names, then it must match the names
          of all of the aliases of the function for the directive to
          actually suppress the diff reports for said function.

       • <b>parameter</b>
          Usage:
              <b>parameter = </b>&lt;function-parameter-specification&gt;

          Suppresses change reports involving functions whose parameters
          match the parameter specification indicated as value of this
          property.

          The format of the function parameter specification is:

          <b>' &lt;parameter-index&gt; &lt;space&gt; &lt;type-name-or-regular-expression&gt;</b>

          That is, an apostrophe followed by a number that is the index
          of the parameter, followed by one of several spaces, followed
          by either the name of the type of the parameter, or a regular
          expression describing a family of parameter type names.

          If the parameter type name is designated by a regular
          expression, then said regular expression must be enclosed
          between two slashes; like <b>/some-regular-expression/</b>.

          The index of the first parameter of the function is zero.
          Note that for member functions (methods of classes), the this
          is the first parameter that comes after the implicit "this"
          pointer parameter.

          Examples of function parameter specifications are:

              '0 int

          Which means, the parameter at index 0, whose type name is <b>int</b>.

              '4 unsigned char*

          Which means, the parameter at index 4, whose type name is
          <b>unsigned char*</b>.

              '2 /^foo.*&amp;/

          Which means, the parameter at index 2, whose type name starts
          with the string "foo" and ends with an '&amp;'.  In other words,
          this is the third parameter and it's a reference on a type
          that starts with the string "foo".

       • <b>return_type_name</b>
          Usage:
              <b>return_type_name = </b>&lt;some-value&gt;

          Suppresses change reports involving functions whose return
          type name equals the value of this property.

       • <b>return_type_regexp</b>
          Usage:
              <b>return_type_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving functions whose return
          type name matches the regular expression specified as value of
          this property.

       • <b>soname_regexp</b>

         Usage:
            <b>soname_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a shared library which SONAME property matches the regular
         expression specified as value of this property.

       • <b>soname_not_regexp</b>

         Usage:
            <b>soname_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a shared library which SONAME property does not match the
         regular expression specified as value of this property.

       • <b>symbol_name</b>
          Usage:
              <b>symbol_name = </b>&lt;some-value&gt;

          Suppresses change reports involving functions whose symbol
          name equals the value of this property.

       • <b>symbol_name_regexp</b>
          Usage:
              <b>symbol_name_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving functions whose symbol
          name matches the regular expression specified as value of this
          property.

          Let's consider the case of functions that have several symbol
          names.  This happens when the underlying symbol for the
          function has aliases.  Each symbol name is actually one alias
          name.

          In this case, the regular expression must match the names of
          all of the aliases of the function for the directive to
          actually suppress the diff reports for said function.

       • <b>symbol_name_not_regexp</b>
          Usage:
              <b>symbol_name_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving functions whose symbol
          name does not match the regular expression specified as value
          of this property.

       • <b>symbol_version</b>
          Usage:
              <b>symbol_version = </b>&lt;some-value&gt;

          Suppresses change reports involving functions whose symbol
          version equals the value of this property.

       • <b>symbol_version_regexp</b>
          Usage:
              <b>symbol_version_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving functions whose symbol
          version matches the regular expression specified as value of
          this property.

   <b>[suppress_variable]</b>
       This directive suppresses report messages about changes on a set
       of variables.

       Note that for the <b>[suppress_variable] </b>directive to work, at least
       one of the following properties must be provided:
          <b>label</b>, <b>file_name_regexp</b>, <b>file_name_not_regexp</b>, <b>soname_regexp</b>,
          <b>soname_not_regexp</b>, <b>name</b>, <b>name_regexp</b>, <b>name_not_regexp</b>,
          <b>symbol_name</b>, <b>symbol_name_regexp</b>, <b>symbol_name_not_regexp</b>,
          <b>symbol_version</b>, <b>symbol_version_regexp</b>, <b>type_name</b>,
          <b>type_name_regexp</b>.

       If none of the above properties are provided, then the
       <b>[suppress_variable] </b>directive is simply ignored.

       The potential properties of this sections are:

       • <b>label</b>
          Usage:
              <b>label = </b>&lt;some-value&gt;

          This property is the same as the <i>label property</i> defined above.

       • <b>file_name_regexp</b>

         Usage:

         <b>file_name_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a binary file which name matches the regular expression
         specified as value of this property.

       • <b>file_name_not_regexp</b>

         Usage:
            <b>file_name_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a binary file which name does not match the regular
         expression specified as value of this property.

       • <b>soname_regexp</b>

         Usage:
            <b>soname_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a shared library which SONAME property matches the regular
         expression specified as value of this property.

       • <b>soname_not_regexp</b>

         Usage:
            <b>soname_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

         Suppresses change reports about ABI artifacts that are defined
         in a shared library which SONAME property does not match the
         regular expression specified as value of this property.

       • <b>name</b>
          Usage:
              <b>name = </b>&lt;some-value&gt;

          Suppresses change reports involving variables whose name
          equals the value of this property.

       • <b>name_regexp</b>
          Usage:
              <b>name_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving variables whose name
          matches the regular expression specified as value of this
          property.

       • <b>change_kind</b>
          Usage:
              <b>change_kind = </b>&lt;predefined-possible-values&gt;

          Specifies the kind of changes this suppression specification
          should apply to.  The possible values of this property as well
          as their meaning are the same as when it's <i>used in the</i>
          <i>[suppress_function] section</i>.

       • <b>symbol_name</b>
          Usage:
              <b>symbol_name = </b>&lt;some-value&gt;

          Suppresses change reports involving variables whose symbol
          name equals the value of this property.

       • symbol_name_regexp
          Usage:
              <b>symbol_name_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving variables whose symbol
          name matches the regular expression specified as value of this
          property.

       • <b>symbol_name_not_regexp</b>
          Usage:
              <b>symbol_name_not_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving variables whose symbol
          name does not match the regular expression specified as value
          of this property.

       • <b>symbol_version</b>
          Usage:
              <b>symbol_version = </b>&lt;some-value&gt;

          Suppresses change reports involving variables whose symbol
          version equals the value of this property.

       • <b>symbol_version_regexp</b>
          Usage:
              <b>symbol_version_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving variables whose symbol
          version matches the regular expression specified as value of
          this property.

       • <b>type_name</b>
          Usage:
              <b>type_name = </b>&lt;some-value&gt;

          Suppresses change reports involving variables whose type name
          equals the value of this property.

       • <b>type_name_regexp</b>
          Usage:
              <b>type_name_regexp = </b>&lt;<i>regular-expression</i>&gt;

          Suppresses change reports involving variables whose type name
          matches the regular expression specified as value of this
          property.

   <b>Comments</b>
       <b>; </b>or <b># </b>ASCII character at the beginning of a line indicates a
       comment.  Comment lines are ignored.

   <b>Code examples</b>
       1. Suppressing change reports about types.

          Suppose we have a library named <b>libtest1-v0.so </b>which contains
          this very useful code:

             $ cat -n test1-v0.cc
                  1  // A forward declaration for a type considered to be opaque to
                  2  // function foo() below.
                  3  struct opaque_type;
                  4
                  5  // This function cannot touch any member of opaque_type.  Hence,
                  6  // changes to members of opaque_type should not impact foo, as far as
                  7  // ABI is concerned.
                  8  void
                  9  foo(opaque_type*)
                 10  {
                 11  }
                 12
                 13  struct opaque_type
                 14  {
                 15    int member0;
                 16    char member1;
                 17  };
             $

       Let's change the layout of struct opaque_type by inserting a data
       member around line 15, leading to a new version of the library,
       that we shall name <b>libtest1-v1.so</b>:

          $ cat -n test1-v1.cc
               1  // A forward declaration for a type considered to be opaque to
               2  // function foo() below.
               3  struct opaque_type;
               4
               5  // This function cannot touch any member of opaque_type;  Hence,
               6  // changes to members of opaque_type should not impact foo, as far as
               7  // ABI is concerned.
               8  void
               9  foo(opaque_type*)
              10  {
              11  }
              12
              13  struct opaque_type
              14  {
              15    char added_member; // &lt;-- a new member got added here now.
              16    int member0;
              17    char member1;
              18  };
          $

       Let's compile both examples.  We shall not forget to compile them
       with debug information generation turned on:

          $ g++ -shared -g -Wall -o libtest1-v0.so test1-v0.cc
          $ g++ -shared -g -Wall -o libtest1-v1.so test1-v1.cc

       Let's ask <i>abidiff</i> which ABI differences it sees between
       <b>libtest1-v0.so </b>and <b>libtest1-v1.so</b>:

          $ abidiff libtest1-v0.so libtest1-v1.so
          Functions changes summary: 0 Removed, 1 Changed, 0 Added function
          Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

          1 function with some indirect sub-type change:

            [C]'function void foo(opaque_type*)' has some indirect sub-type changes:
              parameter 0 of type 'opaque_type*' has sub-type changes:
                in pointed to type 'struct opaque_type':
                  size changed from 64 to 96 bits
                  1 data member insertion:
                    'char opaque_type::added_member', at offset 0 (in bits)
                  2 data member changes:
                   'int opaque_type::member0' offset changed from 0 to 32
                   'char opaque_type::member1' offset changed from 32 to 64

       So <b>abidiff </b>reports that the opaque_type's layout has changed in a
       significant way, as far as ABI implications are concerned, in
       theory.  After all, a sub-type (<b>struct opaque_type</b>) of an
       exported function (<b>foo()</b>) has seen its layout change.  This might
       have non negligible ABI implications.  But in practice here, the
       programmer of the litest1-v1.so library knows that the "soft"
       contract between the function <b>foo() </b>and the type <b>struct</b>
       <b>opaque_type </b>is to stay away from the data members of the type.
       So layout changes of <b>struct opaque_type </b>should not impact <b>foo()</b>.

       Now to teach <b>abidiff </b>about this soft contract and have it avoid
       emitting what amounts to false positives in this case, we write
       the suppression specification file below:

          $ cat test1.suppr
          [suppress_type]
            type_kind = struct
            name = opaque_type

       Translated in plain English, this suppression specification would
       read: "Do not emit change reports about a struct which name is
       opaque_type".

       Let's now invoke <b>abidiff </b>on the two versions of the library
       again, but this time with the suppression specification:

          $ abidiff --suppressions test1.suppr libtest1-v0.so libtest1-v1.so
          Functions changes summary: 0 Removed, 0 Changed (1 filtered out), 0 Added function
          Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

       As you can see, <b>abidiff </b>does not report the change anymore; it
       tells us that it was filtered out instead.

       Suppressing change reports about types with data member
       insertions

       Suppose the first version of a library named <b>libtest3-v0.so </b>has
       this source code:

          /* Compile this with:
               gcc -g -Wall -shared -o libtest3-v0.so test3-v0.c
           */

          struct S
          {
            char member0;
            int member1; /*
                            between member1 and member2, there is some padding,
                            at least on some popular platforms.  On
                            these platforms, adding a small enough data
                            member into that padding shouldn't change
                            the offset of member1.  Right?
                          */
          };

          int
          foo(struct S* s)
          {
            return s-&gt;member0 + s-&gt;member1;
          }

       Now, suppose the second version of the library named
       <b>libtest3-v1.so </b>has this source code in which a data member has
       been added in the padding space of struct S and another data
       member has been added at its end:

          /* Compile this with:
               gcc -g -Wall -shared -o libtest3-v1.so test3-v1.c
           */

          struct S
          {
            char member0;
            char inserted1; /* &lt;---- A data member has been added here...  */
            int member1;
            char inserted2; /* &lt;---- ... and another one has been added here.  */
          };

          int
          foo(struct S* s)
          {
            return s-&gt;member0 + s-&gt;member1;
          }

       In libtest3-v1.so, adding char data members <b>S::inserted1 </b>and
       <b>S::inserted2 </b>can be considered harmless (from an ABI
       compatibility perspective), at least on the x86 platform, because
       that doesn't change the offsets of the data members S::member0
       and S::member1.  But then running <b>abidiff </b>on these two versions
       of library yields:

          $ abidiff libtest3-v0.so libtest3-v1.so
          Functions changes summary: 0 Removed, 1 Changed, 0 Added function
          Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

          1 function with some indirect sub-type change:

            [C]'function int foo(S*)' has some indirect sub-type changes:
              parameter 0 of type 'S*' has sub-type changes:
                in pointed to type 'struct S':
                  type size changed from 64 to 96 bits
                  2 data member insertions:
                    'char S::inserted1', at offset 8 (in bits)
                    'char S::inserted2', at offset 64 (in bits)
          $

       That is, <b>abidiff </b>shows us the two changes, even though we (the
       developers of that very involved library) know that these changes
       are harmless in this particular context.

       Luckily, we can devise a suppression specification that
       essentially tells abidiff to filter out change reports about
       adding a data member between <b>S::member0 </b>and <b>S::member1</b>, and
       adding a data member at the end of struct S.  We have written
       such a suppression specification in a file called test3-1.suppr
       and it unsurprisingly looks like:

          [suppress_type]
            name = S
            has_data_member_inserted_between = {offset_after(member0), offset_of(member1)}
            has_data_member_inserted_at = end

       Now running <b>abidiff </b>with this suppression specification yields:

          $ ../build/tools/abidiff --suppressions test3-1.suppr libtest3-v0.so libtest3-v1.so
          Functions changes summary: 0 Removed, 0 Changed (1 filtered out), 0 Added function
          Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

          $

       Hooora! \o/ (I guess)

       Suppressing change reports about types accessed either directly
       or through pointers

       Suppose we have a first version of an object file which source
       code is the file widget-v0.cc below:

          // Compile with: g++ -g -c widget-v0.cc

          struct widget
          {
            int x;
            int y;

            widget()
              :x(), y()
            {}
          };

          void
          fun0(widget*)
          {
            // .. do stuff here.
          }

          void
          fun1(widget&amp;)
          {
            // .. do stuff here ..
          }

          void
          fun2(widget w)
          {
            // ... do other stuff here ...
          }

       Now suppose in the second version of that file, named
       widget-v1.cc, we have added some data members at the end of the
       type <b>struct widget</b>; here is what the content of that file would
       look like:

          // Compile with: g++ -g -c widget-v1.cc

          struct widget
          {
            int x;
            int y;
            int w; // We have added these two new data members here ..
            int h; // ... and here.

            widget()
              : x(), y(), w(), h()
            {}
          };

          void
          fun0(widget*)
          {
            // .. do stuff here.
          }

          void
          fun1(widget&amp;)
          {
            // .. do stuff here ..
          }

          void
          fun2(widget w)
          {
            // ... do other stuff here ...
          }

       When we invoke <b>abidiff </b>on the object files resulting from the
       compilation of the two file above, here is what we get:

           $ abidiff widget-v0.o widget-v1.o
           Functions changes summary: 0 Removed, 2 Changed (1 filtered out), 0 Added functions
           Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

           2 functions with some indirect sub-type change:

             [C]'function void fun0(widget*)' has some indirect sub-type changes:
               parameter 1 of type 'widget*' has sub-type changes:
                 in pointed to type 'struct widget':
                   type size changed from 64 to 128 bits
                   2 data member insertions:
                     'int widget::w', at offset 64 (in bits)
                     'int widget::h', at offset 96 (in bits)

             [C]'function void fun2(widget)' has some indirect sub-type changes:
               parameter 1 of type 'struct widget' has sub-type changes:
                 details were reported earlier
          $

       I guess a little bit of explaining is due here.  <b>abidiff </b>detects
       that two data member got added at the end of <b>struct widget</b>.  it
       also tells us that the type change impacts the exported function
       <b>fun0() </b>which uses the type <b>struct widget </b>through a pointer, in
       its signature.

       Careful readers will notice that the change to <b>struct widget </b>also
       impacts the exported function <b>fun1()</b>, that uses type <b>struct</b>
       <b>widget </b>through a reference.  But then <b>abidiff </b>doesn't tell us
       about the impact on that function <b>fun1() </b>because it has evaluated
       that change as being <b>redundant </b>with the change it reported on
       <b>fun0()</b>.  It has thus filtered it out, to avoid cluttering the
       output with noise.

       Redundancy detection and filtering is fine and helpful to avoid
       burying the important information in a sea of noise.  However, it
       must be treated with care, by fear of mistakenly filtering out
       relevant and important information.

       That is why <b>abidiff </b>tells us about the impact that the change to
       <b>struct widget </b>has on function <b>fun2()</b>.  In this case, that
       function uses the type <b>struct widget directly </b>(in its signature).
       It does not use it via a pointer or a reference.  In this case,
       the direct use of this type causes <b>fun2() </b>to be exposed to a
       potentially harmful ABI change.  Hence, the report about <b>fun2()</b>
       is not filtered out, even though it's about that same change on
       <b>struct widget</b>.

       To go further in suppressing reports about changes that are
       harmless and keeping only those that we know are harmful, we
       would like to go tell abidiff to suppress reports about this
       particular <b>struct widget </b>change when it impacts uses of <b>struct</b>
       <b>widget </b>through a pointer or reference.  In other words, suppress
       the change reports about <b>fun0() and fun1()</b>.  We would then write
       this suppression specification, in file <b>widget.suppr</b>:

          [suppress_type]
            name = widget
            type_kind = struct
            has_data_member_inserted_at = end
            accessed_through = reference-or-pointer

            # So this suppression specification says to suppress reports about
            # the type 'struct widget', if this type was added some data member
            # at its end, and if the change impacts uses of the type through a
            # reference or a pointer.

       Invoking <b>abidiff </b>on <b>widget-v0.o </b>and <b>widget-v1.o </b>with this
       suppression specification yields:

          $ abidiff --suppressions widget.suppr widget-v0.o widget-v1.o
          Functions changes summary: 0 Removed, 1 Changed (2 filtered out), 0 Added function
          Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

          1 function with some indirect sub-type change:

            [C]'function void fun2(widget)' has some indirect sub-type changes:
              parameter 1 of type 'struct widget' has sub-type changes:
                type size changed from 64 to 128 bits
                2 data member insertions:
                  'int widget::w', at offset 64 (in bits)
                  'int widget::h', at offset 96 (in bits)
          $

       As expected, I guess.

       Suppressing change reports about functions.

       Suppose we have a first version a library named <b>libtest2-v0.so</b>
       whose source code is:

           $ cat -n test2-v0.cc

            1     struct S1
            2     {
            3       int m0;
            4
            5       S1()
            6         : m0()
            7       {}
            8     };
            9
           10     struct S2
           11     {
           12       int m0;
           13
           14       S2()
           15         : m0()
           16       {}
           17     };
           18
           19     struct S3
           20     {
           21       int m0;
           22
           23       S3()
           24         : m0()
           25       {}
           26     };
           27
           28     int
           29     func(S1&amp;)
           30     {
           31       // suppose the code does something with the argument.
           32       return 0;
           33
           34     }
           35
           36     char
           37     func(S2*)
           38     {
           39       // suppose the code does something with the argument.
           40       return 0;
           41     }
           42
           43     unsigned
           44     func(S3)
           45     {
           46       // suppose the code does something with the argument.
           47       return 0;
           48     }
          $

       And then we come up with a second version <b>libtest2-v1.so </b>of that
       library; the source code is modified by making the structures <b>S1</b>,
       <b>S2</b>, <b>S3 </b>inherit another struct:

          $ cat -n test2-v1.cc
                1 struct base_type
                2 {
                3   int m_inserted;
                4 };
                5
                6 struct S1 : public base_type // &lt;--- S1 now has base_type as its base
                7                              // type.
                8 {
                9   int m0;
               10
               11   S1()
               12     : m0()
               13   {}
               14 };
               15
               16 struct S2 : public base_type // &lt;--- S2 now has base_type as its base
               17                              // type.
               18 {
               19   int m0;
               20
               21   S2()
               22     : m0()
               23   {}
               24 };
               25
               26 struct S3 : public base_type // &lt;--- S3 now has base_type as its base
               27                              // type.
               28 {
               29   int m0;
               30
               31   S3()
               32     : m0()
               33   {}
               34 };
               35
               36 int
               37 func(S1&amp;)
               38 {
               39   // suppose the code does something with the argument.
               40   return 0;
               41
               42 }
               43
               44 char
               45 func(S2*)
               46 {
               47   // suppose the code does something with the argument.
               48   return 0;
               49 }
               50
               51 unsigned
               52 func(S3)
               53 {
               54   // suppose the code does something with the argument.
               55   return 0;
               56 }
           $

       Now let's build the two libraries:

          g++ -Wall -g -shared -o libtest2-v0.so test2-v0.cc
          g++ -Wall -g -shared -o libtest2-v0.so test2-v0.cc

       Let's look at the output of <b>abidiff</b>:

          $ abidiff libtest2-v0.so libtest2-v1.so
          Functions changes summary: 0 Removed, 3 Changed, 0 Added functions
          Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

          3 functions with some indirect sub-type change:

            [C]'function unsigned int func(S3)' has some indirect sub-type changes:
              parameter 0 of type 'struct S3' has sub-type changes:
                size changed from 32 to 64 bits
                1 base class insertion:
                  struct base_type
                1 data member change:
                 'int S3::m0' offset changed from 0 to 32

            [C]'function char func(S2*)' has some indirect sub-type changes:
              parameter 0 of type 'S2*' has sub-type changes:
                in pointed to type 'struct S2':
                  size changed from 32 to 64 bits
                  1 base class insertion:
                    struct base_type
                  1 data member change:
                   'int S2::m0' offset changed from 0 to 32

            [C]'function int func(S1&amp;)' has some indirect sub-type changes:
              parameter 0 of type 'S1&amp;' has sub-type changes:
                in referenced type 'struct S1':
                  size changed from 32 to 64 bits
                  1 base class insertion:
                    struct base_type
                  1 data member change:
                   'int S1::m0' offset changed from 0 to 32
          $

       Let's tell <b>abidiff </b>to avoid showing us the differences on the
       overloads of <b>func </b>that takes either a pointer or a reference.
       For that, we author this simple suppression specification:

          $ cat -n libtest2.suppr
               1 [suppress_function]
               2   name = func
               3   parameter = '0 S1&amp;
               4
               5 [suppress_function]
               6   name = func
               7   parameter = '0 S2*
          $

       And then let's invoke <b>abidiff </b>with the suppression specification:

          $ ../build/tools/abidiff --suppressions libtest2.suppr libtest2-v0.so libtest2-v1.so
          Functions changes summary: 0 Removed, 1 Changed (2 filtered out), 0 Added function
          Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

          1 function with some indirect sub-type change:

                 [C]'function unsigned int func(S3)' has some indirect sub-type changes:
                   parameter 0 of type 'struct S3' has sub-type changes:
                     size changed from 32 to 64 bits
                     1 base class insertion:
                       struct base_type
                     1 data member change:
                      'int S3::m0' offset changed from 0 to 32

       The suppression specification could be reduced using <i>regular</i>
       <i>expressions</i>:

          $ cat -n libtest2-1.suppr
                    1   [suppress_function]
                    2     name = func
                    3     parameter = '0 /^S.(&amp;|\\*)/
          $

          $ ../build/tools/abidiff --suppressions libtest2-1.suppr libtest2-v0.so libtest2-v1.so
          Functions changes summary: 0 Removed, 1 Changed (2 filtered out), 0 Added function
          Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

          1 function with some indirect sub-type change:

                 [C]'function unsigned int func(S3)' has some indirect sub-type changes:
                   parameter 0 of type 'struct S3' has sub-type changes:
                     size changed from 32 to 64 bits
                     1 base class insertion:
                       struct base_type
                     1 data member change:
                      'int S3::m0' offset changed from 0 to 32

          $
</pre> <h2>
AUTHOR </h2>
<pre>
       Dodji Seketeli
</pre> <h2>
COPYRIGHT </h2>
<pre>
       2014-2022, Red Hat, Inc.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>libabigail</i> (ABI Generic Analysis and
       Instrumentation Library) project.  Information about the project
       can be found at ⟨<a href="https://sourceware.org/libabigail/">https://sourceware.org/libabigail/</a>⟩.  If you
       have a bug report for this manual page, see
       ⟨<a href="http://sourceware.org/bugzilla/enter_bug.cgi?product=libabigail">http://sourceware.org/bugzilla/enter_bug.cgi?product=libabigail</a>⟩.
       This page was obtained from the project's upstream Git repository
       ⟨git://sourceware.org/git/libabigail.git⟩ on 2024-06-14.  (At
       that time, the date of the most recent commit that was found in
       the repository was 2024-05-31.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">                              Jun 14, 2024                 <i>LIBABIGAIL</i>(7)</span>
</pre>          <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man7/libabigail.7.html" class="_attribution-link">https://man7.org/linux/man-pages/man7/libabigail.7.html</a>
  </p>
</div>
