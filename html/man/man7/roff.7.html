<h1>roff(7) — Linux manual page</h1>   <pre>
<span class="headline"><i>roff</i>(7)             Miscellaneous Information Manual             <i>roff</i>(7)</span>
</pre> <h2>
Name </h2>
<pre>
       roff - concepts and history of <i>roff</i> typesetting
</pre> <h2>
Description </h2>
<pre>
       The term <i>roff</i> denotes a family of document formatting systems
       known by names like <i>troff</i>, <i>nroff</i>, and <i>ditroff</i>.  A <i>roff</i> system
       consists of an interpreter for an extensible text formatting
       language and a set of programs for preparing output for various
       devices and file formats.  Unix-like operating systems often
       distribute a <i>roff</i> system.  The manual pages on Unix systems
       (“man pages”) and bestselling books on software engineering,
       including Brian Kernighan and Dennis Ritchie's <i>The C Programming</i>
       <i>Language</i> and W. Richard Stevens's <i>Advanced Programming in the</i>
       <i>Unix Environment</i>, have been written using <i>roff</i> systems.  GNU
       <i>roff</i>—<i>groff</i>—is arguably the most widespread <i>roff</i> implementation.

       Below we present typographical concepts foundational to
       understanding any <i>roff</i> implementation, narrate the development
       history of some <i>roff</i> systems, detail the command pipeline managed
       by <i>groff</i>(1), survey the formatting language, suggest tips for
       editing <i>roff</i> input, and recommend further reading materials.
</pre> <h2>
Concepts </h2>
<pre>
       <i>roff</i> input files contain text interspersed with instructions to
       control the formatter.  Even in the absence of such instructions,
       a <i>roff</i> formatter still processes its input in several ways, by
       filling, hyphenating, breaking, and adjusting it, and
       supplementing it with inter-sentence space.  These processes are
       basic to typesetting, and can be controlled at the input
       document's discretion.

       When a device-independent <i>roff</i> formatter starts up, it obtains
       information about the device for which it is preparing output
       from the latter's description file (see <i>groff_font</i>(5)).  An
       essential property is the length of the output line, such as “6.5
       inches”.

       The formatter interprets plain text files employing the Unix
       line-ending convention.  It reads input a character at a time,
       collecting words as it goes, and fits as many words together on
       an output line as it can—this is known as <i>filling.</i>  To a <i>roff</i>
       system, a <i>word</i> is any sequence of one or more characters that
       aren't spaces or newlines.  The exceptions separate words.

       A <i>roff</i> formatter attempts to detect boundaries between sentences,
       and supplies additional inter-sentence space between them.  It
       flags certain characters (normally “<b>!</b>”, “<b>?</b>”, and “<b>.</b>”) as
       potentially ending a sentence.  When the formatter encounters one
       of these <i>end-of-sentence characters</i> at the end of an input line,
       or one of them is followed by two (unescaped) spaces on the same
       input line, it appends an inter-word space followed by an inter-
       sentence space in the output.  The dummy character escape
       sequence <b>\&amp; </b>can be used after an end-of-sentence character to
       defeat end-of-sentence detection on a per-instance basis.
       Normally, the occurrence of a visible non-end-of-sentence
       character (as opposed to a space or tab) immediately after an
       end-of-sentence character cancels detection of the end of a
       sentence.  However, several characters are treated <i>transparently</i>
       after the occurrence of an end-of-sentence character.  That is, a
       <i>roff</i> does not cancel end-of-sentence detection when it processes
       them.  This is because such characters are often used as footnote
       markers or to close quotations and parentheticals.  The default
       set is <b>"</b>, <b>'</b>, <b>)</b>, <b>]</b>, <b>*</b>, <b>\[dg]</b>, <b>\[dd]</b>, <b>\[rq]</b>, and <b>\[cq]</b>.  The last
       four are examples of <i>special characters,</i> escape sequences whose
       purpose is to obtain glyphs that are not easily typed at the
       keyboard, or which have special meaning to the formatter (like
       <b>\</b>).

       When an output line is nearly full, it is uncommon for the next
       word collected from the input to exactly fill it—typically, there
       is room left over only for part of the next word.  <i>Hyphenation</i> is
       the process of splitting a word so that it appears partially on
       one line, followed by a hyphen to indicate to the reader that the
       word has been broken, and its remainder on the next.  Hyphenation
       break points can be manually specified; <i>groff</i> also uses a
       hyphenation algorithm and language-specific pattern files to
       decide which words can be hyphenated and where.  Hyphenation does
       not always occur even when the hyphenation rules for a word allow
       it; it can be disabled, and when not disabled there are several
       parameters that can prevent it in certain circumstances.

       Once an output line is full, the next word (or remainder of a
       hyphenated one) is placed on a different output line; this is
       called a <i>break.</i>  In this document and in <i>roff</i> discussions
       generally, a “break” if not further qualified always refers to
       the termination of an output line.  When the formatter is filling
       text, it introduces breaks automatically to keep output lines
       from exceeding the configured line length.  After an automatic
       break, a <i>roff</i> formatter <i>adjusts</i> the line if applicable (see
       below), and then resumes collecting and filling text on the next
       output line.

       Sometimes, a line cannot be broken automatically.  This usually
       does not happen with natural language text unless the output line
       length has been manipulated to be extremely short, but it can
       with specialized text like program source code.  <i>groff</i> provides a
       means of telling the formatter where the line may be broken
       without hyphens.  This is done with the non-printing break point
       escape sequence <b>\:</b>.

       There are several ways to cause a break at a predictable
       location.  A blank input line not only causes a break, but by
       default it also outputs a one-line vertical space (effectively a
       blank output line).  Macro packages may discourage or disable
       this “blank line method” of paragraphing in favor of their own
       macros.  A line that begins with one or more spaces causes a
       break.  The spaces are output at the beginning of the next line
       without being <i>adjusted</i> (see below).  Again, macro packages may
       provide other methods of producing indented paragraphs.  Trailing
       spaces on <i>text lines</i> (see below) are discarded.  The formatter
       flushes any pending output line upon encountering the end of
       input.

       After the formatter performs an automatic break, it may then
       <i>adjust</i> the line, widening inter-word spaces until the text
       reaches the right margin.  Extra spaces between words are
       preserved.  Leading and trailing spaces are handled as noted
       above.  Text can be aligned to the left or right margin only, or
       centered, using <i>requests.</i>

       A <i>roff</i> formatter translates horizontal tab characters, also
       called simply “tabs”, in the input into movements to the next tab
       stop.  Tab stops are by default located every half inch measured
       from the drawing position corresponding to the beginning of the
       input line; see subsection “Page geometry” below.  With them,
       simple tables can be made.  However, this method can be
       deceptive, as the appearance (and width) of the text in an editor
       and the results from the formatter can vary greatly, particularly
       when proportional typefaces are used.  A tab character does not
       cause a break and therefore does not interrupt filling.  The
       formatter provides facilities for sophisticated table
       composition; there are many details to track when using the “tab”
       and “field” low-level features, so most users turn to the <i>tbl</i>(1)
       preprocessor to lay out tables.

   <b>Requests and macros</b>
       A <i>request</i> is an instruction to the formatter that occurs after a
       <i>control character,</i> which is recognized at the beginning of an
       input line.  The regular control character is a dot “<b>.</b>”.  Its
       counterpart, the <i>no-break control character,</i> a neutral apostrophe
       “<b>'</b>”, suppresses the break implied by some requests.  These
       characters were chosen because it is uncommon for lines of text
       in natural languages to begin with them.  If you require a
       formatted period or apostrophe (closing single quotation mark)
       where the formatter is expecting a control character, prefix the
       dot or neutral apostrophe with the dummy character escape
       sequence, “<b>\&amp;</b>”.

       An input line beginning with a control character is called a
       <i>control line.</i>  Every line of input that is not a control line is
       a <i>text line.</i>

       Requests often take <i>arguments,</i> words (separated from the request
       name and each other by spaces) that specify details of the action
       the formatter is expected to perform.  If a request is
       meaningless without arguments, it is typically ignored.  Of key
       importance are the requests that define macros.  Macros are
       invoked like requests, enabling the request repertoire to be
       extended or overridden.

       A <i>macro</i> can be thought of as an abbreviation you can define for a
       collection of control and text lines.  When the macro is <i>called</i>
       by giving its name after a control character, it is replaced with
       what it stands for.  The process of textual replacement is known
       as <i>interpolation.</i>  Interpolations are handled as soon as they are
       recognized, and once performed, a <i>roff</i> formatter scans the
       replacement for further requests, macro calls, and escape
       sequences.  In <i>roff</i> systems, the “<b>de</b>” request defines a macro.

   <b>Page geometry</b>
       <i>roff</i> systems format text under certain assumptions about the size
       of the output medium, or page.  For the formatter to correctly
       break a line it is filling, it must know the line length, which
       it derives from the page width.  For it to decide whether to
       write an output line to the current page or wait until the next
       one, it must know the page length.  A device's <i>resolution</i>
       converts practical units like inches or centimeters to <i>basic</i>
       <i>units,</i> a convenient length measure for the output device or file
       format.  The formatter and output driver use basic units to
       reckon page measurements.  The device description file defines
       its resolution and page dimensions (see <i>groff_font</i>(5)).

       A <i>page</i> is a two-dimensional structure upon which a <i>roff</i> system
       imposes a rectangular coordinate system with its upper left
       corner as the origin.  Coordinate values are in basic units and
       increase down and to the right.  Useful ones are typically
       positive and within numeric ranges corresponding to the page
       boundaries.

       While the formatter (and, later, output driver) is processing a
       page, it keeps track of its <i>drawing position,</i> which is the
       location at which the next glyph will be written, from which the
       next motion will be measured, or where a geometric object will
       commence rendering.  Notionally, glyphs are drawn from the text
       baseline upward and to the right.  (<i>groff</i> does not yet support
       right-to-left scripts.)  The <i>text baseline</i> is a (usually
       invisible) line upon which the glyphs of a typeface are aligned.
       A glyph therefore “starts” at its bottom-left corner.  If drawn
       at the origin, a typical letter glyph would lie partially or
       wholly off the page, depending on whether, like “g”, it features
       a descender below the baseline.

       Such a situation is nearly always undesirable.  It is furthermore
       conventional not to write or draw at the extreme edges of the
       page.  Therefore the initial drawing position of a <i>roff</i> formatter
       is not at the origin, but below and to the right of it.  This
       rightward shift from the left edge is known as the <i>page offset.</i>
       (<i>groff</i>'s terminal output devices have page offsets of zero.)  The
       downward shift leaves room for a text output line.

       Text is arranged on a one-dimensional lattice of text baselines
       from the top to the bottom of the page.  <i>Vertical spacing</i> is the
       distance between adjacent text baselines.  Typographic tradition
       sets this quantity to 120% of the type size.  The initial
       vertical drawing position is one unit of vertical spacing below
       the page top.  Typographers term this unit a <i>vee.</i>

       Vertical spacing has an impact on page-breaking decisions.
       Generally, when a break occurs, the formatter moves the drawing
       position to the next text baseline automatically.  If the
       formatter were already writing to the last line that would fit on
       the page, advancing by one vee would place the next text baseline
       off the page.  Rather than let that happen, <i>roff</i> formatters
       instruct the output driver to eject the page, start a new one,
       and again set the drawing position to one vee below the page top;
       this is a <i>page break.</i>

       When the last line of input text corresponds to the last output
       line that fits on the page, the break caused by the end of input
       will also break the page, producing a useless blank one.  Macro
       packages keep users from having to confront this difficulty by
       setting “traps”; moreover, all but the simplest page layouts tend
       to have headers and footers, or at least bear vertical margins
       larger than one vee.

   <b>Other language elements</b>
       <i>Escape sequences</i> start with the <i>escape character,</i> a backslash <b>\</b>,
       and are followed by at least one additional character.  They can
       appear anywhere in the input.

       With requests, the escape and control characters can be changed;
       further, escape sequence recognition can be turned off and back
       on.

       <i>Strings</i> store character sequences.  In <i>groff</i>, they can be
       parameterized as macros can.

       <i>Registers</i> store numerical values, including measurements.  The
       latter are generally in basic units; <i>scaling units</i> can be
       appended to numeric expressions to clarify their meaning when
       stored or interpolated.  Some read-only predefined registers
       interpolate text.

       <i>Fonts</i> are identified either by a name or by a mounting position
       (a non-negative number).  Four styles are available on all
       devices.  <b>R </b>is “roman”: normal, upright text.  <b>B </b>is <b>bold</b>, an
       upright typeface with a heavier weight.  <b>I </b>is <i>italic</i>, a face that
       is oblique on typesetter output devices and usually underlined
       instead on terminal devices.  <b>BI </b>is <i><b>bold-italic</b></i>, combining both
       of the foregoing style variations.  Typesetting devices group
       these four styles into <i>families</i> of text fonts; they also
       typically offer one or more <i>special</i> fonts that provide unstyled
       glyphs; see <i>groff_char</i>(7).

       <i>groff</i> supports named <i>colors</i> for glyph rendering and drawing of
       geometric objects.  Stroke and fill colors are distinct; the
       stroke color is used for glyphs.

       <i>Glyphs</i> are visual representation forms of <i>characters.</i>  In <i>groff,</i>
       the distinction between those two elements is not always obvious
       (and a full discussion is beyond our scope).  In brief, “A” is a
       character when we consider it in the abstract: to make it a
       glyph, we must select a typeface with which to render it, and
       determine its type size and color.  The formatting process turns
       input characters into output glyphs.  A few characters commonly
       seen on keyboards are treated specially by the <i>roff</i> language and
       may not look correct in output if used unthinkingly; they are the
       (double) quotation mark (<b>"</b>), the neutral apostrophe (<b>'</b>), the
       minus sign (<b>-</b>), the backslash (<b>\</b>), the caret or circumflex accent
       (<b>^</b>), the grave accent (<b>`</b>), and the tilde (<b>~</b>).  All of these and
       more can be produced with <i>special character</i> escape sequences; see
       <i>groff_char</i>(7).

       <i>groff</i> offers <i>streams</i>, identifiers for writable files, but for
       security reasons this feature is disabled by default.

       A further few language elements arise as page layouts become more
       sophisticated and demanding.  <i>Environments</i> collect formatting
       parameters like line length and typeface.  A <i>diversion</i> stores
       formatted output for later use.  A <i>trap</i> is a condition on the
       input or output, tested automatically by the formatter, that is
       associated with a macro, calling it when that condition is
       fulfilled.

       Footnote support often exercises all three of the foregoing
       features.  A simple implementation might work as follows.  A pair
       of macros is defined: one starts a footnote and the other ends
       it.  The author calls the first macro where a footnote marker is
       desired.  The macro establishes a diversion so that the footnote
       text is collected at the place in the body text where its
       corresponding marker appears.  An environment is created for the
       footnote so that it is set at a smaller typeface.  The footnote
       text is formatted in the diversion using that environment, but it
       does not yet appear in the output.  The document author calls the
       footnote end macro, which returns to the previous environment and
       ends the diversion.  Later, after much more body text in the
       document, a trap, set a small distance above the page bottom, is
       sprung.  The macro called by the trap draws a line across the
       page and emits the stored diversion.  Thus, the footnote is
       rendered.
</pre> <h2>
History </h2>
<pre>
       Computer-driven document formatting dates back to the 1960s.  The
       <i>roff</i> system is intimately connected with Unix, but its origins
       lie with the earlier operating systems CTSS, GECOS, and Multics.

   [1mThe predecessor—<i>RUNOFF</i>
       <i>roff</i>'s ancestor <i>RUNOFF</i> was written in the MAD language by Jerry
       Saltzer to prepare his Ph.D. thesis on the Compatible Time
       Sharing System (CTSS), a project of the Massachusetts Institute
       of Technology (MIT).  This program is referred to in full
       capitals, both to distinguish it from its many descendants, and
       because bits were expensive in those days; five- and six-bit
       character encodings were still in widespread usage, and mixed-
       case alphabetics in file names seen as a luxury.  <i>RUNOFF</i>
       introduced a syntax of inlining formatting directives amid
       document text, by beginning a line with a period (an unlikely
       occurrence in human-readable material) followed by a “control
       word”.  Control words with obvious meaning like “.line length <i>n</i>”
       were supported as well as an abbreviation system; the latter came
       to overwhelm the former in popular usage and later derivatives of
       the program.  A sample of control words from a <i>RUNOFF</i> manual of
       December 1966 
       ⟨<a href="http://web.mit.edu/Saltzer/www/publications/ctss/AH.9.01.html">http://web.mit.edu/Saltzer/www/publications/ctss/AH.9.01.html</a>⟩
       was documented as follows (with the parameter notation slightly
       altered).  The abbreviations will be familiar to <i>roff</i> veterans.

                        Abbreviation   Control word
                                 <b>.ad   </b>.adjust
                                 <b>.bp   </b>.begin page
                                 <b>.br   </b>.break
                                 <b>.ce   </b>.center
                                 <b>.in   </b>.indent <i>n</i>
                                 <b>.ll   </b>.line length <i>n</i>
                                 <b>.nf   </b>.nofill
                                 <b>.pl   </b>.paper length <i>n</i>
                                 <b>.sp   </b>.space [<i>n</i>]

       In 1965, MIT's Project MAC teamed with Bell Telephone
       Laboratories and General Electric (GE) to inaugurate the Multics
       ⟨<a href="http://www.multicians.org">http://www.multicians.org</a>⟩ project.  After a few years, Bell
       Labs discontinued its participation in Multics, famously
       prompting the development of Unix.  Meanwhile, Saltzer's <i>RUNOFF</i>
       proved influential, seeing many ports and derivations elsewhere.

       In 1969, Doug McIlroy wrote one such reimplementation, adding
       extensions, in the BCPL language for a GE 645 running GECOS at
       the Bell Labs location in Murray Hill, New Jersey.  In its
       manual, the control commands were termed “requests”, their two-
       letter names were canonical, and the control character was
       configurable with a <b>.cc </b>request.  Other familiar requests emerged
       at this time; no-adjust (<b>.na</b>), need (<b>.ne</b>), page offset (<b>.po</b>), tab
       configuration (<b>.ta</b>, though it worked differently), temporary
       indent (<b>.ti</b>), character translation (<b>.tr</b>), and automatic
       underlining (<b>.ul</b>; on <i>RUNOFF</i> you had to backspace and underscore
       in the input yourself).  <b>.fi </b>to enable filling of output lines
       got the name it retains to this day.  McIlroy's program also
       featured a heuristic system for automatically placing hyphenation
       points, designed and implemented by Molly Wagner.  It furthermore
       introduced numeric variables, termed registers.  By 1971, this
       program had been ported to Multics and was known as <i>roff</i>, a name
       McIlroy attributes to Bob Morris, to distinguish it from CTSS
       <i>RUNOFF</i>.

   [1mUnix and <i>roff</i>
       McIlroy's <i>roff</i> was one of the first Unix programs.  In Ritchie's
       term, it was “transliterated” from BCPL to DEC PDP-7 assembly
       language for the fledgling Unix operating system.  Automatic
       hyphenation was managed with <b>.hc </b>and <b>.hy </b>requests, line spacing
       control was generalized with the <b>.ls </b>request, and what later
       <i>roff</i>s would call diversions were available via “footnote”
       requests.  This <i>roff</i> indirectly funded operating systems research
       at Murray Hill; AT&amp;T prepared patent applications to the U.S.
       government with it.  This arrangement enabled the group to
       acquire a PDP-11; <i>roff</i> promptly proved equal to the task of
       formatting the manual for what would become known as “First
       Edition Unix”, dated November 1971.

       Output from all of the foregoing programs was limited to line
       printers and paper terminals such as the IBM 2471 (based on the
       Selectric line of typewriters) and the Teletype Corporation Model
       37.  Proportionally spaced type was unavailable.

   [1mNew <i>roff</i> and Typesetter <i>roff</i>
       The first years of Unix were spent in rapid evolution.  The
       practicalities of preparing standardized documents like patent
       applications (and Unix manual pages), combined with McIlroy's
       enthusiasm for macro languages, perhaps created an irresistible
       pressure to make <i>roff</i> extensible.  Joe Ossanna's <i>nroff</i>, literally
       a “new roff”, was the outlet for this pressure.  By the time of
       Unix Version 3 (February 1973)—and still in PDP-11 assembly
       language—it sported a swath of features now considered essential
       to <i>roff</i> systems: definition of macros (<b>.de</b>), diversion of text
       thither (<b>.di</b>), and removal thereof (<b>.rm</b>); trap planting (<b>.wh</b>;
       “when”) and relocation (<b>.ch</b>; “change”); conditional processing
       (<b>.if</b>); and environments (<b>.ev</b>).  Incremental improvements included
       assignment of the next page number (<b>.pn</b>); no-space mode (<b>.ns</b>) and
       restoration of vertical spacing (<b>.rs</b>); the saving (<b>.sv</b>) and
       output (<b>.os</b>) of vertical space; specification of replacement
       characters for tabs (<b>.tc</b>) and leaders (<b>.lc</b>); configuration of the
       no-break control character (<b>.c2</b>); shorthand to disable automatic
       hyphenation (<b>.nh</b>); a condensation of what were formerly six
       different requests for configuration of page “titles” (headers
       and footers) into one (<b>.tl</b>) with a length controlled separately
       from the line length (<b>.lt</b>); automatic line numbering (<b>.nm</b>);
       interactive input (<b>.rd</b>), which necessitated buffer-flushing
       (<b>.fl</b>), and was made convenient with early program cessation
       (<b>.ex</b>); source file inclusion in its modern form (<b>.so</b>; though
       <i>RUNOFF</i> had an “.append” control word for a similar purpose) and
       early advance to the next file argument (<b>.nx</b>); ignorable content
       (<b>.ig</b>); and programmable abort (<b>.ab</b>).

       Third Edition Unix also brought the <i>pipe</i>(2) system call, the
       explosive growth of a componentized system based around it, and a
       “filter model” that remains perceptible today.  Equally
       importantly, the Bell Labs site in Murray Hill acquired a Graphic
       Systems C/A/T phototypesetter, and with it came the necessity of
       expanding the capabilities of a <i>roff</i> system to cope with a
       variety of proportionally spaced typefaces at multiple sizes.
       Ossanna wrote a parallel implementation of <i>nroff</i> for the C/A/T,
       dubbing it <i>troff</i> (for “typesetter roff”).  Unfortunately,
       surviving documentation does not illustrate what requests were
       implemented at this time for C/A/T support; the <i>troff</i>(1) man page
       in Fourth Edition Unix (November 1973) does not feature a request
       list, unlike <i>nroff</i>(1).  Apart from typesetter-driven features,
       Unix Version 4 <i>roff</i>s added string definitions (<b>.ds</b>); made the
       escape character configurable (<b>.ec</b>); and enabled the user to
       write diagnostics to the standard error stream (<b>.tm</b>).  Around
       1974, empowered with multiple type sizes, italics, and a symbol
       font specially commissioned by Bell Labs from Graphic Systems,
       Kernighan and Lorinda Cherry implemented <i>eqn</i> for typesetting
       mathematics.  In the same year, for Fifth Edition Unix, Ossanna
       combined and reimplemented the two <i>roff</i>s in C, using that
       language's preprocessor to generate both from a single source
       tree.

       Ossanna documented the syntax of the input language to the <i>nroff</i>
       and <i>troff</i> programs in the “Troff User's Manual”, first published
       in 1976, with further revisions as late as 1992 by Kernighan.
       (The original version was entitled “Nroff/Troff User's Manual”,
       which may partially explain why <i>roff</i> practitioners have tended to
       refer to it by its AT&amp;T document identifier, “CSTR #54”.)  Its
       final revision serves as the <i>de facto</i> specification of AT&amp;T
       <i>troff</i>, and all subsequent implementors of <i>roff</i> systems have done
       so in its shadow.

       A small and simple set of <i>roff</i> macros was first used for the
       manual pages of Unix Version 4 and persisted for two further
       releases, but the first macro package to be formally described
       and installed was <i>ms</i> by Michael Lesk in Version 6.  He also wrote
       a manual, “Typing Documents on the Unix System”, describing <i>ms</i>
       and basic <i>nroff</i>/<i>troff</i> usage, updating it as the package accrued
       features.  Sixth Edition (1975) additionally saw the debut of the
       <i>tbl</i> preprocessor for formatting tables, also by Lesk.

       For Unix Version 7 (January 1979), McIlroy designed, implemented,
       and documented the <i>man</i> macro package, introducing most of the
       macros described in <i>groff_man</i>(7) today, and edited volume 1 of
       the Version 7 manual using it.  Documents composed using <i>ms</i>
       featured in volume 2, edited by Kernighan.

       Meanwhile, <i>troff</i> proved popular even at Unix sites that lacked a
       C/A/T device.  Tom Ferrin of the University of California at San
       Francisco combined it with Allen Hershey's popular vector fonts
       to produce <i>vtroff</i>, which translated <i>troff</i>'s output to the command
       language used by Versatec and Benson-Varian plotters.

       Ossanna had passed away unexpectedly in 1977, and after the
       release of Version 7, with the C/A/T typesetter becoming
       supplanted by alternative devices such as the Mergenthaler
       Linotron 202, Kernighan undertook a revision and rewrite of <i>troff</i>
       to generalize its design.  To implement this revised
       architecture, he developed the font and device description file
       formats and the page description language that remain in use
       today.  He described these novelties in the article “A
       Typesetter-independent TROFF”, last revised in 1982, and like the
       <i>troff</i> manual itself, it is widely known by a shorthand, “CSTR
       #97”.

       Kernighan's innovations prepared <i>troff</i> well for the introduction
       of the Adobe PostScript language in 1982 and a vibrant market in
       laser printers with built-in interpreters for it.  An output
       driver for PostScript, <i>dpost</i>, was swiftly developed.  However,
       AT&amp;T's software licensing practices kept Ossanna's <i>troff</i>, with
       its tight coupling to the C/A/T's capabilities, in parallel
       distribution with device-independent <i>troff</i> throughout the 1980s.
       Today, however, all actively maintained <i>troff</i>s follow Kernighan's
       device-independent design.

   [1mgroff[24m—a free <i>roff</i> from GNU
       The most important free <i>roff</i> project historically has been <i>groff</i>,
       the GNU implementation of <i>troff</i>, developed by James Clark
       starting in 1989 and distributed under copyleft 
       ⟨<a href="http://www.gnu.org/copyleft">http://www.gnu.org/copyleft</a>⟩ licenses, ensuring to all the
       availability of source code and the freedom to modify and
       redistribute it, properties unprecedented in <i>roff</i> systems to that
       point.  <i>groff</i> rapidly attracted contributors, and has served as a
       replacement for almost all applications of AT&amp;T <i>troff</i> (exceptions
       include <i>mv</i>, a macro package for preparation of viewgraphs and
       slides, and the <i>ideal</i> preprocessor, which produces diagrams from
       mathematical constraints).  Beyond that, it has added numerous
       features; see <i>groff_diff</i>(7).  Since its inception and for at
       least the following three decades, it has been used by
       practically all GNU/Linux and BSD operating systems.

       <i>groff</i> continues to be developed, is available for almost all
       operating systems in common use (along with several obscure
       ones), and is free.  These factors make <i>groff</i> the <i>de facto roff</i>
       standard today.

   <b>Other free <i>roff</i>s</b>
       In 2007, Caldera/SCO and Sun Microsystems, having acquired rights
       to AT&amp;T Documenter's Workbench (DWB) <i>troff</i> (a descendant of Bell
       Labs device-independent <i>troff</i>), released it under a free but GPL-
       incompatible license.  This implementation 
       ⟨<a href="https://github.com/n-t-roff/DWB3.3">https://github.com/n-t-roff/DWB3.3</a>⟩ was made portable to modern
       POSIX systems.  Gunnar Ritter and later Carsten Kunze then
       enhanced it to produce Heirloom Doctools <i>troff</i> 
       ⟨<a href="https://github.com/n-t-roff/heirloom-doctools">https://github.com/n-t-roff/heirloom-doctools</a>⟩.

       In July 2013, Ali Gholami Rudi announced <i>neatroff</i> 
       ⟨<a href="https://github.com/aligrudi/neatroff">https://github.com/aligrudi/neatroff</a>⟩, a permissively licensed
       new implementation.

       Another descendant of DWB <i>troff</i> is part of Plan 9 from User Space
       ⟨<a href="https://9fans.github.io/plan9port/">https://9fans.github.io/plan9port/</a>⟩.  Since 2021, this <i>troff</i> has
       been available under permissive terms.
</pre> <h2>
Using <i>roff</i> </h2>
<pre>
       When you read a man page, often a <i>roff</i> is the program rendering
       it.  Some <i>roff</i> implementations provide wrapper programs that make
       it easy to use the <i>roff</i> system from the shell's command line.
       These can be specific to a macro package, like <i>mmroff</i>(1), or more
       general.  <i>groff</i>(1) provides command-line options sparing the user
       from constructing the long, order-dependent pipelines familiar to
       AT&amp;T <i>troff</i> users.  Further, a heuristic program, <i>grog</i>(1), is
       available to infer from a document's contents which <i>groff</i>
       arguments should be used to process it.

   <b>The <i>roff</i> pipeline</b>
       A typical <i>roff</i> document is prepared by running one or more
       processors in series, followed by a a formatter program and then
       an output driver (or “device postprocessor”).  Commonly, these
       programs are structured into a pipeline; that is, each is run in
       sequence such that the output of one is taken as the input to the
       next, without passing through secondary storage.  (Non-Unix
       systems may simulate pipelines with temporary files.)

              $ <i>preproc1</i> <b>&lt; </b><i>input-file</i> <b>| </b><i>preproc2</i> <b>| </b>... <b>| troff </b>[<i>option</i>] ... <b>\</b>
                  <b>| </b><i>output-driver</i>

       Once all preprocessors have run, they deliver pure <i>roff</i> language
       input to the formatter, which in turn generates a document in a
       page description language that is then interpreted by a
       postprocessor for viewing, printing, or further handling.

       Each program interprets input in a language that is independent
       of the others; some are purely descriptive, as with <i>tbl</i>(1) and
       <i>roff</i> output, and some permit the definition of macros, as with
       <i>eqn</i>(1) and <i>roff</i> input.  Most <i>roff</i> input files employ the macros
       of a document formatting package, intermixed with instructions
       for one or more preprocessors, and are seasoned with escape
       sequences and requests from the <i>roff</i> language.  Some documents
       are simpler still, since their formatting packages discourage
       direct use of <i>roff</i> requests; man pages are a prominent example.
       Many features of the <i>roff</i> language are seldom needed by users;
       only authors of macro packages require a substantial command of
       them.

   <b>Preprocessors</b>
       A <i>roff</i> preprocessor is a program that, directly or ultimately,
       generates output in the <i>roff</i> language.  Typically, each
       preprocessor defines a language of its own that transforms its
       input into that for <i>roff</i> or another preprocessor.  As an example
       of the latter, <i>chem</i> produces <i>pic</i> input.  Preprocessors must
       consequently be run in an appropriate order; <i>groff</i>(1) handles
       this automatically for all preprocessors supplied by the GNU <i>roff</i>
       system.

       Portions of the document written in preprocessor languages are
       usually bracketed by tokens that look like <i>roff</i> macro calls.
       <i>roff</i> preprocessor programs transform only the regions of the
       document intended for them.  When a preprocessor language is used
       by a document, its corresponding program must process it before
       the input is seen by the formatter, or incorrect rendering is
       almost guaranteed.

       GNU <i>roff</i> provides several preprocessors, including <i>eqn</i>, <i>grn</i>, <i>pic</i>,
       <i>tbl</i>, <i>refer</i>, and <i>soelim</i>.  See <i>groff</i>(1) for a complete list.  Other
       preprocessors for <i>roff</i> systems are known.

              <i>dformat</i>   depicts data structures;
              <i>grap</i>      constructs statistical charts; and
              <i>ideal</i>     draws diagrams using a constraint-based language.

   <b>Formatter programs</b>
       A <i>roff</i> formatter transforms <i>roff</i> language input into a single
       file in a page description language, described in <i>groff_out</i>(5),
       intended for processing by a selected device.  This page
       description language is specialized in its parameters, but not
       its syntax, for the selected device; the format is device-
       <i>independent</i>, but not device-<i>agnostic</i>.  The parameters the
       formatter uses to arrange the document are stored in <i>device</i> and
       <i>font description files</i>; see <i>groff_font</i>(5).

       AT&amp;T Unix had two formatters—<i>nroff</i> for terminals, and <i>troff</i> for
       typesetters.  Often, the name <i>troff</i> is used loosely to refer to
       both.  When generalizing thus, <i>groff</i> documentation prefers the
       term “<i>roff</i>”.  In GNU <i>roff</i>, the formatter program is always
       <i>troff</i>(1).

   <b>Devices and output drivers</b>
       To a <i>roff</i> system, a <i>device</i> is a hardware interface like a
       printer, a text or graphical terminal, or a standardized file
       format that unrelated software can interpret.  An <i>output driver</i>
       is a program that parses the output of <i>troff</i> and produces
       instructions specific to the device or file format it supports.
       An output driver might support multiple devices, particularly if
       they are similar.

       The names of the devices and their driver programs are not
       standardized.  Technological fashions evolve; the devices popular
       for document preparation when AT&amp;T <i>troff</i> was first written in the
       1970s are no longer used in production environments.  Device
       capabilities have tended to increase, improving resolution and
       font repertoire, and adding color output and hyperlinking.
       Further, to reduce file size and processing time, AT&amp;T <i>troff</i>'s
       page description language placed low limits on the magnitudes of
       some quantities it could represent.  Its PostScript output
       driver, <i>dpost</i>(1), had a resolution of 720 units per inch; <i>groff</i>'s
       <i>grops</i>(1) uses 72,000.
</pre> <i><h2>roff</h2></i> programming <pre>
       Documents using <i>roff</i> are normal text files interleaved with <i>roff</i>
       formatting elements.  The <i>roff</i> language is powerful enough to
       support arbitrary computation and it supplies facilities that
       encourage extension.  The primary such facility is macro
       definition; with this feature, macro packages have been developed
       that are tailored for particular applications.

   <b>Macro packages</b>
       Macro packages can have a much smaller vocabulary than <i>roff</i>
       itself; this trait combined with their domain-specific nature can
       make them easy to acquire and master.  The implementation of a
       package <i>name</i> is typically kept in a file called “name<i>.tmac</i>”
       (historically, “<i>tmac.</i>name”).  Find details on the naming and
       placement of macro packages in <i>groff_tmac</i>(5).

       A macro package anticipated for use in a document can be declared
       to the formatter by the command-line option <b>-m</b>; see <i>troff</i>(1).  It
       can alternatively be specified within a document using the <b>mso</b>
       request of the <i>groff</i> language; see <i>groff</i>(7).

       Well-known macro packages include <i>man</i> for traditional man pages
       and <i>mdoc</i> for BSD-style manual pages.  Macro packages for
       typesetting books, articles, and letters include <i>ms</i> (from
       “manuscript macros”), <i>me</i> (named by a system administrator from
       the first name of its creator, Eric Allman), <i>mm</i> (from “memorandum
       macros”), and <i>mom</i>, a punningly named package exercising many
       <i>groff</i> extensions.  See <i>groff_tmac</i>(5) for more.

   <b>The <i>roff</i> formatting language</b>
       The <i>roff</i> language provides requests, escape sequences, macro
       definition facilities, string variables, registers for storage of
       numbers or dimensions, and control of execution flow.  The
       theoretically minded will observe that a <i>roff</i> is not a mere
       markup language, but Turing-complete.  It has storage
       (registers), it can perform tests (as in conditional expressions
       like “<b>(\n[i] &gt;= 1)</b>”), its “<b>if</b>” and related requests alter the
       flow of control, and macro definition permits unbounded
       recursion.

       <i>Requests</i> and <i>escape sequences</i> are instructions, predefined parts
       of the language, that perform formatting operations, interpolate
       stored material, or otherwise change the state of the parser.
       The user can define their own request-like elements by composing
       together text, requests, and escape sequences <i>ad libitum.</i>  A
       document writer will not (usually) note any difference in usage
       for requests or macros; both are found on control lines.
       However, there is a distinction; requests take either a fixed
       number of arguments (sometimes zero), silently ignoring any
       excess, or consume the rest of the input line, whereas macros can
       take a variable number of arguments.  Since arguments are
       separated by spaces, macros require a means of embedding a space
       in an argument; in other words, of quoting it.  This then demands
       a mechanism of embedding the quoting character itself, in case <i>it</i>
       is needed literally in a macro argument.  AT&amp;T <i>troff</i> had complex
       rules involving the placement and repetition of the double quote
       to achieve both aims.  <i>groff</i> cuts this knot by supporting a
       special character escape sequence for the neutral double quote,
       “<b>\[dq]</b>”, which never performs quoting in the typesetting
       language, but is simply a glyph, ‘<b>"</b>’.

       <i>Escape sequences</i> start with a backslash, “<b>\</b>”.  They can appear
       almost anywhere, even in the midst of text on a line, and
       implement various features, including the insertion of special
       characters with “<b>\(<i>xx</i></b>” or “<b>\[<i>xxx</i>]</b>”, break suppression at input
       line endings with “<b>\c</b>”, font changes with “<b>\f</b>”, type size changes
       with “<b>\s</b>”, in-line comments with “<b>\"</b>”, and many others.

       <i>Strings</i> store text.  They are populated with the <b>ds </b>request and
       interpolated using the <b>\* </b>escape sequence.

       <i>Registers</i> store numbers and measurements.  A register can be set
       with the request <b>nr </b>and its value can be retrieved by the escape
       sequence <b>\n</b>.
</pre> <h2>
File naming conventions </h2>
<pre>
       The structure or content of a file name, beyond its location in
       the file system, is not significant to <i>roff</i> tools.  <i>roff</i>
       documents employing “full-service” macro packages (see
       <i>groff_tmac</i>(5)) tend to be named with a suffix identifying the
       package; we thus see file names ending in <i>.man</i>, <i>.ms</i>, <i>.me</i>, <i>.mm</i>,
       and <i>.mom</i>, for instance.  When installed, man pages tend to be
       named with the manual's section number as the suffix.  For
       example, the file name for this document is <i>roff.7</i>.  Practice for
       “raw” <i>roff</i> documents is less consistent; they are sometimes seen
       with a <i>.t</i> suffix.
</pre> <h2>
Input conventions </h2>
<pre>
       Since <i>troff</i> fills text automatically, it is common practice in
       the <i>roff</i> language to avoid visual composition of text in input
       files: the esthetic appeal of the formatted output is what
       matters.  Therefore, <i>roff</i> input should be arranged such that it
       is easy for authors and maintainers to compose and develop the
       document, understand the syntax of <i>roff</i> requests, macro calls,
       and preprocessor languages used, and predict the behavior of the
       formatter.  Several traditions have accrued in service of these
       goals.

       •  Follow sentence endings in the input with newlines to ease
          their recognition.  It is frequently convenient to end text
          lines after colons and semicolons as well, as these typically
          precede independent clauses.  Consider doing so after commas;
          they often occur in lists that become easy to scan when
          itemized by line, or constitute supplements to the sentence
          that are added, deleted, or updated to clarify it.
          Parenthetical and quoted phrases are also good candidates for
          placement on text lines by themselves.

       •  Set your text editor's line length to 72 characters or fewer;
          see the subsections below.  This limit, combined with the
          previous item of advice, makes it less common that an input
          line will wrap in your text editor, and thus will help you
          perceive excessively long constructions in your text.  Recall
          that natural languages originate in speech, not writing, and
          that punctuation is correlated with pauses for breathing and
          changes in prosody.

       •  Use <b>\&amp; </b>after “<b>!</b>”, “<b>?</b>”, and “<b>.</b>” if they are followed by space,
          tab, or newline characters and don't end a sentence.

       •  In filled text lines, use <b>\&amp; </b>before “<b>.</b>” and “<b>'</b>” if they are
          preceded by space, so that reflowing the input doesn't turn
          them into control lines.

       •  Do not use spaces to perform indentation or align columns of a
          table.  Leading spaces are reliable when text is not being
          filled.

       •  Comment your document.  It is never too soon to apply comments
          to record information of use to future document maintainers
          (including your future self).  The <b>\" </b>escape sequence causes
          <i>troff</i> to ignore the remainder of the input line.

       •  Use the empty request—a control character followed immediately
          by a newline—to visually manage separation of material in
          input files.  Many of the <i>groff</i> project's own documents use an
          empty request between sentences, after macro definitions, and
          where a break is expected, and two empty requests between
          paragraphs or other requests or macro calls that will
          introduce vertical space into the document.  You can combine
          the empty request with the comment escape sequence to include
          whole-line comments in your document, and even “comment out”
          sections of it.

       An example sufficiently long to illustrate most of the above
       suggestions in practice follows.  An arrow → indicates a tab
       character.

              .\"   nroff this_file.roff | less
              .\"   groff -T ps this_file.roff &gt; this_file.ps
              →The theory of relativity is intimately connected with
              the theory of space and time.
              .
              I shall therefore begin with a brief investigation of
              the origin of our ideas of space and time,
              although in doing so I know that I introduce a
              controversial subject.  \" remainder of paragraph elided
              .
              .

              →The experiences of an individual appear to us arranged
              in a series of events;
              in this series the single events which we remember
              appear to be ordered according to the criterion of
              \[lq]earlier\[rq] and \[lq]later\[rq], \" punct swapped
              which cannot be analysed further.
              .
              There exists,
              therefore,
              for the individual,
              an I-time,
              or subjective time.
              .
              This itself is not measurable.
              .
              I can,
              indeed,
              associate numbers with the events,
              in such a way that the greater number is associated with
              the later event than with an earlier one;
              but the nature of this association may be quite
              arbitrary.
              .
              This association I can define by means of a clock by
              comparing the order of events furnished by the clock
              with the order of a given series of events.
              .
              We understand by a clock something which provides a
              series of events which can be counted,
              and which has other properties of which we shall speak
              later.
              .\" Albert Einstein, _The Meaning of Relativity_, 1922

   <b>Editing with Emacs</b>
       Official GNU doctrine holds that the best program for editing a
       <i>roff</i> document is Emacs; see <i>emacs</i>(1).  It provides an <i>nroff</i> major
       mode that is suitable for all kinds of <i>roff</i> dialects.  This mode
       can be activated by the following methods.

       When editing a file within Emacs the mode can be changed by
       typing “<i>M-x</i> <b>nroff-mode</b>”, where <i>M-x</i> means to hold down the meta
       key (often labelled “Alt”) while pressing and releasing the “x”
       key.

       It is also possible to have the mode automatically selected when
       a <i>roff</i> file is loaded into the editor.

       •  The most general approach includes file-local variables at the
          end of the file; we can also configure the fill column this
          way.
                 .\" Local Variables:
                 .\" fill-column: 72
                 .\" mode: nroff
                 .\" End:

       •  Certain file name extensions, like those often used by man
          pages, activate <i>nroff</i> mode automatically.

       •  Loading a file with the sequence
                 .\" -*- nroff -*-
          in its first line into an Emacs buffer causes the editor to
          enter its <i>nroff</i> major mode.  Unfortunately, some
          implementations of the <i>man</i>(1) program are confused by this
          practice, so we discourage it.

   <b>Editing with Vim</b>
       Other editors provide support for <i>roff</i>-style files too, such as
       <i>vim</i>(1), an extension of the <i>vi</i>(1) program.  Vim's highlighting
       can be made to recognize <i>roff</i> files by setting the <b>filetype</b>
       option in a Vim <i>modeline</i>.  For this feature to work, your copy of
       <i>vim</i> must be built with support for, and configured to enable,
       several features; consult the editor's online help topics
       “auto-setting”, “filetype”, and “syntax”.  Then put the following
       at the end of your <i>roff</i> files, after any Emacs configuration.

                     .\" vim: set filetype=groff textwidth=72:

       Replace “groff” in the above with “nroff” if you want
       highlighting that does <i>not</i> recognize many of the GNU extensions
       to <i>roff</i>, such as request, register, and string names longer than
       two characters.
</pre> <h2>
Authors </h2>
<pre>
       This document was written by Bernd Warken ⟨groff-bernd.warken-72@
       web.de⟩ and G. Branden Robinson ⟨g.branden.robinson@gmail.com⟩.
</pre> <h2>
See also </h2>
<pre>
       Much <i>roff</i> documentation is available.  The Bell Labs papers
       describing AT&amp;T <i>troff</i> remain available, and <i>groff</i> is documented
       comprehensively.

   <b>Internet sites</b>
       <i>Unix Text Processing</i> 
       ⟨<a href="https://github.com/larrykollar/Unix-Text-Processing">https://github.com/larrykollar/Unix-Text-Processing</a>⟩, by Dale
       Dougherty and Tim O'Reilly, 1987, Hayden Books.  This well-
       regarded text brings the reader from a state of no knowledge of
       Unix or text editing (if necessary) to sophisticated computer-
       aided typesetting.  It has been placed under a free software
       license by its authors and updated by a team of <i>groff</i>
       contributors and enthusiasts.

       “History of Unix Manpages” ⟨<a href="http://manpages.bsd.lv/history.html">http://manpages.bsd.lv/history.html</a>⟩,
       an online article maintained by the mdocml project, provides an
       overview of <i>roff</i> development from Saltzer's <i>RUNOFF</i> to 2008, with
       links to original documentation and recollections of the authors
       and their contemporaries.

       troff.org ⟨<a href="http://www.troff.org/">http://www.troff.org/</a>⟩, Ralph Corderoy's <i>troff</i> site,
       provides an overview and pointers to much historical <i>roff</i>
       information.

       Multicians ⟨<a href="http://www.multicians.org/">http://www.multicians.org/</a>⟩, a site by Multics
       enthusiasts, contains a lot of information on the MIT projects
       CTSS and Multics, including <i>RUNOFF</i>; it is especially useful for
       its glossary and the many links to historical documents.

       The Unix Archive ⟨<a href="http://www.tuhs.org/Archive/">http://www.tuhs.org/Archive/</a>⟩, curated by the
       Unix Heritage Society, provides the source code and some binaries
       of historical Unices (including the source code of some versions
       of <i>troff</i> and its documentation) contributed by their copyright
       holders.

       Jerry Saltzer's home page 
       ⟨<a href="http://web.mit.edu/Saltzer/www/publications/pubs.html">http://web.mit.edu/Saltzer/www/publications/pubs.html</a>⟩ stores
       some documents using the original <i>RUNOFF</i> formatting language.

       <i>groff</i> ⟨<a href="http://www.gnu.org/software/groff">http://www.gnu.org/software/groff</a>⟩, GNU <i>roff</i>'s web site,
       provides convenient access to <i>groff</i>'s source code repository, bug
       tracker, and mailing lists (including archives and the
       subscription interface).

   <b>Historical <i>roff</i> documentation</b>
       Many AT&amp;T <i>troff</i> documents are available online, and can be found
       at Ralph Corderoy's site (see above) or via Internet search.  Of
       foremost significance are those describing the language and its
       device-independent implementation.

       “Troff User's Manual” by Joseph F. Ossanna, 1976 (revised by
       Brian W. Kernighan, 1992), AT&amp;T Bell Laboratories Computing
       Science Technical Report No. 54.

       “A Typesetter-independent TROFF” by Brian W. Kernighan, 1982,
       AT&amp;T Bell Laboratories Computing Science Technical Report No. 97.

       You can obtain many relevant Bell Labs papers in PDF from Bernd
       Warken's “roff classical” GitHub repository 
       ⟨<a href="https://github.com/bwarken/roff_classical.git">https://github.com/bwarken/roff_classical.git</a>⟩.

   <b>Manual pages</b>
       A componentized system like <i>roff</i> potentially has many man pages,
       each describing an aspect of it.  Unfortunately, there is no
       consistent naming scheme for these pages among the various
       implementations.

       In GNU <i>roff</i>, the <i>groff</i>(1) man page enumerates all man pages
       distributed with the system, and individual pages frequently
       refer to external resources as well as manuals on a variety of
       topics distributed with <i>groff</i>.

       In other <i>roff</i>s, you are on your own, but <i>troff</i>(1) might be a good
       starting point.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>groff</i> (GNU troff) project.  Information
       about the project can be found at 
       ⟨<a href="http://www.gnu.org/software/groff/">http://www.gnu.org/software/groff/</a>⟩.  If you have a bug report
       for this manual page, see ⟨<a href="http://www.gnu.org/software/groff/">http://www.gnu.org/software/groff/</a>⟩.
       This page was obtained from the project's upstream Git repository
       ⟨<a href="https://git.savannah.gnu.org/git/groff.git">https://git.savannah.gnu.org/git/groff.git</a>⟩ on 2024-06-14.  (At
       that time, the date of the most recent commit that was found in
       the repository was 2024-06-10.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">groff 1.23.0.1273-9d53-dirty   6 June 2024                       <i>roff</i>(7)</span>
</pre>          <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man7/roff.7.html" class="_attribution-link">https://man7.org/linux/man-pages/man7/roff.7.html</a>
  </p>
</div>
