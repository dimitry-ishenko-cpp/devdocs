<h1>mount_namespaces(7) — Linux manual page</h1>   <pre>
<span class="headline"><i>mount_namespaces</i>(7) Miscellaneous Information Manual <i>mount_namespaces</i>(7)</span>
</pre> <h2>
NAME </h2>
<pre>
       mount_namespaces - overview of Linux mount namespaces
</pre> <h2>
DESCRIPTION </h2>
<pre>
       For an overview of namespaces, see <a href="namespaces.7.html">namespaces(7)</a>.

       Mount namespaces provide isolation of the list of mounts seen by
       the processes in each namespace instance.  Thus, the processes in
       each of the mount namespace instances will see distinct single-
       directory hierarchies.

       The views provided by the <i>/proc/</i>pid<i>/mounts</i>, <i>/proc/</i>pid<i>/mountinfo</i>,
       and <i>/proc/</i>pid<i>/mountstats</i> files (all described in <a href="../man5/proc.5.html">proc(5)</a>)
       correspond to the mount namespace in which the process with the
       PID <i>pid</i> resides.  (All of the processes that reside in the same
       mount namespace will see the same view in these files.)

       A new mount namespace is created using either <a href="../man2/clone.2.html">clone(2)</a> or
       <a href="../man2/unshare.2.html">unshare(2)</a> with the <b>CLONE_NEWNS </b>flag.  When a new mount namespace
       is created, its mount list is initialized as follows:

       •  If the namespace is created using <a href="../man2/clone.2.html">clone(2)</a>, the mount list of
          the child's namespace is a copy of the mount list in the
          parent process's mount namespace.

       •  If the namespace is created using <a href="../man2/unshare.2.html">unshare(2)</a>, the mount list
          of the new namespace is a copy of the mount list in the
          caller's previous mount namespace.

       Subsequent modifications to the mount list (<a href="../man2/mount.2.html">mount(2)</a> and
       <a href="../man2/umount.2.html">umount(2)</a>) in either mount namespace will not (by default) affect
       the mount list seen in the other namespace (but see the following
       discussion of shared subtrees).
</pre> <h2>
SHARED SUBTREES </h2>
<pre>
       After the implementation of mount namespaces was completed,
       experience showed that the isolation that they provided was, in
       some cases, too great.  For example, in order to make a newly
       loaded optical disk available in all mount namespaces, a mount
       operation was required in each namespace.  For this use case, and
       others, the shared subtree feature was introduced in Linux
       2.6.15.  This feature allows for automatic, controlled
       propagation of <a href="../man2/mount.2.html">mount(2)</a> and <a href="../man2/umount.2.html">umount(2)</a> <i>events</i> between namespaces
       (or, more precisely, between the mounts that are members of a
       <i>peer group</i> that are propagating events to one another).

       Each mount is marked (via <a href="../man2/mount.2.html">mount(2)</a>) as having one of the
       following <i>propagation types</i>:

       <b>MS_SHARED</b>
              This mount shares events with members of a peer group.
              <a href="../man2/mount.2.html">mount(2)</a> and <a href="../man2/umount.2.html">umount(2)</a> events immediately under this mount
              will propagate to the other mounts that are members of the
              peer group.  <i>Propagation</i> here means that the same <a href="../man2/mount.2.html">mount(2)</a>
              or <a href="../man2/umount.2.html">umount(2)</a> will automatically occur under all of the
              other mounts in the peer group.  Conversely, <a href="../man2/mount.2.html">mount(2)</a> and
              <a href="../man2/umount.2.html">umount(2)</a> events that take place under peer mounts will
              propagate to this mount.

       <b>MS_PRIVATE</b>
              This mount is private; it does not have a peer group.
              <a href="../man2/mount.2.html">mount(2)</a> and <a href="../man2/umount.2.html">umount(2)</a> events do not propagate into or out
              of this mount.

       <b>MS_SLAVE</b>
              <a href="../man2/mount.2.html">mount(2)</a> and <a href="../man2/umount.2.html">umount(2)</a> events propagate into this mount
              from a (master) shared peer group.  <a href="../man2/mount.2.html">mount(2)</a> and <a href="../man2/umount.2.html">umount(2)</a>
              events under this mount do not propagate to any peer.

              Note that a mount can be the slave of another peer group
              while at the same time sharing <a href="../man2/mount.2.html">mount(2)</a> and <a href="../man2/umount.2.html">umount(2)</a>
              events with a peer group of which it is a member.  (More
              precisely, one peer group can be the slave of another peer
              group.)

       <b>MS_UNBINDABLE</b>
              This is like a private mount, and in addition this mount
              can't be bind mounted.  Attempts to bind mount this mount
              (<a href="../man2/mount.2.html">mount(2)</a> with the <b>MS_BIND </b>flag) will fail.

              When a recursive bind mount (<a href="../man2/mount.2.html">mount(2)</a> with the <b>MS_BIND </b>and
              <b>MS_REC </b>flags) is performed on a directory subtree, any
              bind mounts within the subtree are automatically pruned
              (i.e., not replicated) when replicating that subtree to
              produce the target subtree.

       For a discussion of the propagation type assigned to a new mount,
       see NOTES.

       The propagation type is a per-mount-point setting; some mounts
       may be marked as shared (with each shared mount being a member of
       a distinct peer group), while others are private (or slaved or
       unbindable).

       Note that a mount's propagation type determines whether <a href="../man2/mount.2.html">mount(2)</a>
       and <a href="../man2/umount.2.html">umount(2)</a> of mounts <i>immediately under</i> the mount are
       propagated.  Thus, the propagation type does not affect
       propagation of events for grandchildren and further removed
       descendant mounts.  What happens if the mount itself is unmounted
       is determined by the propagation type that is in effect for the
       <i>parent</i> of the mount.

       Members are added to a <i>peer group</i> when a mount is marked as
       shared and either:

       (a)  the mount is replicated during the creation of a new mount
            namespace; or

       (b)  a new bind mount is created from the mount.

       In both of these cases, the new mount joins the peer group of
       which the existing mount is a member.

       A new peer group is also created when a child mount is created
       under an existing mount that is marked as shared.  In this case,
       the new child mount is also marked as shared and the resulting
       peer group consists of all the mounts that are replicated under
       the peers of parent mounts.

       A mount ceases to be a member of a peer group when either the
       mount is explicitly unmounted, or when the mount is implicitly
       unmounted because a mount namespace is removed (because it has no
       more member processes).

       The propagation type of the mounts in a mount namespace can be
       discovered via the "optional fields" exposed in
       <i>/proc/</i>pid<i>/mountinfo</i>.  (See <a href="../man5/proc.5.html">proc(5)</a> for details of this file.)
       The following tags can appear in the optional fields for a record
       in that file:

       <i>shared:X</i>
              This mount is shared in peer group <i>X</i>.  Each peer group has
              a unique ID that is automatically generated by the kernel,
              and all mounts in the same peer group will show the same
              ID.  (These IDs are assigned starting from the value 1,
              and may be recycled when a peer group ceases to have any
              members.)

       <i>master:X</i>
              This mount is a slave to shared peer group <i>X</i>.

       <i>propagate_from:X</i> (since Linux 2.6.26)
              This mount is a slave and receives propagation from shared
              peer group <i>X</i>.  This tag will always appear in conjunction
              with a <i>master:X</i> tag.  Here, <i>X</i> is the closest dominant peer
              group under the process's root directory.  If <i>X</i> is the
              immediate master of the mount, or if there is no dominant
              peer group under the same root, then only the <i>master:X</i>
              field is present and not the <i>propagate_from:X</i> field.  For
              further details, see below.

       <i>unbindable</i>
              This is an unbindable mount.

       If none of the above tags is present, then this is a private
       mount.

   <b>MS_SHARED and MS_PRIVATE example</b>
       Suppose that on a terminal in the initial mount namespace, we
       mark one mount as shared and another as private, and then view
       the mounts in <i>/proc/self/mountinfo</i>:

           sh1# <b>mount --make-shared /mntS</b>
           sh1# <b>mount --make-private /mntP</b>
           sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           77 61 8:17 / /mntS rw,relatime shared:1
           83 61 8:15 / /mntP rw,relatime

       From the <i>/proc/self/mountinfo</i> output, we see that <i>/mntS</i> is a
       shared mount in peer group 1, and that <i>/mntP</i> has no optional
       tags, indicating that it is a private mount.  The first two
       fields in each record in this file are the unique ID for this
       mount, and the mount ID of the parent mount.  We can further
       inspect this file to see that the parent mount of <i>/mntS</i> and <i>/mntP</i>
       is the root directory, <i>/</i>, which is mounted as private:

           sh1# <b>cat /proc/self/mountinfo | awk '$1 == 61' | sed 's/ - .*//'</b>
           61 0 8:2 / / rw,relatime

       On a second terminal, we create a new mount namespace where we
       run a second shell and inspect the mounts:

           $ <b>PS1='sh2# ' sudo unshare -m --propagation unchanged sh</b>
           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           222 145 8:17 / /mntS rw,relatime shared:1
           225 145 8:15 / /mntP rw,relatime

       The new mount namespace received a copy of the initial mount
       namespace's mounts.  These new mounts maintain the same
       propagation types, but have unique mount IDs.  (The
       <i>--propagation unchanged</i> option prevents <a href="../man1/unshare.1.html">unshare(1)</a> from marking
       all mounts as private when creating a new mount namespace, which
       it does by default.)

       In the second terminal, we then create submounts under each of
       <i>/mntS</i> and <i>/mntP</i> and inspect the set-up:

           sh2# <b>mkdir /mntS/a</b>
           sh2# <b>mount /dev/sdb6 /mntS/a</b>
           sh2# <b>mkdir /mntP/b</b>
           sh2# <b>mount /dev/sdb7 /mntP/b</b>
           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           222 145 8:17 / /mntS rw,relatime shared:1
           225 145 8:15 / /mntP rw,relatime
           178 222 8:22 / /mntS/a rw,relatime shared:2
           230 225 8:23 / /mntP/b rw,relatime

       From the above, it can be seen that <i>/mntS/a</i> was created as shared
       (inheriting this setting from its parent mount) and <i>/mntP/b</i> was
       created as a private mount.

       Returning to the first terminal and inspecting the set-up, we see
       that the new mount created under the shared mount <i>/mntS</i>
       propagated to its peer mount (in the initial mount namespace),
       but the new mount created under the private mount <i>/mntP</i> did not
       propagate:

           sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           77 61 8:17 / /mntS rw,relatime shared:1
           83 61 8:15 / /mntP rw,relatime
           179 77 8:22 / /mntS/a rw,relatime shared:2

   <b>MS_SLAVE example</b>
       Making a mount a slave allows it to receive propagated <a href="../man2/mount.2.html">mount(2)</a>
       and <a href="../man2/umount.2.html">umount(2)</a> events from a master shared peer group, while
       preventing it from propagating events to that master.  This is
       useful if we want to (say) receive a mount event when an optical
       disk is mounted in the master shared peer group (in another mount
       namespace), but want to prevent <a href="../man2/mount.2.html">mount(2)</a> and <a href="../man2/umount.2.html">umount(2)</a> events
       under the slave mount from having side effects in other
       namespaces.

       We can demonstrate the effect of slaving by first marking two
       mounts as shared in the initial mount namespace:

           sh1# <b>mount --make-shared /mntX</b>
           sh1# <b>mount --make-shared /mntY</b>
           sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           132 83 8:23 / /mntX rw,relatime shared:1
           133 83 8:22 / /mntY rw,relatime shared:2

       On a second terminal, we create a new mount namespace and inspect
       the mounts:

           sh2# <b>unshare -m --propagation unchanged sh</b>
           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime shared:2

       In the new mount namespace, we then mark one of the mounts as a
       slave:

           sh2# <b>mount --make-slave /mntY</b>
           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime master:2

       From the above output, we see that <i>/mntY</i> is now a slave mount
       that is receiving propagation events from the shared peer group
       with the ID 2.

       Continuing in the new namespace, we create submounts under each
       of <i>/mntX</i> and <i>/mntY</i>:

           sh2# <b>mkdir /mntX/a</b>
           sh2# <b>mount /dev/sda3 /mntX/a</b>
           sh2# <b>mkdir /mntY/b</b>
           sh2# <b>mount /dev/sda5 /mntY/b</b>

       When we inspect the state of the mounts in the new mount
       namespace, we see that <i>/mntX/a</i> was created as a new shared mount
       (inheriting the "shared" setting from its parent mount) and
       <i>/mntY/b</i> was created as a private mount:

           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime master:2
           173 168 8:3 / /mntX/a rw,relatime shared:3
           175 169 8:5 / /mntY/b rw,relatime

       Returning to the first terminal (in the initial mount namespace),
       we see that the mount <i>/mntX/a</i> propagated to the peer (the shared
       <i>/mntX</i>), but the mount <i>/mntY/b</i> was not propagated:

           sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           132 83 8:23 / /mntX rw,relatime shared:1
           133 83 8:22 / /mntY rw,relatime shared:2
           174 132 8:3 / /mntX/a rw,relatime shared:3

       Now we create a new mount under <i>/mntY</i> in the first shell:

           sh1# <b>mkdir /mntY/c</b>
           sh1# <b>mount /dev/sda1 /mntY/c</b>
           sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           132 83 8:23 / /mntX rw,relatime shared:1
           133 83 8:22 / /mntY rw,relatime shared:2
           174 132 8:3 / /mntX/a rw,relatime shared:3
           178 133 8:1 / /mntY/c rw,relatime shared:4

       When we examine the mounts in the second mount namespace, we see
       that in this case the new mount has been propagated to the slave
       mount, and that the new mount is itself a slave mount (to peer
       group 4):

           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime master:2
           173 168 8:3 / /mntX/a rw,relatime shared:3
           175 169 8:5 / /mntY/b rw,relatime
           179 169 8:1 / /mntY/c rw,relatime master:4

   <b>MS_UNBINDABLE example</b>
       One of the primary purposes of unbindable mounts is to avoid the
       "mount explosion" problem when repeatedly performing bind mounts
       of a higher-level subtree at a lower-level mount.  The problem is
       illustrated by the following shell session.

       Suppose we have a system with the following mounts:

           # <b>mount | awk '{print $1, $2, $3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY

       Suppose furthermore that we wish to recursively bind mount the
       root directory under several users' home directories.  We do this
       for the first user, and inspect the mounts:

           # <b>mount --rbind / /home/cecilia/</b>
           # <b>mount | awk '{print $1, $2, $3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY

       When we repeat this operation for the second user, we start to
       see the explosion problem:

           # <b>mount --rbind / /home/henry</b>
           # <b>mount | awk '{print $1, $2, $3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY
           /dev/sda1 on /home/henry
           /dev/sdb6 on /home/henry/mntX
           /dev/sdb7 on /home/henry/mntY
           /dev/sda1 on /home/henry/home/cecilia
           /dev/sdb6 on /home/henry/home/cecilia/mntX
           /dev/sdb7 on /home/henry/home/cecilia/mntY

       Under <i>/home/henry</i>, we have not only recursively added the <i>/mntX</i>
       and <i>/mntY</i> mounts, but also the recursive mounts of those
       directories under <i>/home/cecilia</i> that were created in the previous
       step.  Upon repeating the step for a third user, it becomes
       obvious that the explosion is exponential in nature:

           # <b>mount --rbind / /home/otto</b>
           # <b>mount | awk '{print $1, $2, $3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY
           /dev/sda1 on /home/henry
           /dev/sdb6 on /home/henry/mntX
           /dev/sdb7 on /home/henry/mntY
           /dev/sda1 on /home/henry/home/cecilia
           /dev/sdb6 on /home/henry/home/cecilia/mntX
           /dev/sdb7 on /home/henry/home/cecilia/mntY
           /dev/sda1 on /home/otto
           /dev/sdb6 on /home/otto/mntX
           /dev/sdb7 on /home/otto/mntY
           /dev/sda1 on /home/otto/home/cecilia
           /dev/sdb6 on /home/otto/home/cecilia/mntX
           /dev/sdb7 on /home/otto/home/cecilia/mntY
           /dev/sda1 on /home/otto/home/henry
           /dev/sdb6 on /home/otto/home/henry/mntX
           /dev/sdb7 on /home/otto/home/henry/mntY
           /dev/sda1 on /home/otto/home/henry/home/cecilia
           /dev/sdb6 on /home/otto/home/henry/home/cecilia/mntX
           /dev/sdb7 on /home/otto/home/henry/home/cecilia/mntY

       The mount explosion problem in the above scenario can be avoided
       by making each of the new mounts unbindable.  The effect of doing
       this is that recursive mounts of the root directory will not
       replicate the unbindable mounts.  We make such a mount for the
       first user:

           # <b>mount --rbind --make-unbindable / /home/cecilia</b>

       Before going further, we show that unbindable mounts are indeed
       unbindable:

           # <b>mkdir /mntZ</b>
           # <b>mount --bind /home/cecilia /mntZ</b>
           mount: wrong fs type, bad option, bad superblock on /home/cecilia,
                  missing codepage or helper program, or other error

                  In some cases useful info is found in syslog - try
                  dmesg | tail or so.

       Now we create unbindable recursive bind mounts for the other two
       users:

           # <b>mount --rbind --make-unbindable / /home/henry</b>
           # <b>mount --rbind --make-unbindable / /home/otto</b>

       Upon examining the list of mounts, we see there has been no
       explosion of mounts, because the unbindable mounts were not
       replicated under each user's directory:

           # <b>mount | awk '{print $1, $2, $3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY
           /dev/sda1 on /home/henry
           /dev/sdb6 on /home/henry/mntX
           /dev/sdb7 on /home/henry/mntY
           /dev/sda1 on /home/otto
           /dev/sdb6 on /home/otto/mntX
           /dev/sdb7 on /home/otto/mntY

   <b>Propagation type transitions</b>
       The following table shows the effect that applying a new
       propagation type (i.e., <i>mount --make-xxxx</i>) has on the existing
       propagation type of a mount.  The rows correspond to existing
       propagation types, and the columns are the new propagation
       settings.  For reasons of space, "private" is abbreviated as
       "priv" and "unbindable" as "unbind".
                     <b>make-shared   make-slave      make-priv  make-unbind</b>
       ─────────────┬───────────────────────────────────────────────────────
       <b>shared       </b>│shared        slave/priv [1]  priv       unbind
       <b>slave        </b>│slave+shared  slave [2]       priv       unbind
       <b>slave+shared </b>│slave+shared  slave           priv       unbind
       <b>private      </b>│shared        priv [2]        priv       unbind
       <b>unbindable   </b>│shared        unbind [2]      priv       unbind

       Note the following details to the table:

       [1]  If a shared mount is the only mount in its peer group,
            making it a slave automatically makes it private.

       [2]  Slaving a nonshared mount has no effect on the mount.

   <b>Bind (MS_BIND) semantics</b>
       Suppose that the following command is performed:

           mount --bind A/a B/b

       Here, <i>A</i> is the source mount, <i>B</i> is the destination mount, <i>a</i> is a
       subdirectory path under the mount point <i>A</i>, and <i>b</i> is a
       subdirectory path under the mount point <i>B</i>.  The propagation type
       of the resulting mount, <i>B/b</i>, depends on the propagation types of
       the mounts <i>A</i> and <i>B</i>, and is summarized in the following table.

                                  <b>source(A)</b>
                          <b>shared  private    slave         unbind</b>
       ──────────────────┬──────────────────────────────────────────
       <b>dest(B)  shared   </b>│shared  shared     slave+shared  invalid
                <b>nonshared</b>│shared  private    slave         invalid

       Note that a recursive bind of a subtree follows the same
       semantics as for a bind operation on each mount in the subtree.
       (Unbindable mounts are automatically pruned at the target mount
       point.)

       For further details, see
       <i>Documentation/filesystems/sharedsubtree.rst</i> in the kernel source
       tree.

   <b>Move (MS_MOVE) semantics</b>
       Suppose that the following command is performed:

           mount --move A B/b

       Here, <i>A</i> is the source mount, <i>B</i> is the destination mount, and <i>b</i> is
       a subdirectory path under the mount point <i>B</i>.  The propagation
       type of the resulting mount, <i>B/b</i>, depends on the propagation
       types of the mounts <i>A</i> and <i>B</i>, and is summarized in the following
       table.

                                  <b>source(A)</b>
                          <b>shared  private    slave         unbind</b>
       ──────────────────┬─────────────────────────────────────────────
       <b>dest(B)  shared   </b>│shared  shared     slave+shared  invalid
                <b>nonshared</b>│shared  private    slave         unbindable

       Note: moving a mount that resides under a shared mount is
       invalid.

       For further details, see
       <i>Documentation/filesystems/sharedsubtree.rst</i> in the kernel source
       tree.

   <b>Mount semantics</b>
       Suppose that we use the following command to create a mount:

           mount device B/b

       Here, <i>B</i> is the destination mount, and <i>b</i> is a subdirectory path
       under the mount point <i>B</i>.  The propagation type of the resulting
       mount, <i>B/b</i>, follows the same rules as for a bind mount, where the
       propagation type of the source mount is considered always to be
       private.

   <b>Unmount semantics</b>
       Suppose that we use the following command to tear down a mount:

           umount A

       Here, <i>A</i> is a mount on <i>B/b</i>, where <i>B</i> is the parent mount and <i>b</i> is a
       subdirectory path under the mount point <i>B</i>.  If <b>B </b>is shared, then
       all most-recently-mounted mounts at <i>b</i> on mounts that receive
       propagation from mount <i>B</i> and do not have submounts under them are
       unmounted.

   <b>The /proc/ pid /mountinfo propagate_from tag</b>
       The <i>propagate_from:X</i> tag is shown in the optional fields of a
       <i>/proc/</i>pid<i>/mountinfo</i> record in cases where a process can't see a
       slave's immediate master (i.e., the pathname of the master is not
       reachable from the filesystem root directory) and so cannot
       determine the chain of propagation between the mounts it can see.

       In the following example, we first create a two-link master-slave
       chain between the mounts <i>/mnt</i>, <i>/tmp/etc</i>, and <i>/mnt/tmp/etc</i>.  Then
       the <a href="../man1/chroot.1.html">chroot(1)</a> command is used to make the <i>/tmp/etc</i> mount point
       unreachable from the root directory, creating a situation where
       the master of <i>/mnt/tmp/etc</i> is not reachable from the (new) root
       directory of the process.

       First, we bind mount the root directory onto <i>/mnt</i> and then bind
       mount <i>/proc</i> at <i>/mnt/proc</i> so that after the later <a href="../man1/chroot.1.html">chroot(1)</a> the
       <a href="../man5/proc.5.html">proc(5)</a> filesystem remains visible at the correct location in the
       chroot-ed environment.

           # <b>mkdir -p /mnt/proc</b>
           # <b>mount --bind / /mnt</b>
           # <b>mount --bind /proc /mnt/proc</b>

       Next, we ensure that the <i>/mnt</i> mount is a shared mount in a new
       peer group (with no peers):

           # <b>mount --make-private /mnt  </b># Isolate from any previous peer group
           # <b>mount --make-shared /mnt</b>
           # <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           239 61 8:2 / /mnt ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5

       Next, we bind mount <i>/mnt/etc</i> onto <i>/tmp/etc</i>:

           # <b>mkdir -p /tmp/etc</b>
           # <b>mount --bind /mnt/etc /tmp/etc</b>
           # <b>cat /proc/self/mountinfo | egrep '/mnt|/tmp/' | sed 's/ - .*//'</b>
           239 61 8:2 / /mnt ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5
           267 40 8:2 /etc /tmp/etc ... shared:102

       Initially, these two mounts are in the same peer group, but we
       then make the <i>/tmp/etc</i> a slave of <i>/mnt/etc</i>, and then make
       <i>/tmp/etc</i> shared as well, so that it can propagate events to the
       next slave in the chain:

           # <b>mount --make-slave /tmp/etc</b>
           # <b>mount --make-shared /tmp/etc</b>
           # <b>cat /proc/self/mountinfo | egrep '/mnt|/tmp/' | sed 's/ - .*//'</b>
           239 61 8:2 / /mnt ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5
           267 40 8:2 /etc /tmp/etc ... shared:105 master:102

       Then we bind mount <i>/tmp/etc</i> onto <i>/mnt/tmp/etc</i>.  Again, the two
       mounts are initially in the same peer group, but we then make
       <i>/mnt/tmp/etc</i> a slave of <i>/tmp/etc</i>:

           # <b>mkdir -p /mnt/tmp/etc</b>
           # <b>mount --bind /tmp/etc /mnt/tmp/etc</b>
           # <b>mount --make-slave /mnt/tmp/etc</b>
           # <b>cat /proc/self/mountinfo | egrep '/mnt|/tmp/' | sed 's/ - .*//'</b>
           239 61 8:2 / /mnt ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5
           267 40 8:2 /etc /tmp/etc ... shared:105 master:102
           273 239 8:2 /etc /mnt/tmp/etc ... master:105

       From the above, we see that <i>/mnt</i> is the master of the slave
       <i>/tmp/etc</i>, which in turn is the master of the slave <i>/mnt/tmp/etc</i>.

       We then <a href="../man1/chroot.1.html">chroot(1)</a> to the <i>/mnt</i> directory, which renders the mount
       with ID 267 unreachable from the (new) root directory:

           # <b>chroot /mnt</b>

       When we examine the state of the mounts inside the chroot-ed
       environment, we see the following:

           # <b>cat /proc/self/mountinfo | sed 's/ - .*//'</b>
           239 61 8:2 / / ... shared:102
           248 239 0:4 / /proc ... shared:5
           273 239 8:2 /etc /tmp/etc ... master:105 propagate_from:102

       Above, we see that the mount with ID 273 is a slave whose master
       is the peer group 105.  The mount point for that master is
       unreachable, and so a <i>propagate_from</i> tag is displayed, indicating
       that the closest dominant peer group (i.e., the nearest reachable
       mount in the slave chain) is the peer group with the ID 102
       (corresponding to the <i>/mnt</i> mount point before the <a href="../man1/chroot.1.html">chroot(1)</a> was
       performed).
</pre> <h2>
STANDARDS </h2>
<pre>
       Linux.
</pre> <h2>
HISTORY </h2>
<pre>
       Linux 2.4.19.
</pre> <h2>
NOTES </h2>
<pre>
       The propagation type assigned to a new mount depends on the
       propagation type of the parent mount.  If the mount has a parent
       (i.e., it is a non-root mount point) and the propagation type of
       the parent is <b>MS_SHARED</b>, then the propagation type of the new
       mount is also <b>MS_SHARED</b>.  Otherwise, the propagation type of the
       new mount is <b>MS_PRIVATE</b>.

       Notwithstanding the fact that the default propagation type for
       new mount is in many cases <b>MS_PRIVATE</b>, <b>MS_SHARED </b>is typically
       more useful.  For this reason, <a href="../man1/systemd.1.html">systemd(1)</a> automatically remounts
       all mounts as <b>MS_SHARED </b>on system startup.  Thus, on most modern
       systems, the default propagation type is in practice <b>MS_SHARED</b>.

       Since, when one uses <a href="../man1/unshare.1.html">unshare(1)</a> to create a mount namespace, the
       goal is commonly to provide full isolation of the mounts in the
       new namespace, <a href="../man1/unshare.1.html">unshare(1)</a> (since <i>util-linux</i> 2.27) in turn
       reverses the step performed by <a href="../man1/systemd.1.html">systemd(1)</a>, by making all mounts
       private in the new namespace.  That is, <a href="../man1/unshare.1.html">unshare(1)</a> performs the
       equivalent of the following in the new mount namespace:

           mount --make-rprivate /

       To prevent this, one can use the <i>--propagation unchanged</i> option
       to <a href="../man1/unshare.1.html">unshare(1)</a>.

       An application that creates a new mount namespace directly using
       <a href="../man2/clone.2.html">clone(2)</a> or <a href="../man2/unshare.2.html">unshare(2)</a> may desire to prevent propagation of mount
       events to other mount namespaces (as is done by <a href="../man1/unshare.1.html">unshare(1)</a>).
       This can be done by changing the propagation type of mounts in
       the new namespace to either <b>MS_SLAVE </b>or <b>MS_PRIVATE</b>, using a call
       such as the following:

           mount(NULL, "/", MS_SLAVE | MS_REC, NULL);

       For a discussion of propagation types when moving mounts
       (<b>MS_MOVE</b>) and creating bind mounts (<b>MS_BIND</b>), see
       <i>Documentation/filesystems/sharedsubtree.rst</i>.

   <b>Restrictions on mount namespaces</b>
       Note the following points with respect to mount namespaces:

       [1]  Each mount namespace has an owner user namespace.  As
            explained above, when a new mount namespace is created, its
            mount list is initialized as a copy of the mount list of
            another mount namespace.  If the new namespace and the
            namespace from which the mount list was copied are owned by
            different user namespaces, then the new mount namespace is
            considered <i>less privileged</i>.

       [2]  When creating a less privileged mount namespace, shared
            mounts are reduced to slave mounts.  This ensures that
            mappings performed in less privileged mount namespaces will
            not propagate to more privileged mount namespaces.

       [3]  Mounts that come as a single unit from a more privileged
            mount namespace are locked together and may not be separated
            in a less privileged mount namespace.  (The <a href="../man2/unshare.2.html">unshare(2)</a>
            <b>CLONE_NEWNS </b>operation brings across all of the mounts from
            the original mount namespace as a single unit, and recursive
            mounts that propagate between mount namespaces propagate as
            a single unit.)

            In this context, "may not be separated" means that the
            mounts are locked so that they may not be individually
            unmounted.  Consider the following example:

                $ <b>sudo sh</b>
                # <b>mount --bind /dev/null /etc/shadow</b>
                # <b>cat /etc/shadow       </b># Produces no output

            The above steps, performed in a more privileged mount
            namespace, have created a bind mount that obscures the
            contents of the shadow password file, <i>/etc/shadow</i>.  For
            security reasons, it should not be possible to <a href="../man2/umount.2.html">umount(2)</a>
            that mount in a less privileged mount namespace, since that
            would reveal the contents of <i>/etc/shadow</i>.

            Suppose we now create a new mount namespace owned by a new
            user namespace.  The new mount namespace will inherit copies
            of all of the mounts from the previous mount namespace.
            However, those mounts will be locked because the new mount
            namespace is less privileged.  Consequently, an attempt to
            <a href="../man2/umount.2.html">umount(2)</a> the mount fails as show in the following step:

                # <b>unshare --user --map-root-user --mount \</b>
                               <b>strace -o /tmp/log \</b>
                               <b>umount /mnt/dir</b>
                umount: /etc/shadow: not mounted.
                # <b>grep '^umount' /tmp/log</b>
                umount2("/etc/shadow", 0)     = -1 EINVAL (Invalid argument)

            The error message from <a href="../man8/mount.8.html">mount(8)</a> is a little confusing, but
            the <a href="../man1/strace.1.html">strace(1)</a> output reveals that the underlying <a href="../man2/umount2.2.html">umount2(2)</a>
            system call failed with the error <b>EINVAL</b>, which is the error
            that the kernel returns to indicate that the mount is
            locked.

            Note, however, that it is possible to stack (and unstack) a
            mount on top of one of the inherited locked mounts in a less
            privileged mount namespace:

                # <b>echo 'aaaaa' &gt; /tmp/a    </b># File to mount onto /etc/shadow
                # <b>unshare --user --map-root-user --mount \</b>
                    <b>sh -c 'mount --bind /tmp/a /etc/shadow; cat /etc/shadow'</b>
                aaaaa
                # <b>umount /etc/shadow</b>

            The final <a href="../man8/umount.8.html">umount(8)</a> command above, which is performed in the
            initial mount namespace, makes the original <i>/etc/shadow</i> file
            once more visible in that namespace.

       [4]  Following on from point [3], note that it is possible to
            <a href="../man2/umount.2.html">umount(2)</a> an entire subtree of mounts that propagated as a
            unit into a less privileged mount namespace, as illustrated
            in the following example.

            First, we create new user and mount namespaces using
            <a href="../man1/unshare.1.html">unshare(1)</a>.  In the new mount namespace, the propagation
            type of all mounts is set to private.  We then create a
            shared bind mount at <i>/mnt</i>, and a small hierarchy of mounts
            underneath that mount.

                $ <b>PS1='ns1# ' sudo unshare --user --map-root-user \</b>
                                       <b>--mount --propagation private bash</b>
                ns1# <b>echo $$        </b># We need the PID of this shell later
                778501
                ns1# <b>mount --make-shared --bind /mnt /mnt</b>
                ns1# <b>mkdir /mnt/x</b>
                ns1# <b>mount --make-private -t tmpfs none /mnt/x</b>
                ns1# <b>mkdir /mnt/x/y</b>
                ns1# <b>mount --make-private -t tmpfs none /mnt/x/y</b>
                ns1# <b>grep /mnt /proc/self/mountinfo | sed 's/ - .*//'</b>
                986 83 8:5 /mnt /mnt rw,relatime shared:344
                989 986 0:56 / /mnt/x rw,relatime
                990 989 0:57 / /mnt/x/y rw,relatime

            Continuing in the same shell session, we then create a
            second shell in a new user namespace and a new (less
            privileged) mount namespace and check the state of the
            propagated mounts rooted at <i>/mnt</i>.

                ns1# <b>PS1='ns2# ' unshare --user --map-root-user \</b>
                                       <b>--mount --propagation unchanged bash</b>
                ns2# <b>grep /mnt /proc/self/mountinfo | sed 's/ - .*//'</b>
                1239 1204 8:5 /mnt /mnt rw,relatime master:344
                1240 1239 0:56 / /mnt/x rw,relatime
                1241 1240 0:57 / /mnt/x/y rw,relatime

            Of note in the above output is that the propagation type of
            the mount <i>/mnt</i> has been reduced to slave, as explained in
            point [2].  This means that submount events will propagate
            from the master <i>/mnt</i> in "ns1", but propagation will not
            occur in the opposite direction.

            From a separate terminal window, we then use <a href="../man1/nsenter.1.html">nsenter(1)</a> to
            enter the mount and user namespaces corresponding to "ns1".
            In that terminal window, we then recursively bind mount
            <i>/mnt/x</i> at the location <i>/mnt/ppp</i>.

                $ <b>PS1='ns3# ' sudo nsenter -t 778501 --user --mount</b>
                ns3# <b>mount --rbind --make-private /mnt/x /mnt/ppp</b>
                ns3# <b>grep /mnt /proc/self/mountinfo | sed 's/ - .*//'</b>
                986 83 8:5 /mnt /mnt rw,relatime shared:344
                989 986 0:56 / /mnt/x rw,relatime
                990 989 0:57 / /mnt/x/y rw,relatime
                1242 986 0:56 / /mnt/ppp rw,relatime
                1243 1242 0:57 / /mnt/ppp/y rw,relatime shared:518

            Because the propagation type of the parent mount, <i>/mnt</i>, was
            shared, the recursive bind mount propagated a small subtree
            of mounts under the slave mount <i>/mnt</i> into "ns2", as can be
            verified by executing the following command in that shell
            session:

                ns2# <b>grep /mnt /proc/self/mountinfo | sed 's/ - .*//'</b>
                1239 1204 8:5 /mnt /mnt rw,relatime master:344
                1240 1239 0:56 / /mnt/x rw,relatime
                1241 1240 0:57 / /mnt/x/y rw,relatime
                1244 1239 0:56 / /mnt/ppp rw,relatime
                1245 1244 0:57 / /mnt/ppp/y rw,relatime master:518

            While it is not possible to <a href="../man2/umount.2.html">umount(2)</a> a part of the
            propagated subtree (<i>/mnt/ppp/y</i>) in "ns2", it is possible to
            <a href="../man2/umount.2.html">umount(2)</a> the entire subtree, as shown by the following
            commands:

                ns2# <b>umount /mnt/ppp/y</b>
                umount: /mnt/ppp/y: not mounted.
                ns2# <b>umount -l /mnt/ppp | sed 's/ - .*//'      </b># Succeeds...
                ns2# <b>grep /mnt /proc/self/mountinfo</b>
                1239 1204 8:5 /mnt /mnt rw,relatime master:344
                1240 1239 0:56 / /mnt/x rw,relatime
                1241 1240 0:57 / /mnt/x/y rw,relatime

       [5]  The <a href="../man2/mount.2.html">mount(2)</a> flags <b>MS_RDONLY</b>, <b>MS_NOSUID</b>, <b>MS_NOEXEC</b>, and the
            "atime" flags (<b>MS_NOATIME</b>, <b>MS_NODIRATIME</b>, <b>MS_RELATIME</b>)
            settings become locked when propagated from a more
            privileged to a less privileged mount namespace, and may not
            be changed in the less privileged mount namespace.

            This point is illustrated in the following example where, in
            a more privileged mount namespace, we create a bind mount
            that is marked as read-only.  For security reasons, it
            should not be possible to make the mount writable in a less
            privileged mount namespace, and indeed the kernel prevents
            this:

                $ <b>sudo mkdir /mnt/dir</b>
                $ <b>sudo mount --bind -o ro /some/path /mnt/dir</b>
                $ <b>sudo unshare --user --map-root-user --mount \</b>
                               <b>mount -o remount,rw /mnt/dir</b>
                mount: /mnt/dir: permission denied.

       [6]  A file or directory that is a mount point in one namespace
            that is not a mount point in another namespace, may be
            renamed, unlinked, or removed (<a href="../man2/rmdir.2.html">rmdir(2)</a>) in the mount
            namespace in which it is not a mount point (subject to the
            usual permission checks).  Consequently, the mount point is
            removed in the mount namespace where it was a mount point.

            Previously (before Linux 3.18), attempting to unlink,
            rename, or remove a file or directory that was a mount point
            in another mount namespace would result in the error <b>EBUSY</b>.
            That behavior had technical problems of enforcement (e.g.,
            for NFS) and permitted denial-of-service attacks against
            more privileged users (i.e., preventing individual files
            from being updated by bind mounting on top of them).
</pre> <h2>
EXAMPLES </h2>
<pre>
       See <a href="../man2/pivot_root.2.html">pivot_root(2)</a>.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man1/unshare.1.html">unshare(1)</a>, <a href="../man2/clone.2.html">clone(2)</a>, <a href="../man2/mount.2.html">mount(2)</a>, <a href="../man2/mount_setattr.2.html">mount_setattr(2)</a>, <a href="../man2/pivot_root.2.html">pivot_root(2)</a>,
       <a href="../man2/setns.2.html">setns(2)</a>, <a href="../man2/umount.2.html">umount(2)</a>, <a href="../man2/unshare.2.html">unshare(2)</a>, <a href="../man5/proc.5.html">proc(5)</a>, <a href="namespaces.7.html">namespaces(7)</a>,
       <a href="user_namespaces.7.html">user_namespaces(7)</a>, <a href="../man8/findmnt.8.html">findmnt(8)</a>, <a href="../man8/mount.8.html">mount(8)</a>, <a href="../man8/pam_namespace.8.html">pam_namespace(8)</a>,
       <a href="../man8/pivot_root.8.html">pivot_root(8)</a>, <a href="../man8/umount.8.html">umount(8)</a>

       <i>Documentation/filesystems/sharedsubtree.rst</i> in the kernel source
       tree.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       ⟨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>⟩.  If you have a bug report
       for this manual page, see
       ⟨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>⟩.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       ⟨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>⟩ on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-06-15            <i>mount_namespaces</i>(7)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/fuser.1.html">fuser(1)</a>, <a href="../man1/nsenter.1.html">nsenter(1)</a>, <a href="../man1/unshare.1.html">unshare(1)</a>, <a href="../man2/clone.2.html">clone(2)</a>, <a href="../man2/mount.2.html">mount(2)</a>, <a href="../man2/mount_setattr.2.html">mount_setattr(2)</a>, <a href="../man2/pivot_root.2.html">pivot_root(2)</a>, <a href="../man2/umount.2.html">umount(2)</a>, <a href="../man2/unshare.2.html">unshare(2)</a>, <a href="../man3/lttng-ust.3.html">lttng-ust(3)</a>, <a href="../man5/core.5.html">core(5)</a>, <a href="../man5/proc_pid_mountinfo.5.html">proc_pid_mountinfo(5)</a>, <a href="../man5/proc_pid_mounts.5.html">proc_pid_mounts(5)</a>, <a href="../man5/proc_pid_mountstats.5.html">proc_pid_mountstats(5)</a>, <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>, <a href="landlock.7.html">landlock(7)</a>, <a href="pid_namespaces.7.html">pid_namespaces(7)</a>, <a href="symlink.7.html">symlink(7)</a>, <a href="../man8/mount.8.html">mount(8)</a>, <a href="../man8/umount.8.html">umount(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man7/mount_namespaces.7.html" class="_attribution-link">https://man7.org/linux/man-pages/man7/mount_namespaces.7.html</a>
  </p>
</div>
