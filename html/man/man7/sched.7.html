<h1>sched(7) — Linux manual page</h1>   <pre>
<span class="headline"><i>sched</i>(7)            Miscellaneous Information Manual            <i>sched</i>(7)</span>
</pre> <h2>
NAME </h2>
<pre>
       sched - overview of CPU scheduling
</pre> <h2>
DESCRIPTION </h2>
<pre>
       Since Linux 2.6.23, the default scheduler is CFS, the "Completely
       Fair Scheduler".  The CFS scheduler replaced the earlier "O(1)"
       scheduler.

   <b>API summary</b>
       Linux provides the following system calls for controlling the CPU
       scheduling behavior, policy, and priority of processes (or, more
       precisely, threads).

       <a href="../man2/nice.2.html">nice(2)</a>
              Set a new nice value for the calling thread, and return
              the new nice value.

       <a href="../man2/getpriority.2.html">getpriority(2)</a>
              Return the nice value of a thread, a process group, or the
              set of threads owned by a specified user.

       <a href="../man2/setpriority.2.html">setpriority(2)</a>
              Set the nice value of a thread, a process group, or the
              set of threads owned by a specified user.

       <a href="../man2/sched_setscheduler.2.html">sched_setscheduler(2)</a>
              Set the scheduling policy and parameters of a specified
              thread.

       <a href="../man2/sched_getscheduler.2.html">sched_getscheduler(2)</a>
              Return the scheduling policy of a specified thread.

       <a href="../man2/sched_setparam.2.html">sched_setparam(2)</a>
              Set the scheduling parameters of a specified thread.

       <a href="../man2/sched_getparam.2.html">sched_getparam(2)</a>
              Fetch the scheduling parameters of a specified thread.

       <a href="../man2/sched_get_priority_max.2.html">sched_get_priority_max(2)</a>
              Return the maximum priority available in a specified
              scheduling policy.

       <a href="../man2/sched_get_priority_min.2.html">sched_get_priority_min(2)</a>
              Return the minimum priority available in a specified
              scheduling policy.

       <a href="../man2/sched_rr_get_interval.2.html">sched_rr_get_interval(2)</a>
              Fetch the quantum used for threads that are scheduled
              under the "round-robin" scheduling policy.

       <a href="../man2/sched_yield.2.html">sched_yield(2)</a>
              Cause the caller to relinquish the CPU, so that some other
              thread be executed.

       <a href="../man2/sched_setaffinity.2.html">sched_setaffinity(2)</a>
              (Linux-specific) Set the CPU affinity of a specified
              thread.

       <a href="../man2/sched_getaffinity.2.html">sched_getaffinity(2)</a>
              (Linux-specific) Get the CPU affinity of a specified
              thread.

       <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a>
              Set the scheduling policy and parameters of a specified
              thread.  This (Linux-specific) system call provides a
              superset of the functionality of <a href="../man2/sched_setscheduler.2.html">sched_setscheduler(2)</a> and
              <a href="../man2/sched_setparam.2.html">sched_setparam(2)</a>.

       <a href="../man2/sched_getattr.2.html">sched_getattr(2)</a>
              Fetch the scheduling policy and parameters of a specified
              thread.  This (Linux-specific) system call provides a
              superset of the functionality of <a href="../man2/sched_getscheduler.2.html">sched_getscheduler(2)</a> and
              <a href="../man2/sched_getparam.2.html">sched_getparam(2)</a>.

   <b>Scheduling policies</b>
       The scheduler is the kernel component that decides which runnable
       thread will be executed by the CPU next.  Each thread has an
       associated scheduling policy and a <i>static</i> scheduling priority,
       <i>sched_priority</i>.  The scheduler makes its decisions based on
       knowledge of the scheduling policy and static priority of all
       threads on the system.

       For threads scheduled under one of the normal scheduling policies
       (<b>SCHED_OTHER</b>, <b>SCHED_IDLE</b>, <b>SCHED_BATCH</b>), <i>sched_priority</i> is not
       used in scheduling decisions (it must be specified as 0).

       Processes scheduled under one of the real-time policies
       (<b>SCHED_FIFO</b>, <b>SCHED_RR</b>) have a <i>sched_priority</i> value in the range 1
       (low) to 99 (high).  (As the numbers imply, real-time threads
       always have higher priority than normal threads.)  Note well:
       POSIX.1 requires an implementation to support only a minimum 32
       distinct priority levels for the real-time policies, and some
       systems supply just this minimum.  Portable programs should use
       <a href="../man2/sched_get_priority_min.2.html">sched_get_priority_min(2)</a> and <a href="../man2/sched_get_priority_max.2.html">sched_get_priority_max(2)</a> to find
       the range of priorities supported for a particular policy.

       Conceptually, the scheduler maintains a list of runnable threads
       for each possible <i>sched_priority</i> value.  In order to determine
       which thread runs next, the scheduler looks for the nonempty list
       with the highest static priority and selects the thread at the
       head of this list.

       A thread's scheduling policy determines where it will be inserted
       into the list of threads with equal static priority and how it
       will move inside this list.

       All scheduling is preemptive: if a thread with a higher static
       priority becomes ready to run, the currently running thread will
       be preempted and returned to the wait list for its static
       priority level.  The scheduling policy determines the ordering
       only within the list of runnable threads with equal static
       priority.

   <b>SCHED_FIFO: First in-first out scheduling</b>
       <b>SCHED_FIFO </b>can be used only with static priorities higher than 0,
       which means that when a <b>SCHED_FIFO </b>thread becomes runnable, it
       will always immediately preempt any currently running
       <b>SCHED_OTHER</b>, <b>SCHED_BATCH</b>, or <b>SCHED_IDLE </b>thread.  <b>SCHED_FIFO </b>is a
       simple scheduling algorithm without time slicing.  For threads
       scheduled under the <b>SCHED_FIFO </b>policy, the following rules apply:

       •  A running <b>SCHED_FIFO </b>thread that has been preempted by another
          thread of higher priority will stay at the head of the list
          for its priority and will resume execution as soon as all
          threads of higher priority are blocked again.

       •  When a blocked <b>SCHED_FIFO </b>thread becomes runnable, it will be
          inserted at the end of the list for its priority.

       •  If a call to <a href="../man2/sched_setscheduler.2.html">sched_setscheduler(2)</a>, <a href="../man2/sched_setparam.2.html">sched_setparam(2)</a>,
          <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a>, <a href="../man3/pthread_setschedparam.3.html">pthread_setschedparam(3)</a>, or
          <a href="../man3/pthread_setschedprio.3.html">pthread_setschedprio(3)</a> changes the priority of the running or
          runnable <b>SCHED_FIFO </b>thread identified by <i>pid</i> the effect on the
          thread's position in the list depends on the direction of the
          change to the thread's priority:

          (a)  If the thread's priority is raised, it is placed at the
               end of the list for its new priority.  As a consequence,
               it may preempt a currently running thread with the same
               priority.

          (b)  If the thread's priority is unchanged, its position in
               the run list is unchanged.

          (c)  If the thread's priority is lowered, it is placed at the
               front of the list for its new priority.

          According to POSIX.1-2008, changes to a thread's priority (or
          policy) using any mechanism other than <a href="../man3/pthread_setschedprio.3.html">pthread_setschedprio(3)</a>
          should result in the thread being placed at the end of the
          list for its priority.

       •  A thread calling <a href="../man2/sched_yield.2.html">sched_yield(2)</a> will be put at the end of the
          list.

       No other events will move a thread scheduled under the <b>SCHED_FIFO</b>
       policy in the wait list of runnable threads with equal static
       priority.

       A <b>SCHED_FIFO </b>thread runs until either it is blocked by an I/O
       request, it is preempted by a higher priority thread, or it calls
       <a href="../man2/sched_yield.2.html">sched_yield(2)</a>.

   <b>SCHED_RR: Round-robin scheduling</b>
       <b>SCHED_RR </b>is a simple enhancement of <b>SCHED_FIFO</b>.  Everything
       described above for <b>SCHED_FIFO </b>also applies to <b>SCHED_RR</b>, except
       that each thread is allowed to run only for a maximum time
       quantum.  If a <b>SCHED_RR </b>thread has been running for a time period
       equal to or longer than the time quantum, it will be put at the
       end of the list for its priority.  A <b>SCHED_RR </b>thread that has
       been preempted by a higher priority thread and subsequently
       resumes execution as a running thread will complete the unexpired
       portion of its round-robin time quantum.  The length of the time
       quantum can be retrieved using <a href="../man2/sched_rr_get_interval.2.html">sched_rr_get_interval(2)</a>.

   <b>SCHED_DEADLINE: Sporadic task model deadline scheduling</b>
       Since Linux 3.14, Linux provides a deadline scheduling policy
       (<b>SCHED_DEADLINE</b>).  This policy is currently implemented using
       GEDF (Global Earliest Deadline First) in conjunction with CBS
       (Constant Bandwidth Server).  To set and fetch this policy and
       associated attributes, one must use the Linux-specific
       <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a> and <a href="../man2/sched_getattr.2.html">sched_getattr(2)</a> system calls.

       A sporadic task is one that has a sequence of jobs, where each
       job is activated at most once per period.  Each job also has a
       <i>relative deadline</i>, before which it should finish execution, and a
       <i>computation time</i>, which is the CPU time necessary for executing
       the job.  The moment when a task wakes up because a new job has
       to be executed is called the <i>arrival time</i> (also referred to as
       the request time or release time).  The <i>start time</i> is the time at
       which a task starts its execution.  The <i>absolute deadline</i> is thus
       obtained by adding the relative deadline to the arrival time.

       The following diagram clarifies these terms:

           arrival/wakeup                    absolute deadline
                |    start time                    |
                |        |                         |
                v        v                         v
           -----x--------xooooooooooooooooo--------x--------x---
                         |&lt;- comp. time -&gt;|
                |&lt;------- relative deadline ------&gt;|
                |&lt;-------------- period -------------------&gt;|

       When setting a <b>SCHED_DEADLINE </b>policy for a thread using
       <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a>, one can specify three parameters: <i>Runtime</i>,
       <i>Deadline</i>, and <i>Period</i>.  These parameters do not necessarily
       correspond to the aforementioned terms: usual practice is to set
       Runtime to something bigger than the average computation time (or
       worst-case execution time for hard real-time tasks), Deadline to
       the relative deadline, and Period to the period of the task.
       Thus, for <b>SCHED_DEADLINE </b>scheduling, we have:

           arrival/wakeup                    absolute deadline
                |    start time                    |
                |        |                         |
                v        v                         v
           -----x--------xooooooooooooooooo--------x--------x---
                         |&lt;-- Runtime -------&gt;|
                |&lt;----------- Deadline -----------&gt;|
                |&lt;-------------- Period -------------------&gt;|

       The three deadline-scheduling parameters correspond to the
       <i>sched_runtime</i>, <i>sched_deadline</i>, and <i>sched_period</i> fields of the
       <i>sched_attr</i> structure; see <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a>.  These fields express
       values in nanoseconds.  If <i>sched_period</i> is specified as 0, then
       it is made the same as <i>sched_deadline</i>.

       The kernel requires that:

           sched_runtime &lt;= sched_deadline &lt;= sched_period

       In addition, under the current implementation, all of the
       parameter values must be at least 1024 (i.e., just over one
       microsecond, which is the resolution of the implementation), and
       less than 2^63.  If any of these checks fails, <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a>
       fails with the error <b>EINVAL</b>.

       The CBS guarantees non-interference between tasks, by throttling
       threads that attempt to over-run their specified Runtime.

       To ensure deadline scheduling guarantees, the kernel must prevent
       situations where the set of <b>SCHED_DEADLINE </b>threads is not
       feasible (schedulable) within the given constraints.  The kernel
       thus performs an admittance test when setting or changing
       <b>SCHED_DEADLINE </b>policy and attributes.  This admission test
       calculates whether the change is feasible; if it is not,
       <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a> fails with the error <b>EBUSY</b>.

       For example, it is required (but not necessarily sufficient) for
       the total utilization to be less than or equal to the total
       number of CPUs available, where, since each thread can maximally
       run for Runtime per Period, that thread's utilization is its
       Runtime divided by its Period.

       In order to fulfill the guarantees that are made when a thread is
       admitted to the <b>SCHED_DEADLINE </b>policy, <b>SCHED_DEADLINE </b>threads are
       the highest priority (user controllable) threads in the system;
       if any <b>SCHED_DEADLINE </b>thread is runnable, it will preempt any
       thread scheduled under one of the other policies.

       A call to <a href="../man2/fork.2.html">fork(2)</a> by a thread scheduled under the <b>SCHED_DEADLINE</b>
       policy fails with the error <b>EAGAIN</b>, unless the thread has its
       reset-on-fork flag set (see below).

       A <b>SCHED_DEADLINE </b>thread that calls <a href="../man2/sched_yield.2.html">sched_yield(2)</a> will yield the
       current job and wait for a new period to begin.

   <b>SCHED_OTHER: Default Linux time-sharing scheduling</b>
       <b>SCHED_OTHER </b>can be used at only static priority 0 (i.e., threads
       under real-time policies always have priority over <b>SCHED_OTHER</b>
       processes).  <b>SCHED_OTHER </b>is the standard Linux time-sharing
       scheduler that is intended for all threads that do not require
       the special real-time mechanisms.

       The thread to run is chosen from the static priority 0 list based
       on a <i>dynamic</i> priority that is determined only inside this list.
       The dynamic priority is based on the nice value (see below) and
       is increased for each time quantum the thread is ready to run,
       but denied to run by the scheduler.  This ensures fair progress
       among all <b>SCHED_OTHER </b>threads.

       In the Linux kernel source code, the <b>SCHED_OTHER </b>policy is
       actually named <b>SCHED_NORMAL</b>.

   <b>The nice value</b>
       The nice value is an attribute that can be used to influence the
       CPU scheduler to favor or disfavor a process in scheduling
       decisions.  It affects the scheduling of <b>SCHED_OTHER </b>and
       <b>SCHED_BATCH </b>(see below) processes.  The nice value can be
       modified using <a href="../man2/nice.2.html">nice(2)</a>, <a href="../man2/setpriority.2.html">setpriority(2)</a>, or <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a>.

       According to POSIX.1, the nice value is a per-process attribute;
       that is, the threads in a process should share a nice value.
       However, on Linux, the nice value is a per-thread attribute:
       different threads in the same process may have different nice
       values.

       The range of the nice value varies across UNIX systems.  On
       modern Linux, the range is -20 (high priority) to +19 (low
       priority).  On some other systems, the range is -20..20.  Very
       early Linux kernels (before Linux 2.0) had the range
       -infinity..15.

       The degree to which the nice value affects the relative
       scheduling of <b>SCHED_OTHER </b>processes likewise varies across UNIX
       systems and across Linux kernel versions.

       With the advent of the CFS scheduler in Linux 2.6.23, Linux
       adopted an algorithm that causes relative differences in nice
       values to have a much stronger effect.  In the current
       implementation, each unit of difference in the nice values of two
       processes results in a factor of 1.25 in the degree to which the
       scheduler favors the higher priority process.  This causes very
       low nice values (+19) to truly provide little CPU to a process
       whenever there is any other higher priority load on the system,
       and makes high nice values (-20) deliver most of the CPU to
       applications that require it (e.g., some audio applications).

       On Linux, the <b>RLIMIT_NICE </b>resource limit can be used to define a
       limit to which an unprivileged process's nice value can be
       raised; see <a href="../man2/setrlimit.2.html">setrlimit(2)</a> for details.

       For further details on the nice value, see the subsections on the
       autogroup feature and group scheduling, below.

   <b>SCHED_BATCH: Scheduling batch processes</b>
       (Since Linux 2.6.16.)  <b>SCHED_BATCH </b>can be used only at static
       priority 0.  This policy is similar to <b>SCHED_OTHER </b>in that it
       schedules the thread according to its dynamic priority (based on
       the nice value).  The difference is that this policy will cause
       the scheduler to always assume that the thread is CPU-intensive.
       Consequently, the scheduler will apply a small scheduling penalty
       with respect to wakeup behavior, so that this thread is mildly
       disfavored in scheduling decisions.

       This policy is useful for workloads that are noninteractive, but
       do not want to lower their nice value, and for workloads that
       want a deterministic scheduling policy without interactivity
       causing extra preemptions (between the workload's tasks).

   <b>SCHED_IDLE: Scheduling very low priority jobs</b>
       (Since Linux 2.6.23.)  <b>SCHED_IDLE </b>can be used only at static
       priority 0; the process nice value has no influence for this
       policy.

       This policy is intended for running jobs at extremely low
       priority (lower even than a +19 nice value with the <b>SCHED_OTHER</b>
       or <b>SCHED_BATCH </b>policies).

   <b>Resetting scheduling policy for child processes</b>
       Each thread has a reset-on-fork scheduling flag.  When this flag
       is set, children created by <a href="../man2/fork.2.html">fork(2)</a> do not inherit privileged
       scheduling policies.  The reset-on-fork flag can be set by
       either:

       •  ORing the <b>SCHED_RESET_ON_FORK </b>flag into the <i>policy</i> argument
          when calling <a href="../man2/sched_setscheduler.2.html">sched_setscheduler(2)</a> (since Linux 2.6.32); or

       •  specifying the <b>SCHED_FLAG_RESET_ON_FORK </b>flag in
          <i>attr.sched_flags</i> when calling <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a>.

       Note that the constants used with these two APIs have different
       names.  The state of the reset-on-fork flag can analogously be
       retrieved using <a href="../man2/sched_getscheduler.2.html">sched_getscheduler(2)</a> and <a href="../man2/sched_getattr.2.html">sched_getattr(2)</a>.

       The reset-on-fork feature is intended for media-playback
       applications, and can be used to prevent applications evading the
       <b>RLIMIT_RTTIME </b>resource limit (see <a href="../man2/getrlimit.2.html">getrlimit(2)</a>) by creating
       multiple child processes.

       More precisely, if the reset-on-fork flag is set, the following
       rules apply for subsequently created children:

       •  If the calling thread has a scheduling policy of <b>SCHED_FIFO </b>or
          <b>SCHED_RR</b>, the policy is reset to <b>SCHED_OTHER </b>in child
          processes.

       •  If the calling process has a negative nice value, the nice
          value is reset to zero in child processes.

       After the reset-on-fork flag has been enabled, it can be reset
       only if the thread has the <b>CAP_SYS_NICE </b>capability.  This flag is
       disabled in child processes created by <a href="../man2/fork.2.html">fork(2)</a>.

   <b>Privileges and resource limits</b>
       Before Linux 2.6.12, only privileged (<b>CAP_SYS_NICE</b>) threads can
       set a nonzero static priority (i.e., set a real-time scheduling
       policy).  The only change that an unprivileged thread can make is
       to set the <b>SCHED_OTHER </b>policy, and this can be done only if the
       effective user ID of the caller matches the real or effective
       user ID of the target thread (i.e., the thread specified by <i>pid</i>)
       whose policy is being changed.

       A thread must be privileged (<b>CAP_SYS_NICE</b>) in order to set or
       modify a <b>SCHED_DEADLINE </b>policy.

       Since Linux 2.6.12, the <b>RLIMIT_RTPRIO </b>resource limit defines a
       ceiling on an unprivileged thread's static priority for the
       <b>SCHED_RR </b>and <b>SCHED_FIFO </b>policies.  The rules for changing
       scheduling policy and priority are as follows:

       •  If an unprivileged thread has a nonzero <b>RLIMIT_RTPRIO </b>soft
          limit, then it can change its scheduling policy and priority,
          subject to the restriction that the priority cannot be set to
          a value higher than the maximum of its current priority and
          its <b>RLIMIT_RTPRIO </b>soft limit.

       •  If the <b>RLIMIT_RTPRIO </b>soft limit is 0, then the only permitted
          changes are to lower the priority, or to switch to a non-real-
          time policy.

       •  Subject to the same rules, another unprivileged thread can
          also make these changes, as long as the effective user ID of
          the thread making the change matches the real or effective
          user ID of the target thread.

       •  Special rules apply for the <b>SCHED_IDLE </b>policy.  Before Linux
          2.6.39, an unprivileged thread operating under this policy
          cannot change its policy, regardless of the value of its
          <b>RLIMIT_RTPRIO </b>resource limit.  Since Linux 2.6.39, an
          unprivileged thread can switch to either the <b>SCHED_BATCH </b>or
          the <b>SCHED_OTHER </b>policy so long as its nice value falls within
          the range permitted by its <b>RLIMIT_NICE </b>resource limit (see
          <a href="../man2/getrlimit.2.html">getrlimit(2)</a>).

       Privileged (<b>CAP_SYS_NICE</b>) threads ignore the <b>RLIMIT_RTPRIO </b>limit;
       as with older kernels, they can make arbitrary changes to
       scheduling policy and priority.  See <a href="../man2/getrlimit.2.html">getrlimit(2)</a> for further
       information on <b>RLIMIT_RTPRIO</b>.

   <b>Limiting the CPU usage of real-time and deadline processes</b>
       A nonblocking infinite loop in a thread scheduled under the
       <b>SCHED_FIFO</b>, <b>SCHED_RR</b>, or <b>SCHED_DEADLINE </b>policy can potentially
       block all other threads from accessing the CPU forever.  Before
       Linux 2.6.25, the only way of preventing a runaway real-time
       process from freezing the system was to run (at the console) a
       shell scheduled under a higher static priority than the tested
       application.  This allows an emergency kill of tested real-time
       applications that do not block or terminate as expected.

       Since Linux 2.6.25, there are other techniques for dealing with
       runaway real-time and deadline processes.  One of these is to use
       the <b>RLIMIT_RTTIME </b>resource limit to set a ceiling on the CPU time
       that a real-time process may consume.  See <a href="../man2/getrlimit.2.html">getrlimit(2)</a> for
       details.

       Since Linux 2.6.25, Linux also provides two <i>/proc</i> files that can
       be used to reserve a certain amount of CPU time to be used by
       non-real-time processes.  Reserving CPU time in this fashion
       allows some CPU time to be allocated to (say) a root shell that
       can be used to kill a runaway process.  Both of these files
       specify time values in microseconds:

       <i>/proc/sys/kernel/sched_rt_period_us</i>
              This file specifies a scheduling period that is equivalent
              to 100% CPU bandwidth.  The value in this file can range
              from 1 to <b>INT_MAX</b>, giving an operating range of 1
              microsecond to around 35 minutes.  The default value in
              this file is 1,000,000 (1 second).

       <i>/proc/sys/kernel/sched_rt_runtime_us</i>
              The value in this file specifies how much of the "period"
              time can be used by all real-time and deadline scheduled
              processes on the system.  The value in this file can range
              from -1 to <b>INT_MAX</b>-1.  Specifying -1 makes the run time
              the same as the period; that is, no CPU time is set aside
              for non-real-time processes (which was the behavior before
              Linux 2.6.25).  The default value in this file is 950,000
              (0.95 seconds), meaning that 5% of the CPU time is
              reserved for processes that don't run under a real-time or
              deadline scheduling policy.

   <b>Response time</b>
       A blocked high priority thread waiting for I/O has a certain
       response time before it is scheduled again.  The device driver
       writer can greatly reduce this response time by using a "slow
       interrupt" interrupt handler.

   <b>Miscellaneous</b>
       Child processes inherit the scheduling policy and parameters
       across a <a href="../man2/fork.2.html">fork(2)</a>.  The scheduling policy and parameters are
       preserved across <a href="../man2/execve.2.html">execve(2)</a>.

       Memory locking is usually needed for real-time processes to avoid
       paging delays; this can be done with <a href="../man2/mlock.2.html">mlock(2)</a> or <a href="../man2/mlockall.2.html">mlockall(2)</a>.

   <b>The autogroup feature</b>
       Since Linux 2.6.38, the kernel provides a feature known as
       autogrouping to improve interactive desktop performance in the
       face of multiprocess, CPU-intensive workloads such as building
       the Linux kernel with large numbers of parallel build processes
       (i.e., the <a href="../man1/make.1.html">make(1)</a> <b>-j </b>flag).

       This feature operates in conjunction with the CFS scheduler and
       requires a kernel that is configured with <b>CONFIG_SCHED_AUTOGROUP</b>.
       On a running system, this feature is enabled or disabled via the
       file <i>/proc/sys/kernel/sched_autogroup_enabled</i>; a value of 0
       disables the feature, while a value of 1 enables it.  The default
       value in this file is 1, unless the kernel was booted with the
       <i>noautogroup</i> parameter.

       A new autogroup is created when a new session is created via
       <a href="../man2/setsid.2.html">setsid(2)</a>; this happens, for example, when a new terminal window
       is started.  A new process created by <a href="../man2/fork.2.html">fork(2)</a> inherits its
       parent's autogroup membership.  Thus, all of the processes in a
       session are members of the same autogroup.  An autogroup is
       automatically destroyed when the last process in the group
       terminates.

       When autogrouping is enabled, all of the members of an autogroup
       are placed in the same kernel scheduler "task group".  The CFS
       scheduler employs an algorithm that equalizes the distribution of
       CPU cycles across task groups.  The benefits of this for
       interactive desktop performance can be described via the
       following example.

       Suppose that there are two autogroups competing for the same CPU
       (i.e., presume either a single CPU system or the use of
       <a href="../man1/taskset.1.html">taskset(1)</a> to confine all the processes to the same CPU on an SMP
       system).  The first group contains ten CPU-bound processes from a
       kernel build started with <i>make -j10</i>.  The other contains a single
       CPU-bound process: a video player.  The effect of autogrouping is
       that the two groups will each receive half of the CPU cycles.
       That is, the video player will receive 50% of the CPU cycles,
       rather than just 9% of the cycles, which would likely lead to
       degraded video playback.  The situation on an SMP system is more
       complex, but the general effect is the same: the scheduler
       distributes CPU cycles across task groups such that an autogroup
       that contains a large number of CPU-bound processes does not end
       up hogging CPU cycles at the expense of the other jobs on the
       system.

       A process's autogroup (task group) membership can be viewed via
       the file <i>/proc/</i>pid<i>/autogroup</i>:

           $ <b>cat /proc/1/autogroup</b>
           /autogroup-1 nice 0

       This file can also be used to modify the CPU bandwidth allocated
       to an autogroup.  This is done by writing a number in the "nice"
       range to the file to set the autogroup's nice value.  The allowed
       range is from +19 (low priority) to -20 (high priority).
       (Writing values outside of this range causes <a href="../man2/write.2.html">write(2)</a> to fail
       with the error <b>EINVAL</b>.)

       The autogroup nice setting has the same meaning as the process
       nice value, but applies to distribution of CPU cycles to the
       autogroup as a whole, based on the relative nice values of other
       autogroups.  For a process inside an autogroup, the CPU cycles
       that it receives will be a product of the autogroup's nice value
       (compared to other autogroups) and the process's nice value
       (compared to other processes in the same autogroup.

       The use of the <a href="cgroups.7.html">cgroups(7)</a> CPU controller to place processes in
       cgroups other than the root CPU cgroup overrides the effect of
       autogrouping.

       The autogroup feature groups only processes scheduled under non-
       real-time policies (<b>SCHED_OTHER</b>, <b>SCHED_BATCH</b>, and <b>SCHED_IDLE</b>).
       It does not group processes scheduled under real-time and
       deadline policies.  Those processes are scheduled according to
       the rules described earlier.

   <b>The nice value and group scheduling</b>
       When scheduling non-real-time processes (i.e., those scheduled
       under the <b>SCHED_OTHER</b>, <b>SCHED_BATCH</b>, and <b>SCHED_IDLE </b>policies), the
       CFS scheduler employs a technique known as "group scheduling", if
       the kernel was configured with the <b>CONFIG_FAIR_GROUP_SCHED </b>option
       (which is typical).

       Under group scheduling, threads are scheduled in "task groups".
       Task groups have a hierarchical relationship, rooted under the
       initial task group on the system, known as the "root task group".
       Task groups are formed in the following circumstances:

       •  All of the threads in a CPU cgroup form a task group.  The
          parent of this task group is the task group of the
          corresponding parent cgroup.

       •  If autogrouping is enabled, then all of the threads that are
          (implicitly) placed in an autogroup (i.e., the same session,
          as created by <a href="../man2/setsid.2.html">setsid(2)</a>) form a task group.  Each new
          autogroup is thus a separate task group.  The root task group
          is the parent of all such autogroups.

       •  If autogrouping is enabled, then the root task group consists
          of all processes in the root CPU cgroup that were not
          otherwise implicitly placed into a new autogroup.

       •  If autogrouping is disabled, then the root task group consists
          of all processes in the root CPU cgroup.

       •  If group scheduling was disabled (i.e., the kernel was
          configured without <b>CONFIG_FAIR_GROUP_SCHED</b>), then all of the
          processes on the system are notionally placed in a single task
          group.

       Under group scheduling, a thread's nice value has an effect for
       scheduling decisions <i>only relative to other threads in the same</i>
       <i>task group</i>.  This has some surprising consequences in terms of
       the traditional semantics of the nice value on UNIX systems.  In
       particular, if autogrouping is enabled (which is the default in
       various distributions), then employing <a href="../man2/setpriority.2.html">setpriority(2)</a> or <a href="../man1/nice.1.html">nice(1)</a>
       on a process has an effect only for scheduling relative to other
       processes executed in the same session (typically: the same
       terminal window).

       Conversely, for two processes that are (for example) the sole
       CPU-bound processes in different sessions (e.g., different
       terminal windows, each of whose jobs are tied to different
       autogroups), <i>modifying the nice value of the process in one of</i>
       <i>the sessions has no effect</i> in terms of the scheduler's decisions
       relative to the process in the other session.  A possibly useful
       workaround here is to use a command such as the following to
       modify the autogroup nice value for <i>all</i> of the processes in a
       terminal session:

           $ <b>echo 10 &gt; /proc/self/autogroup</b>

   <b>Real-time features in the mainline Linux kernel</b>
       Since Linux 2.6.18, Linux is gradually becoming equipped with
       real-time capabilities, most of which are derived from the former
       <i>realtime-preempt</i> patch set.  Until the patches have been
       completely merged into the mainline kernel, they must be
       installed to achieve the best real-time performance.  These
       patches are named:

           patch-<i>kernelversion</i>-rt<i>patchversion</i>

       and can be downloaded from 
       ⟨<a href="http://www.kernel.org/pub/linux/kernel/projects/rt/">http://www.kernel.org/pub/linux/kernel/projects/rt/</a>⟩.

       Without the patches and prior to their full inclusion into the
       mainline kernel, the kernel configuration offers only the three
       preemption classes <b>CONFIG_PREEMPT_NONE</b>, <b>CONFIG_PREEMPT_VOLUNTARY</b>,
       and <b>CONFIG_PREEMPT_DESKTOP </b>which respectively provide no, some,
       and considerable reduction of the worst-case scheduling latency.

       With the patches applied or after their full inclusion into the
       mainline kernel, the additional configuration item
       <b>CONFIG_PREEMPT_RT </b>becomes available.  If this is selected, Linux
       is transformed into a regular real-time operating system.  The
       FIFO and RR scheduling policies are then used to run a thread
       with true real-time priority and a minimum worst-case scheduling
       latency.
</pre> <h2>
NOTES </h2>
<pre>
       The <a href="cgroups.7.html">cgroups(7)</a> CPU controller can be used to limit the CPU
       consumption of groups of processes.

       Originally, Standard Linux was intended as a general-purpose
       operating system being able to handle background processes,
       interactive applications, and less demanding real-time
       applications (applications that need to usually meet timing
       deadlines).  Although the Linux 2.6 allowed for kernel preemption
       and the newly introduced O(1) scheduler ensures that the time
       needed to schedule is fixed and deterministic irrespective of the
       number of active tasks, true real-time computing was not possible
       up to Linux 2.6.17.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <b>chcpu</b>(1), <a href="../man1/chrt.1.html">chrt(1)</a>, <a href="../man1/lscpu.1.html">lscpu(1)</a>, <a href="../man1/ps.1.html">ps(1)</a>, <a href="../man1/taskset.1.html">taskset(1)</a>, <a href="../man1/top.1.html">top(1)</a>,
       <a href="../man2/getpriority.2.html">getpriority(2)</a>, <a href="../man2/mlock.2.html">mlock(2)</a>, <a href="../man2/mlockall.2.html">mlockall(2)</a>, <a href="../man2/munlock.2.html">munlock(2)</a>, <a href="../man2/munlockall.2.html">munlockall(2)</a>,
       <a href="../man2/nice.2.html">nice(2)</a>, <a href="../man2/sched_get_priority_max.2.html">sched_get_priority_max(2)</a>, <a href="../man2/sched_get_priority_min.2.html">sched_get_priority_min(2)</a>,
       <a href="../man2/sched_getaffinity.2.html">sched_getaffinity(2)</a>, <a href="../man2/sched_getparam.2.html">sched_getparam(2)</a>, <a href="../man2/sched_getscheduler.2.html">sched_getscheduler(2)</a>,
       <a href="../man2/sched_rr_get_interval.2.html">sched_rr_get_interval(2)</a>, <a href="../man2/sched_setaffinity.2.html">sched_setaffinity(2)</a>,
       <a href="../man2/sched_setparam.2.html">sched_setparam(2)</a>, <a href="../man2/sched_setscheduler.2.html">sched_setscheduler(2)</a>, <a href="../man2/sched_yield.2.html">sched_yield(2)</a>,
       <a href="../man2/setpriority.2.html">setpriority(2)</a>, <a href="../man3/pthread_getaffinity_np.3.html">pthread_getaffinity_np(3)</a>,
       <a href="../man3/pthread_getschedparam.3.html">pthread_getschedparam(3)</a>, <a href="../man3/pthread_setaffinity_np.3.html">pthread_setaffinity_np(3)</a>,
       <a href="../man3/sched_getcpu.3.html">sched_getcpu(3)</a>, <a href="capabilities.7.html">capabilities(7)</a>, <a href="cpuset.7.html">cpuset(7)</a>

       <i>Programming</i>  <i>for the real world - POSIX.4</i> by Bill O. Gallmeister,
       O'Reilly &amp; Associates, Inc., ISBN 1-56592-074-0.

       The   Linux   kernel   source   files    <i>Documentation/scheduler/</i>
       <i>sched-deadline.txt</i>,   <i>Documentation/scheduler/sched-rt-group.txt</i>,
       <i>Documentation/scheduler/sched-design-CFS.txt</i>, and  <i>Documentation/</i>
       <i>scheduler/sched-nice-design.txt</i>
</pre> <h2>
COLOPHON </h2>
<pre>
       This  page  is  part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.   Information  about
       the       project       can       be       found       at      
       ⟨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>⟩.  If you have a bug report
       for           this           manual           page,           see
       ⟨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>⟩.
       This  page  was  obtained from the tarball man-pages-6.9.1.tar.gz
       fetched                                                      from
       ⟨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>⟩    on
       2024-06-26.  If you discover any rendering problems in this  HTML
       version of the page, or you believe there is a better or more up-
       to-date   source  for  the  page,  or  you  have  corrections  or
       improvements to the information in this COLOPHON  (which  is  <i>not</i>
       part   of   the   original   manual   page),   send   a  mail  to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-05-02                       <i>sched</i>(7)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/chrt.1.html">chrt(1)</a>, <a href="../man1/coresched.1.html">coresched(1)</a>, <a href="../man1/renice.1.html">renice(1)</a>, <a href="../man1/taskset.1.html">taskset(1)</a>, <a href="../man1/uclampset.1.html">uclampset(1)</a>, <a href="../man2/fork.2.html">fork(2)</a>, <a href="../man2/futex.2.html">futex(2)</a>, <a href="../man2/getpriority.2.html">getpriority(2)</a>, <a href="../man2/getrlimit.2.html">getrlimit(2)</a>, <a href="../man2/nice.2.html">nice(2)</a>, <a href="../man2/sched_get_priority_max.2.html">sched_get_priority_max(2)</a>, <a href="../man2/sched_rr_get_interval.2.html">sched_rr_get_interval(2)</a>, <a href="../man2/sched_setaffinity.2.html">sched_setaffinity(2)</a>, <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a>, <a href="../man2/sched_setparam.2.html">sched_setparam(2)</a>, <a href="../man2/sched_setscheduler.2.html">sched_setscheduler(2)</a>, <a href="../man2/sched_yield.2.html">sched_yield(2)</a>, <a href="../man2/setsid.2.html">setsid(2)</a>, <a href="../man3/pthread_attr_setinheritsched.3.html">pthread_attr_setinheritsched(3)</a>, <a href="../man3/pthread_attr_setschedparam.3.html">pthread_attr_setschedparam(3)</a>, <a href="../man3/pthread_attr_setschedpolicy.3.html">pthread_attr_setschedpolicy(3)</a>, <a href="../man3/pthread_setaffinity_np.3.html">pthread_setaffinity_np(3)</a>, <a href="../man3/pthread_setschedparam.3.html">pthread_setschedparam(3)</a>, <a href="../man3/pthread_setschedprio.3.html">pthread_setschedprio(3)</a>, <a href="../man3/pthread_yield.3.html">pthread_yield(3)</a>, <a href="../man3/sched_getcpu.3.html">sched_getcpu(3)</a>, <a href="../man5/proc_pid_autogroup.5.html">proc_pid_autogroup(5)</a>, <a href="../man5/proc_sys_kernel.5.html">proc_sys_kernel(5)</a>, <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>, <a href="../man5/systemd.resource-control.5.html">systemd.resource-control(5)</a>, <a href="capabilities.7.html">capabilities(7)</a>, <a href="cgroups.7.html">cgroups(7)</a>, <a href="cpuset.7.html">cpuset(7)</a>, <a href="pthreads.7.html">pthreads(7)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man7/sched.7.html" class="_attribution-link">https://man7.org/linux/man-pages/man7/sched.7.html</a>
  </p>
</div>
