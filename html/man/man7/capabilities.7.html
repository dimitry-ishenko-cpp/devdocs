<h1>capabilities(7) — Linux manual page</h1>   <pre>
<span class="headline"><i>Capabilities</i>(7)     Miscellaneous Information Manual     <i>Capabilities</i>(7)</span>
</pre> <h2>
NAME </h2>
<pre>
       capabilities - overview of Linux capabilities
</pre> <h2>
DESCRIPTION </h2>
<pre>
       For the purpose of performing permission checks, traditional UNIX
       implementations distinguish two categories of processes:
       <i>privileged</i> processes (whose effective user ID is 0, referred to
       as superuser or root), and <i>unprivileged</i> processes (whose
       effective UID is nonzero).  Privileged processes bypass all
       kernel permission checks, while unprivileged processes are
       subject to full permission checking based on the process's
       credentials (usually: effective UID, effective GID, and
       supplementary group list).

       Starting with Linux 2.2, Linux divides the privileges
       traditionally associated with superuser into distinct units,
       known as <i>capabilities</i>, which can be independently enabled and
       disabled.  Capabilities are a per-thread attribute.

   <b>Capabilities list</b>
       The following list shows the capabilities implemented on Linux,
       and the operations or behaviors that each capability permits:

       <b>CAP_AUDIT_CONTROL </b>(since Linux 2.6.11)
              Enable and disable kernel auditing; change auditing filter
              rules; retrieve auditing status and filtering rules.

       <b>CAP_AUDIT_READ </b>(since Linux 3.16)
              Allow reading the audit log via a multicast netlink
              socket.

       <b>CAP_AUDIT_WRITE </b>(since Linux 2.6.11)
              Write records to kernel auditing log.

       <b>CAP_BLOCK_SUSPEND </b>(since Linux 3.5)
              Employ features that can block system suspend (<a href="epoll.7.html">epoll(7)</a>
              <b>EPOLLWAKEUP</b>, <i>/proc/sys/wake_lock</i>).

       <b>CAP_BPF </b>(since Linux 5.8)
              Employ privileged BPF operations; see <a href="../man2/bpf.2.html">bpf(2)</a> and
              <a href="bpf-helpers.7.html">bpf-helpers(7)</a>.

              This capability was added in Linux 5.8 to separate out BPF
              functionality from the overloaded <b>CAP_SYS_ADMIN</b>
              capability.

       <b>CAP_CHECKPOINT_RESTORE </b>(since Linux 5.9)
              •  Update <i>/proc/sys/kernel/ns_last_pid</i> (see
                 <a href="pid_namespaces.7.html">pid_namespaces(7)</a>);
              •  employ the <i>set_tid</i> feature of <a href="../man2/clone3.2.html">clone3(2)</a>;
              •  read the contents of the symbolic links in
                 <i>/proc/</i>pid<i>/map_files</i> for other processes.

              This capability was added in Linux 5.9 to separate out
              checkpoint/restore functionality from the overloaded
              <b>CAP_SYS_ADMIN </b>capability.

       <b>CAP_CHOWN</b>
              Make arbitrary changes to file UIDs and GIDs (see
              <a href="../man2/chown.2.html">chown(2)</a>).

       <b>CAP_DAC_OVERRIDE</b>
              Bypass file read, write, and execute permission checks.
              (DAC is an abbreviation of "discretionary access
              control".)

       <b>CAP_DAC_READ_SEARCH</b>
              •  Bypass file read permission checks and directory read
                 and execute permission checks;
              •  invoke <a href="../man2/open_by_handle_at.2.html">open_by_handle_at(2)</a>;
              •  use the <a href="../man2/linkat.2.html">linkat(2)</a> <b>AT_EMPTY_PATH </b>flag to create a link
                 to a file referred to by a file descriptor.

       <b>CAP_FOWNER</b>
              •  Bypass permission checks on operations that normally
                 require the filesystem UID of the process to match the
                 UID of the file (e.g., <a href="../man2/chmod.2.html">chmod(2)</a>, <a href="../man2/utime.2.html">utime(2)</a>), excluding
                 those operations covered by <b>CAP_DAC_OVERRIDE </b>and
                 <b>CAP_DAC_READ_SEARCH</b>;
              •  set inode flags (see <a href="../man2/fs_ioc_setflags.2const.html">FS_IOC_SETFLAGS(2const)</a>) on
                 arbitrary files;
              •  set Access Control Lists (ACLs) on arbitrary files;
              •  ignore directory sticky bit on file deletion;
              •  modify <i>user</i> extended attributes on sticky directory
                 owned by any user;
              •  specify <b>O_NOATIME </b>for arbitrary files in <a href="../man2/open.2.html">open(2)</a> and
                 <a href="../man2/fcntl.2.html">fcntl(2)</a>.

       <b>CAP_FSETID</b>
              •  Don't clear set-user-ID and set-group-ID mode bits when
                 a file is modified;
              •  set the set-group-ID bit for a file whose GID does not
                 match the filesystem or any of the supplementary GIDs
                 of the calling process.

       <b>CAP_IPC_LOCK</b>
              •  Lock memory (<a href="../man2/mlock.2.html">mlock(2)</a>, <a href="../man2/mlockall.2.html">mlockall(2)</a>, <a href="../man2/mmap.2.html">mmap(2)</a>,
                 <a href="../man2/shmctl.2.html">shmctl(2)</a>);
              •  Allocate memory using huge pages (<a href="../man2/memfd_create.2.html">memfd_create(2)</a>,
                 <a href="../man2/mmap.2.html">mmap(2)</a>, <a href="../man2/shmctl.2.html">shmctl(2)</a>).

       <b>CAP_IPC_OWNER</b>
              Bypass permission checks for operations on System V IPC
              objects.

       <b>CAP_KILL</b>
              Bypass permission checks for sending signals (see
              <a href="../man2/kill.2.html">kill(2)</a>).  This includes use of the <a href="../man2/ioctl.2.html">ioctl(2)</a> <b>KDSIGACCEPT</b>
              operation.

       <b>CAP_LEASE </b>(since Linux 2.4)
              Establish leases on arbitrary files (see <a href="../man2/fcntl.2.html">fcntl(2)</a>).

       <b>CAP_LINUX_IMMUTABLE</b>
              Set the <b>FS_APPEND_FL </b>and <b>FS_IMMUTABLE_FL </b>inode flags (see
              <a href="../man2/fs_ioc_setflags.2const.html">FS_IOC_SETFLAGS(2const)</a>).

       <b>CAP_MAC_ADMIN </b>(since Linux 2.6.25)
              Allow MAC configuration or state changes.  Implemented for
              the Smack Linux Security Module (LSM).

       <b>CAP_MAC_OVERRIDE </b>(since Linux 2.6.25)
              Override Mandatory Access Control (MAC).  Implemented for
              the Smack LSM.

       <b>CAP_MKNOD </b>(since Linux 2.4)
              Create special files using <a href="../man2/mknod.2.html">mknod(2)</a>.

       <b>CAP_NET_ADMIN</b>
              Perform various network-related operations:
              •  interface configuration;
              •  administration of IP firewall, masquerading, and
                 accounting;
              •  modify routing tables;
              •  bind to any address for transparent proxying;
              •  set type-of-service (TOS);
              •  clear driver statistics;
              •  set promiscuous mode;
              •  enabling multicasting;
              •  use <a href="../man2/setsockopt.2.html">setsockopt(2)</a> to set the following socket options:
                 <b>SO_DEBUG</b>, <b>SO_MARK</b>, <b>SO_PRIORITY </b>(for a priority outside
                 the range 0 to 6), <b>SO_RCVBUFFORCE</b>, and <b>SO_SNDBUFFORCE</b>.

       <b>CAP_NET_BIND_SERVICE</b>
              Bind a socket to Internet domain privileged ports (port
              numbers less than 1024).

       <b>CAP_NET_BROADCAST</b>
              (Unused)  Make socket broadcasts, and listen to
              multicasts.

       <b>CAP_NET_RAW</b>
              •  Use RAW and PACKET sockets;
              •  bind to any address for transparent proxying.

       <b>CAP_PERFMON </b>(since Linux 5.8)
              Employ various performance-monitoring mechanisms,
              including:

              •  call <a href="../man2/perf_event_open.2.html">perf_event_open(2)</a>;
              •  employ various BPF operations that have performance
                 implications.

              This capability was added in Linux 5.8 to separate out
              performance monitoring functionality from the overloaded
              <b>CAP_SYS_ADMIN </b>capability.  See also the kernel source file
              <i>Documentation/admin-guide/perf-security.rst</i>.

       <b>CAP_SETGID</b>
              •  Make arbitrary manipulations of process GIDs and
                 supplementary GID list;
              •  forge GID when passing socket credentials via UNIX
                 domain sockets;
              •  write a group ID mapping in a user namespace (see
                 <a href="user_namespaces.7.html">user_namespaces(7)</a>).

       <b>CAP_SETFCAP </b>(since Linux 2.6.24)
              Set arbitrary capabilities on a file.

              Since Linux 5.12, this capability is also needed to map
              user ID 0 in a new user namespace; see <a href="user_namespaces.7.html">user_namespaces(7)</a>
              for details.

       <b>CAP_SETPCAP</b>
              If file capabilities are supported (i.e., since Linux
              2.6.24): add any capability from the calling thread's
              bounding set to its inheritable set; drop capabilities
              from the bounding set (via <a href="../man2/prctl.2.html">prctl(2)</a> <b>PR_CAPBSET_DROP</b>); make
              changes to the <i>securebits</i> flags.

              If file capabilities are not supported (i.e., before Linux
              2.6.24): grant or remove any capability in the caller's
              permitted capability set to or from any other process.
              (This property of <b>CAP_SETPCAP </b>is not available when the
              kernel is configured to support file capabilities, since
              <b>CAP_SETPCAP </b>has entirely different semantics for such
              kernels.)

       <b>CAP_SETUID</b>
              •  Make arbitrary manipulations of process UIDs
                 (<a href="../man2/setuid.2.html">setuid(2)</a>, <a href="../man2/setreuid.2.html">setreuid(2)</a>, <a href="../man2/setresuid.2.html">setresuid(2)</a>, <a href="../man2/setfsuid.2.html">setfsuid(2)</a>);
              •  forge UID when passing socket credentials via UNIX
                 domain sockets;
              •  write a user ID mapping in a user namespace (see
                 <a href="user_namespaces.7.html">user_namespaces(7)</a>).

       <b>CAP_SYS_ADMIN</b>
              <i>Note</i>: this capability is overloaded; see <i>Notes to kernel</i>
              <i>developers</i> below.

              •  Perform a range of system administration operations
                 including: <a href="../man2/quotactl.2.html">quotactl(2)</a>, <a href="../man2/mount.2.html">mount(2)</a>, <a href="../man2/umount.2.html">umount(2)</a>,
                 <a href="../man2/pivot_root.2.html">pivot_root(2)</a>, <a href="../man2/swapon.2.html">swapon(2)</a>, <a href="../man2/swapoff.2.html">swapoff(2)</a>, <a href="../man2/sethostname.2.html">sethostname(2)</a>,
                 and <a href="../man2/setdomainname.2.html">setdomainname(2)</a>;
              •  perform privileged <a href="../man2/syslog.2.html">syslog(2)</a> operations (since Linux
                 2.6.37, <b>CAP_SYSLOG </b>should be used to permit such
                 operations);
              •  perform <b>VM86_REQUEST_IRQ vm86</b>(2) command;
              •  access the same checkpoint/restore functionality that
                 is governed by <b>CAP_CHECKPOINT_RESTORE </b>(but the latter,
                 weaker capability is preferred for accessing that
                 functionality).
              •  perform the same BPF operations as are governed by
                 <b>CAP_BPF </b>(but the latter, weaker capability is preferred
                 for accessing that functionality).
              •  employ the same performance monitoring mechanisms as
                 are governed by <b>CAP_PERFMON </b>(but the latter, weaker
                 capability is preferred for accessing that
                 functionality).
              •  perform <b>IPC_SET </b>and <b>IPC_RMID </b>operations on arbitrary
                 System V IPC objects;
              •  override <b>RLIMIT_NPROC </b>resource limit;
              •  perform operations on <i>trusted</i> and <i>security</i> extended
                 attributes (see <a href="xattr.7.html">xattr(7)</a>);
              •  use <a href="../man2/lookup_dcookie.2.html">lookup_dcookie(2)</a>;
              •  use <a href="../man2/ioprio_set.2.html">ioprio_set(2)</a> to assign <b>IOPRIO_CLASS_RT </b>and (before
                 Linux 2.6.25) <b>IOPRIO_CLASS_IDLE </b>I/O scheduling classes;
              •  forge PID when passing socket credentials via UNIX
                 domain sockets;
              •  exceed <i>/proc/sys/fs/file-max</i>, the system-wide limit on
                 the number of open files, in system calls that open
                 files (e.g., <a href="../man2/accept.2.html">accept(2)</a>, <a href="../man2/execve.2.html">execve(2)</a>, <a href="../man2/open.2.html">open(2)</a>, <a href="../man2/pipe.2.html">pipe(2)</a>);
              •  employ <b>CLONE_* </b>flags that create new namespaces with
                 <a href="../man2/clone.2.html">clone(2)</a> and <a href="../man2/unshare.2.html">unshare(2)</a> (but, since Linux 3.8, creating
                 user namespaces does not require any capability);
              •  access privileged <i>perf</i> event information;
              •  call <a href="../man2/setns.2.html">setns(2)</a> (requires <b>CAP_SYS_ADMIN </b>in the <i>target</i>
                 namespace);
              •  call <a href="../man2/fanotify_init.2.html">fanotify_init(2)</a>;
              •  perform privileged <b>KEYCTL_CHOWN </b>and <b>KEYCTL_SETPERM</b>
                 <a href="../man2/keyctl.2.html">keyctl(2)</a> operations;
              •  perform <a href="../man2/madvise.2.html">madvise(2)</a> <b>MADV_HWPOISON </b>operation;
              •  employ the <b>TIOCSTI ioctl</b>(2) to insert characters into
                 the input queue of a terminal other than the caller's
                 controlling terminal;
              •  employ the obsolete <a href="../man2/nfsservctl.2.html">nfsservctl(2)</a> system call;
              •  employ the obsolete <a href="../man2/bdflush.2.html">bdflush(2)</a> system call;
              •  perform various privileged block-device <a href="../man2/ioctl.2.html">ioctl(2)</a>
                 operations;
              •  perform various privileged filesystem <a href="../man2/ioctl.2.html">ioctl(2)</a>
                 operations;
              •  perform privileged <a href="../man2/ioctl.2.html">ioctl(2)</a> operations on the
                 <i>/dev/random</i> device (see <a href="../man4/random.4.html">random(4)</a>);
              •  install a <a href="../man2/seccomp.2.html">seccomp(2)</a> filter without first having to set
                 the <i>no_new_privs</i> thread attribute;
              •  modify allow/deny rules for device control groups;
              •  employ the <a href="../man2/ptrace.2.html">ptrace(2)</a> <b>PTRACE_SECCOMP_GET_FILTER</b>
                 operation to dump tracee's seccomp filters;
              •  employ the <a href="../man2/ptrace.2.html">ptrace(2)</a> <b>PTRACE_SETOPTIONS </b>operation to
                 suspend the tracee's seccomp protections (i.e., the
                 <b>PTRACE_O_SUSPEND_SECCOMP </b>flag);
              •  perform administrative operations on many device
                 drivers;
              •  modify autogroup nice values by writing to
                 <i>/proc/</i>pid<i>/autogroup</i> (see <a href="sched.7.html">sched(7)</a>).

       <b>CAP_SYS_BOOT</b>
              Use <a href="../man2/reboot.2.html">reboot(2)</a> and <a href="../man2/kexec_load.2.html">kexec_load(2)</a>.

       <b>CAP_SYS_CHROOT</b>
              •  Use <a href="../man2/chroot.2.html">chroot(2)</a>;
              •  change mount namespaces using <a href="../man2/setns.2.html">setns(2)</a>.

       <b>CAP_SYS_MODULE</b>
              •  Load and unload kernel modules (see <a href="../man2/init_module.2.html">init_module(2)</a> and
                 <a href="../man2/delete_module.2.html">delete_module(2)</a>);
              •  before Linux 2.6.25: drop capabilities from the system-
                 wide capability bounding set.

       <b>CAP_SYS_NICE</b>
              •  Lower the process nice value (<a href="../man2/nice.2.html">nice(2)</a>, <a href="../man2/setpriority.2.html">setpriority(2)</a>)
                 and change the nice value for arbitrary processes;
              •  set real-time scheduling policies for calling process,
                 and set scheduling policies and priorities for
                 arbitrary processes (<a href="../man2/sched_setscheduler.2.html">sched_setscheduler(2)</a>,
                 <a href="../man2/sched_setparam.2.html">sched_setparam(2)</a>, <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a>);
              •  set CPU affinity for arbitrary processes
                 (<a href="../man2/sched_setaffinity.2.html">sched_setaffinity(2)</a>);
              •  set I/O scheduling class and priority for arbitrary
                 processes (<a href="../man2/ioprio_set.2.html">ioprio_set(2)</a>);
              •  apply <a href="../man2/migrate_pages.2.html">migrate_pages(2)</a> to arbitrary processes and allow
                 processes to be migrated to arbitrary nodes;
              •  apply <a href="../man2/move_pages.2.html">move_pages(2)</a> to arbitrary processes;
              •  use the <b>MPOL_MF_MOVE_ALL </b>flag with <a href="../man2/mbind.2.html">mbind(2)</a> and
                 <a href="../man2/move_pages.2.html">move_pages(2)</a>.

       <b>CAP_SYS_PACCT</b>
              Use <a href="../man2/acct.2.html">acct(2)</a>.

       <b>CAP_SYS_PTRACE</b>
              •  Trace arbitrary processes using <a href="../man2/ptrace.2.html">ptrace(2)</a>;
              •  apply <a href="../man2/get_robust_list.2.html">get_robust_list(2)</a> to arbitrary processes;
              •  transfer data to or from the memory of arbitrary
                 processes using <a href="../man2/process_vm_readv.2.html">process_vm_readv(2)</a> and
                 <a href="../man2/process_vm_writev.2.html">process_vm_writev(2)</a>;
              •  inspect processes using <a href="../man2/kcmp.2.html">kcmp(2)</a>.

       <b>CAP_SYS_RAWIO</b>
              •  Perform I/O port operations (<a href="../man2/iopl.2.html">iopl(2)</a> and <a href="../man2/ioperm.2.html">ioperm(2)</a>);
              •  access <i>/proc/kcore</i>;
              •  employ the <b>FIBMAP ioctl</b>(2) operation;
              •  open devices for accessing x86 model-specific registers
                 (MSRs, see <a href="../man4/msr.4.html">msr(4)</a>);
              •  update <i>/proc/sys/vm/mmap_min_addr</i>;
              •  create memory mappings at addresses below the value
                 specified by <i>/proc/sys/vm/mmap_min_addr</i>;
              •  map files in <i>/proc/bus/pci</i>;
              •  open <i>/dev/mem</i> and <i>/dev/kmem</i>;
              •  perform various SCSI device commands;
              •  perform certain operations on <a href="../man4/hpsa.4.html">hpsa(4)</a> and <a href="../man4/cciss.4.html">cciss(4)</a>
                 devices;
              •  perform a range of device-specific operations on other
                 devices.

       <b>CAP_SYS_RESOURCE</b>
              •  Use reserved space on ext2 filesystems;
              •  make <a href="../man2/ioctl.2.html">ioctl(2)</a> calls controlling ext3 journaling;
              •  override disk quota limits;
              •  increase resource limits (see <a href="../man2/setrlimit.2.html">setrlimit(2)</a>);
              •  override <b>RLIMIT_NPROC </b>resource limit;
              •  override maximum number of consoles on console
                 allocation;
              •  override maximum number of keymaps;
              •  allow more than 64hz interrupts from the real-time
                 clock;
              •  raise <i>msg_qbytes</i> limit for a System V message queue
                 above the limit in <i>/proc/sys/kernel/msgmnb</i> (see
                 <a href="../man2/msgop.2.html">msgop(2)</a> and <a href="../man2/msgctl.2.html">msgctl(2)</a>);
              •  allow the <b>RLIMIT_NOFILE </b>resource limit on the number of
                 "in-flight" file descriptors to be bypassed when
                 passing file descriptors to another process via a UNIX
                 domain socket (see <a href="unix.7.html">unix(7)</a>);
              •  override the <i>/proc/sys/fs/pipe-size-max</i> limit when
                 setting the capacity of a pipe using the <b>F_SETPIPE_SZ</b>
                 <a href="../man2/fcntl.2.html">fcntl(2)</a> command;
              •  use <b>F_SETPIPE_SZ </b>to increase the capacity of a pipe
                 above the limit specified by
                 <i>/proc/sys/fs/pipe-max-size</i>;
              •  override <i>/proc/sys/fs/mqueue/queues_max</i>,
                 <i>/proc/sys/fs/mqueue/msg_max</i>, and
                 <i>/proc/sys/fs/mqueue/msgsize_max</i> limits when creating
                 POSIX message queues (see <a href="mq_overview.7.html">mq_overview(7)</a>);
              •  employ the <a href="../man2/prctl.2.html">prctl(2)</a> <b>PR_SET_MM </b>operation;
              •  set <i>/proc/</i>pid<i>/oom_score_adj</i> to a value lower than the
                 value last set by a process with <b>CAP_SYS_RESOURCE</b>.

       <b>CAP_SYS_TIME</b>
              Set system clock (<a href="../man2/settimeofday.2.html">settimeofday(2)</a>, <a href="../man2/stime.2.html">stime(2)</a>, <a href="../man2/adjtimex.2.html">adjtimex(2)</a>);
              set real-time (hardware) clock.

       <b>CAP_SYS_TTY_CONFIG</b>
              Use <a href="../man2/vhangup.2.html">vhangup(2)</a>; employ various privileged <a href="../man2/ioctl.2.html">ioctl(2)</a>
              operations on virtual terminals.

       <b>CAP_SYSLOG </b>(since Linux 2.6.37)
              •  Perform privileged <a href="../man2/syslog.2.html">syslog(2)</a> operations.  See <a href="../man2/syslog.2.html">syslog(2)</a>
                 for information on which operations require privilege.
              •  View kernel addresses exposed via <i>/proc</i> and other
                 interfaces when <i>/proc/sys/kernel/kptr_restrict</i> has the
                 value 1.  (See the discussion of the <i>kptr_restrict</i> in
                 <a href="../man5/proc.5.html">proc(5)</a>.)

       <b>CAP_WAKE_ALARM </b>(since Linux 3.0)
              Trigger something that will wake up the system (set
              <b>CLOCK_REALTIME_ALARM </b>and <b>CLOCK_BOOTTIME_ALARM </b>timers).

   <b>Past and current implementation</b>
       A full implementation of capabilities requires that:

       •  For all privileged operations, the kernel must check whether
          the thread has the required capability in its effective set.

       •  The kernel must provide system calls allowing a thread's
          capability sets to be changed and retrieved.

       •  The filesystem must support attaching capabilities to an
          executable file, so that a process gains those capabilities
          when the file is executed.

       Before Linux 2.6.24, only the first two of these requirements are
       met; since Linux 2.6.24, all three requirements are met.

   <b>Notes to kernel developers</b>
       When adding a new kernel feature that should be governed by a
       capability, consider the following points.

       •  The goal of capabilities is divide the power of superuser into
          pieces, such that if a program that has one or more
          capabilities is compromised, its power to do damage to the
          system would be less than the same program running with root
          privilege.

       •  You have the choice of either creating a new capability for
          your new feature, or associating the feature with one of the
          existing capabilities.  In order to keep the set of
          capabilities to a manageable size, the latter option is
          preferable, unless there are compelling reasons to take the
          former option.  (There is also a technical limit: the size of
          capability sets is currently limited to 64 bits.)

       •  To determine which existing capability might best be
          associated with your new feature, review the list of
          capabilities above in order to find a "silo" into which your
          new feature best fits.  One approach to take is to determine
          if there are other features requiring capabilities that will
          always be used along with the new feature.  If the new feature
          is useless without these other features, you should use the
          same capability as the other features.

       •  <i>Don't</i> choose <b>CAP_SYS_ADMIN </b>if you can possibly avoid it!  A
          vast proportion of existing capability checks are associated
          with this capability (see the partial list above).  It can
          plausibly be called "the new root", since on the one hand, it
          confers a wide range of powers, and on the other hand, its
          broad scope means that this is the capability that is required
          by many privileged programs.  Don't make the problem worse.
          The only new features that should be associated with
          <b>CAP_SYS_ADMIN </b>are ones that <i>closely</i> match existing uses in
          that silo.

       •  If you have determined that it really is necessary to create a
          new capability for your feature, don't make or name it as a
          "single-use" capability.  Thus, for example, the addition of
          the highly specific <b>CAP_SYS_PACCT </b>was probably a mistake.
          Instead, try to identify and name your new capability as a
          broader silo into which other related future use cases might
          fit.

   <b>Thread capability sets</b>
       Each thread has the following capability sets containing zero or
       more of the above capabilities:

       <i>Permitted</i>
              This is a limiting superset for the effective capabilities
              that the thread may assume.  It is also a limiting
              superset for the capabilities that may be added to the
              inheritable set by a thread that does not have the
              <b>CAP_SETPCAP </b>capability in its effective set.

              If a thread drops a capability from its permitted set, it
              can never reacquire that capability (unless it <a href="../man2/execve.2.html">execve(2)</a>s
              either a set-user-ID-root program, or a program whose
              associated file capabilities grant that capability).

       <i>Inheritable</i>
              This is a set of capabilities preserved across an
              <a href="../man2/execve.2.html">execve(2)</a>.  Inheritable capabilities remain inheritable
              when executing any program, and inheritable capabilities
              are added to the permitted set when executing a program
              that has the corresponding bits set in the file
              inheritable set.

              Because inheritable capabilities are not generally
              preserved across <a href="../man2/execve.2.html">execve(2)</a> when running as a non-root
              user, applications that wish to run helper programs with
              elevated capabilities should consider using ambient
              capabilities, described below.

       <i>Effective</i>
              This is the set of capabilities used by the kernel to
              perform permission checks for the thread.

       <i>Bounding</i> (per-thread since Linux 2.6.25)
              The capability bounding set is a mechanism that can be
              used to limit the capabilities that are gained during
              <a href="../man2/execve.2.html">execve(2)</a>.

              Since Linux 2.6.25, this is a per-thread capability set.
              In older kernels, the capability bounding set was a system
              wide attribute shared by all threads on the system.

              For more details, see <i>Capability bounding set</i> below.

       <i>Ambient</i> (since Linux 4.3)
              This is a set of capabilities that are preserved across an
              <a href="../man2/execve.2.html">execve(2)</a> of a program that is not privileged.  The
              ambient capability set obeys the invariant that no
              capability can ever be ambient if it is not both permitted
              and inheritable.

              The ambient capability set can be directly modified using
              <a href="../man2/prctl.2.html">prctl(2)</a>.  Ambient capabilities are automatically lowered
              if either of the corresponding permitted or inheritable
              capabilities is lowered.

              Executing a program that changes UID or GID due to the
              set-user-ID or set-group-ID bits or executing a program
              that has any file capabilities set will clear the ambient
              set.  Ambient capabilities are added to the permitted set
              and assigned to the effective set when <a href="../man2/execve.2.html">execve(2)</a> is
              called.  If ambient capabilities cause a process's
              permitted and effective capabilities to increase during an
              <a href="../man2/execve.2.html">execve(2)</a>, this does not trigger the secure-execution mode
              described in <a href="../man8/ld.so.8.html">ld.so(8)</a>.

       A child created via <a href="../man2/fork.2.html">fork(2)</a> inherits copies of its parent's
       capability sets.  For details on how <a href="../man2/execve.2.html">execve(2)</a> affects
       capabilities, see <i>Transformation of capabilities during execve()</i>
       below.

       Using <a href="../man2/capset.2.html">capset(2)</a>, a thread may manipulate its own capability sets;
       see <i>Programmatically adjusting capability sets</i> below.

       Since Linux 3.2, the file <i>/proc/sys/kernel/cap_last_cap</i> exposes
       the numerical value of the highest capability supported by the
       running kernel; this can be used to determine the highest bit
       that may be set in a capability set.

   <b>File capabilities</b>
       Since Linux 2.6.24, the kernel supports associating capability
       sets with an executable file using <a href="../man8/setcap.8.html">setcap(8)</a>.  The file
       capability sets are stored in an extended attribute (see
       <a href="../man2/setxattr.2.html">setxattr(2)</a> and <a href="xattr.7.html">xattr(7)</a>) named <i>security.capability</i>.  Writing to
       this extended attribute requires the <b>CAP_SETFCAP </b>capability.  The
       file capability sets, in conjunction with the capability sets of
       the thread, determine the capabilities of a thread after an
       <a href="../man2/execve.2.html">execve(2)</a>.

       The three file capability sets are:

       <i>Permitted</i> (formerly known as <i>forced</i>):
              These capabilities are automatically permitted to the
              thread, regardless of the thread's inheritable
              capabilities.

       <i>Inheritable</i> (formerly known as <i>allowed</i>):
              This set is ANDed with the thread's inheritable set to
              determine which inheritable capabilities are enabled in
              the permitted set of the thread after the <a href="../man2/execve.2.html">execve(2)</a>.

       <i>Effective</i>:
              This is not a set, but rather just a single bit.  If this
              bit is set, then during an <a href="../man2/execve.2.html">execve(2)</a> all of the new
              permitted capabilities for the thread are also raised in
              the effective set.  If this bit is not set, then after an
              <a href="../man2/execve.2.html">execve(2)</a>, none of the new permitted capabilities is in
              the new effective set.

              Enabling the file effective capability bit implies that
              any file permitted or inheritable capability that causes a
              thread to acquire the corresponding permitted capability
              during an <a href="../man2/execve.2.html">execve(2)</a> (see <i>Transformation of capabilities</i>
              <i>during execve()</i> below) will also acquire that capability
              in its effective set.  Therefore, when assigning
              capabilities to a file (<a href="../man8/setcap.8.html">setcap(8)</a>, <a href="../man3/cap_set_file.3.html">cap_set_file(3)</a>,
              <a href="../man3/cap_set_fd.3.html">cap_set_fd(3)</a>), if we specify the effective flag as being
              enabled for any capability, then the effective flag must
              also be specified as enabled for all other capabilities
              for which the corresponding permitted or inheritable flag
              is enabled.

   <b>File capability extended attribute versioning</b>
       To allow extensibility, the kernel supports a scheme to encode a
       version number inside the <i>security.capability</i> extended attribute
       that is used to implement file capabilities.  These version
       numbers are internal to the implementation, and not directly
       visible to user-space applications.  To date, the following
       versions are supported:

       <b>VFS_CAP_REVISION_1</b>
              This was the original file capability implementation,
              which supported 32-bit masks for file capabilities.

       <b>VFS_CAP_REVISION_2 </b>(since Linux 2.6.25)
              This version allows for file capability masks that are 64
              bits in size, and was necessary as the number of supported
              capabilities grew beyond 32.  The kernel transparently
              continues to support the execution of files that have
              32-bit version 1 capability masks, but when adding
              capabilities to files that did not previously have
              capabilities, or modifying the capabilities of existing
              files, it automatically uses the version 2 scheme (or
              possibly the version 3 scheme, as described below).

       <b>VFS_CAP_REVISION_3 </b>(since Linux 4.14)
              Version 3 file capabilities are provided to support
              namespaced file capabilities (described below).

              As with version 2 file capabilities, version 3 capability
              masks are 64 bits in size.  But in addition, the root user
              ID of namespace is encoded in the <i>security.capability</i>
              extended attribute.  (A namespace's root user ID is the
              value that user ID 0 inside that namespace maps to in the
              initial user namespace.)

              Version 3 file capabilities are designed to coexist with
              version 2 capabilities; that is, on a modern Linux system,
              there may be some files with version 2 capabilities while
              others have version 3 capabilities.

       Before Linux 4.14, the only kind of file capability extended
       attribute that could be attached to a file was a
       <b>VFS_CAP_REVISION_2 </b>attribute.  Since Linux 4.14, the version of
       the <i>security.capability</i> extended attribute that is attached to a
       file depends on the circumstances in which the attribute was
       created.

       Starting with Linux 4.14, a <i>security.capability</i> extended
       attribute is automatically created as (or converted to) a version
       3 (<b>VFS_CAP_REVISION_3</b>) attribute if both of the following are
       true:

       •  The thread writing the attribute resides in a noninitial user
          namespace.  (More precisely: the thread resides in a user
          namespace other than the one from which the underlying
          filesystem was mounted.)

       •  The thread has the <b>CAP_SETFCAP </b>capability over the file inode,
          meaning that (a) the thread has the <b>CAP_SETFCAP </b>capability in
          its own user namespace; and (b) the UID and GID of the file
          inode have mappings in the writer's user namespace.

       When a <b>VFS_CAP_REVISION_3 </b><i>security.capability</i> extended attribute
       is created, the root user ID of the creating thread's user
       namespace is saved in the extended attribute.

       By contrast, creating or modifying a <i>security.capability</i> extended
       attribute from a privileged (<b>CAP_SETFCAP</b>) thread that resides in
       the namespace where the underlying filesystem was mounted (this
       normally means the initial user namespace) automatically results
       in the creation of a version 2 (<b>VFS_CAP_REVISION_2</b>) attribute.

       Note that the creation of a version 3 <i>security.capability</i>
       extended attribute is automatic.  That is to say, when a user-
       space application writes (<a href="../man2/setxattr.2.html">setxattr(2)</a>) a <i>security.capability</i>
       attribute in the version 2 format, the kernel will automatically
       create a version 3 attribute if the attribute is created in the
       circumstances described above.  Correspondingly, when a version 3
       <i>security.capability</i> attribute is retrieved (<a href="../man2/getxattr.2.html">getxattr(2)</a>) by a
       process that resides inside a user namespace that was created by
       the root user ID (or a descendant of that user namespace), the
       returned attribute is (automatically) simplified to appear as a
       version 2 attribute (i.e., the returned value is the size of a
       version 2 attribute and does not include the root user ID).
       These automatic translations mean that no changes are required to
       user-space tools (e.g., <b>setcap</b>(1) and <b>getcap</b>(1)) in order for
       those tools to be used to create and retrieve version 3
       <i>security.capability</i> attributes.

       Note that a file can have either a version 2 or a version 3
       <i>security.capability</i> extended attribute associated with it, but
       not both: creation or modification of the <i>security.capability</i>
       extended attribute will automatically modify the version
       according to the circumstances in which the extended attribute is
       created or modified.

   <b>Transformation of capabilities during execve()</b>
       During an <a href="../man2/execve.2.html">execve(2)</a>, the kernel calculates the new capabilities
       of the process using the following algorithm:

           P'(ambient)     = (file is privileged) ? 0 : P(ambient)

           P'(permitted)   = (P(inheritable) &amp; F(inheritable)) |
                             (F(permitted) &amp; P(bounding)) | P'(ambient)

           P'(effective)   = F(effective) ? P'(permitted) : P'(ambient)

           P'(inheritable) = P(inheritable)    [i.e., unchanged]

           P'(bounding)    = P(bounding)       [i.e., unchanged]

       where:

           P()    denotes the value of a thread capability set before
                  the <a href="../man2/execve.2.html">execve(2)</a>

           P'()   denotes the value of a thread capability set after the
                  <a href="../man2/execve.2.html">execve(2)</a>

           F()    denotes a file capability set

       Note the following details relating to the above capability
       transformation rules:

       •  The ambient capability set is present only since Linux 4.3.
          When determining the transformation of the ambient set during
          <a href="../man2/execve.2.html">execve(2)</a>, a privileged file is one that has capabilities or
          has the set-user-ID or set-group-ID bit set.

       •  Prior to Linux 2.6.25, the bounding set was a system-wide
          attribute shared by all threads.  That system-wide value was
          employed to calculate the new permitted set during <a href="../man2/execve.2.html">execve(2)</a>
          in the same manner as shown above for <i>P(bounding)</i>.

       <i>Note</i>: during the capability transitions described above, file
       capabilities may be ignored (treated as empty) for the same
       reasons that the set-user-ID and set-group-ID bits are ignored;
       see <a href="../man2/execve.2.html">execve(2)</a>.  File capabilities are similarly ignored if the
       kernel was booted with the <i>no_file_caps</i> option.

       <i>Note</i>: according to the rules above, if a process with nonzero
       user IDs performs an <a href="../man2/execve.2.html">execve(2)</a> then any capabilities that are
       present in its permitted and effective sets will be cleared.  For
       the treatment of capabilities when a process with a user ID of
       zero performs an <a href="../man2/execve.2.html">execve(2)</a>, see <i>Capabilities and execution of</i>
       <i>programs by root</i> below.

   <b>Safety checking for capability-dumb binaries</b>
       A capability-dumb binary is an application that has been marked
       to have file capabilities, but has not been converted to use the
       <a href="../man3/libcap.3.html">libcap(3)</a> API to manipulate its capabilities.  (In other words,
       this is a traditional set-user-ID-root program that has been
       switched to use file capabilities, but whose code has not been
       modified to understand capabilities.)  For such applications, the
       effective capability bit is set on the file, so that the file
       permitted capabilities are automatically enabled in the process
       effective set when executing the file.  The kernel recognizes a
       file which has the effective capability bit set as capability-
       dumb for the purpose of the check described here.

       When executing a capability-dumb binary, the kernel checks if the
       process obtained all permitted capabilities that were specified
       in the file permitted set, after the capability transformations
       described above have been performed.  (The typical reason why
       this might <i>not</i> occur is that the capability bounding set masked
       out some of the capabilities in the file permitted set.)  If the
       process did not obtain the full set of file permitted
       capabilities, then <a href="../man2/execve.2.html">execve(2)</a> fails with the error <b>EPERM</b>.  This
       prevents possible security risks that could arise when a
       capability-dumb application is executed with less privilege than
       it needs.  Note that, by definition, the application could not
       itself recognize this problem, since it does not employ the
       <a href="../man3/libcap.3.html">libcap(3)</a> API.

   <b>Capabilities and execution of programs by root</b>
       In order to mirror traditional UNIX semantics, the kernel
       performs special treatment of file capabilities when a process
       with UID 0 (root) executes a program and when a set-user-ID-root
       program is executed.

       After having performed any changes to the process effective ID
       that were triggered by the set-user-ID mode bit of the binary—
       e.g., switching the effective user ID to 0 (root) because a set-
       user-ID-root program was executed—the kernel calculates the file
       capability sets as follows:

       (1)  If the real or effective user ID of the process is 0 (root),
            then the file inheritable and permitted sets are ignored;
            instead they are notionally considered to be all ones (i.e.,
            all capabilities enabled).  (There is one exception to this
            behavior, described in <i>Set-user-ID-root programs that have</i>
            <i>file capabilities</i> below.)

       (2)  If the effective user ID of the process is 0 (root) or the
            file effective bit is in fact enabled, then the file
            effective bit is notionally defined to be one (enabled).

       These notional values for the file's capability sets are then
       used as described above to calculate the transformation of the
       process's capabilities during <a href="../man2/execve.2.html">execve(2)</a>.

       Thus, when a process with nonzero UIDs <a href="../man2/execve.2.html">execve(2)</a>s a set-user-ID-
       root program that does not have capabilities attached, or when a
       process whose real and effective UIDs are zero <a href="../man2/execve.2.html">execve(2)</a>s a
       program, the calculation of the process's new permitted
       capabilities simplifies to:

           P'(permitted)   = P(inheritable) | P(bounding)

           P'(effective)   = P'(permitted)

       Consequently, the process gains all capabilities in its permitted
       and effective capability sets, except those masked out by the
       capability bounding set.  (In the calculation of P'(permitted),
       the P'(ambient) term can be simplified away because it is by
       definition a proper subset of P(inheritable).)

       The special treatments of user ID 0 (root) described in this
       subsection can be disabled using the securebits mechanism
       described below.

   <b>Set-user-ID-root programs that have file capabilities</b>
       There is one exception to the behavior described in <i>Capabilities</i>
       <i>and execution of programs by root</i> above.  If (a) the binary that
       is being executed has capabilities attached and (b) the real user
       ID of the process is <i>not</i> 0 (root) and (c) the effective user ID
       of the process <i>is</i> 0 (root), then the file capability bits are
       honored (i.e., they are not notionally considered to be all
       ones).  The usual way in which this situation can arise is when
       executing a set-UID-root program that also has file capabilities.
       When such a program is executed, the process gains just the
       capabilities granted by the program (i.e., not all capabilities,
       as would occur when executing a set-user-ID-root program that
       does not have any associated file capabilities).

       Note that one can assign empty capability sets to a program file,
       and thus it is possible to create a set-user-ID-root program that
       changes the effective and saved set-user-ID of the process that
       executes the program to 0, but confers no capabilities to that
       process.

   <b>Capability bounding set</b>
       The capability bounding set is a security mechanism that can be
       used to limit the capabilities that can be gained during an
       <a href="../man2/execve.2.html">execve(2)</a>.  The bounding set is used in the following ways:

       •  During an <a href="../man2/execve.2.html">execve(2)</a>, the capability bounding set is ANDed with
          the file permitted capability set, and the result of this
          operation is assigned to the thread's permitted capability
          set.  The capability bounding set thus places a limit on the
          permitted capabilities that may be granted by an executable
          file.

       •  (Since Linux 2.6.25) The capability bounding set acts as a
          limiting superset for the capabilities that a thread can add
          to its inheritable set using <a href="../man2/capset.2.html">capset(2)</a>.  This means that if a
          capability is not in the bounding set, then a thread can't add
          this capability to its inheritable set, even if it was in its
          permitted capabilities, and thereby cannot have this
          capability preserved in its permitted set when it <a href="../man2/execve.2.html">execve(2)</a>s a
          file that has the capability in its inheritable set.

       Note that the bounding set masks the file permitted capabilities,
       but not the inheritable capabilities.  If a thread maintains a
       capability in its inheritable set that is not in its bounding
       set, then it can still gain that capability in its permitted set
       by executing a file that has the capability in its inheritable
       set.

       Depending on the kernel version, the capability bounding set is
       either a system-wide attribute, or a per-process attribute.

       <b>Capability bounding set from Linux 2.6.25 onward</b>

       From Linux 2.6.25, the <i>capability bounding set</i> is a per-thread
       attribute.  (The system-wide capability bounding set described
       below no longer exists.)

       The bounding set is inherited at <a href="../man2/fork.2.html">fork(2)</a> from the thread's
       parent, and is preserved across an <a href="../man2/execve.2.html">execve(2)</a>.

       A thread may remove capabilities from its capability bounding set
       using the <a href="../man2/prctl.2.html">prctl(2)</a> <b>PR_CAPBSET_DROP </b>operation, provided it has the
       <b>CAP_SETPCAP </b>capability.  Once a capability has been dropped from
       the bounding set, it cannot be restored to that set.  A thread
       can determine if a capability is in its bounding set using the
       <a href="../man2/prctl.2.html">prctl(2)</a> <b>PR_CAPBSET_READ </b>operation.

       Removing capabilities from the bounding set is supported only if
       file capabilities are compiled into the kernel.  Before Linux
       2.6.33, file capabilities were an optional feature configurable
       via the <b>CONFIG_SECURITY_FILE_CAPABILITIES </b>option.  Since Linux
       2.6.33, the configuration option has been removed and file
       capabilities are always part of the kernel.  When file
       capabilities are compiled into the kernel, the <b>init </b>process (the
       ancestor of all processes) begins with a full bounding set.  If
       file capabilities are not compiled into the kernel, then <b>init</b>
       begins with a full bounding set minus <b>CAP_SETPCAP</b>, because this
       capability has a different meaning when there are no file
       capabilities.

       Removing a capability from the bounding set does not remove it
       from the thread's inheritable set.  However it does prevent the
       capability from being added back into the thread's inheritable
       set in the future.

       <b>Capability bounding set prior to Linux 2.6.25</b>

       Before Linux 2.6.25, the capability bounding set is a system-wide
       attribute that affects all threads on the system.  The bounding
       set is accessible via the file <i>/proc/sys/kernel/cap-bound</i>.
       (Confusingly, this bit mask parameter is expressed as a signed
       decimal number in <i>/proc/sys/kernel/cap-bound</i>.)

       Only the <b>init </b>process may set capabilities in the capability
       bounding set; other than that, the superuser (more precisely: a
       process with the <b>CAP_SYS_MODULE </b>capability) may only clear
       capabilities from this set.

       On a standard system the capability bounding set always masks out
       the <b>CAP_SETPCAP </b>capability.  To remove this restriction
       (dangerous!), modify the definition of <b>CAP_INIT_EFF_SET </b>in
       <i>include/linux/capability.h</i> and rebuild the kernel.

       The system-wide capability bounding set feature was added to
       Linux 2.2.11.

   <b>Effect of user ID changes on capabilities</b>
       To preserve the traditional semantics for transitions between 0
       and nonzero user IDs, the kernel makes the following changes to a
       thread's capability sets on changes to the thread's real,
       effective, saved set, and filesystem user IDs (using <a href="../man2/setuid.2.html">setuid(2)</a>,
       <a href="../man2/setresuid.2.html">setresuid(2)</a>, or similar):

       •  If one or more of the real, effective, or saved set user IDs
          was previously 0, and as a result of the UID changes all of
          these IDs have a nonzero value, then all capabilities are
          cleared from the permitted, effective, and ambient capability
          sets.

       •  If the effective user ID is changed from 0 to nonzero, then
          all capabilities are cleared from the effective set.

       •  If the effective user ID is changed from nonzero to 0, then
          the permitted set is copied to the effective set.

       •  If the filesystem user ID is changed from 0 to nonzero (see
          <a href="../man2/setfsuid.2.html">setfsuid(2)</a>), then the following capabilities are cleared from
          the effective set: <b>CAP_CHOWN</b>, <b>CAP_DAC_OVERRIDE</b>,
          <b>CAP_DAC_READ_SEARCH</b>, <b>CAP_FOWNER</b>, <b>CAP_FSETID</b>,
          <b>CAP_LINUX_IMMUTABLE </b>(since Linux 2.6.30), <b>CAP_MAC_OVERRIDE</b>,
          and <b>CAP_MKNOD </b>(since Linux 2.6.30).  If the filesystem UID is
          changed from nonzero to 0, then any of these capabilities that
          are enabled in the permitted set are enabled in the effective
          set.

       If a thread that has a 0 value for one or more of its user IDs
       wants to prevent its permitted capability set being cleared when
       it resets all of its user IDs to nonzero values, it can do so
       using the <b>SECBIT_KEEP_CAPS </b>securebits flag described below.

   <b>Programmatically adjusting capability sets</b>
       A thread can retrieve and change its permitted, effective, and
       inheritable capability sets using the <a href="../man2/capget.2.html">capget(2)</a> and <a href="../man2/capset.2.html">capset(2)</a>
       system calls.  However, the use of <a href="../man3/cap_get_proc.3.html">cap_get_proc(3)</a> and
       <a href="../man3/cap_set_proc.3.html">cap_set_proc(3)</a>, both provided in the <i>libcap</i> package, is
       preferred for this purpose.  The following rules govern changes
       to the thread capability sets:

       •  If the caller does not have the <b>CAP_SETPCAP </b>capability, the
          new inheritable set must be a subset of the combination of the
          existing inheritable and permitted sets.

       •  (Since Linux 2.6.25) The new inheritable set must be a subset
          of the combination of the existing inheritable set and the
          capability bounding set.

       •  The new permitted set must be a subset of the existing
          permitted set (i.e., it is not possible to acquire permitted
          capabilities that the thread does not currently have).

       •  The new effective set must be a subset of the new permitted
          set.

   <b>The securebits flags: establishing a capabilities-only environment</b>
       Starting with Linux 2.6.26, and with a kernel in which file
       capabilities are enabled, Linux implements a set of per-thread
       <i>securebits</i> flags that can be used to disable special handling of
       capabilities for UID 0 (<i>root</i>).  These flags are as follows:

       <b>SECBIT_KEEP_CAPS</b>
              Setting this flag allows a thread that has one or more 0
              UIDs to retain capabilities in its permitted set when it
              switches all of its UIDs to nonzero values.  If this flag
              is not set, then such a UID switch causes the thread to
              lose all permitted capabilities.  This flag is always
              cleared on an <a href="../man2/execve.2.html">execve(2)</a>.

              Note that even with the <b>SECBIT_KEEP_CAPS </b>flag set, the
              effective capabilities of a thread are cleared when it
              switches its effective UID to a nonzero value.  However,
              if the thread has set this flag and its effective UID is
              already nonzero, and the thread subsequently switches all
              other UIDs to nonzero values, then the effective
              capabilities will not be cleared.

              The setting of the <b>SECBIT_KEEP_CAPS </b>flag is ignored if the
              <b>SECBIT_NO_SETUID_FIXUP </b>flag is set.  (The latter flag
              provides a superset of the effect of the former flag.)

              This flag provides the same functionality as the older
              <a href="../man2/prctl.2.html">prctl(2)</a> <b>PR_SET_KEEPCAPS </b>operation.

       <b>SECBIT_NO_SETUID_FIXUP</b>
              Setting this flag stops the kernel from adjusting the
              process's permitted, effective, and ambient capability
              sets when the thread's effective and filesystem UIDs are
              switched between zero and nonzero values.  See <i>Effect of</i>
              <i>user ID changes on capabilities</i> above.

       <b>SECBIT_NOROOT</b>
              If this bit is set, then the kernel does not grant
              capabilities when a set-user-ID-root program is executed,
              or when a process with an effective or real UID of 0 calls
              <a href="../man2/execve.2.html">execve(2)</a>.  (See <i>Capabilities and execution of programs by</i>
              <i>root</i> above.)

       <b>SECBIT_NO_CAP_AMBIENT_RAISE</b>
              Setting this flag disallows raising ambient capabilities
              via the <a href="../man2/prctl.2.html">prctl(2)</a> <b>PR_CAP_AMBIENT_RAISE </b>operation.

       Each of the above "base" flags has a companion "locked" flag.
       Setting any of the "locked" flags is irreversible, and has the
       effect of preventing further changes to the corresponding "base"
       flag.  The locked flags are: <b>SECBIT_KEEP_CAPS_LOCKED</b>,
       <b>SECBIT_NO_SETUID_FIXUP_LOCKED</b>, <b>SECBIT_NOROOT_LOCKED</b>, and
       <b>SECBIT_NO_CAP_AMBIENT_RAISE_LOCKED</b>.

       The <i>securebits</i> flags can be modified and retrieved using the
       <a href="../man2/prctl.2.html">prctl(2)</a> <b>PR_SET_SECUREBITS </b>and <b>PR_GET_SECUREBITS </b>operations.  The
       <b>CAP_SETPCAP </b>capability is required to modify the flags.  Note
       that the <b>SECBIT_* </b>constants are available only after including
       the <i>&lt;linux/securebits.h&gt;</i> header file.

       The <i>securebits</i> flags are inherited by child processes.  During an
       <a href="../man2/execve.2.html">execve(2)</a>, all of the flags are preserved, except
       <b>SECBIT_KEEP_CAPS </b>which is always cleared.

       An application can use the following call to lock itself, and all
       of its descendants, into an environment where the only way of
       gaining capabilities is by executing a program with associated
       file capabilities:

           prctl(PR_SET_SECUREBITS,
                   /* SECBIT_KEEP_CAPS off */
                   SECBIT_KEEP_CAPS_LOCKED |
                   SECBIT_NO_SETUID_FIXUP |
                   SECBIT_NO_SETUID_FIXUP_LOCKED |
                   SECBIT_NOROOT |
                   SECBIT_NOROOT_LOCKED);
                   /* Setting/locking SECBIT_NO_CAP_AMBIENT_RAISE
                      is not required */

   <b>Per-user-namespace "set-user-ID-root" programs</b>
       A set-user-ID program whose UID matches the UID that created a
       user namespace will confer capabilities in the process's
       permitted and effective sets when executed by any process inside
       that namespace or any descendant user namespace.

       The rules about the transformation of the process's capabilities
       during the <a href="../man2/execve.2.html">execve(2)</a> are exactly as described in <i>Transformation</i>
       <i>of capabilities during execve()</i> and <i>Capabilities and execution of</i>
       <i>programs by root</i> above, with the difference that, in the latter
       subsection, "root" is the UID of the creator of the user
       namespace.

   <b>Namespaced file capabilities</b>
       Traditional (i.e., version 2) file capabilities associate only a
       set of capability masks with a binary executable file.  When a
       process executes a binary with such capabilities, it gains the
       associated capabilities (within its user namespace) as per the
       rules described in <i>Transformation of capabilities during execve()</i>
       above.

       Because version 2 file capabilities confer capabilities to the
       executing process regardless of which user namespace it resides
       in, only privileged processes are permitted to associate
       capabilities with a file.  Here, "privileged" means a process
       that has the <b>CAP_SETFCAP </b>capability in the user namespace where
       the filesystem was mounted (normally the initial user namespace).
       This limitation renders file capabilities useless for certain use
       cases.  For example, in user-namespaced containers, it can be
       desirable to be able to create a binary that confers capabilities
       only to processes executed inside that container, but not to
       processes that are executed outside the container.

       Linux 4.14 added so-called namespaced file capabilities to
       support such use cases.  Namespaced file capabilities are
       recorded as version 3 (i.e., <b>VFS_CAP_REVISION_3</b>)
       <i>security.capability</i> extended attributes.  Such an attribute is
       automatically created in the circumstances described in <i>File</i>
       <i>capability extended attribute versioning</i> above.  When a version 3
       <i>security.capability</i> extended attribute is created, the kernel
       records not just the capability masks in the extended attribute,
       but also the namespace root user ID.

       As with a binary that has <b>VFS_CAP_REVISION_2 </b>file capabilities, a
       binary with <b>VFS_CAP_REVISION_3 </b>file capabilities confers
       capabilities to a process during <b>execve</b>().  However, capabilities
       are conferred only if the binary is executed by a process that
       resides in a user namespace whose UID 0 maps to the root user ID
       that is saved in the extended attribute, or when executed by a
       process that resides in a descendant of such a namespace.

   <b>Interaction with user namespaces</b>
       For further information on the interaction of capabilities and
       user namespaces, see <a href="user_namespaces.7.html">user_namespaces(7)</a>.
</pre> <h2>
STANDARDS </h2>
<pre>
       No standards govern capabilities, but the Linux capability
       implementation is based on the withdrawn POSIX.1e draft standard
       ⟨<a href="https://archive.org/details/posix_1003.1e-990310">https://archive.org/details/posix_1003.1e-990310</a>⟩.
</pre> <h2>
NOTES </h2>
<pre>
       When attempting to <a href="../man1/strace.1.html">strace(1)</a> binaries that have capabilities (or
       set-user-ID-root binaries), you may find the <i>-u &lt;username&gt;</i> option
       useful.  Something like:

           $ <b>sudo strace -o trace.log -u ceci ./myprivprog</b>

       From Linux 2.5.27 to Linux 2.6.26, capabilities were an optional
       kernel component, and could be enabled/disabled via the
       <b>CONFIG_SECURITY_CAPABILITIES </b>kernel configuration option.

       The <i>/proc/</i>pid<i>/task/TID/status</i> file can be used to view the
       capability sets of a thread.  The <i>/proc/</i>pid<i>/status</i> file shows the
       capability sets of a process's main thread.  Before Linux 3.8,
       nonexistent capabilities were shown as being enabled (1) in these
       sets.  Since Linux 3.8, all nonexistent capabilities (above
       <b>CAP_LAST_CAP</b>) are shown as disabled (0).

       The <i>libcap</i> package provides a suite of routines for setting and
       getting capabilities that is more comfortable and less likely to
       change than the interface provided by <a href="../man2/capset.2.html">capset(2)</a> and <a href="../man2/capget.2.html">capget(2)</a>.
       This package also provides the <a href="../man8/setcap.8.html">setcap(8)</a> and <a href="../man8/getcap.8.html">getcap(8)</a> programs.
       It can be found at
       ⟨<a href="https://git.kernel.org/pub/scm/libs/libcap/libcap.git/refs/">https://git.kernel.org/pub/scm/libs/libcap/libcap.git/refs/</a>⟩.

       Before Linux 2.6.24, and from Linux 2.6.24 to Linux 2.6.32 if
       file capabilities are not enabled, a thread with the <b>CAP_SETPCAP</b>
       capability can manipulate the capabilities of threads other than
       itself.  However, this is only theoretically possible, since no
       thread ever has <b>CAP_SETPCAP </b>in either of these cases:

       •  In the pre-2.6.25 implementation the system-wide capability
          bounding set, <i>/proc/sys/kernel/cap-bound</i>, always masks out the
          <b>CAP_SETPCAP </b>capability, and this can not be changed without
          modifying the kernel source and rebuilding the kernel.

       •  If file capabilities are disabled (i.e., the kernel
          <b>CONFIG_SECURITY_FILE_CAPABILITIES </b>option is disabled), then
          <b>init </b>starts out with the <b>CAP_SETPCAP </b>capability removed from
          its per-process bounding set, and that bounding set is
          inherited by all other processes created on the system.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man1/capsh.1.html">capsh(1)</a>, <a href="../man1/setpriv.1.html">setpriv(1)</a>, <a href="../man2/prctl.2.html">prctl(2)</a>, <a href="../man2/setfsuid.2.html">setfsuid(2)</a>, <a href="../man3/cap_clear.3.html">cap_clear(3)</a>,
       <a href="../man3/cap_copy_ext.3.html">cap_copy_ext(3)</a>, <a href="../man3/cap_from_text.3.html">cap_from_text(3)</a>, <a href="../man3/cap_get_file.3.html">cap_get_file(3)</a>,
       <a href="../man3/cap_get_proc.3.html">cap_get_proc(3)</a>, <a href="../man3/cap_init.3.html">cap_init(3)</a>, <a href="../man3/capgetp.3.html">capgetp(3)</a>, <a href="../man3/capsetp.3.html">capsetp(3)</a>, <a href="../man3/libcap.3.html">libcap(3)</a>,
       <a href="../man5/proc.5.html">proc(5)</a>, <a href="credentials.7.html">credentials(7)</a>, <a href="pthreads.7.html">pthreads(7)</a>, <a href="user_namespaces.7.html">user_namespaces(7)</a>,
       <a href="../man8/captest.8.html">captest(8)</a>, <a href="../man8/filecap.8.html">filecap(8)</a>, <a href="../man8/getcap.8.html">getcap(8)</a>, <a href="../man8/getpcaps.8.html">getpcaps(8)</a>, <a href="../man8/netcap.8.html">netcap(8)</a>,
       <a href="../man8/pscap.8.html">pscap(8)</a>, <a href="../man8/setcap.8.html">setcap(8)</a>

       <i>include/linux/capability.h</i> in the Linux kernel source tree
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       ⟨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>⟩.  If you have a bug report
       for this manual page, see
       ⟨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>⟩.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       ⟨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>⟩ on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-06-13                <i>Capabilities</i>(7)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/capsh.1.html">capsh(1)</a>, <a href="../man1/homectl.1.html">homectl(1)</a>, <a href="../man1/setpriv.1.html">setpriv(1)</a>, <a href="../man1/systemd-analyze.1.html">systemd-analyze(1)</a>, <a href="../man1/systemd-nspawn.1.html">systemd-nspawn(1)</a>, <a href="../man2/adjtimex.2.html">adjtimex(2)</a>, <a href="../man2/capget.2.html">capget(2)</a>, <a href="../man2/clone.2.html">clone(2)</a>, <a href="../man2/execve.2.html">execve(2)</a>, <a href="../man2/fcntl.2.html">fcntl(2)</a>, <a href="../man2/fork.2.html">fork(2)</a>, <a href="../man2/getgroups.2.html">getgroups(2)</a>, <a href="../man2/getpriority.2.html">getpriority(2)</a>, <a href="../man2/getrlimit.2.html">getrlimit(2)</a>, <a href="../man2/gettimeofday.2.html">gettimeofday(2)</a>, <a href="../man2/intro.2.html">intro(2)</a>, <a href="../man2/ioperm.2.html">ioperm(2)</a>, <a href="../man2/iopl.2.html">iopl(2)</a>, <a href="../man2/ioprio_set.2.html">ioprio_set(2)</a>, <a href="../man2/keyctl.2.html">keyctl(2)</a>, <a href="../man2/kill.2.html">kill(2)</a>, <a href="../man2/mlock.2.html">mlock(2)</a>, <a href="../man2/mount_setattr.2.html">mount_setattr(2)</a>, <a href="../man2/msgctl.2.html">msgctl(2)</a>, <a href="../man2/msgget.2.html">msgget(2)</a>, <a href="../man2/msgop.2.html">msgop(2)</a>, <a href="../man2/nice.2.html">nice(2)</a>, <a href="../man2/pciconfig_read.2.html">pciconfig_read(2)</a>, <a href="../man2/pr_get_keepcaps.2const.html">PR_GET_KEEPCAPS(2const)</a>, <a href="../man2/pr_get_securebits.2const.html">PR_GET_SECUREBITS(2const)</a>, <a href="../man2/process_madvise.2.html">process_madvise(2)</a>, <a href="../man2/pr_set_dumpable.2const.html">PR_SET_DUMPABLE(2const)</a>, <a href="../man2/pr_set_keepcaps.2const.html">PR_SET_KEEPCAPS(2const)</a>, <a href="../man2/pr_set_pdeathsig.2const.html">PR_SET_PDEATHSIG(2const)</a>, <a href="../man2/pr_set_securebits.2const.html">PR_SET_SECUREBITS(2const)</a>, <a href="../man2/ptrace.2.html">ptrace(2)</a>, <a href="../man2/reboot.2.html">reboot(2)</a>, <a href="../man2/request_key.2.html">request_key(2)</a>, <a href="../man2/sched_setaffinity.2.html">sched_setaffinity(2)</a>, <a href="../man2/sched_setattr.2.html">sched_setattr(2)</a>, <a href="../man2/sched_setparam.2.html">sched_setparam(2)</a>, <a href="../man2/sched_setscheduler.2.html">sched_setscheduler(2)</a>, <a href="../man2/semctl.2.html">semctl(2)</a>, <a href="../man2/semget.2.html">semget(2)</a>, <a href="../man2/semop.2.html">semop(2)</a>, <a href="../man2/seteuid.2.html">seteuid(2)</a>, <a href="../man2/setfsgid.2.html">setfsgid(2)</a>, <a href="../man2/setfsuid.2.html">setfsuid(2)</a>, <a href="../man2/setgid.2.html">setgid(2)</a>, <a href="../man2/setresuid.2.html">setresuid(2)</a>, <a href="../man2/setreuid.2.html">setreuid(2)</a>, <a href="../man2/setuid.2.html">setuid(2)</a>, <a href="../man2/shmctl.2.html">shmctl(2)</a>, <a href="../man2/shmget.2.html">shmget(2)</a>, <a href="../man2/shmop.2.html">shmop(2)</a>, <a href="../man2/spu_create.2.html">spu_create(2)</a>, <a href="../man2/spu_run.2.html">spu_run(2)</a>, <a href="../man2/stat.2.html">stat(2)</a>, <a href="../man2/statx.2.html">statx(2)</a>, <a href="../man2/stime.2.html">stime(2)</a>, <a href="../man2/syslog.2.html">syslog(2)</a>, <a href="../man2/uselib.2.html">uselib(2)</a>, <a href="../man2/vhangup.2.html">vhangup(2)</a>, <a href="../man3/cap_clear.3.html">cap_clear(3)</a>, <a href="../man3/cap_copy_ext.3.html">cap_copy_ext(3)</a>, <a href="../man3/cap_from_text.3.html">cap_from_text(3)</a>, <a href="../man3/cap_get_file.3.html">cap_get_file(3)</a>, <a href="../man3/cap_get_proc.3.html">cap_get_proc(3)</a>, <a href="../man3/cap_iab.3.html">cap_iab(3)</a>, <a href="../man3/cap_init.3.html">cap_init(3)</a>, <a href="../man3/cap_launch.3.html">cap_launch(3)</a>, <a href="../man3/capng_apply.3.html">capng_apply(3)</a>, <a href="../man3/capng_apply_caps_fd.3.html">capng_apply_caps_fd(3)</a>, <a href="../man3/capng_capability_to_name.3.html">capng_capability_to_name(3)</a>, <a href="../man3/capng_change_id.3.html">capng_change_id(3)</a>, <a href="../man3/capng_clear.3.html">capng_clear(3)</a>, <a href="../man3/capng_fill.3.html">capng_fill(3)</a>, <a href="../man3/capng_get_caps_fd.3.html">capng_get_caps_fd(3)</a>, <a href="../man3/capng_get_caps_process.3.html">capng_get_caps_process(3)</a>, <a href="../man3/capng_get_rootid.3.html">capng_get_rootid(3)</a>, <a href="../man3/capng_have_capabilities.3.html">capng_have_capabilities(3)</a>, <a href="../man3/capng_have_capability.3.html">capng_have_capability(3)</a>, <a href="../man3/capng_lock.3.html">capng_lock(3)</a>, <a href="../man3/capng_name_to_capability.3.html">capng_name_to_capability(3)</a>, <a href="../man3/capng_print_caps_numeric.3.html">capng_print_caps_numeric(3)</a>, <a href="../man3/capng_print_caps_text.3.html">capng_print_caps_text(3)</a>, <a href="../man3/capng_restore_state.3.html">capng_restore_state(3)</a>, <a href="../man3/capng_save_state.3.html">capng_save_state(3)</a>, <a href="../man3/capng_setpid.3.html">capng_setpid(3)</a>, <a href="../man3/capng_set_rootid.3.html">capng_set_rootid(3)</a>, <a href="../man3/capng_update.3.html">capng_update(3)</a>, <a href="../man3/capng_updatev.3.html">capng_updatev(3)</a>, <a href="../man3/getauxval.3.html">getauxval(3)</a>, <a href="../man3/getenv.3.html">getenv(3)</a>, <a href="../man3/intro.3.html">intro(3)</a>, <a href="../man3/killpg.3.html">killpg(3)</a>, <a href="../man3/libcap.3.html">libcap(3)</a>, <a href="../man3/pthread_create.3.html">pthread_create(3)</a>, <a href="../man3/sd_bus_add_object.3.html">sd_bus_add_object(3)</a>, <a href="../man3/sd_bus_creds_get_pid.3.html">sd_bus_creds_get_pid(3)</a>, <a href="../man3/sd_bus_query_sender_creds.3.html">sd_bus_query_sender_creds(3)</a>, <a href="../man5/core.5.html">core(5)</a>, <a href="../man5/lxc.container.conf.5.html">lxc.container.conf(5)</a>, <a href="../man5/proc_pid_status.5.html">proc_pid_status(5)</a>, <a href="../man5/proc_sys_kernel.5.html">proc_sys_kernel(5)</a>, <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>, <a href="../man5/systemd.nspawn.5.html">systemd.nspawn(5)</a>, <a href="../man5/systemd-system.conf.5.html">systemd-system.conf(5)</a>, <a href="../man5/systemd.unit.5.html">systemd.unit(5)</a>, <a href="arp.7.html">arp(7)</a>, <a href="credentials.7.html">credentials(7)</a>, <a href="ddp.7.html">ddp(7)</a>, <a href="ip.7.html">ip(7)</a>, <a href="libdrop_ambient.7.html">libdrop_ambient(7)</a>, <a href="namespaces.7.html">namespaces(7)</a>, <a href="netdevice.7.html">netdevice(7)</a>, <a href="netlink.7.html">netlink(7)</a>, <a href="packet.7.html">packet(7)</a>, <a href="path_resolution.7.html">path_resolution(7)</a>, <a href="pid_namespaces.7.html">pid_namespaces(7)</a>, <a href="pthreads.7.html">pthreads(7)</a>, <a href="raw.7.html">raw(7)</a>, <a href="sched.7.html">sched(7)</a>, <a href="socket.7.html">socket(7)</a>, <a href="spufs.7.html">spufs(7)</a>, <a href="systemd.journal-fields.7.html">systemd.journal-fields(7)</a>, <a href="unix.7.html">unix(7)</a>, <a href="user_namespaces.7.html">user_namespaces(7)</a>, <a href="vsock.7.html">vsock(7)</a>, <a href="xattr.7.html">xattr(7)</a>, <a href="../man8/captest.8.html">captest(8)</a>, <a href="../man8/captree.8.html">captree(8)</a>, <a href="../man8/filecap.8.html">filecap(8)</a>, <a href="../man8/getcap.8.html">getcap(8)</a>, <a href="../man8/getpcaps.8.html">getpcaps(8)</a>, <a href="../man8/ip-vrf.8.html">ip-vrf(8)</a>, <a href="../man8/ld.so.8.html">ld.so(8)</a>, <a href="../man8/mount.fuse3.8.html">mount.fuse3(8)</a>, <a href="../man8/netcap.8.html">netcap(8)</a>, <a href="../man8/pam_systemd.8.html">pam_systemd(8)</a>, <a href="../man8/pscap.8.html">pscap(8)</a>, <a href="../man8/setcap.8.html">setcap(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man7/capabilities.7.html" class="_attribution-link">https://man7.org/linux/man-pages/man7/capabilities.7.html</a>
  </p>
</div>
