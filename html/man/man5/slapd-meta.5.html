<h1>slapd-meta(5) â€” Linux manual page</h1>   <pre>
<span class="headline"><i>SLAPD-META</i>(5)              File Formats Manual             <i>SLAPD-META</i>(5)</span>
</pre> <h2>
NAME </h2>
<pre>
       slapd-meta - metadirectory backend to slapd
</pre> <h2>
SYNOPSIS </h2>
<pre>
       ETCDIR/slapd.conf
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <b>meta </b>backend to <a href="../man8/slapd.8.html">slapd(8)</a> performs basic LDAP proxying with
       respect to a set of remote LDAP servers, called "targets".  The
       information contained in these servers can be presented as
       belonging to a single Directory Information Tree (DIT).

       A basic knowledge of the functionality of the <a href="slapd-ldap.5.html">slapd-ldap(5)</a>
       backend is recommended.  This backend has been designed as an
       enhancement of the ldap backend.  The two backends share many
       features (actually they also share portions of code).  While the
       <b>ldap </b>backend is intended to proxy operations directed to a single
       server, the <b>meta </b>backend is mainly intended for proxying of
       multiple servers and possibly naming context masquerading.  These
       features, although useful in many scenarios, may result in
       excessive overhead for some applications, so its use should be
       carefully considered.  In the examples section, some typical
       scenarios will be discussed.

       The proxy instance of <a href="../man8/slapd.8.html">slapd(8)</a> must contain schema information
       for the attributes and objectClasses used in filters, request DN
       and request-related data in general.  It should also contain
       schema information for the data returned by the proxied server.
       It is the responsibility of the proxy administrator to keep the
       schema of the proxy lined up with that of the proxied server.

       Note: When looping back to the same instance of <a href="../man8/slapd.8.html">slapd(8)</a>, each
       connection requires a new thread; as a consequence, the <a href="../man8/slapd.8.html">slapd(8)</a>
       <b>threads </b>parameter may need some tuning. In those cases, unless
       the multiple target feature is required, one may consider using
       <a href="slapd-relay.5.html">slapd-relay(5)</a> instead, which performs the relayed operation
       internally and thus reuses the same connection.
</pre> <h2>
EXAMPLES </h2>
<pre>
       There are examples in various places in this document, as well as
       in the slapd/back-meta/data/ directory in the OpenLDAP source
       tree.
</pre> <h2>
CONFIGURATION </h2>
<pre>
       These <b>slapd.conf </b>options apply to the META backend database.
       That is, they must follow a "database meta" line and come before
       any subsequent "backend" or "database" lines.  Other database
       options are described in the <a href="slapd.conf.5.html">slapd.conf(5)</a> manual page.

       Note: In early versions of back-ldap and back-meta it was
       recommended to always set

              lastmod  off

       for <b>ldap </b>and <b>meta </b>databases.  This was required because
       operational attributes related to entry creation and modification
       should not be proxied, as they could be mistakenly written to the
       target server(s), generating an error.  The current
       implementation automatically sets lastmod to <b>off</b>, so its use is
       redundant and should be omitted.
</pre> <h2>
SPECIAL CONFIGURATION DIRECTIVES </h2>
<pre>
       Target configuration starts with the "uri" directive.  All the
       configuration directives that are not specific to targets should
       be defined first for clarity, including those that are common to
       all backends.  They are:

       <b>conn-pool-max &lt;int&gt;</b>
              This directive defines the maximum size of the privileged
              connections pool.

       <b>conn-ttl &lt;time&gt;</b>
              This directive causes a cached connection to be dropped an
              recreated after a given ttl, regardless of being idle or
              not.

       <b>default-target none</b>
              This directive forces the backend to reject all those
              operations that must resolve to a single target in case
              none or multiple targets are selected.  They include: add,
              delete, modify, modrdn; compare is not included, as well
              as bind since, as they don't alter entries, in case of
              multiple matches an attempt is made to perform the
              operation on any candidate target, with the constraint
              that at most one must succeed.  This directive can also be
              used when processing targets to mark a specific target as
              default.

       <b>dncache-ttl {DISABLED|forever|&lt;ttl&gt;}</b>
              This directive sets the time-to-live of the DN cache.
              This caches the target that holds a given DN to speed up
              target selection in case multiple targets would result
              from an uncached search; forever means cache never
              expires; disabled means no DN caching; otherwise a valid (
              &gt; 0 ) ttl is required, in the format illustrated for the
              <b>idle-timeout </b>directive.

       <b>onerr {CONTINUE|report|stop}</b>
              This directive allows one to select the behavior in case
              an error is returned by one target during a search.  The
              default, <b>continue</b>, consists in continuing the operation,
              trying to return as much data as possible.  If the value
              is set to <b>stop</b>, the search is terminated as soon as an
              error is returned by one target, and the error is
              immediately propagated to the client.  If the value is set
              to <b>report</b>, the search is continued to the end but, in case
              at least one target returned an error code, the first non-
              success error code is returned.

       <b>norefs &lt;NO|yes&gt;</b>
              If <b>yes</b>, do not return search reference responses.  By
              default, they are returned unless request is LDAPv2.  If
              set before any target specification, it affects all
              targets, unless overridden by any per-target directive.

       <b>noundeffilter &lt;NO|yes&gt;</b>
              If <b>yes</b>, return success instead of searching if a filter is
              undefined or contains undefined portions.  By default, the
              search is propagated after replacing undefined portions
              with <b>(!(objectClass=*))</b>, which corresponds to the empty
              result set.  If set before any target specification, it
              affects all targets, unless overridden by any per-target
              directive.

       <b>protocol-version {0,2,3}</b>
              This directive indicates what protocol version must be
              used to contact the remote server.  If set to 0 (the
              default), the proxy uses the same protocol version used by
              the client, otherwise the requested protocol is used.  The
              proxy returns <i>unwillingToPerform</i> if an operation that is
              incompatible with the requested protocol is attempted.  If
              set before any target specification, it affects all
              targets, unless overridden by any per-target directive.

       <b>pseudoroot-bind-defer {YES|no}</b>
              This directive, when set to <b>yes</b>, causes the authentication
              to the remote servers with the pseudo-root identity (the
              identity defined in each <b>idassert-bind </b>directive) to be
              deferred until actually needed by subsequent operations.
              Otherwise, all binds as the rootdn are propagated to the
              targets.

       <b>quarantine &lt;interval&gt;,&lt;num&gt;[;&lt;interval&gt;,&lt;num&gt;[...]]</b>
              Turns on quarantine of URIs that returned
              <i>LDAP_UNAVAILABLE</i>, so that an attempt to reconnect only
              occurs at given intervals instead of any time a client
              requests an operation.  The pattern is: retry only after
              at least <i>interval</i> seconds elapsed since last attempt, for
              exactly <i>num</i> times; then use the next pattern.  If <i>num</i> for
              the last pattern is "<b>+</b>", it retries forever; otherwise, no
              more retries occur.  This directive must appear before any
              target specification; it affects all targets with the same
              pattern.

       <b>rebind-as-user {NO|yes}</b>
              If this option is given, the client's bind credentials are
              remembered for rebinds, when trying to re-establish a
              broken connection, or when chasing a referral, if
              <b>chase-referrals </b>is set to <i>yes</i>.

       <b>session-tracking-request {NO|yes}</b>
              Adds session tracking control for all requests.  The
              client's IP and hostname, and the identity associated to
              each request, if known, are sent to the remote server for
              informational purposes.  This directive is incompatible
              with setting <i>protocol-version</i> to 2.  If set before any
              target specification, it affects all targets, unless
              overridden by any per-target directive.

       <b>single-conn {NO|yes}</b>
              Discards current cached connection when the client
              rebinds.

       <b>use-temporary-conn {NO|yes}</b>
              when set to <b>yes</b>, create a temporary connection whenever
              competing with other threads for a shared one; otherwise,
              wait until the shared connection is available.
</pre> <h2>
TARGET SPECIFICATION </h2>
<pre>
       Target specification starts with a "uri" directive:

       <b>uri &lt;protocol&gt;://[&lt;host&gt;]/&lt;naming context&gt; [...]</b>
              The &lt;protocol&gt; part can be anything <a href="../man3/ldap_initialize.3.html">ldap_initialize(3)</a>
              accepts ({ldap|ldaps|ldapi} and variants); the &lt;host&gt; may
              be omitted, defaulting to whatever is set in <a href="ldap.conf.5.html">ldap.conf(5)</a>.
              The &lt;naming context&gt; part is <i>mandatory</i> for the first URI,
              but it <i>must be omitted</i> for subsequent ones, if any.  The
              naming context part must be within the naming context
              defined for the backend, e.g.:

              suffix "<b>dc=foo,dc=com</b>"
              uri    "ldap://x.foo.com/dc=x,<b>dc=foo,dc=com</b>"

              The &lt;naming context&gt; part doesn't need to be unique across
              the targets; it may also match one of the values of the
              "suffix" directive.  Multiple URIs may be defined in a
              single URI statement.  The additional URIs must be
              separate arguments and must not have any &lt;naming context&gt;
              part.  This causes the underlying library to contact the
              first server of the list that responds.  For example, if
              <i>l1.foo.com</i> and <i>l2.foo.com</i> are shadows of the same server,
              the directive

              suffix "<b>dc=foo,dc=com</b>"
              uri    "ldap://l1.foo.com/<b>dc=foo,dc=com</b>" "ldap://l2.foo.com/"

              causes <i>l2.foo.com</i> to be contacted whenever <i>l1.foo.com</i> does
              not respond.  In that case, the URI list is internally
              rearranged, by moving unavailable URIs to the end, so that
              further connection attempts occur with respect to the last
              URI that succeeded.

       <b>acl-authcDN &lt;administrative DN for access control purposes&gt;</b>
              DN which is used to query the target server for acl
              checking, as in the LDAP backend; it is supposed to have
              read access on the target server to attributes used on the
              proxy for acl checking.  There is no risk of giving away
              such values; they are only used to check permissions.  <b>The</b>
              <b>acl-authcDN identity is by no means implicitly used by the</b>
              <b>proxy when the client connects anonymously.</b>

       <b>acl-passwd &lt;password&gt;</b>
              Password used with the <b>acl-authcDN </b>above.

       <b>bind-timeout &lt;microseconds&gt;</b>
              This directive defines the timeout, in microseconds, used
              when polling for response after an asynchronous bind
              connection.  The initial call to ldap_result(3) is
              performed with a trade-off timeout of 100000 us; if that
              results in a timeout exceeded, subsequent calls use the
              value provided with <b>bind-timeout</b>.  The default value is
              used also for subsequent calls if <b>bind-timeout </b>is not
              specified.  If set before any target specification, it
              affects all targets, unless overridden by any per-target
              directive.

       <b>chase-referrals {YES|no}</b>
              enable/disable automatic referral chasing, which is
              delegated to the underlying libldap, with rebinding
              eventually performed if the <b>rebind-as-user </b>directive is
              used.  The default is to chase referrals.  If set before
              any target specification, it affects all targets, unless
              overridden by any per-target directive.

       <b>client-pr {accept-unsolicited|DISABLE|&lt;size&gt;}</b>
              This feature allows one to use RFC 2696 Paged Results
              control when performing search operations with a specific
              target, irrespective of the client's request.  When set to
              a numeric value, Paged Results control is always used with
              <i>size</i> as the page size.  When set to <i>accept-unsolicited</i>,
              unsolicited Paged Results control responses are accepted
              and honored for compatibility with broken remote DSAs.
              The client is not exposed to paged results handling
              between <a href="slapd-meta.5.html">slapd-meta(5)</a> and the remote servers.  By default
              (disabled), Paged Results control is not used and
              responses are not accepted.  If set before any target
              specification, it affects all targets, unless overridden
              by any per-target directive.

       <b>default-target [&lt;target&gt;]</b>
              The "default-target" directive can also be used during
              target specification.  With no arguments it marks the
              current target as the default.  The optional number marks
              target &lt;target&gt; as the default one, starting from 1.
              Target &lt;target&gt; must be defined.

       <b>filter &lt;pattern&gt;</b>
              This directive allows specifying a <b>regex</b>(5) pattern to
              indicate what search filter terms are actually served by a
              target.

              In a search request, if the search filter matches the
              <i>pattern</i> the target is considered while fulfilling the
              request; otherwise the target is ignored. There may be
              multiple occurrences of the <b>filter </b>directive for each
              target.

       <b>idassert-authzFrom &lt;authz-regexp&gt;</b>
              if defined, selects what <i>local</i> identities are authorized
              to exploit the identity assertion feature.  The string
              <b>&lt;authz-regexp&gt; </b>follows the rules defined for the <i>authzFrom</i>
              attribute.  See <a href="slapd.conf.5.html">slapd.conf(5)</a>, section related to
              <b>authz-policy</b>, for details on the syntax of this field.

       <b>idassert-bind bindmethod=none|simple|sasl [binddn=&lt;simple DN&gt;]</b>
              <b>[credentials=&lt;simple password&gt;] [saslmech=&lt;SASL mech&gt;]</b>
              <b>[secprops=&lt;properties&gt;] [realm=&lt;realm&gt;]</b>
              <b>[authcId=&lt;authentication ID&gt;] [authzId=&lt;authorization ID&gt;]</b>
              <b>[authz={native|proxyauthz}] [mode=&lt;mode&gt;] [flags=&lt;flags&gt;]</b>
              <b>[starttls=no|yes|critical] [tls_cert=&lt;file&gt;]</b>
              <b>[tls_key=&lt;file&gt;] [tls_cacert=&lt;file&gt;]</b>
              <b>[tls_cacertdir=&lt;path&gt;]</b>
              <b>[tls_reqcert=never|allow|try|demand]</b>
              <b>[tls_reqsan=never|allow|try|demand]</b>
              <b>[tls_cipher_suite=&lt;ciphers&gt;] [tls_ecname=&lt;ciphers&gt;]</b>
              <b>[tls_protocol_min=&lt;major&gt;[.&lt;minor&gt;]]</b>
              <b>[tls_crlcheck=none|peer|all]</b>
              Allows one to define the parameters of the authentication
              method that is internally used by the proxy to authorize
              connections that are authenticated by other databases.
              The identity defined by this directive, according to the
              properties associated to the authentication method, is
              supposed to have auth access on the target server to
              attributes used on the proxy for authentication and
              authorization, and to be allowed to authorize the users.
              This requires to have <b>proxyAuthz </b>privileges on a wide set
              of DNs, e.g.  <b>authzTo=dn.subtree:""</b>, and the remote server
              to have <b>authz-policy </b>set to <b>to </b>or <b>both</b>.  See <a href="slapd.conf.5.html">slapd.conf(5)</a>
              for details on these statements and for remarks and
              drawbacks about their usage.  The supported bindmethods
              are

              <b>none|simple|sasl</b>

              where <b>none </b>is the default, i.e. no <i>identity assertion</i> is
              performed.

              The <b>authz </b>parameter is used to instruct the SASL bind to
              exploit <b>native </b>SASL authorization, if available; since
              connections are cached, this should only be used when
              authorizing with a fixed identity (e.g. by means of the
              <b>authzDN </b>or <b>authzID </b>parameters).  Otherwise, the default
              <b>proxyauthz </b>is used, i.e. the proxyAuthz control (Proxied
              Authorization, RFC 4370) is added to all operations.

              The supported modes are:

              <b>&lt;mode&gt; := {legacy|anonymous|none|self}</b>

              If <b>&lt;mode&gt; </b>is not present, and <b>authzId </b>is given, the proxy
              always authorizes that identity.  <b>&lt;authorization ID&gt; </b>can
              be

              <b>u:&lt;user&gt;</b>

              <b>[dn:]&lt;DN&gt;</b>

              The former is supposed to be expanded by the remote server
              according to the authz rules; see <a href="slapd.conf.5.html">slapd.conf(5)</a> for
              details.  In the latter case, whether or not the <b>dn:</b>
              prefix is present, the string must pass DN validation and
              normalization.

              The default mode is <b>legacy</b>, which implies that the proxy
              will either perform a simple bind as the <i>authcDN</i> or a SASL
              bind as the <i>authcID</i> and assert the client's identity when
              it is not anonymous.  Direct binds are always proxied.
              The other modes imply that the proxy will always either
              perform a simple bind as the <i>authcDN</i> or a SASL bind as the
              <i>authcID</i>, unless restricted by <b>idassert-authzFrom </b>rules
              (see below), in which case the operation will fail;
              eventually, it will assert some other identity according
              to <b>&lt;mode&gt;</b>.  Other identity assertion modes are <b>anonymous</b>
              and <b>self</b>, which respectively mean that the <i>empty</i> or the
              <i>client</i>'s identity will be asserted; <b>none</b>, which means that
              no proxyAuthz control will be used, so the <i>authcDN</i> or the
              <i>authcID</i> identity will be asserted.  For all modes that
              require the use of the <i>proxyAuthz</i> control, on the remote
              server the proxy identity must have appropriate <i>authzTo</i>
              permissions, or the asserted identities must have
              appropriate <i>authzFrom</i> permissions.  Note, however, that
              the ID assertion feature is mostly useful when the
              asserted identities do not exist on the remote server.
              When <i>bindmethod</i> is <b>SASL</b>, the <i>authcDN</i> must be specified in
              addition to the <i>authcID</i>, although it is not used within
              the authentication process.

              Flags can be

              <b>override,[non-]prescriptive,proxy-authz-[non-]critical</b>

              When the <b>override </b>flag is used, identity assertion takes
              place even when the database is authorizing for the
              identity of the client, i.e. after binding with the
              provided identity, and thus authenticating it, the proxy
              performs the identity assertion using the configured
              identity and authentication method.

              When the <b>prescriptive </b>flag is used (the default),
              operations fail with <i>inappropriateAuthentication</i> for those
              identities whose assertion is not allowed by the
              <b>idassert-authzFrom </b>patterns.  If the <b>non-prescriptive </b>flag
              is used, operations are performed anonymously for those
              identities whose assertion is not allowed by the
              <b>idassert-authzFrom </b>patterns.

              When the <b>proxy-authz-non-critical </b>flag is used (the
              default), the proxyAuthz control is not marked as
              critical, in violation of RFC 4370.  Use of
              <b>proxy-authz-critical </b>is recommended.

              The TLS settings default to the same as the main slapd TLS
              settings, except for <b>tls_reqcert </b>which defaults to
              "demand", and <b>tls_reqsan </b>which defaults to "allow"..

              The identity associated to this directive is also used for
              privileged operations whenever <b>idassert-bind </b>is defined
              and <b>acl-bind </b>is not.  See <b>acl-bind </b>for details.

       <b>idle-timeout &lt;time&gt;</b>
              This directive causes a cached connection to be dropped an
              recreated after it has been idle for the specified time.
              The value can be specified as

              [&lt;d&gt;d][&lt;h&gt;h][&lt;m&gt;m][&lt;s&gt;[s]]

              where &lt;d&gt;, &lt;h&gt;, &lt;m&gt; and &lt;s&gt; are respectively treated as
              days, hours, minutes and seconds.  If set before any
              target specification, it affects all targets, unless
              overridden by any per-target directive.

       <b>keepalive &lt;idle&gt;:&lt;probes&gt;:&lt;interval&gt;</b>
              The <b>keepalive </b>parameter sets the values of <i>idle</i>, <i>probes</i>,
              and <i>interval</i> used to check whether a socket is alive; <i>idle</i>
              is the number of seconds a connection needs to remain idle
              before TCP starts sending keepalive probes; <i>probes</i> is the
              maximum number of keepalive probes TCP should send before
              dropping the connection; <i>interval</i> is interval in seconds
              between individual keepalive probes.  Only some systems
              support the customization of these values; the <b>keepalive</b>
              parameter is ignored otherwise, and system-wide settings
              are used.

       <b>tcp-user-timeout &lt;milliseconds&gt;</b>
              If non-zero, corresponds to the <b>TCP_USER_TIMEOUT </b>set on
              the target connections, overriding the operating system
              setting.  Only some systems support the customization of
              this parameter, it is ignored otherwise and system-wide
              settings are used.

       <b>map {attribute|objectclass} [&lt;local name&gt;|*] {&lt;foreign name&gt;|*}</b>
              This maps object classes and attributes as in the LDAP
              backend.  See <a href="slapd-ldap.5.html">slapd-ldap(5)</a>.

       <b>network-timeout &lt;time&gt;</b>
              Sets the network timeout value after which
              <a href="../man2/poll.2.html">poll(2)</a>/<a href="../man2/select.2.html">select(2)</a> following a <a href="../man2/connect.2.html">connect(2)</a> returns in case
              of no activity.  The value is in seconds, and it can be
              specified as for <b>idle-timeout</b>.  If set before any target
              specification, it affects all targets, unless overridden
              by any per-target directive.

       <b>nretries {forever|never|&lt;nretries&gt;}</b>
              This directive defines how many times a bind should be
              retried in case of temporary failure in contacting a
              target.  If defined before any target specification, it
              applies to all targets (by default, <b>3 </b>times); the global
              value can be overridden by redefinitions inside each
              target specification.

       <b>rewrite* ...</b>
              The rewrite options are described in the "REWRITING"
              section.

       <b>subtree-{exclude|include} &lt;rule&gt;</b>
              This directive allows one to indicate what subtrees are
              actually served by a target.  The syntax of the supported
              rules is

              <b>&lt;rule&gt;: [dn[.&lt;style&gt;]:]&lt;pattern&gt;</b>

              <b>&lt;style&gt;: subtree|children|regex</b>

              When <b>&lt;style&gt; </b>is either <b>subtree </b>or <b>children </b>the <b>&lt;pattern&gt;</b>
              is a DN that must be within the naming context served by
              the target.  When <b>&lt;style&gt; </b>is <b>regex </b>the <b>&lt;pattern&gt; </b>is a
              <b>regex</b>(5) pattern.  If the <b>dn.&lt;style&gt;: </b>prefix is omitted,
              <b>dn.subtree: </b>is implicitly assumed for backward
              compatibility.

              In the <b>subtree-exclude </b>form if the <i>request DN</i> matches at
              least one rule, the target is not considered while
              fulfilling the request; otherwise, the target is
              considered based on the value of the <i>request DN</i>.  When the
              request is a search, also the <i>scope</i> is considered.

              In the <b>subtree-include </b>form if the <i>request DN</i> matches at
              least one rule, the target is considered while fulfilling
              the request; otherwise the target is ignored.

                  |  match  | exclude |
                  +---------+---------+-------------------+
                  |    T    |    T    | not candidate     |
                  |    F    |    T    | continue checking |
                  +---------+---------+-------------------+
                  |    T    |    F    | candidate         |
                  |    F    |    F    | not candidate     |
                  +---------+---------+-------------------+

              There may be multiple occurrences of the <b>subtree-exclude</b>
              or <b>subtree-include </b>directive for each of the targets, but
              they are mutually exclusive.

       <b>suffixmassage &lt;virtual naming context&gt; &lt;real naming context&gt;</b>
              All the directives starting with "rewrite" refer to the
              rewrite engine that has been added to slapd.  The
              "suffixmassage" directive was introduced in the LDAP
              backend to allow suffix massaging while proxying.  It has
              been obsoleted by the rewriting tools.  However, both for
              backward compatibility and for ease of configuration when
              simple suffix massage is required, it has been preserved.
              It wraps the basic rewriting instructions that perform
              suffix massaging.  See the "REWRITING" section for a
              detailed list of the rewrite rules it implies.

       <b>t-f-support {NO|yes|discover}</b>
              enable if the remote server supports absolute filters (see
              <i>RFC 4526</i> for details).  If set to <b>discover</b>, support is
              detected by reading the remote server's root DSE.  If set
              before any target specification, it affects all targets,
              unless overridden by any per-target directive.

       <b>timeout [&lt;op&gt;=]&lt;val&gt; [...]</b>
              This directive allows one to set per-operation timeouts.
              Operations can be

              <b>&lt;op&gt; ::= bind, add, delete, modrdn, modify, compare,</b>
              <b>search</b>

              The overall duration of the <b>search </b>operation is controlled
              either by the <b>timelimit </b>parameter or by server-side
              enforced time limits (see <b>timelimit </b>and <b>limits </b>in
              <a href="slapd.conf.5.html">slapd.conf(5)</a> for details).  This <b>timeout </b>parameter
              controls how long the target can be irresponsive before
              the operation is aborted.  Timeout is meaningless for the
              remaining operations, <b>unbind </b>and <b>abandon</b>, which do not
              imply any response, while it is not yet implemented in
              currently supported <b>extended </b>operations.  If no operation
              is specified, the timeout <b>val </b>affects all supported
              operations.  If specified before any target definition, it
              affects all targets unless overridden by per-target
              directives.

              Note: if the timeout is exceeded, the operation is
              cancelled (according to the <b>cancel </b>directive); the
              protocol does not provide any means to rollback
              operations, so the client will not be notified about the
              result of the operation, which may eventually succeeded or
              not.  In case the timeout is exceeded during a bind
              operation, the connection is destroyed, according to
              RFC4511.

       <b>tls {none|[try-]start|[try-]propagate|ldaps}</b>
              <b>[starttls=no] [tls_cert=&lt;file&gt;] [tls_key=&lt;file&gt;]</b>
              <b>[tls_cacert=&lt;file&gt;] [tls_cacertdir=&lt;path&gt;]</b>
              <b>[tls_reqcert=never|allow|try|demand]</b>
              <b>[tls_reqsan=never|allow|try|demand]</b>
              <b>[tls_cipher_suite=&lt;ciphers&gt;] [tls_ecname=&lt;names&gt;]</b>
              <b>[tls_crlcheck=none|peer|all]</b>
              Specify TLS settings regular connections.

              If the first parameter is not "none" then this configures
              the TLS settings to be used for regular connections.  The
              StartTLS extended operation will be used when establishing
              the connection unless the URI directive protocol scheme is
              <b>ldaps://</b>.  In that case this keyword may only be set to
              "ldaps" and the StartTLS operation will not be used.

              With <b>propagate</b>, the proxy issues the StartTLS operation
              only if the original connection has a TLS layer set up.
              The <b>try- </b>prefix instructs the proxy to continue operations
              if the StartTLS operation failed; its use is <b>not</b>
              recommended.

              The TLS settings default to the same as the main slapd TLS
              settings, except for <b>tls_reqcert </b>which defaults to
              "demand", <b>tls_reqsan </b>which defaults to "allow", and
              <b>starttls </b>which is overshadowed by the first keyword and
              thus ignored.

              If set before any target specification, it affects all
              targets, unless overridden by any per-target directive.
</pre> <h2>
SCENARIOS </h2>
<pre>
       A powerful (and in some sense dangerous) rewrite engine has been
       added to both the LDAP and Meta backends.  While the former can
       gain limited beneficial effects from rewriting stuff, the latter
       can become an amazingly powerful tool.

       Consider a couple of scenarios first.

       1) Two directory servers share two levels of naming context; say
       "dc=a,dc=foo,dc=com" and "dc=b,dc=foo,dc=com".  Then, an
       unambiguous Meta database can be configured as:

              database meta
              suffix   "<b>dc=foo,dc=com</b>"
              uri      "ldap://a.foo.com/dc=a,<b>dc=foo,dc=com</b>"
              uri      "ldap://b.foo.com/dc=b,<b>dc=foo,dc=com</b>"

       Operations directed to a specific target can be easily resolved
       because there are no ambiguities.  The only operation that may
       resolve to multiple targets is a search with base "dc=foo,dc=com"
       and scope at least "one", which results in spawning two searches
       to the targets.

       2a) Two directory servers don't share any portion of naming
       context, but they'd present as a single DIT [Caveat: uniqueness
       of (massaged) entries among the two servers is assumed; integrity
       checks risk to incur in excessive overhead and have not been
       implemented].  Say we have "dc=bar,dc=org" and "o=Foo,c=US", and
       we'd like them to appear as branches of "dc=foo,dc=com", say
       "dc=a,dc=foo,dc=com" and "dc=b,dc=foo,dc=com".  Then we need to
       configure our Meta backend as:

              database      meta
              suffix        "dc=foo,dc=com"

              uri           "ldap://a.bar.com/<b>dc=a,dc=foo,dc=com</b>"
              suffixmassage "<b>dc=a,dc=foo,dc=com</b>" "dc=bar,dc=org"

              uri           "ldap://b.foo.com/<b>dc=b,dc=foo,dc=com</b>"
              suffixmassage "<b>dc=b,dc=foo,dc=com</b>" "o=Foo,c=US"

       Again, operations can be resolved without ambiguity, although
       some rewriting is required.  Notice that the virtual naming
       context of each target is a branch of the database's naming
       context; it is rewritten back and forth when operations are
       performed towards the target servers.  What "back and forth"
       means will be clarified later.

       When a search with base "dc=foo,dc=com" is attempted, if the
       scope is "base" it fails with "no such object"; in fact, the
       common root of the two targets (prior to massaging) does not
       exist.  If the scope is "one", both targets are contacted with
       the base replaced by each target's base; the scope is derated to
       "base".  In general, a scope "one" search is honored, and the
       scope is derated, only when the incoming base is at most one
       level lower of a target's naming context (prior to massaging).

       Finally, if the scope is "sub" the incoming base is replaced by
       each target's unmassaged naming context, and the scope is not
       altered.

       2b) Consider the above reported scenario with the two servers
       sharing the same naming context:

              database      meta
              suffix        "<b>dc=foo,dc=com</b>"

              uri           "ldap://a.bar.com/<b>dc=foo,dc=com</b>"
              suffixmassage "<b>dc=foo,dc=com</b>" "dc=bar,dc=org"

              uri           "ldap://b.foo.com/<b>dc=foo,dc=com</b>"
              suffixmassage "<b>dc=foo,dc=com</b>" "o=Foo,c=US"

       All the previous considerations hold, except that now there is no
       way to unambiguously resolve a DN.  In this case, all the
       operations that require an unambiguous target selection will fail
       unless the DN is already cached or a default target has been set.
       Practical configurations may result as a combination of all the
       above scenarios.
</pre> <h2>
ACLs </h2>
<pre>
       Note on ACLs: at present you may add whatever ACL rule you desire
       to the Meta (and LDAP) backends.  However, the meaning of an ACL
       on a proxy may require some considerations.  Two philosophies may
       be considered:

       a) the remote server dictates the permissions; the proxy simply
       passes back what it gets from the remote server.

       b) the remote server unveils "everything"; the proxy is
       responsible for protecting data from unauthorized access.

       Of course the latter sounds unreasonable, but it is not.  It is
       possible to imagine scenarios in which a remote host discloses
       data that can be considered "public" inside an intranet, and a
       proxy that connects it to the internet may impose additional
       constraints.  To this purpose, the proxy should be able to comply
       with all the ACL matching criteria that the server supports.
       This has been achieved with regard to all the criteria supported
       by slapd except a special subtle case (please file an ITS if you
       can find other exceptions: &lt;<a href="http://www.openldap.org/its/">http://www.openldap.org/its/</a>&gt;).  The
       rule

              access to dn="&lt;dn&gt;" attrs=&lt;attr&gt;
                     by dnattr=&lt;dnattr&gt; read
                     by * none

       cannot be matched iff the attribute that is being requested,
       &lt;attr&gt;, is NOT &lt;dnattr&gt;, and the attribute that determines
       membership, &lt;dnattr&gt;, has not been requested (e.g. in a search)

       In fact this ACL is resolved by slapd using the portion of entry
       it retrieved from the remote server without requiring any further
       intervention of the backend, so, if the &lt;dnattr&gt; attribute has
       not been fetched, the match cannot be assessed because the
       attribute is not present, not because no value matches the
       requirement!

       Note on ACLs and attribute mapping: ACLs are applied to the
       mapped attributes; for instance, if the attribute locally known
       as "foo" is mapped to "bar" on a remote server, then local ACLs
       apply to attribute "foo" and are totally unaware of its remote
       name.  The remote server will check permissions for "bar", and
       the local server will possibly enforce additional restrictions to
       "foo".
</pre> <h2>
REWRITING </h2>
<pre>
       A string is rewritten according to a set of rules, called a
       `rewrite context'.  The rules are based on POSIX (''extended'')
       regular expressions (regex) with substring matching; basic
       variable substitution and map resolution of substrings is allowed
       by specific mechanisms detailed in the following.  The behavior
       of pattern matching/substitution can be altered by a set of
       flags.

       The underlying concept is to build a lightweight rewrite module
       for the slapd server (initially dedicated to the LDAP backend).
</pre> <h2>
Passes </h2>
<pre>
       An incoming string is matched against a set of rules.  Rules are
       made of a regex match pattern, a substitution pattern and a set
       of actions, described by a set of flags.  In case of match a
       string rewriting is performed according to the substitution
       pattern that allows one to refer to substrings matched in the
       incoming string.  The actions, if any, are finally performed.
       The substitution pattern allows map resolution of substrings.  A
       map is a generic object that maps a substitution pattern to a
       value.  The flags are divided in "Pattern matching Flags" and
       "Action Flags"; the former alter the regex match pattern behavior
       while the latter alter the action that is taken after
       substitution.
</pre> <h2>
Pattern Matching Flags </h2>
<pre>
       <b>`C'    </b>honors case in matching (default is case insensitive)

       <b>`R'    </b>use POSIX ''basic'' regular expressions (default is
              ''extended'')

       <b>`M{n}' </b>allow no more than <b>n </b>recursive passes for a specific rule;
              does not alter the max total count of passes, so it can
              only enforce a stricter limit for a specific rule.
</pre> <h2>
Action Flags </h2>
<pre>
       <b>`:'    </b>apply the rule once only (default is recursive)

       <b>`@'    </b>stop applying rules in case of match; the current rule is
              still applied recursively; combine with `:' to apply the
              current rule only once and then stop.

       <b>`#'    </b>stop current operation if the rule matches, and issue an
              `unwilling to perform' error.

       <b>`G{n}' </b>jump <b>n </b>rules back and forth (watch for loops!).  Note that
              `G{1}' is implicit in every rule.

       <b>`I'    </b>ignores errors in rule; this means, in case of error, e.g.
              issued by a map, the error is treated as a missed match.
              The `unwilling to perform' is not overridden.

       <b>`U{n}' </b>uses <b>n </b>as return code if the rule matches; the flag does
              not alter the recursive behavior of the rule, so, to have
              it performed only once, it must be used in combination
              with `:', e.g.  <b>`:U{16}' </b>returns the value `16' after
              exactly one execution of the rule, if the pattern matches.
              As a consequence, its behavior is equivalent to `@', with
              the return code set to <b>n</b>; or, in other words, `@' is
              equivalent to `U{0}'.  By convention, the freely available
              codes are above 16 included; the others are reserved.

       The ordering of the flags can be significant.  For instance:
       `IG{2}' means ignore errors and jump two lines ahead both in case
       of match and in case of error, while `G{2}I' means ignore errors,
       but jump two lines ahead only in case of match.

       More flags (mainly Action Flags) will be added as needed.
</pre> <h2>
Pattern matching: </h2>
<pre>
       See <a href="../man7/regex.7.html">regex(7)</a> and/or <b>re_format</b>(7).
</pre> <h2>
Substitution Pattern Syntax: </h2>
<pre>
       Everything starting with `%' requires substitution;

       the only obvious exception is `%%', which is left as is;

       the basic substitution is `%d', where `d' is a digit; 0 means the
       whole string, while 1-9 is a submatch;

       a `%' followed by a `{' invokes an advanced substitution.  The
       pattern is:

              `%' `{' [ &lt;op&gt; ] &lt;name&gt; `(' &lt;substitution&gt; `)' `}'

       where &lt;name&gt; must be a legal name for the map, i.e.

              &lt;name&gt; ::= [a-z][a-z0-9]* (case insensitive)
              &lt;op&gt; ::= `&gt;' `|' `&amp;' `&amp;&amp;' `*' `**' `$'

       and &lt;substitution&gt; must be a legal substitution pattern, with no
       limits on the nesting level.

       The operators are:

       <b>&gt;      </b>sub context invocation; &lt;name&gt; must be a legal, already
              defined rewrite context name

       <b>|      </b>external command invocation; &lt;name&gt; must refer to a legal,
              already defined command name (NOT IMPL.)

       <b>&amp;      </b>variable assignment; &lt;name&gt; defines a variable in the
              running operation structure which can be dereferenced
              later; operator <b>&amp; </b>assigns a variable in the rewrite
              context scope; operator <b>&amp;&amp; </b>assigns a variable that scopes
              the entire session, e.g. its value can be dereferenced
              later by other rewrite contexts

       <b>*      </b>variable dereferencing; &lt;name&gt; must refer to a variable
              that is defined and assigned for the running operation;
              operator <b>* </b>dereferences a variable scoping the rewrite
              context; operator <b>** </b>dereferences a variable scoping the
              whole session, e.g. the value is passed across rewrite
              contexts

       <b>$      </b>parameter dereferencing; &lt;name&gt; must refer to an existing
              parameter; the idea is to make some run-time parameters
              set by the system available to the rewrite engine, as the
              client host name, the bind DN if any, constant parameters
              initialized at config time, and so on; no parameter is
              currently set by either <b>back-ldap </b>or <b>back-meta</b>, but
              constant parameters can be defined in the configuration
              file by using the <b>rewriteParam </b>directive.

       Substitution escaping has been delegated to the `%' symbol, which
       is used instead of `\' in string substitution patterns because
       `\' is already escaped by slapd's low level parsing routines; as
       a consequence, regex escaping requires two `\' symbols, e.g.
       `<b>.*\.foo\.bar</b>' must be written as `<b>.*\\.foo\\.bar</b>'.
</pre> <h2>
Rewrite context: </h2>
<pre>
       A rewrite context is a set of rules which are applied in
       sequence.  The basic idea is to have an application initialize a
       rewrite engine (think of Apache's mod_rewrite ...) with a set of
       rewrite contexts; when string rewriting is required, one invokes
       the appropriate rewrite context with the input string and obtains
       the newly rewritten one if no errors occur.

       Each basic server operation is associated to a rewrite context;
       they are divided in two main groups: client -&gt; server and server
       -&gt; client rewriting.

       client -&gt; server:

              (default)            if defined and no specific context
                                   is available
              bindDN               bind
              searchBase           search
              searchFilter         search
              searchFilterAttrDN   search
              compareDN            compare
              compareAttrDN        compare AVA
              addDN                add
              addAttrDN            add AVA
              modifyDN             modify
              modifyAttrDN         modify AVA
              modrDN               modrdn
              newSuperiorDN        modrdn
              deleteDN             delete
              exopPasswdDN         password modify extended operation DN if proxy

       server -&gt; client:

              searchResult         search (only if defined; no default;
                                   acts on DN and DN-syntax attributes
                                   of search results)
              searchAttrDN         search AVA
              matchedDN            all ops (only if applicable)
</pre> <h2>
Basic configuration syntax </h2>
<pre>
       <b>rewriteEngine { on | off }</b>
              If `on', the requested rewriting is performed; if `off',
              no rewriting takes place (an easy way to stop rewriting
              without altering too much the configuration file).

       <b>rewriteContext &lt;context name&gt; [ alias &lt;aliased context name&gt; ]</b>
              &lt;Context name&gt; is the name that identifies the context,
              i.e. the name used by the application to refer to the set
              of rules it contains.  It is used also to reference sub
              contexts in string rewriting.  A context may alias another
              one.  In this case the alias context contains no rule, and
              any reference to it will result in accessing the aliased
              one.

       <b>rewriteRule &lt;regex match pattern&gt; &lt;substitution pattern&gt; [</b>
       <b>&lt;flags&gt; ]</b>
              Determines how a string can be rewritten if a pattern is
              matched.  Examples are reported below.
</pre> <h2>
Additional configuration syntax: </h2>
<pre>
       <b>rewriteMap &lt;map type&gt; &lt;map name&gt; [ &lt;map attrs&gt; ]</b>
              Allows one to define a map that transforms substring
              rewriting into something else.  The map is referenced
              inside the substitution pattern of a rule.

       <b>rewriteParam &lt;param name&gt; &lt;param value&gt;</b>
              Sets a value with global scope, that can be dereferenced
              by the command `%{$paramName}'.

       <b>rewriteMaxPasses &lt;number of passes&gt; [&lt;number of passes per rule&gt;]</b>
              Sets the maximum number of total rewriting passes that can
              be performed in a single rewrite operation (to avoid
              loops).  A safe default is set to 100; note that reaching
              this limit is still treated as a success; recursive
              invocation of rules is simply interrupted.  The count
              applies to the rewriting operation as a whole, not to any
              single rule; an optional per-rule limit can be set.  This
              limit is overridden by setting specific per-rule limits
              with the `M{n}' flag.
</pre> <h2>
Configuration examples: </h2>
<pre>
       # set to `off' to disable rewriting
       rewriteEngine on

       # the rules the "suffixmassage" directive implies
       rewriteEngine on
       # all dataflow from client to server referring to DNs
       rewriteContext default
       rewriteRule "(.*)&lt;virtualnamingcontext&gt;$" "%1&lt;realnamingcontext&gt;" ":"
       # empty filter rule
       rewriteContext searchFilter
       # all dataflow from server to client
       rewriteContext searchResult
       rewriteRule "(.*)&lt;realnamingcontext&gt;$" "%1&lt;virtualnamingcontext&gt;" ":"
       rewriteContext searchAttrDN alias searchResult
       rewriteContext matchedDN alias searchResult

       # Everything defined here goes into the `default' context.
       # This rule changes the naming context of anything sent
       # to `dc=home,dc=net' to `dc=OpenLDAP, dc=org'

       rewriteRule "(.*)dc=home,[ ]?dc=net"
                   "%1dc=OpenLDAP, dc=org"  ":"

       # since a pretty/normalized DN does not include spaces
       # after rdn separators, e.g. `,', this rule suffices:

       rewriteRule "(.*)dc=home,dc=net"
                   "%1dc=OpenLDAP,dc=org"  ":"

       # Start a new context (ends input of the previous one).
       # This rule adds blanks between DN parts if not present.
       rewriteContext  addBlanks
       rewriteRule     "(.*),([^ ].*)" "%1, %2"

       # This one eats blanks
       rewriteContext  eatBlanks
       rewriteRule     "(.*),[ ](.*)" "%1,%2"

       # Here control goes back to the default rewrite
       # context; rules are appended to the existing ones.
       # anything that gets here is piped into rule `addBlanks'
       rewriteContext  default
       rewriteRule     ".*" "%{&gt;addBlanks(%0)}" ":"

       # Rewrite the search base according to `default' rules.
       rewriteContext  searchBase alias default

       # Search results with OpenLDAP DN are rewritten back with
       # `dc=home,dc=net' naming context, with spaces eaten.
       rewriteContext  searchResult
       rewriteRule     "(.*[^ ]?)[ ]?dc=OpenLDAP,[ ]?dc=org"
                       "%{&gt;eatBlanks(%1)}dc=home,dc=net"    ":"

       # Bind with email instead of full DN: we first need
       # an ldap map that turns attributes into a DN (the
       # argument used when invoking the map is appended to
       # the URI and acts as the filter portion)
       rewriteMap ldap attr2dn "ldap://host/dc=my,dc=org?dn?sub"

       # Then we need to detect DN made up of a single email,
       # e.g. `mail=someone@example.com'; note that the rule
       # in case of match stops rewriting; in case of error,
       # it is ignored.  In case we are mapping virtual
       # to real naming contexts, we also need to rewrite
       # regular DNs, because the definition of a bindDn
       # rewrite context overrides the default definition.
       rewriteContext bindDN
       rewriteRule "^mail=[^,]+@[^,]+$" "%{attr2dn(%0)}" ":@I"

       # This is a rather sophisticated example. It massages a
       # search filter in case who performs the search has
       # administrative privileges.  First we need to keep
       # track of the bind DN of the incoming request, which is
       # stored in a variable called `binddn' with session scope,
       # and left in place to allow regular binding:
       rewriteContext  bindDN
       rewriteRule     ".+" "%{&amp;&amp;binddn(%0)}%0" ":"

       # A search filter containing `uid=' is rewritten only
       # if an appropriate DN is bound.
       # To do this, in the first rule the bound DN is
       # dereferenced, while the filter is decomposed in a
       # prefix, in the value of the `uid=&lt;arg&gt;' AVA, and
       # in a suffix. A tag `&lt;&gt;' is appended to the DN.
       # If the DN refers to an entry in the `ou=admin' subtree,
       # the filter is rewritten OR-ing the `uid=&lt;arg&gt;' with
       # `cn=&lt;arg&gt;'; otherwise it is left as is. This could be
       # useful, for instance, to allow apache's auth_ldap-1.4
       # module to authenticate users with both `uid' and
       # `cn', but only if the request comes from a possible
       # `cn=Web auth,ou=admin,dc=home,dc=net' user.
       rewriteContext searchFilter
       rewriteRule "(.*\\()uid=([a-z0-9_]+)(\\).*)"
         "%{**binddn}&lt;&gt;%{&amp;prefix(%1)}%{&amp;arg(%2)}%{&amp;suffix(%3)}"
         ":I"
       rewriteRule "[^,]+,ou=admin,dc=home,dc=net"
         "%{*prefix}|(uid=%{*arg})(cn=%{*arg})%{*suffix}" ":@I"
       rewriteRule ".*&lt;&gt;" "%{*prefix}uid=%{*arg}%{*suffix}" ":"

       # This example shows how to strip unwanted DN-valued
       # attribute values from a search result; the first rule
       # matches DN values below "ou=People,dc=example,dc=com";
       # in case of match the rewriting exits successfully.
       # The second rule matches everything else and causes
       # the value to be rejected.
       rewriteContext searchResult
       rewriteRule ".*,ou=People,dc=example,dc=com" "%0" ":@"
       rewriteRule ".*" "" "#"
</pre> <h2>
LDAP Proxy resolution (a possible evolution of slapd-ldap(5)): </h2>
<pre>
       In case the rewritten DN is an LDAP URI, the operation is
       initiated towards the host[:port] indicated in the uri, if it
       does not refer to the local server.  E.g.:

         rewriteRule '^cn=root,.*' '%0'                     'G{3}'
         rewriteRule '^cn=[a-l].*' 'ldap://ldap1.my.org/%0' ':@'
         rewriteRule '^cn=[m-z].*' 'ldap://ldap2.my.org/%0' ':@'
         rewriteRule '.*'          'ldap://ldap3.my.org/%0' ':@'

       (Rule 1 is simply there to illustrate the `G{n}' action; it could
       have been written:

         rewriteRule '^cn=root,.*' 'ldap://ldap3.my.org/%0' ':@'

       with the advantage of saving one rewrite pass ...)
</pre> <h2>
ACCESS CONTROL </h2>
<pre>
       The <b>meta </b>backend does not honor all ACL semantics as described in
       <a href="slapd.access.5.html">slapd.access(5)</a>.  In general, access checking is delegated to the
       remote server(s).  Only <b>read (=r) </b>access to the <b>entry </b>pseudo-
       attribute and to the other attribute values of the entries
       returned by the <b>search </b>operation is honored, which is performed
       by the frontend.
</pre> <h2>
PROXY CACHE OVERLAY </h2>
<pre>
       The proxy cache overlay allows caching of LDAP search requests
       (queries) in a local database.  See <a href="slapo-pcache.5.html">slapo-pcache(5)</a> for details.
</pre> <h2>
DEPRECATED STATEMENTS </h2>
<pre>
       The following statements have been deprecated and should no
       longer be used.

       <b>pseudorootdn &lt;substitute DN in case of rootdn bind&gt;</b>
              Use <b>idassert-bind </b>instead.

       <b>pseudorootpw &lt;substitute password in case of rootdn bind&gt;</b>
              Use <b>idassert-bind </b>instead.
</pre> <h2>
FILES </h2>
<pre>
       ETCDIR/slapd.conf
              default slapd configuration file
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="slapd.conf.5.html">slapd.conf(5)</a>, <a href="slapd-asyncmeta.5.html">slapd-asyncmeta(5)</a>, <a href="slapd-ldap.5.html">slapd-ldap(5)</a>,
       <a href="slapo-pcache.5.html">slapo-pcache(5)</a>, <a href="../man8/slapd.8.html">slapd(8)</a>, <a href="../man7/regex.7.html">regex(7)</a>, <b>re_format</b>(7).
</pre> <h2>
AUTHOR </h2>
<pre>
       Pierangelo Masarati, based on back-ldap by Howard Chu
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>OpenLDAP</i> (an open source implementation
       of the Lightweight Directory Access Protocol) project.
       Information about the project can be found at 
       âŸ¨<a href="http://www.openldap.org/">http://www.openldap.org/</a>âŸ©.  If you have a bug report for this
       manual page, see âŸ¨<a href="http://www.openldap.org/its/">http://www.openldap.org/its/</a>âŸ©.  This page was
       obtained from the project's upstream Git repository
       âŸ¨<a href="https://git.openldap.org/openldap/openldap.git">https://git.openldap.org/openldap/openldap.git</a>âŸ© on 2024-06-14.
       (At that time, the date of the most recent commit that was found
       in the repository was 2024-06-13.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">OpenLDAP LDVERSION             RELEASEDATE                 <i>SLAPD-META</i>(5)</span>
</pre>  <p>Pages that refer to this page: <a href="slapd-asyncmeta.5.html">slapd-asyncmeta(5)</a>, <a href="slapd.backends.5.html">slapd.backends(5)</a>, <a href="slapd-ldap.5.html">slapd-ldap(5)</a>, <a href="slapd-meta.5.html">slapd-meta(5)</a>, <a href="slapd.overlays.5.html">slapd.overlays(5)</a>, <a href="slapo-pcache.5.html">slapo-pcache(5)</a>, <a href="slapo-rwm.5.html">slapo-rwm(5)</a>, <a href="slapo-translucent.5.html">slapo-translucent(5)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man5/slapd-meta.5.html" class="_attribution-link">https://man7.org/linux/man-pages/man5/slapd-meta.5.html</a>
  </p>
</div>
