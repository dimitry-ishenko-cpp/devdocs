<h1>org.freedesktop.login1(5) â€” Linux manual page</h1>   <pre>
<span class="headline"><i>ORG.FREED...OP.LOGIN1</i>(5) org.freedesktop.login1 <i>ORG.FREED...OP.LOGIN1</i>(5)</span>
</pre> <h2>
NAME </h2>
<pre>
       org.freedesktop.login1 - The D-Bus interface of systemd-logind
</pre> <h2>
INTRODUCTION </h2>
<pre>
       <a href="../man8/systemd-logind.service.8.html">systemd-logind.service(8)</a> is a system service that keeps track of
       user logins and seats.

       The daemon provides both a C library interface as well as a D-Bus
       interface. The library interface may be used to introspect and
       watch the state of user logins and seats. The bus interface
       provides the same functionality but in addition may also be used
       to make changes to the system state. For more information please
       consult <a href="../man3/sd-login.3.html">sd-login(3)</a>.
</pre> <h2>
THE MANAGER OBJECT </h2>
<pre>
       The service exposes the following interfaces on the Manager
       object on the bus:

           node /org/freedesktop/login1 {
             interface org.freedesktop.login1.Manager {
               methods:
                 GetSession(in  s session_id,
                            out o object_path);
                 GetSessionByPID(in  u pid,
                                 out o object_path);
                 GetUser(in  u uid,
                         out o object_path);
                 GetUserByPID(in  u pid,
                              out o object_path);
                 GetSeat(in  s seat_id,
                         out o object_path);
                 ListSessions(out a(susso) sessions);
                 ListSessionsEx(out a(sussussbto) sessions);
                 ListUsers(out a(uso) users);
                 ListSeats(out a(so) seats);
                 ListInhibitors(out a(ssssuu) inhibitors);
                 @org.freedesktop.systemd1.Privileged("true")
                 CreateSession(in  u uid,
                               in  u pid,
                               in  s service,
                               in  s type,
                               in  s class,
                               in  s desktop,
                               in  s seat_id,
                               in  u vtnr,
                               in  s tty,
                               in  s display,
                               in  b remote,
                               in  s remote_user,
                               in  s remote_host,
                               in  a(sv) properties,
                               out s session_id,
                               out o object_path,
                               out s runtime_path,
                               out h fifo_fd,
                               out u uid,
                               out s seat_id,
                               out u vtnr,
                               out b existing);
                 @org.freedesktop.systemd1.Privileged("true")
                 CreateSessionWithPIDFD(in  u uid,
                                        in  h pidfd,
                                        in  s service,
                                        in  s type,
                                        in  s class,
                                        in  s desktop,
                                        in  s seat_id,
                                        in  u vtnr,
                                        in  s tty,
                                        in  s display,
                                        in  b remote,
                                        in  s remote_user,
                                        in  s remote_host,
                                        in  t flags,
                                        in  a(sv) properties,
                                        out s session_id,
                                        out o object_path,
                                        out s runtime_path,
                                        out h fifo_fd,
                                        out u uid,
                                        out s seat_id,
                                        out u vtnr,
                                        out b existing);
                 ReleaseSession(in  s session_id);
                 ActivateSession(in  s session_id);
                 ActivateSessionOnSeat(in  s session_id,
                                       in  s seat_id);
                 LockSession(in  s session_id);
                 UnlockSession(in  s session_id);
                 LockSessions();
                 UnlockSessions();
                 KillSession(in  s session_id,
                             in  s who,
                             in  i signal_number);
                 KillUser(in  u uid,
                          in  i signal_number);
                 TerminateSession(in  s session_id);
                 TerminateUser(in  u uid);
                 TerminateSeat(in  s seat_id);
                 SetUserLinger(in  u uid,
                               in  b enable,
                               in  b interactive);
                 AttachDevice(in  s seat_id,
                              in  s sysfs_path,
                              in  b interactive);
                 FlushDevices(in  b interactive);
                 PowerOff(in  b interactive);
                 PowerOffWithFlags(in  t flags);
                 Reboot(in  b interactive);
                 RebootWithFlags(in  t flags);
                 Halt(in  b interactive);
                 HaltWithFlags(in  t flags);
                 Suspend(in  b interactive);
                 SuspendWithFlags(in  t flags);
                 Hibernate(in  b interactive);
                 HibernateWithFlags(in  t flags);
                 HybridSleep(in  b interactive);
                 HybridSleepWithFlags(in  t flags);
                 SuspendThenHibernate(in  b interactive);
                 SuspendThenHibernateWithFlags(in  t flags);
                 Sleep(in  t flags);
                 CanPowerOff(out s result);
                 CanReboot(out s result);
                 CanHalt(out s result);
                 CanSuspend(out s result);
                 CanHibernate(out s result);
                 CanHybridSleep(out s result);
                 CanSuspendThenHibernate(out s result);
                 CanSleep(out s result);
                 ScheduleShutdown(in  s type,
                                  in  t usec);
                 CancelScheduledShutdown(out b cancelled);
                 Inhibit(in  s what,
                         in  s who,
                         in  s why,
                         in  s mode,
                         out h pipe_fd);
                 CanRebootParameter(out s result);
                 SetRebootParameter(in  s parameter);
                 CanRebootToFirmwareSetup(out s result);
                 SetRebootToFirmwareSetup(in  b enable);
                 CanRebootToBootLoaderMenu(out s result);
                 SetRebootToBootLoaderMenu(in  t timeout);
                 CanRebootToBootLoaderEntry(out s result);
                 SetRebootToBootLoaderEntry(in  s boot_loader_entry);
                 SetWallMessage(in  s wall_message,
                                in  b enable);
               signals:
                 SessionNew(s session_id,
                            o object_path);
                 SessionRemoved(s session_id,
                                o object_path);
                 UserNew(u uid,
                         o object_path);
                 UserRemoved(u uid,
                             o object_path);
                 SeatNew(s seat_id,
                         o object_path);
                 SeatRemoved(s seat_id,
                             o object_path);
                 PrepareForShutdown(b start);
                 PrepareForShutdownWithMetadata(b start,
                                                a{sv} metadata);
                 PrepareForSleep(b start);
               properties:
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 @org.freedesktop.systemd1.Privileged("true")
                 readwrite b EnableWallMessages = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 @org.freedesktop.systemd1.Privileged("true")
                 readwrite s WallMessage = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u NAutoVTs = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly as KillOnlyUsers = ['...', ...];
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly as KillExcludeUsers = ['...', ...];
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly b KillUserProcesses = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly s RebootParameter = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b RebootToFirmwareSetup = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly t RebootToBootLoaderMenu = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly s RebootToBootLoaderEntry = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly as BootLoaderEntries = ['...', ...];
                 readonly b IdleHint = ...;
                 readonly t IdleSinceHint = ...;
                 readonly t IdleSinceHintMonotonic = ...;
                 readonly s BlockInhibited = '...';
                 readonly s DelayInhibited = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t InhibitDelayMaxUSec = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t UserStopDelayUSec = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly as SleepOperation = ['...', ...];
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandlePowerKey = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandlePowerKeyLongPress = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleRebootKey = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleRebootKeyLongPress = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleSuspendKey = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleSuspendKeyLongPress = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleHibernateKey = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleHibernateKeyLongPress = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleLidSwitch = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleLidSwitchExternalPower = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleLidSwitchDocked = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t HoldoffTimeoutUSec = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s IdleAction = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t IdleActionUSec = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b PreparingForShutdown = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b PreparingForSleep = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly (st) ScheduledShutdown = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b Docked = ...;
                 readonly b LidClosed = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b OnExternalPower = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly b RemoveIPC = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t RuntimeDirectorySize = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t RuntimeDirectoryInodesMax = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t InhibitorsMax = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly t NCurrentInhibitors = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t SessionsMax = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly t NCurrentSessions = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t StopIdleSessionUSec = ...;
             };
             interface org.freedesktop.DBus.Peer { ... };
             interface org.freedesktop.DBus.Introspectable { ... };
             interface org.freedesktop.DBus.Properties { ... };
           };

   <b>Methods</b>
       <b>GetSession() </b>may be used to get the session object path for the
       session with the specified ID. Similarly, <b>GetUser() </b>and <b>GetSeat()</b>
       get the user and seat objects, respectively.  <b>GetSessionByPID()</b>
       and <b>GetUserByPID() </b>get the session/user object the specified PID
       belongs to if there is any.

       <b>ListSessions() </b>returns an array of all current sessions. The
       structures in the array consist of the following fields: <i>session</i>
       <i>id</i>, <i>user id</i>, <i>user name</i>, <i>seat id</i>, and <i>session object path</i>. If a
       session does not have a seat attached, the seat id field will be
       an empty string.

       <b>ListSessionsEx() </b>returns an array of all current sessions with
       more metadata than <b>ListSessions()</b>. The structures in the array
       consist of the following fields: <i>session id</i>, <i>user id</i>, <i>user name</i>,
       <i>seat id</i>, <i>leader pid</i>, <i>session class</i>, <i>tty name</i>, <i>idle hint</i>, <i>idle</i>
       <i>hint monotonic timestamp</i>, and <i>session object path</i>.  <i>tty</i> and <i>seat</i>
       <i>id</i> fields could be empty, if the session has no associated tty or
       session has no seat attached, respectively.

       <b>ListUsers() </b>returns an array of all currently logged in users.
       The structures in the array consist of the following fields: user
       id, user name, user object path.

       <b>ListSeats() </b>returns an array of all currently available seats.
       The structure in the array consists of the following fields: seat
       id, seat object path.

       <b>ListInhibitors() </b>lists all currently active inhibitors. It
       returns an array of structures consisting of <i>what</i>, <i>who</i>, <i>why</i>,
       <i>mode</i>, <i>uid</i> (user ID), and <i>pid</i> (process ID).

       <b>CreateSession()</b>, <b>CreateSessionWithPIDFD()</b>, and <b>ReleaseSession()</b>
       may be used to open or close login sessions. These calls should
       <i>never</i> be invoked directly by clients. Creating/closing sessions
       is exclusively the job of PAM and its <a href="../man8/pam_systemd.8.html">pam_systemd(8)</a> module.

       <b>ActivateSession() </b>brings the session with the specified ID into
       the foreground.  <b>ActivateSessionOnSeat() </b>does the same, but only
       if the seat id matches.

       <b>LockSession() </b>asks the session with the specified ID to activate
       the screen lock.  <b>UnlockSession() </b>asks the session with the
       specified ID to remove an active screen lock, if there is any.
       This is implemented by sending out the Lock() and Unlock()
       signals from the respective session object which session managers
       are supposed to listen on.

       <b>LockSessions() </b>asks all sessions to activate their screen locks.
       This may be used to lock access to the entire machine in one
       action. Similarly, <b>UnlockSessions() </b>asks all sessions to
       deactivate their screen locks.

       <b>KillSession() </b>may be used to send a Unix signal to one or all
       processes of a session. As arguments it takes the session id,
       either the string "leader" or "all" and a signal number. If
       "leader" is passed only the session "leader" is killed. If "all"
       is passed all processes of the session are killed.

       <b>KillUser() </b>may be used to send a Unix signal to all processes of
       a user. As arguments it takes the user id and a signal number.

       <b>TerminateSession()</b>, <b>TerminateUser()</b>, <b>TerminateSeat() </b>may be used
       to forcibly terminate one specific session, all processes of a
       user, and all sessions attached to a specific seat, respectively.
       The session, user, and seat are identified by their respective
       IDs.

       <b>SetUserLinger() </b>enables or disables user lingering. If enabled,
       the runtime directory of a user is kept around and they may
       continue to run processes while logged out. If disabled, the
       runtime directory goes away as soon as they log out.
       <b>SetUserLinger() </b>expects three arguments: the UID, a boolean
       whether to enable/disable and a boolean controlling the <b>polkit</b>[1]
       authorization interactivity (see below). Note that the user
       linger state is persistently stored on disk.

       <b>AttachDevice() </b>may be used to assign a specific device to a
       specific seat. The device is identified by its /sys/ path and
       must be eligible for seat assignments.  <b>AttachDevice() </b>takes
       three arguments: the seat id, the sysfs path, and a boolean for
       controlling polkit interactivity (see below). Device assignments
       are persistently stored on disk. To create a new seat, simply
       specify a previously unused seat id. For more information about
       the seat assignment logic see <a href="../man3/sd-login.3.html">sd-login(3)</a>.

       <b>FlushDevices() </b>removes all explicit seat assignments for devices,
       resetting all assignments to the automatic defaults. The only
       argument it takes is the polkit interactivity boolean (see
       below).

       <b>PowerOff()</b>, <b>Reboot()</b>, <b>Halt()</b>, <b>Suspend()</b>, and <b>Hibernate() </b>result
       in the system being powered off, rebooted, halted (shut down
       without turning off power), suspended (the system state is saved
       to RAM and the CPU is turned off), or hibernated (the system
       state is saved to disk and the machine is powered down).
       <b>HybridSleep() </b>results in the system entering a hybrid-sleep mode,
       i.e. the system is both hibernated and suspended.
       <b>SuspendThenHibernate() </b>results in the system being suspended,
       then later woken using an RTC timer and hibernated. The only
       argument is the polkit interactivity boolean <i>interactive</i> (see
       below). The main purpose of these calls is that they enforce
       polkit policy and hence allow powering
       off/rebooting/suspending/hibernating even by unprivileged users.
       They also enforce inhibition locks for non-privileged users.
       <b>Sleep() </b>automatically selects the most suitable sleep operation
       supported by the machine. The candidate sleep operations to check
       for support can be configured through <i>SleepOperation=</i> setting in
       <a href="logind.conf.5.html">logind.conf(5)</a>. UIs should expose these calls as the primary
       mechanism to poweroff/reboot/suspend/hibernate the machine.
       Methods <b>PowerOffWithFlags()</b>, <b>RebootWithFlags()</b>, <b>HaltWithFlags()</b>,
       <b>SuspendWithFlags()</b>, <b>HibernateWithFlags()</b>, <b>HybridSleepWithFlags()</b>,
       <b>SuspendThenHibernateWithFlags()</b>, and <b>Sleep() </b>take <i>flags</i> to allow
       for extendability, defined as follows:

           #define SD_LOGIND_ROOT_CHECK_INHIBITORS          (UINT64_C(1) &lt;&lt; 0)
           #define SD_LOGIND_KEXEC_REBOOT                   (UINT64_C(1) &lt;&lt; 1)
           #define SD_LOGIND_SOFT_REBOOT                    (UINT64_C(1) &lt;&lt; 2)
           #define SD_LOGIND_SOFT_REBOOT_IF_NEXTROOT_SET_UP (UINT64_C(1) &lt;&lt; 3)

       When the <i>flags</i> is 0 then these methods behave just like the
       versions without flags. When <b>SD_LOGIND_ROOT_CHECK_INHIBITORS</b>
       (0x01) is set, active inhibitors are honoured for privileged
       users too. When <b>SD_LOGIND_KEXEC_REBOOT </b>(0x02) is set, then
       <b>RebootWithFlags() </b>performs a kexec reboot if kexec kernel is
       loaded. When <b>SD_LOGIND_SOFT_REBOOT </b>(0x04) is set, or
       <b>SD_LOGIND_SOFT_REBOOT_IF_NEXTROOT_SET_UP </b>(0x08) is set and a new
       root file system has been set up on "/run/nextroot/", then
       <b>RebootWithFlags() </b>performs a userspace reboot only.
       <b>SD_LOGIND_SOFT_REBOOT_IF_NEXTROOT_SET_UP </b>and
       <b>SD_LOGIND_KEXEC_REBOOT </b>can be combined, with soft-reboot having
       precedence.

       <b>SetRebootParameter() </b>sets a parameter for a subsequent reboot
       operation. See the description of <b>reboot </b>in <a href="../man1/systemctl.1.html">systemctl(1)</a> and
       <a href="../man2/reboot.2.html">reboot(2)</a> for more information.

       <b>SetRebootToFirmwareSetup()</b>, <b>SetRebootToBootLoaderMenu()</b>, and
       <b>SetRebootToBootLoaderEntry() </b>configure the action to be taken
       from the boot loader after a reboot: respectively entering
       firmware setup mode, the boot loader menu, or a specific boot
       loader entry. See <a href="../man1/systemctl.1.html">systemctl(1)</a> for the corresponding command line
       interface.

       <b>CanPowerOff()</b>, <b>CanReboot()</b>, <b>CanHalt()</b>, <b>CanSuspend()</b>,
       <b>CanHibernate()</b>, <b>CanHybridSleep()</b>, <b>CanSuspendThenHibernate()</b>,
       <b>CanSleep()</b>, <b>CanRebootParameter()</b>, <b>CanRebootToFirmwareSetup()</b>,
       <b>CanRebootToBootLoaderMenu()</b>, and <b>CanRebootToBootLoaderEntry()</b>
       test whether the system supports the respective operation and
       whether the calling user is allowed to execute it. Returns one of
       "na", "yes", "no", and "challenge". If "na" is returned, the
       operation is not available because hardware, kernel, or drivers
       do not support it. If "yes" is returned, the operation is
       supported and the user may execute the operation without further
       authentication. If "no" is returned, the operation is available
       but the user is not allowed to execute the operation. If
       "challenge" is returned, the operation is available but only
       after authorization.

       <b>ScheduleShutdown() </b>schedules a shutdown operation <i>type</i> at time
       <i>usec</i> in microseconds since the UNIX epoch.  <i>type</i> can be one of
       "poweroff", "dry-poweroff", "reboot", "dry-reboot", "halt", and
       "dry-halt". (The "dry-" variants do not actually execute the
       shutdown action.)  <b>CancelScheduledShutdown() </b>cancels a scheduled
       shutdown. The output parameter <i>cancelled</i> is true if a shutdown
       operation was scheduled.

       <b>SetWallMessage() </b>sets the wall message (the message that will be
       sent out to all terminals and stored in a <a href="utmp.5.html">utmp(5)</a> record) for a
       subsequent scheduled shutdown operation. The parameter
       <i>wall_message</i> specifies the shutdown reason (and may be empty)
       which will be included in the shutdown message. The parameter
       <i>enable</i> specifies whether to print a wall message on shutdown.

       <b>Inhibit() </b>creates an inhibition lock. It takes four parameters:
       <i>what</i>, <i>who</i>, <i>why</i>, and <i>mode</i>.  <i>what</i> is one or more of "shutdown",
       "sleep", "idle", "handle-power-key", "handle-suspend-key",
       "handle-hibernate-key", "handle-lid-switch", separated by colons,
       for inhibiting poweroff/reboot, suspend/hibernate, the automatic
       idle logic, or hardware key handling.  <i>who</i> should be a short
       human readable string identifying the application taking the
       lock.  <i>why</i> should be a short human readable string identifying
       the reason why the lock is taken. Finally, <i>mode</i> is either "block"
       or "delay" which encodes whether the inhibit shall be consider
       mandatory or whether it should just delay the operation to a
       certain maximum time. The method returns a file descriptor. The
       lock is released the moment this file descriptor and all its
       duplicates are closed. For more information on the inhibition
       logic see <b>Inhibitor Locks</b>[2].

   <b>Signals</b>
       Whenever the inhibition state or idle hint changes,
       <b>PropertyChanged </b>signals are sent out to which clients can
       subscribe.

       The <b>SessionNew()</b>, <b>SessionRemoved()</b>, <b>UserNew()</b>, <b>UserRemoved()</b>,
       <b>SeatNew()</b>, and <b>SeatRemoved() </b>signals are sent each time a session
       is created or removed, a user logs in or out, or a seat is added
       or removed. They each contain the ID of the object plus the
       object path.

       The <b>PrepareForShutdown()</b>, <b>PrepareForShutdownWithMetadata()</b>, and
       <b>PrepareForSleep() </b>signals are sent right before (with the
       argument "true") or after (with the argument "false") the system
       goes down for reboot/poweroff and suspend/hibernate,
       respectively. This may be used by applications to save data on
       disk, release memory, or do other jobs that should be done
       shortly before shutdown/sleep, in conjunction with delay
       inhibitor locks. After completion of this work they should
       release their inhibition locks in order to not delay the
       operation any further. For more information see <b>Inhibitor</b>
       <b>Locks</b>[2]. The <b>PrepareForShutdownWithMetadata() </b>signal
       additionally sends a list of key/value pair metadata fields.
       Currently it sends a <i>type</i> string which defines the type of
       shutdown. The type can be one of "power-off", "reboot", "halt",
       "kexec" or "soft-reboot". This signal is sent first, followed by
       <b>PrepareForShutdown() </b>(for backward compatibility).

   <b>Properties</b>
       Most properties simply reflect the configuration, see
       <a href="logind.conf.5.html">logind.conf(5)</a>. This includes: <i>NAutoVTs</i>, <i>KillOnlyUsers</i>,
       <i>KillExcludeUsers</i>, <i>KillUserProcesses</i>, <i>IdleAction</i>,
       <i>InhibitDelayMaxUSec</i>, <i>InhibitorsMax</i>, <i>UserStopDelayUSec</i>,
       <i>HandlePowerKey</i>, <i>HandleSuspendKey</i>, <i>HandleHibernateKey</i>,
       <i>HandleLidSwitch</i>, <i>HandleLidSwitchExternalPower</i>,
       <i>HandleLidSwitchDocked</i>, <i>IdleActionUSec</i>, <i>HoldoffTimeoutUSec</i>,
       <i>RemoveIPC</i>, <i>RuntimeDirectorySize</i>, <i>RuntimeDirectoryInodesMax</i>,
       <i>InhibitorsMax</i>, and <i>SessionsMax</i>.

       The <i>IdleHint</i> property reflects the idle hint state of the system.
       If the system is idle it might get into automatic suspend or
       shutdown depending on the configuration.

       <i>IdleSinceHint</i> and <i>IdleSinceHintMonotonic</i> encode the timestamps of
       the last change of the idle hint boolean, in <b>CLOCK_REALTIME </b>and
       <b>CLOCK_MONOTONIC </b>timestamps, respectively, in microseconds since
       the epoch.

       The <i>BlockInhibited</i> and <i>DelayInhibited</i> properties encode the
       currently active locks of the respective modes. They are colon
       separated lists of "shutdown", "sleep", and "idle" (see above).

       <i>NCurrentSessions</i> and <i>NCurrentInhibitors</i> contain the number of
       currently registered sessions and inhibitors.

       The <i>BootLoaderEntries</i> property contains a list of boot loader
       entries. This includes boot loader entries defined in
       configuration and any additional loader entries reported by the
       boot loader. See <a href="../man7/systemd-boot.7.html">systemd-boot(7)</a> for more information.

       The <i>PreparingForShutdown</i> and <i>PreparingForSleep</i> boolean properties
       are true during the interval between the two <b>PrepareForShutdown()</b>
       and <b>PrepareForSleep() </b>signals respectively. Note that these
       properties do not send out <b>PropertyChanged </b>signals.

       The <i>RebootParameter</i> property shows the value set with the
       <b>SetRebootParameter() </b>method described above.

       <i>ScheduledShutdown</i> shows the value pair set with the
       <b>ScheduleShutdown() </b>method described above.

       <i>RebootToFirmwareSetup</i>, <i>RebootToBootLoaderMenu</i>, and
       <i>RebootToBootLoaderEntry</i> are true when the resprective post-reboot
       operation was selected with <b>SetRebootToFirmwareSetup()</b>,
       <b>SetRebootToBootLoaderMenu()</b>, or <b>SetRebootToBootLoaderEntry()</b>.

       The <i>WallMessage</i> and <i>EnableWallMessages</i> properties reflect the
       shutdown reason and wall message enablement switch which can be
       set with the <b>SetWallMessage() </b>method described above.

       <i>Docked</i> is true if the machine is connected to a dock.  <i>LidClosed</i>
       is true when the lid (of a laptop) is closed.  <i>OnExternalPower</i> is
       true when the machine is connected to an external power supply.

   <b>Security</b>
       A number of operations are protected via the polkit privilege
       system.  <b>SetUserLinger() </b>requires the
       org.freedesktop.login1.set-user-linger privilege.  <b>AttachDevice()</b>
       requires org.freedesktop.login1.attach-device and <b>FlushDevices()</b>
       requires org.freedesktop.login1.flush-devices.  <b>PowerOff()</b>,
       <b>Reboot()</b>, <b>Halt()</b>, <b>Suspend()</b>, <b>Hibernate() </b>require
       org.freedesktop.login1.power-off,
       org.freedesktop.login1.power-off-multiple-sessions,
       org.freedesktop.login1.power-off-ignore-inhibit,
       org.freedesktop.login1.reboot,
       org.freedesktop.login1.reboot-multiple-sessions,
       org.freedesktop.login1.reboot-ignore-inhibit,
       org.freedesktop.login1.halt,
       org.freedesktop.login1.halt-multiple-sessions,
       org.freedesktop.login1.halt-ignore-inhibit,
       org.freedesktop.login1.suspend,
       org.freedesktop.login1.suspend-multiple-sessions,
       org.freedesktop.login1.suspend-ignore-inhibit,
       org.freedesktop.login1.hibernate,
       org.freedesktop.login1.hibernate-multiple-sessions,
       org.freedesktop.login1.hibernate-ignore-inhibit, respectively
       depending on whether there are other sessions around or active
       inhibits are present.  <b>HybridSleep() </b>and <b>SuspendThenHibernate()</b>
       use the same privileges as <b>Hibernate()</b>.  <b>Sleep() </b>uses the
       inhibits of the auto-selected sleep operation.
       <b>SetRebootParameter() </b>requires
       org.freedesktop.login1.set-reboot-parameter.

       <b>SetRebootToFirmwareSetup() </b>requires
       org.freedesktop.login1.set-reboot-to-firmware-setup.
       <b>SetRebootToBootLoaderMenu() </b>requires
       org.freedesktop.login1.set-reboot-to-boot-loader-menu.
       <b>SetRebootToBootLoaderEntry() </b>requires
       org.freedesktop.login1.set-reboot-to-boot-loader-entry.

       <b>ScheduleShutdown() </b>and <b>CancelScheduledShutdown() </b>require the same
       privileges (listed above) as the immediate poweroff/reboot/halt
       operations.

       <b>Inhibit() </b>is protected via one of
       org.freedesktop.login1.inhibit-block-shutdown,
       org.freedesktop.login1.inhibit-delay-shutdown,
       org.freedesktop.login1.inhibit-block-sleep,
       org.freedesktop.login1.inhibit-delay-sleep,
       org.freedesktop.login1.inhibit-block-idle,
       org.freedesktop.login1.inhibit-handle-power-key,
       org.freedesktop.login1.inhibit-handle-suspend-key,
       org.freedesktop.login1.inhibit-handle-hibernate-key,
       org.freedesktop.login1.inhibit-handle-lid-switch depending on the
       lock type and mode taken.

       The <i>interactive</i> boolean parameters can be used to control whether
       polkit should interactively ask the user for authentication
       credentials if required.
</pre> <h2>
SEAT OBJECTS </h2>
<pre>
           node /org/freedesktop/login1/seat/seat0 {
             interface org.freedesktop.login1.Seat {
               methods:
                 Terminate();
                 ActivateSession(in  s session_id);
                 SwitchTo(in  u vtnr);
                 SwitchToNext();
                 SwitchToPrevious();
               properties:
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Id = '...';
                 readonly (so) ActiveSession = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly b CanTTY = ...;
                 readonly b CanGraphical = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly a(so) Sessions = [...];
                 readonly b IdleHint = ...;
                 readonly t IdleSinceHint = ...;
                 readonly t IdleSinceHintMonotonic = ...;
             };
             interface org.freedesktop.DBus.Peer { ... };
             interface org.freedesktop.DBus.Introspectable { ... };
             interface org.freedesktop.DBus.Properties { ... };
           };

   <b>Methods</b>
       <b>Terminate() </b>and <b>ActivateSession() </b>work similarly to
       <b>TerminateSeat() </b>and <b>ActivationSessionOnSeat() </b>on the Manager
       object.

       <b>SwitchTo() </b>switches to the session on the virtual terminal <i>vtnr</i>.
       <b>SwitchToNext() </b>and <b>SwitchToPrevious() </b>switch to, respectively,
       the next and previous sessions on the seat in the order of
       virtual terminals. If there is no active session, they switch to,
       respectively, the first and last session on the seat.

   <b>Signals</b>
       Whenever <b>ActiveSession</b>, <b>Sessions</b>, <b>CanGraphical</b>, <b>CanTTY</b>, or the
       idle state changes, <b>PropertyChanged </b>signals are sent out to which
       clients can subscribe.

   <b>Properties</b>
       The <i>Id</i> property encodes the ID of the seat.

       <i>ActiveSession</i> encodes the currently active session if there is
       one. It is a structure consisting of the session id and the
       object path.

       <i>CanTTY</i> encodes whether the session is suitable for text logins,
       and <i>CanGraphical</i> whether it is suitable for graphical sessions.

       The <i>Sessions</i> property is an array of all current sessions of this
       seat, each encoded in a structure consisting of the ID and the
       object path.

       The <i>IdleHint</i>, <i>IdleSinceHint</i>, and <i>IdleSinceHintMonotonic</i>
       properties encode the idle state, similarly to the ones exposed
       on the Manager object, but specific for this seat.
</pre> <h2>
USER OBJECTS </h2>
<pre>
           node /org/freedesktop/login1/user/_1000 {
             interface org.freedesktop.login1.User {
               methods:
                 Terminate();
                 Kill(in  i signal_number);
               properties:
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u UID = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u GID = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Name = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t Timestamp = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t TimestampMonotonic = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s RuntimePath = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Service = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Slice = '...';
                 readonly (so) Display = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly s State = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly a(so) Sessions = [...];
                 readonly b IdleHint = ...;
                 readonly t IdleSinceHint = ...;
                 readonly t IdleSinceHintMonotonic = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b Linger = ...;
             };
             interface org.freedesktop.DBus.Peer { ... };
             interface org.freedesktop.DBus.Introspectable { ... };
             interface org.freedesktop.DBus.Properties { ... };
           };

   <b>Methods</b>
       <b>Terminate() </b>and <b>Kill() </b>work similarly to the <b>TerminateUser() </b>and
       <b>KillUser() </b>methods on the manager object.

   <b>Signals</b>
       Whenever <i>Sessions</i> or the idle state changes, <b>PropertyChanged</b>
       signals are sent out to which clients can subscribe.

   <b>Properties</b>
       The <i>UID</i> and <i>GID</i> properties encode the Unix UID and primary GID of
       the user.

       The <i>Name</i> property encodes the user name.

       <i>Timestamp</i> and <i>TimestampMonotonic</i> encode the login time of the
       user in microseconds since the epoch, in the <b>CLOCK_REALTIME </b>and
       <b>CLOCK_MONOTONIC </b>clocks, respectively.

       <i>RuntimePath</i> encodes the runtime path of the user, i.e.
       <i>$XDG_RUNTIME_DIR</i>. For details see the <b>XDG Basedir</b>
       <b>Specification</b>[3].

       <i>Service</i> contains the unit name of the user systemd service of
       this user. Each logged in user is assigned a user service that
       runs a user systemd instance. This is usually an instance of
       user@.service.

       <i>Slice</i> contains the unit name of the user systemd slice of this
       user. Each logged in user gets a private slice.

       <i>Display</i> encodes which graphical session should be used as the
       primary UI display for the user. It is a structure encoding the
       session ID and the object path of the session to use.

       <i>State</i> encodes the user state and is one of "offline",
       "lingering", "online", "active", or "closing". See
       <a href="../man3/sd_uid_get_state.3.html">sd_uid_get_state(3)</a> for more information about the states.

       <i>Sessions</i> is an array of structures encoding all current sessions
       of the user. Each structure consists of the ID and object path.

       The <i>IdleHint</i>, <i>IdleSinceHint</i>, and <i>IdleSinceHintMonotonic</i>
       properties encode the idle hint state of the user, similarly to
       the Manager's properties, but specific for this user.

       The <i>Linger</i> property shows whether lingering is enabled for this
       user.
</pre> <h2>
SESSION OBJECTS </h2>
<pre>
           node /org/freedesktop/login1/session/1 {
             interface org.freedesktop.login1.Session {
               methods:
                 Terminate();
                 Activate();
                 Lock();
                 Unlock();
                 SetIdleHint(in  b idle);
                 SetLockedHint(in  b locked);
                 Kill(in  s who,
                      in  i signal_number);
                 TakeControl(in  b force);
                 ReleaseControl();
                 SetType(in  s type);
                 SetClass(in  s class);
                 SetDisplay(in  s display);
                 SetTTY(in  h tty_fd);
                 TakeDevice(in  u major,
                            in  u minor,
                            out h fd,
                            out b inactive);
                 ReleaseDevice(in  u major,
                               in  u minor);
                 PauseDeviceComplete(in  u major,
                                     in  u minor);
                 SetBrightness(in  s subsystem,
                               in  s name,
                               in  u brightness);
               signals:
                 PauseDevice(u major,
                             u minor,
                             s type);
                 ResumeDevice(u major,
                              u minor,
                              h fd);
                 Lock();
                 Unlock();
               properties:
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Id = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly (uo) User = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Name = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t Timestamp = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t TimestampMonotonic = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u VTNr = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly (so) Seat = ...;
                 readonly s TTY = '...';
                 readonly s Display = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly b Remote = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s RemoteHost = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s RemoteUser = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Service = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Desktop = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Scope = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u Leader = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u Audit = ...;
                 readonly s Type = '...';
                 readonly s Class = '...';
                 readonly b Active = ...;
                 readonly s State = '...';
                 readonly b IdleHint = ...;
                 readonly t IdleSinceHint = ...;
                 readonly t IdleSinceHintMonotonic = ...;
                 readonly b LockedHint = ...;
             };
             interface org.freedesktop.DBus.Peer { ... };
             interface org.freedesktop.DBus.Introspectable { ... };
             interface org.freedesktop.DBus.Properties { ... };
           };

   <b>Methods</b>
       <b>Terminate()</b>, <b>Activate()</b>, <b>Lock()</b>, <b>Unlock()</b>, and <b>Kill() </b>work
       similarly to the respective calls on the Manager object.

       <b>SetIdleHint() </b>is called by the session object to update the idle
       state of the session whenever it changes.

       <b>TakeControl() </b>allows a process to take exclusive managed device
       access-control for that session. Only one D-Bus connection can be
       a controller for a given session at any time. If the <i>force</i>
       argument is set (root only), an existing controller is kicked out
       and replaced. Otherwise, this method fails if there is already a
       controller. Note that this method is limited to D-Bus users with
       the effective UID set to the user of the session or root.

       <b>ReleaseControl() </b>drops control of a given session. Closing the
       D-Bus connection implicitly releases control as well. See
       <b>TakeControl() </b>for more information. This method also releases all
       devices for which the controller requested ownership via
       <b>TakeDevice()</b>.

       <b>SetType() </b>allows the type of the session to be changed
       dynamically. It can only be called by session's current
       controller. If <b>TakeControl() </b>has not been called, this method
       will fail. In addition, the session type will be reset to its
       original value once control is released, either by calling
       <b>ReleaseControl() </b>or closing the D-Bus connection. This should
       help prevent a session from entering an inconsistent state, for
       example if the controller crashes. The only argument <i>type</i> is the
       new session type.

       <b>SetClass() </b>allows the caller to change the class of the session
       dynamically. It may only be called by session's owening user.
       Currently, this call may be exclusively used to change the class
       from "user-incomplete" to "user". The call is synchronous, and
       will return only once the user's service manager has successfully
       been started, if necessary. The only argument <i>type</i> is the new
       session type.

       <b>SetDisplay() </b>allows the display name of the graphical session to
       be changed. This is useful if the display server is started as
       part of the session. It can only be called by session's current
       controller. If <b>TakeControl() </b>has not been called, this method
       will fail. The only argument <i>display</i> is the new display name.

       <b>SetTTY() </b>allows the device name of the session to be changed.
       This is useful if the tty device is only known after
       authentication. It can only be called by session's current
       controller. If <b>TakeControl() </b>has not been called, this method
       will fail. The only argument <i>tty_fd</i> is a file handle to the new
       tty device.

       <b>TakeDevice() </b>allows a session controller to get a file descriptor
       for a specific device. Pass in the major and minor numbers of the
       character device and systemd-logind will return a file descriptor
       for the device. Only a limited set of device-types is currently
       supported (but may be extended).  systemd-logind automatically
       mutes the file descriptor if the session is inactive and resumes
       it once the session is activated again. This guarantees that a
       session can only access session devices if the session is active.
       Note that this revoke/resume mechanism is asynchronous and may
       happen at any given time. This only works on devices that are
       attached to the seat of the given session. A process is not
       required to have direct access to the device node.
       systemd-logind only requires you to be the active session
       controller (see <b>TakeControl()</b>). Also note that any device can
       only be requested once. As long as you don't release it, further
       <b>TakeDevice() </b>calls will fail.

       <b>ReleaseDevice() </b>releases a device again (see <b>TakeDevice()</b>). This
       is also implicitly done by <b>ReleaseControl() </b>or when closing the
       D-Bus connection.

       <b>PauseDeviceComplete() </b>allows a session controller to
       synchronously pause a device after receiving a
       <b>PauseDevice("pause") </b>signal. Forced signals (or after an internal
       timeout) are automatically completed by systemd-logind
       asynchronously.

       <b>SetLockedHint() </b>may be used to set the "locked hint" to <i>locked</i>,
       i.e. information whether the session is locked. This is intended
       to be used by the desktop environment to tell <b>systemd-logind </b>when
       the session is locked and unlocked.

       <b>SetBrightness() </b>may be used to set the display brightness. This
       is intended to be used by the desktop environment and allows
       unprivileged programs to access hardware settings in a controlled
       way. The <i>subsystem</i> parameter specifies a kernel subsystem, either
       "backlight" or "leds". The <i>name</i> parameter specifies a device name
       under the specified subsystem. The <i>brightness</i> parameter specifies
       the brightness. The range is defined by individual drivers, see
       /sys/class/<i>subsystem</i>/<i>name</i>/max_brightness.

   <b>Signals</b>
       The active session controller exclusively gets <b>PauseDevice() </b>and
       <b>ResumeDevice() </b>events for any device it requested via
       <b>TakeDevice()</b>. They notify the controller whenever a device is
       paused or resumed. A device is never resumed if its session is
       inactive. Also note that <b>PauseDevice() </b>signals are sent before
       the <b>PropertyChanged </b>signal for the <b>Active </b>state. The inverse is
       true for <b>ResumeDevice()</b>. A device may remain paused for unknown
       reasons even though the Session is active.

       A <b>PauseDevice() </b>signal carries the major and minor numbers and a
       string describing the type as arguments.  <b>force </b>means the device
       was already paused by systemd-logind and the signal is only an
       asynchronous notification.  <b>pause </b>means systemd-logind grants you
       a limited amount of time to pause the device. You must respond to
       this via <b>PauseDeviceComplete()</b>. This synchronous pausing
       mechanism is used for backwards-compatibility to VTs and
       systemd-logind is free to not make use of it. It is also free to
       send a forced <b>PauseDevice() </b>if you don't respond in a timely
       manner (or for any other reason).  <b>gone </b>means the device was
       unplugged from the system and you will no longer get any
       notifications about it. There is no need to call <b>ReleaseDevice()</b>.
       You may call <b>TakeDevice() </b>again if a new device is assigned the
       major+minor combination.

       <b>ResumeDevice() </b>is sent whenever a session is active and a device
       is resumed. It carries the major/minor numbers as arguments and
       provides a new open file descriptor. You should switch to the new
       descriptor and close the old one. They are not guaranteed to have
       the same underlying open file descriptor in the kernel (except
       for a limited set of device types).

       Whenever <b>Active </b>or the idle state changes, <b>PropertyChanged</b>
       signals are sent out to which clients can subscribe.

       <b>Lock()</b>/<b>Unlock() </b>is sent when the session is asked to be
       screen-locked/unlocked. A session manager of the session should
       listen to this signal and act accordingly. This signal is sent
       out as a result of the <b>Lock() </b>and <b>Unlock() </b>methods, respectively.

   <b>Properties</b>
       <i>Id</i> encodes the session ID.

       <i>User</i> encodes the user ID of the user this session belongs to.
       This is a structure consisting of the Unix UID and the object
       path.

       <i>Name</i> encodes the user name.

       <i>Timestamp</i> and <i>TimestampMonotonic</i> encode the microseconds since
       the epoch when the session was created, in <b>CLOCK_REALTIME </b>or
       <b>CLOCK_MONOTONIC</b>, respectively.

       <i>VTNr</i> encodes the virtual terminal number of the session if there
       is any, 0 otherwise.

       <i>Seat</i> encodes the seat this session belongs to if there is any.
       This is a structure consisting of the ID and the seat object
       path.

       <i>TTY</i> encodes the kernel TTY path of the session if this is a text
       login. If not this is an empty string.

       <i>Display</i> encodes the X11 display name if this is a graphical
       login. If not, this is an empty string.

       <i>Remote</i> encodes whether the session is local or remote.

       <i>RemoteHost</i> and <i>RemoteUser</i> encode the remote host and user if this
       is a remote session, or an empty string otherwise.

       <i>Service</i> encodes the PAM service name that registered the session.

       <i>Desktop</i> describes the desktop environment running in the session
       (if known).

       <i>Scope</i> contains the systemd scope unit name of this session.

       <i>Leader</i> encodes the PID of the process that registered the
       session.

       <i>Audit</i> encodes the Kernel Audit session ID of the session if
       auditing is available.

       <i>Type</i> encodes the session type. It's one of "unspecified" (for
       cron PAM sessions and suchlike), "tty" (for text logins) or
       "x11"/"mir"/"wayland" (for graphical logins).

       <i>Class</i> encodes the session class. It's one of "user" (for normal
       user sessions), "greeter" (for display manager pseudo-sessions),
       or "lock-screen" (for display lock screens).

       <i>Active</i> is a boolean that is true if the session is active, i.e.
       currently in the foreground. This field is semi-redundant due to
       <i>State</i>.

       <i>State</i> encodes the session state and one of "online", "active", or
       "closing". See <a href="../man3/sd_session_get_state.3.html">sd_session_get_state(3)</a> for more information about
       the states.

       <i>IdleHint</i>, <i>IdleSinceHint</i>, and <i>IdleSinceHintMonotonic</i> encapsulate
       the idle hint state of this session, similarly to how the
       respective properties on the manager object do it for the whole
       system.

       <i>LockedHint</i> shows the locked hint state of this session, as set by
       the <b>SetLockedHint() </b>method described above.
</pre> <h2>
EXAMPLES </h2>
<pre>
       <b>Example 1. Introspect the logind manager on the bus</b>

           $ gdbus introspect --system --dest org.freedesktop.login1 \
             --object-path /org/freedesktop/login1

       or

           $ busctl introspect org.freedesktop.login1 /org/freedesktop/login1

       <b>Example 2. Introspect the default seat on the bus</b>

           $ gdbus introspect --system --dest org.freedesktop.login1 \
            --object-path /org/freedesktop/login1/seat/seat0

       or

           $ busctl introspect org.freedesktop.login1 /org/freedesktop/login1/seat/seat0

       Seat "seat0" is the default seat, so it'll be present unless
       local configuration is made to reassign all devices to a
       different seat. The list of seats and users can be acquired with
       <b>loginctl list-sessions</b>.

       <b>Example 3. Introspect a single user on the bus</b>

           $ gdbus introspect --system --dest org.freedesktop.login1 \
             --object-path /org/freedesktop/login1/user/_1000

       or

           $ busctl introspect org.freedesktop.login1 /org/freedesktop/login1/user/_1000

       <b>Example 4. Introspect org.freedesktop.login1.Session on the bus</b>

           $ gdbus introspect --system --dest org.freedesktop.login1 \
             --object-path /org/freedesktop/login1/session/45

       or

           $ busctl introspect org.freedesktop.login1 /org/freedesktop/login1/session/45
</pre> <h2>
VERSIONING </h2>
<pre>
       These D-Bus interfaces follow <b>the usual interface versioning</b>
       <b>guidelines</b>[4].
</pre> <h2>
HISTORY </h2>
<pre>
   <b>The Manager Object</b>
       <i>HandlePowerKeyLongPress</i>, <i>HandleRebootKey</i>,
       <i>HandleRebootKeyLongPress</i>, <i>HandleSuspendKeyLongPress</i>, and
       <i>HandleHibernateKeyLongPress</i> were added in version 251.

       <i>StopIdleSessionUSec</i> was added in version 252.

       <b>PrepareForShutdownWithMetadata() </b>and <b>CreateSessionWithPIDFD()</b>
       were added in version 255.

       <b>Sleep()</b>, <b>CanSleep()</b>, <i>SleepOperation</i>, and <b>ListSessionsEx() </b>were
       added in version 256.

   <b>Session Objects</b>
       <b>SetDisplay() </b>was added in version 252.

       <b>SetTTY() </b>was added in version 254.

       <b>SetClass() </b>was added in version 256.
</pre> <h2>
NOTES </h2>
<pre>
        1. polkit
           <a href="https://www.freedesktop.org/software/polkit/docs/latest/">https://www.freedesktop.org/software/polkit/docs/latest/</a>

        2. Inhibitor Locks
           <a href="https://systemd.io/INHIBITOR_LOCKS">https://systemd.io/INHIBITOR_LOCKS</a>

        3. XDG Basedir Specification
           <a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html</a>

        4. the usual interface versioning guidelines
           <a href="https://0pointer.de/blog/projects/versioning-dbus.html">https://0pointer.de/blog/projects/versioning-dbus.html</a>
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>systemd</i> (systemd system and service
       manager) project.  Information about the project can be found at
       âŸ¨<a href="http://www.freedesktop.org/wiki/Software/systemd">http://www.freedesktop.org/wiki/Software/systemd</a>âŸ©.  If you have
       a bug report for this manual page, see
       âŸ¨<a href="http://www.freedesktop.org/wiki/Software/systemd/#bugreports">http://www.freedesktop.org/wiki/Software/systemd/#bugreports</a>âŸ©.
       This page was obtained from the project's upstream Git repository
       âŸ¨<a href="https://github.com/systemd/systemd.git">https://github.com/systemd/systemd.git</a>âŸ© on 2024-06-14.  (At that
       time, the date of the most recent commit that was found in the
       repository was 2024-06-13.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">systemd 257~devel                               <i>ORG.FREED...OP.LOGIN1</i>(5)</span>
</pre>  <p>Pages that refer to this page: <a href="org.freedesktop.systemd1.5.html">org.freedesktop.systemd1(5)</a>, <a href="../man7/systemd.directives.7.html">systemd.directives(7)</a>, <a href="../man7/systemd.index.7.html">systemd.index(7)</a>, <a href="../man7/systemd.offline-updates.7.html">systemd.offline-updates(7)</a>, <a href="../man8/systemd-logind.service.8.html">systemd-logind.service(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man5/org.freedesktop.login1.5.html" class="_attribution-link">https://man7.org/linux/man-pages/man5/org.freedesktop.login1.5.html</a>
  </p>
</div>
