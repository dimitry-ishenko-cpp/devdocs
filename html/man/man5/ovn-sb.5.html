<h1>ovn-sb(5) — Linux manual page</h1>   <pre>
<span class="headline"><i>ovn-sb</i>(5)                  Open vSwitch Manual                 <i>ovn-sb</i>(5)</span>
</pre> <h2>
NAME </h2>
<pre>
       ovn-sb - OVN_Southbound database schema

       This database holds logical and physical configuration and state
       for the Open Virtual Network (OVN) system to support virtual
       network abstraction. For an introduction to OVN, please see
       <a href="../man7/ovn-architecture.7.html">ovn-architecture(7)</a>.

       The OVN Southbound database sits at the center of the OVN
       architecture. It is the one component that speaks both southbound
       directly to all the hypervisors and gateways, via
       <b>ovn-controller</b>/<b>ovn-controller-vtep</b>, and northbound to the Cloud
       Management System, via <b>ovn-northd</b>:

   <b>Database Structure</b>
       The OVN Southbound database contains classes of data with
       different properties, as described in the sections below.

     <i>Physical network</i>

       Physical network tables contain information about the chassis
       nodes in the system. This contains all the information necessary
       to wire the overlay, such as IP addresses, supported tunnel
       types, and security keys.

       The amount of physical network data is small (O(n) in the number
       of chassis) and it changes infrequently, so it can be replicated
       to every chassis.

       The <b>Chassis </b>and <b>Encap </b>tables are the physical network tables.

     <i>Logical Network</i>

       Logical network tables contain the topology of logical switches
       and routers, ACLs, firewall rules, and everything needed to
       describe how packets traverse a logical network, represented as
       logical datapath flows (see Logical Datapath Flows, below).

       Logical network data may be large (O(n) in the number of logical
       ports, ACL rules, etc.). Thus, to improve scaling, each chassis
       should receive only data related to logical networks in which
       that chassis participates.

       The logical network data is ultimately controlled by the cloud
       management system (CMS) running northbound of OVN. That CMS
       determines the entire OVN logical configuration and therefore the
       logical network data at any given time is a deterministic
       function of the CMS’s configuration, although that happens
       indirectly via the <b>OVN_Northbound </b>database and <b>ovn-northd</b>.

       Logical network data is likely to change more quickly than
       physical network data. This is especially true in a container
       environment where containers are created and destroyed (and
       therefore added to and deleted from logical switches) quickly.

       The <b>Logical_Flow</b>, <b>Multicast_Group</b>, <b>Address_Group</b>, <b>DHCP_Options</b>,
       <b>DHCPv6_Options</b>, and <b>DNS </b>tables contain logical network data.

     <i>Logical-physical bindings</i>

       These tables link logical and physical components. They show the
       current placement of logical components (such as VMs and VIFs)
       onto chassis, and map logical entities to the values that
       represent them in tunnel encapsulations.

       These tables change frequently, at least every time a VM powers
       up or down or migrates, and especially quickly in a container
       environment. The amount of data per VM (or VIF) is small.

       Each chassis is authoritative about the VMs and VIFs that it
       hosts at any given time and can efficiently flood that state to a
       central location, so the consistency needs are minimal.

       The <b>Port_Binding </b>and <b>Datapath_Binding </b>tables contain binding
       data.

     <i>MAC bindings</i>

       The <b>MAC_Binding </b>table tracks the bindings from IP addresses to
       Ethernet addresses that are dynamically discovered using ARP (for
       IPv4) and neighbor discovery (for IPv6). Usually, IP-to-MAC
       bindings for virtual machines are statically populated into the
       <b>Port_Binding </b>table, so <b>MAC_Binding </b>is primarily used to discover
       bindings on physical networks.

   <b>Common Columns</b>
       Some tables contain a special column named <b>external_ids</b>. This
       column has the same form and purpose each place that it appears,
       so we describe it here to save space later.

              <b>external_ids</b>: map of string-string pairs
                     Key-value pairs for use by the software that
                     manages the OVN Southbound database rather than by
                     <b>ovn-controller</b>/<b>ovn-controller-vtep</b>. In particular,
                     <b>ovn-northd </b>can use key-value pairs in this column
                     to relate entities in the southbound database to
                     higher-level entities (such as entities in the OVN
                     Northbound database). Individual key-value pairs in
                     this column may be documented in some cases to aid
                     in understanding and troubleshooting, but the
                     reader should not mistake such documentation as
                     comprehensive.
</pre> <h2>
TABLE SUMMARY </h2>
<pre>
       The following list summarizes the purpose of each of the tables
       in the <b>OVN_Southbound </b>database.  Each table is described in more
       detail on a later page.

       Table     Purpose
       <b>SB_Global </b>Southbound configuration
       <b>Chassis   </b>Physical Network Hypervisor and Gateway Information
       <b>Chassis_Private</b>
                 Chassis Private
       <b>Encap     </b>Encapsulation Types
       <b>Address_Set</b>
                 Address Sets
       <b>Port_Group</b>
                 Port Groups
       <b>Logical_Flow</b>
                 Logical Network Flows
       <b>Logical_DP_Group</b>
                 Logical Datapath Groups
       <b>Multicast_Group</b>
                 Logical Port Multicast Groups
       <b>Mirror    </b>Mirror Entry
       <b>Meter     </b>Meter entry
       <b>Meter_Band</b>
                 Band for meter entries
       <b>Datapath_Binding</b>
                 Physical-Logical Datapath Bindings
       <b>Port_Binding</b>
                 Physical-Logical Port Bindings
       <b>MAC_Binding</b>
                 IP to MAC bindings
       <b>DHCP_Options</b>
                 DHCP Options supported by native OVN DHCP
       <b>DHCPv6_Options</b>
                 DHCPv6 Options supported by native OVN DHCPv6
       <b>Connection</b>
                 OVSDB client connections.
       <b>SSL       </b>SSL configuration.
       <b>DNS       </b>Native DNS resolution
       <b>RBAC_Role </b>RBAC_Role configuration.
       <b>RBAC_Permission</b>
                 RBAC_Permission configuration.
       <b>Gateway_Chassis</b>
                 Gateway_Chassis configuration.
       <b>HA_Chassis</b>
                 HA_Chassis configuration.
       <b>HA_Chassis_Group</b>
                 HA_Chassis_Group configuration.
       <b>Controller_Event</b>
                 Controller Event table
       <b>IP_Multicast</b>
                 IP_Multicast configuration.
       <b>IGMP_Group</b>
                 IGMP_Group configuration.
       <b>Service_Monitor</b>
                 Service_Monitor configuration.
       <b>Load_Balancer</b>
                 Load_Balancer configuration.
       <b>BFD       </b>BFD configuration.
       <b>FDB       </b>Port to MAC bindings
       <b>Static_MAC_Binding</b>
                 IP to MAC bindings
       <b>Chassis_Template_Var</b>
                 Chassis_Template_Var configuration.
</pre> <h2>
SB_Global TABLE </h2>
<pre>
       Southbound configuration for an OVN system. This table must have
       exactly one row.

   <b>Summary:</b>
       <i>Status:</i>
         <b>nb_cfg                      </b>integer
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs
         <b>options                     </b>map of string-string pairs
       <i>Common options:</i>
         <b>options                     </b>map of string-string pairs
         <i>Options for configuring BFD:</i>
            <b>options : bfd-min-rx     </b>optional string
            <b>options : bfd-decay-min-rx</b>
                                     optional string
            <b>options : bfd-min-tx     </b>optional string
            <b>options : bfd-mult       </b>optional string
            <b>options : debug_drop_domain_id</b>
                                     optional string
            <b>options : debug_drop_collector_set</b>
                                     optional string
         <i>Options for configuring Load Balancers:</i>
            <b>options : lb_hairpin_use_ct_mark</b>
                                     optional string
         <i>Options for configuring ovn-sbctl:</i>
            <b>options : sbctl_probe_interval</b>
                                     optional string
       <i>Connection Options:</i>
         <b>connections                 </b>set of <b>Connection</b>s
         <b>ssl                         </b>optional <b>SSL</b>
       <i>Security Configurations:</i>
         <b>ipsec                       </b>boolean

   <b>Details:</b>
     <i>Status:</i>

       This column allow a client to track the overall configuration
       state of the system.

       <b>nb_cfg</b>: integer
              Sequence number for the configuration. When a CMS or
              <b>ovn-nbctl </b>updates the northbound database, it increments
              the <b>nb_cfg </b>column in the <b>NB_Global </b>table in the northbound
              database. In turn, when <b>ovn-northd </b>updates the southbound
              database to bring it up to date with these changes, it
              updates this column to the same value.

     <i>Common Columns:</i>

       <b>external_ids</b>: map of string-string pairs
              See <b>External IDs </b>at the beginning of this document.

       <b>options</b>: map of string-string pairs

     <i>Common options:</i>

       <b>options</b>: map of string-string pairs
              This column provides general key/value settings. The
              supported options are described individually below.

     <i>Options for configuring BFD:</i>

       These options apply when <b>ovn-controller </b>configures BFD on tunnels
       interfaces.

       <b>options : bfd-min-rx</b>: optional string
              BFD option <b>min-rx </b>value to use when configuring BFD on
              tunnel interfaces.

       <b>options : bfd-decay-min-rx</b>: optional string
              BFD option <b>decay-min-rx </b>value to use when configuring BFD
              on tunnel interfaces.

       <b>options : bfd-min-tx</b>: optional string
              BFD option <b>min-tx </b>value to use when configuring BFD on
              tunnel interfaces.

       <b>options : bfd-mult</b>: optional string
              BFD option <b>mult </b>value to use when configuring BFD on
              tunnel interfaces.

       <b>options : debug_drop_domain_id</b>: optional string
              If set to a 8-bit number and if <b>debug_drop_collector_set</b>
              is also configured, <b>ovn-controller </b>will add a <b>sample</b>
              action to every flow that does not come from a logical
              flow that contains a ’drop’ action. The 8 most significant
              bits of the observation_domain_id field will be those
              specified in the  <b>debug_drop_domain_id</b>. The 24 least
              significant bits of the observation_domain_id field will
              be zero.

              The observation_point_id will be set to the OpenFlow table
              number.

       <b>options : debug_drop_collector_set</b>: optional string
              If set to a 32-bit number <b>ovn-controller </b>will add a <b>sample</b>
              action to every flow that does not come from a logical
              flow that contains a ’drop’ action. The sample action will
              have the specified collector_set_id. The value must match
              that of the local OVS configuration as described in
              <a href="../man7/ovs-actions.7.html">ovs-actions(7)</a>.

     <i>Options for configuring Load Balancers:</i>

       These options apply when <b>ovn-controller </b>configures load balancer
       related flows.

       <b>options : lb_hairpin_use_ct_mark</b>: optional string
              By default this option is turned on (even if not present
              in the database) unless its value is explicitly set to
              <b>false</b>. This value is automatically set to <b>false </b>by
              <b>ovn-northd </b>when action <b>ct_lb_mark </b>cannot be used for new
              load balancer sessions and action <b>ct_lb </b>will be used
              instead. <b>ovn-controller </b>then knows that it should check
              <b>ct_label.natted </b>to detect load balanced traffic.

     <i>Options for configuring ovn-sbctl:</i>

       These options apply when <b>ovn-sbctl </b>connects to OVN Southbound
       database.

       <b>options : sbctl_probe_interval</b>: optional string
              The inactivity probe interval of the connection to the OVN
              Southbound database from <b>ovn-sbctl </b>utility, in
              milliseconds. If the value is zero, it disables the
              connection keepalive feature.

              If the value is nonzero, then it will be forced to a value
              of at least 1000 ms.

              If the value is less than zero, then the default
              inactivity probe interval for <b>ovn-sbctl </b>would be left
              intact (120000 ms).

     <i>Connection Options:</i>

       <b>connections</b>: set of <b>Connection</b>s
              Database clients to which the Open vSwitch database server
              should connect or on which it should listen, along with
              options for how these connections should be configured.
              See the <b>Connection </b>table for more information.

       <b>ssl</b>: optional <b>SSL</b>
              Global SSL configuration.

     <i>Security Configurations:</i>

       <b>ipsec</b>: boolean
              Tunnel encryption configuration. If this column is set to
              be true, all OVN tunnels will be encrypted with IPsec.
</pre> <h2>
Chassis TABLE </h2>
<pre>
       Each row in this table represents a hypervisor or gateway (a
       chassis) in the physical network. Each chassis, via
       <b>ovn-controller</b>/<b>ovn-controller-vtep</b>, adds and updates its own row,
       and keeps a copy of the remaining rows to determine how to reach
       other hypervisors.

       When a chassis shuts down gracefully, it should remove its own
       row. (This is not critical because resources hosted on the
       chassis are equally unreachable regardless of whether the row is
       present.) If a chassis shuts down permanently without removing
       its row, some kind of manual or automatic cleanup is eventually
       needed; we can devise a process for that as necessary.

   <b>Summary:</b>
       <b>name                          </b>string (must be unique within
                                     table)
       <b>hostname                      </b>string
       <b>nb_cfg                        </b>integer
       <b>other_config : ovn-bridge-mappings</b>
                                     optional string
       <b>other_config : datapath-type  </b>optional string
       <b>other_config : iface-types    </b>optional string
       <b>other_config : ovn-cms-options</b>
                                     optional string
       <b>other_config : is-interconn   </b>optional string
       <b>other_config : is-remote      </b>optional string
       <b>transport_zones               </b>set of strings
       <b>other_config : ovn-chassis-mac-mappings</b>
                                     optional string
       <b>other_config : port-up-notif  </b>optional string
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs
       <i>Encapsulation Configuration:</i>
         <b>encaps                      </b>set of 1 or more <b>Encap</b>s
       <i>Gateway Configuration:</i>
         <b>vtep_logical_switches       </b>set of strings

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              OVN does not prescribe a particular format for chassis
              names. ovn-controller populates this column using
              <b>external_ids:system-id </b>in the Open_vSwitch database’s
              <b>Open_vSwitch </b>table. ovn-controller-vtep populates this
              column with <b>name </b>in the hardware_vtep database’s
              <b>Physical_Switch </b>table.

       <b>hostname</b>: string
              The hostname of the chassis, if applicable. ovn-controller
              will populate this column with the hostname of the host it
              is running on. ovn-controller-vtep will leave this column
              empty.

       <b>nb_cfg</b>: integer
              Deprecated. This column is replaced by the <b>nb_cfg </b>column
              of the <b>Chassis_Private </b>table.

       <b>other_config : ovn-bridge-mappings</b>: optional string
              <b>ovn-controller </b>populates this key with the set of bridge
              mappings it has been configured to use. Other applications
              should treat this key as read-only. See <a href="../man8/ovn-controller.8.html">ovn-controller(8)</a>
              for more information.

       <b>other_config : datapath-type</b>: optional string
              <b>ovn-controller </b>populates this key with the datapath type
              configured in the <b>datapath_type </b>column of the Open_vSwitch
              database’s <b>Bridge </b>table. Other applications should treat
              this key as read-only. See <a href="../man8/ovn-controller.8.html">ovn-controller(8)</a> for more
              information.

       <b>other_config : iface-types</b>: optional string
              <b>ovn-controller </b>populates this key with the interface types
              configured in the <b>iface_types </b>column of the Open_vSwitch
              database’s <b>Open_vSwitch </b>table. Other applications should
              treat this key as read-only. See <a href="../man8/ovn-controller.8.html">ovn-controller(8)</a> for
              more information.

       <b>other_config : ovn-cms-options</b>: optional string
              <b>ovn-controller </b>populates this key with the set of options
              configured in the <b>external_ids:ovn-cms-options </b>column of
              the Open_vSwitch database’s <b>Open_vSwitch </b>table. See
              <a href="../man8/ovn-controller.8.html">ovn-controller(8)</a> for more information.

       <b>other_config : is-interconn</b>: optional string
              <b>ovn-controller </b>populates this key with the setting
              configured in the <b>external_ids:ovn-is-interconn </b>column of
              the Open_vSwitch database’s <b>Open_vSwitch </b>table. If set to
              true, the chassis is used as an interconnection gateway.
              See <a href="../man8/ovn-controller.8.html">ovn-controller(8)</a> for more information.

       <b>other_config : is-remote</b>: optional string
              <b>ovn-ic </b>set this key to true for remote interconnection
              gateway chassises learned from the interconnection
              southbound database. See <a href="../man8/ovn-ic.8.html">ovn-ic(8)</a> for more information.

       <b>transport_zones</b>: set of strings
              <b>ovn-controller </b>populates this key with the transport zones
              configured in the <b>external_ids:ovn-transport-zones </b>column
              of the Open_vSwitch database’s <b>Open_vSwitch </b>table. See
              <a href="../man8/ovn-controller.8.html">ovn-controller(8)</a> for more information.

       <b>other_config : ovn-chassis-mac-mappings</b>: optional string
              <b>ovn-controller </b>populates this key with the set of options
              configured in the <b>external_ids:ovn-chassis-mac-mappings</b>
              column of the Open_vSwitch database’s <b>Open_vSwitch </b>table.
              See <a href="../man8/ovn-controller.8.html">ovn-controller(8)</a> for more information.

       <b>other_config : port-up-notif</b>: optional string
              <b>ovn-controller </b>populates this key with <b>true </b>when it
              supports <b>Port_Binding.up</b>.

     <i>Common Columns:</i>

       The overall purpose of these columns is described under <b>Common</b>
       <b>Columns </b>at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs

     <i>Encapsulation Configuration:</i>

       OVN uses encapsulation to transmit logical dataplane packets
       between chassis.

       <b>encaps</b>: set of 1 or more <b>Encap</b>s
              Points to supported encapsulation configurations to
              transmit logical dataplane packets to this chassis. Each
              entry is a <b>Encap </b>record that describes the configuration.

     <i>Gateway Configuration:</i>

       A <i>gateway</i> is a chassis that forwards traffic between the OVN-
       managed part of a logical network and a physical VLAN, extending
       a tunnel-based logical network into a physical network. Gateways
       are typically dedicated nodes that do not host VMs and will be
       controlled by <b>ovn-controller-vtep</b>.

       <b>vtep_logical_switches</b>: set of strings
              Stores all VTEP logical switch names connected by this
              gateway chassis. The <b>Port_Binding </b>table entry with
              <b>options</b>:<b>vtep-physical-switch </b>equal <b>Chassis name</b>, and
              <b>options</b>:<b>vtep-logical-switch </b>value in <b>Chassis</b>
              <b>vtep_logical_switches</b>, will be associated with this
              <b>Chassis</b>.
</pre> <h2>
Chassis_Private TABLE </h2>
<pre>
       Each row in this table maintains per chassis private data that
       are accessed only by the owning chassis (write only) and ovn-
       northd, not by any other chassis. These data are stored in this
       separate table instead of the <b>Chassis </b>table for performance
       considerations: the rows in this table can be conditionally
       monitored by chassises so that each chassis only get update
       notifications for its own row, to avoid unnecessary chassis
       private data update flooding in a large scale deployment.

   <b>Summary:</b>
       <b>name                          </b>string (must be unique within
                                     table)
       <b>chassis                       </b>optional weak reference to <b>Chassis</b>
       <b>nb_cfg                        </b>integer
       <b>nb_cfg_timestamp              </b>integer
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              The name of the chassis that owns these chassis-private
              data.

       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              The reference to <b>Chassis </b>table for the chassis that owns
              these chassis-private data.

       <b>nb_cfg</b>: integer
              Sequence number for the configuration. When <b>ovn-controller</b>
              updates the configuration of a chassis from the contents
              of the southbound database, it copies <b>nb_cfg </b>from the
              <b>SB_Global </b>table into this column.

       <b>nb_cfg_timestamp</b>: integer
              The timestamp when <b>ovn-controller </b>finishes processing the
              change corresponding to <b>nb_cfg</b>.

     <i>Common Columns:</i>

       The overall purpose of these columns is described under <b>Common</b>
       <b>Columns </b>at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs
</pre> <h2>
Encap TABLE </h2>
<pre>
       The <b>encaps </b>column in the <b>Chassis </b>table refers to rows in this
       table to identify how OVN may transmit logical dataplane packets
       to this chassis. Each chassis, via <a href="../man8/ovn-controller.8.html">ovn-controller(8)</a> or
       <a href="../man8/ovn-controller-vtep.8.html">ovn-controller-vtep(8)</a>, adds and updates its own rows and keeps a
       copy of the remaining rows to determine how to reach other
       chassis.

   <b>Summary:</b>
       <b>type                          </b>string, one of <b>geneve</b>, <b>stt</b>, or
                                     <b>vxlan</b>
       <b>options                       </b>map of string-string pairs
       <b>options : csum                </b>optional string, either <b>true </b>or
                                     <b>false</b>
       <b>options : dst_port            </b>optional string, containing an
                                     integer
       <b>ip                            </b>string
       <b>chassis_name                  </b>string

   <b>Details:</b>
       <b>type</b>: string, one of <b>geneve</b>, <b>stt</b>, or <b>vxlan</b>
              The encapsulation to use to transmit packets to this
              chassis. Hypervisors and gateways must use one of: <b>geneve</b>,
              <b>vxlan</b>, or <b>stt</b>.

       <b>options</b>: map of string-string pairs
              Options for configuring the encapsulation, which may be
              <b>type </b>specific.

       <b>options : csum</b>: optional string, either <b>true </b>or <b>false</b>
              <b>csum </b>indicates whether this chassis can transmit and
              receive packets that include checksums with reasonable
              performance. It hints to senders transmitting data to this
              chassis that they should use checksums to protect OVN
              metadata. <b>ovn-controller </b>populates this key with the value
              defined in <b>external_ids:ovn-encap-csum </b>column of the
              Open_vSwitch database’s <b>Open_vSwitch </b>table. Other
              applications should treat this key as read-only. See
              <a href="../man8/ovn-controller.8.html">ovn-controller(8)</a> for more information.

              In terms of performance, checksumming actually
              significantly increases throughput in most common cases
              when running on Linux based hosts without NICs supporting
              encapsulation hardware offload (around 60% for bulk
              traffic). The reason is that generally all NICs are
              capable of offloading transmitted and received TCP/UDP
              checksums (viewed as ordinary data packets and not as
              tunnels). The benefit comes on the receive side where the
              validated outer checksum can be used to additionally
              validate an inner checksum (such as TCP), which in turn
              allows aggregation of packets to be more efficiently
              handled by the rest of the stack.

              Not all devices see such a benefit. The most notable
              exception is hardware VTEPs. These devices are designed to
              not buffer entire packets in their switching engines and
              are therefore unable to efficiently compute or validate
              full packet checksums. In addition certain versions of the
              Linux kernel are not able to fully take advantage of
              encapsulation NIC offloads in the presence of checksums.
              (This is actually a pretty narrow corner case though:
              earlier versions of Linux don’t support encapsulation
              offloads at all and later versions support both offloads
              and checksums well.)

              <b>csum </b>defaults to <b>false </b>for hardware VTEPs and <b>true </b>for all
              other cases.

              This option applies to <b>geneve </b>and <b>vxlan </b>encapsulations.

       <b>options : dst_port</b>: optional string, containing an integer
              If set, overrides the UDP (for <b>geneve </b>and <b>vxlan</b>) or TCP
              (for <b>stt</b>) destination port.

       <b>ip</b>: string
              The IPv4 address of the encapsulation tunnel endpoint.

       <b>chassis_name</b>: string
              The name of the chassis that created this encap.
</pre> <h2>
Address_Set TABLE </h2>
<pre>
       This table contains address sets synced from the <b>Address_Set</b>
       table in the <b>OVN_Northbound </b>database and address sets generated
       from the <b>Port_Group </b>table in the <b>OVN_Northbound </b>database.

       See the documentation for the <b>Address_Set </b>table and <b>Port_Group</b>
       table in the <b>OVN_Northbound </b>database for details.

   <b>Summary:</b>
       <b>name                          </b>string (must be unique within
                                     table)
       <b>addresses                     </b>set of strings

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)

       <b>addresses</b>: set of strings
</pre> <h2>
Port_Group TABLE </h2>
<pre>
       This table contains names for the logical switch ports in the
       <b>OVN_Northbound </b>database that belongs to the same group that is
       defined in <b>Port_Group </b>in the <b>OVN_Northbound </b>database.

   <b>Summary:</b>
       <b>name                          </b>string (must be unique within
                                     table)
       <b>ports                         </b>set of strings

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)

       <b>ports</b>: set of strings
</pre> <h2>
Logical_Flow TABLE </h2>
<pre>
       Each row in this table represents one logical flow. <b>ovn-northd</b>
       populates this table with logical flows that implement the L2 and
       L3 topologies specified in the <b>OVN_Northbound </b>database. Each
       hypervisor, via <b>ovn-controller</b>, translates the logical flows into
       OpenFlow flows specific to its hypervisor and installs them into
       Open vSwitch.

       Logical flows are expressed in an OVN-specific format, described
       here. A logical datapath flow is much like an OpenFlow flow,
       except that the flows are written in terms of logical ports and
       logical datapaths instead of physical ports and physical
       datapaths. Translation between logical and physical flows helps
       to ensure isolation between logical datapaths. (The logical flow
       abstraction also allows the OVN centralized components to do less
       work, since they do not have to separately compute and push out
       physical flows to each chassis.)

       The default action when no flow matches is to drop packets.

       <b>Architectural Logical Life Cycle of a Packet</b>

       This following description focuses on the life cycle of a packet
       through a logical datapath, ignoring physical details of the
       implementation. Please refer to <b>Architectural Physical Life Cycle</b>
       <b>of a Packet </b>in <a href="../man7/ovn-architecture.7.html">ovn-architecture(7)</a> for the physical information.

       The description here is written as if OVN itself executes these
       steps, but in fact OVN (that is, <b>ovn-controller</b>) programs Open
       vSwitch, via OpenFlow and OVSDB, to execute them on its behalf.

       At a high level, OVN passes each packet through the logical
       datapath’s logical ingress pipeline, which may output the packet
       to one or more logical port or logical multicast groups. For each
       such logical output port, OVN passes the packet through the
       datapath’s logical egress pipeline, which may either drop the
       packet or deliver it to the destination. Between the two
       pipelines, outputs to logical multicast groups are expanded into
       logical ports, so that the egress pipeline only processes a
       single logical output port at a time. Between the two pipelines
       is also where, when necessary, OVN encapsulates a packet in a
       tunnel (or tunnels) to transmit to remote hypervisors.

       In more detail, to start, OVN searches the <b>Logical_Flow </b>table for
       a row with correct <b>logical_datapath </b>or a <b>logical_dp_group</b>, a
       <b>pipeline </b>of <b>ingress</b>, a <b>table_id </b>of 0, and a <b>match </b>that is true
       for the packet. If none is found, OVN drops the packet. If OVN
       finds more than one, it chooses the match with the highest
       <b>priority</b>. Then OVN executes each of the actions specified in the
       row’s <b>actions </b>column, in the order specified. Some actions, such
       as those to modify packet headers, require no further details.
       The <b>next </b>and <b>output </b>actions are special.

       The <b>next </b>action causes the above process to be repeated
       recursively, except that OVN searches for <b>table_id </b>of 1 instead
       of 0. Similarly, any <b>next </b>action in a row found in that table
       would cause a further search for a <b>table_id </b>of 2, and so on. When
       recursive processing completes, flow control returns to the
       action following <b>next</b>.

       The <b>output </b>action also introduces recursion. Its effect depends
       on the current value of the <b>outport </b>field. Suppose <b>outport</b>
       designates a logical port. First, OVN compares <b>inport </b>to <b>outport</b>;
       if they are equal, it treats the <b>output </b>as a no-op by default. In
       the common case, where they are different, the packet enters the
       egress pipeline. This transition to the egress pipeline discards
       register data, e.g. <b>reg0 </b>... <b>reg9 </b>and connection tracking state,
       to achieve uniform behavior regardless of whether the egress
       pipeline is on a different hypervisor (because registers aren’t
       preserve across tunnel encapsulation).

       To execute the egress pipeline, OVN again searches the
       <b>Logical_Flow </b>table for a row with correct <b>logical_datapath </b>or a
       <b>logical_dp_group</b>, a <b>table_id </b>of 0, a <b>match </b>that is true for the
       packet, but now looking for a <b>pipeline </b>of <b>egress</b>. If no matching
       row is found, the output becomes a no-op. Otherwise, OVN executes
       the actions for the matching flow (which is chosen from multiple,
       if necessary, as already described).

       In the <b>egress </b>pipeline, the <b>next </b>action acts as already
       described, except that it, of course, searches for <b>egress </b>flows.
       The <b>output </b>action, however, now directly outputs the packet to
       the output port (which is now fixed, because <b>outport </b>is read-only
       within the egress pipeline).

       The description earlier assumed that <b>outport </b>referred to a
       logical port. If it instead designates a logical multicast group,
       then the description above still applies, with the addition of
       fan-out from the logical multicast group to each logical port in
       the group. For each member of the group, OVN executes the logical
       pipeline as described, with the logical output port replaced by
       the group member.

       <b>Pipeline Stages</b>

       <b>ovn-northd </b>populates the <b>Logical_Flow </b>table with the logical
       flows described in detail in <a href="../man8/ovn-northd.8.html">ovn-northd(8)</a>.

   <b>Summary:</b>
       <b>logical_datapath              </b>optional <b>Datapath_Binding</b>
       <b>logical_dp_group              </b>optional <b>Logical_DP_Group</b>
       <b>pipeline                      </b>string, either <b>egress </b>or <b>ingress</b>
       <b>table_id                      </b>integer, in range 0 to 32
       <b>priority                      </b>integer, in range 0 to 65,535
       <b>match                         </b>string
       <b>actions                       </b>string
       <b>tags                          </b>map of string-string pairs
       <b>controller_meter              </b>optional string
       <b>external_ids : stage-name     </b>optional string
       <b>external_ids : stage-hint     </b>optional string, containing an uuid
       <b>external_ids : source         </b>optional string
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs

   <b>Details:</b>
       <b>logical_datapath</b>: optional <b>Datapath_Binding</b>
              The logical datapath to which the logical flow belongs.

       <b>logical_dp_group</b>: optional <b>Logical_DP_Group</b>
              The group of logical datapaths to which the logical flow
              belongs. This means that the same logical flow belongs to
              all datapaths in a group.

       <b>pipeline</b>: string, either <b>egress </b>or <b>ingress</b>
              The primary flows used for deciding on a packet’s
              destination are the <b>ingress </b>flows. The <b>egress </b>flows
              implement ACLs. See <b>Logical Life Cycle of a Packet</b>, above,
              for details.

       <b>table_id</b>: integer, in range 0 to 32
              The stage in the logical pipeline, analogous to an
              OpenFlow table number.

       <b>priority</b>: integer, in range 0 to 65,535
              The flow’s priority. Flows with numerically higher
              priority take precedence over those with lower. If two
              logical datapath flows with the same priority both match,
              then the one actually applied to the packet is undefined.

       <b>match</b>: string
              A matching expression. OVN provides a superset of OpenFlow
              matching capabilities, using a syntax similar to Boolean
              expressions in a programming language.

              The most important components of match expression are
              <i>comparisons</i> between <i>symbols</i> and <i>constants</i>, e.g. <b>ip4.dst ==</b>
              <b>192.168.0.1</b>, <b>ip.proto == 6</b>, <b>arp.op == 1</b>, <b>eth.type ==</b>
              <b>0x800</b>. The logical AND operator <b>&amp;&amp; </b>and logical OR operator
              <b>|| </b>can combine comparisons into a larger expression.

              Matching expressions also support parentheses for
              grouping, the logical NOT prefix operator <b>!</b>, and literals
              <b>0 </b>and <b>1 </b>to express ``false’’ or ``true,’’ respectively.
              The latter is useful by itself as a catch-all expression
              that matches every packet.

              Match expressions also support a kind of function syntax.
              The following functions are supported:

              <b>is_chassis_resident(</b><i>lport</i><b>)</b>
                     Evaluates to true on a chassis on which logical
                     port <i>lport</i> (a quoted string) resides, and to false
                     elsewhere. This function was introduced in OVN 2.7.

              <b>Symbols</b>

              <b>Type</b>. Symbols have <i>integer</i> or <i>string</i> type. Integer symbols
              have a <i>width</i> in bits.

              <b>Kinds</b>. There are three kinds of symbols:

              •      <i>Fields</i>. A field symbol represents a packet header
                     or metadata field. For example, a field named
                     <b>vlan.tci </b>might represent the VLAN TCI field in a
                     packet.

                     A field symbol can have integer or string type.
                     Integer fields can be nominal or ordinal (see <b>Level</b>
                     <b>of Measurement</b>, below).

              •      <i>Subfields</i>. A subfield represents a subset of bits
                     from a larger field. For example, a field <b>vlan.vid</b>
                     might be defined as an alias for <b>vlan.tci[0..11]</b>.
                     Subfields are provided for syntactic convenience,
                     because it is always possible to instead refer to a
                     subset of bits from a field directly.

                     Only ordinal fields (see <b>Level of Measurement</b>,
                     below) may have subfields. Subfields are always
                     ordinal.

              •      <i>Predicates</i>. A predicate is shorthand for a Boolean
                     expression. Predicates may be used much like 1-bit
                     fields. For example, <b>ip4 </b>might expand to <b>eth.type</b>
                     <b>== 0x800</b>. Predicates are provided for syntactic
                     convenience, because it is always possible to
                     instead specify the underlying expression directly.

                     A predicate whose expansion refers to any nominal
                     field or predicate (see <b>Level of Measurement</b>,
                     below) is nominal; other predicates have Boolean
                     level of measurement.

              <b>Level of Measurement</b>. See
              <a href="http://en.wikipedia.org/wiki/Level_of_measurement">http://en.wikipedia.org/wiki/Level_of_measurement</a> for the
              statistical concept on which this classification is based.
              There are three levels:

              •      <i>Ordinal</i>. In statistics, ordinal values can be
                     ordered on a scale. OVN considers a field (or
                     subfield) to be ordinal if its bits can be examined
                     individually. This is true for the OpenFlow fields
                     that OpenFlow or Open vSwitch makes ``maskable.’’

                     Any use of a ordinal field may specify a single bit
                     or a range of bits, e.g. <b>vlan.tci[13..15] </b>refers to
                     the PCP field within the VLAN TCI, and <b>eth.dst[40]</b>
                     refers to the multicast bit in the Ethernet
                     destination address.

                     OVN supports all the usual arithmetic relations
                     (<b>==</b>, <b>!=</b>, <b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, and <b>&gt;=</b>) on ordinal fields and
                     their subfields, because OVN can implement these in
                     OpenFlow and Open vSwitch as collections of bitwise
                     tests.

              •      <i>Nominal</i>. In statistics, nominal values cannot be
                     usefully compared except for equality. This is true
                     of OpenFlow port numbers, Ethernet types, and IP
                     protocols are examples: all of these are just
                     identifiers assigned arbitrarily with no deeper
                     meaning. In OpenFlow and Open vSwitch, bits in
                     these fields generally aren’t individually
                     addressable.

                     OVN only supports arithmetic tests for equality on
                     nominal fields, because OpenFlow and Open vSwitch
                     provide no way for a flow to efficiently implement
                     other comparisons on them. (A test for inequality
                     can be sort of built out of two flows with
                     different priorities, but OVN matching expressions
                     always generate flows with a single priority.)

                     String fields are always nominal.

              •      <i>Boolean</i>. A nominal field that has only two values,
                     0 and 1, is somewhat exceptional, since it is easy
                     to support both equality and inequality tests on
                     such a field: either one can be implemented as a
                     test for 0 or 1.

                     Only predicates (see above) have a Boolean level of
                     measurement.

                     This isn’t a standard level of measurement.

              <b>Prerequisites</b>. Any symbol can have prerequisites, which
              are additional condition implied by the use of the symbol.
              For example, For example, <b>icmp4.type </b>symbol might have
              prerequisite <b>icmp4</b>, which would cause an expression
              <b>icmp4.type == 0 </b>to be interpreted as <b>icmp4.type == 0 &amp;&amp;</b>
              <b>icmp4</b>, which would in turn expand to <b>icmp4.type == 0 &amp;&amp;</b>
              <b>eth.type == 0x800 &amp;&amp; ip4.proto == 1 </b>(assuming <b>icmp4 </b>is a
              predicate defined as suggested under <b>Types </b>above).

              <b>Relational operators</b>

              All of the standard relational operators <b>==</b>, <b>!=</b>, <b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>,
              and <b>&gt;= </b>are supported. Nominal fields support only <b>== </b>and
              <b>!=</b>, and only in a positive sense when outer <b>! </b>are taken
              into account, e.g. given string field <b>inport</b>, <b>inport ==</b>
              <b>"eth0" </b>and <b>!(inport != "eth0") </b>are acceptable, but not
              <b>inport != "eth0"</b>.

              The implementation of <b>== </b>(or <b>!= </b>when it is negated), is
              more efficient than that of the other relational
              operators.

              <b>Constants</b>

              Integer constants may be expressed in decimal, hexadecimal
              prefixed by <b>0x</b>, or as dotted-quad IPv4 addresses, IPv6
              addresses in their standard forms, or Ethernet addresses
              as colon-separated hex digits. A constant in any of these
              forms may be followed by a slash and a second constant
              (the mask) in the same form, to form a masked constant.
              IPv4 and IPv6 masks may be given as integers, to express
              CIDR prefixes.

              String constants have the same syntax as quoted strings in
              JSON (thus, they are Unicode strings).

              Some operators support sets of constants written inside
              curly braces <b>{ </b>... <b>}</b>. Commas between elements of a set,
              and after the last elements, are optional. With <b>==</b>,
              ``<i>field</i> <b>== { </b><i>constant1</i><b>, </b><i>constant2</i><b>, </b>... <b>}</b>’’ is syntactic
              sugar for ``<i>field</i> <b>== </b><i>constant1</i> <b>|| </b><i>field</i> <b>== </b><i>constant2</i> <b>||</b>
              .... Similarly, ``<i>field</i> <b>!= { </b><i>constant1</i><b>, </b><i>constant2</i><b>, </b>... <b>}</b>’’
              is equivalent to ``<i>field</i> <b>!= </b><i>constant1</i> <b>&amp;&amp; </b><i>field</i> <b>!=</b>
              <i>constant2</i> <b>&amp;&amp; </b>...’’.

              You may refer to a set of IPv4, IPv6, or MAC addresses
              stored in the <b>Address_Set </b>table by its <b>name</b>. An
              <b>Address_Set </b>with a name of <b>set1 </b>can be referred to as
              <b>$set1</b>.

              You may refer to a group of logical switch ports stored in
              the <b>Port_Group </b>table by its <b>name</b>. An <b>Port_Group </b>with a
              name of <b>port_group1 </b>can be referred to as <b>@port_group1</b>.

              Additionally, you may refer to the set of addresses
              belonging to a group of logical switch ports stored in the
              <b>Port_Group </b>table by its <b>name </b>followed by a suffix
              ’_ip4’/’_ip6’. The IPv4 address set of a <b>Port_Group </b>with a
              name of <b>port_group1 </b>can be referred to as
              <b>$port_group1_ip4</b>, and the IPv6 address set of the same
              <b>Port_Group </b>can be referred to as <b>$port_group1_ip6</b>

              <b>Miscellaneous</b>

              Comparisons may name the symbol or the constant first,
              e.g. <b>tcp.src == 80 </b>and <b>80 == tcp.src </b>are both acceptable.

              Tests for a range may be expressed using a syntax like
              <b>1024 &lt;= tcp.src &lt;= 49151</b>, which is equivalent to <b>1024 &lt;=</b>
              <b>tcp.src &amp;&amp; tcp.src &lt;= 49151</b>.

              For a one-bit field or predicate, a mention of its name is
              equivalent to <i>symobl</i> <b>== 1</b>, e.g. <b>vlan.present </b>is equivalent
              to <b>vlan.present == 1</b>. The same is true for one-bit
              subfields, e.g. <b>vlan.tci[12]</b>. There is no technical
              limitation to implementing the same for ordinal fields of
              all widths, but the implementation is expensive enough
              that the syntax parser requires writing an explicit
              comparison against zero to make mistakes less likely, e.g.
              in <b>tcp.src != 0 </b>the comparison against 0 is required.

              <b>Operator precedence </b>is as shown below, from highest to
              lowest. There are two exceptions where parentheses are
              required even though the table would suggest that they are
              not: <b>&amp;&amp; </b>and <b>|| </b>require parentheses when used together, and
              <b>! </b>requires parentheses when applied to a relational
              expression. Thus, in <b>(eth.type == 0x800 || eth.type ==</b>
              <b>0x86dd) &amp;&amp; ip.proto == 6 </b>or <b>!(arp.op == 1)</b>, the
              parentheses are mandatory.

              •      <b>()</b>

              •      <b>==   !=   &lt;   &lt;=   &gt;   &gt;=</b>

              •      <b>!</b>

              •      <b>&amp;&amp;   ||</b>

              <b>Comments </b>may be introduced by <b>//</b>, which extends to the
              next new-line. Comments within a line may be bracketed by
              <b>/* </b>and <b>*/</b>. Multiline comments are not supported.

              <b>Symbols</b>

              Most of the symbols below have integer type. Only <b>inport</b>
              and <b>outport </b>have string type. <b>inport </b>names a logical port.
              Thus, its value is a <b>logical_port </b>name from the
              <b>Port_Binding </b>table. <b>outport </b>may name a logical port, as
              <b>inport</b>, or a logical multicast group defined in the
              <b>Multicast_Group </b>table. For both symbols, only names within
              the flow’s logical datapath may be used.

              The <b>reg</b><i>X</i> symbols are 32-bit integers. The <b>xxreg</b><i>X</i> symbols
              are 128-bit integers, which overlay four of the 32-bit
              registers: <b>xxreg0 </b>overlays <b>reg0 </b>through <b>reg3</b>, with <b>reg0</b>
              supplying the most-significant bits of <b>xxreg0 </b>and <b>reg3 </b>the
              least-significant. <b>xxreg1 </b>similarly overlays <b>reg4 </b>through
              <b>reg7</b>.

              •      <b>reg0</b>...<b>reg9</b>

              •      <b>xxreg0 xxreg1</b>

              •      <b>inport outport</b>

              •      <b>flags.loopback</b>

              •      <b>pkt.mark</b>

              •      <b>eth.src eth.dst eth.type</b>

              •      <b>vlan.tci vlan.vid vlan.pcp vlan.present</b>

              •      <b>ip.proto ip.dscp ip.ecn ip.ttl ip.frag</b>

              •      <b>ip4.src ip4.dst</b>

              •      <b>ip6.src ip6.dst ip6.label</b>

              •      <b>arp.op arp.spa arp.tpa arp.sha arp.tha</b>

              •      <b>rarp.op rarp.spa rarp.tpa rarp.sha rarp.tha</b>

              •      <b>tcp.src tcp.dst tcp.flags</b>

              •      <b>udp.src udp.dst</b>

              •      <b>sctp.src sctp.dst</b>

              •      <b>icmp4.type icmp4.code</b>

              •      <b>icmp6.type icmp6.code</b>

              •      <b>nd.target nd.sll nd.tll</b>

              •      <b>ct_mark ct_label</b>

              •      <b>ct_state</b>, which has several Boolean subfields. The
                     <b>ct_next </b>action initializes the following subfields:

                     •      <b>ct.trk</b>: Always set to true by <b>ct_next </b>to
                            indicate that connection tracking has taken
                            place. All other <b>ct </b>subfields have <b>ct.trk </b>as
                            a prerequisite.

                     •      <b>ct.new</b>: True for a new flow

                     •      <b>ct.est</b>: True for an established flow

                     •      <b>ct.rel</b>: True for a related flow

                     •      <b>ct.rpl</b>: True for a reply flow

                     •      <b>ct.inv</b>: True for a connection entry in a bad
                            state

                     The <b>ct_dnat</b>, <b>ct_snat</b>, and <b>ct_lb </b>actions initialize
                     the following subfields:

                     •      <b>ct.dnat</b>: True for a packet whose destination
                            IP address has been changed.

                     •      <b>ct.snat</b>: True for a packet whose source IP
                            address has been changed.

              The following predicates are supported:

              •      <b>eth.bcast </b>expands to <b>eth.dst == ff:ff:ff:ff:ff:ff</b>

              •      <b>eth.mcast </b>expands to <b>eth.dst[40]</b>

              •      <b>vlan.present </b>expands to <b>vlan.tci[12]</b>

              •      <b>ip4 </b>expands to <b>eth.type == 0x800</b>

              •      <b>ip4.src_mcast </b>expands to <b>ip4.src[28..31] == 0xe</b>

              •      <b>ip4.mcast </b>expands to <b>ip4.dst[28..31] == 0xe</b>

              •      <b>ip6 </b>expands to <b>eth.type == 0x86dd</b>

              •      <b>ip </b>expands to <b>ip4 || ip6</b>

              •      <b>icmp4 </b>expands to <b>ip4 &amp;&amp; ip.proto == 1</b>

              •      <b>icmp6 </b>expands to <b>ip6 &amp;&amp; ip.proto == 58</b>

              •      <b>icmp </b>expands to <b>icmp4 || icmp6</b>

              •      <b>ip.is_frag </b>expands to <b>ip.frag[0]</b>

              •      <b>ip.later_frag </b>expands to <b>ip.frag[1]</b>

              •      <b>ip.first_frag </b>expands to <b>ip.is_frag &amp;&amp;</b>
                     <b>!ip.later_frag</b>

              •      <b>arp </b>expands to <b>eth.type == 0x806</b>

              •      <b>rarp </b>expands to <b>eth.type == 0x8035</b>

              •      <b>nd </b>expands to <b>icmp6.type == {135, 136} &amp;&amp;</b>
                     <b>icmp6.code == 0 &amp;&amp; ip.ttl == 255</b>

              •      <b>nd_ns </b>expands to <b>icmp6.type == 135 &amp;&amp; icmp6.code ==</b>
                     <b>0 &amp;&amp; ip.ttl == 255</b>

              •      <b>nd_na </b>expands to <b>icmp6.type == 136 &amp;&amp; icmp6.code ==</b>
                     <b>0 &amp;&amp; ip.ttl == 255</b>

              •      <b>nd_rs </b>expands to <b>icmp6.type == 133 &amp;&amp; icmp6.code ==</b>
                     <b>0 &amp;&amp; ip.ttl == 255</b>

              •      <b>nd_ra </b>expands to <b>icmp6.type == 134 &amp;&amp; icmp6.code ==</b>
                     <b>0 &amp;&amp; ip.ttl == 255</b>

              •      <b>tcp </b>expands to <b>ip.proto == 6</b>

              •      <b>udp </b>expands to <b>ip.proto == 17</b>

              •      <b>sctp </b>expands to <b>ip.proto == 132</b>

       <b>actions</b>: string
              Logical datapath actions, to be executed when the logical
              flow represented by this row is the highest-priority
              match.

              Actions share lexical syntax with the <b>match </b>column. An
              empty set of actions (or one that contains just white
              space or comments), or a set of actions that consists of
              just <b>drop;</b>, causes the matched packets to be dropped.
              Otherwise, the column should contain a sequence of
              actions, each terminated by a semicolon.

              The following actions are defined:

              <b>output;</b>
                     In the ingress pipeline, this action executes the
                     <b>egress </b>pipeline as a subroutine. If <b>outport </b>names a
                     logical port, the egress pipeline executes once; if
                     it is a multicast group, the egress pipeline runs
                     once for each logical port in the group.

                     In the egress pipeline, this action performs the
                     actual output to the <b>outport </b>logical port. (In the
                     egress pipeline, <b>outport </b>never names a multicast
                     group.)

                     By default, output to the input port is implicitly
                     dropped, that is, <b>output </b>becomes a no-op if <b>outport</b>
                     == <b>inport</b>. Occasionally it may be useful to
                     override this behavior, e.g. to send an ARP reply
                     to an ARP request; to do so, use <b>flags.loopback = 1</b>
                     to allow the packet to "hair-pin" back to the input
                     port.

              <b>next;</b>
              <b>next(</b><i>table</i><b>);</b>
              <b>next(pipeline=</b><i>pipeline</i><b>, table=</b><i>table</i><b>);</b>
                   Executes the given logical datapath <i>table</i> in <i>pipeline</i>
                   as a subroutine. The default <i>table</i> is just after the
                   current one. If <i>pipeline</i> is specified, it may be
                   <b>ingress </b>or <b>egress</b>; the default <i>pipeline</i> is the one
                   currently executing. Actions in the both ingress and
                   egress pipeline can use <b>next </b>to jump across the other
                   pipeline. Actions in the ingress pipeline should use
                   <b>next </b>to jump into the specific table of egress
                   pipeline only if it is certain that the packets are
                   local and not tunnelled and wants to skip certain
                   stages in the packet processing.

              <i>field</i> <b>= </b><i>constant</i><b>;</b>
                   Sets data or metadata field <i>field</i> to constant value
                   <i>constant</i>, e.g. <b>outport = "vif0"; </b>to set the logical
                   output port. To set only a subset of bits in a field,
                   specify a subfield for <i>field</i> or a masked <i>constant</i>,
                   e.g. one may use <b>vlan.pcp[2] = 1; </b>or <b>vlan.pcp = 4/4;</b>
                   to set the most significant bit of the VLAN PCP.

                   Assigning to a field with prerequisites implicitly
                   adds those prerequisites to <b>match</b>; thus, for example,
                   a flow that sets <b>tcp.dst </b>applies only to TCP flows,
                   regardless of whether its <b>match </b>mentions any TCP
                   field.

                   Not all fields are modifiable (e.g. <b>eth.type </b>and
                   <b>ip.proto </b>are read-only), and not all modifiable
                   fields may be partially modified (e.g. <b>ip.ttl </b>must
                   assigned as a whole). The <b>outport </b>field is modifiable
                   in the <b>ingress </b>pipeline but not in the <b>egress</b>
                   pipeline.

              <i>ovn_field</i> <b>= </b><i>constant</i><b>;</b>
                   Sets OVN field <i>ovn_field</i> to constant value <i>constant</i>.

                   <b>OVN </b>supports setting the values of certain fields
                   which are not yet supported in OpenFlow to set or
                   modify them.

                   Below are the supported <b>OVN fields</b>:

                   •      <b>icmp4.frag_mtu icmp6.frag_mtu</b>

                          This field sets the low-order 16 bits of the
                          ICMP{4,6} header field that is labelled
                          "unused" in the ICMP specification as defined
                          in the RFC 1191 with the value specified in
                          <i>constant</i>.

                          Eg. icmp4.frag_mtu = 1500;

              <i>field1</i> <b>= </b><i>field2</i><b>;</b>
                   Sets data or metadata field <i>field1</i> to the value of
                   data or metadata field <i>field2</i>, e.g. <b>reg0 = ip4.src;</b>
                   copies <b>ip4.src </b>into <b>reg0</b>. To modify only a subset of
                   a field’s bits, specify a subfield for <i>field1</i> or
                   <i>field2</i> or both, e.g. <b>vlan.pcp = reg0[0..2]; </b>copies
                   the least-significant bits of <b>reg0 </b>into the VLAN PCP.

                   <i>field1</i> and <i>field2</i> must be the same type, either both
                   string or both integer fields. If they are both
                   integer fields, they must have the same width.

                   If <i>field1</i> or <i>field2</i> has prerequisites, they are added
                   implicitly to <b>match</b>. It is possible to write an
                   assignment with contradictory prerequisites, such as
                   <b>ip4.src = ip6.src[0..31];</b>, but the contradiction
                   means that a logical flow with such an assignment
                   will never be matched.

              <i>field1</i> <b>&lt;-&gt; </b><i>field2</i><b>;</b>
                   Similar to <i>field1</i> <b>= </b><i>field2</i><b>; </b>except that the two
                   values are exchanged instead of copied. Both <i>field1</i>
                   and <i>field2</i> must modifiable.

              <b>push(</b><i>field</i><b>);</b>
                   Push the value of <i>field</i> to the stack top.

              <b>pop(</b><i>field</i><b>);</b>
                   Pop the stack top and store the value to <i>field</i>, which
                   must be modifiable.

              <b>ip.ttl--;</b>
                   Decrements the IPv4 or IPv6 TTL. If this would make
                   the TTL zero or negative, then processing of the
                   packet halts; no further actions are processed. (To
                   properly handle such cases, a higher-priority flow
                   should match on <b>ip.ttl == {0, 1};</b>.)

                   <b>Prerequisite: ip</b>

              <b>ct_next;</b>
                   Apply connection tracking to the flow, initializing
                   <b>ct_state </b>for matching in later tables. Automatically
                   moves on to the next table, as if followed by <b>next</b>.

                   As a side effect, IP fragments will be reassembled
                   for matching. If a fragmented packet is output, then
                   it will be sent with any overlapping fragments
                   squashed. The connection tracking state is scoped by
                   the logical port when the action is used in a flow
                   for a logical switch, so overlapping addresses may be
                   used. To allow traffic related to the matched flow,
                   execute <b>ct_commit </b>. Connection tracking state is
                   scoped by the logical topology when the action is
                   used in a flow for a router.

                   It is possible to have actions follow <b>ct_next</b>, but
                   they will not have access to any of its side-effects
                   and is not generally useful.

              <b>ct_commit { };</b>
              <b>ct_commit { ct_mark=</b><i>value[/mask]</i><b>; };</b>
              <b>ct_commit { ct_label=</b><i>value[/mask]</i><b>; };</b>
              <b>ct_commit { ct_mark=</b><i>value[/mask]</i><b>; ct_label=</b><i>value[/mask]</i><b>;</b>
              <b>};</b>
                   Commit the flow to the connection tracking entry
                   associated with it by a previous call to <b>ct_next</b>.
                   When <b>ct_mark=</b><i>value[/mask]</i> and/or
                   <b>ct_label=</b><i>value[/mask]</i> are supplied, <b>ct_mark </b>and/or
                   <b>ct_label </b>will be set to the values indicated by
                   <i>value[/mask]</i> on the connection tracking entry.
                   <b>ct_mark </b>is a 32-bit field. <b>ct_label </b>is a 128-bit
                   field. The <i>value[/mask]</i> should be specified in hex
                   string if more than 64bits are to be used. Registers
                   and other named fields can be used for <i>value</i>. <b>ct_mark</b>
                   and <b>ct_label </b>may be sub-addressed in order to have
                   specific bits set.

                   Note that if you want processing to continue in the
                   next table, you must execute the <b>next </b>action after
                   <b>ct_commit</b>. You may also leave out <b>next </b>which will
                   commit connection tracking state, and then drop the
                   packet. This could be useful for setting <b>ct_mark </b>on a
                   connection tracking entry before dropping a packet,
                   for example.

              <b>ct_commit_to_zone(dnat);</b>
              <b>ct_commit_to_zone(snat);</b>
                   Commit the flow to the specific zone in the
                   connection tracker. The packet is then automatically
                   sent to the next tables as if followed by <b>next;</b>
                   action. The next tables will see the changes in the
                   packet caused by the connection tracker.

                   Note that this action is meaningful only in the
                   Logical Router Datapath as the Logical Switch
                   Datapath does not use separate connection tracking
                   zones. Using this action in Logical Switch Datapath
                   falls back to committing the flow into the logical
                   port’s conntrack zone.

              <b>ct_dnat;</b>
              <b>ct_dnat(</b><i>IP</i><b>);</b>
                   <b>ct_dnat </b>sends the packet through the DNAT zone in
                   connection tracking table to unDNAT any packet that
                   was DNATed in the opposite direction. The packet is
                   then automatically sent to the next tables as if
                   followed by <b>next; </b>action. The next tables will see
                   the changes in the packet caused by the connection
                   tracker.

                   <b>ct_dnat(</b><i>IP</i><b>) </b>sends the packet through the DNAT zone to
                   change the destination IP address of the packet to
                   the one provided inside the parentheses and commits
                   the connection. The packet is then automatically sent
                   to the next tables as if followed by <b>next; </b>action.
                   The next tables will see the changes in the packet
                   caused by the connection tracker.

              <b>ct_snat;</b>
              <b>ct_snat(</b><i>IP</i><b>);</b>
                   <b>ct_snat </b>sends the packet through the SNAT zone to
                   unSNAT any packet that was SNATed in the opposite
                   direction. The packet is automatically sent to the
                   next tables as if followed by the <b>next; </b>action. The
                   next tables will see the changes in the packet caused
                   by the connection tracker.

                   <b>ct_snat(</b><i>IP</i><b>) </b>sends the packet through the SNAT zone to
                   change the source IP address of the packet to the one
                   provided inside the parenthesis and commits the
                   connection. The packet is then automatically sent to
                   the next tables as if followed by <b>next; </b>action. The
                   next tables will see the changes in the packet caused
                   by the connection tracker.

              <b>ct_dnat_in_czone;</b>
              <b>ct_dnat_in_czone(</b><i>IP</i><b>);</b>
                   <b>ct_dnat_in_czone </b>sends the packet through the common
                   NAT zone (used for both DNAT and SNAT) in connection
                   tracking table to unDNAT any packet that was DNATed
                   in the opposite direction. The packet is then
                   automatically sent to the next tables as if followed
                   by <b>next; </b>action. The next tables will see the changes
                   in the packet caused by the connection tracker.

                   <b>ct_dnat_in_czone(</b><i>IP</i><b>) </b>sends the packet through the
                   common NAT zone to change the destination IP address
                   of the packet to the one provided inside the
                   parentheses and commits the connection. The packet is
                   then automatically sent to the next tables as if
                   followed by <b>next; </b>action. The next tables will see
                   the changes in the packet caused by the connection
                   tracker.

              <b>ct_snat_in_czone;</b>
              <b>ct_snat_in_czone(</b><i>IP</i><b>);</b>
                   <b>ct_snat_in_czone </b>sends the packet through the common
                   NAT zone to unSNAT any packet that was SNATed in the
                   opposite direction. The packet is automatically sent
                   to the next tables as if followed by the <b>next;</b>
                   action. The next tables will see the changes in the
                   packet caused by the connection tracker.

                   <b>ct_snat_in_czone(</b><i>IP</i><b>) </b>sends the packet\ through the
                   common NAT zone to change the source IP address of
                   the packet to the one provided inside the parenthesis
                   and commits the connection. The packet is then
                   automatically sent to the next tables as if followed
                   by <b>next; </b>action. The next tables will see the changes
                   in the packet caused by the connection tracker.

              <b>ct_clear;</b>
                   Clears connection tracking state.

              <b>ct_commit_nat;</b>
                   Applies NAT and commits the connection to the CT.
                   Automatically moves on to the next table, as if
                   followed by <b>next</b>. This is very useful for connections
                   that are in related state for already existing
                   connections and allows the NAT to be applied to them
                   as well.

              <b>clone { </b><i>action</i><b>; </b>... <b>};</b>
                   Makes a copy of the packet being processed and
                   executes each <b>action </b>on the copy. Actions following
                   the <i>clone</i> action, if any, apply to the original,
                   unmodified packet. This can be used as a way to
                   ``save and restore’’ the packet around a set of
                   actions that may modify it and should not persist.

              <b>arp { </b><i>action</i><b>; </b>... <b>};</b>
                   Temporarily replaces the IPv4 packet being processed
                   by an ARP packet and executes each nested <i>action</i> on
                   the ARP packet. Actions following the <i>arp</i> action, if
                   any, apply to the original, unmodified packet.

                   The ARP packet that this action operates on is
                   initialized based on the IPv4 packet being processed,
                   as follows. These are default values that the nested
                   actions will probably want to change:

                   •      <b>eth.src </b>unchanged

                   •      <b>eth.dst </b>unchanged

                   •      <b>eth.type = 0x0806</b>

                   •      <b>arp.op = 1 </b>(ARP request)

                   •      <b>arp.sha </b>copied from <b>eth.src</b>

                   •      <b>arp.spa </b>copied from <b>ip4.src</b>

                   •      <b>arp.tha = 00:00:00:00:00:00</b>

                   •      <b>arp.tpa </b>copied from <b>ip4.dst</b>

                   The ARP packet has the same VLAN header, if any, as
                   the IP packet it replaces.

                   <b>Prerequisite: ip4</b>

              <b>get_arp(</b><i>P</i><b>, </b><i>A</i><b>);</b>
                   <b>Parameters</b>: logical port string field <i>P</i>, 32-bit IP
                   address field <i>A</i>.

                   Looks up <i>A</i> in <i>P</i>’s mac binding table. If an entry is
                   found, stores its Ethernet address in <b>eth.dst</b>,
                   otherwise stores <b>00:00:00:00:00:00 </b>in <b>eth.dst</b>.

                   <b>Example: get_arp(outport, ip4.dst);</b>

              <b>put_arp(</b><i>P</i><b>, </b><i>A</i><b>, </b><i>E</i><b>);</b>
                   <b>Parameters</b>: logical port string field <i>P</i>, 32-bit IP
                   address field <i>A</i>, 48-bit Ethernet address field <i>E</i>.

                   Adds or updates the entry for IP address <i>A</i> in logical
                   port <i>P</i>’s mac binding table, setting its Ethernet
                   address to <i>E</i>.

                   <b>Example: put_arp(inport, arp.spa, arp.sha);</b>

              <i>R</i> <b>= lookup_arp(</b><i>P</i><b>, </b><i>A</i><b>, </b><i>M</i><b>);</b>
                   <b>Parameters</b>: logical port string field <i>P</i>, 32-bit IP
                   address field <i>A</i>, 48-bit MAC address field <i>M</i>.

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   Looks up <i>A</i> and <i>M</i> in <i>P</i>’s mac binding table. If an
                   entry is found, stores <b>1 </b>in the 1-bit subfield <i>R</i>,
                   else 0.

                   <b>Example: reg0[0] = lookup_arp(inport, arp.spa,</b>
                   <b>arp.sha);</b>

              <i>R</i> <b>= lookup_arp_ip(</b><i>P</i><b>, </b><i>A</i><b>);</b>
                   <b>Parameters</b>: logical port string field <i>P</i>, 32-bit IP
                   address field <i>A</i>.

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   Looks up <i>A</i> in <i>P</i>’s mac binding table. If an entry is
                   found, stores <b>1 </b>in the 1-bit subfield <i>R</i>, else 0.

                   <b>Example: reg0[0] = lookup_arp_ip(inport, arp.spa);</b>

              <i>P</i> <b>= get_fdb(</b><i>A</i><b>);</b>
                   <b>Parameters</b>:48-bit MAC address field <i>A</i>.

                   Looks up <i>A</i> in fdb table. If an entry is found, stores
                   the logical port key to the out parameter <b>P</b>.

                   <b>Example: outport = get_fdb(eth.src);</b>

              <b>put_fdb(</b><i>P</i><b>, </b><i>A</i><b>);</b>
                   <b>Parameters</b>: logical port string field <i>P</i>, 48-bit MAC
                   address field <i>A</i>.

                   Adds or updates the entry for Ethernet address <i>A</i> in
                   fdb table, setting its logical port key to <i>P</i>.

                   <b>Example: put_fdb(inport, arp.spa);</b>

              <i>R</i> <b>= lookup_fdb(</b><i>P</i><b>, </b><i>A</i><b>);</b>
                   <b>Parameters</b>: 48-bit MAC address field <i>M</i>, logical port
                   string field <i>P</i>.

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   Looks up <i>A</i> in fdb table. If an entry is found and the
                   logical port key is <i>P</i>, <b>P</b>, stores <b>1 </b>in the 1-bit
                   subfield <i>R</i>, else 0. If <b>flags.localnet </b>is set then <b>1</b>
                   is stored if an entry is found and the logical port
                   key is <i>P</i> or if an entry is found and the entry port
                   type is VIF.

                   <b>Example: reg0[0] = lookup_fdb(inport, eth.src);</b>

              <b>nd_ns { </b><i>action</i><b>; </b>... <b>};</b>
                   Temporarily replaces the IPv6 packet being processed
                   by an IPv6 Neighbor Solicitation packet and executes
                   each nested <i>action</i> on the IPv6 NS packet. Actions
                   following the <i>nd_ns</i> action, if any, apply to the
                   original, unmodified packet.

                   The IPv6 NS packet that this action operates on is
                   initialized based on the IPv6 packet being processed,
                   as follows. These are default values that the nested
                   actions will probably want to change:

                   •      <b>eth.src </b>unchanged

                   •      <b>eth.dst </b>set to IPv6 multicast MAC address

                   •      <b>eth.type = 0x86dd</b>

                   •      <b>ip6.src </b>copied from <b>ip6.src</b>

                   •      <b>ip6.dst </b>set to IPv6 Solicited-Node multicast
                          address

                   •      <b>icmp6.type = 135 </b>(Neighbor Solicitation)

                   •      <b>nd.target </b>copied from <b>ip6.dst</b>

                   The IPv6 NS packet has the same VLAN header, if any,
                   as the IP packet it replaces.

                   <b>Prerequisite: ip6</b>

              <b>nd_na { </b><i>action</i><b>; </b>... <b>};</b>
                   Temporarily replaces the IPv6 neighbor solicitation
                   packet being processed by an IPv6 neighbor
                   advertisement (NA) packet and executes each nested
                   <i>action</i> on the NA packet. Actions following the <b>nd_na</b>
                   action, if any, apply to the original, unmodified
                   packet.

                   The NA packet that this action operates on is
                   initialized based on the IPv6 packet being processed,
                   as follows. These are default values that the nested
                   actions will probably want to change:

                   •      <b>eth.dst </b>exchanged with <b>eth.src</b>

                   •      <b>eth.type = 0x86dd</b>

                   •      <b>ip6.dst </b>copied from <b>ip6.src</b>

                   •      <b>ip6.src </b>copied from <b>nd.target</b>

                   •      <b>icmp6.type = 136 </b>(Neighbor Advertisement)

                   •      <b>nd.target </b>unchanged

                   •      <b>nd.sll = 00:00:00:00:00:00</b>

                   •      <b>nd.tll </b>copied from <b>eth.dst</b>

                   The ND packet has the same VLAN header, if any, as
                   the IPv6 packet it replaces.

                   <b>Prerequisite: nd_ns</b>

              <b>nd_na_router { </b><i>action</i><b>; </b>... <b>};</b>
                   Temporarily replaces the IPv6 neighbor solicitation
                   packet being processed by an IPv6 neighbor
                   advertisement (NA) packet, sets ND_NSO_ROUTER in the
                   RSO flags and executes each nested <i>action</i> on the NA
                   packet. Actions following the <b>nd_na_router </b>action, if
                   any, apply to the original, unmodified packet.

                   The NA packet that this action operates on is
                   initialized based on the IPv6 packet being processed,
                   as follows. These are default values that the nested
                   actions will probably want to change:

                   •      <b>eth.dst </b>exchanged with <b>eth.src</b>

                   •      <b>eth.type = 0x86dd</b>

                   •      <b>ip6.dst </b>copied from <b>ip6.src</b>

                   •      <b>ip6.src </b>copied from <b>nd.target</b>

                   •      <b>icmp6.type = 136 </b>(Neighbor Advertisement)

                   •      <b>nd.target </b>unchanged

                   •      <b>nd.sll = 00:00:00:00:00:00</b>

                   •      <b>nd.tll </b>copied from <b>eth.dst</b>

                   The ND packet has the same VLAN header, if any, as
                   the IPv6 packet it replaces.

                   <b>Prerequisite: nd_ns</b>

              <b>get_nd(</b><i>P</i><b>, </b><i>A</i><b>);</b>
                   <b>Parameters</b>: logical port string field <i>P</i>, 128-bit IPv6
                   address field <i>A</i>.

                   Looks up <i>A</i> in <i>P</i>’s mac binding table. If an entry is
                   found, stores its Ethernet address in <b>eth.dst</b>,
                   otherwise stores <b>00:00:00:00:00:00 </b>in <b>eth.dst</b>.

                   <b>Example: get_nd(outport, ip6.dst);</b>

              <b>put_nd(</b><i>P</i><b>, </b><i>A</i><b>, </b><i>E</i><b>);</b>
                   <b>Parameters</b>: logical port string field <i>P</i>, 128-bit IPv6
                   address field <i>A</i>, 48-bit Ethernet address field <i>E</i>.

                   Adds or updates the entry for IPv6 address <i>A</i> in
                   logical port <i>P</i>’s mac binding table, setting its
                   Ethernet address to <i>E</i>.

                   <b>Example: put_nd(inport, nd.target, nd.tll);</b>

              <i>R</i> <b>= lookup_nd(</b><i>P</i><b>, </b><i>A</i><b>, </b><i>M</i><b>);</b>
                   <b>Parameters</b>: logical port string field <i>P</i>, 128-bit IP
                   address field <i>A</i>, 48-bit MAC address field <i>M</i>.

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   Looks up <i>A</i> and <i>M</i> in <i>P</i>’s mac binding table. If an
                   entry is found, stores <b>1 </b>in the 1-bit subfield <i>R</i>,
                   else 0.

                   <b>Example: reg0[0] = lookup_nd(inport, ip6.src,</b>
                   <b>eth.src);</b>

              <i>R</i> <b>= lookup_nd_ip(</b><i>P</i><b>, </b><i>A</i><b>);</b>
                   <b>Parameters</b>: logical port string field <i>P</i>, 128-bit IP
                   address field <i>A</i>.

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   Looks up <i>A</i> in <i>P</i>’s mac binding table. If an entry is
                   found, stores <b>1 </b>in the 1-bit subfield <i>R</i>, else 0.

                   <b>Example: reg0[0] = lookup_nd_ip(inport, ip6.src);</b>

              <i>R</i> <b>= put_dhcp_opts(</b><i>D1</i> <b>= </b><i>V1</i><b>, </b><i>D2</i> <b>= </b><i>V2</i><b>, ..., </b><i>Dn</i> <b>= </b><i>Vn</i><b>);</b>
                   <b>Parameters</b>: one or more DHCP option/value pairs,
                   which must include an <b>offerip </b>option (with code 0).

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   Valid only in the ingress pipeline.

                   When this action is applied to a DHCP request packet
                   (DHCPDISCOVER or DHCPREQUEST), it changes the packet
                   into a DHCP reply (DHCPOFFER or DHCPACK,
                   respectively), replaces the options by those
                   specified as parameters, and stores 1 in <i>R</i>.

                   When this action is applied to a non-DHCP packet or a
                   DHCP packet that is not DHCPDISCOVER or DHCPREQUEST,
                   it leaves the packet unchanged and stores 0 in <i>R</i>.

                   The contents of the <b>DHCP_Option </b>table control the
                   DHCP option names and values that this action
                   supports.

                   <b>Example: reg0[0] = put_dhcp_opts(offerip = 10.0.0.2,</b>
                   <b>router = 10.0.0.1, netmask = 255.255.255.0,</b>
                   <b>dns_server = {8.8.8.8, 7.7.7.7});</b>

              <i>R</i> <b>= put_dhcpv6_opts(</b><i>D1</i> <b>= </b><i>V1</i><b>, </b><i>D2</i> <b>= </b><i>V2</i><b>, ..., </b><i>Dn</i> <b>= </b><i>Vn</i><b>);</b>
                   <b>Parameters</b>: one or more DHCPv6 option/value pairs.

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   Valid only in the ingress pipeline.

                   When this action is applied to a DHCPv6 request
                   packet, it changes the packet into a DHCPv6 reply,
                   replaces the options by those specified as
                   parameters, and stores 1 in <i>R</i>.

                   When this action is applied to a non-DHCPv6 packet or
                   an invalid DHCPv6 request packet , it leaves the
                   packet unchanged and stores 0 in <i>R</i>.

                   The contents of the <b>DHCPv6_Options </b>table control the
                   DHCPv6 option names and values that this action
                   supports.

                   <b>Example: reg0[3] = put_dhcpv6_opts(ia_addr = aef0::4,</b>
                   <b>server_id = 00:00:00:00:10:02,</b>
                   <b>dns_server={ae70::1,ae70::2});</b>

              <b>set_queue(</b><i>queue_number</i><b>);</b>
                   <b>Parameters</b>: Queue number <i>queue_number</i>, in the range 0
                   to 61440.

                   This is a logical equivalent of the OpenFlow
                   <b>set_queue </b>action. It affects packets that egress a
                   hypervisor through a physical interface. For nonzero
                   <i>queue_number</i>, it configures packet queuing to match
                   the settings configured for the <b>Port_Binding </b>with
                   <b>options:qdisc_queue_id </b>matching <i>queue_number</i>. When
                   <i>queue_number</i> is zero, it resets queuing to the
                   default strategy.

                   <b>Example: set_queue(10);</b>

              <b>ct_lb;</b>
              <b>ct_lb(backends=</b><i>ip</i><b>[:</b><i>port</i><b>][,...][;</b>
              <b>hash_fields=</b><i>field1</i><b>,</b><i>field2</i><b>,...][; ct_flag]);</b>
                   With arguments, <b>ct_lb </b>commits the packet to the
                   connection tracking table and DNATs the packet’s
                   destination IP address (and port) to the IP address
                   or addresses (and optional ports) specified in the
                   <b>backends</b>. If multiple comma-separated IP addresses
                   are specified, each is given equal weight for picking
                   the DNAT address. By default, <b>dp_hash </b>is used as the
                   OpenFlow group selection method, but if <b>hash_fields</b>
                   is specified, <b>hash </b>is used as the selection method,
                   and the fields listed are used as the hash fields.
                   The <b>ct_flag </b>field represents one of supported flag:
                   <b>skip_snat </b>or <b>force_snat</b>, this flag will be stored in
                   <b>ct_label </b>register.

                   Without arguments, <b>ct_lb </b>sends the packet to the
                   connection tracking table to NAT the packets. If the
                   packet is part of an established connection that was
                   previously committed to the connection tracker via
                   <b>ct_lb(</b>...<b>)</b>, it will automatically get DNATed to the
                   same IP address as the first packet in that
                   connection.

                   Processing automatically moves on to the next table,
                   as if <b>next; </b>were specified, and later tables act on
                   the packet as modified by the connection tracker.
                   Connection tracking state is scoped by the logical
                   port when the action is used in a flow for a logical
                   switch, so overlapping addresses may be used.
                   Connection tracking state is scoped by the logical
                   topology when the action is used in a flow for a
                   router.

              <b>ct_lb_mark;</b>
              <b>ct_lb_mark(backends=</b><i>ip</i><b>[:</b><i>port</i><b>][,...][;</b>
              <b>hash_fields=</b><i>field1</i><b>,</b><i>field2</i><b>,...][; ct_flag]);</b>
                   Same as <b>ct_lb</b>, except that it internally uses ct_mark
                   to store the NAT flag, while <b>ct_lb </b>uses ct_label for
                   the same purpose.

              <i>R</i> <b>= dns_lookup();</b>
                   <b>Parameters</b>: No parameters.

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   Valid only in the ingress pipeline.

                   When this action is applied to a valid DNS request (a
                   UDP packet typically directed to port 53), it
                   attempts to resolve the query using the contents of
                   the <b>DNS </b>table. If it is successful, it changes the
                   packet into a DNS reply and stores 1 in <i>R</i>. If the
                   action is applied to a non-DNS packet, an invalid DNS
                   request packet, or a valid DNS request for which the
                   <b>DNS </b>table does not supply an answer, it leaves the
                   packet unchanged and stores 0 in <i>R</i>.

                   Regardless of success, the action does not make any
                   of the changes to the flow that are necessary to
                   direct the packet back to the requester. The logical
                   pipeline can implement this behavior with matches and
                   actions in later tables.

                   <b>Example: reg0[3] = dns_lookup();</b>

                   <b>Prerequisite: udp</b>

              <i>R</i> <b>= put_nd_ra_opts(</b><i>D1</i> <b>= </b><i>V1</i><b>, </b><i>D2</i> <b>= </b><i>V2</i><b>, ..., </b><i>Dn</i> <b>= </b><i>Vn</i><b>);</b>
                   <b>Parameters</b>: The following IPv6 ND Router
                   Advertisement option/value pairs as defined in RFC
                   4861.

                   •      <b>addr_mode</b>

                          Mandatory parameter which specifies the
                          address mode flag to be set in the RA flag
                          options field. The value of this option is a
                          string and the following values can be defined
                          - "slaac", "dhcpv6_stateful" and
                          "dhcpv6_stateless".

                   •      <b>slla</b>

                          Mandatory parameter which specifies the link-
                          layer address of the interface from which the
                          Router Advertisement is sent.

                   •      <b>mtu</b>

                          Optional parameter which specifies the MTU.

                   •      <b>prefix</b>

                          Optional parameter which should be specified
                          if the addr_mode is "slaac" or
                          "dhcpv6_stateless". The value should be an
                          IPv6 prefix which will be used for stateless
                          IPv6 address configuration. This option can be
                          defined multiple times.

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   Valid only in the ingress pipeline.

                   When this action is applied to an IPv6 Router
                   solicitation request packet, it changes the packet
                   into an IPv6 Router Advertisement reply and adds the
                   options specified in the parameters, and stores 1 in
                   <i>R</i>.

                   When this action is applied to a non-IPv6 Router
                   solicitation packet or an invalid IPv6 request packet
                   , it leaves the packet unchanged and stores 0 in <i>R</i>.

                   <b>Example: reg0[3] = put_nd_ra_opts(addr_mode =</b>
                   <b>"slaac", slla = 00:00:00:00:10:02, prefix =</b>
                   <b>aef0::/64, mtu = 1450);</b>

              <b>set_meter(</b><i>rate</i><b>);</b>
              <b>set_meter(</b><i>rate</i><b>, </b><i>burst</i><b>);</b>
                   <b>Parameters</b>: rate limit int field <i>rate</i> in kbps, burst
                   rate limits int field <i>burst</i> in kbps.

                   This action sets the rate limit for a flow.

                   <b>Example: set_meter(100, 1000);</b>

              <i>R</i> <b>= check_pkt_larger(</b><i>L</i><b>)</b>
                   <b>Parameters</b>: packet length <i>L</i> to check for in bytes.

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   This is a logical equivalent of the OpenFlow
                   <b>check_pkt_larger </b>action. If the packet is larger than
                   the length specified in <i>L</i>, it stores 1 in the
                   subfield <i>R</i>.

                   <b>Example: reg0[6] = check_pkt_larger(1000);</b>

              <b>log(</b><i>key</i><b>=</b><i>value</i><b>, </b>...<b>);</b>
                     Causes <b>ovn-controller </b>to log the packet on the
                     chassis that processes it. Packet logging currently
                     uses the same logging mechanism as other Open
                     vSwitch and OVN messages, which means that whether
                     and where log messages appear depends on the local
                     logging configuration that can be configured with
                     <b>ovs-appctl</b>, etc.

                     The <b>log </b>action takes zero or more of the following
                     key-value pair arguments that control what is
                     logged:

                     <b>name=</b><i>string</i>
                            An optional name for the ACL. The <i>string</i> is
                            currently limited to 64 bytes.

                     <b>severity=</b><i>level</i>
                            Indicates the severity of the event. The
                            <i>level</i> is one of following (from more to less
                            serious): <b>alert</b>, <b>warning</b>, <b>notice</b>, <b>info</b>, or
                            <b>debug</b>. If a severity is not provided, the
                            default is <b>info</b>.

                     <b>verdict=</b><i>value</i>
                            The verdict for packets matching the flow.
                            The value must be one of <b>allow</b>, <b>deny</b>, or
                            <b>reject</b>.

                     <b>meter=</b><i>string</i>
                            An optional rate-limiting meter to be
                            applied to the logs. The <i>string</i> should
                            reference a <b>name </b>entry from the <b>Meter </b>table.
                            The only meter <b>action </b>that is appropriate is
                            <b>drop</b>.

              <b>fwd_group(liveness=</b><i>bool</i><b>, childports=</b><i>port</i><b>, ...);</b>
                     <b>Parameters</b>: optional <b>liveness</b>, either <b>true </b>or
                     <b>false</b>, defaulting to false; <b>childports</b>, a comma-
                     delimited list of strings denoting logical ports to
                     load balance across.

                     Load balance traffic to one or more child ports in
                     a logical switch. <b>ovn-controller </b>translates the
                     <b>fwd_group </b>into an OpenFlow group with one bucket
                     for each child port. If <b>liveness=true </b>is specified,
                     it also integrates the bucket selection with BFD
                     status on the tunnel interface corresponding to
                     child port.

                     <b>Example: fwd_group(liveness=true, childports="p1",</b>
                     <b>"p2");</b>

              <b>icmp4 { </b><i>action</i><b>; </b>... <b>};</b>
              <b>icmp4_error { </b><i>action</i><b>; </b>... <b>};</b>
                   Temporarily replaces the IPv4 packet being processed
                   by an ICMPv4 packet and executes each nested <i>action</i>
                   on the ICMPv4 packet. Actions following these
                   actions, if any, apply to the original, unmodified
                   packet.

                   The ICMPv4 packet that these actions operates on is
                   initialized based on the IPv4 packet being processed,
                   as follows. These are default values that the nested
                   actions will probably want to change. Ethernet and
                   IPv4 fields not listed here are not changed:

                   •      <b>ip.proto = 1 </b>(ICMPv4)

                   •      <b>ip.frag = 0 </b>(not a fragment)

                   •      <b>ip.ttl = 255</b>

                   •      <b>icmp4.type = 3 </b>(destination unreachable)

                   •      <b>icmp4.code = 1 </b>(host unreachable)

                   <b>icmp4_error </b>action is expected to be used to generate
                   an ICMPv4 packet in response to an error in original
                   IP packet. When this action generates the ICMPv4
                   packet, it also copies the original IP datagram
                   following the ICMPv4 header as per RFC 1122: 3.2.2.

                   <b>Prerequisite: ip4</b>

              <b>icmp6 { </b><i>action</i><b>; </b>... <b>};</b>
              <b>icmp6_error { </b><i>action</i><b>; </b>... <b>};</b>
                   Temporarily replaces the IPv6 packet being processed
                   by an ICMPv6 packet and executes each nested <i>action</i>
                   on the ICMPv6 packet. Actions following the <i>icmp6</i>
                   action, if any, apply to the original, unmodified
                   packet.

                   The ICMPv6 packet that this action operates on is
                   initialized based on the IPv6 packet being processed,
                   as follows. These are default values that the nested
                   actions will probably want to change. Ethernet and
                   IPv6 fields not listed here are not changed:

                   •      <b>ip.proto = 58 </b>(ICMPv6)

                   •      <b>ip.ttl = 255</b>

                   •      <b>icmp6.type = 1 </b>(destination unreachable)

                   •      <b>icmp6.code = 1 </b>(administratively prohibited)

                   <b>icmp6_error </b>action is expected to be used to generate
                   an ICMPv6 packet in response to an error in original
                   IPv6 packet.

                   <b>Prerequisite: ip6</b>

              <b>tcp_reset;</b>
                   This action transforms the current TCP packet
                   according to the following pseudocode:

                   <b>if (tcp.ack) {</b>
                           <b>tcp.seq = tcp.ack;</b>
                   <b>} else {</b>
                           <b>tcp.ack = tcp.seq + length(tcp.payload);</b>
                           <b>tcp.seq = 0;</b>
                   <b>}</b>
                   <b>tcp.flags = RST;</b>

                   Then, the action drops all TCP options and payload
                   data, and updates the TCP checksum. IP ttl is set to
                   255.

                   <b>Prerequisite: tcp</b>

              <b>reject { </b><i>action</i><b>; </b>... <b>};</b>
                   If the original packet is IPv4 or IPv6 TCP packet, it
                   replaces it with IPv4 or IPv6 TCP RST packet and
                   executes the inner actions. Otherwise it replaces it
                   with an ICMPv4 or ICMPv6 packet and executes the
                   inner actions.

                   The inner actions should not attempt to swap eth
                   source with eth destination and IP source with IP
                   destination as this action implicitly does that.

              <b>trigger_event;</b>
                   This action is used to allow ovs-vswitchd to report
                   CMS related events writing them in <b>Controller_Event</b>
                   table. It is possible to associate a meter to a each
                   event in order to not overload pinctrl thread under
                   heavy load; each meter is identified though a defined
                   naming convention. Supported events:

                   •      <i>empty_lb_backends</i>. This event is raised if a
                          received packet is destined for a load
                          balancer VIP that has no configured backend
                          destinations. For this event, the event info
                          includes the load balancer VIP, the load
                          balancer UUID, and the transport protocol.
                          Associated meter: <b>event-elb</b>

              <b>igmp;</b>
                   This action sends the packet to <b>ovn-controller </b>for
                   multicast snooping.

                   <b>Prerequisite: igmp</b>

              <b>bind_vport(</b><i>V</i><b>, </b><i>P</i><b>);</b>
                   <b>Parameters</b>: logical port string field <i>V</i> of type
                   <b>virtual</b>, logical port string field <i>P</i>.

                   Binds the virtual logical port <i>V</i> and sets the <b>chassis</b>
                   column and <b>virtual_parent </b>of the table <b>Port_Binding</b>.
                   <b>virtual_parent </b>is set to <i>P</i>.

              <b>handle_svc_check(</b><i>P</i><b>);</b>
                   <b>Parameters</b>: logical port string field <i>P</i>.

                   Handles the service monitor reply received from the
                   VIF of the logical port <i>P</i>. <b>ovn-controller</b>
                   periodically sends out the service monitor packets
                   for the services configured in the <b>Service_Monitor</b>
                   table and this action updates the status of those
                   services.

                   <b>Example: handle_svc_check(inport);</b>

              <b>handle_dhcpv6_reply;</b>
                   Handle DHCPv6 prefix delegation
                   advertisements/replies from a IPv6 delegation server.
                   <b>ovn-controller </b>will add an entry <b>ipv6_ra_pd_list </b>in
                   the <b>options </b>table for each prefix received from the
                   delegation server

              <i>R</i> <b>= select(</b><i>N1</i><b>[=</b><i>W1</i><b>], </b><i>N2</i><b>[=</b><i>W2</i><b>], ...);</b>
                   <b>Parameters</b>: Integer <i>N1</i>, <i>N2</i>..., with optional weight
                   <i>W1</i>, <i>W2</i>, ...

                   <b>Result</b>: stored to a logical field or subfield <i>R</i>.

                   Select from a list of integers <i>N1</i>, <i>N2</i>..., each within
                   the range 0 ~ 65535, and store the selected one in
                   the field <i>R</i>. There must be 2 or more integers listed,
                   each with an optional weight, which is an integer
                   within the range 1 ~ 65535. If weight is not
                   specified, it defaults to 100. The selection method
                   is based on the 5-tuple hash of packet header.

                   Processing automatically moves on to the next table,
                   as if <b>next; </b>were specified. The <b>select </b>action must be
                   put as the last action of the logical flow when there
                   are multiple actions (actions put after <b>select </b>will
                   not take effect).

                   <b>Example: reg8[16..31] = select(1=20, 2=30, 3=50);</b>

              <b>handle_dhcpv6_reply;</b>
                   This action is used to parse DHCPv6 replies from IPv6
                   Delegation Router and managed IPv6 Prefix delegation
                   state machine

              <i>R</i> <b>= chk_lb_hairpin();</b>
                   This action checks if the packet under consideration
                   was destined to a load balancer VIP and it is
                   hairpinned, i.e., after load balancing the
                   destination IP matches the source IP. If it is so,
                   then the 1-bit destination register <i>R</i> is set to 1.

              <i>R</i> <b>= chk_lb_hairpin_reply();</b>
                   This action checks if the packet under consideration
                   is from one of the backend IP of a load balancer VIP
                   and the destination IP is the load balancer VIP. If
                   it is so, then the 1-bit destination register <i>R</i> is
                   set to 1.

              <i>R</i> <b>= ct_snat_to_vip;</b>
                   This action sends the packet through the SNAT zone to
                   change the source IP address of the packet to the
                   load balancer VIP if the original destination IP was
                   load balancer VIP and commits the connection. This
                   action applies successfully only for the hairpinned
                   traffic i.e if the action <b>chk_lb_hairpin </b>returned
                   success. This action doesn’t take any arguments and
                   it determines the SNAT IP internally. The packet is
                   not automatically sent to the next table. The caller
                   has to execute the <b>next; </b>action explicitly after this
                   action to advance the packet to the next stage.

              <i>R</i> <b>= check_in_port_sec();</b>
                   This action checks if the packet under consideration
                   passes the inport port security checks. If the packet
                   fails the port security checks, then <b>1 </b>is stored in
                   the destination register <i>R</i>. Else 0 is stored. The
                   port security values to check are retrieved from the
                   the <b>inport </b>logical port.

                   This action should be used in the ingress logical
                   switch pipeline.

                   <b>Example: reg8[0..7] = check_in_port_sec();</b>

              <i>R</i> <b>= check_out_port_sec();</b>
                   This action checks if the packet under consideration
                   passes the outport port security checks. If the
                   packet fails the port security checks, then <b>1 </b>is
                   stored in the destination register <i>R</i>. Else 0 is
                   stored. The port security values to check are
                   retrieved from the the <b>outport </b>logical port.

                   This action should be used in the egress logical
                   switch pipeline.

                   <b>Example: reg8[0..7] = check_out_port_sec();</b>

              <b>commit_ecmp_nh(</b><i>ipv6</i><b>);</b>
                   <b>Parameters</b>: IPv4/IPv6 traffic.

                   This action translates to an openflow "learn" action
                   that inserts two new flows in tables 76 and 77.

                   •      Match on the the 5-tuple and the expected
                          next-hop mac address in table 76: <b>nw_src=ip0</b>,
                          <b>nw_dst=ip1</b>, <b>ip_proto</b>,<b>tp_src=l4_port0</b>,
                          <b>tp_dst=l4_port1</b>,<b>dl_src=ethaddr </b>and set
                          <b>reg9[5]</b>.

                   •      Match on the 5-tuple in table 77: <b>nw_src=ip1</b>,
                          <b>nw_dst=ip0</b>, <b>ip_proto</b>, <b>tp_src=l4_port1</b>,
                          <b>tp_dst=l4_port0 </b>and set <b>reg9[5] </b>to 1

                   This action is applied if the packet arrives via ECMP
                   route or if it is routed via an ECMP route

              <i>R</i> <b>= check_ecmp_nh_mac();</b>
                   This action checks if the packet under consideration
                   matches any flow in table 76. If it is so, then the
                   1-bit destination register <i>R</i> is set to 1.

              <i>R</i> <b>= check_ecmp_nh();</b>
                   This action checks if the packet under consideration
                   matches the any flow in table 77. If it is so, then
                   the 1-bit destination register <i>R</i> is set to 1.

                   commit_lb_aff(<i>vip</i><b>, </b><i>backend</i><b>, </b><i>proto</i><b>, </b><i>timeout</i><b>);</b>
                   <b>Parameters</b>: load-balancer virtual ip:port <i>vip</i>, load-
                   balancer backend ip:port <i>backend</i>, load-balancer
                   protocol <i>proto</i>, affinity timeout <i>timeout</i>.

                   This action translates to an openflow "learn" action
                   that inserts a new flow in table 78.

                   •      Match on the 4-tuple in table 78: <b>nw_src=ip</b>
                          <b>client</b>, <b>nw_dst=vip ip</b>, <b>ip_proto</b>, <b>tp_dst=vip</b>
                          <b>port </b>and set <b>reg9[6] </b>to 1, <b>reg4 </b>and <b>reg8 </b>to
                          backend ip and port respectively. For IPv6
                          register <b>xxreg1 </b>is used to store the backend
                          ip.

                   This action is applied for new connections received
                   by a specific load-balacer with affinity timeout
                   configured.

              <i>R</i> <b>= chk_lb_aff();</b>
                   This action checks if the packet under consideration
                   matches any flow in table 78. If it is so, then the
                   1-bit destination register <i>R</i> is set to 1.

              <b>sample(probability=</b><i>packets</i><b>, ...)</b>
                   This action causes the matched traffic to be sampled
                   using IPFIX protocol. More information about how per-
                   flow IPFIX sampling works in OVS can be found in
                   <a href="../man7/ovs-actions.7.html">ovs-actions(7)</a> and <a href="ovs-vswitchd.conf.db.5.html">ovs-vswitchd.conf.db(5)</a>.

                   In order to reliably identify each sampled packet
                   when it is received by the IPFIX collector, this
                   action sets the content of the <b>ObservationDomainID</b>
                   and <b>ObservationPointID </b>IPFIX fields (see argument
                   description below).

                   The following key-value arguments are supported:

                   <b>probability=</b><i>packets</i>
                          The number of sampled packets out of 65535. It
                          must be greater or equal to 1.

                   <b>collector_set=</b><i>id</i>
                          The unsigned 32-bit integer identifier of the
                          sample collector to send sampled packets to.
                          It must match the value configured in the
                          <b>Flow_Sample_Collector_Set </b>Table in OVS.
                          Defaults to 0.

                   <b>obs_domain=</b><i>id</i>
                          An unsigned 8-bit integer that identifies the
                          sampling application. It will be placed in the
                          8 most significant bits of the
                          <b>ObservationDomainID </b>field of IPFIX samples.
                          The 24 less significant bits will be
                          automatically filled in with the datapath key.
                          Defaults to 0.

                   <b>obs_point=</b><i>id</i>
                          An unsigned 32-bit integer to be used as
                          <b>ObsservationPointID </b>or the string <b>@cookie </b>to
                          indicate that the first 32 bits of the
                          <b>Logical_Flow</b>’s UUID shall be used instead.

              <b>mac_cache_use;</b>
                   This action resubmits to corresponding table which
                   updates the use statistics of MAC cache.

              <i>R</i> <b>= dhcp_relay_req_chk(</b><i>relay-ip</i><b>,</b>
                   <i>server-ip</i><b>); Parameters</b>: Logical Router Port IP <i>relay-</i>
                   <i>ip</i>, DHCP Server IP <i>server-ip</i>.

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   This action executes on the source node on which the
                   DHCP request (DHCPDISCOVER or DHCPREQUEST)
                   originated.

                   When this action applied successfully on the DHCP
                   request packet, it updates GIADDR in the DHCP packet
                   with <i>relay-ip</i> and stores 1 in R.

                   When this action failed to apply on the packet, it
                   leaves the packet unchanged and stores 0 in R.

              <i>R</i> <b>= dhcp_relay_resp_chk(</b><i>relay-ip</i><b>,</b>
                   <i>server-ip</i><b>); Parameters</b>: Logical Router Port IP <i>relay-</i>
                   <i>ip</i>, DHCP Server IP <i>server-ip</i>.

                   <b>Result</b>: stored to a 1-bit subfield <i>R</i>.

                   This action executes on the first node (Redirect
                   Chassis node) which processes the DHCP
                   response(DHCPOFFER, DHCPACK) from the DHCP server.

                   When this action applied successfully on the DHCP
                   response packet, it updates the destination MAC and
                   destination IP in the packet and stores 1 in R.
                   <i>relay-ip</i> and <i>server-ip</i> are used to validate GIADDR
                   and SERVER-ID in the DHCP response packet.

                   When this action failed to apply on the packet, it
                   leaves the packet unchanged and stores 0 in R.

       <b>tags</b>: map of string-string pairs
              Key-value pairs that provide additional information to
              help ovn-controller processing the logical flow. Below are
              the tags used by ovn-controller.

              in_out_port
                     In the logical flow’s "match" column, if a logical
                     port P is compared with "inport" and the logical
                     flow is on a logical switch ingress pipeline, or if
                     P is compared with "outport" and the logical flow
                     is on a logical switch egress pipeline, and the
                     expression is combined with other expressions (if
                     any) using the operator &amp;&amp;, then the port P should
                     be added as the value in this tag. If there are
                     multiple logical ports meeting this criteria, one
                     of them can be added. ovn-controller uses this
                     information to skip parsing flows that are not
                     needed on the chassis. Failing to add the tag will
                     affect efficiency, while adding wrong value will
                     affect correctness.

       <b>controller_meter</b>: optional string
              The name of the meter in table <b>Meter </b>to be used for all
              packets that the logical flow might send to
              <b>ovn-controller</b>.

       <b>external_ids : stage-name</b>: optional string
              Human-readable name for this flow’s stage in the pipeline.

       <b>external_ids : stage-hint</b>: optional string, containing an uuid
              UUID of a <b>OVN_Northbound </b>record that caused this logical
              flow to be created. Currently used only for attribute of
              logical flows to northbound <b>ACL </b>records.

       <b>external_ids : source</b>: optional string
              Source file and line number of the code that added this
              flow to the pipeline.

     <i>Common Columns:</i>

       The overall purpose of these columns is described under <b>Common</b>
       <b>Columns </b>at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs
</pre> <h2>
Logical_DP_Group TABLE </h2>
<pre>
       Each row in this table represents a group of logical datapaths
       referenced by the <b>logical_dp_group </b>column in the <b>Logical_Flow</b>
       table.

   <b>Summary:</b>
       <b>datapaths                     </b>set of weak reference to
                                     <b>Datapath_Binding</b>s

   <b>Details:</b>
       <b>datapaths</b>: set of weak reference to <b>Datapath_Binding</b>s
              List of <b>Datapath_Binding </b>entries.
</pre> <h2>
Multicast_Group TABLE </h2>
<pre>
       The rows in this table define multicast groups of logical ports.
       Multicast groups allow a single packet transmitted over a tunnel
       to a hypervisor to be delivered to multiple VMs on that
       hypervisor, which uses bandwidth more efficiently.

       Each row in this table defines a logical multicast group numbered
       <b>tunnel_key </b>within <b>datapath</b>, whose logical ports are listed in the
       <b>ports </b>column.

   <b>Summary:</b>
       <b>datapath                      Datapath_Binding</b>
       <b>tunnel_key                    </b>integer, in range 32,768 to 65,535
       <b>name                          </b>string
       <b>ports                         </b>set of weak reference to
                                     <b>Port_Binding</b>s

   <b>Details:</b>
       <b>datapath</b>: <b>Datapath_Binding</b>
              The logical datapath in which the multicast group resides.

       <b>tunnel_key</b>: integer, in range 32,768 to 65,535
              The value used to designate this logical egress port in
              tunnel encapsulations. An index forces the key to be
              unique within the <b>datapath</b>. The unusual range ensures that
              multicast group IDs do not overlap with logical port IDs.

       <b>name</b>: string
              The logical multicast group’s name. An index forces the
              name to be unique within the <b>datapath</b>. Logical flows in
              the ingress pipeline may output to the group just as for
              individual logical ports, by assigning the group’s name to
              <b>outport </b>and executing an <b>output </b>action.

              Multicast group names and logical port names share a
              single namespace and thus should not overlap (but the
              database schema cannot enforce this). To try to avoid
              conflicts, <b>ovn-northd </b>uses names that begin with <b>_MC_</b>.

       <b>ports</b>: set of weak reference to <b>Port_Binding</b>s
              The logical ports included in the multicast group. All of
              these ports must be in the <b>datapath </b>logical datapath (but
              the database schema cannot enforce this).
</pre> <h2>
Mirror TABLE </h2>
<pre>
       Each row in this table represents a mirror that can be used for
       port mirroring. These mirrors are referenced by the <b>mirror_rules</b>
       column in the <b>Port_Binding </b>table.

   <b>Summary:</b>
       <b>name                          </b>string (must be unique within
                                     table)
       <b>filter                        </b>string, one of <b>both</b>, <b>from-lport</b>, or
                                     <b>to-lport</b>
       <b>sink                          </b>string
       <b>type                          </b>string, one of <b>erspan</b>, <b>gre</b>, or
                                     <b>local</b>
       <b>index                         </b>integer
       <b>external_ids                  </b>map of string-string pairs

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              Represents the name of the mirror.

       <b>filter</b>: string, one of <b>both</b>, <b>from-lport</b>, or <b>to-lport</b>
              The value of this field represents selection criteria of
              the mirror. <b>to-lport </b>mirrors the packets coming into
              logical port. <b>from-lport </b>mirrors the packets going out of
              logical port. <b>both </b>mirrors for both directions.

       <b>sink</b>: string
              The value of this field represents the destination/sink of
              the mirror. If the <i>type</i> is <b>gre </b>or <b>erspan</b>, the value
              indicates the tunnel remote IP (either IPv4 or IPv6). For
              a <i>type</i> of <b>local</b>, this field defines a local interface on
              the OVS integration bridge to be used as the mirror
              destination. The interface must possess external-
              ids:mirror-id that matches this string.

       <b>type</b>: string, one of <b>erspan</b>, <b>gre</b>, or <b>local</b>
              The value of this field specifies the mirror type - <b>gre</b>,
              <b>erspan </b>or <b>local</b>.

       <b>index</b>: integer
              The value of this field represents the tunnel ID. If the
              configured tunnel type is <b>gre</b>, this field represents the
              <b>GRE </b>key value and if the configured tunnel type is <b>erspan</b>
              it represents the <b>erspan_idx </b>value. It is ignored if the
              type is <b>local</b>.

       <b>external_ids</b>: map of string-string pairs
              See <b>External IDs </b>at the beginning of this document.
</pre> <h2>
Meter TABLE </h2>
<pre>
       Each row in this table represents a meter that can be used for
       QoS or rate-limiting.

   <b>Summary:</b>
       <b>name                          </b>string (must be unique within
                                     table)
       <b>unit                          </b>string, either <b>kbps </b>or <b>pktps</b>
       <b>bands                         </b>set of 1 or more <b>Meter_Band</b>s

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              A name for this meter.

              Names that begin with "__" (two underscores) are reserved
              for OVN internal use and should not be added manually.

       <b>unit</b>: string, either <b>kbps </b>or <b>pktps</b>
              The unit for <b>rate </b>and <b>burst_rate </b>parameters in the <b>bands</b>
              entry. <b>kbps </b>specifies kilobits per second, and <b>pktps</b>
              specifies packets per second.

       <b>bands</b>: set of 1 or more <b>Meter_Band</b>s
              The bands associated with this meter. Each band specifies
              a rate above which the band is to take the action <b>action</b>.
              If multiple bands’ rates are exceeded, then the band with
              the highest rate among the exceeded bands is selected.
</pre> <h2>
Meter_Band TABLE </h2>
<pre>
       Each row in this table represents a meter band which specifies
       the rate above which the configured action should be applied.
       These bands are referenced by the <b>bands </b>column in the <b>Meter</b>
       table.

   <b>Summary:</b>
       <b>action                        </b>string, must be <b>drop</b>
       <b>rate                          </b>integer, in range 1 to
                                     4,294,967,295
       <b>burst_size                    </b>integer, in range 0 to
                                     4,294,967,295

   <b>Details:</b>
       <b>action</b>: string, must be <b>drop</b>
              The action to execute when this band matches. The only
              supported action is <b>drop</b>.

       <b>rate</b>: integer, in range 1 to 4,294,967,295
              The rate limit for this band, in kilobits per second or
              bits per second, depending on whether the parent <b>Meter</b>
              entry’s <b>unit </b>column specified <b>kbps </b>or <b>pktps</b>.

       <b>burst_size</b>: integer, in range 0 to 4,294,967,295
              The maximum burst allowed for the band in kilobits or
              packets, depending on whether <b>kbps </b>or <b>pktps </b>was selected
              in the parent <b>Meter </b>entry’s <b>unit </b>column. If the size is
              zero, the switch is free to select some reasonable value
              depending on its configuration.
</pre> <h2>
Datapath_Binding TABLE </h2>
<pre>
       Each row in this table represents a logical datapath, which
       implements a logical pipeline among the ports in the <b>Port_Binding</b>
       table associated with it. In practice, the pipeline in a given
       logical datapath implements either a logical switch or a logical
       router.

       The main purpose of a row in this table is provide a physical
       binding for a logical datapath. A logical datapath does not have
       a physical location, so its physical binding information is
       limited: just <b>tunnel_key</b>. The rest of the data in this table does
       not affect packet forwarding.

   <b>Summary:</b>
       <b>tunnel_key                    </b>integer, in range 1 to 16,777,215
                                     (must be unique within table)
       <b>load_balancers                </b>set of uuids
       <i>OVN_Northbound Relationship:</i>
         <b>external_ids : logical-switch</b>
                                     optional string, containing an uuid
         <b>external_ids : logical-router</b>
                                     optional string, containing an uuid
         <b>external_ids : interconn-ts</b>
                                     optional string
         <i>Naming:</i>
            <b>external_ids : name      </b>optional string
            <b>external_ids : name2     </b>optional string
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs

   <b>Details:</b>
       <b>tunnel_key</b>: integer, in range 1 to 16,777,215 (must be unique
       within table)
              The tunnel key value to which the logical datapath is
              bound. The <b>Tunnel Encapsulation </b>section in
              <a href="../man7/ovn-architecture.7.html">ovn-architecture(7)</a> describes how tunnel keys are
              constructed for each supported encapsulation.

       <b>load_balancers</b>: set of uuids
              Not used anymore; kept for backwards compatibility of the
              schema.

     <i>OVN_Northbound Relationship:</i>

       Each row in <b>Datapath_Binding </b>is associated with some logical
       datapath. <b>ovn-northd </b>uses these keys to track the association of
       a logical datapath with concepts in the <b>OVN_Northbound </b>database.

       <b>external_ids : logical-switch</b>: optional string, containing an
       uuid
              For a logical datapath that represents a logical switch,
              <b>ovn-northd </b>stores in this key the UUID of the
              corresponding <b>Logical_Switch </b>row in the <b>OVN_Northbound</b>
              database.

       <b>external_ids : logical-router</b>: optional string, containing an
       uuid
              For a logical datapath that represents a logical router,
              <b>ovn-northd </b>stores in this key the UUID of the
              corresponding <b>Logical_Router </b>row in the <b>OVN_Northbound</b>
              database.

       <b>external_ids : interconn-ts</b>: optional string
              For a logical datapath that represents a logical switch
              that represents a transit switch for interconnection,
              <b>ovn-northd </b>stores in this key the value of the same
              <b>interconn-ts </b>key of the <b>external_ids </b>column of the
              corresponding <b>Logical_Switch </b>row in the <b>OVN_Northbound</b>
              database.

     <i>Naming:</i>

       <b>ovn-northd </b>copies these from the name fields in the
       <b>OVN_Northbound </b>database, either from <b>name </b>and
       <b>external_ids:neutron:router_name </b>in the <b>Logical_Router </b>table or
       from <b>name </b>and <b>external_ids:neutron:network_name </b>in the
       <b>Logical_Switch </b>table.

       <b>external_ids : name</b>: optional string
              A name for the logical datapath.

       <b>external_ids : name2</b>: optional string
              Another name for the logical datapath.

     <i>Common Columns:</i>

       The overall purpose of these columns is described under <b>Common</b>
       <b>Columns </b>at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs
</pre> <h2>
Port_Binding TABLE </h2>
<pre>
       Each row in this table binds a logical port to a realization. For
       most logical ports, this means binding to some physical location,
       for example by binding a logical port to a VIF that belongs to a
       VM running on a particular hypervisor. Other logical ports, such
       as logical patch ports, can be realized without a specific
       physical location, but their bindings are still expressed through
       rows in this table.

       For every <b>Logical_Switch_Port </b>record in <b>OVN_Northbound </b>database,
       <b>ovn-northd </b>creates a record in this table. <b>ovn-northd </b>populates
       and maintains every column except the <b>chassis </b>and <b>virtual_parent</b>
       columns, which it leaves empty in new records.

       <b>ovn-controller</b>/<b>ovn-controller-vtep </b>populates the <b>chassis </b>column
       for the records that identify the logical ports that are located
       on its hypervisor/gateway, which
       <b>ovn-controller</b>/<b>ovn-controller-vtep </b>in turn finds out by
       monitoring the local hypervisor’s Open_vSwitch database, which
       identifies logical ports via the conventions described in
       <b>IntegrationGuide.rst</b>. (The exceptions are for <b>Port_Binding</b>
       records with <b>type </b>of <b>l3gateway</b>, whose locations are identified by
       <b>ovn-northd </b>via the <b>options:l3gateway-chassis </b>column in this
       table. <b>ovn-controller </b>is still responsible to populate the
       <b>chassis </b>column.)

       <b>ovn-controller </b>also populates the <b>virtual_parent </b>column of
       records whose <b>type </b>is <b>virtual</b>.

       When a chassis shuts down gracefully, it should clean up the
       <b>chassis </b>column that it previously had populated. (This is not
       critical because resources hosted on the chassis are equally
       unreachable regardless of whether their rows are present.) To
       handle the case where a VM is shut down abruptly on one chassis,
       then brought up again on a different one,
       <b>ovn-controller</b>/<b>ovn-controller-vtep </b>must overwrite the <b>chassis</b>
       column with new information.

   <b>Summary:</b>
       <i>Core Features:</i>
         <b>datapath                    Datapath_Binding</b>
         <b>logical_port                </b>string (must be unique within
                                     table)
         <b>encap                       </b>optional weak reference to <b>Encap</b>
         <b>additional_encap            </b>set of weak reference to <b>Encap</b>s
         <b>chassis                     </b>optional weak reference to <b>Chassis</b>
         <b>additional_chassis          </b>set of weak reference to <b>Chassis</b>
         <b>gateway_chassis             </b>set of <b>Gateway_Chassis</b>es
         <b>ha_chassis_group            </b>optional <b>HA_Chassis_Group</b>
         <b>up                          </b>optional boolean
         <b>tunnel_key                  </b>integer, in range 1 to 32,767
         <b>mac                         </b>set of strings
         <b>port_security               </b>set of strings
         <b>type                        </b>string
         <b>requested_chassis           </b>optional weak reference to <b>Chassis</b>
         <b>requested_additional_chassis</b>
                                     set of weak reference to <b>Chassis</b>
       <b>mirror_rules                  </b>set of weak reference to <b>Mirror</b>s
       <i>Patch Options:</i>
         <b>options : peer              </b>optional string
         <b>nat_addresses               </b>set of strings
       <i>L3 Gateway Options:</i>
         <b>options : peer              </b>optional string
         <b>options : l3gateway-chassis</b>
                                     optional string
         <b>nat_addresses               </b>set of strings
       <i>Localnet Options:</i>
         <b>options : network_name      </b>optional string
         <b>tag                         </b>optional integer, in range 1 to
                                     4,095
       <i>L2 Gateway Options:</i>
         <b>options : network_name      </b>optional string
         <b>options : l2gateway-chassis</b>
                                     optional string
         <b>tag                         </b>optional integer, in range 1 to
                                     4,095
       <i>VTEP Options:</i>
         <b>options : vtep-physical-switch</b>
                                     optional string
         <b>options : vtep-logical-switch</b>
                                     optional string
       <i>VMI (or VIF) Options:</i>
         <b>options : requested-chassis</b>
                                     optional string
         <b>options : activation-strategy</b>
                                     optional string
         <b>options : additional-chassis-activated</b>
                                     optional string
         <b>options : iface-id-ver      </b>optional string
         <b>options : qos_min_rate      </b>optional string
         <b>options : qos_max_rate      </b>optional string
         <b>options : qos_burst         </b>optional string
         <b>options : qos_physical_network</b>
                                     optional string
         <b>options : qdisc_queue_id    </b>optional string, containing an
                                     integer, in range 1 to 61,440
       <i>Distributed Gateway Port Options:</i>
         <b>options : chassis-redirect-port</b>
                                     optional string
       <i>Chassis Redirect Options:</i>
         <b>options : distributed-port  </b>optional string
         <b>options : redirect-type     </b>optional string
         <b>options : always-redirect   </b>optional string
       <i>Nested Containers:</i>
         <b>parent_port                 </b>optional string
         <b>tag                         </b>optional integer, in range 1 to
                                     4,095
       <i>Virtual ports:</i>
         <b>virtual_parent              </b>optional string
       <i>Naming:</i>
         <b>external_ids : name         </b>optional string
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs

   <b>Details:</b>
     <i>Core Features:</i>

       <b>datapath</b>: <b>Datapath_Binding</b>
              The logical datapath to which the logical port belongs.

       <b>logical_port</b>: string (must be unique within table)
              A logical port. For a logical switch port, this is taken
              from <b>name </b>in the OVN_Northbound database’s
              <b>Logical_Switch_Port </b>table. For a logical router port, this
              is taken from <b>name </b>in the OVN_Northbound database’s
              <b>Logical_Router_port </b>table. (This means that logical switch
              ports and router port names must not share names in an OVN
              deployment.) OVN does not prescribe a particular format
              for the logical port ID.

       <b>encap</b>: optional weak reference to <b>Encap</b>
              Points to preferred encapsulation configuration to
              transmit logical dataplane packets to this chassis. The
              entry is reference to a <b>Encap </b>record.

       <b>additional_encap</b>: set of weak reference to <b>Encap</b>s
              Points to preferred encapsulation configuration to
              transmit logical dataplane packets to this additional
              chassis. The entry is reference to a <b>Encap </b>record. See
              also <b>additional_chassis</b>.

       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              The meaning of this column depends on the value of the
              <b>type </b>column. This is the meaning for each <b>type</b>

              (empty string)
                     The physical location of the logical port. To
                     successfully identify a chassis, this column must
                     be a <b>Chassis </b>record. This is populated by
                     <b>ovn-controller</b>.

              vtep   The physical location of the hardware_vtep gateway.
                     To successfully identify a chassis, this column
                     must be a <b>Chassis </b>record. This is populated by
                     <b>ovn-controller-vtep</b>.

              localnet
                     Always empty. A localnet port is realized on every
                     chassis that has connectivity to the corresponding
                     physical network.

              localport
                     Always empty. A localport port is present on every
                     chassis.

              l3gateway
                     The physical location of the L3 gateway. To
                     successfully identify a chassis, this column must
                     be a <b>Chassis </b>record. This is populated by
                     <b>ovn-controller </b>based on the value of the
                     <b>options:l3gateway-chassis </b>column in this table.

              l2gateway
                     The physical location of this L2 gateway. To
                     successfully identify a chassis, this column must
                     be a <b>Chassis </b>record. This is populated by
                     <b>ovn-controller </b>based on the value of the
                     <b>options:l2gateway-chassis </b>column in this table.

       <b>additional_chassis</b>: set of weak reference to <b>Chassis</b>
              The meaning of this column is the same as for the <b>chassis</b>.
              The column is used to track an additional physical
              location of the logical port. Used with regular (empty
              <b>type</b>) port bindings.

       <b>gateway_chassis</b>: set of <b>Gateway_Chassis</b>es
              A list of <b>Gateway_Chassis</b>.

              This should only be populated for ports with <b>type </b>set to
              <b>chassisredirect</b>. This column defines the list of chassis
              used as gateways where traffic will be redirected through.

       <b>ha_chassis_group</b>: optional <b>HA_Chassis_Group</b>
              This should only be populated for ports with <b>type </b>set to
              <b>chassisredirect</b>. This column defines the HA chassis group
              with a list of HA chassis used as gateways where traffic
              will be redirected through.

       <b>up</b>: optional boolean
              This is set to <b>true </b>whenever all OVS flows required by
              this Port_Binding have been installed. This is populated
              by <b>ovn-controller</b>.

       <b>tunnel_key</b>: integer, in range 1 to 32,767
              A number that represents the logical port in the key (e.g.
              STT key or Geneve TLV) field carried within tunnel
              protocol packets.

              The tunnel ID must be unique within the scope of a logical
              datapath.

       <b>mac</b>: set of strings
              This column is a misnomer as it may contain MAC addresses
              and IP addresses. It is copied from the <b>addresses </b>column
              in the <b>Logical_Switch_Port </b>table in the Northbound
              database. It follows the same format as that column.

       <b>port_security</b>: set of strings
              This column controls the addresses from which the host
              attached to the logical port (``the host’’) is allowed to
              send packets and to which it is allowed to receive
              packets. If this column is empty, all addresses are
              permitted.

              It is copied from the <b>port_security </b>column in the
              <b>Logical_Switch_Port </b>table in the Northbound database. It
              follows the same format as that column.

       <b>type</b>: string
              A type for this logical port. Logical ports can be used to
              model other types of connectivity into an OVN logical
              switch. The following types are defined:

              (empty string)
                     VM (or VIF) interface.

              <b>patch  </b>One of a pair of logical ports that act as if
                     connected by a patch cable. Useful for connecting
                     two logical datapaths, e.g. to connect a logical
                     router to a logical switch or to another logical
                     router.

              <b>l3gateway</b>
                     One of a pair of logical ports that act as if
                     connected by a patch cable across multiple chassis.
                     Useful for connecting a logical switch with a
                     Gateway router (which is only resident on a
                     particular chassis).

              <b>localnet</b>
                     A connection to a locally accessible network from
                     <b>ovn-controller </b>instances that have a corresponding
                     bridge mapping. A logical switch can have multiple
                     <b>localnet </b>ports attached. This type is used to model
                     direct connectivity to existing networks. In this
                     case, each chassis should have a mapping for one of
                     the physical networks only. Note: nothing said
                     above implies that a chassis cannot be plugged to
                     multiple physical networks as long as they belong
                     to different switches.

              <b>localport</b>
                     A connection to a local VIF. Traffic that arrives
                     on a <b>localport </b>is never forwarded over a tunnel to
                     another chassis. These ports are present on every
                     chassis and have the same address in all of them.
                     This is used to model connectivity to local
                     services that run on every hypervisor.

              <b>l2gateway</b>
                     An L2 connection to a physical network. The chassis
                     this <b>Port_Binding </b>is bound to will serve as an L2
                     gateway to the network named by
                     <b>options</b>:<b>network_name</b>.

              <b>vtep   </b>A port to a logical switch on a VTEP gateway
                     chassis. In order to get this port correctly
                     recognized by the OVN controller, the
                     <b>options</b>:<b>vtep-physical-switch </b>and
                     <b>options</b>:<b>vtep-logical-switch </b>must also be defined.

              <b>chassisredirect</b>
                     A logical port that represents a particular
                     instance, bound to a specific chassis, of an
                     otherwise distributed parent port (e.g. of type
                     <b>patch</b>). A <b>chassisredirect </b>port should never be used
                     as an <b>inport</b>. When an ingress pipeline sets the
                     <b>outport</b>, it may set the value to a logical port of
                     type <b>chassisredirect</b>. This will cause the packet to
                     be directed to a specific chassis to carry out the
                     egress pipeline. At the beginning of the egress
                     pipeline, the <b>outport </b>will be reset to the value of
                     the distributed port.

              <b>virtual</b>
                     Represents a logical port with an <b>virtual ip</b>. This
                     <b>virtual ip </b>can be configured on a logical port
                     (which is referred as virtual parent).

       <b>requested_chassis</b>: optional weak reference to <b>Chassis</b>
              This column exists so that the ovn-controller can
              effectively monitor all <b>Port_Binding </b>records destined for
              it, and is a supplement to the <b>options:requested-chassis</b>
              option. The option is still required so that the ovn-
              controller can check the CMS intent when the chassis
              pointed to does not currently exist, which for example
              occurs when the ovn-controller is stopped without passing
              the -restart argument. This column must be a <b>Chassis</b>
              record. This is populated by <b>ovn-northd </b>when the
              <b>options:requested-chassis </b>is defined and contains a string
              matching the name or hostname of an existing chassis. See
              also <b>requested_additional_chassis</b>.

       <b>requested_additional_chassis</b>: set of weak reference to <b>Chassis</b>
              This column exists so that the ovn-controller can
              effectively monitor all <b>Port_Binding </b>records destined for
              it, and is a supplement to the <b>options:requested-chassis</b>
              option when multiple chassis are listed. This column must
              be a list of <b>Chassis </b>records. This is populated by
              <b>ovn-northd </b>when the <b>options:requested-chassis </b>is defined
              as a list of chassis names or hostnames. See also
              <b>requested_chassis</b>.

       <b>mirror_rules</b>: set of weak reference to <b>Mirror</b>s
              Mirror rules that apply to the port binding. Please see
              the <b>Mirror </b>table.

     <i>Patch Options:</i>

       These options apply to logical ports with <b>type </b>of <b>patch</b>.

       <b>options : peer</b>: optional string
              The <b>logical_port </b>in the <b>Port_Binding </b>record for the other
              side of the patch. The named <b>logical_port </b>must specify
              this <b>logical_port </b>in its own <b>peer </b>option. That is, the two
              patch logical ports must have reversed <b>logical_port </b>and
              <b>peer </b>values.

       <b>nat_addresses</b>: set of strings
              MAC address followed by a list of SNAT and DNAT external
              IP addresses, followed by <b>is_chassis_resident("</b><i>lport</i><b>")</b>,
              where <i>lport</i> is the name of a logical port on the same
              chassis where the corresponding NAT rules are applied.
              This is used to send gratuitous ARPs for SNAT and DNAT
              external IP addresses via <b>localnet</b>, from the chassis where
              <i>lport</i> resides. Example: <b>80:fa:5b:06:72:b7 158.36.44.22</b>
              <b>158.36.44.24 is_chassis_resident("foo1")</b>. This would
              result in generation of gratuitous ARPs for IP addresses
              158.36.44.22 and 158.36.44.24 with a MAC address of
              80:fa:5b:06:72:b7 from the chassis where the logical port
              "foo1" resides.

     <i>L3 Gateway Options:</i>

       These options apply to logical ports with <b>type </b>of <b>l3gateway</b>.

       <b>options : peer</b>: optional string
              The <b>logical_port </b>in the <b>Port_Binding </b>record for the other
              side of the ’l3gateway’ port. The named <b>logical_port </b>must
              specify this <b>logical_port </b>in its own <b>peer </b>option. That is,
              the two ’l3gateway’ logical ports must have reversed
              <b>logical_port </b>and <b>peer </b>values.

       <b>options : l3gateway-chassis</b>: optional string
              The <b>chassis </b>in which the port resides.

       <b>nat_addresses</b>: set of strings
              MAC address of the <b>l3gateway </b>port followed by a list of
              SNAT and DNAT external IP addresses. This is used to send
              gratuitous ARPs for SNAT and DNAT external IP addresses
              via <b>localnet</b>. Example: <b>80:fa:5b:06:72:b7 158.36.44.22</b>
              <b>158.36.44.24</b>. This would result in generation of
              gratuitous ARPs for IP addresses 158.36.44.22 and
              158.36.44.24 with a MAC address of 80:fa:5b:06:72:b7. This
              is used in OVS version 2.8 and later versions.

     <i>Localnet Options:</i>

       These options apply to logical ports with <b>type </b>of <b>localnet</b>.

       <b>options : network_name</b>: optional string
              Required. <b>ovn-controller </b>uses the configuration entry
              <b>ovn-bridge-mappings </b>to determine how to connect to this
              network. <b>ovn-bridge-mappings </b>is a list of network names
              mapped to a local OVS bridge that provides access to that
              network. An example of configuring <b>ovn-bridge-mappings</b>
              would be: .IP
              <b>$ ovs-vsctl set open . external-ids:ovn-bridge-mappings=physnet1:br-eth0,physnet2:br-eth1</b>

              When a logical switch has a <b>localnet </b>port attached, every
              chassis that may have a local vif attached to that logical
              switch must have a bridge mapping configured to reach that
              <b>localnet</b>. Traffic that arrives on a <b>localnet </b>port is never
              forwarded over a tunnel to another chassis. If there are
              multiple <b>localnet </b>ports in a logical switch, each chassis
              should only have a single bridge mapping for one of the
              physical networks. Note: In case of multiple <b>localnet</b>
              ports, to provide interconnectivity between all VIFs
              located on different chassis with different fabric
              connectivity, the fabric should implement some form of
              routing between the segments.

       <b>tag</b>: optional integer, in range 1 to 4,095
              If set, indicates that the port represents a connection to
              a specific VLAN on a locally accessible network. The VLAN
              ID is used to match incoming traffic and is also added to
              outgoing traffic.

     <i>L2 Gateway Options:</i>

       These options apply to logical ports with <b>type </b>of <b>l2gateway</b>.

       <b>options : network_name</b>: optional string
              Required. <b>ovn-controller </b>uses the configuration entry
              <b>ovn-bridge-mappings </b>to determine how to connect to this
              network. <b>ovn-bridge-mappings </b>is a list of network names
              mapped to a local OVS bridge that provides access to that
              network. An example of configuring <b>ovn-bridge-mappings</b>
              would be: .IP
              <b>$ ovs-vsctl set open . external-ids:ovn-bridge-mappings=physnet1:br-eth0,physnet2:br-eth1</b>

              When a logical switch has a <b>l2gateway </b>port attached, the
              chassis that the <b>l2gateway </b>port is bound to must have a
              bridge mapping configured to reach the network identified
              by <b>network_name</b>.

       <b>options : l2gateway-chassis</b>: optional string
              Required. The <b>chassis </b>in which the port resides.

       <b>tag</b>: optional integer, in range 1 to 4,095
              If set, indicates that the gateway is connected to a
              specific VLAN on the physical network. The VLAN ID is used
              to match incoming traffic and is also added to outgoing
              traffic.

     <i>VTEP Options:</i>

       These options apply to logical ports with <b>type </b>of <b>vtep</b>.

       <b>options : vtep-physical-switch</b>: optional string
              Required. The name of the VTEP gateway.

       <b>options : vtep-logical-switch</b>: optional string
              Required. A logical switch name connected by the VTEP
              gateway. Must be set when <b>type </b>is <b>vtep</b>.

     <i>VMI (or VIF) Options:</i>

       These options apply to logical ports with <b>type </b>having (empty
       string)

       <b>options : requested-chassis</b>: optional string
              If set, identifies a specific chassis (by name or
              hostname) that is allowed to bind this port. Using this
              option will prevent thrashing between two chassis trying
              to bind the same port during a live migration. It can also
              prevent similar thrashing due to a mis-configuration, if a
              port is accidentally created on more than one chassis.

              If set to a comma separated list, the first entry
              identifies the main chassis and the rest are one or more
              additional chassis that are allowed to bind the same port.

              When multiple chassis are set for the port, and the
              logical switch is connected to an external network through
              a <b>localnet </b>port, tunneling is enforced for the port to
              guarantee delivery of packets directed to the port to all
              its locations. This has MTU implications because the
              network used for tunneling must have MTU larger than
              <b>localnet </b>for stable connectivity.

       <b>options : activation-strategy</b>: optional string
              If used with multiple chassis set in <b>requested-chassis</b>,
              specifies an activation strategy for all additional
              chassis. By default, no activation strategy is used,
              meaning additional port locations are immediately
              available for use. When set to "rarp", the port is blocked
              for ingress and egress communication until a RARP packet
              is sent from a new location. The "rarp" strategy is useful
              in live migration scenarios for virtual machines.

       <b>options : additional-chassis-activated</b>: optional string
              When <b>activation-strategy </b>is set, this option indicates
              that the port was activated using the strategy specified.

       <b>options : iface-id-ver</b>: optional string
              If set, this port will be bound by <b>ovn-controller </b>only if
              this same key and value is configured in the <b>external_ids</b>
              column in the Open_vSwitch database’s <b>Interface </b>table.

       <b>options : qos_min_rate</b>: optional string
              If set, indicates the minimum guaranteed rate available
              for data sent from this interface, in bit/s.

       <b>options : qos_max_rate</b>: optional string
              If set, indicates the maximum rate for data sent from this
              interface, in bit/s. The traffic will be shaped according
              to this limit.

       <b>options : qos_burst</b>: optional string
              If set, indicates the maximum burst size for data sent
              from this interface, in bits.

       <b>options : qos_physical_network</b>: optional string
              If set, indicates the name of the egress network name
              where traffic shaping will be applied.

       <b>options : qdisc_queue_id</b>: optional string, containing an integer,
       in range 1 to 61,440
              Indicates the queue number on the physical device. This is
              same as the <b>queue_id </b>used in OpenFlow in <b>struct</b>
              <b>ofp_action_enqueue</b>.

     <i>Distributed Gateway Port Options:</i>

       These options apply to the distributed parent ports of logical
       ports with <b>type </b>of <b>chasssisredirect</b>.

       <b>options : chassis-redirect-port</b>: optional string
              The name of the chassis redirect port derived from this
              port if this port is a distributed parent of a chassis
              redirect port.

     <i>Chassis Redirect Options:</i>

       These options apply to logical ports with <b>type </b>of
       <b>chassisredirect</b>.

       <b>options : distributed-port</b>: optional string
              The name of the distributed port for which this
              <b>chassisredirect </b>port represents a particular instance.

       <b>options : redirect-type</b>: optional string
              The value is copied from the column <b>options </b>in the
              OVN_Northbound database’s <b>Logical_Router_Port </b>table for
              the distributed parent of this port.

       <b>options : always-redirect</b>: optional string
              A boolean option that is set to true if the distributed
              parent of this chassis redirect port does not need
              distributed processing.

     <i>Nested Containers:</i>

       These columns support containers nested within a VM.
       Specifically, they are used when <b>type </b>is empty and <b>logical_port</b>
       identifies the interface of a container spawned inside a VM. They
       are empty for containers or VMs that run directly on a
       hypervisor.

       <b>parent_port</b>: optional string
              This is taken from <b>parent_name </b>in the OVN_Northbound
              database’s <b>Logical_Switch_Port </b>table.

       <b>tag</b>: optional integer, in range 1 to 4,095
              Identifies the VLAN tag in the network traffic associated
              with that container’s network interface.

              This column is used for a different purpose when <b>type </b>is
              <b>localnet </b>(see <b>Localnet Options</b>, above) or <b>l2gateway </b>(see
              <b>L2 Gateway Options</b>, above).

     <i>Virtual ports:</i>

       <b>virtual_parent</b>: optional string
              This column is set by <b>ovn-controller </b>with one of the value
              from the <b>options:virtual-parents </b>in the OVN_Northbound
              database’s <b>Logical_Switch_Port </b>table when the OVN action
              <b>bind_vport </b>is executed. <b>ovn-controller </b>also sets the
              <b>chassis </b>column when it executes this action with its
              chassis id.

              <b>ovn-controller </b>sets this column only if the <b>type </b>is
              "virtual".

     <i>Naming:</i>

       <b>external_ids : name</b>: optional string
              For a logical switch port, <b>ovn-northd </b>copies this from
              <b>external_ids:neutron:port_name </b>in the <b>Logical_Switch_Port</b>
              table in the OVN_Northbound database, if it is a nonempty
              string.

              For a logical switch port, <b>ovn-northd </b>does not currently
              set this key.

     <i>Common Columns:</i>

       <b>external_ids</b>: map of string-string pairs
              See <b>External IDs </b>at the beginning of this document.

              The <b>ovn-northd </b>program populates this column with all
              entries into the <b>external_ids </b>column of the
              <b>Logical_Switch_Port </b>and <b>Logical_Router_Port </b>tables of the
              <b>OVN_Northbound </b>database.
</pre> <h2>
MAC_Binding TABLE </h2>
<pre>
       Each row in this table specifies a binding from an IP address to
       an Ethernet address that has been discovered through ARP (for
       IPv4) or neighbor discovery (for IPv6). This table is primarily
       used to discover bindings on physical networks, because IP-to-MAC
       bindings for virtual machines are usually populated statically
       into the <b>Port_Binding </b>table.

       This table expresses a functional relationship:
       <b>MAC_Binding</b>(<b>logical_port</b>, <b>ip</b>) = <b>mac</b>.

       In outline, the lifetime of a logical router’s MAC binding looks
       like this:

              1.  On hypervisor 1, a logical router determines that a
                  packet should be forwarded to IP address <i>A</i> on one of
                  its router ports. It uses its logical flow table to
                  determine that <i>A</i> lacks a static IP-to-MAC binding and
                  the <b>get_arp </b>action to determine that it lacks a
                  dynamic IP-to-MAC binding.

              2.  Using an OVN logical <b>arp </b>action, the logical router
                  generates and sends a broadcast ARP request to the
                  router port. It drops the IP packet.

              3.  The logical switch attached to the router port
                  delivers the ARP request to all of its ports. (It
                  might make sense to deliver it only to ports that have
                  no static IP-to-MAC bindings, but this could also be
                  surprising behavior.)

              4.  A host or VM on hypervisor 2 (which might be the same
                  as hypervisor 1) attached to the logical switch owns
                  the IP address in question. It composes an ARP reply
                  and unicasts it to the logical router port’s Ethernet
                  address.

              5.  The logical switch delivers the ARP reply to the
                  logical router port.

              6.  The logical router flow table executes a <b>put_arp</b>
                  action. To record the IP-to-MAC binding,
                  <b>ovn-controller </b>adds a row to the <b>MAC_Binding </b>table.

              7.  On hypervisor 1, <b>ovn-controller </b>receives the updated
                  <b>MAC_Binding </b>table from the OVN southbound database.
                  The next packet destined to <i>A</i> through the logical
                  router is sent directly to the bound Ethernet address.

   <b>Summary:</b>
       <b>logical_port                  </b>string
       <b>ip                            </b>string
       <b>mac                           </b>string
       <b>timestamp                     </b>integer
       <b>datapath                      Datapath_Binding</b>

   <b>Details:</b>
       <b>logical_port</b>: string
              The logical port on which the binding was discovered.

       <b>ip</b>: string
              The bound IP address.

       <b>mac</b>: string
              The Ethernet address to which the IP is bound.

       <b>timestamp</b>: integer
              The timestamp in msec when the MAC binding was added or
              updated. Records that existed before this column will have
              0.

       <b>datapath</b>: <b>Datapath_Binding</b>
              The logical datapath to which the logical port belongs.
</pre> <h2>
DHCP_Options TABLE </h2>
<pre>
       Each row in this table stores the DHCP Options supported by
       native OVN DHCP. <b>ovn-northd </b>populates this table with the
       supported DHCP options. <b>ovn-controller </b>looks up this table to get
       the DHCP codes of the DHCP options defined in the "put_dhcp_opts"
       action. Please refer to the RFC 2132
       <b>"https://tools.ietf.org/html/rfc2132" </b>for the possible list of
       DHCP options that can be defined here.

   <b>Summary:</b>
       <b>name                          </b>string
       <b>code                          </b>integer, in range 0 to 254
       <b>type                          </b>string, one of <b>bool</b>, <b>domains</b>,
                                     <b>host_id</b>, <b>ipv4</b>, <b>static_routes</b>, <b>str</b>,
                                     <b>uint16</b>, <b>uint32</b>, or <b>uint8</b>

   <b>Details:</b>
       <b>name</b>: string
              Name of the DHCP option.

              Example. name="router"

       <b>code</b>: integer, in range 0 to 254
              DHCP option code for the DHCP option as defined in the RFC
              2132.

              Example. code=3

       <b>type</b>: string, one of <b>bool</b>, <b>domains</b>, <b>host_id</b>, <b>ipv4</b>, <b>static_routes</b>,
       <b>str</b>, <b>uint16</b>, <b>uint32</b>, or <b>uint8</b>
              Data type of the DHCP option code.

              <b>value: bool</b>
                     This indicates that the value of the DHCP option is
                     a bool.

                     Example. "name=ip_forward_enable", "code=19",
                     "type=bool".

                     put_dhcp_opts(..., ip_forward_enable = 1,...)

              <b>value: uint8</b>
                     This indicates that the value of the DHCP option is
                     an unsigned int8 (8 bits)

                     Example. "name=default_ttl", "code=23",
                     "type=uint8".

                     put_dhcp_opts(..., default_ttl = 50,...)

              <b>value: uint16</b>
                     This indicates that the value of the DHCP option is
                     an unsigned int16 (16 bits).

                     Example. "name=mtu", "code=26", "type=uint16".

                     put_dhcp_opts(..., mtu = 1450,...)

              <b>value: uint32</b>
                     This indicates that the value of the DHCP option is
                     an unsigned int32 (32 bits).

                     Example. "name=lease_time", "code=51",
                     "type=uint32".

                     put_dhcp_opts(..., lease_time = 86400,...)

              <b>value: ipv4</b>
                     This indicates that the value of the DHCP option is
                     an IPv4 address or addresses.

                     Example. "name=router", "code=3", "type=ipv4".

                     put_dhcp_opts(..., router = 10.0.0.1,...)

                     Example. "name=dns_server", "code=6", "type=ipv4".

                     put_dhcp_opts(..., dns_server = {8.8.8.8
                     7.7.7.7},...)

              <b>value: static_routes</b>
                     This indicates that the value of the DHCP option
                     contains a pair of IPv4 route and next hop
                     addresses.

                     Example. "name=classless_static_route", "code=121",
                     "type=static_routes".

                     put_dhcp_opts(..., classless_static_route =
                     {30.0.0.0/24,10.0.0.4,0.0.0.0/0,10.0.0.1}...)

              <b>value: str</b>
                     This indicates that the value of the DHCP option is
                     a string.

                     Example. "name=host_name", "code=12", "type=str".

              <b>value: host_id</b>
                     This indicates that the value of the DHCP option is
                     a host_id. It can either be a host_name or an IP
                     address.

                     Example. "name=tftp_server", "code=66",
                     "type=host_id".

              <b>value: domains</b>
                     This indicates that the value of the DHCP option is
                     a domain name or a comma separated list of domain
                     names.

                     Example. "name=domain_search_list", "code=119",
                     "type=domains".
</pre> <h2>
DHCPv6_Options TABLE </h2>
<pre>
       Each row in this table stores the DHCPv6 Options supported by
       native OVN DHCPv6. <b>ovn-northd </b>populates this table with the
       supported DHCPv6 options. <b>ovn-controller </b>looks up this table to
       get the DHCPv6 codes of the DHCPv6 options defined in the
       <b>put_dhcpv6_opts </b>action. Please refer to RFC 3315 and RFC 3646 for
       the list of DHCPv6 options that can be defined here.

   <b>Summary:</b>
       <b>name                          </b>string
       <b>code                          </b>integer, in range 0 to 254
       <b>type                          </b>string, one of <b>domain</b>, <b>ipv6</b>, <b>mac</b>,
                                     or <b>str</b>

   <b>Details:</b>
       <b>name</b>: string
              Name of the DHCPv6 option.

              Example. name="ia_addr"

       <b>code</b>: integer, in range 0 to 254
              DHCPv6 option code for the DHCPv6 option as defined in the
              appropriate RFC.

              Example. code=3

       <b>type</b>: string, one of <b>domain</b>, <b>ipv6</b>, <b>mac</b>, or <b>str</b>
              Data type of the DHCPv6 option code.

              <b>value: ipv6</b>
                     This indicates that the value of the DHCPv6 option
                     is an IPv6 address(es).

                     Example. "name=ia_addr", "code=5", "type=ipv6".

                     put_dhcpv6_opts(..., ia_addr = ae70::4,...)

              <b>value: str</b>
                     This indicates that the value of the DHCPv6 option
                     is a string.

                     Example. "name=domain_search", "code=24",
                     "type=str".

                     put_dhcpv6_opts(..., domain_search =
                     ovn.domain,...)

              <b>value: mac</b>
                     This indicates that the value of the DHCPv6 option
                     is a MAC address.

                     Example. "name=server_id", "code=2", "type=mac".

                     put_dhcpv6_opts(..., server_id =
                     01:02:03:04L05:06,...)
</pre> <h2>
Connection TABLE </h2>
<pre>
       Configuration for a database connection to an Open vSwitch
       database (OVSDB) client.

       This table primarily configures the Open vSwitch database server
       (<b>ovsdb-server</b>).

       The Open vSwitch database server can initiate and maintain active
       connections to remote clients. It can also listen for database
       connections.

   <b>Summary:</b>
       <i>Core Features:</i>
         <b>target                      </b>string (must be unique within
                                     table)
         <b>read_only                   </b>boolean
         <b>role                        </b>string
       <i>Client Failure Detection and Handling:</i>
         <b>max_backoff                 </b>optional integer, at least 1,000
         <b>inactivity_probe            </b>optional integer
       <i>Status:</i>
         <b>is_connected                </b>boolean
         <b>status : last_error         </b>optional string
         <b>status : state              </b>optional string, one of <b>ACTIVE</b>,
                                     <b>BACKOFF</b>, <b>CONNECTING</b>, <b>IDLE</b>, or <b>VOID</b>
         <b>status : sec_since_connect  </b>optional string, containing an
                                     integer, at least 0
         <b>status : sec_since_disconnect</b>
                                     optional string, containing an
                                     integer, at least 0
         <b>status : locks_held         </b>optional string
         <b>status : locks_waiting      </b>optional string
         <b>status : locks_lost         </b>optional string
         <b>status : n_connections      </b>optional string, containing an
                                     integer, at least 2
         <b>status : bound_port         </b>optional string, containing an
                                     integer
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs
         <b>other_config                </b>map of string-string pairs

   <b>Details:</b>
     <i>Core Features:</i>

       <b>target</b>: string (must be unique within table)
              Connection methods for clients.

              The following connection methods are currently supported:

              <b>ssl:</b><i>host</i>[<b>:</b><i>port</i>]
                     The specified SSL <i>port</i> on the given <i>host</i>, which can
                     either be a DNS name (if built with unbound
                     library) or an IP address. A valid SSL
                     configuration must be provided when this form is
                     used, this configuration can be specified via
                     command-line options or the <b>SSL </b>table.

                     If <i>port</i> is not specified, it defaults to 6640.

                     SSL support is an optional feature that is not
                     always built as part of Open vSwitch.

              <b>tcp:</b><i>host</i>[<b>:</b><i>port</i>]
                     The specified TCP <i>port</i> on the given <i>host</i>, which can
                     either be a DNS name (if built with unbound
                     library) or an IP address (IPv4 or IPv6). If <i>host</i>
                     is an IPv6 address, wrap it in square brackets,
                     e.g. <b>tcp:[::1]:6640</b>.

                     If <i>port</i> is not specified, it defaults to 6640.

              <b>pssl:</b>[<i>port</i>][<b>:</b><i>host</i>]
                     Listens for SSL connections on the specified TCP
                     <i>port</i>. Specify 0 for <i>port</i> to have the kernel
                     automatically choose an available port. If <i>host</i>,
                     which can either be a DNS name (if built with
                     unbound library) or an IP address, is specified,
                     then connections are restricted to the resolved or
                     specified local IP address (either IPv4 or IPv6
                     address). If <i>host</i> is an IPv6 address, wrap in
                     square brackets, e.g. <b>pssl:6640:[::1]</b>. If <i>host</i> is
                     not specified then it listens only on IPv4 (but not
                     IPv6) addresses. A valid SSL configuration must be
                     provided when this form is used, this can be
                     specified either via command-line options or the
                     <b>SSL </b>table.

                     If <i>port</i> is not specified, it defaults to 6640.

                     SSL support is an optional feature that is not
                     always built as part of Open vSwitch.

              <b>ptcp:</b>[<i>port</i>][<b>:</b><i>host</i>]
                     Listens for connections on the specified TCP <i>port</i>.
                     Specify 0 for <i>port</i> to have the kernel automatically
                     choose an available port. If <i>host</i>, which can either
                     be a DNS name (if built with unbound library) or an
                     IP address, is specified, then connections are
                     restricted to the resolved or specified local IP
                     address (either IPv4 or IPv6 address). If <i>host</i> is
                     an IPv6 address, wrap it in square brackets, e.g.
                     <b>ptcp:6640:[::1]</b>. If <i>host</i> is not specified then it
                     listens only on IPv4 addresses.

                     If <i>port</i> is not specified, it defaults to 6640.

              When multiple clients are configured, the <b>target </b>values
              must be unique. Duplicate <b>target </b>values yield unspecified
              results.

       <b>read_only</b>: boolean
              <b>true </b>to restrict these connections to read-only
              transactions, <b>false </b>to allow them to modify the database.

       <b>role</b>: string
              String containing role name for this connection entry.

     <i>Client Failure Detection and Handling:</i>

       <b>max_backoff</b>: optional integer, at least 1,000
              Maximum number of milliseconds to wait between connection
              attempts. Default is implementation-specific.

       <b>inactivity_probe</b>: optional integer
              Maximum number of milliseconds of idle time on connection
              to the client before sending an inactivity probe message.
              If Open vSwitch does not communicate with the client for
              the specified number of seconds, it will send a probe. If
              a response is not received for the same additional amount
              of time, Open vSwitch assumes the connection has been
              broken and attempts to reconnect. Default is
              implementation-specific. A value of 0 disables inactivity
              probes.

     <i>Status:</i>

       Key-value pair of <b>is_connected </b>is always updated. Other key-value
       pairs in the status columns may be updated depends on the <b>target</b>
       type.

       When <b>target </b>specifies a connection method that listens for
       inbound connections (e.g. <b>ptcp: </b>or <b>punix:</b>), both <b>n_connections</b>
       and <b>is_connected </b>may also be updated while the remaining key-
       value pairs are omitted.

       On the other hand, when <b>target </b>specifies an outbound connection,
       all key-value pairs may be updated, except the above-mentioned
       two key-value pairs associated with inbound connection targets.
       They are omitted.

       <b>is_connected</b>: boolean
              <b>true </b>if currently connected to this client, <b>false</b>
              otherwise.

       <b>status : last_error</b>: optional string
              A human-readable description of the last error on the
              connection to the manager; i.e. <b>strerror(errno)</b>. This key
              will exist only if an error has occurred.

       <b>status : state</b>: optional string, one of <b>ACTIVE</b>, <b>BACKOFF</b>,
       <b>CONNECTING</b>, <b>IDLE</b>, or <b>VOID</b>
              The state of the connection to the manager:

              <b>VOID   </b>Connection is disabled.

              <b>BACKOFF</b>
                     Attempting to reconnect at an increasing period.

              <b>CONNECTING</b>
                     Attempting to connect.

              <b>ACTIVE </b>Connected, remote host responsive.

              <b>IDLE   </b>Connection is idle. Waiting for response to keep-
                     alive.

              These values may change in the future. They are provided
              only for human consumption.

       <b>status : sec_since_connect</b>: optional string, containing an
       integer, at least 0
              The amount of time since this client last successfully
              connected to the database (in seconds). Value is empty if
              client has never successfully been connected.

       <b>status : sec_since_disconnect</b>: optional string, containing an
       integer, at least 0
              The amount of time since this client last disconnected
              from the database (in seconds). Value is empty if client
              has never disconnected.

       <b>status : locks_held</b>: optional string
              Space-separated list of the names of OVSDB locks that the
              connection holds. Omitted if the connection does not hold
              any locks.

       <b>status : locks_waiting</b>: optional string
              Space-separated list of the names of OVSDB locks that the
              connection is currently waiting to acquire. Omitted if the
              connection is not waiting for any locks.

       <b>status : locks_lost</b>: optional string
              Space-separated list of the names of OVSDB locks that the
              connection has had stolen by another OVSDB client. Omitted
              if no locks have been stolen from this connection.

       <b>status : n_connections</b>: optional string, containing an integer,
       at least 2
              When <b>target </b>specifies a connection method that listens for
              inbound connections (e.g. <b>ptcp: </b>or <b>pssl:</b>) and more than
              one connection is actually active, the value is the number
              of active connections. Otherwise, this key-value pair is
              omitted.

       <b>status : bound_port</b>: optional string, containing an integer
              When <b>target </b>is <b>ptcp: </b>or <b>pssl:</b>, this is the TCP port on
              which the OVSDB server is listening. (This is particularly
              useful when <b>target </b>specifies a port of 0, allowing the
              kernel to choose any available port.)

     <i>Common Columns:</i>

       The overall purpose of these columns is described under <b>Common</b>
       <b>Columns </b>at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs

       <b>other_config</b>: map of string-string pairs
</pre> <h2>
SSL TABLE </h2>
<pre>
       SSL configuration for ovn-sb database access.

   <b>Summary:</b>
       <b>private_key                   </b>string
       <b>certificate                   </b>string
       <b>ca_cert                       </b>string
       <b>bootstrap_ca_cert             </b>boolean
       <b>ssl_protocols                 </b>string
       <b>ssl_ciphers                   </b>string
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs

   <b>Details:</b>
       <b>private_key</b>: string
              Name of a PEM file containing the private key used as the
              switch’s identity for SSL connections to the controller.

       <b>certificate</b>: string
              Name of a PEM file containing a certificate, signed by the
              certificate authority (CA) used by the controller and
              manager, that certifies the switch’s private key,
              identifying a trustworthy switch.

       <b>ca_cert</b>: string
              Name of a PEM file containing the CA certificate used to
              verify that the switch is connected to a trustworthy
              controller.

       <b>bootstrap_ca_cert</b>: boolean
              If set to <b>true</b>, then Open vSwitch will attempt to obtain
              the CA certificate from the controller on its first SSL
              connection and save it to the named PEM file. If it is
              successful, it will immediately drop the connection and
              reconnect, and from then on all SSL connections must be
              authenticated by a certificate signed by the CA
              certificate thus obtained. <b>This option exposes the SSL</b>
              <b>connection to a man-in-the-middle attack obtaining the</b>
              <b>initial CA certificate. </b>It may still be useful for
              bootstrapping.

       <b>ssl_protocols</b>: string
              List of SSL protocols to be enabled for SSL connections.
              The default when this option is omitted is
              <b>TLSv1,TLSv1.1,TLSv1.2</b>.

       <b>ssl_ciphers</b>: string
              List of ciphers (in OpenSSL cipher string format) to be
              supported for SSL connections. The default when this
              option is omitted is <b>HIGH:!aNULL:!MD5</b>.

     <i>Common Columns:</i>

       The overall purpose of these columns is described under <b>Common</b>
       <b>Columns </b>at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs
</pre> <h2>
DNS TABLE </h2>
<pre>
       Each row in this table stores the DNS records. The OVN action
       <b>dns_lookup </b>uses this table for DNS resolution.

   <b>Summary:</b>
       <b>records                       </b>map of string-string pairs
       <b>datapaths                     </b>set of 1 or more <b>Datapath_Binding</b>s
       <b>options : ovn-owned           </b>optional string
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs

   <b>Details:</b>
       <b>records</b>: map of string-string pairs
              Key-value pair of DNS records with <b>DNS query name </b>as the
              key and a string of IP address(es) separated by comma or
              space as the value. ovn-northd stores the DNS query name
              in all lowercase in order to facilitate case-insensitive
              lookups.

              <b>Example:  </b>"vm1.ovn.org" = "10.0.0.4 aef0::4"

       <b>datapaths</b>: set of 1 or more <b>Datapath_Binding</b>s
              The DNS records defined in the column <b>records </b>will be
              applied only to the DNS queries originating from the
              datapaths defined in this column.

       <b>options : ovn-owned</b>: optional string
              This column indicates that all the <b>Domains </b>in this table
              are owned by OVN, and all <b>DNS queries </b>for those domains
              will be answered locally by either an IP address or <b>DNS</b>
              <b>rejection</b>.

     <i>Common Columns:</i>

       <b>external_ids</b>: map of string-string pairs
              See <b>External IDs </b>at the beginning of this document.
</pre> <h2>
RBAC_Role TABLE </h2>
<pre>
       Role table for role-based access controls.

   <b>Summary:</b>
       <b>name                          </b>string
       <b>permissions                   </b>map of string-weak reference to
                                     <b>RBAC_Permission </b>pairs

   <b>Details:</b>
       <b>name</b>: string
              The role name, corresponding to the <b>role </b>column in the
              <b>Connection </b>table.

       <b>permissions</b>: map of string-weak reference to <b>RBAC_Permission</b>
       pairs
              A mapping of table names to rows in the <b>RBAC_Permission</b>
              table.
</pre> <h2>
RBAC_Permission TABLE </h2>
<pre>
       Permissions table for role-based access controls.

   <b>Summary:</b>
       <b>table                         </b>string
       <b>authorization                 </b>set of strings
       <b>insert_delete                 </b>boolean
       <b>update                        </b>set of strings

   <b>Details:</b>
       <b>table</b>: string
              Name of table to which this row applies.

       <b>authorization</b>: set of strings
              Set of strings identifying columns and column:key pairs to
              be compared with client ID. At least one match is required
              in order to be authorized. A zero-length string is treated
              as a special value indicating all clients should be
              considered authorized.

       <b>insert_delete</b>: boolean
              When "true", row insertions and authorized row deletions
              are permitted.

       <b>update</b>: set of strings
              Set of strings identifying columns and column:key pairs
              that authorized clients are allowed to modify.
</pre> <h2>
Gateway_Chassis TABLE </h2>
<pre>
       Association of <b>Port_Binding </b>rows of <b>type chassisredirect </b>to a
       <b>Chassis</b>. The traffic going out through a specific <b>chassisredirect</b>
       port will be redirected to a chassis, or a set of them in high
       availability configurations.

   <b>Summary:</b>
       <b>name                          </b>string (must be unique within
                                     table)
       <b>chassis                       </b>optional weak reference to <b>Chassis</b>
       <b>priority                      </b>integer, in range 0 to 32,767
       <b>options                       </b>map of string-string pairs
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              Name of the <b>Gateway_Chassis</b>.

              A suggested, but not required naming convention is
              <b>${port_name}_${chassis_name}</b>.

       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              The <b>Chassis </b>to which we send the traffic.

       <b>priority</b>: integer, in range 0 to 32,767
              This is the priority the specific <b>Chassis </b>among all
              Gateway_Chassis belonging to the same <b>Port_Binding</b>.

       <b>options</b>: map of string-string pairs
              Reserved for future use.

     <i>Common Columns:</i>

       The overall purpose of these columns is described under <b>Common</b>
       <b>Columns </b>at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs
</pre> <h2>
HA_Chassis TABLE </h2>
<pre>
   <b>Summary:</b>
       <b>chassis                       </b>optional weak reference to <b>Chassis</b>
       <b>priority                      </b>integer, in range 0 to 32,767
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs

   <b>Details:</b>
       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              The <b>Chassis </b>which provides the HA functionality.

       <b>priority</b>: integer, in range 0 to 32,767
              Priority of the HA chassis. Chassis with highest priority
              will be the active chassis in the HA chassis group.

     <i>Common Columns:</i>

       <b>external_ids</b>: map of string-string pairs
              See <b>External IDs </b>at the beginning of this document.
</pre> <h2>
HA_Chassis_Group TABLE </h2>
<pre>
       Table representing a group of chassis which can provide High
       availability services. Each chassis in the group is represented
       by the table <b>HA_Chassis</b>. The HA chassis with highest priority
       will be the active chassis of this group. If the active chassis
       failover is detected, the HA chassis with the next higher
       priority takes over the responsibility of providing the HA. If
       <b>ha_chassis_group </b>column of the table <b>Port_Binding </b>references this
       table, then this HA chassis group provides the gateway
       functionality and redirects the gateway traffic to the active
       chassis of this group.

   <b>Summary:</b>
       <b>name                          </b>string (must be unique within
                                     table)
       <b>ha_chassis                    </b>set of <b>HA_Chassis</b>es
       <b>ref_chassis                   </b>set of weak reference to <b>Chassis</b>
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              Name of the <b>HA_Chassis_Group</b>. Name should be unique.

       <b>ha_chassis</b>: set of <b>HA_Chassis</b>es
              A list of <b>HA_Chassis </b>which belongs to this group.

       <b>ref_chassis</b>: set of weak reference to <b>Chassis</b>
              The set of <b>Chassis </b>that reference this HA chassis group.
              To determine the correct <b>Chassis</b>, find the <b>chassisredirect</b>
              type <b>Port_Binding </b>that references this <b>HA_Chassis_Group</b>.
              This <b>Port_Binding </b>is derived from some particular logical
              router. Starting from that LR, find the set of all logical
              switches and routers connected to it, directly or
              indirectly, across router ports that link one LRP to
              another or to a LSP. For each LSP in these logical
              switches, find the corresponding <b>Port_Binding </b>and add its
              bound <b>Chassis </b>(if any) to <b>ref_chassis</b>.

     <i>Common Columns:</i>

       <b>external_ids</b>: map of string-string pairs
              See <b>External IDs </b>at the beginning of this document.
</pre> <h2>
Controller_Event TABLE </h2>
<pre>
       Database table used by <b>ovn-controller </b>to report CMS related
       events. Please note there is no guarantee a given event is
       written exactly once in the db. It is CMS responsibility to
       squash duplicated lines or to filter out duplicated events

   <b>Summary:</b>
       <b>event_type                    </b>string, must be <b>empty_lb_backends</b>
       <b>event_info                    </b>map of string-string pairs
       <b>chassis                       </b>optional weak reference to <b>Chassis</b>
       <b>seq_num                       </b>integer

   <b>Details:</b>
       <b>event_type</b>: string, must be <b>empty_lb_backends</b>
              Event type occurred

       <b>event_info</b>: map of string-string pairs
              Key-value pairs used to specify event info to the CMS.
              Possible values are:

              •      <b>vip</b>: VIP reported for the <b>empty_lb_backends </b>event

              •      <b>protocol</b>: Transport protocol reported for the
                     <b>empty_lb_backends </b>event

              •      <b>load_balancer</b>: UUID of the load balancer reported
                     for the <b>empty_lb_backends </b>event

       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              This column is a <b>Chassis </b>record to identify the chassis
              that has managed a given event.

       <b>seq_num</b>: integer
              Event sequence number. Global counter for controller
              generated events. It can be used by the CMS to detect
              possible duplication of the same event.
</pre> <h2>
IP_Multicast TABLE </h2>
<pre>
       IP Multicast configuration options. For now only applicable to
       IGMP.

   <b>Summary:</b>
       <b>datapath                      </b>weak reference to <b>Datapath_Binding</b>
                                     (must be unique within table)
       <b>enabled                       </b>optional boolean
       <b>querier                       </b>optional boolean
       <b>table_size                    </b>optional integer
       <b>idle_timeout                  </b>optional integer
       <b>query_interval                </b>optional integer
       <b>seq_no                        </b>integer
       <i>Querier configuration options:</i>
         <b>eth_src                     </b>string
         <b>ip4_src                     </b>string
         <b>ip6_src                     </b>string
         <b>query_max_resp              </b>optional integer

   <b>Details:</b>
       <b>datapath</b>: weak reference to <b>Datapath_Binding </b>(must be unique
       within table)
              <b>Datapath_Binding </b>entry for which these configuration
              options are defined.

       <b>enabled</b>: optional boolean
              Enables/disables multicast snooping. Default: disabled.

       <b>querier</b>: optional boolean
              Enables/disables multicast querying. If <b>enabled </b>then
              multicast querying is enabled by default.

       <b>table_size</b>: optional integer
              Limits the number of multicast groups that can be learned.
              Default: 2048 groups per datapath.

       <b>idle_timeout</b>: optional integer
              Configures the idle timeout (in seconds) for IP multicast
              groups if multicast snooping is enabled. Default: 300
              seconds.

       <b>query_interval</b>: optional integer
              Configures the interval (in seconds) for sending multicast
              queries if snooping and querier are enabled. Default:
              <b>idle_timeout</b>/2 seconds.

       <b>seq_no</b>: integer
              <b>ovn-controller </b>reads this value and flushes all learned
              multicast groups when it detects that <b>seq_no </b>was changed.

     <i>Querier configuration options:</i>

       The <b>ovn-controller </b>process that runs on OVN hypervisor nodes uses
       the following columns to determine field values in IGMP/MLD
       queries that it originates:

       <b>eth_src</b>: string
              Source Ethernet address.

       <b>ip4_src</b>: string
              Source IPv4 address.

       <b>ip6_src</b>: string
              Source IPv6 address.

       <b>query_max_resp</b>: optional integer
              Value (in seconds) to be used as "max-response" field in
              multicast queries. Default: 1 second.
</pre> <h2>
IGMP_Group TABLE </h2>
<pre>
       Contains learned IGMP groups indexed by address/datapath/chassis.

   <b>Summary:</b>
       <b>address                       </b>string
       <b>protocol                      </b>string
       <b>datapath                      </b>optional weak reference to
                                     <b>Datapath_Binding</b>
       <b>chassis                       </b>optional weak reference to <b>Chassis</b>
       <b>ports                         </b>set of weak reference to
                                     <b>Port_Binding</b>s
       <b>chassis_name                  </b>string

   <b>Details:</b>
       <b>address</b>: string
              Destination IPv4 address for the IGMP group.

       <b>protocol</b>: string
              Group protocol version either IGMPv1,v2,v3 or MLDv1,v2.

       <b>datapath</b>: optional weak reference to <b>Datapath_Binding</b>
              Datapath to which this IGMP group belongs.

       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              Chassis to which this IGMP group belongs.

       <b>ports</b>: set of weak reference to <b>Port_Binding</b>s
              The destination port bindings for this IGMP group.

       <b>chassis_name</b>: string
              The chassis that inserted this record. This column is used
              for RBAC purposes only.
</pre> <h2>
Service_Monitor TABLE </h2>
<pre>
       Each row in this table configures monitoring a service for its
       liveness. The service can be an IPv4 TCP or UDP service.
       <b>ovn-controller </b>periodically sends out service monitor packets and
       updates the status of the service.

       <b>ovn-northd </b>uses this feature to implement the load balancer
       health check feature offered to the CMS through the northbound
       database.

   <b>Summary:</b>
       <i>Configuration:</i>
         <b>ip                          </b>string
         <b>protocol                    </b>optional string, either <b>tcp </b>or <b>udp</b>
         <b>port                        </b>integer, in range 0 to 65,535
         <b>logical_port                </b>string
         <b>src_mac                     </b>string
         <b>src_ip                      </b>string
         <b>chassis_name                </b>string
         <b>options : interval          </b>optional string, containing an
                                     integer
         <b>options : timeout           </b>optional string, containing an
                                     integer
         <b>options : success_count     </b>optional string, containing an
                                     integer
         <b>options : failure_count     </b>optional string, containing an
                                     integer
       <i>Status Reporting:</i>
         <b>status                      </b>optional string, one of <b>error</b>,
                                     <b>offline</b>, or <b>online</b>
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs

   <b>Details:</b>
     <i>Configuration:</i>

       <b>ovn-northd </b>sets these columns and values to configure the service
       monitor.

       <b>ip</b>: string
              IP of the service to be monitored. Only IPv4 is supported.

       <b>protocol</b>: optional string, either <b>tcp </b>or <b>udp</b>
              The protocol of the service.

       <b>port</b>: integer, in range 0 to 65,535
              The TCP or UDP port of the service.

       <b>logical_port</b>: string
              The VIF of the logical port on which the service is
              running. The <b>ovn-controller </b>that binds this <b>logical_port</b>
              monitors the service by sending periodic monitor packets.

       <b>src_mac</b>: string
              Source Ethernet address to use in the service monitor
              packet.

       <b>src_ip</b>: string
              Source IPv4 or IPv6 address to use in the service monitor
              packet.

       <b>chassis_name</b>: string
              The name of the chassis where the logical port is bound.

       <b>options : interval</b>: optional string, containing an integer
              The interval, in seconds, between service monitor checks.

       <b>options : timeout</b>: optional string, containing an integer
              The time, in seconds, after which the service monitor
              check times out.

       <b>options : success_count</b>: optional string, containing an integer
              The number of successful checks after which the service is
              considered <b>online</b>.

       <b>options : failure_count</b>: optional string, containing an integer
              The number of failure checks after which the service is
              considered <b>offline</b>.

     <i>Status Reporting:</i>

       The <b>ovn-controller </b>on the chassis that hosts the <b>logical_port</b>
       updates this column to report the service’s status.

       <b>status</b>: optional string, one of <b>error</b>, <b>offline</b>, or <b>online</b>
              For TCP service, <b>ovn-controller </b>sends a SYN to the service
              and expects an ACK response to consider the service to be
              <b>online</b>.

              For UDP service, <b>ovn-controller </b>sends a UDP packet to the
              service and doesn’t expect any reply. If it receives an
              ICMP reply, then it considers the service to be <b>offline</b>.

     <i>Common Columns:</i>

       <b>external_ids</b>: map of string-string pairs
              See <b>External IDs </b>at the beginning of this document.
</pre> <h2>
Load_Balancer TABLE </h2>
<pre>
       Each row represents a load balancer.

   <b>Summary:</b>
       <b>name                          </b>string
       <b>vips                          </b>map of string-string pairs
       <b>protocol                      </b>optional string, one of <b>sctp</b>, <b>tcp</b>,
                                     or <b>udp</b>
       <b>datapaths                     </b>set of <b>Datapath_Binding</b>s
       <b>datapath_group                </b>optional <b>Logical_DP_Group</b>
       <b>ls_datapath_group             </b>optional <b>Logical_DP_Group</b>
       <b>lr_datapath_group             </b>optional <b>Logical_DP_Group</b>
       <i>Load_Balancer options:</i>
         <b>options : hairpin_snat_ip   </b>optional string
         <b>options : hairpin_orig_tuple</b>
                                     optional string, either <b>true </b>or
                                     <b>false</b>
       <i>Common Columns:</i>
         <b>external_ids                </b>map of string-string pairs

   <b>Details:</b>
       <b>name</b>: string
              A name for the load balancer. This name has no special
              meaning or purpose other than to provide convenience for
              human interaction with the ovn-nb database.

       <b>vips</b>: map of string-string pairs
              A map of virtual IP addresses (and an optional port number
              with <b>: </b>as a separator) associated with this load balancer
              and their corresponding endpoint IP addresses (and
              optional port numbers with <b>: </b>as separators) separated by
              commas.

       <b>protocol</b>: optional string, one of <b>sctp</b>, <b>tcp</b>, or <b>udp</b>
              Valid protocols are <b>tcp</b>, <b>udp</b>, or <b>sctp</b>. This column is
              useful when a port number is provided as part of the <b>vips</b>
              column. If this column is empty and a port number is
              provided as part of <b>vips </b>column, OVN assumes the protocol
              to be <b>tcp</b>.

       <b>datapaths</b>: set of <b>Datapath_Binding</b>s
              Datapaths to which this load balancer applies to.

       <b>datapath_group</b>: optional <b>Logical_DP_Group</b>
              Deprecated. The group of datapaths to which this load
              balancer applies to. This means that the same load
              balancer applies to all datapaths in a group.

       <b>ls_datapath_group</b>: optional <b>Logical_DP_Group</b>
              The group of datapaths to which this load balancer applies
              to. This means that the same load balancer applies to all
              datapaths in a group.

       <b>lr_datapath_group</b>: optional <b>Logical_DP_Group</b>
              The group of logical router datapaths to which this load
              balancer applies to. This means that the same load
              balancer applies to all datapaths in a group.

     <i>Load_Balancer options:</i>

       <b>options : hairpin_snat_ip</b>: optional string
              IP to be used as source IP for packets that have been
              hair-pinned after load balancing. This value is
              automatically populated by <b>ovn-northd</b>.

       <b>options : hairpin_orig_tuple</b>: optional string, either <b>true </b>or
       <b>false</b>
              This value is automatically set to <b>true </b>by <b>ovn-northd </b>when
              original destination IP and transport port of the load
              balanced packets are stored in registers <b>reg1, reg2,</b>
              <b>xxreg1</b>.

     <i>Common Columns:</i>

       <b>external_ids</b>: map of string-string pairs
              See <b>External IDs </b>at the beginning of this document.
</pre> <h2>
BFD TABLE </h2>
<pre>
       Contains BFD parameter for ovn-controller bfd configuration.

   <b>Summary:</b>
       <i>Configuration:</i>
         <b>src_port                    </b>integer, in range 49,152 to 65,535
         <b>disc                        </b>integer
         <b>logical_port                </b>string
         <b>dst_ip                      </b>string
         <b>min_tx                      </b>integer
         <b>min_rx                      </b>integer
         <b>detect_mult                 </b>integer
         <b>chassis_name                </b>string
         <b>options                     </b>map of string-string pairs
         <b>external_ids                </b>map of string-string pairs
       <i>Status Reporting:</i>
         <b>status                      </b>string, one of <b>admin_down</b>, <b>down</b>,
                                     <b>init</b>, or <b>up</b>

   <b>Details:</b>
     <i>Configuration:</i>

       <b>src_port</b>: integer, in range 49,152 to 65,535
              udp source port used in bfd control packets. The source
              port MUST be in the range 49152 through 65535 (RFC5881
              section 4).

       <b>disc</b>: integer
              A unique, nonzero discriminator value generated by the
              transmitting system, used to demultiplex multiple BFD
              sessions between the same pair of systems.

       <b>logical_port</b>: string
              OVN logical port when BFD engine is running.

       <b>dst_ip</b>: string
              BFD peer IP address.

       <b>min_tx</b>: integer
              This is the minimum interval, in milliseconds, that the
              local system would like to use when transmitting BFD
              Control packets, less any jitter applied. The value zero
              is reserved.

       <b>min_rx</b>: integer
              This is the minimum interval, in milliseconds, between
              received BFD Control packets that this system is capable
              of supporting, less any jitter applied by the sender. If
              this value is zero, the transmitting system does not want
              the remote system to send any periodic BFD Control
              packets.

       <b>detect_mult</b>: integer
              Detection time multiplier. The negotiated transmit
              interval, multiplied by this value, provides the Detection
              Time for the receiving system in Asynchronous mode.

       <b>chassis_name</b>: string
              The name of the chassis where the logical port is bound.

       <b>options</b>: map of string-string pairs
              Reserved for future use.

       <b>external_ids</b>: map of string-string pairs
              See <b>External IDs </b>at the beginning of this document.

     <i>Status Reporting:</i>

       <b>status</b>: string, one of <b>admin_down</b>, <b>down</b>, <b>init</b>, or <b>up</b>
              BFD port logical states. Possible values are:

              •      <b>admin_down</b>

              •      <b>down</b>

              •      <b>init</b>

              •      <b>up</b>
</pre> <h2>
FDB TABLE </h2>
<pre>
       This table is primarily used to learn the MACs observed on a VIF
       (or a localnet port with ’localnet_learn_fdb’ enabled) which
       belongs to a <b>Logical_Switch_Port </b>record in <b>OVN_Northbound </b>whose
       port security is disabled and ’unknown’ address set. If port
       security is disabled on a <b>Logical_Switch_Port </b>record, OVN should
       allow traffic with any source mac from the VIF. This table will
       be used to deliver a packet to the VIF, If a packet’s <b>eth.dst </b>is
       learnt.

   <b>Summary:</b>
       <b>mac                           </b>string
       <b>dp_key                        </b>integer, in range 1 to 16,777,215
       <b>port_key                      </b>integer, in range 1 to 16,777,215
       <b>timestamp                     </b>integer

   <b>Details:</b>
       <b>mac</b>: string
              The learnt mac address.

       <b>dp_key</b>: integer, in range 1 to 16,777,215
              The key of the datapath on which this FDB was learnt.

       <b>port_key</b>: integer, in range 1 to 16,777,215
              The key of the port binding on which this FDB was learnt.

       <b>timestamp</b>: integer
              The timestamp in msec when the FDB was added or updated.
              Records that existed before this column will have 0.
</pre> <h2>
Static_MAC_Binding TABLE </h2>
<pre>
       Each record represents a Static_MAC_Binding entry for a logical
       router.

   <b>Summary:</b>
       <b>logical_port                  </b>string
       <b>ip                            </b>string
       <b>mac                           </b>string
       <b>override_dynamic_mac          </b>boolean
       <b>datapath                      Datapath_Binding</b>

   <b>Details:</b>
       <b>logical_port</b>: string
              The logical router port for the binding.

       <b>ip</b>: string
              The bound IP address.

       <b>mac</b>: string
              The Ethernet address to which the IP is bound.

       <b>override_dynamic_mac</b>: boolean
              Override dynamically learnt MACs.

       <b>datapath</b>: <b>Datapath_Binding</b>
              The logical datapath to which the logical router port
              belongs.
</pre> <h2>
Chassis_Template_Var TABLE </h2>
<pre>
       Each record represents the set of template variable
       instantiations for a given chassis and is populated by <b>ovn-northd</b>
       from the contents of the <b>OVN_Northbound.Chassis_Template_Var</b>
       table.

   <b>Summary:</b>
       <b>chassis                       </b>string (must be unique within
                                     table)
       <b>variables                     </b>map of string-string pairs

   <b>Details:</b>
       <b>chassis</b>: string (must be unique within table)
              The chassis this set of variable values applies to.

       <b>variables</b>: map of string-string pairs
              The set of variable values for a given chassis.
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>Open Virtual Network</i> (Daemons for Open
       vSwitch that translate virtual network configurations into
       OpenFlow) project.  Information about the project can be found at
       ⟨<a href="https://www.ovn.org/">https://www.ovn.org/</a>⟩.  If you have a bug report for this manual
       page, send it to bugs@openvswitch.org.  This page was obtained
       from the project's upstream Git repository
       ⟨<a href="https://github.com/ovn-org/ovn">https://github.com/ovn-org/ovn</a>⟩ on 2024-06-14.  (At that time,
       the date of the most recent commit that was found in the
       repository was 2024-06-12.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Open vSwitch 24.03.90       DB Schema 20.34.0                  <i>ovn-sb</i>(5)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/ovn-sim.1.html">ovn-sim(1)</a>, <a href="../man7/ovn-architecture.7.html">ovn-architecture(7)</a>, <a href="../man7/ovsdb.7.html">ovsdb(7)</a>, <a href="../man8/ovn-controller.8.html">ovn-controller(8)</a>, <a href="../man8/ovn-controller-vtep.8.html">ovn-controller-vtep(8)</a>, <a href="../man8/ovn-northd.8.html">ovn-northd(8)</a>, <a href="../man8/ovn-sbctl.8.html">ovn-sbctl(8)</a>, <a href="../man8/ovn-trace.8.html">ovn-trace(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man5/ovn-sb.5.html" class="_attribution-link">https://man7.org/linux/man-pages/man5/ovn-sb.5.html</a>
  </p>
</div>
