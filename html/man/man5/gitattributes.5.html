<h1>gitattributes(5) — Linux manual page</h1>   <pre>
<span class="headline"><i>GITATTRIBUTES</i>(5)               Git Manual               <i>GITATTRIBUTES</i>(5)</span>
</pre> <h2>
NAME </h2>
<pre>
       gitattributes - Defining attributes per path
</pre> <h2>
SYNOPSIS </h2>
<pre>
       $GIT_DIR/info/attributes, .gitattributes
</pre> <h2>
DESCRIPTION </h2>
<pre>
       A <b>gitattributes </b>file is a simple text file that gives <b>attributes</b>
       to pathnames.

       Each line in <b>gitattributes </b>file is of form:

           pattern attr1 attr2 ...

       That is, a pattern followed by an attributes list, separated by
       whitespaces. Leading and trailing whitespaces are ignored. Lines
       that begin with <i>#</i> are ignored. Patterns that begin with a double
       quote are quoted in C style. When the pattern matches the path in
       question, the attributes listed on the line are given to the
       path.

       Each attribute can be in one of these states for a given path:

       Set
           The path has the attribute with special value "true"; this is
           specified by listing only the name of the attribute in the
           attribute list.

       Unset
           The path has the attribute with special value "false"; this
           is specified by listing the name of the attribute prefixed
           with a dash <b>- </b>in the attribute list.

       Set to a value
           The path has the attribute with specified string value; this
           is specified by listing the name of the attribute followed by
           an equal sign <b>= </b>and its value in the attribute list.

       Unspecified
           No pattern matches the path, and nothing says if the path has
           or does not have the attribute, the attribute for the path is
           said to be Unspecified.

       When more than one pattern matches the path, a later line
       overrides an earlier line. This overriding is done per attribute.

       The rules by which the pattern matches paths are the same as in
       <b>.gitignore </b>files (see <a href="gitignore.5.html">gitignore(5)</a>), with a few exceptions:

       •   negative patterns are forbidden

       •   patterns that match a directory do not recursively match
           paths inside that directory (so using the trailing-slash
           <b>path/ </b>syntax is pointless in an attributes file; use <b>path/**</b>
           instead)

       When deciding what attributes are assigned to a path, Git
       consults <b>$GIT_DIR/info/attributes </b>file (which has the highest
       precedence), <b>.gitattributes </b>file in the same directory as the
       path in question, and its parent directories up to the toplevel
       of the work tree (the further the directory that contains
       <b>.gitattributes </b>is from the path in question, the lower its
       precedence). Finally global and system-wide files are considered
       (they have the lowest precedence).

       When the <b>.gitattributes </b>file is missing from the work tree, the
       path in the index is used as a fall-back. During checkout
       process, <b>.gitattributes </b>in the index is used and then the file in
       the working tree is used as a fall-back.

       If you wish to affect only a single repository (i.e., to assign
       attributes to files that are particular to one user’s workflow
       for that repository), then attributes should be placed in the
       <b>$GIT_DIR/info/attributes </b>file. Attributes which should be
       version-controlled and distributed to other repositories (i.e.,
       attributes of interest to all users) should go into
       <b>.gitattributes </b>files. Attributes that should affect all
       repositories for a single user should be placed in a file
       specified by the <b>core.attributesFile </b>configuration option (see
       <a href="../man1/git-config.1.html">git-config(1)</a>). Its default value is
       $XDG_CONFIG_HOME/git/attributes. If $XDG_CONFIG_HOME is either
       not set or empty, $HOME/.config/git/attributes is used instead.
       Attributes for all users on a system should be placed in the
       <b>$(prefix)/etc/gitattributes </b>file.

       Sometimes you would need to override a setting of an attribute
       for a path to <b>Unspecified </b>state. This can be done by listing the
       name of the attribute prefixed with an exclamation point <b>!</b>.
</pre> <h2>
RESERVED BUILTIN_* ATTRIBUTES </h2>
<pre>
       builtin_* is a reserved namespace for builtin attribute values.
       Any user defined attributes under this namespace will be ignored
       and trigger a warning.

   <b>builtin_objectmode</b>
       This attribute is for filtering files by their file bit modes
       (40000, 120000, 160000, 100755, 100644). e.g.
       <i>:(attr:builtin_objectmode=160000)</i>. You may also check these
       values with <b>git check-attr builtin_objectmode -- &lt;file&gt;</b>. If the
       object is not in the index <b>git check-attr --cached </b>will return
       unspecified.
</pre> <h2>
EFFECTS </h2>
<pre>
       Certain operations by Git can be influenced by assigning
       particular attributes to a path. Currently, the following
       operations are attributes-aware.

   <b>Checking-out and checking-in</b>
       These attributes affect how the contents stored in the repository
       are copied to the working tree files when commands such as <i>git</i>
       <i>switch</i>, <i>git checkout</i> and <i>git merge</i> run. They also affect how Git
       stores the contents you prepare in the working tree in the
       repository upon <i>git add</i> and <i>git commit</i>.

       <b>text</b>

           This attribute marks the path as a text file, which enables
           end-of-line conversion: When a matching file is added to the
           index, the file’s line endings are normalized to LF in the
           index. Conversely, when the file is copied from the index to
           the working directory, its line endings may be converted from
           LF to CRLF depending on the <b>eol </b>attribute, the Git config,
           and the platform (see explanation of <b>eol </b>below).

           Set
               Setting the <b>text </b>attribute on a path enables end-of-line
               conversion on checkin and checkout as described above.
               Line endings are normalized to LF in the index every time
               the file is checked in, even if the file was previously
               added to Git with CRLF line endings.

           Unset
               Unsetting the <b>text </b>attribute on a path tells Git not to
               attempt any end-of-line conversion upon checkin or
               checkout.

           Set to string value "auto"
               When <b>text </b>is set to "auto", Git decides by itself whether
               the file is text or binary. If it is text and the file
               was not already in Git with CRLF endings, line endings
               are converted on checkin and checkout as described above.
               Otherwise, no conversion is done on checkin or checkout.

           Unspecified
               If the <b>text </b>attribute is unspecified, Git uses the
               <b>core.autocrlf </b>configuration variable to determine if the
               file should be converted.

           Any other value causes Git to act as if <b>text </b>has been left
           unspecified.

       <b>eol</b>

           This attribute marks a path to use a specific line-ending
           style in the working tree when it is checked out. It has
           effect only if <b>text </b>or <b>text=auto </b>is set (see above), but
           specifying <b>eol </b>automatically sets <b>text </b>if <b>text </b>was left
           unspecified.

           Set to string value "crlf"
               This setting converts the file’s line endings in the
               working directory to CRLF when the file is checked out.

           Set to string value "lf"
               This setting uses the same line endings in the working
               directory as in the index when the file is checked out.

           Unspecified
               If the <b>eol </b>attribute is unspecified for a file, its line
               endings in the working directory are determined by the
               <b>core.autocrlf </b>or <b>core.eol </b>configuration variable (see the
               definitions of those options in <a href="../man1/git-config.1.html">git-config(1)</a>). If <b>text</b>
               is set but neither of those variables is, the default is
               <b>eol=crlf </b>on Windows and <b>eol=lf </b>on all other platforms.

       <b>Backwards compatibility with crlf attribute</b>

           For backwards compatibility, the <b>crlf </b>attribute is
           interpreted as follows:

               crlf            text
               -crlf           -text
               crlf=input      eol=lf

       <b>End-of-line conversion</b>

           While Git normally leaves file contents alone, it can be
           configured to normalize line endings to LF in the repository
           and, optionally, to convert them to CRLF when files are
           checked out.

           If you simply want to have CRLF line endings in your working
           directory regardless of the repository you are working with,
           you can set the config variable "core.autocrlf" without using
           any attributes.

               [core]
                       autocrlf = true

           This does not force normalization of text files, but does
           ensure that text files that you introduce to the repository
           have their line endings normalized to LF when they are added,
           and that files that are already normalized in the repository
           stay normalized.

           If you want to ensure that text files that any contributor
           introduces to the repository have their line endings
           normalized, you can set the <b>text </b>attribute to "auto" for <i>all</i>
           files.

               *       text=auto

           The attributes allow a fine-grained control, how the line
           endings are converted. Here is an example that will make Git
           normalize .txt, .vcproj and .sh files, ensure that .vcproj
           files have CRLF and .sh files have LF in the working
           directory, and prevent .jpg files from being normalized
           regardless of their content.

               *               text=auto
               *.txt           text
               *.vcproj        text eol=crlf
               *.sh            text eol=lf
               *.jpg           -text

               <b>Note</b>

               When <b>text=auto </b>conversion is enabled in a cross-platform
               project using push and pull to a central repository the
               text files containing CRLFs should be normalized.

           From a clean working directory:

               $ echo "* text=auto" &gt;.gitattributes
               $ git add --renormalize .
               $ git status        # Show files that will be normalized
               $ git commit -m "Introduce end-of-line normalization"

           If any files that should not be normalized show up in <i>git</i>
           <i>status</i>, unset their <b>text </b>attribute before running <i>git add -u</i>.

               manual.pdf      -text

           Conversely, text files that Git does not detect can have
           normalization enabled manually.

               weirdchars.txt  text

           If <b>core.safecrlf </b>is set to "true" or "warn", Git verifies if
           the conversion is reversible for the current setting of
           <b>core.autocrlf</b>. For "true", Git rejects irreversible
           conversions; for "warn", Git only prints a warning but
           accepts an irreversible conversion. The safety triggers to
           prevent such a conversion done to the files in the work tree,
           but there are a few exceptions. Even though...

           •   <i>git add</i> itself does not touch the files in the work tree,
               the next checkout would, so the safety triggers;

           •   <i>git apply</i> to update a text file with a patch does touch
               the files in the work tree, but the operation is about
               text files and CRLF conversion is about fixing the line
               ending inconsistencies, so the safety does not trigger;

           •   <i>git diff</i> itself does not touch the files in the work
               tree, it is often run to inspect the changes you intend
               to next <i>git add</i>. To catch potential problems early,
               safety triggers.

       <b>working-tree-encoding</b>

           Git recognizes files encoded in ASCII or one of its supersets
           (e.g. UTF-8, ISO-8859-1, ...) as text files. Files encoded in
           certain other encodings (e.g. UTF-16) are interpreted as
           binary and consequently built-in Git text processing tools
           (e.g. <i>git diff</i>) as well as most Git web front ends do not
           visualize the contents of these files by default.

           In these cases you can tell Git the encoding of a file in the
           working directory with the <b>working-tree-encoding </b>attribute.
           If a file with this attribute is added to Git, then Git
           re-encodes the content from the specified encoding to UTF-8.
           Finally, Git stores the UTF-8 encoded content in its internal
           data structure (called "the index"). On checkout the content
           is re-encoded back to the specified encoding.

           Please note that using the <b>working-tree-encoding </b>attribute
           may have a number of pitfalls:

           •   Alternative Git implementations (e.g. JGit or libgit2)
               and older Git versions (as of March 2018) do not support
               the <b>working-tree-encoding </b>attribute. If you decide to use
               the <b>working-tree-encoding </b>attribute in your repository,
               then it is strongly recommended to ensure that all
               clients working with the repository support it.

               For example, Microsoft Visual Studio resources files
               (<b>*.rc</b>) or PowerShell script files (<b>*.ps1</b>) are sometimes
               encoded in UTF-16. If you declare <b>*.ps1 </b>as files as
               UTF-16 and you add <b>foo.ps1 </b>with a <b>working-tree-encoding</b>
               enabled Git client, then <b>foo.ps1 </b>will be stored as UTF-8
               internally. A client without <b>working-tree-encoding</b>
               support will checkout <b>foo.ps1 </b>as UTF-8 encoded file. This
               will typically cause trouble for the users of this file.

               If a Git client that does not support the
               <b>working-tree-encoding </b>attribute adds a new file <b>bar.ps1</b>,
               then <b>bar.ps1 </b>will be stored "as-is" internally (in this
               example probably as UTF-16). A client with
               <b>working-tree-encoding </b>support will interpret the internal
               contents as UTF-8 and try to convert it to UTF-16 on
               checkout. That operation will fail and cause an error.

           •   Reencoding content to non-UTF encodings can cause errors
               as the conversion might not be UTF-8 round trip safe. If
               you suspect your encoding to not be round trip safe, then
               add it to <b>core.checkRoundtripEncoding </b>to make Git check
               the round trip encoding (see <a href="../man1/git-config.1.html">git-config(1)</a>). SHIFT-JIS
               (Japanese character set) is known to have round trip
               issues with UTF-8 and is checked by default.

           •   Reencoding content requires resources that might slow
               down certain Git operations (e.g <i>git checkout</i> or <i>git</i>
               <i>add</i>).

           Use the <b>working-tree-encoding </b>attribute only if you cannot
           store a file in UTF-8 encoding and if you want Git to be able
           to process the content as text.

           As an example, use the following attributes if your <i>*.ps1</i>
           files are UTF-16 encoded with byte order mark (BOM) and you
           want Git to perform automatic line ending conversion based on
           your platform.

               *.ps1           text working-tree-encoding=UTF-16

           Use the following attributes if your <i>*.ps1</i> files are UTF-16
           little endian encoded without BOM and you want Git to use
           Windows line endings in the working directory (use
           <b>UTF-16LE-BOM </b>instead of <b>UTF-16LE </b>if you want UTF-16 little
           endian with BOM). Please note, it is highly recommended to
           explicitly define the line endings with <b>eol </b>if the
           <b>working-tree-encoding </b>attribute is used to avoid ambiguity.

               *.ps1           text working-tree-encoding=UTF-16LE eol=CRLF

           You can get a list of all available encodings on your
           platform with the following command:

               iconv --list

           If you do not know the encoding of a file, then you can use
           the <b>file </b>command to guess the encoding:

               file foo.ps1

       <b>ident</b>

           When the attribute <b>ident </b>is set for a path, Git replaces <b>$Id$</b>
           in the blob object with <b>$Id:</b>, followed by the 40-character
           hexadecimal blob object name, followed by a dollar sign <b>$</b>
           upon checkout. Any byte sequence that begins with <b>$Id: </b>and
           ends with <b>$ </b>in the worktree file is replaced with <b>$Id$ </b>upon
           check-in.

       <b>filter</b>

           A <b>filter </b>attribute can be set to a string value that names a
           filter driver specified in the configuration.

           A filter driver consists of a <b>clean </b>command and a <b>smudge</b>
           command, either of which can be left unspecified. Upon
           checkout, when the <b>smudge </b>command is specified, the command
           is fed the blob object from its standard input, and its
           standard output is used to update the worktree file.
           Similarly, the <b>clean </b>command is used to convert the contents
           of worktree file upon checkin. By default these commands
           process only a single blob and terminate. If a long running
           <b>process </b>filter is used in place of <b>clean </b>and/or <b>smudge</b>
           filters, then Git can process all blobs with a single filter
           command invocation for the entire life of a single Git
           command, for example <b>git add --all</b>. If a long running <b>process</b>
           filter is configured then it always takes precedence over a
           configured single blob filter. See section below for the
           description of the protocol used to communicate with a
           <b>process </b>filter.

           One use of the content filtering is to massage the content
           into a shape that is more convenient for the platform,
           filesystem, and the user to use. For this mode of operation,
           the key phrase here is "more convenient" and not "turning
           something unusable into usable". In other words, the intent
           is that if someone unsets the filter driver definition, or
           does not have the appropriate filter program, the project
           should still be usable.

           Another use of the content filtering is to store the content
           that cannot be directly used in the repository (e.g. a UUID
           that refers to the true content stored outside Git, or an
           encrypted content) and turn it into a usable form upon
           checkout (e.g. download the external content, or decrypt the
           encrypted content).

           These two filters behave differently, and by default, a
           filter is taken as the former, massaging the contents into
           more convenient shape. A missing filter driver definition in
           the config, or a filter driver that exits with a non-zero
           status, is not an error but makes the filter a no-op
           passthru.

           You can declare that a filter turns a content that by itself
           is unusable into a usable content by setting the
           filter.&lt;driver&gt;.required configuration variable to <b>true</b>.

           Note: Whenever the clean filter is changed, the repo should
           be renormalized: $ git add --renormalize .

           For example, in .gitattributes, you would assign the <b>filter</b>
           attribute for paths.

               *.c     filter=indent

           Then you would define a "filter.indent.clean" and
           "filter.indent.smudge" configuration in your .git/config to
           specify a pair of commands to modify the contents of C
           programs when the source files are checked in ("clean" is
           run) and checked out (no change is made because the command
           is "cat").

               [filter "indent"]
                       clean = indent
                       smudge = cat

           For best results, <b>clean </b>should not alter its output further
           if it is run twice ("clean→clean" should be equivalent to
           "clean"), and multiple <b>smudge </b>commands should not alter
           <b>clean</b>'s output ("smudge→smudge→clean" should be equivalent to
           "clean"). See the section on merging below.

           The "indent" filter is well-behaved in this regard: it will
           not modify input that is already correctly indented. In this
           case, the lack of a smudge filter means that the clean filter
           <i>must</i> accept its own output without modifying it.

           If a filter <i>must</i> succeed in order to make the stored contents
           usable, you can declare that the filter is <b>required</b>, in the
           configuration:

               [filter "crypt"]
                       clean = openssl enc ...
                       smudge = openssl enc -d ...
                       required

           Sequence "%f" on the filter command line is replaced with the
           name of the file the filter is working on. A filter might use
           this in keyword substitution. For example:

               [filter "p4"]
                       clean = git-p4-filter --clean %f
                       smudge = git-p4-filter --smudge %f

           Note that "%f" is the name of the path that is being worked
           on. Depending on the version that is being filtered, the
           corresponding file on disk may not exist, or may have
           different contents. So, smudge and clean commands should not
           try to access the file on disk, but only act as filters on
           the content provided to them on standard input.

       <b>Long Running Filter Process</b>

           If the filter command (a string value) is defined via
           <b>filter.&lt;driver&gt;.process </b>then Git can process all blobs with a
           single filter invocation for the entire life of a single Git
           command. This is achieved by using the long-running process
           protocol (described in
           technical/long-running-process-protocol.txt).

           When Git encounters the first file that needs to be cleaned
           or smudged, it starts the filter and performs the handshake.
           In the handshake, the welcome message sent by Git is
           "git-filter-client", only version 2 is supported, and the
           supported capabilities are "clean", "smudge", and "delay".

           Afterwards Git sends a list of "key=value" pairs terminated
           with a flush packet. The list will contain at least the
           filter command (based on the supported capabilities) and the
           pathname of the file to filter relative to the repository
           root. Right after the flush packet Git sends the content
           split in zero or more pkt-line packets and a flush packet to
           terminate content. Please note, that the filter must not send
           any response before it received the content and the final
           flush packet. Also note that the "value" of a "key=value"
           pair can contain the "=" character whereas the key would
           never contain that character.

               packet:          git&gt; command=smudge
               packet:          git&gt; pathname=path/testfile.dat
               packet:          git&gt; 0000
               packet:          git&gt; CONTENT
               packet:          git&gt; 0000

           The filter is expected to respond with a list of "key=value"
           pairs terminated with a flush packet. If the filter does not
           experience problems then the list must contain a "success"
           status. Right after these packets the filter is expected to
           send the content in zero or more pkt-line packets and a flush
           packet at the end. Finally, a second list of "key=value"
           pairs terminated with a flush packet is expected. The filter
           can change the status in the second list or keep the status
           as is with an empty list. Please note that the empty list
           must be terminated with a flush packet regardless.

               packet:          git&lt; status=success
               packet:          git&lt; 0000
               packet:          git&lt; SMUDGED_CONTENT
               packet:          git&lt; 0000
               packet:          git&lt; 0000  # empty list, keep "status=success" unchanged!

           If the result content is empty then the filter is expected to
           respond with a "success" status and a flush packet to signal
           the empty content.

               packet:          git&lt; status=success
               packet:          git&lt; 0000
               packet:          git&lt; 0000  # empty content!
               packet:          git&lt; 0000  # empty list, keep "status=success" unchanged!

           In case the filter cannot or does not want to process the
           content, it is expected to respond with an "error" status.

               packet:          git&lt; status=error
               packet:          git&lt; 0000

           If the filter experiences an error during processing, then it
           can send the status "error" after the content was (partially
           or completely) sent.

               packet:          git&lt; status=success
               packet:          git&lt; 0000
               packet:          git&lt; HALF_WRITTEN_ERRONEOUS_CONTENT
               packet:          git&lt; 0000
               packet:          git&lt; status=error
               packet:          git&lt; 0000

           In case the filter cannot or does not want to process the
           content as well as any future content for the lifetime of the
           Git process, then it is expected to respond with an "abort"
           status at any point in the protocol.

               packet:          git&lt; status=abort
               packet:          git&lt; 0000

           Git neither stops nor restarts the filter process in case the
           "error"/"abort" status is set. However, Git sets its exit
           code according to the <b>filter.&lt;driver&gt;.required </b>flag,
           mimicking the behavior of the <b>filter.&lt;driver&gt;.clean </b>/
           <b>filter.&lt;driver&gt;.smudge </b>mechanism.

           If the filter dies during the communication or does not
           adhere to the protocol then Git will stop the filter process
           and restart it with the next file that needs to be processed.
           Depending on the <b>filter.&lt;driver&gt;.required </b>flag Git will
           interpret that as error.

       <b>Delay</b>

           If the filter supports the "delay" capability, then Git can
           send the flag "can-delay" after the filter command and
           pathname. This flag denotes that the filter can delay
           filtering the current blob (e.g. to compensate network
           latencies) by responding with no content but with the status
           "delayed" and a flush packet.

               packet:          git&gt; command=smudge
               packet:          git&gt; pathname=path/testfile.dat
               packet:          git&gt; can-delay=1
               packet:          git&gt; 0000
               packet:          git&gt; CONTENT
               packet:          git&gt; 0000
               packet:          git&lt; status=delayed
               packet:          git&lt; 0000

           If the filter supports the "delay" capability then it must
           support the "list_available_blobs" command. If Git sends this
           command, then the filter is expected to return a list of
           pathnames representing blobs that have been delayed earlier
           and are now available. The list must be terminated with a
           flush packet followed by a "success" status that is also
           terminated with a flush packet. If no blobs for the delayed
           paths are available, yet, then the filter is expected to
           block the response until at least one blob becomes available.
           The filter can tell Git that it has no more delayed blobs by
           sending an empty list. As soon as the filter responds with an
           empty list, Git stops asking. All blobs that Git has not
           received at this point are considered missing and will result
           in an error.

               packet:          git&gt; command=list_available_blobs
               packet:          git&gt; 0000
               packet:          git&lt; pathname=path/testfile.dat
               packet:          git&lt; pathname=path/otherfile.dat
               packet:          git&lt; 0000
               packet:          git&lt; status=success
               packet:          git&lt; 0000

           After Git received the pathnames, it will request the
           corresponding blobs again. These requests contain a pathname
           and an empty content section. The filter is expected to
           respond with the smudged content in the usual way as
           explained above.

               packet:          git&gt; command=smudge
               packet:          git&gt; pathname=path/testfile.dat
               packet:          git&gt; 0000
               packet:          git&gt; 0000  # empty content!
               packet:          git&lt; status=success
               packet:          git&lt; 0000
               packet:          git&lt; SMUDGED_CONTENT
               packet:          git&lt; 0000
               packet:          git&lt; 0000  # empty list, keep "status=success" unchanged!

       <b>Example</b>

           A long running filter demo implementation can be found in
           <b>contrib/long-running-filter/example.pl </b>located in the Git
           core repository. If you develop your own long running filter
           process then the <b>GIT_TRACE_PACKET </b>environment variables can
           be very helpful for debugging (see <a href="../man1/git.1.html">git(1)</a>).

           Please note that you cannot use an existing
           <b>filter.&lt;driver&gt;.clean </b>or <b>filter.&lt;driver&gt;.smudge </b>command with
           <b>filter.&lt;driver&gt;.process </b>because the former two use a
           different inter process communication protocol than the
           latter one.

       <b>Interaction between checkin/checkout attributes</b>

           In the check-in codepath, the worktree file is first
           converted with <b>filter </b>driver (if specified and corresponding
           driver defined), then the result is processed with <b>ident </b>(if
           specified), and then finally with <b>text </b>(again, if specified
           and applicable).

           In the check-out codepath, the blob content is first
           converted with <b>text</b>, and then <b>ident </b>and fed to <b>filter</b>.

       <b>Merging branches with differing checkin/checkout attributes</b>

           If you have added attributes to a file that cause the
           canonical repository format for that file to change, such as
           adding a clean/smudge filter or text/eol/ident attributes,
           merging anything where the attribute is not in place would
           normally cause merge conflicts.

           To prevent these unnecessary merge conflicts, Git can be told
           to run a virtual check-out and check-in of all three stages
           of a file when resolving a three-way merge by setting the
           <b>merge.renormalize </b>configuration variable. This prevents
           changes caused by check-in conversion from causing spurious
           merge conflicts when a converted file is merged with an
           unconverted file.

           As long as a "smudge→clean" results in the same output as a
           "clean" even on files that are already smudged, this strategy
           will automatically resolve all filter-related conflicts.
           Filters that do not act in this way may cause additional
           merge conflicts that must be resolved manually.

   <b>Generating diff text</b>
       <b>diff</b>

           The attribute <b>diff </b>affects how Git generates diffs for
           particular files. It can tell Git whether to generate a
           textual patch for the path or to treat the path as a binary
           file. It can also affect what line is shown on the hunk
           header <b>@@ -k,l +n,m @@ </b>line, tell Git to use an external
           command to generate the diff, or ask Git to convert binary
           files to a text format before generating the diff.

           Set
               A path to which the <b>diff </b>attribute is set is treated as
               text, even when they contain byte values that normally
               never appear in text files, such as NUL.

           Unset
               A path to which the <b>diff </b>attribute is unset will generate
               <b>Binary files differ </b>(or a binary patch, if binary patches
               are enabled).

           Unspecified
               A path to which the <b>diff </b>attribute is unspecified first
               gets its contents inspected, and if it looks like text
               and is smaller than core.bigFileThreshold, it is treated
               as text. Otherwise it would generate <b>Binary files differ</b>.

           String
               Diff is shown using the specified diff driver. Each
               driver may specify one or more options, as described in
               the following section. The options for the diff driver
               "foo" are defined by the configuration variables in the
               "diff.foo" section of the Git config file.

       <b>Defining an external diff driver</b>

           The definition of a diff driver is done in <b>gitconfig</b>, not
           <b>gitattributes </b>file, so strictly speaking this manual page is
           a wrong place to talk about it. However...

           To define an external diff driver <b>jcdiff</b>, add a section to
           your <b>$GIT_DIR/config </b>file (or <b>$HOME/.gitconfig </b>file) like
           this:

               [diff "jcdiff"]
                       command = j-c-diff

           When Git needs to show you a diff for the path with <b>diff</b>
           attribute set to <b>jcdiff</b>, it calls the command you specified
           with the above configuration, i.e. <b>j-c-diff</b>, with 7
           parameters, just like <b>GIT_EXTERNAL_DIFF </b>program is called.
           See <a href="../man1/git.1.html">git(1)</a> for details.

       <b>Setting the internal diff algorithm</b>

           The diff algorithm can be set through the <b>diff.algorithm</b>
           config key, but sometimes it may be helpful to set the diff
           algorithm per path. For example, one may want to use the
           <b>minimal </b>diff algorithm for .json files, and the <b>histogram </b>for
           .c files, and so on without having to pass in the algorithm
           through the command line each time.

           First, in <b>.gitattributes</b>, assign the <b>diff </b>attribute for
           paths.

               *.json diff=&lt;name&gt;

           Then, define a "diff.&lt;name&gt;.algorithm" configuration to
           specify the diff algorithm, choosing from <b>myers</b>, <b>patience</b>,
           <b>minimal</b>, or <b>histogram</b>.

               [diff "&lt;name&gt;"]
                 algorithm = histogram

           This diff algorithm applies to user facing diff output like
           git-diff(1), git-show(1) and is used for the <b>--stat </b>output as
           well. The merge machinery will not use the diff algorithm set
           through this method.

               <b>Note</b>

               If <b>diff.&lt;name&gt;.command </b>is defined for path with the
               <b>diff=&lt;name&gt; </b>attribute, it is executed as an external diff
               driver (see above), and adding <b>diff.&lt;name&gt;.algorithm </b>has
               no effect, as the algorithm is not passed to the external
               diff driver.

       <b>Defining a custom hunk-header</b>

           Each group of changes (called a "hunk") in the textual diff
           output is prefixed with a line of the form:

               @@ -k,l +n,m @@ TEXT

           This is called a <i>hunk header</i>. The "TEXT" portion is by
           default a line that begins with an alphabet, an underscore or
           a dollar sign; this matches what GNU <i>diff -p</i> output uses.
           This default selection however is not suited for some
           contents, and you can use a customized pattern to make a
           selection.

           First, in .gitattributes, you would assign the <b>diff </b>attribute
           for paths.

               *.tex   diff=tex

           Then, you would define a "diff.tex.xfuncname" configuration
           to specify a regular expression that matches a line that you
           would want to appear as the hunk header "TEXT". Add a section
           to your <b>$GIT_DIR/config </b>file (or <b>$HOME/.gitconfig </b>file) like
           this:

               [diff "tex"]
                       xfuncname = "^(\\\\(sub)*section\\{.*)$"

           Note. A single level of backslashes are eaten by the
           configuration file parser, so you would need to double the
           backslashes; the pattern above picks a line that begins with
           a backslash, and zero or more occurrences of <b>sub </b>followed by
           <b>section </b>followed by open brace, to the end of line.

           There are a few built-in patterns to make this easier, and
           <b>tex </b>is one of them, so you do not have to write the above in
           your configuration file (you still need to enable this with
           the attribute mechanism, via <b>.gitattributes</b>). The following
           built in patterns are available:

           •   <b>ada </b>suitable for source code in the Ada language.

           •   <b>bash </b>suitable for source code in the Bourne-Again SHell
               language. Covers a superset of POSIX shell function
               definitions.

           •   <b>bibtex </b>suitable for files with BibTeX coded references.

           •   <b>cpp </b>suitable for source code in the C and C++ languages.

           •   <b>csharp </b>suitable for source code in the C# language.

           •   <b>css </b>suitable for cascading style sheets.

           •   <b>dts </b>suitable for devicetree (DTS) files.

           •   <b>elixir </b>suitable for source code in the Elixir language.

           •   <b>fortran </b>suitable for source code in the Fortran language.

           •   <b>fountain </b>suitable for Fountain documents.

           •   <b>golang </b>suitable for source code in the Go language.

           •   <b>html </b>suitable for HTML/XHTML documents.

           •   <b>java </b>suitable for source code in the Java language.

           •   <b>kotlin </b>suitable for source code in the Kotlin language.

           •   <b>markdown </b>suitable for Markdown documents.

           •   <b>matlab </b>suitable for source code in the MATLAB and Octave
               languages.

           •   <b>objc </b>suitable for source code in the Objective-C
               language.

           •   <b>pascal </b>suitable for source code in the Pascal/Delphi
               language.

           •   <b>perl </b>suitable for source code in the Perl language.

           •   <b>php </b>suitable for source code in the PHP language.

           •   <b>python </b>suitable for source code in the Python language.

           •   <b>ruby </b>suitable for source code in the Ruby language.

           •   <b>rust </b>suitable for source code in the Rust language.

           •   <b>scheme </b>suitable for source code in the Scheme language.

           •   <b>tex </b>suitable for source code for LaTeX documents.

       <b>Customizing word diff</b>

           You can customize the rules that <b>git diff --word-diff </b>uses to
           split words in a line, by specifying an appropriate regular
           expression in the "diff.*.wordRegex" configuration variable.
           For example, in TeX a backslash followed by a sequence of
           letters forms a command, but several such commands can be run
           together without intervening whitespace. To separate them,
           use a regular expression in your <b>$GIT_DIR/config </b>file (or
           <b>$HOME/.gitconfig </b>file) like this:

               [diff "tex"]
                       wordRegex = "\\\\[a-zA-Z]+|[{}]|\\\\.|[^\\{}[:space:]]+"

           A built-in pattern is provided for all languages listed in
           the previous section.

       <b>Performing text diffs of binary files</b>

           Sometimes it is desirable to see the diff of a text-converted
           version of some binary files. For example, a word processor
           document can be converted to an ASCII text representation,
           and the diff of the text shown. Even though this conversion
           loses some information, the resulting diff is useful for
           human viewing (but cannot be applied directly).

           The <b>textconv </b>config option is used to define a program for
           performing such a conversion. The program should take a
           single argument, the name of a file to convert, and produce
           the resulting text on stdout.

           For example, to show the diff of the exif information of a
           file instead of the binary information (assuming you have the
           exif tool installed), add the following section to your
           <b>$GIT_DIR/config </b>file (or <b>$HOME/.gitconfig </b>file):

               [diff "jpg"]
                       textconv = exif

               <b>Note</b>

               The text conversion is generally a one-way conversion; in
               this example, we lose the actual image contents and focus
               just on the text data. This means that diffs generated by
               textconv are <i>not</i> suitable for applying. For this reason,
               only <b>git diff </b>and the <b>git log </b>family of commands (i.e.,
               log, whatchanged, show) will perform text conversion. <b>git</b>
               <b>format-patch </b>will never generate this output. If you want
               to send somebody a text-converted diff of a binary file
               (e.g., because it quickly conveys the changes you have
               made), you should generate it separately and send it as a
               comment <i>in addition to</i> the usual binary diff that you
               might send.

           Because text conversion can be slow, especially when doing a
           large number of them with <b>git log -p</b>, Git provides a
           mechanism to cache the output and use it in future diffs. To
           enable caching, set the "cachetextconv" variable in your diff
           driver’s config. For example:

               [diff "jpg"]
                       textconv = exif
                       cachetextconv = true

           This will cache the result of running "exif" on each blob
           indefinitely. If you change the textconv config variable for
           a diff driver, Git will automatically invalidate the cache
           entries and re-run the textconv filter. If you want to
           invalidate the cache manually (e.g., because your version of
           "exif" was updated and now produces better output), you can
           remove the cache manually with <b>git update-ref -d</b>
           <b>refs/notes/textconv/jpg </b>(where "jpg" is the name of the diff
           driver, as in the example above).

       <b>Choosing textconv versus external diff</b>

           If you want to show differences between binary or
           specially-formatted blobs in your repository, you can choose
           to use either an external diff command, or to use textconv to
           convert them to a diff-able text format. Which method you
           choose depends on your exact situation.

           The advantage of using an external diff command is
           flexibility. You are not bound to find line-oriented changes,
           nor is it necessary for the output to resemble unified diff.
           You are free to locate and report changes in the most
           appropriate way for your data format.

           A textconv, by comparison, is much more limiting. You provide
           a transformation of the data into a line-oriented text
           format, and Git uses its regular diff tools to generate the
           output. There are several advantages to choosing this method:

            1. Ease of use. It is often much simpler to write a binary
               to text transformation than it is to perform your own
               diff. In many cases, existing programs can be used as
               textconv filters (e.g., exif, odt2txt).

            2. Git diff features. By performing only the transformation
               step yourself, you can still utilize many of Git’s diff
               features, including colorization, word-diff, and combined
               diffs for merges.

            3. Caching. Textconv caching can speed up repeated diffs,
               such as those you might trigger by running <b>git log -p</b>.

       <b>Marking files as binary</b>

           Git usually guesses correctly whether a blob contains text or
           binary data by examining the beginning of the contents.
           However, sometimes you may want to override its decision,
           either because a blob contains binary data later in the file,
           or because the content, while technically composed of text
           characters, is opaque to a human reader. For example, many
           postscript files contain only ASCII characters, but produce
           noisy and meaningless diffs.

           The simplest way to mark a file as binary is to unset the
           diff attribute in the <b>.gitattributes </b>file:

               *.ps -diff

           This will cause Git to generate <b>Binary files differ </b>(or a
           binary patch, if binary patches are enabled) instead of a
           regular diff.

           However, one may also want to specify other diff driver
           attributes. For example, you might want to use <b>textconv </b>to
           convert postscript files to an ASCII representation for human
           viewing, but otherwise treat them as binary files. You cannot
           specify both <b>-diff </b>and <b>diff=ps </b>attributes. The solution is to
           use the <b>diff.*.binary </b>config option:

               [diff "ps"]
                 textconv = ps2ascii
                 binary = true

   <b>Performing a three-way merge</b>
       <b>merge</b>

           The attribute <b>merge </b>affects how three versions of a file are
           merged when a file-level merge is necessary during <b>git merge</b>,
           and other commands such as <b>git revert </b>and <b>git cherry-pick</b>.

           Set
               Built-in 3-way merge driver is used to merge the contents
               in a way similar to <i>merge</i> command of <b>RCS </b>suite. This is
               suitable for ordinary text files.

           Unset
               Take the version from the current branch as the tentative
               merge result, and declare that the merge has conflicts.
               This is suitable for binary files that do not have a
               well-defined merge semantics.

           Unspecified
               By default, this uses the same built-in 3-way merge
               driver as is the case when the <b>merge </b>attribute is set.
               However, the <b>merge.default </b>configuration variable can
               name different merge driver to be used with paths for
               which the <b>merge </b>attribute is unspecified.

           String
               3-way merge is performed using the specified custom merge
               driver. The built-in 3-way merge driver can be explicitly
               specified by asking for "text" driver; the built-in "take
               the current branch" driver can be requested with
               "binary".

       <b>Built-in merge drivers</b>

           There are a few built-in low-level merge drivers defined that
           can be asked for via the <b>merge </b>attribute.

           text
               Usual 3-way file level merge for text files. Conflicted
               regions are marked with conflict markers <b>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</b>, <b>=======</b>
               and <b>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</b>. The version from your branch appears before
               the <b>======= </b>marker, and the version from the merged
               branch appears after the <b>======= </b>marker.

           binary
               Keep the version from your branch in the work tree, but
               leave the path in the conflicted state for the user to
               sort out.

           union
               Run 3-way file level merge for text files, but take lines
               from both versions, instead of leaving conflict markers.
               This tends to leave the added lines in the resulting file
               in random order and the user should verify the result. Do
               not use this if you do not understand the implications.

       <b>Defining a custom merge driver</b>

           The definition of a merge driver is done in the <b>.git/config</b>
           file, not in the <b>gitattributes </b>file, so strictly speaking
           this manual page is a wrong place to talk about it.
           However...

           To define a custom merge driver <b>filfre</b>, add a section to your
           <b>$GIT_DIR/config </b>file (or <b>$HOME/.gitconfig </b>file) like this:

               [merge "filfre"]
                       name = feel-free merge driver
                       driver = filfre %O %A %B %L %P
                       recursive = binary

           The <b>merge.*.name </b>variable gives the driver a human-readable
           name.

           The ‘merge.*.driver` variable’s value is used to construct a
           command to run to common ancestor’s version (<b>%O</b>), current
           version (<b>%A</b>) and the other branches’ version (<b>%B</b>). These
           three tokens are replaced with the names of temporary files
           that hold the contents of these versions when the command
           line is built. Additionally, <b>%L </b>will be replaced with the
           conflict marker size (see below).

           The merge driver is expected to leave the result of the merge
           in the file named with <b>%A </b>by overwriting it, and exit with
           zero status if it managed to merge them cleanly, or non-zero
           if there were conflicts. When the driver crashes (e.g. killed
           by SEGV), it is expected to exit with non-zero status that
           are higher than 128, and in such a case, the merge results in
           a failure (which is different from producing a conflict).

           The <b>merge.*.recursive </b>variable specifies what other merge
           driver to use when the merge driver is called for an internal
           merge between common ancestors, when there are more than one.
           When left unspecified, the driver itself is used for both
           internal merge and the final merge.

           The merge driver can learn the pathname in which the merged
           result will be stored via placeholder <b>%P</b>. The conflict labels
           to be used for the common ancestor, local head and other head
           can be passed by using <i>%S</i>, <i>%X</i> and '%Y` respectively.

       <b>conflict-marker-size</b>

           This attribute controls the length of conflict markers left
           in the work tree file during a conflicted merge. Only a
           positive integer has a meaningful effect.

           For example, this line in <b>.gitattributes </b>can be used to tell
           the merge machinery to leave much longer (instead of the
           usual 7-character-long) conflict markers when merging the
           file <b>Documentation/git-merge.txt </b>results in a conflict.

               Documentation/git-merge.txt     conflict-marker-size=32

   <b>Checking whitespace errors</b>
       <b>whitespace</b>

           The <b>core.whitespace </b>configuration variable allows you to
           define what <i>diff</i> and <i>apply</i> should consider whitespace errors
           for all paths in the project (See <a href="../man1/git-config.1.html">git-config(1)</a>). This
           attribute gives you finer control per path.

           Set
               Notice all types of potential whitespace errors known to
               Git. The tab width is taken from the value of the
               <b>core.whitespace </b>configuration variable.

           Unset
               Do not notice anything as error.

           Unspecified
               Use the value of the <b>core.whitespace </b>configuration
               variable to decide what to notice as error.

           String
               Specify a comma separated list of common whitespace
               problems to notice in the same format as the
               <b>core.whitespace </b>configuration variable.

   <b>Creating an archive</b>
       <b>export-ignore</b>

           Files and directories with the attribute <b>export-ignore </b>won’t
           be added to archive files.

       <b>export-subst</b>

           If the attribute <b>export-subst </b>is set for a file then Git will
           expand several placeholders when adding this file to an
           archive. The expansion depends on the availability of a
           commit ID, i.e., if <a href="../man1/git-archive.1.html">git-archive(1)</a> has been given a tree
           instead of a commit or a tag then no replacement will be
           done. The placeholders are the same as those for the option
           <b>--pretty=format: </b>of <a href="../man1/git-log.1.html">git-log(1)</a>, except that they need to be
           wrapped like this: <b>$Format:PLACEHOLDERS$ </b>in the file. E.g.
           the string <b>$Format:%H$ </b>will be replaced by the commit hash.
           However, only one <b>%(describe) </b>placeholder is expanded per
           archive to avoid denial-of-service attacks.

   <b>Packing objects</b>
       <b>delta</b>

           Delta compression will not be attempted for blobs for paths
           with the attribute <b>delta </b>set to false.

   <b>Viewing files in GUI tools</b>
       <b>encoding</b>

           The value of this attribute specifies the character encoding
           that should be used by GUI tools (e.g. <a href="../man1/gitk.1.html">gitk(1)</a> and
           <a href="../man1/git-gui.1.html">git-gui(1)</a>) to display the contents of the relevant file.
           Note that due to performance considerations <a href="../man1/gitk.1.html">gitk(1)</a> does not
           use this attribute unless you manually enable per-file
           encodings in its options.

           If this attribute is not set or has an invalid value, the
           value of the <b>gui.encoding </b>configuration variable is used
           instead (See <a href="../man1/git-config.1.html">git-config(1)</a>).
</pre> <h2>
USING MACRO ATTRIBUTES </h2>
<pre>
       You do not want any end-of-line conversions applied to, nor
       textual diffs produced for, any binary file you track. You would
       need to specify e.g.

           *.jpg -text -diff

       but that may become cumbersome, when you have many attributes.
       Using macro attributes, you can define an attribute that, when
       set, also sets or unsets a number of other attributes at the same
       time. The system knows a built-in macro attribute, <b>binary</b>:

           *.jpg binary

       Setting the "binary" attribute also unsets the "text" and "diff"
       attributes as above. Note that macro attributes can only be
       "Set", though setting one might have the effect of setting or
       unsetting other attributes or even returning other attributes to
       the "Unspecified" state.
</pre> <h2>
DEFINING MACRO ATTRIBUTES </h2>
<pre>
       Custom macro attributes can be defined only in top-level
       gitattributes files (<b>$GIT_DIR/info/attributes</b>, the <b>.gitattributes</b>
       file at the top level of the working tree, or the global or
       system-wide gitattributes files), not in <b>.gitattributes </b>files in
       working tree subdirectories. The built-in macro attribute
       "binary" is equivalent to:

           [attr]binary -diff -merge -text
</pre> <h2>
NOTES </h2>
<pre>
       Git does not follow symbolic links when accessing a
       <b>.gitattributes </b>file in the working tree. This keeps behavior
       consistent when the file is accessed from the index or a tree
       versus from the filesystem.
</pre> <h2>
EXAMPLES </h2>
<pre>
       If you have these three <b>gitattributes </b>file:

           (in $GIT_DIR/info/attributes)

           a*      foo !bar -baz

           (in .gitattributes)
           abc     foo bar baz

           (in t/.gitattributes)
           ab*     merge=filfre
           abc     -foo -bar
           *.c     frotz

       the attributes given to path <b>t/abc </b>are computed as follows:

        1. By examining <b>t/.gitattributes </b>(which is in the same directory
           as the path in question), Git finds that the first line
           matches.  <b>merge </b>attribute is set. It also finds that the
           second line matches, and attributes <b>foo </b>and <b>bar </b>are unset.

        2. Then it examines <b>.gitattributes </b>(which is in the parent
           directory), and finds that the first line matches, but
           <b>t/.gitattributes </b>file already decided how <b>merge</b>, <b>foo </b>and <b>bar</b>
           attributes should be given to this path, so it leaves <b>foo </b>and
           <b>bar </b>unset. Attribute <b>baz </b>is set.

        3. Finally it examines <b>$GIT_DIR/info/attributes</b>. This file is
           used to override the in-tree settings. The first line is a
           match, and <b>foo </b>is set, <b>bar </b>is reverted to unspecified state,
           and <b>baz </b>is unset.

       As the result, the attributes assignment to <b>t/abc </b>becomes:

           foo     set to true
           bar     unspecified
           baz     set to false
           merge   set to string value "filfre"
           frotz   unspecified
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man1/git-check-attr.1.html">git-check-attr(1)</a>.
</pre> <h2>
GIT </h2>
<pre>
       Part of the <a href="../man1/git.1.html">git(1)</a> suite
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>git</i> (Git distributed version control
       system) project.  Information about the project can be found at
       ⟨<a href="http://git-scm.com/">http://git-scm.com/</a>⟩.  If you have a bug report for this manual
       page, see ⟨<a href="http://git-scm.com/community">http://git-scm.com/community</a>⟩.  This page was obtained
       from the project's upstream Git repository
       ⟨<a href="https://github.com/git/git.git">https://github.com/git/git.git</a>⟩ on 2024-06-14.  (At that time,
       the date of the most recent commit that was found in the
       repository was 2024-06-12.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Git 2.45.2.492.gd63586         2024-06-12               <i>GITATTRIBUTES</i>(5)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/git.1.html">git(1)</a>, <a href="../man1/git-annotate.1.html">git-annotate(1)</a>, <a href="../man1/git-archive.1.html">git-archive(1)</a>, <a href="../man1/git-blame.1.html">git-blame(1)</a>, <a href="../man1/git-check-attr.1.html">git-check-attr(1)</a>, <a href="../man1/git-commit.1.html">git-commit(1)</a>, <a href="../man1/git-commit-tree.1.html">git-commit-tree(1)</a>, <a href="../man1/git-config.1.html">git-config(1)</a>, <a href="../man1/git-cvsserver.1.html">git-cvsserver(1)</a>, <a href="../man1/git-diff.1.html">git-diff(1)</a>, <a href="../man1/git-diff-files.1.html">git-diff-files(1)</a>, <a href="../man1/git-diff-index.1.html">git-diff-index(1)</a>, <a href="../man1/git-diff-tree.1.html">git-diff-tree(1)</a>, <a href="../man1/git-format-patch.1.html">git-format-patch(1)</a>, <a href="../man1/git-grep.1.html">git-grep(1)</a>, <a href="../man1/gitk.1.html">gitk(1)</a>, <a href="../man1/git-log.1.html">git-log(1)</a>, <a href="../man1/git-merge.1.html">git-merge(1)</a>, <a href="../man1/git-pull.1.html">git-pull(1)</a>, <a href="../man1/git-rebase.1.html">git-rebase(1)</a>, <a href="../man1/git-rerere.1.html">git-rerere(1)</a>, <a href="../man1/git-show.1.html">git-show(1)</a>, <a href="../man1/git-var.1.html">git-var(1)</a>, <a href="gitrepository-layout.5.html">gitrepository-layout(5)</a>, <a href="../man7/gitfaq.7.html">gitfaq(7)</a>, <a href="../man7/gitglossary.7.html">gitglossary(7)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man5/gitattributes.5.html" class="_attribution-link">https://man7.org/linux/man-pages/man5/gitattributes.5.html</a>
  </p>
</div>
