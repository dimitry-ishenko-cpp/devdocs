<div class="section" id="Basic-Statistical-Functions">   <h1 class="section">26.3 Basic Statistical Functions</h1> <p>Octave supports various helpful statistical functions. Many are useful as initial steps to prepare a data set for further analysis. Others provide different measures from those of the basic descriptive statistics. </p> <dl class="def"> <dt id="index-center">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>center</strong> <em>(<var>x</var>)</em><a href="#index-center" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-center-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>center</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-center-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Center data by subtracting its mean. </p> <p>If <var>x</var> is a vector, subtract its mean. </p> <p>If <var>x</var> is a matrix, do the above for each column. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>Programming Note: <code>center</code> has obvious application for normalizing statistical data. It is also useful for improving the precision of general numerical calculations. Whenever there is a large value that is common to a batch of data, the mean can be subtracted off, the calculation performed, and then the mean added back to obtain the final answer. </p> <p><strong>See also:</strong> <a href="#XREFzscore">zscore</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-zscore">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>zscore</strong> <em>(<var>x</var>)</em><a href="#index-zscore" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-zscore-1">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>zscore</strong> <em>(<var>x</var>, <var>opt</var>)</em><a href="#index-zscore-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-zscore-2">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>zscore</strong> <em>(<var>x</var>, <var>opt</var>, <var>dim</var>)</em><a href="#index-zscore-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-zscore-3">
<span class="category">: </span><span><em>[<var>z</var>, <var>mu</var>, <var>sigma</var>] =</em> <strong>zscore</strong> <em>(…)</em><a href="#index-zscore-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the Z score of <var>x</var>. </p> <p>If <var>x</var> is a vector, subtract its mean and divide by its standard deviation. If the standard deviation is zero, divide by 1 instead. </p> <p>The optional parameter <var>opt</var> determines the normalization to use when computing the standard deviation and has the same definition as the corresponding parameter for <code>std</code>. </p> <p>If <var>x</var> is a matrix, calculate along the first non-singleton dimension. If the third optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional outputs <var>mu</var> and <var>sigma</var> contain the mean and standard deviation. </p> <p><strong>See also:</strong> <a href="descriptive-statistics.html#XREFmean">mean</a>, <a href="descriptive-statistics.html#XREFstd">std</a>, <a href="#XREFcenter">center</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-normalize">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>normalize</strong> <em>(<var>x</var>)</em><a href="#index-normalize" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-normalize-1">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>normalize</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-normalize-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-normalize-2">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>normalize</strong> <em>(…, <var>method</var>)</em><a href="#index-normalize-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-normalize-3">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>normalize</strong> <em>(…, <var>method</var>, <var>option</var>)</em><a href="#index-normalize-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-normalize-4">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>normalize</strong> <em>(…, <var>scale</var>, <var>scaleoption</var>, <var>center</var>, <var>centeroption</var>)</em><a href="#index-normalize-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-normalize-5">
<span class="category">: </span><span><em>[<var>z</var>, <var>c</var>, <var>s</var>] =</em> <strong>normalize</strong> <em>(…)</em><a href="#index-normalize-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Return a normalization of the data in <var>x</var> using one of several available scaling and centering methods. </p> <p><code>normalize</code> by default will return the <code>zscore</code> of <var>x</var>, defined as the number of standard deviations each element is from the mean of <var>x</var>. This is equivalent to centering at the mean of the data and scaling by the standard deviation. </p> <p>The returned value <var>z</var> will have the same size as <var>x</var>. The optional return variables <var>c</var> and <var>s</var> are the centering and scaling factors used in the normalization such that: </p> <pre class="example" data-language="matlab">z = (x - c) ./ s</pre> <p>If <var>x</var> is a vector, <code>normalize</code> will operate on the data in <var>x</var>. </p> <p>If <var>x</var> is a matrix, <code>normalize</code> will operate independently on each column in <var>x</var>. </p> <p>If <var>x</var> is an N-dimensional array, <code>normalize</code> will operate independently on the first non-singleton dimension in <var>x</var>. </p> <p>If the optional second argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional inputs <var>method</var> and <var>option</var> can be used to specify the type of normalization performed on <var>x</var>. Note that only the <samp>scale</samp> and <samp>center</samp> options may be specified together using any of the methods defined below. Valid normalization methods are: </p> <dl compact> <dt><span><code>zscore</code></span></dt> <dd>
<p>(Default) Normalizes the elements in <var>x</var> to the scaled distance from a central value. Valid Options: </p> <dl compact> <dt><span><code>std</code></span></dt> <dd>
<p>(Default) Data is centered at <code>mean (<var>x</var>)</code> and scaled by the standard deviation. </p> </dd> <dt><span><code>robust</code></span></dt> <dd><p>Data is centered at <code>median (<var>x</var>)</code> and scaled by the median absolute deviation. </p></dd> </dl> </dd> <dt><span><code>norm</code></span></dt> <dd>
<p><var>z</var> is the general vector norm of <var>x</var>, with <var>option</var> being the normalization factor <var>p</var> that determines the vector norm type according to: </p> <pre class="example" data-language="matlab">z = [sum (abs (x) .^ p)] ^ (1/p)</pre> <p><var>p</var> can be any positive scalar, specific values being: </p> <dl compact> <dt><span><code><var>p</var> = 1</code></span></dt> <dd>
<p><var>x</var> is normalized by <code>sum (abs (<var>x</var>))</code>. </p> </dd> <dt><span><code><var>p</var> = 2</code></span></dt> <dd>
<p>(Default) <var>x</var> is normalized by the Euclidian norm, or vector magnitude, of the elements. </p> </dd> <dt><span><code><var>P</var> = Inf</code></span></dt> <dd><p><var>x</var> is normalized by <code>max (abs (<var>x</var>))</code>. </p></dd> </dl> </dd> <dt><span><code>scale</code></span></dt> <dd>
<p><var>x</var> is scaled by a factor determined by <var>option</var>, which can be a numeric scalar or one of the following: </p> <dl compact> <dt><span><code>std</code></span></dt> <dd>
<p>(Default) <var>x</var> is scaled by its standard deviation. </p> </dd> <dt><span><code>mad</code></span></dt> <dd>
<p><var>x</var> is scaled by its median absolute deviation. </p> </dd> <dt><span><code>first</code></span></dt> <dd>
<p><var>x</var> is scaled by its first element. </p> </dd> <dt><span><code>iqr</code></span></dt> <dd><p><var>x</var> is scaled by its interquartile range. </p></dd> </dl> </dd> <dt><span><code>range</code></span></dt> <dd>
<p><var>x</var> is scaled to fit the range specified by <var>option</var> as a two element scalar row vector. The default range is [0, 1]. </p> </dd> <dt><span><code>center</code></span></dt> <dd>
<p><var>x</var> is shifted by an amount determined by <var>option</var>, which can be a numeric scalar or one of the following: </p> <dl compact> <dt><span><code>mean</code></span></dt> <dd>
<p>(Default) <var>x</var> is shifted by <code>mean (<var>x</var>)</code>. </p> </dd> <dt><span><code>median</code></span></dt> <dd><p><var>x</var> is shifted by <code>median (<var>x</var>)</code>. </p></dd> </dl> </dd> <dt><span><code>medianiqr</code></span></dt> <dd><p><var>x</var> is shifted by <code>median (<var>x</var>)</code> and scaled by the interquartile range. </p></dd> </dl> <p>Known <small>MATLAB</small> incompatibilities: </p> <ol> <li> The option <samp>DataVariables</samp> is not yet implemented for Table class <var>x</var> inputs. </li>
<li> Certain arrays containing NaN elements may not return <small>MATLAB</small> compatible output. </li>
</ol> <p><strong>See also:</strong> <a href="#XREFzscore">zscore</a>, <a href="descriptive-statistics.html#XREFiqr">iqr</a>, <a href="basic-matrix-functions.html#XREFnorm">norm</a>, <a href="simple-file-i_002fo.html#XREFrescale">rescale</a>, <a href="descriptive-statistics.html#XREFstd">std</a>, <a href="descriptive-statistics.html#XREFmedian">median</a>, <a href="descriptive-statistics.html#XREFmean">mean</a>, <a href="descriptive-statistics.html#XREFmad">mad</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-histc">
<span class="category">: </span><span><em><var>n</var> =</em> <strong>histc</strong> <em>(<var>x</var>, <var>edges</var>)</em><a href="#index-histc" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-histc-1">
<span class="category">: </span><span><em><var>n</var> =</em> <strong>histc</strong> <em>(<var>x</var>, <var>edges</var>, <var>dim</var>)</em><a href="#index-histc-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-histc-2">
<span class="category">: </span><span><em>[<var>n</var>, <var>idx</var>] =</em> <strong>histc</strong> <em>(…)</em><a href="#index-histc-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute histogram counts. </p> <p>When <var>x</var> is a vector, the function counts the number of elements of <var>x</var> that fall in the histogram bins defined by <var>edges</var>. This must be a vector of monotonically increasing values that define the edges of the histogram bins. <code><var>n</var>(k)</code> contains the number of elements in <var>x</var> for which <code><var>edges</var>(k) &lt;= <var>x</var> &lt; <var>edges</var>(k+1)</code>. The final element of <var>n</var> contains the number of elements of <var>x</var> exactly equal to the last element of <var>edges</var>. </p> <p>When <var>x</var> is an <em class="math">N</em>-dimensional array, the computation is carried out along dimension <var>dim</var>. If not specified <var>dim</var> defaults to the first non-singleton dimension. </p> <p>When a second output argument is requested an index matrix is also returned. The <var>idx</var> matrix has the same size as <var>x</var>. Each element of <var>idx</var> contains the index of the histogram bin in which the corresponding element of <var>x</var> was counted. </p> <p><strong>See also:</strong> <a href="two_002ddimensional-plots.html#XREFhist">hist</a>. </p>
</dd>
</dl> <p><code>unique</code> function documented at <a href="sets.html#XREFunique">unique</a> is often useful for statistics. </p> <dl class="def"> <dt id="index-nchoosek">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>nchoosek</strong> <em>(<var>n</var>, <var>k</var>)</em><a href="#index-nchoosek" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-nchoosek-1">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>nchoosek</strong> <em>(<var>set</var>, <var>k</var>)</em><a href="#index-nchoosek-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Compute the binomial coefficient of <var>n</var> or list all possible combinations of a <var>set</var> of items. </p> <p>If <var>n</var> is a scalar then calculate the binomial coefficient of <var>n</var> and <var>k</var> which is defined as </p> <pre class="example" data-language="matlab">/   \
 | n |    n (n-1) (n-2) … (n-k+1)       n!
 |   |  = ------------------------- =  ---------
 | k |               k!                k! (n-k)!
 \   /</pre> <p>This is the number of combinations of <var>n</var> items taken in groups of size <var>k</var>. </p> <p>If the first argument is a vector, <var>set</var>, then generate all combinations of the elements of <var>set</var>, taken <var>k</var> at a time, with one row per combination. The result <var>c</var> has <var>k</var> columns and <code>nchoosek (length (<var>set</var>), <var>k</var>)</code> rows. </p> <p>For example: </p> <p>How many ways can three items be grouped into pairs? </p> <pre class="example" data-language="matlab">nchoosek (3, 2)
   ⇒ 3</pre> <p>What are the possible pairs? </p> <pre class="example" data-language="matlab">nchoosek (1:3, 2)
   ⇒  1   2
       1   3
       2   3</pre> <p>Programming Note: When calculating the binomial coefficient <code>nchoosek</code> works only for non-negative, integer arguments. Use <code>bincoeff</code> for non-integer and negative scalar arguments, or for computing many binomial coefficients at once with vector inputs for <var>n</var> or <var>k</var>. </p> <p><strong>See also:</strong> <a href="special-functions.html#XREFbincoeff">bincoeff</a>, <a href="#XREFperms">perms</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-perms">
<span class="category">: </span><span><em><var>P</var> =</em> <strong>perms</strong> <em>(<var>v</var>)</em><a href="#index-perms" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-perms-1">
<span class="category">: </span><span><em><var>P</var> =</em> <strong>perms</strong> <em>(<var>v</var>, "unique")</em><a href="#index-perms-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Generate all permutations of vector <var>v</var> with one row per permutation. </p> <p>Results are returned in inverse lexicographic order. The result has size <code>factorial (<var>n</var>) * <var>n</var></code>, where <var>n</var> is the length of <var>v</var>. Any repeated elements are included in the output. </p> <p>If the optional argument <code>"unique"</code> is given then only unique permutations are returned, using less memory and generally taking less time than calling <code>unique (perms (<var>v</var>), "rows")</code>. </p> <p>Example 1 </p> <pre class="example" data-language="matlab">perms ([1, 2, 3])
⇒
  3   2   1
  3   1   2
  2   3   1
  2   1   3
  1   3   2
  1   2   3</pre> <p>Example 2 </p> <pre class="example" data-language="matlab">perms ([1, 1, 2, 2], "unique")
⇒
  1   1   2   2
  1   2   1   2
  1   2   2   1
  2   1   1   2
  2   1   2   1
  2   2   1   1</pre> <p>Programming Note: If the <code>"unique"</code> option is not used, the length of <var>v</var> should be no more than 10-12 to limit memory consumption. Even with <code>"unique"</code>, there should be no more than 10-12 unique elements in <var>v</var>. </p> <p><strong>See also:</strong> <a href="rearranging-matrices.html#XREFpermute">permute</a>, <a href="special-utility-matrices.html#XREFrandperm">randperm</a>, <a href="#XREFnchoosek">nchoosek</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ranks">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>ranks</strong> <em>(<var>x</var>)</em><a href="#index-ranks" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ranks-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>ranks</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-ranks-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ranks-2">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>ranks</strong> <em>(<var>x</var>, <var>dim</var>, <var>rtype</var>)</em><a href="#index-ranks-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the ranks (in the sense of order statistics) of <var>x</var> along the first non-singleton dimension adjusted for ties. </p> <p>If the optional <var>dim</var> argument is given, operate along this dimension. </p> <p>The optional parameter <var>rtype</var> determines how ties are handled. All examples below assume an input of <code>[ 1, 2, 2, 4 ]</code>. </p> <dl compact> <dt><span>0 or <code>"fractional"</code> (default) for fractional ranking (1, 2.5,</span></dt> <dd>
<p>2.5, 4); </p> </dd> <dt><span>1 or <code>"competition"</code> for competition ranking (1, 2, 2, 4);</span></dt> <dt><span>2 or <code>"modified"</code> for modified competition ranking (1, 3, 3, 4);</span></dt> <dt><span>3 or <code>"ordinal"</code> for ordinal ranking (1, 2, 3, 4);</span></dt> <dt><span>4 or <code>"dense"</code> for dense ranking (1, 2, 2, 3).</span></dt> </dl> <p><strong>See also:</strong> <a href="correlation-and-regression-analysis.html#XREFspearman">spearman</a>, <a href="correlation-and-regression-analysis.html#XREFkendall">kendall</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-run_005fcount">
<span class="category">: </span><span><em><var>cnt</var> =</em> <strong>run_count</strong> <em>(<var>x</var>, <var>n</var>)</em><a href="#index-run_005fcount" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-run_005fcount-1">
<span class="category">: </span><span><em><var>cnt</var> =</em> <strong>run_count</strong> <em>(<var>x</var>, <var>n</var>, <var>dim</var>)</em><a href="#index-run_005fcount-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Count the upward runs along the first non-singleton dimension of <var>x</var> of length 1, 2, …, <var>n</var>-1 and greater than or equal to <var>n</var>. </p> <p>If the optional argument <var>dim</var> is given then operate along this dimension. </p> <p><strong>See also:</strong> <a href="#XREFrunlength">runlength</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-runlength">
<span class="category">: </span><span><em>count =</em> <strong>runlength</strong> <em>(<var>x</var>)</em><a href="#index-runlength" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-runlength-1">
<span class="category">: </span><span><em>[count, value] =</em> <strong>runlength</strong> <em>(<var>x</var>)</em><a href="#index-runlength-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Find the lengths of all sequences of common values. </p> <p><var>count</var> is a vector with the lengths of each repeated value. </p> <p>The optional output <var>value</var> contains the value that was repeated in the sequence. </p> <pre class="example" data-language="matlab">runlength ([2, 2, 0, 4, 4, 4, 0, 1, 1, 1, 1])
⇒   2   1   3   1   4</pre> <p><strong>See also:</strong> <a href="#XREFrun_005fcount">run_count</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Basic-Statistical-Functions.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Basic-Statistical-Functions.html</a>
  </p>
</div>
