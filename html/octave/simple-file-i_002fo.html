<div class="subsection" id="Simple-File-I_002fO">   <h1 class="subsection">14.1.3 Simple File I/O</h1>   <p>The <code>save</code> and <code>load</code> commands allow data to be written to and read from disk files in various formats. The default format of files written by the <code>save</code> command can be controlled using the functions <code>save_default_options</code> and <code>save_precision</code>. </p> <p>As an example the following code creates a 3-by-3 matrix and saves it to the file ‘<samp>myfile.mat</samp>’. </p> <pre class="example" data-language="matlab">A = [ 1:3; 4:6; 7:9 ];
save myfile.mat A</pre> <p>Once one or more variables have been saved to a file, they can be read into memory using the <code>load</code> command. </p> <pre class="example" data-language="matlab">load myfile.mat
A
     -| A =
     -|
     -|    1   2   3
     -|    4   5   6
     -|    7   8   9</pre> <dl class="def"> <dt id="index-save">
<span class="category">: </span><span> <strong>save</strong> <em>file</em><a href="#index-save" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save-1">
<span class="category">: </span><span> <strong>save</strong> <em>options file</em><a href="#index-save-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save-2">
<span class="category">: </span><span> <strong>save</strong> <em>options file <var>v1</var> <var>v2</var> …</em><a href="#index-save-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save-3">
<span class="category">: </span><span> <strong>save</strong> <em>options file -struct <var>STRUCT</var></em><a href="#index-save-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save-4">
<span class="category">: </span><span> <strong>save</strong> <em>options file -struct <var>STRUCT</var> <var>f1</var> <var>f2</var> …</em><a href="#index-save-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save-5">
<span class="category">: </span><span> <strong>save</strong> <em>- <var>v1</var> <var>v2</var> …</em><a href="#index-save-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save-6">
<span class="category">: </span><span><em><var>str</var> =</em> <strong>save</strong> <em>("-", <code>"<var>v1</var>"</code>, <code>"<var>v2</var>"</code>, …)</em><a href="#index-save-6" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Save the named variables <var>v1</var>, <var>v2</var>, …, in the file <var>file</var>. </p> <p>The special filename ‘<samp>-</samp>’ may be used to return the content of the variables as a string. If no variable names are listed, Octave saves all the variables in the current scope. Otherwise, full variable names or pattern syntax can be used to specify the variables to save. If the <samp>-struct</samp> modifier is used then the fields of the <strong>scalar</strong> struct are saved as if they were variables with the corresponding field names. The <samp>-struct</samp> option can be combined with specific field names <var>f1</var>, <var>f2</var>, … to write only certain fields to the file. </p> <p>Valid options for the <code>save</code> command are listed in the following table. Options that modify the output format override the format specified by <code>save_default_options</code>. </p> <p>If save is invoked using the functional form </p> <pre class="example" data-language="matlab">save ("-option1", …, "file", "v1", …)</pre> <p>then the <var>options</var>, <var>file</var>, and variable name arguments (<var>v1</var>, …) must be specified as character strings. </p> <p>If called with a filename of <code>"-"</code>, write the output to stdout if nargout is 0, otherwise return the output in a character string. </p> <dl compact> <dt><span><code>-append</code></span></dt> <dd>
<p>Append to the destination instead of overwriting. </p> </dd> <dt><span><code>-ascii</code></span></dt> <dd>
<p>Save a matrix in a text file without a header or any other information. The matrix must be 2-D and only the real part of any complex value is written to the file. Numbers are stored in single-precision format and separated by spaces. Additional options for the <samp>-ascii</samp> format are </p> <dl compact> <dt><span><code>-double</code></span></dt> <dd>
<p>Store numbers in double-precision format. </p> </dd> <dt><span><code>-tabs</code></span></dt> <dd><p>Separate numbers with tabs. </p></dd> </dl> </dd> <dt><span><code>-binary</code></span></dt> <dd>
<p>Save the data in Octave’s binary data format. </p> </dd> <dt><span><code>-float-binary</code></span></dt> <dd>
<p>Save the data in Octave’s binary data format but using only single precision. Use this format <strong>only</strong> if you know that all the values to be saved can be represented in single precision. </p> </dd> <dt><span><code>-hdf5</code></span></dt> <dd>
<p>Save the data in <small>HDF5</small> format. (HDF5 is a free, portable, binary format developed by the National Center for Supercomputing Applications at the University of Illinois.) This format is only available if Octave was built with a link to the <small>HDF5</small> libraries. </p> </dd> <dt><span><code>-float-hdf5</code></span></dt> <dd>
<p>Save the data in <small>HDF5</small> format but using only single precision. Use this format <strong>only</strong> if you know that all the values to be saved can be represented in single precision. </p> </dd> <dt><span><code>-text</code></span></dt> <dd>
<p>Save the data in Octave’s text data format. (default) </p> </dd> <dt><span><code>-v7.3</code></span></dt> <dt><span><code>-V7.3</code></span></dt> <dt><span><code>-7.3</code></span></dt> <dd>
<p>Octave does <strong>not</strong> yet implement <small>MATLAB</small>’s v7.3 binary data format. </p> </dd> <dt><span><code>-v7</code></span></dt> <dt><span><code>-V7</code></span></dt> <dt><span><code>-7</code></span></dt> <dt><span><code>-mat7-binary</code></span></dt> <dd>
<p>Save the data in <small>MATLAB</small>’s v7 binary data format. </p> </dd> <dt><span><code>-v6</code></span></dt> <dt><span><code>-V6</code></span></dt> <dt><span><code>-6</code></span></dt> <dt><span><code>-mat</code></span></dt> <dt><span><code>-mat-binary</code></span></dt> <dd>
<p>Save the data in <small>MATLAB</small>’s v6 binary data format. </p> </dd> <dt><span><code>-v4</code></span></dt> <dt><span><code>-V4</code></span></dt> <dt><span><code>-4</code></span></dt> <dt><span><code>-mat4-binary</code></span></dt> <dd>
<p>Save the data in <small>MATLAB</small>’s v4 binary data format. </p> </dd> <dt><span><code>-zip</code></span></dt> <dt><span><code>-z</code></span></dt> <dd><p>Use the gzip algorithm to compress the file. This works on files that are compressed with gzip outside of Octave, and gzip can also be used to convert the files for backward compatibility. This option is only available if Octave was built with a link to the zlib libraries. </p></dd> </dl> <p>The list of variables to save may use wildcard patterns (glob patterns) containing the following special characters: </p> <dl compact> <dt><span><code>?</code></span></dt> <dd>
<p>Match any single character. </p> </dd> <dt><span><code>*</code></span></dt> <dd>
<p>Match zero or more characters. </p> </dd> <dt><span><code>[ <var>list</var> ]</code></span></dt> <dd>
<p>Match the list of characters specified by <var>list</var>. If the first character is <code>!</code> or <code>^</code>, match all characters except those specified by <var>list</var>. For example, the pattern <code>[a-zA-Z]</code> will match all lower and uppercase alphabetic characters. </p> <p>Wildcards may also be used in the field name specifications when using the <samp>-struct</samp> modifier (but not in the struct name itself). </p> </dd> </dl> <p>Except when using the <small>MATLAB</small> binary data file format or the ‘<samp>-ascii</samp>’ format, saving global variables also saves the global status of the variable. If the variable is restored at a later time using ‘<samp>load</samp>’, it will be restored as a global variable. </p> <p>Example: </p> <p>The command </p> <pre class="example" data-language="matlab">save -binary data a b*</pre> <p>saves the variable ‘<samp>a</samp>’ and all variables beginning with ‘<samp>b</samp>’ to the file <samp>data</samp> in Octave’s binary format. </p> <p><strong>See also:</strong> <a href="#XREFload">load</a>, <a href="#XREFsave_005fdefault_005foptions">save_default_options</a>, <a href="#XREFsave_005fheader_005fformat_005fstring">save_header_format_string</a>, <a href="#XREFsave_005fprecision">save_precision</a>, <a href="#XREFdlmread">dlmread</a>, <a href="#XREFcsvread">csvread</a>, <a href="binary-i_002fo.html#XREFfread">fread</a>. </p>
</dd>
</dl> <p>There are three functions that modify the behavior of <code>save</code>. </p> <dl class="def"> <dt id="index-save_005fdefault_005foptions">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>save_default_options</strong> <em>()</em><a href="#index-save_005fdefault_005foptions" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save_005fdefault_005foptions-1">
<span class="category">: </span><span><em><var>old_val</var> =</em> <strong>save_default_options</strong> <em>(<var>new_val</var>)</em><a href="#index-save_005fdefault_005foptions-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save_005fdefault_005foptions-2">
<span class="category">: </span><span><em><var>old_val</var> =</em> <strong>save_default_options</strong> <em>(<var>new_val</var>, "local")</em><a href="#index-save_005fdefault_005foptions-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Query or set the internal variable that specifies the default options for the <code>save</code> command, and defines the default format. </p> <p>The default value is <code>"-text"</code> (Octave’s own text-based file format). See the documentation of the <code>save</code> command for other choices. </p> <p>When called from inside a function with the <code>"local"</code> option, the variable is changed locally for the function and any subroutines it calls. The original variable value is restored when exiting the function. </p> <p><strong>See also:</strong> <a href="#XREFsave">save</a>, <a href="#XREFsave_005fheader_005fformat_005fstring">save_header_format_string</a>, <a href="#XREFsave_005fprecision">save_precision</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-save_005fprecision">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>save_precision</strong> <em>()</em><a href="#index-save_005fprecision" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save_005fprecision-1">
<span class="category">: </span><span><em><var>old_val</var> =</em> <strong>save_precision</strong> <em>(<var>new_val</var>)</em><a href="#index-save_005fprecision-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save_005fprecision-2">
<span class="category">: </span><span><em><var>old_val</var> =</em> <strong>save_precision</strong> <em>(<var>new_val</var>, "local")</em><a href="#index-save_005fprecision-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Query or set the internal variable that specifies the number of digits to keep when saving data in text format. </p> <p>The default value is 17 which is the minimum necessary for the lossless saving and restoring of IEEE-754 double values; For IEEE-754 single values the minimum value is 9. If file size is a concern, it is probably better to choose a binary format for saving data rather than to reduce the precision of the saved values. </p> <p>When called from inside a function with the <code>"local"</code> option, the variable is changed locally for the function and any subroutines it calls. The original variable value is restored when exiting the function. </p> <p><strong>See also:</strong> <a href="#XREFsave_005fdefault_005foptions">save_default_options</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-save_005fheader_005fformat_005fstring">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>save_header_format_string</strong> <em>()</em><a href="#index-save_005fheader_005fformat_005fstring" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save_005fheader_005fformat_005fstring-1">
<span class="category">: </span><span><em><var>old_val</var> =</em> <strong>save_header_format_string</strong> <em>(<var>new_val</var>)</em><a href="#index-save_005fheader_005fformat_005fstring-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-save_005fheader_005fformat_005fstring-2">
<span class="category">: </span><span><em><var>old_val</var> =</em> <strong>save_header_format_string</strong> <em>(<var>new_val</var>, "local")</em><a href="#index-save_005fheader_005fformat_005fstring-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Query or set the internal variable that specifies the format string used for the comment line written at the beginning of text-format data files saved by Octave. </p> <p>The format string is passed to <code>strftime</code> and must begin with the character ‘<samp>#</samp>’ and contain no newline characters. If the value of <code>save_header_format_string</code> is the empty string, the header comment is omitted from text-format data files. The default value is </p> <pre class="example" data-language="matlab">"# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z &lt;USER@HOST&gt;"</pre> <p>When called from inside a function with the <code>"local"</code> option, the variable is changed locally for the function and any subroutines it calls. The original variable value is restored when exiting the function. </p> <p><strong>See also:</strong> <a href="timing-utilities.html#XREFstrftime">strftime</a>, <a href="#XREFsave_005fdefault_005foptions">save_default_options</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-load">
<span class="category">: </span><span> <strong>load</strong> <em>file</em><a href="#index-load" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-load-1">
<span class="category">: </span><span> <strong>load</strong> <em>options file</em><a href="#index-load-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-load-2">
<span class="category">: </span><span> <strong>load</strong> <em>options file v1 v2 …</em><a href="#index-load-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-load-3">
<span class="category">: </span><span><em>S =</em> <strong>load</strong> <em>("options", "file", "v1", "v2", …)</em><a href="#index-load-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-load-4">
<span class="category">: </span><span> <strong>load</strong> <em>file options</em><a href="#index-load-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-load-5">
<span class="category">: </span><span> <strong>load</strong> <em>file options v1 v2 …</em><a href="#index-load-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-load-6">
<span class="category">: </span><span><em>S =</em> <strong>load</strong> <em>("file", "options", "v1", "v2", …)</em><a href="#index-load-6" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Load the named variables <var>v1</var>, <var>v2</var>, …, from the file <var>file</var>. </p> <p>If no variables are specified then all variables found in the file will be loaded. As with <code>save</code>, the list of variables to extract can be full names or use a pattern syntax. The format of the file is automatically detected but may be overridden by supplying the appropriate option. </p> <p>If load is invoked using the functional form </p> <pre class="example" data-language="matlab">load ("-option1", …, "file", "v1", …)</pre> <p>then the <var>options</var>, <var>file</var>, and variable name arguments (<var>v1</var>, …) must be specified as character strings. </p> <p>If a variable that is not marked as global is loaded from a file when a global symbol with the same name already exists, it is loaded in the global symbol table. Also, if a variable is marked as global in a file and a local symbol exists, the local symbol is moved to the global symbol table and given the value from the file. </p> <p>If invoked with a single output argument, Octave returns data instead of inserting variables in the symbol table. If the data file contains only numbers (TAB- or space-delimited columns), a matrix of values is returned. Otherwise, <code>load</code> returns a structure with members corresponding to the names of the variables in the file. </p> <p>The <code>load</code> command can read data stored in Octave’s text and binary formats, and <small>MATLAB</small>’s binary format. If compiled with zlib support, it can also load gzip-compressed files. It will automatically detect the type of file and do conversion from different floating point formats (currently only IEEE big and little endian, though other formats may be added in the future). </p> <p>Valid options for <code>load</code> are listed in the following table. </p> <dl compact> <dt><span><code>-force</code></span></dt> <dd>
<p>This option is accepted for backward compatibility but is ignored. Octave now overwrites variables currently in memory with those of the same name found in the file. </p> </dd> <dt><span><code>-ascii</code></span></dt> <dd>
<p>Force Octave to assume the file contains columns of numbers in text format without any header or other information. Data in the file will be loaded as a single numeric matrix with the name of the variable derived from the name of the file. </p> </dd> <dt><span><code>-binary</code></span></dt> <dd>
<p>Force Octave to assume the file is in Octave’s binary format. </p> </dd> <dt><span><code>-hdf5</code></span></dt> <dd>
<p>Force Octave to assume the file is in <small>HDF5</small> format. (<small>HDF5</small> is a free, portable binary format developed by the National Center for Supercomputing Applications at the University of Illinois.) Note that Octave can only read <small>HDF5</small> files that were created by itself with <code>save</code>. This format is only available if Octave was built with a link to the <small>HDF5</small> libraries. </p> </dd> <dt><span><code>-import</code></span></dt> <dd>
<p>This option is accepted for backward compatibility but is ignored. Octave can now support multi-dimensional HDF data and automatically modifies variable names if they are invalid Octave identifiers. </p> </dd> <dt><span><code>-text</code></span></dt> <dd>
<p>Force Octave to assume the file is in Octave’s text format. </p> </dd> <dt><span><code>-v7.3</code></span></dt> <dt><span><code>-V7.3</code></span></dt> <dt><span><code>-7.3</code></span></dt> <dd>
<p>Octave does <strong>not</strong> yet implement <small>MATLAB</small>’s v7.3 binary data format. </p> </dd> <dt><span><code>-v7</code></span></dt> <dt><span><code>-V7</code></span></dt> <dt><span><code>-7</code></span></dt> <dt><span><code>-mat7-binary</code></span></dt> <dd>
<p>Force Octave to assume the file is in <small>MATLAB</small>’s version 7 binary format. </p> </dd> <dt><span><code>-v6</code></span></dt> <dt><span><code>-V6</code></span></dt> <dt><span><code>-6</code></span></dt> <dt><span><code>-mat</code></span></dt> <dt><span><code>-mat-binary</code></span></dt> <dd>
<p>Force Octave to assume the file is in <small>MATLAB</small>’s version 6 binary format. </p> </dd> <dt><span><code>-v4</code></span></dt> <dt><span><code>-V4</code></span></dt> <dt><span><code>-4</code></span></dt> <dt><span><code>-mat4-binary</code></span></dt> <dd>
<p>Force Octave to assume the file is in <small>MATLAB</small>’s version 4 binary format. </p> </dd> </dl> <p><strong>See also:</strong> <a href="#XREFsave">save</a>, <a href="#XREFdlmwrite">dlmwrite</a>, <a href="#XREFcsvwrite">csvwrite</a>, <a href="binary-i_002fo.html#XREFfwrite">fwrite</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-fileread">
<span class="category">: </span><span><em><var>str</var> =</em> <strong>fileread</strong> <em>(<var>filename</var>)</em><a href="#index-fileread" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Read the contents of <var>filename</var> and return it as a string. </p> <p><strong>See also:</strong> <a href="binary-i_002fo.html#XREFfread">fread</a>, <a href="formatted-input.html#XREFfscanf">fscanf</a>, <a href="#XREFimportdata">importdata</a>, <a href="#XREFtextscan">textscan</a>, <a href="status-of-variables.html#XREFtype">type</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-native_005ffloat_005fformat">
<span class="category">: </span><span><em><var>fmtstr</var> =</em> <strong>native_float_format</strong> <em>()</em><a href="#index-native_005ffloat_005fformat" class="copiable-anchor"> ¶</a></span>
</dt> <dd><p>Return the native floating point format as a string. </p></dd>
</dl> <p>It is possible to write data to a file in a similar way to the <code>disp</code> function for writing data to the screen. The <code>fdisp</code> works just like <code>disp</code> except its first argument is a file pointer as created by <code>fopen</code>. As an example, the following code writes to data ‘<samp>myfile.txt</samp>’. </p> <pre class="example" data-language="matlab">fid = fopen ("myfile.txt", "w");
fdisp (fid, "3/8 is ");
fdisp (fid, 3/8);
fclose (fid);</pre> <p>See <a href="opening-and-closing-files.html">Opening and Closing Files</a>, for details on how to use <code>fopen</code> and <code>fclose</code>. </p> <dl class="def"> <dt id="index-fdisp">
<span class="category">: </span><span> <strong>fdisp</strong> <em>(<var>fid</var>, <var>x</var>)</em><a href="#index-fdisp" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Display the value of <var>x</var> on the stream <var>fid</var>. </p> <p>For example: </p> <pre class="example" data-language="matlab">fdisp (stdout, "The value of pi is:"), fdisp (stdout, pi)

     -| the value of pi is:
     -| 3.1416</pre> <p>Note that the output from <code>fdisp</code> always ends with a newline. </p> <p><strong>See also:</strong> <a href="terminal-output.html#XREFdisp">disp</a>. </p>
</dd>
</dl> <p>Octave can also read and write matrices text files such as comma separated lists. </p> <dl class="def"> <dt id="index-dlmwrite">
<span class="category">: </span><span> <strong>dlmwrite</strong> <em>(<var>file</var>, <var>M</var>)</em><a href="#index-dlmwrite" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-dlmwrite-1">
<span class="category">: </span><span> <strong>dlmwrite</strong> <em>(<var>file</var>, <var>M</var>, <var>delim</var>, <var>r</var>, <var>c</var>)</em><a href="#index-dlmwrite-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-dlmwrite-2">
<span class="category">: </span><span> <strong>dlmwrite</strong> <em>(<var>file</var>, <var>M</var>, <var>key</var>, <var>val</var> …)</em><a href="#index-dlmwrite-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-dlmwrite-3">
<span class="category">: </span><span> <strong>dlmwrite</strong> <em>(<var>file</var>, <var>M</var>, "-append", …)</em><a href="#index-dlmwrite-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-dlmwrite-4">
<span class="category">: </span><span> <strong>dlmwrite</strong> <em>(<var>fid</var>, …)</em><a href="#index-dlmwrite-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Write the numeric matrix <var>M</var> to the text file <var>file</var> using a delimiter. </p> <p><var>file</var> should be a filename or a writable file ID given by <code>fopen</code>. </p> <p>The parameter <var>delim</var> specifies the delimiter to use to separate values on a row. If no delimiter is specified the comma character ‘<samp>,</samp>’ is used. </p> <p>The value of <var>r</var> specifies the number of delimiter-only lines to add to the start of the file. </p> <p>The value of <var>c</var> specifies the number of delimiters to prepend to each line of data. </p> <p>If the argument <code>"-append"</code> is given, append to the end of <var>file</var>. </p> <p>In addition, the following keyword value pairs may appear at the end of the argument list: </p> <dl compact> <dt><span><code>"append"</code></span></dt> <dd>
<p>Either <code>"on"</code> or <code>"off"</code>. See <code>"-append"</code> above. </p> </dd> <dt><span><code>"delimiter"</code></span></dt> <dd>
<p>See <var>delim</var> above. </p> </dd> <dt><span><code>"newline"</code></span></dt> <dd>
<p>The character(s) to separate each row. Three special cases exist for this option. <code>"unix"</code> is changed into <code>"\n"</code>, <code>"pc"</code> is changed into <code>"\r\n"</code>, and <code>"mac"</code> is changed into <code>"\r"</code>. Any other value is used directly as the newline separator. </p> </dd> <dt><span><code>"roffset"</code></span></dt> <dd>
<p>See <var>r</var> above. </p> </dd> <dt><span><code>"coffset"</code></span></dt> <dd>
<p>See <var>c</var> above. </p> </dd> <dt><span><code>"precision"</code></span></dt> <dd><p>The precision to use when writing the file. It can either be a format string (as used by fprintf) or a number of significant digits. </p></dd> </dl> <pre class="example" data-language="matlab">dlmwrite ("file.csv", reshape (1:16, 4, 4));</pre> <pre class="example" data-language="matlab">dlmwrite ("file.tex", a, "delimiter", "&amp;", "newline", "\n")</pre> <p><strong>See also:</strong> <a href="#XREFdlmread">dlmread</a>, <a href="#XREFcsvread">csvread</a>, <a href="#XREFcsvwrite">csvwrite</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-dlmread">
<span class="category">: </span><span><em><var>data</var> =</em> <strong>dlmread</strong> <em>(<var>file</var>)</em><a href="#index-dlmread" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-dlmread-1">
<span class="category">: </span><span><em><var>data</var> =</em> <strong>dlmread</strong> <em>(<var>file</var>, <var>sep</var>)</em><a href="#index-dlmread-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-dlmread-2">
<span class="category">: </span><span><em><var>data</var> =</em> <strong>dlmread</strong> <em>(<var>file</var>, <var>sep</var>, <var>r0</var>, <var>c0</var>)</em><a href="#index-dlmread-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-dlmread-3">
<span class="category">: </span><span><em><var>data</var> =</em> <strong>dlmread</strong> <em>(<var>file</var>, <var>sep</var>, <var>range</var>)</em><a href="#index-dlmread-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-dlmread-4">
<span class="category">: </span><span><em><var>data</var> =</em> <strong>dlmread</strong> <em>(…, "emptyvalue", <var>EMPTYVAL</var>)</em><a href="#index-dlmread-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Read numeric data from the text file <var>file</var> which uses the delimiter <var>sep</var> between data values. </p> <p>If <var>sep</var> is not defined the separator between fields is determined from the file itself. </p> <p>The optional scalar arguments <var>r0</var> and <var>c0</var> define the starting row and column of the data to be read. These values are indexed from zero, i.e., the first data row corresponds to an index of zero. </p> <p>The <var>range</var> parameter specifies exactly which data elements are read. The first form of the parameter is a 4-element vector containing the upper left and lower right corners <code>[<var>R0</var>,<var>C0</var>,<var>R1</var>,<var>C1</var>]</code> where the indices are zero-based. To specify the last column—the equivalent of <code>end</code> when indexing—use the specifier <code>Inf</code>. Alternatively, a spreadsheet style form such as <code>"A2..Q15"</code> or <code>"T1:AA5"</code> can be used. The lowest alphabetical index <code>'A'</code> refers to the first column. The lowest row index is 1. </p> <p><var>file</var> should be a filename or a file id given by <code>fopen</code>. In the latter case, the file is read until end of file is reached. </p> <p>The <code>"emptyvalue"</code> option may be used to specify the value used to fill empty fields. The default is zero. Note that any non-numeric values, such as text, are also replaced by the <code>"emptyvalue"</code>. </p> <p><strong>See also:</strong> <a href="#XREFcsvread">csvread</a>, <a href="#XREFtextscan">textscan</a>, <a href="#XREFdlmwrite">dlmwrite</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-csvwrite">
<span class="category">: </span><span> <strong>csvwrite</strong> <em>(<var>filename</var>, <var>x</var>)</em><a href="#index-csvwrite" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-csvwrite-1">
<span class="category">: </span><span> <strong>csvwrite</strong> <em>(<var>filename</var>, <var>x</var>, <var>dlm_opt1</var>, …)</em><a href="#index-csvwrite-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Write the numeric matrix <var>x</var> to the file <var>filename</var> in <span class="nolinebreak">comma-separated-value</span> (CSV) format. </p> <p>This function is equivalent to </p> <pre class="example" data-language="matlab">dlmwrite (filename, x, ",", dlm_opt1, …)</pre> <p>Any optional arguments are passed directly to <code>dlmwrite</code> (see <a href="#XREFdlmwrite"><code>dlmwrite</code></a>). </p> <p><strong>See also:</strong> <a href="#XREFcsvread">csvread</a>, <a href="#XREFdlmwrite">dlmwrite</a>, <a href="#XREFdlmread">dlmread</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-csvread">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>csvread</strong> <em>(<var>filename</var>)</em><a href="#index-csvread" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-csvread-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>csvread</strong> <em>(<var>filename</var>, <var>dlm_opt1</var>, …)</em><a href="#index-csvread-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Read the comma-separated-value (CSV) file <var>filename</var> into the matrix <var>x</var>. </p> <p>Note: only CSV files containing numeric data can be read. </p> <p>This function is equivalent to </p> <pre class="example" data-language="matlab">x = dlmread (filename, "," , dlm_opt1, …)</pre> <p>Any optional arguments are passed directly to <code>dlmread</code> (see <a href="#XREFdlmread"><code>dlmread</code></a>). </p> <p><strong>See also:</strong> <a href="#XREFdlmread">dlmread</a>, <a href="#XREFtextscan">textscan</a>, <a href="#XREFcsvwrite">csvwrite</a>, <a href="#XREFdlmwrite">dlmwrite</a>. </p>
</dd>
</dl> <p>Formatted data from can be read from, or written to, text files as well. </p> <dl class="def"> <dt id="index-textread">
<span class="category">: </span><span><em>[<var>a</var>, …] =</em> <strong>textread</strong> <em>(<var>filename</var>)</em><a href="#index-textread" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-textread-1">
<span class="category">: </span><span><em>[<var>a</var>, …] =</em> <strong>textread</strong> <em>(<var>filename</var>, <var>format</var>)</em><a href="#index-textread-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-textread-2">
<span class="category">: </span><span><em>[<var>a</var>, …] =</em> <strong>textread</strong> <em>(<var>filename</var>, <var>format</var>, <var>n</var>)</em><a href="#index-textread-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-textread-3">
<span class="category">: </span><span><em>[<var>a</var>, …] =</em> <strong>textread</strong> <em>(<var>filename</var>, <var>format</var>, <var>prop1</var>, <var>value1</var>, …)</em><a href="#index-textread-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-textread-4">
<span class="category">: </span><span><em>[<var>a</var>, …] =</em> <strong>textread</strong> <em>(<var>filename</var>, <var>format</var>, <var>n</var>, <var>prop1</var>, <var>value1</var>, …)</em><a href="#index-textread-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>This function is obsolete. Use <code>textscan</code> instead. </p> <p>Read data from a text file. </p> <p>The file <var>filename</var> is read and parsed according to <var>format</var>. The function behaves like <code>strread</code> except it works by parsing a file instead of a string. See the documentation of <code>strread</code> for details. </p> <p>In addition to the options supported by <code>strread</code>, this function supports two more: </p> <ul> <li> <code>"headerlines"</code>: The first <var>value</var> number of lines of <var>filename</var> are skipped. </li>
<li> <code>"endofline"</code>: Specify a single character or <code>"\r\n"</code>. If no value is given, it will be inferred from the file. If set to <code>""</code> (empty string) EOLs are ignored as delimiters. </li>
</ul> <p>The optional input <var>n</var> (format repeat count) specifies the number of times the format string is to be used or the number of lines to be read, whichever happens first while reading. The former is equivalent to requesting that the data output vectors should be of length <var>N</var>. Note that when reading files with format strings referring to multiple lines, <var>n</var> should rather be the number of lines to be read than the number of format string uses. </p> <p>If the format string is empty (not just omitted) and the file contains only numeric data (excluding headerlines), textread will return a rectangular matrix with the number of columns matching the number of numeric fields on the first data line of the file. Empty fields are returned as zero values. </p> <p>Examples: </p> <pre class="example" data-language="matlab">Assume a data file like:
  1 a 2 b
  3 c 4 d
  5 e</pre> <pre class="example" data-language="matlab">[a, b] = textread (f, "%f %s")
  returns two columns of data, one with doubles, the other a
  cellstr array:
  a = [1; 2; 3; 4; 5]
  b = {"a"; "b"; "c"; "d"; "e"}</pre> <pre class="example" data-language="matlab">[a, b] = textread (f, "%f %s", 3)
  (read data into two culumns, try to use the format string
  three times)
  returns
  a = [1; 2; 3]
  b = {"a"; "b"; "c"}</pre> <pre class="example" data-language="matlab">With a data file like:
  1
  a
  2
  b

  [a, b] = textread (f, "%f %s", 2)
  returns a = 1 and b = {"a"}; i.e., the format string is used
  only once because the format string refers to 2 lines of the
  data file.  To obtain 2x1 data output columns, specify N = 4
  (number of data lines containing all requested data) rather
  than 2.</pre> <p><strong>See also:</strong> <a href="#XREFtextscan">textscan</a>, <a href="#XREFload">load</a>, <a href="#XREFdlmread">dlmread</a>, <a href="formatted-input.html#XREFfscanf">fscanf</a>, <a href="numerical-data-and-strings.html#XREFstrread">strread</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-textscan">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>textscan</strong> <em>(<var>fid</var>, <var>format</var>)</em><a href="#index-textscan" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-textscan-1">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>textscan</strong> <em>(<var>fid</var>, <var>format</var>, <var>repeat</var>)</em><a href="#index-textscan-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-textscan-2">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>textscan</strong> <em>(<var>fid</var>, <var>format</var>, <var>param</var>, <var>value</var>, …)</em><a href="#index-textscan-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-textscan-3">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>textscan</strong> <em>(<var>fid</var>, <var>format</var>, <var>repeat</var>, <var>param</var>, <var>value</var>, …)</em><a href="#index-textscan-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-textscan-4">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>textscan</strong> <em>(<var>str</var>, …)</em><a href="#index-textscan-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-textscan-5">
<span class="category">: </span><span><em>[<var>C</var>, <var>position</var>, <var>errmsg</var>] =</em> <strong>textscan</strong> <em>(…)</em><a href="#index-textscan-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Read data from a text file or string. </p> <p>The string <var>str</var> or file associated with <var>fid</var> is read from and parsed according to <var>format</var>. The function is an extension of <code>strread</code> and <code>textread</code>. Differences include: the ability to read from either a file or a string, additional options, and additional format specifiers. </p> <p>The input is interpreted as a sequence of words, delimiters (such as whitespace), and literals. The characters that form delimiters and whitespace are determined by the options. The format consists of format specifiers interspersed between literals. In the format, whitespace forms a delimiter between consecutive literals, but is otherwise ignored. </p> <p>The output <var>C</var> is a cell array where the number of columns is determined by the number of format specifiers. </p> <p>The first word of the input is matched to the first specifier of the format and placed in the first column of the output; the second is matched to the second specifier and placed in the second column and so forth. If there are more words than specifiers then the process is repeated until all words have been processed or the limit imposed by <var>repeat</var> has been met (see below). </p> <p>The string <var>format</var> describes how the words in <var>str</var> should be parsed. As in <var>fscanf</var>, any (non-whitespace) text in the format that is not one of these specifiers is considered a literal. If there is a literal between two format specifiers then that same literal must appear in the input stream between the matching words. </p> <p>The following specifiers are valid: </p> <dl compact> <dt><span><code>%f</code></span></dt> <dt><span><code>%f64</code></span></dt> <dt><span><code>%n</code></span></dt> <dd>
<p>The word is parsed as a number and converted to double. </p> </dd> <dt><span><code>%f32</code></span></dt> <dd>
<p>The word is parsed as a number and converted to single (float). </p> </dd> <dt><span><code>%d</code></span></dt> <dt><span><code>%d8</code></span></dt> <dt><span><code>%d16</code></span></dt> <dt><span><code>%d32</code></span></dt> <dt><span><code>%d64</code></span></dt> <dd>
<p>The word is parsed as a number and converted to int8, int16, int32, or int64. If no size is specified then int32 is used. </p> </dd> <dt><span><code>%u</code></span></dt> <dt><span><code>%u8</code></span></dt> <dt><span><code>%u16</code></span></dt> <dt><span><code>%u32</code></span></dt> <dt><span><code>%u64</code></span></dt> <dd>
<p>The word is parsed as a number and converted to uint8, uint16, uint32, or uint64. If no size is specified then uint32 is used. </p> </dd> <dt><span><code>%s</code></span></dt> <dd>
<p>The word is parsed as a string ending at the last character before whitespace, an end-of-line, or a delimiter specified in the options. </p> </dd> <dt><span><code>%q</code></span></dt> <dd>
<p>The word is parsed as a "quoted string". If the first character of the string is a double quote (") then the string includes everything until a matching double quote—including whitespace, delimiters, and end-of-line characters. If a pair of consecutive double quotes appears in the input, it is replaced in the output by a single double quote. For examples, the input "He said ""Hello""" would return the value ’He said "Hello"’. </p> </dd> <dt><span><code>%c</code></span></dt> <dd>
<p>The next character of the input is read. This includes delimiters, whitespace, and end-of-line characters. </p> </dd> <dt><span><code>%[…]</code></span></dt> <dt><span><code>%[^…]</code></span></dt> <dd>
<p>In the first form, the word consists of the longest run consisting of only characters between the brackets. Ranges of characters can be specified by a hyphen; for example, %[0-9a-zA-Z] matches all alphanumeric characters (if the underlying character set is ASCII). Since <small>MATLAB</small> treats hyphens literally, this expansion only applies to alphanumeric characters. To include ’-’ in the set, it should appear first or last in the brackets; to include ’]’, it should be the first character. If the first character is ’^’ then the word consists of characters <strong>not</strong> listed. </p> </dd> <dt><span><code>%N…</code></span></dt> <dd>
<p>For %s, %c %d, %f, %n, %u, an optional width can be specified as %Ns, etc. where N is an integer &gt; 1. For %c, this causes exactly N characters to be read instead of a single character. For the other specifiers, it is an upper bound on the number of characters read; normal delimiters can cause fewer characters to be read. For complex numbers, this limit applies to the real and imaginary components individually. For %f and %n, format specifiers like %N.Mf are allowed, where M is an upper bound on number of characters after the decimal point to be considered; subsequent digits are skipped. For example, the specifier %8.2f would read 12.345e6 as 1.234e7. </p> </dd> <dt><span><code>%*…</code></span></dt> <dd>
<p>The word specified by the remainder of the conversion specifier is skipped. </p> </dd> <dt><span><code>literals</code></span></dt> <dd><p>In addition the format may contain literal character strings; these will be skipped during reading. If the input string does not match this literal, the processing terminates. </p></dd> </dl> <p>Parsed words corresponding to the first specifier are returned in the first output argument and likewise for the rest of the specifiers. </p> <p>By default, if there is only one input argument, <var>format</var> is <tt>"%f"</tt>. This means that numbers are read from the input into a single column vector. If <var>format</var> is explicitly empty (<code>""</code>) then textscan will return data in a number of columns matching the number of fields on the first data line of the input. Either of these is suitable only when the input is exclusively numeric. </p> <p>For example, the string </p> <pre class="example" data-language="matlab">str = "\
Bunny Bugs   5.5\n\
Duck Daffy  -7.5e-5\n\
Penguin Tux   6"</pre> <p>can be read using </p> <pre class="example" data-language="matlab">a = textscan (str, "%s %s %f");</pre> <p>The optional numeric argument <var>repeat</var> can be used for limiting the number of items read: </p> <dl compact> <dt><span>-1</span></dt> <dd>
<p>Read all of the string or file until the end (default). </p> </dd> <dt><span>N</span></dt> <dd><p>Read until the first of two conditions occurs: 1) the format has been processed N times, or 2) N lines of the input have been processed. Zero (0) is an acceptable value for <var>repeat</var>. Currently, end-of-line characters inside %q, %c, and %[…]$ conversions do not contribute to the line count. This is incompatible with <small>MATLAB</small> and may change in future. </p></dd> </dl> <p>The behavior of <code>textscan</code> can be changed via property/value pairs. The following properties are recognized: </p> <dl compact> <dt><span><code>"BufSize"</code></span></dt> <dd>
<p>This specifies the number of bytes to use for the internal buffer. A modest speed improvement may be obtained by setting this to a large value when reading a large file, especially if the input contains long strings. The default is 4096, or a value dependent on <var>n</var> if that is specified. </p> </dd> <dt><span><code>"CollectOutput"</code></span></dt> <dd>
<p>A value of 1 or true instructs <code>textscan</code> to concatenate consecutive columns of the same class in the output cell array. A value of 0 or false (default) leaves output in distinct columns. </p> </dd> <dt><span><code>"CommentStyle"</code></span></dt> <dd>
<p>Specify parts of the input which are considered comments and will be skipped. <var>value</var> is the comment style and can be either (1) A string or 1x1 cell string, to skip everything to the right of it; (2) A cell array of two strings, to skip everything between the first and second strings. Comments are only parsed where whitespace is accepted and do not act as delimiters. </p> </dd> <dt><span><code>"Delimiter"</code></span></dt> <dd>
<p>If <var>value</var> is a string, any character in <var>value</var> will be used to split the input into words. If <var>value</var> is a cell array of strings, any string in the array will be used to split the input into words. (default value = any whitespace.) </p> </dd> <dt><span><code>"EmptyValue"</code></span></dt> <dd>
<p>Value to return for empty numeric values in non-whitespace delimited data. The default is NaN. When the data type does not support NaN (int32 for example), then the default is zero. </p> </dd> <dt><span><code>"EndOfLine"</code></span></dt> <dd>
<p><var>value</var> can be either an empty or one character specifying the end-of-line character, or the pair <code>"\r\n"</code> (CRLF). In the latter case, any of <code>"\r"</code>, <code>"\n"</code> or <code>"\r\n"</code> is counted as a (single) newline. If no value is given, <code>"\r\n"</code> is used. </p> </dd> <dt><span><code>"HeaderLines"</code></span></dt> <dd>
<p>The first <var>value</var> number of lines of <var>fid</var> are skipped. Note that this does not refer to the first non-comment lines, but the first lines of any type. </p> </dd> <dt><span><code>"MultipleDelimsAsOne"</code></span></dt> <dd>
<p>If <var>value</var> is nonzero, treat a series of consecutive delimiters, without whitespace in between, as a single delimiter. Consecutive delimiter series need not be vertically aligned. Without this option, a single delimiter before the end of the line does not cause the line to be considered to end with an empty value, but a single delimiter at the start of a line causes the line to be considered to start with an empty value. </p> </dd> <dt><span><code>"TreatAsEmpty"</code></span></dt> <dd>
<p>Treat single occurrences (surrounded by delimiters or whitespace) of the string(s) in <var>value</var> as missing values. </p> </dd> <dt><span><code>"ReturnOnError"</code></span></dt> <dd>
<p>If set to numerical 1 or true, return normally as soon as an error is encountered, such as trying to read a string using <code>%f</code>. If set to 0 or false, return an error and no data. </p> </dd> <dt><span><code>"Whitespace"</code></span></dt> <dd>
<p>Any character in <var>value</var> will be interpreted as whitespace and trimmed; The default value for whitespace is <code>"
\b\r\n\t"</code> (note the space). Unless whitespace is set to <code>""</code> (empty) AND at least one <code>"%s"</code> format conversion specifier is supplied, a space is always part of whitespace. </p> </dd> </dl> <p>When the number of words in <var>str</var> or <var>fid</var> doesn’t match an exact multiple of the number of format conversion specifiers, <code>textscan</code>’s behavior depends on whether the last character of the string or file is an end-of-line as specified by the <code>EndOfLine</code> option: </p> <dl compact> <dt><span>last character = end-of-line</span></dt> <dd>
<p>Data columns are padded with empty fields, NaN or 0 (for integer fields) so that all columns have equal length </p> </dd> <dt><span>last character is not end-of-line</span></dt> <dd><p>Data columns are not padded; <code>textscan</code> returns columns of unequal length </p></dd> </dl> <p>The second output <var>position</var> provides the location, in characters from the beginning of the file or string, where processing stopped. </p> <p><strong>See also:</strong> <a href="#XREFdlmread">dlmread</a>, <a href="formatted-input.html#XREFfscanf">fscanf</a>, <a href="#XREFload">load</a>, <a href="numerical-data-and-strings.html#XREFstrread">strread</a>, <a href="#XREFtextread">textread</a>. </p>
</dd>
</dl> <p>The <code>importdata</code> function has the ability to work with a wide variety of data. </p> <dl class="def"> <dt id="index-importdata">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>importdata</strong> <em>(<var>fname</var>)</em><a href="#index-importdata" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-importdata-1">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>importdata</strong> <em>(<var>fname</var>, <var>delimiter</var>)</em><a href="#index-importdata-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-importdata-2">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>importdata</strong> <em>(<var>fname</var>, <var>delimiter</var>, <var>header_rows</var>)</em><a href="#index-importdata-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-importdata-3">
<span class="category">: </span><span><em>[<var>A</var>, <var>delimiter</var>] =</em> <strong>importdata</strong> <em>(…)</em><a href="#index-importdata-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-importdata-4">
<span class="category">: </span><span><em>[<var>A</var>, <var>delimiter</var>, <var>header_rows</var>] =</em> <strong>importdata</strong> <em>(…)</em><a href="#index-importdata-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Import data from the file <var>fname</var>. </p> <p>Input parameters: </p> <ul> <li> <var>fname</var> The name of the file containing data. </li>
<li> <var>delimiter</var> The character separating columns of data. Use <code>\t</code> for tab. (Only valid for ASCII files) </li>
<li> <var>header_rows</var> The number of header rows before the data begins. (Only valid for ASCII files) </li>
</ul> <p>Different file types are supported: </p> <ul> <li> ASCII table <p>Import ASCII table using the specified number of header rows and the specified delimiter. </p> </li>
<li> Image file </li>
<li> <small>MATLAB</small> file </li>
<li> Spreadsheet files (depending on external software) </li>
<li> WAV file </li>
</ul> <p><strong>See also:</strong> <a href="#XREFtextscan">textscan</a>, <a href="#XREFdlmread">dlmread</a>, <a href="#XREFcsvread">csvread</a>, <a href="#XREFload">load</a>. </p>
</dd>
</dl> <p>After importing, the data may need to be transformed before further analysis. The <code>rescale</code> function can shift and normalize a data set to a specified range. </p> <dl class="def"> <dt id="index-rescale">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>rescale</strong> <em>(<var>A</var>)</em><a href="#index-rescale" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rescale-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>rescale</strong> <em>(<var>A</var>, <var>l</var>, <var>u</var>)</em><a href="#index-rescale-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rescale-2">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>rescale</strong> <em>(…, "inputmin", <var>inmin</var>)</em><a href="#index-rescale-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rescale-3">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>rescale</strong> <em>(…, "inputmax", <var>inmax</var>)</em><a href="#index-rescale-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Scale matrix elements to a specified range of values. </p> <p>When called with a single matrix argument <var>A</var>, rescale elements to occupy the interval [0, 1]. </p> <p>The optional inputs <code>[<var>l</var>, <var>u</var>]</code> will scale <var>A</var> to the interval with lower bound <var>l</var> and upper bound <var>u</var>. </p> <p>The optional input <code>"inputmin"</code> replaces all elements less than the specified value <var>inmin</var> with <var>inmin</var>. Similarly, the optional input <code>"inputmax"</code> replaces all elements greater than the specified value <var>inmax</var> with <var>inmax</var>. If unspecified the minimum and maximum are taken from the data itself (<code><var>inmin</var> = min (A(:))</code> and <code><var>inmax</var> = max (A(:))</code>). </p> <p>Programming Notes: The applied formula is </p> <p><var>B</var> = <var>l</var> + ((<var>A</var> - <var>inmin</var>) ./ (<var>inmax</var> - <var>inmin</var>)) .* (<var>u</var> - <var>l</var>) </p> <p>The class of the output matrix <var>B</var> is single if the input <var>A</var> is single, but otherwise is of class double for inputs which are of double, integer, or logical type. </p> <p><strong>See also:</strong> <a href="descriptive-statistics.html#XREFbounds">bounds</a>, <a href="utility-functions.html#XREFmin">min</a>, <a href="utility-functions.html#XREFmax">max</a>. </p>
</dd>
</dl> <ul class="section-toc"> <li><a href="saving-data-on-unexpected-exits.html" accesskey="1">Saving Data on Unexpected Exits</a></li> </ul> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Simple-File-I_002fO.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Simple-File-I_002fO.html</a>
  </p>
</div>
