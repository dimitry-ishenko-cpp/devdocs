<div class="subsection-level-extent" id="Binary-I_002fO"> <div class="nav-panel"> <p> Next: <a href="temporary-files.html" accesskey="n" rel="next">Temporary Files</a>, Previous: <a href="string-input-conversions.html" accesskey="p" rel="prev">String Input Conversions</a>, Up: <a href="c_002dstyle-i_002fo-functions.html" accesskey="u" rel="up">C-Style I/O Functions</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="Binary-I_002fO-1"><span>14.2.16 Binary I/O<a class="copiable-link" href="#Binary-I_002fO-1"> ¶</a></span></h1> <p>Octave can read and write binary data using the functions <code class="code">fread</code> and <code class="code">fwrite</code>, which are patterned after the standard C functions with the same names. They are able to automatically swap the byte order of integer data and convert among the supported floating point formats as the data are read. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fread">
<span class="category-def">: </span><span><code class="def-type"><var class="var">val</var> =</code> <strong class="def-name">fread</strong> <code class="def-code-arguments">(<var class="var">fid</var>)</code><a class="copiable-link" href="#index-fread"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fread-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">val</var> =</code> <strong class="def-name">fread</strong> <code class="def-code-arguments">(<var class="var">fid</var>, <var class="var">size</var>)</code><a class="copiable-link" href="#index-fread-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fread-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">val</var> =</code> <strong class="def-name">fread</strong> <code class="def-code-arguments">(<var class="var">fid</var>, <var class="var">size</var>, <var class="var">precision</var>)</code><a class="copiable-link" href="#index-fread-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fread-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">val</var> =</code> <strong class="def-name">fread</strong> <code class="def-code-arguments">(<var class="var">fid</var>, <var class="var">size</var>, <var class="var">precision</var>, <var class="var">skip</var>)</code><a class="copiable-link" href="#index-fread-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fread-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">val</var> =</code> <strong class="def-name">fread</strong> <code class="def-code-arguments">(<var class="var">fid</var>, <var class="var">size</var>, <var class="var">precision</var>, <var class="var">skip</var>, <var class="var">arch</var>)</code><a class="copiable-link" href="#index-fread-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fread-5">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">val</var>, <var class="var">count</var>] =</code> <strong class="def-name">fread</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-fread-5"> ¶</a></span>
</dt> <dd>
<p>Read binary data from the file specified by the file descriptor <var class="var">fid</var>. </p> <p>The optional argument <var class="var">size</var> specifies the amount of data to read and may be one of </p> <dl class="table"> <dt><code class="code">Inf</code></dt> <dd>
<p>Read as much as possible, returning a column vector. </p> </dd> <dt><code class="code"><var class="var">nr</var></code></dt> <dd>
<p>Read up to <var class="var">nr</var> elements, returning a column vector. </p> </dd> <dt><code class="code">[<var class="var">nr</var>, Inf]</code></dt> <dd>
<p>Read as much as possible, returning a matrix with <var class="var">nr</var> rows. If the number of elements read is not an exact multiple of <var class="var">nr</var>, the last column is padded with zeros. </p> </dd> <dt><code class="code">[<var class="var">nr</var>, <var class="var">nc</var>]</code></dt> <dd><p>Read up to <code class="code"><var class="var">nr</var> * <var class="var">nc</var></code> elements, returning a matrix with <var class="var">nr</var> rows. If the number of elements read is not an exact multiple of <var class="var">nr</var>, the last column is padded with zeros. </p></dd> </dl> <p>If <var class="var">size</var> is omitted, a value of <code class="code">Inf</code> is assumed. </p> <p>The optional argument <var class="var">precision</var> is a string specifying the type of data to read and may be one of </p> <dl class="table"> <dt>
<code class="code">"uint8"</code> (default)</dt> <dd>
<p>8-bit unsigned integer. </p> </dd> <dt><code class="code">"int8"</code></dt> <dt><code class="code">"integer*1"</code></dt> <dd>
<p>8-bit signed integer. </p> </dd> <dt><code class="code">"uint16"</code></dt> <dt><code class="code">"ushort"</code></dt> <dt><code class="code">"unsigned short"</code></dt> <dd>
<p>16-bit unsigned integer. </p> </dd> <dt><code class="code">"int16"</code></dt> <dt><code class="code">"integer*2"</code></dt> <dt><code class="code">"short"</code></dt> <dd>
<p>16-bit signed integer. </p> </dd> <dt><code class="code">"uint"</code></dt> <dt><code class="code">"uint32"</code></dt> <dt><code class="code">"unsigned int"</code></dt> <dt><code class="code">"ulong"</code></dt> <dt><code class="code">"unsigned long"</code></dt> <dd>
<p>32-bit unsigned integer. </p> </dd> <dt><code class="code">"int"</code></dt> <dt><code class="code">"int32"</code></dt> <dt><code class="code">"integer*4"</code></dt> <dt><code class="code">"long"</code></dt> <dd>
<p>32-bit signed integer. </p> </dd> <dt><code class="code">"uint64"</code></dt> <dd>
<p>64-bit unsigned integer. </p> </dd> <dt><code class="code">"int64"</code></dt> <dt><code class="code">"integer*8"</code></dt> <dd>
<p>64-bit signed integer. </p> </dd> <dt><code class="code">"single"</code></dt> <dt><code class="code">"float"</code></dt> <dt><code class="code">"float32"</code></dt> <dt><code class="code">"real*4"</code></dt> <dd>
<p>32-bit floating point number. </p> </dd> <dt><code class="code">"double"</code></dt> <dt><code class="code">"float64"</code></dt> <dt><code class="code">"real*8"</code></dt> <dd>
<p>64-bit floating point number. </p> </dd> <dt><code class="code">"char"</code></dt> <dt><code class="code">"char*1"</code></dt> <dd>
<p>8-bit single character. </p> </dd> <dt><code class="code">"uchar"</code></dt> <dt><code class="code">"unsigned char"</code></dt> <dd>
<p>8-bit unsigned character. </p> </dd> <dt><code class="code">"schar"</code></dt> <dt><code class="code">"signed char"</code></dt> <dd>
<p>8-bit signed character. </p> </dd> </dl> <p>The default precision is <code class="code">"uint8"</code>. </p> <p>The <var class="var">precision</var> argument may also specify an optional repeat count. For example, ‘<samp class="samp">32*single</samp>’ causes <code class="code">fread</code> to read a block of 32 single precision floating point numbers. Reading in blocks is useful in combination with the <var class="var">skip</var> argument. </p> <p>The <var class="var">precision</var> argument may also specify a type conversion. For example, ‘<samp class="samp">int16=&gt;int32</samp>’ causes <code class="code">fread</code> to read 16-bit integer values and return an array of 32-bit integer values. By default, <code class="code">fread</code> returns a double precision array. The special form ‘<samp class="samp">*TYPE</samp>’ is shorthand for ‘<samp class="samp">TYPE=&gt;TYPE</samp>’. </p> <p>The conversion and repeat counts may be combined. For example, the specification ‘<samp class="samp">32*single=&gt;single</samp>’ causes <code class="code">fread</code> to read blocks of single precision floating point values and return an array of single precision values instead of the default array of double precision values. </p> <p>The optional argument <var class="var">skip</var> specifies the number of bytes to skip after each element (or block of elements) is read. If it is not specified, a value of 0 is assumed. If the final block read is not complete, the final skip is omitted. For example, </p> <pre class="example" data-language="matlab">fread (f, 10, "3*single=&gt;single", 8)</pre> <p>will omit the final 8-byte skip because the last read will not be a complete block of 3 values. </p> <p>The optional argument <var class="var">arch</var> is a string specifying the data format for the file. Valid values are </p> <dl class="table"> <dt>
<code class="code">"native"</code> or <code class="code">"n"</code>
</dt> <dd>
<p>The format of the current machine. </p> </dd> <dt>
<code class="code">"ieee-be"</code> or <code class="code">"b"</code>
</dt> <dd>
<p>IEEE big endian. </p> </dd> <dt>
<code class="code">"ieee-le"</code> or <code class="code">"l"</code>
</dt> <dd><p>IEEE little endian. </p></dd> </dl> <p>If no <var class="var">arch</var> is given the value used in the call to <code class="code">fopen</code> which created the file descriptor is used. Otherwise, the value specified with <code class="code">fread</code> overrides that of <code class="code">fopen</code> and determines the data format. </p> <p>The output argument <var class="var">val</var> contains the data read from the file. </p> <p>The optional return value <var class="var">count</var> contains the number of elements read. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfwrite">fwrite</a>, <a class="ref" href="line_002doriented-input.html#XREFfgets">fgets</a>, <a class="ref" href="line_002doriented-input.html#XREFfgetl">fgetl</a>, <a class="ref" href="formatted-input.html#XREFfscanf">fscanf</a>, <a class="ref" href="opening-and-closing-files.html#XREFfopen">fopen</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fwrite">
<span class="category-def">: </span><span><code class="def-type"><var class="var">count</var> =</code> <strong class="def-name">fwrite</strong> <code class="def-code-arguments">(<var class="var">fid</var>, <var class="var">data</var>)</code><a class="copiable-link" href="#index-fwrite"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fwrite-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">count</var> =</code> <strong class="def-name">fwrite</strong> <code class="def-code-arguments">(<var class="var">fid</var>, <var class="var">data</var>, <var class="var">precision</var>)</code><a class="copiable-link" href="#index-fwrite-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fwrite-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">count</var> =</code> <strong class="def-name">fwrite</strong> <code class="def-code-arguments">(<var class="var">fid</var>, <var class="var">data</var>, <var class="var">precision</var>, <var class="var">skip</var>)</code><a class="copiable-link" href="#index-fwrite-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fwrite-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">count</var> =</code> <strong class="def-name">fwrite</strong> <code class="def-code-arguments">(<var class="var">fid</var>, <var class="var">data</var>, <var class="var">precision</var>, <var class="var">skip</var>, <var class="var">arch</var>)</code><a class="copiable-link" href="#index-fwrite-3"> ¶</a></span>
</dt> <dd>
<p>Write data in binary form to the file specified by the file descriptor <var class="var">fid</var>. </p> <p>The argument <var class="var">data</var> is a matrix of values that are to be written to the file. The values are extracted in column-major order. </p> <p>The remaining arguments <var class="var">precision</var>, <var class="var">skip</var>, and <var class="var">arch</var> are optional, and are interpreted as described for <code class="code">fread</code>. </p> <p>The output <var class="var">count</var> is the number of data items successfully written. </p> <p>Programming Note: The behavior of <code class="code">fwrite</code> is undefined if the values in <var class="var">data</var> are too large to fit in the specified precision. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfread">fread</a>, <a class="ref" href="simple-output.html#XREFfputs">fputs</a>, <a class="ref" href="formatted-output.html#XREFfprintf">fprintf</a>, <a class="ref" href="opening-and-closing-files.html#XREFfopen">fopen</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="temporary-files.html">Temporary Files</a>, Previous: <a href="string-input-conversions.html">String Input Conversions</a>, Up: <a href="c_002dstyle-i_002fo-functions.html">C-Style I/O Functions</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Binary-I_002fO.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Binary-I_002fO.html</a>
  </p>
</div>
