<div class="subsection" id="Binary-I_002fO">   <h1 class="subsection">14.2.16 Binary I/O</h1> <p>Octave can read and write binary data using the functions <code>fread</code> and <code>fwrite</code>, which are patterned after the standard C functions with the same names. They are able to automatically swap the byte order of integer data and convert among the supported floating point formats as the data are read. </p> <dl class="def"> <dt id="index-fread">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>fread</strong> <em>(<var>fid</var>)</em><a href="#index-fread" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fread-1">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>fread</strong> <em>(<var>fid</var>, <var>size</var>)</em><a href="#index-fread-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fread-2">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>fread</strong> <em>(<var>fid</var>, <var>size</var>, <var>precision</var>)</em><a href="#index-fread-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fread-3">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>fread</strong> <em>(<var>fid</var>, <var>size</var>, <var>precision</var>, <var>skip</var>)</em><a href="#index-fread-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fread-4">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>fread</strong> <em>(<var>fid</var>, <var>size</var>, <var>precision</var>, <var>skip</var>, <var>arch</var>)</em><a href="#index-fread-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fread-5">
<span class="category">: </span><span><em>[<var>val</var>, <var>count</var>] =</em> <strong>fread</strong> <em>(…)</em><a href="#index-fread-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Read binary data from the file specified by the file descriptor <var>fid</var>. </p> <p>The optional argument <var>size</var> specifies the amount of data to read and may be one of </p> <dl compact> <dt><span><code>Inf</code></span></dt> <dd>
<p>Read as much as possible, returning a column vector. </p> </dd> <dt><span><code><var>nr</var></code></span></dt> <dd>
<p>Read up to <var>nr</var> elements, returning a column vector. </p> </dd> <dt><span><code>[<var>nr</var>, Inf]</code></span></dt> <dd>
<p>Read as much as possible, returning a matrix with <var>nr</var> rows. If the number of elements read is not an exact multiple of <var>nr</var>, the last column is padded with zeros. </p> </dd> <dt><span><code>[<var>nr</var>, <var>nc</var>]</code></span></dt> <dd><p>Read up to <code><var>nr</var> * <var>nc</var></code> elements, returning a matrix with <var>nr</var> rows. If the number of elements read is not an exact multiple of <var>nr</var>, the last column is padded with zeros. </p></dd> </dl> <p>If <var>size</var> is omitted, a value of <code>Inf</code> is assumed. </p> <p>The optional argument <var>precision</var> is a string specifying the type of data to read and may be one of </p> <dl compact> <dt><span><code>"uint8"</code> (default)</span></dt> <dd>
<p>8-bit unsigned integer. </p> </dd> <dt><span><code>"int8"</code></span></dt> <dt><span><code>"integer*1"</code></span></dt> <dd>
<p>8-bit signed integer. </p> </dd> <dt><span><code>"uint16"</code></span></dt> <dt><span><code>"ushort"</code></span></dt> <dt><span><code>"unsigned short"</code></span></dt> <dd>
<p>16-bit unsigned integer. </p> </dd> <dt><span><code>"int16"</code></span></dt> <dt><span><code>"integer*2"</code></span></dt> <dt><span><code>"short"</code></span></dt> <dd>
<p>16-bit signed integer. </p> </dd> <dt><span><code>"uint"</code></span></dt> <dt><span><code>"uint32"</code></span></dt> <dt><span><code>"unsigned int"</code></span></dt> <dt><span><code>"ulong"</code></span></dt> <dt><span><code>"unsigned long"</code></span></dt> <dd>
<p>32-bit unsigned integer. </p> </dd> <dt><span><code>"int"</code></span></dt> <dt><span><code>"int32"</code></span></dt> <dt><span><code>"integer*4"</code></span></dt> <dt><span><code>"long"</code></span></dt> <dd>
<p>32-bit signed integer. </p> </dd> <dt><span><code>"uint64"</code></span></dt> <dd>
<p>64-bit unsigned integer. </p> </dd> <dt><span><code>"int64"</code></span></dt> <dt><span><code>"integer*8"</code></span></dt> <dd>
<p>64-bit signed integer. </p> </dd> <dt><span><code>"single"</code></span></dt> <dt><span><code>"float"</code></span></dt> <dt><span><code>"float32"</code></span></dt> <dt><span><code>"real*4"</code></span></dt> <dd>
<p>32-bit floating point number. </p> </dd> <dt><span><code>"double"</code></span></dt> <dt><span><code>"float64"</code></span></dt> <dt><span><code>"real*8"</code></span></dt> <dd>
<p>64-bit floating point number. </p> </dd> <dt><span><code>"char"</code></span></dt> <dt><span><code>"char*1"</code></span></dt> <dd>
<p>8-bit single character. </p> </dd> <dt><span><code>"uchar"</code></span></dt> <dt><span><code>"unsigned char"</code></span></dt> <dd>
<p>8-bit unsigned character. </p> </dd> <dt><span><code>"schar"</code></span></dt> <dt><span><code>"signed char"</code></span></dt> <dd>
<p>8-bit signed character. </p> </dd> </dl> <p>The default precision is <code>"uint8"</code>. </p> <p>The <var>precision</var> argument may also specify an optional repeat count. For example, ‘<samp>32*single</samp>’ causes <code>fread</code> to read a block of 32 single precision floating point numbers. Reading in blocks is useful in combination with the <var>skip</var> argument. </p> <p>The <var>precision</var> argument may also specify a type conversion. For example, ‘<samp>int16=&gt;int32</samp>’ causes <code>fread</code> to read 16-bit integer values and return an array of 32-bit integer values. By default, <code>fread</code> returns a double precision array. The special form ‘<samp>*TYPE</samp>’ is shorthand for ‘<samp>TYPE=&gt;TYPE</samp>’. </p> <p>The conversion and repeat counts may be combined. For example, the specification ‘<samp>32*single=&gt;single</samp>’ causes <code>fread</code> to read blocks of single precision floating point values and return an array of single precision values instead of the default array of double precision values. </p> <p>The optional argument <var>skip</var> specifies the number of bytes to skip after each element (or block of elements) is read. If it is not specified, a value of 0 is assumed. If the final block read is not complete, the final skip is omitted. For example, </p> <pre class="example" data-language="matlab">fread (f, 10, "3*single=&gt;single", 8)</pre> <p>will omit the final 8-byte skip because the last read will not be a complete block of 3 values. </p> <p>The optional argument <var>arch</var> is a string specifying the data format for the file. Valid values are </p> <dl compact> <dt><span><code>"native"</code> or <code>"n"</code></span></dt> <dd>
<p>The format of the current machine. </p> </dd> <dt><span><code>"ieee-be"</code> or <code>"b"</code></span></dt> <dd>
<p>IEEE big endian. </p> </dd> <dt><span><code>"ieee-le"</code> or <code>"l"</code></span></dt> <dd><p>IEEE little endian. </p></dd> </dl> <p>If no <var>arch</var> is given the value used in the call to <code>fopen</code> which created the file descriptor is used. Otherwise, the value specified with <code>fread</code> overrides that of <code>fopen</code> and determines the data format. </p> <p>The output argument <var>val</var> contains the data read from the file. </p> <p>The optional return value <var>count</var> contains the number of elements read. </p> <p><strong>See also:</strong> <a href="#XREFfwrite">fwrite</a>, <a href="line_002doriented-input.html#XREFfgets">fgets</a>, <a href="line_002doriented-input.html#XREFfgetl">fgetl</a>, <a href="formatted-input.html#XREFfscanf">fscanf</a>, <a href="opening-and-closing-files.html#XREFfopen">fopen</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-fwrite">
<span class="category">: </span><span><em><var>count</var> =</em> <strong>fwrite</strong> <em>(<var>fid</var>, <var>data</var>)</em><a href="#index-fwrite" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fwrite-1">
<span class="category">: </span><span><em><var>count</var> =</em> <strong>fwrite</strong> <em>(<var>fid</var>, <var>data</var>, <var>precision</var>)</em><a href="#index-fwrite-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fwrite-2">
<span class="category">: </span><span><em><var>count</var> =</em> <strong>fwrite</strong> <em>(<var>fid</var>, <var>data</var>, <var>precision</var>, <var>skip</var>)</em><a href="#index-fwrite-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fwrite-3">
<span class="category">: </span><span><em><var>count</var> =</em> <strong>fwrite</strong> <em>(<var>fid</var>, <var>data</var>, <var>precision</var>, <var>skip</var>, <var>arch</var>)</em><a href="#index-fwrite-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Write data in binary form to the file specified by the file descriptor <var>fid</var>. </p> <p>The argument <var>data</var> is a matrix of values that are to be written to the file. The values are extracted in column-major order. </p> <p>The remaining arguments <var>precision</var>, <var>skip</var>, and <var>arch</var> are optional, and are interpreted as described for <code>fread</code>. </p> <p>The output <var>count</var> is the number of data items successfully written. </p> <p>Programming Note: The behavior of <code>fwrite</code> is undefined if the values in <var>data</var> are too large to fit in the specified precision. </p> <p><strong>See also:</strong> <a href="#XREFfread">fread</a>, <a href="simple-output.html#XREFfputs">fputs</a>, <a href="formatted-output.html#XREFfprintf">fprintf</a>, <a href="opening-and-closing-files.html#XREFfopen">fopen</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Binary-I_002fO.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Binary-I_002fO.html</a>
  </p>
</div>
