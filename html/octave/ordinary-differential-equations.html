<div class="section" id="Ordinary-Differential-Equations">   <h1 class="section">24.1 Ordinary Differential Equations</h1> <p>The function <code>lsode</code> can be used to solve ODEs of the form </p> <pre class="example" data-language="matlab">dx
-- = f (x, t)
dt</pre> <p>using Hindmarsh’s ODE solver <small>LSODE</small>. </p> <dl class="def"> <dt id="index-lsode">
<span class="category">: </span><span><em>[<var>x</var>, <var>istate</var>, <var>msg</var>] =</em> <strong>lsode</strong> <em>(<var>fcn</var>, <var>x_0</var>, <var>t</var>)</em><a href="#index-lsode" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-lsode-1">
<span class="category">: </span><span><em>[<var>x</var>, <var>istate</var>, <var>msg</var>] =</em> <strong>lsode</strong> <em>(<var>fcn</var>, <var>x_0</var>, <var>t</var>, <var>t_crit</var>)</em><a href="#index-lsode-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Ordinary Differential Equation (ODE) solver. </p> <p>The set of differential equations to solve is </p> <pre class="example" data-language="matlab">dx
-- = f (x, t)
dt</pre> <p>with </p> <pre class="example" data-language="matlab">x(t_0) = x_0</pre> <p>The solution is returned in the matrix <var>x</var>, with each row corresponding to an element of the vector <var>t</var>. The first element of <var>t</var> should be <em class="math">t_0</em> and should correspond to the initial state of the system <var>x_0</var>, so that the first row of the output is <var>x_0</var>. </p> <p>The first argument, <var>fcn</var>, is a string, inline, or function handle that names the function <em class="math">f</em> to call to compute the vector of right hand sides for the set of equations. The function must have the form </p> <pre class="example" data-language="matlab">xdot = f (x, t)</pre> <p>in which <var>xdot</var> and <var>x</var> are vectors and <var>t</var> is a scalar. </p> <p>If <var>fcn</var> is a two-element string array or a two-element cell array of strings, inline functions, or function handles, the first element names the function <em class="math">f</em> described above, and the second element names a function to compute the Jacobian of <em class="math">f</em>. The Jacobian function must have the form </p> <pre class="example" data-language="matlab">jac = j (x, t)</pre> <p>in which <var>jac</var> is the matrix of partial derivatives </p> <pre class="example" data-language="matlab">| df_1  df_1       df_1 |
             | ----  ----  ...  ---- |
             | dx_1  dx_2       dx_N |
             |                       |
             | df_2  df_2       df_2 |
             | ----  ----  ...  ---- |
      df_i   | dx_1  dx_2       dx_N |
jac = ---- = |                       |
      dx_j   |  .    .     .    .    |
             |  .    .      .   .    |
             |  .    .       .  .    |
             |                       |
             | df_M  df_M       df_M |
             | ----  ----  ...  ---- |
             | dx_1  dx_2       dx_N |</pre> <p>The second argument specifies the initial state of the system <em class="math">x_0</em>. The third argument is a vector, <var>t</var>, specifying the time values for which a solution is sought. </p> <p>The fourth argument is optional, and may be used to specify a set of times that the ODE solver should not integrate past. It is useful for avoiding difficulties with singularities and points where there is a discontinuity in the derivative. </p> <p>After a successful computation, the value of <var>istate</var> will be 2 (consistent with the Fortran version of <small>LSODE</small>). </p> <p>If the computation is not successful, <var>istate</var> will be something other than 2 and <var>msg</var> will contain additional information. </p> <p>You can use the function <code>lsode_options</code> to set optional parameters for <code>lsode</code>. </p> <p>See Alan C. Hindmarsh, <cite>ODEPACK, A Systematized Collection of ODE Solvers</cite>, in Scientific Computing, R. S. Stepleman, editor, (1983) or <a href="https://computing.llnl.gov/projects/odepack">https://computing.llnl.gov/projects/odepack</a> for more information about the inner workings of <code>lsode</code>. </p> <p>Example: Solve the Van der Pol equation </p> <pre class="example" data-language="matlab">fvdp = @(y,t) [y(2); (1 - y(1)^2) * y(2) - y(1)];
t = linspace (0, 20, 100);
y = lsode (fvdp, [2; 0], t);</pre> <p><strong>See also:</strong> <a href="differential_002dalgebraic-equations.html#XREFdaspk">daspk</a>, <a href="differential_002dalgebraic-equations.html#XREFdassl">dassl</a>, <a href="differential_002dalgebraic-equations.html#XREFdasrt">dasrt</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-lsode_005foptions">
<span class="category">: </span><span> <strong>lsode_options</strong> <em>()</em><a href="#index-lsode_005foptions" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-lsode_005foptions-1">
<span class="category">: </span><span><em>val =</em> <strong>lsode_options</strong> <em>(<var>opt</var>)</em><a href="#index-lsode_005foptions-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-lsode_005foptions-2">
<span class="category">: </span><span> <strong>lsode_options</strong> <em>(<var>opt</var>, <var>val</var>)</em><a href="#index-lsode_005foptions-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Query or set options for the function <code>lsode</code>. </p> <p>When called with no arguments, the names of all available options and their current values are displayed. </p> <p>Given one argument, return the value of the option <var>opt</var>. </p> <p>When called with two arguments, <code>lsode_options</code> sets the option <var>opt</var> to value <var>val</var>. </p> <p>Options include </p> <dl compact> <dt><span><code>"absolute tolerance"</code></span></dt> <dd>
<p>Absolute tolerance. May be either vector or scalar. If a vector, it must match the dimension of the state vector. </p> </dd> <dt><span><code>"relative tolerance"</code></span></dt> <dd>
<p>Relative tolerance parameter. Unlike the absolute tolerance, this parameter may only be a scalar. </p> <p>The local error test applied at each integration step is </p> <pre class="example" data-language="matlab">abs (local error in x(i)) &lt;= ...
      rtol * abs (y(i)) + atol(i)</pre> </dd> <dt><span><code>"integration method"</code></span></dt> <dd>
<p>A string specifying the method of integration to use to solve the ODE system. Valid values are </p> <dl compact> <dt><span><code>"adams"</code></span></dt> <dt><span><code>"non-stiff"</code></span></dt> <dd>
<p>No Jacobian used (even if it is available). </p> </dd> <dt><span><code>"bdf"</code></span></dt> <dt><span><code>"stiff"</code></span></dt> <dd><p>Use stiff backward differentiation formula (BDF) method. If a function to compute the Jacobian is not supplied, <code>lsode</code> will compute a finite difference approximation of the Jacobian matrix. </p></dd> </dl> </dd> <dt><span><code>"initial step size"</code></span></dt> <dd>
<p>The step size to be attempted on the first step (default is determined automatically). </p> </dd> <dt><span><code>"maximum order"</code></span></dt> <dd>
<p>Restrict the maximum order of the solution method. If using the Adams method, this option must be between 1 and 12. Otherwise, it must be between 1 and 5, inclusive. </p> </dd> <dt><span><code>"maximum step size"</code></span></dt> <dd>
<p>Setting the maximum stepsize will avoid passing over very large regions (default is not specified). </p> </dd> <dt><span><code>"minimum step size"</code></span></dt> <dd>
<p>The minimum absolute step size allowed (default is 0). </p> </dd> <dt><span><code>"step limit"</code></span></dt> <dd>
<p>Maximum number of steps allowed (default is 100000). </p> </dd> <dt><span><code>"jacobian type"</code></span></dt> <dd>
<p>A string specifying the type of Jacobian used with the stiff backward differentiation formula (BDF) integration method. Valid values are </p> <dl compact> <dt><span><code>"full"</code></span></dt> <dd>
<p>The default. All partial derivatives are approximated or used from the user-supplied Jacobian function. </p> </dd> <dt><span><code>"banded"</code></span></dt> <dd>
<p>Only the diagonal and the number of lower and upper subdiagonals specified by the options <code>"lower jacobian subdiagonals"</code> and <code>"upper jacobian
subdiagonals"</code>, respectively, are approximated or used from the user-supplied Jacobian function. A user-supplied Jacobian function may set all other partial derivatives to arbitrary values. </p> </dd> <dt><span><code>"diagonal"</code></span></dt> <dd><p>If a Jacobian function is supplied by the user, this setting has no effect. A Jacobian approximated by <code>lsode</code> is restricted to the diagonal, where each partial derivative is computed by applying a finite change to all elements of the state together; if the real Jacobian is indeed always diagonal, this has the same effect as applying the finite change only to the respective element of the state, but is more efficient. </p></dd> </dl> </dd> <dt><span><code>"lower jacobian subdiagonals"</code></span></dt> <dd>
<p>Number of lower subdiagonals used if option <code>"jacobian type"</code> is set to <code>"banded"</code>. The default is zero. </p> </dd> <dt><span><code>"upper jacobian subdiagonals"</code></span></dt> <dd>
<p>Number of upper subdiagonals used if option <code>"jacobian type"</code> is set to <code>"banded"</code>. The default is zero. </p> </dd> </dl> </dd>
</dl> <p>Here is an example of solving a set of three differential equations using <code>lsode</code>. Given the function </p>  <pre class="example" data-language="matlab">## oregonator differential equation
function xdot = f (x, t)

  xdot = zeros (3,1);

  xdot(1) = 77.27 * (x(2) - x(1)*x(2) + x(1) ...
            - 8.375e-06*x(1)^2);
  xdot(2) = (x(3) - x(1)*x(2) - x(2)) / 77.27;
  xdot(3) = 0.161*(x(1) - x(3));

endfunction</pre> <p>and the initial condition <code>x0 = [ 4; 1.1; 4 ]</code>, the set of equations can be integrated using the command </p> <pre class="example" data-language="matlab">t = linspace (0, 500, 1000);

y = lsode ("f", x0, t);</pre> <p>If you try this, you will see that the value of the result changes dramatically between <var>t</var> = 0 and 5, and again around <var>t</var> = 305. A more efficient set of output points might be </p> <pre class="example" data-language="matlab">t = [0, logspace(-1, log10(303), 150), ...
        logspace(log10(304), log10(500), 150)];</pre> <p>An m-file for the differential equation used above is included with the Octave distribution in the examples directory under the name <samp>oregonator.m</samp>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Ordinary-Differential-Equations.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Ordinary-Differential-Equations.html</a>
  </p>
</div>
