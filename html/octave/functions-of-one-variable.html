<div class="section-level-extent" id="Functions-of-One-Variable"> <div class="nav-panel"> <p> Next: <a href="orthogonal-collocation.html" accesskey="n" rel="next">Orthogonal Collocation</a>, Up: <a href="numerical-integration.html" accesskey="u" rel="up">Numerical Integration</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Functions-of-One-Variable-1"><span>23.1 Functions of One Variable<a class="copiable-link" href="#Functions-of-One-Variable-1"> ¶</a></span></h1> <p>Octave supports five different adaptive quadrature algorithms for computing the integral of a function <em class="math">f</em> over the interval from <em class="math">a</em> to <em class="math">b</em>. These are </p> <dl class="table"> <dt><code class="code">quad</code></dt> <dd>
<p>Numerical integration based on Gaussian quadrature. </p> </dd> <dt><code class="code">quadv</code></dt> <dd>
<p>Numerical integration using an adaptive vectorized Simpson’s rule. </p> </dd> <dt><code class="code">quadl</code></dt> <dd>
<p>Numerical integration using an adaptive Lobatto rule. </p> </dd> <dt><code class="code">quadgk</code></dt> <dd>
<p>Numerical integration using an adaptive Gauss-Konrod rule. </p> </dd> <dt><code class="code">quadcc</code></dt> <dd>
<p>Numerical integration using adaptive Clenshaw-Curtis rules. </p> <p>In addition, the following functions are also provided: </p> </dd> <dt><code class="code">integral</code></dt> <dd>
<p>A compatibility wrapper function that will choose between <code class="code">quadv</code> and <code class="code">quadgk</code> depending on the integrand and options chosen. </p> </dd> <dt><code class="code">trapz, cumtrapz</code></dt> <dd><p>Numerical integration of data using the trapezoidal method. </p></dd> </dl> <p>The best quadrature algorithm to use depends on the integrand. If you have empirical data, rather than a function, the choice is <code class="code">trapz</code> or <code class="code">cumtrapz</code>. If you are uncertain about the characteristics of the integrand, <code class="code">quadcc</code> will be the most robust as it can handle discontinuities, singularities, oscillatory functions, and infinite intervals. When the integrand is smooth <code class="code">quadgk</code> may be the fastest of the algorithms. </p> <table class="multitable"> <thead><tr>
<th width="5%"></th>
<th width="15%">Function</th>
<th width="80%">Characteristics</th>
</tr></thead> <tbody>
<tr>
<td width="5%"></td>
<td width="15%">quad</td>
<td width="80%">Low accuracy with nonsmooth integrands</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%">quadv</td>
<td width="80%">Medium accuracy with smooth integrands</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%">quadl</td>
<td width="80%">Medium accuracy with smooth integrands. Slower than quadgk.</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%">quadgk</td>
<td width="80%">Medium accuracy (1e-6 – 1e-9) with smooth integrands.</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%"></td>
<td width="80%">Handles oscillatory functions and infinite bounds</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%">quadcc</td>
<td width="80%">Low to High accuracy with nonsmooth/smooth integrands</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%"></td>
<td width="80%">Handles oscillatory functions, singularities, and infinite bounds</td>
</tr> </tbody> </table> <p>Here is an example of using <code class="code">quad</code> to integrate the function </p> <pre class="example" data-language="matlab">f(x) = x * sin (1/x) * sqrt (abs (1 - x))</pre> <p>from <var class="var">x</var> = 0 to <var class="var">x</var> = 3. </p> <p>This is a fairly difficult integration (plot the function over the range of integration to see why). </p> <p>The first step is to define the function: </p> <pre class="example" data-language="matlab">function y = f (x)
  y = x .* sin (1./x) .* sqrt (abs (1 - x));
endfunction</pre> <p>Note the use of the ‘dot’ forms of the operators. This is not necessary for the <code class="code">quad</code> integrator, but is required by the other integrators. In any case, it makes it much easier to generate a set of points for plotting because it is possible to call the function with a vector argument to produce a vector result. </p> <p>The second step is to call quad with the limits of integration: </p> <pre class="example" data-language="matlab">[q, ier, nfun, err] = quad ("f", 0, 3)
     ⇒ 1.9819
     ⇒ 1
     ⇒ 5061
     ⇒ 1.1522e-07</pre> <p>Although <code class="code">quad</code> returns a nonzero value for <var class="var">ier</var>, the result is reasonably accurate (to see why, examine what happens to the result if you move the lower bound to 0.1, then 0.01, then 0.001, etc.). </p> <p>The function <code class="code">"f"</code> can be the string name of a function or a function handle. These options make it quite easy to do integration without having to fully define a function in an m-file. For example: </p> <pre class="example" data-language="matlab"># Verify gamma function = (n-1)! for n = 4
f = @(x) x.^3 .* exp (-x);
quadcc (f, 0, Inf)
     ⇒ 6.0000</pre>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-quad">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quad</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-quad"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quad-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quad</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-quad-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quad-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quad</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">sing</var>)</code><a class="copiable-link" href="#index-quad-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quad-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">q</var>, <var class="var">ier</var>, <var class="var">nfev</var>, <var class="var">err</var>] =</code> <strong class="def-name">quad</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-quad-3"> ¶</a></span>
</dt> <dd>
<p>Numerically evaluate the integral of <var class="var">f</var> from <var class="var">a</var> to <var class="var">b</var> using Fortran routines from <small class="sc">QUADPACK</small>. </p> <p><var class="var">f</var> is a function handle, inline function, or a string containing the name of the function to evaluate. The function must have the form <code class="code">y =
f (x)</code> where <var class="var">y</var> and <var class="var">x</var> are scalars. </p> <p><var class="var">a</var> and <var class="var">b</var> are the lower and upper limits of integration. Either or both may be infinite. </p> <p>The optional argument <var class="var">tol</var> is a vector that specifies the desired accuracy of the result. The first element of the vector is the desired absolute tolerance, and the second element is the desired relative tolerance. To choose a relative test only, set the absolute tolerance to zero. To choose an absolute test only, set the relative tolerance to zero. Both tolerances default to <code class="code">sqrt (eps)</code> or approximately 1.5e-8. </p> <p>The optional argument <var class="var">sing</var> is a vector of values at which the integrand is known to be singular. </p> <p>The result of the integration is returned in <var class="var">q</var>. </p> <p><var class="var">ier</var> contains an integer error code (0 indicates a successful integration). </p> <p><var class="var">nfev</var> indicates the number of function evaluations that were made. </p> <p><var class="var">err</var> contains an estimate of the error in the solution. </p> <p>The function <code class="code">quad_options</code> can set other optional parameters for <code class="code">quad</code>. </p> <p>Note: because <code class="code">quad</code> is written in Fortran it cannot be called recursively. This prevents its use in integrating over more than one variable by routines <code class="code">dblquad</code> and <code class="code">triplequad</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFquad_005foptions">quad_options</a>, <a class="ref" href="#XREFquadv">quadv</a>, <a class="ref" href="#XREFquadl">quadl</a>, <a class="ref" href="#XREFquadgk">quadgk</a>, <a class="ref" href="#XREFquadcc">quadcc</a>, <a class="ref" href="#XREFtrapz">trapz</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFdblquad">dblquad</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFtriplequad">triplequad</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-quad_005foptions">
<span class="category-def">: </span><span><strong class="def-name">quad_options</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-quad_005foptions"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quad_005foptions-1">
<span class="category-def">: </span><span><code class="def-type">val =</code> <strong class="def-name">quad_options</strong> <code class="def-code-arguments">(<var class="var">opt</var>)</code><a class="copiable-link" href="#index-quad_005foptions-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quad_005foptions-2">
<span class="category-def">: </span><span><strong class="def-name">quad_options</strong> <code class="def-code-arguments">(<var class="var">opt</var>, <var class="var">val</var>)</code><a class="copiable-link" href="#index-quad_005foptions-2"> ¶</a></span>
</dt> <dd>
<p>Query or set options for the function <code class="code">quad</code>. </p> <p>When called with no arguments, the names of all available options and their current values are displayed. </p> <p>Given one argument, return the value of the option <var class="var">opt</var>. </p> <p>When called with two arguments, <code class="code">quad_options</code> sets the option <var class="var">opt</var> to value <var class="var">val</var>. </p> <p>Options include </p> <dl class="table"> <dt><code class="code">"absolute tolerance"</code></dt> <dd>
<p>Absolute tolerance; may be zero for pure relative error test. </p> </dd> <dt><code class="code">"relative tolerance"</code></dt> <dd>
<p>Non-negative relative tolerance. If the absolute tolerance is zero, the relative tolerance must be greater than or equal to <code class="code">max (50*eps, 0.5e-28)</code>. </p> </dd> <dt><code class="code">"single precision absolute tolerance"</code></dt> <dd>
<p>Absolute tolerance for single precision; may be zero for pure relative error test. </p> </dd> <dt><code class="code">"single precision relative tolerance"</code></dt> <dd><p>Non-negative relative tolerance for single precision. If the absolute tolerance is zero, the relative tolerance must be greater than or equal to <code class="code">max (50*eps, 0.5e-28)</code>. </p></dd> </dl> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-quadv">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadv</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-quadv"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadv-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadv</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-quadv-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadv-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadv</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">trace</var>)</code><a class="copiable-link" href="#index-quadv-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadv-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadv</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">trace</var>, <var class="var">p1</var>, <var class="var">p2</var>, …)</code><a class="copiable-link" href="#index-quadv-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadv-4">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">q</var>, <var class="var">nfev</var>] =</code> <strong class="def-name">quadv</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-quadv-4"> ¶</a></span>
</dt> <dd> <p>Numerically evaluate the integral of <var class="var">f</var> from <var class="var">a</var> to <var class="var">b</var> using an adaptive Simpson’s rule. </p> <p><var class="var">f</var> is a function handle, inline function, or string containing the name of the function to evaluate. <code class="code">quadv</code> is a vectorized version of <code class="code">quad</code> and the function defined by <var class="var">f</var> must accept a scalar or vector as input and return a scalar, vector, or array as output. </p> <p><var class="var">a</var> and <var class="var">b</var> are the lower and upper limits of integration. Both limits must be finite. </p> <p>The optional argument <var class="var">tol</var> defines the absolute tolerance used to stop the adaptation procedure. The default value is 1e-6. </p> <p>The algorithm used by <code class="code">quadv</code> involves recursively subdividing the integration interval and applying Simpson’s rule on each subinterval. If <var class="var">trace</var> is true then after computing each of these partial integrals display: (1) the total number of function evaluations, (2) the left end of the subinterval, (3) the length of the subinterval, (4) the approximation of the integral over the subinterval. </p> <p>Additional arguments <var class="var">p1</var>, etc., are passed directly to the function <var class="var">f</var>. To use default values for <var class="var">tol</var> and <var class="var">trace</var>, one may pass empty matrices ([]). </p> <p>The result of the integration is returned in <var class="var">q</var>. </p> <p>The optional output <var class="var">nfev</var> indicates the total number of function evaluations performed. </p> <p>Note: <code class="code">quadv</code> is written in Octave’s scripting language and can be used recursively in <code class="code">dblquad</code> and <code class="code">triplequad</code>, unlike the <code class="code">quad</code> function. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFquad">quad</a>, <a class="ref" href="#XREFquadl">quadl</a>, <a class="ref" href="#XREFquadgk">quadgk</a>, <a class="ref" href="#XREFquadcc">quadcc</a>, <a class="ref" href="#XREFtrapz">trapz</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFdblquad">dblquad</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFtriplequad">triplequad</a>, <a class="ref" href="#XREFintegral">integral</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFintegral2">integral2</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFintegral3">integral3</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-quadl">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadl</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-quadl"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadl-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadl</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-quadl-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadl-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadl</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">trace</var>)</code><a class="copiable-link" href="#index-quadl-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadl-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadl</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">trace</var>, <var class="var">p1</var>, <var class="var">p2</var>, …)</code><a class="copiable-link" href="#index-quadl-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadl-4">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">q</var>, <var class="var">nfev</var>] =</code> <strong class="def-name">quadl</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-quadl-4"> ¶</a></span>
</dt> <dd> <p>Numerically evaluate the integral of <var class="var">f</var> from <var class="var">a</var> to <var class="var">b</var> using an adaptive Lobatto rule. </p> <p><var class="var">f</var> is a function handle, inline function, or string containing the name of the function to evaluate. The function <var class="var">f</var> must be vectorized and return a vector of output values when given a vector of input values. </p> <p><var class="var">a</var> and <var class="var">b</var> are the lower and upper limits of integration. Both limits must be finite. </p> <p>The optional argument <var class="var">tol</var> defines the absolute tolerance with which to perform the integration. The default value is 1e-6. </p> <p>The algorithm used by <code class="code">quadl</code> involves recursively subdividing the integration interval. If <var class="var">trace</var> is defined then for each subinterval display: (1) the total number of function evaluations, (2) the left end of the subinterval, (3) the length of the subinterval, (4) the approximation of the integral over the subinterval. </p> <p>Additional arguments <var class="var">p1</var>, etc., are passed directly to the function <var class="var">f</var>. To use default values for <var class="var">tol</var> and <var class="var">trace</var>, one may pass empty matrices ([]). </p> <p>The result of the integration is returned in <var class="var">q</var>. </p> <p>The optional output <var class="var">nfev</var> indicates the total number of function evaluations performed. </p> <p>Reference: W. Gander and W. Gautschi, <cite class="cite">Adaptive Quadrature - Revisited</cite>, BIT Vol. 40, No. 1, March 2000, pp. 84–101. <a class="url" href="https://www.inf.ethz.ch/personal/gander/">https://www.inf.ethz.ch/personal/gander/</a> </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFquad">quad</a>, <a class="ref" href="#XREFquadv">quadv</a>, <a class="ref" href="#XREFquadgk">quadgk</a>, <a class="ref" href="#XREFquadcc">quadcc</a>, <a class="ref" href="#XREFtrapz">trapz</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFdblquad">dblquad</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFtriplequad">triplequad</a>, <a class="ref" href="#XREFintegral">integral</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFintegral2">integral2</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFintegral3">integral3</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-quadgk">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadgk</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-quadgk"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadgk-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadgk</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">abstol</var>)</code><a class="copiable-link" href="#index-quadgk-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadgk-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadgk</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">abstol</var>, <var class="var">trace</var>)</code><a class="copiable-link" href="#index-quadgk-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadgk-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadgk</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, "<var class="var">prop</var>", <var class="var">val</var>, …)</code><a class="copiable-link" href="#index-quadgk-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadgk-4">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">q</var>, <var class="var">err</var>] =</code> <strong class="def-name">quadgk</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-quadgk-4"> ¶</a></span>
</dt> <dd> <p>Numerically evaluate the integral of <var class="var">f</var> from <var class="var">a</var> to <var class="var">b</var> using adaptive Gauss-Kronrod quadrature. </p> <p><var class="var">f</var> is a function handle, inline function, or string containing the name of the function to evaluate. The function <var class="var">f</var> must be vectorized and return a vector of output values when given a vector of input values (See property <code class="code">"ArrayValued"</code> for an exception to this rule). </p> <p><var class="var">a</var> and <var class="var">b</var> are the lower and upper limits of integration. Either or both limits may be infinite or contain weak end singularities. Variable transformation will be used to treat any infinite intervals and weaken the singularities. For example: </p> <pre class="example" data-language="matlab">quadgk (@(x) 1 ./ (sqrt (x) .* (x + 1)), 0, Inf)</pre> <p>Note that the formulation of the integrand uses the element-by-element operator <code class="code">./</code> and all user functions to <code class="code">quadgk</code> should do the same. </p> <p>The optional argument <var class="var">abstol</var> defines the absolute tolerance used to stop the integration procedure. The default value is 1e-10 (1e-5 for single). </p> <p>The algorithm used by <code class="code">quadgk</code> involves subdividing the integration interval and evaluating each subinterval. If <var class="var">trace</var> is true then after computing each of these partial integrals display: (1) the number of subintervals at this step, (2) the current estimate of the error <var class="var">err</var>, (3) the current estimate for the integral <var class="var">q</var>. </p> <p>The behavior of the algorithm can be configured by passing arguments to <code class="code">quadgk</code> as pairs <code class="code">"<var class="var">prop</var>", <var class="var">val</var></code>. Valid properties are </p> <dl class="table"> <dt><code class="code">AbsTol</code></dt> <dd>
<p>Define the absolute error tolerance for the quadrature. The default absolute tolerance is 1e-10 (1e-5 for single). </p> </dd> <dt><code class="code">RelTol</code></dt> <dd>
<p>Define the relative error tolerance for the quadrature. The default relative tolerance is 1e-6 (1e-4 for single). </p> </dd> <dt><code class="code">ArrayValued</code></dt> <dd>
<p>When set to true, the function <var class="var">f</var> produces an array output for a scalar input. The default is false which requires that <var class="var">f</var> produce an output that is the same size as the input. For example, </p> <pre class="example" data-language="matlab">quadgk (@(x) x .^ (1:5), 0, 2, "ArrayValued", 1)</pre> <p>will integrate <code class="code">[x.^1, x.^2, x.^3, x.^4, x.^5]</code> in one function call rather than having to repeatedly define a single anonymous function and use a normal invocation of <code class="code">quadgk</code>. </p> </dd> <dt><code class="code">WayPoints</code></dt> <dd>
<p>Specify points which will become endpoints for subintervals in the algorithm which can result in significantly improved estimation of the error in the integral, faster computation, or both. It can be useful to specify more subintervals around a region where the integrand is rapidly changing or to flag locations where there is a discontinuity in the first derivative of the function. For example, the signum function has a discontinuity at <code class="code">x == 0</code> and by specifying a waypoint </p> <pre class="example" data-language="matlab">quadgk (@(x) sign (x), -0.5, 1, "Waypoints", [0])</pre> <p>the error bound is reduced from 4e-7 to 1e-13. </p> <p>If the function has <strong class="strong">singularities</strong> within the region of integration those should not be addressed with waypoints. Instead, the overall integral should be decomposed into a sum of several smaller integrals such that the singularity occurs as one of the bounds of integration in the call to <code class="code">quadgk</code>. </p> <p>If any of the waypoints are complex then contour integration is performed as documented below. </p> </dd> <dt><code class="code">MaxIntervalCount</code></dt> <dd>
<p><code class="code">quadgk</code> initially subdivides the interval on which to perform the quadrature into 10 intervals or, if WayPoints are given, at each waypoint. Subintervals that have an unacceptable error are subdivided and re-evaluated. If the number of subintervals exceeds 650 subintervals at any point then a poor convergence is signaled and the current estimate of the integral is returned. The property <code class="code">"MaxIntervalCount"</code> can be used to alter the number of subintervals that can exist before exiting. </p> </dd> <dt><code class="code">Trace</code></dt> <dd><p>If logically true <code class="code">quadgk</code> prints information on the convergence of the quadrature at each iteration. </p></dd> </dl> <p>If any of <var class="var">a</var>, <var class="var">b</var>, or <var class="var">waypoints</var> is complex then the quadrature is treated as a contour integral along a piecewise linear path defined by <code class="code">[<var class="var">a</var>, <var class="var">waypoints</var>(1), <var class="var">waypoints</var>(2), …, <var class="var">b</var>]</code>. In this case the integral is assumed to have no edge singularities. For example, </p> <pre class="example" data-language="matlab">quadgk (@(z) log (z), 1+1i, 1+1i, "WayPoints",
        [-1+1i, -1-1i, +1-1i])</pre> <p>integrates <code class="code">log (z)</code> along the square defined by <code class="code">[1+1i, -1+1i, -1-1i, +1-1i]</code>. </p> <p>The result of the integration is returned in <var class="var">q</var>. </p> <p><var class="var">err</var> is an approximate bound on the error in the integral <code class="code">abs (<var class="var">q</var> - <var class="var">I</var>)</code>, where <var class="var">I</var> is the exact value of the integral. If the adaptive integration did not converge, the value of <var class="var">err</var> will be larger than the requested tolerance. If only a single output is requested then a warning will be emitted when the requested tolerance is not met. If the second output <var class="var">err</var> is requested then no warning is issued and it is the responsibility of the programmer to inspect and determine whether the results are satisfactory. </p> <p>Reference: L.F. Shampine, <cite class="cite">"Vectorized adaptive quadrature in <small class="sc">MATLAB</small>"</cite>, Journal of Computational and Applied Mathematics, pp. 131–140, Vol 211, Issue 2, Feb 2008. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFquad">quad</a>, <a class="ref" href="#XREFquadv">quadv</a>, <a class="ref" href="#XREFquadl">quadl</a>, <a class="ref" href="#XREFquadcc">quadcc</a>, <a class="ref" href="#XREFtrapz">trapz</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFdblquad">dblquad</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFtriplequad">triplequad</a>, <a class="ref" href="#XREFintegral">integral</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFintegral2">integral2</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFintegral3">integral3</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-quadcc">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadcc</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-quadcc"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadcc-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadcc</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-quadcc-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadcc-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quadcc</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">sing</var>)</code><a class="copiable-link" href="#index-quadcc-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quadcc-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">q</var>, <var class="var">err</var>, <var class="var">nr_points</var>] =</code> <strong class="def-name">quadcc</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-quadcc-3"> ¶</a></span>
</dt> <dd>
<p>Numerically evaluate the integral of <var class="var">f</var> from <var class="var">a</var> to <var class="var">b</var> using doubly-adaptive Clenshaw-Curtis quadrature. </p> <p><var class="var">f</var> is a function handle, inline function, or string containing the name of the function to evaluate. The function <var class="var">f</var> must be vectorized and must return a vector of output values if given a vector of input values. For example, </p> <pre class="example" data-language="matlab">f = @(x) x .* sin (1./x) .* sqrt (abs (1 - x));</pre> <p>which uses the element-by-element “dot” form for all operators. </p> <p><var class="var">a</var> and <var class="var">b</var> are the lower and upper limits of integration. Either or both limits may be infinite. <code class="code">quadcc</code> handles an infinite limit by substituting the variable of integration with <code class="code">x = tan (pi/2*u)</code>. </p> <p>The optional argument <var class="var">tol</var> is a 1- or 2-element vector that specifies the desired accuracy of the result. The first element of the vector is the desired absolute tolerance, and the second element is the desired relative tolerance. To choose a relative test only, set the absolute tolerance to zero. To choose an absolute test only, set the relative tolerance to zero. The default absolute tolerance is 1e-10 (1e-5 for single), and the default relative tolerance is 1e-6 (1e-4 for single). </p> <p>The optional argument <var class="var">sing</var> contains a list of points where the integrand has known singularities, or discontinuities in any of its derivatives, inside the integration interval. For the example above, which has a discontinuity at x=1, the call to <code class="code">quadcc</code> would be as follows </p> <pre class="example" data-language="matlab">int = quadcc (f, a, b, [], [ 1 ]);</pre> <p>The result of the integration is returned in <var class="var">q</var>. </p> <p><var class="var">err</var> is an estimate of the absolute integration error. </p> <p><var class="var">nr_points</var> is the number of points at which the integrand was evaluated. </p> <p>If the adaptive integration did not converge, the value of <var class="var">err</var> will be larger than the requested tolerance. If only a single output is requested then a warning will be emitted when the requested tolerance is not met. If the second output <var class="var">err</var> is requested then no warning is issued and it is the responsibility of the programmer to inspect and determine whether the results are satisfactory. </p> <p><code class="code">quadcc</code> is capable of dealing with non-numeric values of the integrand such as <code class="code">NaN</code> or <code class="code">Inf</code>. If the integral diverges, and <code class="code">quadcc</code> detects this, then a warning is issued and <code class="code">Inf</code> or <code class="code">-Inf</code> is returned. </p> <p>Note: <code class="code">quadcc</code> is a general purpose quadrature algorithm and, as such, may be less efficient for a smooth or otherwise well-behaved integrand than other methods such as <code class="code">quadgk</code>. </p> <p>The algorithm uses Clenshaw-Curtis quadrature rules of increasing degree in each interval and bisects the interval if either the function does not appear to be smooth or a rule of maximum degree has been reached. The error estimate is computed from the L2-norm of the difference between two successive interpolations of the integrand over the nodes of the respective quadrature rules. </p> <p>Reference: P. Gonnet, <cite class="cite">Increasing the Reliability of Adaptive Quadrature Using Explicit Interpolants</cite>, ACM Transactions on Mathematical Software, Vol. 37, Issue 3, Article No. 3, 2010. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFquad">quad</a>, <a class="ref" href="#XREFquadv">quadv</a>, <a class="ref" href="#XREFquadl">quadl</a>, <a class="ref" href="#XREFquadgk">quadgk</a>, <a class="ref" href="#XREFtrapz">trapz</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFdblquad">dblquad</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFtriplequad">triplequad</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-integral">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">integral</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-integral"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-integral-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">integral</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">prop</var>, <var class="var">val</var>, …)</code><a class="copiable-link" href="#index-integral-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-integral-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">q</var>, <var class="var">err</var>] =</code> <strong class="def-name">integral</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-integral-2"> ¶</a></span>
</dt> <dd> <p>Numerically evaluate the integral of <var class="var">f</var> from <var class="var">a</var> to <var class="var">b</var> using adaptive quadrature. </p> <p><code class="code">integral</code> is a wrapper for <code class="code">quadcc</code> (general real-valued, scalar integrands and limits), and <code class="code">quadgk</code> (integrals with specified integration paths and array-valued integrands) that is intended to provide <small class="sc">MATLAB</small> compatibility. More control of the numerical integration may be achievable by calling the various quadrature functions directly. </p> <p><var class="var">f</var> is a function handle, inline function, or string containing the name of the function to evaluate. The function <var class="var">f</var> must be vectorized and return a vector of output values when given a vector of input values. </p> <p><var class="var">a</var> and <var class="var">b</var> are the lower and upper limits of integration. Either or both limits may be infinite or contain weak end singularities. If either or both limits are complex, <code class="code">integral</code> will perform a straight line path integral. Alternatively, a complex domain path can be specified using the <code class="code">"Waypoints"</code> option (see below). </p> <p>Additional optional parameters can be specified using <code class="code">"<var class="var">property</var>", <var class="var">value</var></code> pairs. Valid properties are: </p> <dl class="table"> <dt><code class="code">Waypoints</code></dt> <dd>
<p>Specifies points to be used in defining subintervals of the quadrature algorithm, or if <var class="var">a</var>, <var class="var">b</var>, or <var class="var">waypoints</var> are complex then the quadrature is calculated as a contour integral along a piecewise continuous path. For more detail, see <a class="pxref" href="#XREFquadgk"><code class="code">quadgk</code></a>. </p> </dd> <dt><code class="code">ArrayValued</code></dt> <dd>
<p><code class="code">integral</code> expects <var class="var">f</var> to return a scalar value unless <var class="var">arrayvalued</var> is specified as true. This option will cause <code class="code">integral</code> to perform the integration over the entire array and return <var class="var">q</var> with the same dimensions as returned by <var class="var">f</var>. For more detail see <a class="pxref" href="#XREFquadgk"><code class="code">quadgk</code></a>. </p> </dd> <dt><code class="code">AbsTol</code></dt> <dd>
<p>Define the absolute error tolerance for the quadrature. The default absolute tolerance is 1e-10 (1e-5 for single). </p> </dd> <dt><code class="code">RelTol</code></dt> <dd><p>Define the relative error tolerance for the quadrature. The default relative tolerance is 1e-6 (1e-4 for single). </p></dd> </dl> <p>The optional output <var class="var">err</var> contains the absolute error estimate used by the called integrator. </p> <p>Adaptive quadrature is used to minimize the estimate of error until the following is satisfied: </p> <pre class="example" data-language="matlab">error &lt;= max (AbsTol, RelTol*|q|).</pre> <p>Known <small class="sc">MATLAB</small> incompatibilities: </p> <ol class="enumerate"> <li> If tolerances are left unspecified, and any integration limits or waypoints are of type <code class="code">single</code>, then Octave’s integral functions automatically reduce the default absolute and relative error tolerances as specified above. If tighter tolerances are desired they must be specified. <small class="sc">MATLAB</small> leaves the tighter tolerances appropriate for <code class="code">double</code> inputs in place regardless of the class of the integration limits. </li>
</ol> <p><strong class="strong">See also:</strong> <a class="ref" href="functions-of-multiple-variables.html#XREFintegral2">integral2</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFintegral3">integral3</a>, <a class="ref" href="#XREFquad">quad</a>, <a class="ref" href="#XREFquadgk">quadgk</a>, <a class="ref" href="#XREFquadv">quadv</a>, <a class="ref" href="#XREFquadl">quadl</a>, <a class="ref" href="#XREFquadcc">quadcc</a>, <a class="ref" href="#XREFtrapz">trapz</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFdblquad">dblquad</a>, <a class="ref" href="functions-of-multiple-variables.html#XREFtriplequad">triplequad</a>. </p>
</dd>
</dl> <p>Sometimes one does not have the function, but only the raw (x, y) points from which to perform an integration. This can occur when collecting data in an experiment. The <code class="code">trapz</code> function can integrate these values as shown in the following example where "data" has been collected on the cosine function over the range [0, pi/2). </p> <pre class="example" data-language="matlab">x = 0:0.1:pi/2;  # Uniformly spaced points
y = cos (x);
trapz (x, y)
     ⇒ 0.99666</pre> <p>The answer is reasonably close to the exact value of 1. Ordinary quadrature is sensitive to the characteristics of the integrand. Empirical integration depends not just on the integrand, but also on the particular points chosen to represent the function. Repeating the example above with the sine function over the range [0, pi/2) produces far inferior results. </p> <pre class="example" data-language="matlab">x = 0:0.1:pi/2;  # Uniformly spaced points
y = sin (x);
trapz (x, y)
     ⇒ 0.92849</pre> <p>However, a slightly different choice of data points can change the result significantly. The same integration, with the same number of points, but spaced differently produces a more accurate answer. </p> <pre class="example" data-language="matlab">x = linspace (0, pi/2, 16);  # Uniformly spaced, but including endpoint
y = sin (x);
trapz (x, y)
     ⇒ 0.99909</pre> <p>In general there may be no way of knowing the best distribution of points ahead of time. Or the points may come from an experiment where there is no freedom to select the best distribution. In any case, one must remain aware of this issue when using <code class="code">trapz</code>. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-trapz">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">trapz</strong> <code class="def-code-arguments">(<var class="var">y</var>)</code><a class="copiable-link" href="#index-trapz"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-trapz-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">trapz</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-trapz-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-trapz-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">trapz</strong> <code class="def-code-arguments">(…, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-trapz-2"> ¶</a></span>
</dt> <dd> <p>Numerically evaluate the integral of points <var class="var">y</var> using the trapezoidal method. </p> <p><code class="code">trapz (<var class="var">y</var>)</code> computes the integral of <var class="var">y</var> along the first non-singleton dimension. When the argument <var class="var">x</var> is omitted an equally spaced <var class="var">x</var> vector with unit spacing (1) is assumed. <code class="code">trapz (<var class="var">x</var>, <var class="var">y</var>)</code> evaluates the integral with respect to the spacing in <var class="var">x</var> and the values in <var class="var">y</var>. This is useful if the points in <var class="var">y</var> have been sampled unevenly. </p> <p>If the optional <var class="var">dim</var> argument is given, operate along this dimension. </p> <p>Application Note: If <var class="var">x</var> is not specified then unit spacing will be used. To scale the integral to the correct value you must multiply by the actual spacing value (deltaX). As an example, the integral of <em class="math">x^3</em> over the range [0, 1] is <em class="math">x^4/4</em> or 0.25. The following code uses <code class="code">trapz</code> to calculate the integral in three different ways. </p> <pre class="example" data-language="matlab">x = 0:0.1:1;
y = x.^3;
## No scaling
q = trapz (y)
  ⇒ q = 2.5250
## Approximation to integral by scaling
q * 0.1
  ⇒ 0.25250
## Same result by specifying x
trapz (x, y)
  ⇒ 0.25250</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcumtrapz">cumtrapz</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-cumtrapz">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">cumtrapz</strong> <code class="def-code-arguments">(<var class="var">y</var>)</code><a class="copiable-link" href="#index-cumtrapz"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-cumtrapz-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">cumtrapz</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-cumtrapz-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-cumtrapz-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">cumtrapz</strong> <code class="def-code-arguments">(…, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-cumtrapz-2"> ¶</a></span>
</dt> <dd>
<p>Cumulative numerical integration of points <var class="var">y</var> using the trapezoidal method. </p> <p><code class="code">cumtrapz (<var class="var">y</var>)</code> computes the cumulative integral of <var class="var">y</var> along the first non-singleton dimension. Where <code class="code">trapz</code> reports only the overall integral sum, <code class="code">cumtrapz</code> reports the current partial sum value at each point of <var class="var">y</var>. </p> <p>When the argument <var class="var">x</var> is omitted an equally spaced <var class="var">x</var> vector with unit spacing (1) is assumed. <code class="code">cumtrapz (<var class="var">x</var>, <var class="var">y</var>)</code> evaluates the integral with respect to the spacing in <var class="var">x</var> and the values in <var class="var">y</var>. This is useful if the points in <var class="var">y</var> have been sampled unevenly. </p> <p>If the optional <var class="var">dim</var> argument is given, operate along this dimension. </p> <p>Application Note: If <var class="var">x</var> is not specified then unit spacing will be used. To scale the integral to the correct value you must multiply by the actual spacing value (deltaX). </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFtrapz">trapz</a>, <a class="ref" href="sums-and-products.html#XREFcumsum">cumsum</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="orthogonal-collocation.html">Orthogonal Collocation</a>, Up: <a href="numerical-integration.html">Numerical Integration</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Functions-of-One-Variable.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Functions-of-One-Variable.html</a>
  </p>
</div>
