<div class="section" id="Predicates-for-Numeric-Objects">   <h1 class="section">4.8 Predicates for Numeric Objects</h1> <p>Since the type of a variable may change during the execution of a program, it can be necessary to do type checking at run-time. Doing this also allows you to change the behavior of a function depending on the type of the input. As an example, this naive implementation of <code>abs</code> returns the absolute value of the input if it is a real number, and the length of the input if it is a complex number. </p> <pre class="example" data-language="matlab">function a = abs (x)
  if (isreal (x))
    a = sign (x) .* x;
  elseif (iscomplex (x))
    a = sqrt (real(x).^2 + imag(x).^2);
  endif
endfunction</pre> <p>The following functions are available for determining the type of a variable. </p> <dl class="def"> <dt id="index-isnumeric">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isnumeric</strong> <em>(<var>x</var>)</em><a href="#index-isnumeric" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>x</var> is a numeric object, i.e., an integer, real, or complex array. </p> <p>Logical and character arrays are not considered to be numeric. </p> <p><strong>See also:</strong> <a href="integer-data-types.html#XREFisinteger">isinteger</a>, <a href="#XREFisfloat">isfloat</a>, <a href="#XREFisreal">isreal</a>, <a href="#XREFiscomplex">iscomplex</a>, <a href="character-arrays.html#XREFischar">ischar</a>, <a href="#XREFislogical">islogical</a>, <a href="character-arrays.html#XREFisstring">isstring</a>, <a href="basic-usage-of-cell-arrays.html#XREFiscell">iscell</a>, <a href="creating-structures.html#XREFisstruct">isstruct</a>, <a href="built_002din-data-types.html#XREFisa">isa</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-islogical">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>islogical</strong> <em>(<var>x</var>)</em><a href="#index-islogical" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-isbool">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isbool</strong> <em>(<var>x</var>)</em><a href="#index-isbool" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>x</var> is a logical object. </p> <p><strong>See also:</strong> <a href="character-arrays.html#XREFischar">ischar</a>, <a href="#XREFisfloat">isfloat</a>, <a href="integer-data-types.html#XREFisinteger">isinteger</a>, <a href="character-arrays.html#XREFisstring">isstring</a>, <a href="#XREFisnumeric">isnumeric</a>, <a href="built_002din-data-types.html#XREFisa">isa</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isfloat">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isfloat</strong> <em>(<var>x</var>)</em><a href="#index-isfloat" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>x</var> is a floating-point numeric object. </p> <p>Objects of class double or single are floating-point objects. </p> <p><strong>See also:</strong> <a href="integer-data-types.html#XREFisinteger">isinteger</a>, <a href="character-arrays.html#XREFischar">ischar</a>, <a href="#XREFislogical">islogical</a>, <a href="#XREFisnumeric">isnumeric</a>, <a href="character-arrays.html#XREFisstring">isstring</a>, <a href="built_002din-data-types.html#XREFisa">isa</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isreal">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isreal</strong> <em>(<var>x</var>)</em><a href="#index-isreal" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>x</var> is a non-complex matrix or scalar. </p> <p>For compatibility with <small>MATLAB</small>, this includes logical and character matrices. </p> <p><strong>See also:</strong> <a href="#XREFiscomplex">iscomplex</a>, <a href="#XREFisnumeric">isnumeric</a>, <a href="built_002din-data-types.html#XREFisa">isa</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-iscomplex">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>iscomplex</strong> <em>(<var>x</var>)</em><a href="#index-iscomplex" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>x</var> is a complex-valued numeric object. </p> <p><strong>See also:</strong> <a href="#XREFisreal">isreal</a>, <a href="#XREFisnumeric">isnumeric</a>, <a href="character-arrays.html#XREFischar">ischar</a>, <a href="#XREFisfloat">isfloat</a>, <a href="#XREFislogical">islogical</a>, <a href="character-arrays.html#XREFisstring">isstring</a>, <a href="built_002din-data-types.html#XREFisa">isa</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ismatrix">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>ismatrix</strong> <em>(<var>x</var>)</em><a href="#index-ismatrix" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>x</var> is a 2-D array. </p> <p>A matrix is an object with two dimensions (<code>ndims (<var>x</var>) == 2</code>) for which <code>size (<var>x</var>)</code> returns <code>[M, N]</code> with non-negative M and N. </p> <p><strong>See also:</strong> <a href="#XREFisscalar">isscalar</a>, <a href="#XREFisvector">isvector</a>, <a href="basic-usage-of-cell-arrays.html#XREFiscell">iscell</a>, <a href="creating-structures.html#XREFisstruct">isstruct</a>, <a href="information.html#XREFissparse">issparse</a>, <a href="built_002din-data-types.html#XREFisa">isa</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isvector">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isvector</strong> <em>(<var>x</var>)</em><a href="#index-isvector" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>x</var> is a vector. </p> <p>A vector is a 2-D array where one of the dimensions is equal to 1 (either 1xN or Nx1). As a consequence of this definition, a 1x1 array (a scalar) is also a vector. </p> <p><strong>See also:</strong> <a href="#XREFisscalar">isscalar</a>, <a href="#XREFismatrix">ismatrix</a>, <a href="#XREFiscolumn">iscolumn</a>, <a href="#XREFisrow">isrow</a>, <a href="object-sizes.html#XREFsize">size</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isrow">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isrow</strong> <em>(<var>x</var>)</em><a href="#index-isrow" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>x</var> is a row vector. </p> <p>A row vector is a 2-D array for which <code>size (<var>x</var>)</code> returns <code>[1, N]</code> with non-negative N. </p> <p><strong>See also:</strong> <a href="#XREFiscolumn">iscolumn</a>, <a href="#XREFisscalar">isscalar</a>, <a href="#XREFisvector">isvector</a>, <a href="#XREFismatrix">ismatrix</a>, <a href="object-sizes.html#XREFsize">size</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-iscolumn">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>iscolumn</strong> <em>(<var>x</var>)</em><a href="#index-iscolumn" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>x</var> is a column vector. </p> <p>A column vector is a 2-D array for which <code>size (<var>x</var>)</code> returns <code>[N, 1]</code> with non-negative N. </p> <p><strong>See also:</strong> <a href="#XREFisrow">isrow</a>, <a href="#XREFisscalar">isscalar</a>, <a href="#XREFisvector">isvector</a>, <a href="#XREFismatrix">ismatrix</a>, <a href="object-sizes.html#XREFsize">size</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isscalar">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isscalar</strong> <em>(<var>x</var>)</em><a href="#index-isscalar" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>x</var> is a scalar. </p> <p>A scalar is an object with two dimensions for which <code>size (<var>x</var>)</code> returns <code>[1, 1]</code>. </p> <p><strong>See also:</strong> <a href="#XREFisvector">isvector</a>, <a href="#XREFismatrix">ismatrix</a>, <a href="object-sizes.html#XREFsize">size</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-issquare">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>issquare</strong> <em>(<var>x</var>)</em><a href="#index-issquare" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>x</var> is a 2-D square array. </p> <p>A square array is a 2-D object for which <code>size (<var>x</var>)</code> returns <code>[N, N]</code> where N is a non-negative integer. </p> <p><strong>See also:</strong> <a href="#XREFisscalar">isscalar</a>, <a href="#XREFisvector">isvector</a>, <a href="#XREFismatrix">ismatrix</a>, <a href="object-sizes.html#XREFsize">size</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-issymmetric">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>issymmetric</strong> <em>(<var>A</var>)</em><a href="#index-issymmetric" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-issymmetric-1">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>issymmetric</strong> <em>(<var>A</var>, <var>tol</var>)</em><a href="#index-issymmetric-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-issymmetric-2">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>issymmetric</strong> <em>(<var>A</var>, <code>"skew"</code>)</em><a href="#index-issymmetric-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-issymmetric-3">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>issymmetric</strong> <em>(<var>A</var>, <code>"skew"</code>, <var>tol</var>)</em><a href="#index-issymmetric-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>A</var> is a symmetric or skew-symmetric matrix within the tolerance specified by <var>tol</var>. </p> <p>The default tolerance is zero (uses faster code). </p> <p>The type of symmetry to check may be specified with the additional input <code>"nonskew"</code> (default) for regular symmetry or <code>"skew"</code> for skew-symmetry. </p> <p>Background: A matrix is symmetric if the transpose of the matrix is equal to the original matrix: <code><var>A</var> == <var>A</var>.'</code>. If a tolerance is given then symmetry is determined by <code>norm (<var>A</var> - <var>A</var>.', Inf) / norm (<var>A</var>, Inf) &lt; <var>tol</var></code>. </p> <p>A matrix is skew-symmetric if the transpose of the matrix is equal to the negative of the original matrix: <code><var>A</var> == <span class="nolinebreak">-</span><var>A</var>.'</code>. If a tolerance is given then skew-symmetry is determined by <code>norm (<var>A</var> + <var>A</var>.', Inf) / norm (<var>A</var>, Inf) &lt; <var>tol</var></code>. </p> <p><strong>See also:</strong> <a href="#XREFishermitian">ishermitian</a>, <a href="#XREFisdefinite">isdefinite</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ishermitian">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>ishermitian</strong> <em>(<var>A</var>)</em><a href="#index-ishermitian" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ishermitian-1">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>ishermitian</strong> <em>(<var>A</var>, <var>tol</var>)</em><a href="#index-ishermitian-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ishermitian-2">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>ishermitian</strong> <em>(<var>A</var>, <code>"skew"</code>)</em><a href="#index-ishermitian-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ishermitian-3">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>ishermitian</strong> <em>(<var>A</var>, <code>"skew"</code>, <var>tol</var>)</em><a href="#index-ishermitian-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>A</var> is a Hermitian or skew-Hermitian matrix within the tolerance specified by <var>tol</var>. </p> <p>The default tolerance is zero (uses faster code). </p> <p>The type of symmetry to check may be specified with the additional input <code>"nonskew"</code> (default) for regular Hermitian or <code>"skew"</code> for skew-Hermitian. </p> <p>Background: A matrix is Hermitian if the complex conjugate transpose of the matrix is equal to the original matrix: <code><var>A</var> == <var>A</var>'</code>. If a tolerance is given then the calculation is <code>norm (<var>A</var> - <var>A</var>', Inf) / norm (<var>A</var>, Inf) &lt; <var>tol</var></code>. </p> <p>A matrix is skew-Hermitian if the complex conjugate transpose of the matrix is equal to the negative of the original matrix: <code><var>A</var> == <span class="nolinebreak">-</span><var>A</var>'</code>. If a tolerance is given then the calculation is <code>norm (<var>A</var> + <var>A</var>', Inf) / norm (<var>A</var>, Inf) &lt; <var>tol</var></code>. </p> <p><strong>See also:</strong> <a href="#XREFissymmetric">issymmetric</a>, <a href="#XREFisdefinite">isdefinite</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isdefinite">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isdefinite</strong> <em>(<var>A</var>)</em><a href="#index-isdefinite" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-isdefinite-1">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isdefinite</strong> <em>(<var>A</var>, <var>tol</var>)</em><a href="#index-isdefinite-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>A</var> is symmetric positive definite matrix within the tolerance specified by <var>tol</var>. </p> <p>If <var>tol</var> is omitted, use a tolerance of <code>100 * eps * norm (<var>A</var>, "fro")</code>. </p> <p>Background: A positive definite matrix has eigenvalues which are all greater than zero. A positive semi-definite matrix has eigenvalues which are all greater than or equal to zero. The matrix <var>A</var> is very likely to be positive semi-definite if the following two conditions hold for a suitably small tolerance <var>tol</var>. </p> <pre class="example" data-language="matlab">isdefinite (A) ⇒ 0
isdefinite (A + 5*tol, tol) ⇒ 1</pre> <p><strong>See also:</strong> <a href="#XREFissymmetric">issymmetric</a>, <a href="#XREFishermitian">ishermitian</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isbanded">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isbanded</strong> <em>(<var>A</var>, <var>lower</var>, <var>upper</var>)</em><a href="#index-isbanded" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>A</var> is a matrix with entries confined between <var>lower</var> diagonals below the main diagonal and <var>upper</var> diagonals above the main diagonal. </p> <p><var>lower</var> and <var>upper</var> must be non-negative integers. </p> <p><strong>See also:</strong> <a href="#XREFisdiag">isdiag</a>, <a href="#XREFistril">istril</a>, <a href="#XREFistriu">istriu</a>, <a href="basic-matrix-functions.html#XREFbandwidth">bandwidth</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isdiag">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isdiag</strong> <em>(<var>A</var>)</em><a href="#index-isdiag" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>A</var> is a diagonal matrix. </p> <p><strong>See also:</strong> <a href="#XREFisbanded">isbanded</a>, <a href="#XREFistril">istril</a>, <a href="#XREFistriu">istriu</a>, <a href="rearranging-matrices.html#XREFdiag">diag</a>, <a href="basic-matrix-functions.html#XREFbandwidth">bandwidth</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-istril">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>istril</strong> <em>(<var>A</var>)</em><a href="#index-istril" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>A</var> is a lower triangular matrix. </p> <p>A lower triangular matrix has nonzero entries only on the main diagonal and below. </p> <p><strong>See also:</strong> <a href="#XREFistriu">istriu</a>, <a href="#XREFisbanded">isbanded</a>, <a href="#XREFisdiag">isdiag</a>, <a href="rearranging-matrices.html#XREFtril">tril</a>, <a href="basic-matrix-functions.html#XREFbandwidth">bandwidth</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-istriu">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>istriu</strong> <em>(<var>A</var>)</em><a href="#index-istriu" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if <var>A</var> is an upper triangular matrix. </p> <p>An upper triangular matrix has nonzero entries only on the main diagonal and above. </p> <p><strong>See also:</strong> <a href="#XREFisdiag">isdiag</a>, <a href="#XREFisbanded">isbanded</a>, <a href="#XREFistril">istril</a>, <a href="rearranging-matrices.html#XREFtriu">triu</a>, <a href="basic-matrix-functions.html#XREFbandwidth">bandwidth</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isprime">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isprime</strong> <em>(<var>x</var>)</em><a href="#index-isprime" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a logical array which is true where the elements of <var>x</var> are prime numbers and false where they are not. </p> <p>A prime number is conventionally defined as a positive integer greater than 1 (e.g., 2, 3, …) which is divisible only by itself and 1. Octave extends this definition to include both negative integers and complex values. A negative integer is prime if its positive counterpart is prime. This is equivalent to <code>isprime (abs (x))</code>. </p> <p>If <code>class (<var>x</var>)</code> is complex, then primality is tested in the domain of Gaussian integers (<a href="https://en.wikipedia.org/wiki/Gaussian_integer">https://en.wikipedia.org/wiki/Gaussian_integer</a>). Some non-complex integers are prime in the ordinary sense, but not in the domain of Gaussian integers. For example, <em class="math">5 = (1+2i)*(1-2i)</em> shows that 5 is not prime because it has a factor other than itself and 1. Exercise caution when testing complex and real values together in the same matrix. </p> <p>Examples: </p> <pre class="example" data-language="matlab">isprime (1:6)
  ⇒  0  1  1  0  1  0</pre> <pre class="example" data-language="matlab">isprime ([i, 2, 3, 5])
  ⇒  0  0  1  0</pre> <p>Programming Note: <code>isprime</code> is suitable for all <var>x</var> in the range abs(<var>x</var>) &lt; 2^64. </p> <p>Compatibility Note: <small>MATLAB</small> does not extend the definition of prime numbers and will produce an error if given negative or complex inputs. </p> <p><strong>See also:</strong> <a href="utility-functions.html#XREFprimes">primes</a>, <a href="utility-functions.html#XREFfactor">factor</a>, <a href="utility-functions.html#XREFgcd">gcd</a>, <a href="utility-functions.html#XREFlcm">lcm</a>. </p>
</dd>
</dl> <p>If instead of knowing properties of variables, you wish to know which variables are defined and to gather other information about the workspace itself, see <a href="status-of-variables.html">Status of Variables</a>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Predicates-for-Numeric-Objects.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Predicates-for-Numeric-Objects.html</a>
  </p>
</div>
