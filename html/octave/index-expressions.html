<div class="section" id="Index-Expressions">   <h1 class="section">8.1 Index Expressions</h1>    <p>An <em>index expression</em> allows you to reference or extract selected elements of a vector, a matrix (2-D), or a higher-dimensional array. </p> <p>Indices may be scalars, vectors, ranges, or the special operator ‘<samp>:</samp>’, which selects entire rows, columns, or higher-dimensional slices. </p> <p>An index expression consists of a set of parentheses enclosing <em class="math">M</em> expressions separated by commas. Each individual index value, or component, is used for the respective dimension of the object that it is applied to. In other words, the first index component is used for the first dimension (rows) of the object, the second index component is used for the second dimension (columns) of the object, and so on. The number of index components <em class="math">M</em> defines the dimensionality of the index expression. An index with two components would be referred to as a 2-D index because it has two dimensions. </p> <p>In the simplest case, 1) all components are scalars, and 2) the dimensionality of the index expression <em class="math">M</em> is equal to the dimensionality of the object it is applied to. For example: </p> <pre class="example" data-language="matlab">A = reshape (1:8, 2, 2, 2)  # Create 3-D array
A =

ans(:,:,1) =

   1   3
   2   4

ans(:,:,2) =

   5   7
   6   8

A(2, 1, 2)   # second row, first column of second slice
             # in third dimension: ans = 6</pre> <p>The size of the returned object in a specific dimension is equal to the number of elements in the corresponding component of the index expression. When all components are scalars, the result is a single output value. However, if any component is a vector or range then the returned values are the Cartesian product of the indices in the respective dimensions. For example: </p> <pre class="example" data-language="matlab">A([1, 2], 1, 2) ≡ [A(1,1,2); A(2,1,2)]
⇒
ans =
   5
   6</pre> <p>The total number of returned values is the product of the number of elements returned for each index component. In the example above, the total is 2*1*1 = 2 elements. </p> <p>Notice that the size of the returned object in a given dimension is equal to the number of elements in the index expression for that dimension. In the code above, the first index component (<code>[1, 2]</code>) was specified as a row vector, but its shape is unimportant. The important fact is that the component specified two values, and hence the result must have a size of two in the first dimension; and because the first dimension corresponds to rows, the overall result is a column vector. </p> <pre class="example" data-language="matlab">A(1, [2, 1, 1], 1)    # result is a row vector: ans = [3, 1, 1]
A(ones (2, 2), 1, 1)  # result is a column vector: ans = [1; 1; 1; 1]</pre> <p>The first line demonstrates again that the size of the output in a given dimension is equal to the number of elements in the respective indexing component. In this case, the output has three elements in the second dimension (which corresponds to columns), so the result is a row vector. The example also shows how repeating entries in the index expression can be used to replicate elements in the output. The last example further proves that the shape of the indexing component is irrelevant, it is only the number of elements (2x2 = 4) which is important. </p> <p>The above rules apply whenever the dimensionality of the index expression is greater than one (<em class="math">M &gt; 1</em>). However, for one-dimensional index expressions special rules apply and the shape of the output <strong>is</strong> determined by the shape of the indexing component. For example: </p> <pre class="example" data-language="matlab">A([1, 2])  # result is a row vector: ans = [1, 2]
A([1; 2])  # result is a column vector: ans = [1; 2]</pre> <p>The shape rules for <var>A</var>(<var>P</var>) are: </p>
<ul> <li> When at least one of <var>A</var> or <var>P</var> has two or more dimensions, then <var>A</var>(<var>P</var>) takes the shape of <var>P</var>. This happens when at least one of the variables is a 2-D matrix or an N-D array. </li>
<li> When both <var>A</var> and <var>P</var> are 1-D vectors, then <var>A</var>(<var>P</var>) takes the shape of <var>A</var> itself. In particular, when <var>A</var> is a row vector, then <var>A</var>(<var>P</var>) is also a row vector irrespective of <var>P</var>’s shape. The case when <var>A</var> is a column vector is analogous. </li>
</ul> <p>Note that it is permissible to use a 1-D index with a multi-dimensional object (also called linear indexing). In this case, the elements of the multi-dimensional array are taken in column-first order like Fortran. That is, the columns of the array are imagined to be stacked on top of each other to form a column vector and then the single linear index is applied to this vector. </p> <pre class="example" data-language="matlab">A(5)    # linear indexing into three-dimensional array: ans = 5
A(3:5)  # result has shape of index component: ans = [3, 4, 5]</pre>  <p>A colon (‘<samp>:</samp>’) may be used as an index component to select all of the elements in a specified dimension. Given the matrix, </p> <pre class="example" data-language="matlab">A = [1, 2; 3, 4]</pre> <p>all of the following expressions are equivalent and select the first row of the matrix. </p> <pre class="example" data-language="matlab">A(1, [1, 2])  # row 1, columns 1 and 2
A(1, 1:2)     # row 1, columns in range 1-2
A(1, :)       # row 1, all columns</pre> <p>When a colon is used in the special case of 1-D indexing the result is always a column vector. Creating column vectors with a colon index is a very frequently encountered code idiom and is faster and generally clearer than calling <code>reshape</code> for this case. </p> <pre class="example" data-language="matlab">A(:)    # result is column vector: ans = [1; 2; 3; 4]
A(:)'   # result is row vector: ans = [1, 2, 3, 4]</pre>   <p>In index expressions the keyword <code>end</code> automatically refers to the last entry for a particular dimension. This magic index can also be used in ranges and typically eliminates the needs to call <code>size</code> or <code>length</code> to gather array bounds before indexing. For example: </p> <pre class="example" data-language="matlab">A(1:end/2)        # first half of A =&gt; [1, 2]
A(end + 1) = 5;   # append element
A(end) = [];      # delete element
A(1:2:end)        # odd elements of A =&gt; [1, 3]
A(2:2:end)        # even elements of A =&gt; [2, 4]
A(end:-1:1)       # reversal of A =&gt; [4, 3, 2, 1]</pre> <ul class="section-toc"> <li><a href="advanced-indexing.html" accesskey="1">Advanced Indexing</a></li> </ul> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Index-Expressions.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Index-Expressions.html</a>
  </p>
</div>
