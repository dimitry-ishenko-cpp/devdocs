<div class="section-level-extent" id="Linear-Least-Squares"> <div class="nav-panel"> <p> Previous: <a href="nonlinear-programming.html" accesskey="p" rel="prev">Nonlinear Programming</a>, Up: <a href="optimization.html" accesskey="u" rel="up">Optimization</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Linear-Least-Squares-1"><span>25.4 Linear Least Squares<a class="copiable-link" href="#Linear-Least-Squares-1"> ¶</a></span></h1> <p>Octave also supports linear least squares minimization. That is, Octave can find the parameter <em class="math">b</em> such that the model <em class="math">y = x*b</em> fits data <em class="math">(x,y)</em> as well as possible, assuming zero-mean Gaussian noise. If the noise is assumed to be isotropic the problem can be solved using the ‘<samp class="samp">\</samp>’ or ‘<samp class="samp">/</samp>’ operators, or the <code class="code">ols</code> function. In the general case where the noise is assumed to be anisotropic the <code class="code">gls</code> is needed. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ols">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">beta</var>, <var class="var">sigma</var>, <var class="var">r</var>] =</code> <strong class="def-name">ols</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-ols"> ¶</a></span>
</dt> <dd>
<p>Ordinary least squares (OLS) estimation. </p> <p>OLS applies to the multivariate model <em class="math"><var class="var">y</var> = <var class="var">x</var>*<var class="var">b</var> + <var class="var">e</var></em> where <em class="math"><var class="var">y</var></em> is a <em class="math">t</em>-by-<em class="math">p</em> matrix, <em class="math"><var class="var">x</var></em> is a <em class="math">t</em>-by-<em class="math">k</em> matrix, <var class="var">b</var> is a <em class="math">k</em>-by-<em class="math">p</em> matrix, and <var class="var">e</var> is a <em class="math">t</em>-by-<em class="math">p</em> matrix. </p> <p>Each row of <var class="var">y</var> is a <em class="math">p</em>-variate observation in which each column represents a variable. Likewise, the rows of <var class="var">x</var> represent <em class="math">k</em>-variate observations or possibly designed values. Furthermore, the collection of observations <var class="var">x</var> must be of adequate rank, <em class="math">k</em>, otherwise <var class="var">b</var> cannot be uniquely estimated. </p> <p>The observation errors, <var class="var">e</var>, are assumed to originate from an underlying <em class="math">p</em>-variate distribution with zero mean and <em class="math">p</em>-by-<em class="math">p</em> covariance matrix <var class="var">S</var>, both constant conditioned on <var class="var">x</var>. Furthermore, the matrix <var class="var">S</var> is constant with respect to each observation such that <code class="code">mean (<var class="var">e</var>) = 0</code> and <code class="code">cov (vec (<var class="var">e</var>)) = kron (<var class="var">s</var>, <var class="var">I</var>)</code>. (For cases that don’t meet this criteria, such as autocorrelated errors, see generalized least squares, gls, for more efficient estimations.) </p> <p>The return values <var class="var">beta</var>, <var class="var">sigma</var>, and <var class="var">r</var> are defined as follows. </p> <dl class="table"> <dt><var class="var">beta</var></dt> <dd>
<p>The OLS estimator for matrix <var class="var">b</var>. <var class="var">beta</var> is calculated directly via <code class="code">inv (<var class="var">x</var>'*<var class="var">x</var>) * <var class="var">x</var>' * <var class="var">y</var></code> if the matrix <code class="code"><var class="var">x</var>'*<var class="var">x</var></code> is of full rank. Otherwise, <code class="code"><var class="var">beta</var> = pinv (<var class="var">x</var>) * <var class="var">y</var></code> where <code class="code">pinv (<var class="var">x</var>)</code> denotes the pseudoinverse of <var class="var">x</var>. </p> </dd> <dt><var class="var">sigma</var></dt> <dd>
<p>The OLS estimator for the matrix <var class="var">s</var>, </p> <pre class="example" data-language="matlab">sigma = (y-x*beta)' * (y-x*beta) / (t-rank(x))</pre> </dd> <dt><var class="var">r</var></dt> <dd><p>The matrix of OLS residuals, <code class="code"><var class="var">r</var> = <var class="var">y</var> - <var class="var">x</var>*<var class="var">beta</var></code>. </p></dd> </dl> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgls">gls</a>, <a class="ref" href="basic-matrix-functions.html#XREFpinv">pinv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-gls">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">beta</var>, <var class="var">v</var>, <var class="var">r</var>] =</code> <strong class="def-name">gls</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">x</var>, <var class="var">o</var>)</code><a class="copiable-link" href="#index-gls"> ¶</a></span>
</dt> <dd>
<p>Generalized least squares (GLS) model. </p> <p>Perform a generalized least squares estimation for the multivariate model <em class="math"><var class="var">y</var> = <var class="var">x</var>*<var class="var">B</var> + <var class="var">E</var></em> where <var class="var">y</var> is a <em class="math">t</em>-by-<em class="math">p</em> matrix, <var class="var">x</var> is a <em class="math">t</em>-by-<em class="math">k</em> matrix, <var class="var">b</var> is a <em class="math">k</em>-by-<em class="math">p</em> matrix and <var class="var">e</var> is a <em class="math">t</em>-by-<em class="math">p</em> matrix. </p> <p>Each row of <var class="var">y</var> is a <em class="math">p</em>-variate observation in which each column represents a variable. Likewise, the rows of <var class="var">x</var> represent <em class="math">k</em>-variate observations or possibly designed values. Furthermore, the collection of observations <var class="var">x</var> must be of adequate rank, <em class="math">k</em>, otherwise <var class="var">b</var> cannot be uniquely estimated. </p> <p>The observation errors, <var class="var">e</var>, are assumed to originate from an underlying <em class="math">p</em>-variate distribution with zero mean but possibly heteroscedastic observations. That is, in general, <code class="code"><em class="math">mean (<var class="var">e</var>) = 0</em></code> and <code class="code"><em class="math">cov (vec (<var class="var">e</var>)) = (<em class="math">s</em>^2)*<var class="var">o</var></em></code> in which <em class="math">s</em> is a scalar and <var class="var">o</var> is a <em class="math">t*p</em>-by-<em class="math">t*p</em> matrix. </p> <p>The return values <var class="var">beta</var>, <var class="var">v</var>, and <var class="var">r</var> are defined as follows. </p> <dl class="table"> <dt><var class="var">beta</var></dt> <dd>
<p>The GLS estimator for matrix <var class="var">b</var>. </p> </dd> <dt><var class="var">v</var></dt> <dd>
<p>The GLS estimator for scalar <em class="math">s^2</em>. </p> </dd> <dt><var class="var">r</var></dt> <dd><p>The matrix of GLS residuals, <em class="math"><var class="var">r</var> = <var class="var">y</var> - <var class="var">x</var>*<var class="var">beta</var></em>. </p></dd> </dl> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFols">ols</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-lsqnonneg">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">lsqnonneg</strong> <code class="def-code-arguments">(<var class="var">c</var>, <var class="var">d</var>)</code><a class="copiable-link" href="#index-lsqnonneg"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lsqnonneg-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">lsqnonneg</strong> <code class="def-code-arguments">(<var class="var">c</var>, <var class="var">d</var>, <var class="var">x0</var>)</code><a class="copiable-link" href="#index-lsqnonneg-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lsqnonneg-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">lsqnonneg</strong> <code class="def-code-arguments">(<var class="var">c</var>, <var class="var">d</var>, <var class="var">x0</var>, <var class="var">options</var>)</code><a class="copiable-link" href="#index-lsqnonneg-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lsqnonneg-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">resnorm</var>] =</code> <strong class="def-name">lsqnonneg</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-lsqnonneg-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lsqnonneg-4">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">resnorm</var>, <var class="var">residual</var>] =</code> <strong class="def-name">lsqnonneg</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-lsqnonneg-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lsqnonneg-5">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">resnorm</var>, <var class="var">residual</var>, <var class="var">exitflag</var>] =</code> <strong class="def-name">lsqnonneg</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-lsqnonneg-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lsqnonneg-6">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">resnorm</var>, <var class="var">residual</var>, <var class="var">exitflag</var>, <var class="var">output</var>] =</code> <strong class="def-name">lsqnonneg</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-lsqnonneg-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lsqnonneg-7">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">resnorm</var>, <var class="var">residual</var>, <var class="var">exitflag</var>, <var class="var">output</var>, <var class="var">lambda</var>] =</code> <strong class="def-name">lsqnonneg</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-lsqnonneg-7"> ¶</a></span>
</dt> <dd> <p>Minimize <code class="code">norm (<var class="var">c</var>*<var class="var">x</var> - <var class="var">d</var>)</code> subject to <code class="code"><var class="var">x</var> &gt;= 0</code>. </p> <p><var class="var">c</var> and <var class="var">d</var> must be real matrices. </p> <p><var class="var">x0</var> is an optional initial guess for the solution <var class="var">x</var>. </p> <p><var class="var">options</var> is an options structure to change the behavior of the algorithm (see <a class="pxref" href="#XREFoptimset"><code class="code">optimset</code></a>). <code class="code">lsqnonneg</code> recognizes these options: <code class="code">"MaxIter"</code>, <code class="code">"TolX"</code>. </p> <p>Outputs: </p> <dl class="table"> <dt><var class="var">resnorm</var></dt> <dd>
<p>The squared 2-norm of the residual: <code class="code">norm (<var class="var">c</var>*<var class="var">x</var>-<var class="var">d</var>)^2</code> </p> </dd> <dt><var class="var">residual</var></dt> <dd>
<p>The residual: <code class="code"><var class="var">d</var>-<var class="var">c</var>*<var class="var">x</var></code> </p> </dd> <dt><var class="var">exitflag</var></dt> <dd>
<p>An indicator of convergence. 0 indicates that the iteration count was exceeded, and therefore convergence was not reached; &gt;0 indicates that the algorithm converged. (The algorithm is stable and will converge given enough iterations.) </p> </dd> <dt><var class="var">output</var></dt> <dd>
<p>A structure with two fields: </p> <ul class="itemize mark-bullet"> <li>
<code class="code">"algorithm"</code>: The algorithm used (<code class="code">"nnls"</code>) </li>
<li>
<code class="code">"iterations"</code>: The number of iterations taken. </li>
</ul> </dd> <dt><var class="var">lambda</var></dt> <dd>
<p>Lagrange multipliers. If these are nonzero, the corresponding <var class="var">x</var> values should be zero, indicating the solution is pressed up against a coordinate plane. The magnitude indicates how much the residual would improve if the <code class="code"><var class="var">x</var> &gt;= 0</code> constraints were relaxed in that direction. </p> </dd> </dl> <p><strong class="strong">See also:</strong> <a class="ref" href="quadratic-programming.html#XREFpqpnonneg">pqpnonneg</a>, <a class="ref" href="#XREFlscov">lscov</a>, <a class="ref" href="#XREFoptimset">optimset</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-lscov">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">lscov</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-lscov"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lscov-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">lscov</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">V</var>)</code><a class="copiable-link" href="#index-lscov-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lscov-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">lscov</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">V</var>, <var class="var">alg</var>)</code><a class="copiable-link" href="#index-lscov-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lscov-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">stdx</var>, <var class="var">mse</var>, <var class="var">S</var>] =</code> <strong class="def-name">lscov</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-lscov-3"> ¶</a></span>
</dt> <dd> <p>Compute a generalized linear least squares fit. </p> <p>Estimate <var class="var">x</var> under the model <var class="var">b</var> = <var class="var">A</var><var class="var">x</var> + <var class="var">w</var>, where the noise <var class="var">w</var> is assumed to follow a normal distribution with covariance matrix <em class="math">{\sigma^2} V</em>. </p> <p>If the size of the coefficient matrix <var class="var">A</var> is n-by-p, the size of the vector/array of constant terms <var class="var">b</var> must be n-by-k. </p> <p>The optional input argument <var class="var">V</var> may be an n-element vector of positive weights (inverse variances), or an n-by-n symmetric positive semi-definite matrix representing the covariance of <var class="var">b</var>. If <var class="var">V</var> is not supplied, the ordinary least squares solution is returned. </p> <p>The <var class="var">alg</var> input argument, a guidance on solution method to use, is currently ignored. </p> <p>Besides the least-squares estimate matrix <var class="var">x</var> (p-by-k), the function also returns <var class="var">stdx</var> (p-by-k), the error standard deviation of estimated <var class="var">x</var>; <var class="var">mse</var> (k-by-1), the estimated data error covariance scale factors (<em class="math">\sigma^2</em>); and <var class="var">S</var> (p-by-p, or p-by-p-by-k if k &gt; 1), the error covariance of <var class="var">x</var>. </p> <p>Reference: Golub and Van Loan (1996), <cite class="cite">Matrix Computations (3rd Ed.)</cite>, Johns Hopkins, Section 5.6.3 </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFols">ols</a>, <a class="ref" href="#XREFgls">gls</a>, <a class="ref" href="#XREFlsqnonneg">lsqnonneg</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-optimset">
<span class="category-def">: </span><span><strong class="def-name">optimset</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-optimset"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-optimset-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">options</var> =</code> <strong class="def-name">optimset</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-optimset-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-optimset-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">options</var> =</code> <strong class="def-name">optimset</strong> <code class="def-code-arguments">(<var class="var">par</var>, <var class="var">val</var>, …)</code><a class="copiable-link" href="#index-optimset-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-optimset-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">options</var> =</code> <strong class="def-name">optimset</strong> <code class="def-code-arguments">(<var class="var">old</var>, <var class="var">par</var>, <var class="var">val</var>, …)</code><a class="copiable-link" href="#index-optimset-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-optimset-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">options</var> =</code> <strong class="def-name">optimset</strong> <code class="def-code-arguments">(<var class="var">old</var>, <var class="var">new</var>)</code><a class="copiable-link" href="#index-optimset-4"> ¶</a></span>
</dt> <dd>
<p>Create options structure for optimization functions. </p> <p>When called without any input or output arguments, <code class="code">optimset</code> prints a list of all valid optimization parameters. </p> <p>When called with one output and no inputs, return an options structure with all valid option parameters initialized to <code class="code">[]</code>. </p> <p>When called with a list of parameter/value pairs, return an options structure with only the named parameters initialized. </p> <p>When the first input is an existing options structure <var class="var">old</var>, the values are updated from either the <var class="var">par</var>/<var class="var">val</var> list or from the options structure <var class="var">new</var>. </p> <p>If <var class="var">par</var> does not exactly match the name of a standard parameter, <code class="code">optimset</code> will attempt to match <var class="var">par</var> to a standard parameter and will set the value of that parameter if a match is found. Matching is case insensitive and is based on character matching at the start of the parameter name. <code class="code">optimset</code> produces an error if it finds multiple ambiguous matches. If no standard parameter matches are found a warning is issued and the non-standard parameter is created. </p> <p>Standard list of valid parameters: </p> <dl class="table"> <dt>AutoScaling</dt> <dt>ComplexEqn</dt> <dt>Display</dt> <dd>
<p>Request verbose display of results from optimizations. Values are: </p> <dl class="table"> <dt>
<code class="code">"off"</code> [default]</dt> <dd>
<p>No display. </p> </dd> <dt><code class="code">"iter"</code></dt> <dd>
<p>Display intermediate results for every loop iteration. </p> </dd> <dt><code class="code">"final"</code></dt> <dd>
<p>Display the result of the final loop iteration. </p> </dd> <dt><code class="code">"notify"</code></dt> <dd><p>Display the result of the final loop iteration if the function has failed to converge. </p></dd> </dl> </dd> <dt>FinDiffType</dt> <dt>FunValCheck</dt> <dd>
<p>When enabled, display an error if the objective function returns an invalid value (a complex number, NaN, or Inf). Must be set to <code class="code">"on"</code> or <code class="code">"off"</code> [default]. Note: the functions <code class="code">fzero</code> and <code class="code">fminbnd</code> correctly handle Inf values and only complex values or NaN will cause an error in this case. </p> </dd> <dt>GradObj</dt> <dd>
<p>When set to <code class="code">"on"</code>, the function to be minimized must return a second argument which is the gradient, or first derivative, of the function at the point <var class="var">x</var>. If set to <code class="code">"off"</code> [default], the gradient is computed via finite differences. </p> </dd> <dt>Jacobian</dt> <dd>
<p>When set to <code class="code">"on"</code>, the function to be minimized must return a second argument which is the Jacobian, or first derivative, of the function at the point <var class="var">x</var>. If set to <code class="code">"off"</code> [default], the Jacobian is computed via finite differences. </p> </dd> <dt>MaxFunEvals</dt> <dd>
<p>Maximum number of function evaluations before optimization stops. Must be a positive integer. </p> </dd> <dt>MaxIter</dt> <dd>
<p>Maximum number of algorithm iterations before optimization stops. Must be a positive integer. </p> </dd> <dt>OutputFcn</dt> <dd>
<p>A user-defined function executed once per algorithm iteration. </p> </dd> <dt>TolFun</dt> <dd>
<p>Termination criterion for the function output. If the difference in the calculated objective function between one algorithm iteration and the next is less than <code class="code">TolFun</code> the optimization stops. Must be a positive scalar. </p> </dd> <dt>TolX</dt> <dd>
<p>Termination criterion for the function input. If the difference in <var class="var">x</var>, the current search point, between one algorithm iteration and the next is less than <code class="code">TolX</code> the optimization stops. Must be a positive scalar. </p> </dd> <dt>TypicalX</dt> <dt>Updating</dt> </dl> <p>This list can be extended by the user or other loaded Octave packages. An updated valid parameters list can be queried using the no-argument form of <code class="code">optimset</code>. </p> <p>Note 1: Only parameter names from the standard list are considered when matching short parameter names, and <var class="var">par</var> will always be expanded to match a standard parameter even if an exact non-standard match exists. The value of a non-standard parameter that is ambiguous with one or more standard parameters cannot be set by <code class="code">optimset</code> and can only be set using <code class="code">setfield</code> or dot notation for structs. </p> <p>Note 2: The optimization options structure is primarily intended for manipulation of known parameters by <code class="code">optimset</code> and <code class="code">optimget</code>. Unpredictable behavior on future calls to <code class="code">optimset</code> or <code class="code">optimget</code> can result from creating non-standard or ambiguous parameters or from loading/unloading packages that change the known parameter list after creation of an optimization options structure. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFoptimget">optimget</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-optimget">
<span class="category-def">: </span><span><code class="def-type"><var class="var">val</var> =</code> <strong class="def-name">optimget</strong> <code class="def-code-arguments">(<var class="var">options</var>, <var class="var">par</var>)</code><a class="copiable-link" href="#index-optimget"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-optimget-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">val</var> =</code> <strong class="def-name">optimget</strong> <code class="def-code-arguments">(<var class="var">options</var>, <var class="var">par</var>, <var class="var">default</var>)</code><a class="copiable-link" href="#index-optimget-1"> ¶</a></span>
</dt> <dd>
<p>Return the value of the specific parameter <var class="var">par</var> from the optimization options structure <var class="var">options</var> created by <code class="code">optimset</code>. </p> <p>If <var class="var">par</var> is not defined then return the <var class="var">default</var> value if supplied, otherwise return an empty matrix. </p> <p>If <var class="var">par</var> does not exactly match the name of a standard parameter, <code class="code">optimget</code> will attempt to match <var class="var">par</var> to a standard parameter and will return that parameter’s value if a match is found. Matching is case insensitive and is based on character matching at the start of the parameter name. <code class="code">optimget</code> produces an error if it finds multiple ambiguous matches. If no standard parameter matches are found a warning is issued. See <code class="code">optimset</code> for information about the standard options list. </p> <p>Note: Only parameter names from the standard list are considered when matching short parameter names, and <var class="var">par</var> will always be expanded to match a standard parameter even if an exact non-standard match exists. The value of a non-standard parameter that is ambiguous with one or more standard parameters cannot be returned by <code class="code">optimget</code> and can only be accessed using <code class="code">getfield</code> or dot notation for structs. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFoptimset">optimset</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Previous: <a href="nonlinear-programming.html">Nonlinear Programming</a>, Up: <a href="optimization.html">Optimization</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Linear-Least-Squares.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Linear-Least-Squares.html</a>
  </p>
</div>
