<div class="section" id="Products-of-Polynomials">   <h1 class="section">28.3 Products of Polynomials</h1> <dl class="def"> <dt id="index-conv">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>conv</strong> <em>(<var>a</var>, <var>b</var>)</em><a href="#index-conv" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-conv-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>conv</strong> <em>(<var>a</var>, <var>b</var>, <var>shape</var>)</em><a href="#index-conv-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Convolve two vectors <var>a</var> and <var>b</var>. </p> <p>When <var>a</var> and <var>b</var> are the coefficient vectors of two polynomials, the convolution represents the coefficient vector of the product polynomial. </p> <p>The size of the result is determined by the optional <var>shape</var> argument which takes the following values </p> <dl compact> <dt><span><var>shape</var> = <code>"full"</code></span></dt> <dd>
<p>Return the full convolution. (default) The result is a vector with length equal to <code>length (<var>a</var>) + length (<var>b</var>) - 1</code>. </p> </dd> <dt><span><var>shape</var> = <code>"same"</code></span></dt> <dd>
<p>Return the central part of the convolution with the same size as <var>a</var>. </p> </dd> <dt><span><var>shape</var> = <code>"valid"</code></span></dt> <dd><p>Return only the parts which do not include zero-padded edges. The size of the result is <code>max (size (<var>a</var>) - size (<var>b</var>) + 1, 0)</code>. </p></dd> </dl> <p><strong>See also:</strong> <a href="#XREFdeconv">deconv</a>, <a href="#XREFconv2">conv2</a>, <a href="#XREFconvn">convn</a>, <a href="signal-processing.html#XREFfftconv">fftconv</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-convn">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>convn</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-convn" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-convn-1">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>convn</strong> <em>(<var>A</var>, <var>B</var>, <var>shape</var>)</em><a href="#index-convn-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the n-D convolution of <var>A</var> and <var>B</var>. </p> <p>The size of the result is determined by the optional <var>shape</var> argument which takes the following values </p> <dl compact> <dt><span><var>shape</var> = <code>"full"</code></span></dt> <dd>
<p>Return the full convolution. (default) </p> </dd> <dt><span><var>shape</var> = <code>"same"</code></span></dt> <dd>
<p>Return central part of the convolution with the same size as <var>A</var>. The central part of the convolution begins at the indices <code>floor ([size(<var>B</var>)/2] + 1)</code>. </p> </dd> <dt><span><var>shape</var> = <code>"valid"</code></span></dt> <dd><p>Return only the parts which do not include zero-padded edges. The size of the result is <code>max (size (A) - size (B) + 1, 0)</code>. </p></dd> </dl> <p><strong>See also:</strong> <a href="#XREFconv2">conv2</a>, <a href="#XREFconv">conv</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-deconv">
<span class="category">: </span><span><em><var>b</var> =</em> <strong>deconv</strong> <em>(<var>y</var>, <var>a</var>)</em><a href="#index-deconv" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-deconv-1">
<span class="category">: </span><span><em>[<var>b</var>, <var>r</var>] =</em> <strong>deconv</strong> <em>(<var>y</var>, <var>a</var>)</em><a href="#index-deconv-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Deconvolve two vectors (polynomial division). </p> <p><code>[<var>b</var>, <var>r</var>] = deconv (<var>y</var>, <var>a</var>)</code> solves for <var>b</var> and <var>r</var> such that <code><var>y</var> = conv (<var>a</var>, <var>b</var>) + <var>r</var></code>. </p> <p>If <var>y</var> and <var>a</var> are polynomial coefficient vectors, <var>b</var> will contain the coefficients of the polynomial quotient and <var>r</var> will be a remainder polynomial of lowest order. </p> <p><strong>See also:</strong> <a href="#XREFconv">conv</a>, <a href="#XREFresidue">residue</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-conv2">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>conv2</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-conv2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-conv2-1">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>conv2</strong> <em>(<var>v1</var>, <var>v2</var>, <var>m</var>)</em><a href="#index-conv2-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-conv2-2">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>conv2</strong> <em>(…, <var>shape</var>)</em><a href="#index-conv2-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the 2-D convolution of <var>A</var> and <var>B</var>. </p> <p>The size of the result is determined by the optional <var>shape</var> argument which takes the following values </p> <dl compact> <dt><span><var>shape</var> = <code>"full"</code></span></dt> <dd>
<p>Return the full convolution. (default) </p> </dd> <dt><span><var>shape</var> = <code>"same"</code></span></dt> <dd>
<p>Return the central part of the convolution with the same size as <var>A</var>. The central part of the convolution begins at the indices <code>floor ([size(<var>B</var>)/2] + 1)</code>. </p> </dd> <dt><span><var>shape</var> = <code>"valid"</code></span></dt> <dd><p>Return only the parts which do not include zero-padded edges. The size of the result is <code>max (size (A) - size (B) + 1, 0)</code>. </p></dd> </dl> <p>When the third argument is a matrix, return the convolution of the matrix <var>m</var> by the vector <var>v1</var> in the column direction and by the vector <var>v2</var> in the row direction. </p> <p><strong>See also:</strong> <a href="#XREFconv">conv</a>, <a href="#XREFconvn">convn</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-polygcd">
<span class="category">: </span><span><em><var>q</var> =</em> <strong>polygcd</strong> <em>(<var>b</var>, <var>a</var>)</em><a href="#index-polygcd" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-polygcd-1">
<span class="category">: </span><span><em><var>q</var> =</em> <strong>polygcd</strong> <em>(<var>b</var>, <var>a</var>, <var>tol</var>)</em><a href="#index-polygcd-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Find the greatest common divisor of two polynomials. </p> <p>This is equivalent to the polynomial found by multiplying together all the common roots. Together with deconv, you can reduce a ratio of two polynomials. </p> <p>The tolerance <var>tol</var> defaults to <code>sqrt (eps)</code>. </p> <p><strong>Caution:</strong> This is a numerically unstable algorithm and should not be used on large polynomials. </p> <p>Example code: </p> <pre class="example" data-language="matlab">polygcd (poly (1:8), poly (3:12)) - poly (3:8)
⇒ [ 0, 0, 0, 0, 0, 0, 0 ]
deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))) - poly (1:2)
⇒ [ 0, 0, 0 ]</pre> <p><strong>See also:</strong> <a href="miscellaneous-functions.html#XREFpoly">poly</a>, <a href="finding-roots.html#XREFroots">roots</a>, <a href="#XREFconv">conv</a>, <a href="#XREFdeconv">deconv</a>, <a href="#XREFresidue">residue</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-residue">
<span class="category">: </span><span><em>[<var>r</var>, <var>p</var>, <var>k</var>, <var>e</var>] =</em> <strong>residue</strong> <em>(<var>b</var>, <var>a</var>)</em><a href="#index-residue" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-residue-1">
<span class="category">: </span><span><em>[<var>b</var>, <var>a</var>] =</em> <strong>residue</strong> <em>(<var>r</var>, <var>p</var>, <var>k</var>)</em><a href="#index-residue-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-residue-2">
<span class="category">: </span><span><em>[<var>b</var>, <var>a</var>] =</em> <strong>residue</strong> <em>(<var>r</var>, <var>p</var>, <var>k</var>, <var>e</var>)</em><a href="#index-residue-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>The first calling form computes the partial fraction expansion for the quotient of the polynomials, <var>b</var> and <var>a</var>. </p> <p>The quotient is defined as </p> <pre class="example" data-language="matlab">B(s)    M       r(m)        N
---- = SUM ------------- + SUM k(i)*s^(N-i)
A(s)   m=1 (s-p(m))^e(m)   i=1</pre> <p>where <em class="math">M</em> is the number of poles (the length of the <var>r</var>, <var>p</var>, and <var>e</var>), the <var>k</var> vector is a polynomial of order <em class="math">N-1</em> representing the direct contribution, and the <var>e</var> vector specifies the multiplicity of the m-th residue’s pole. </p> <p>For example, </p> <pre class="example" data-language="matlab">b = [1, 1, 1];
a = [1, -5, 8, -4];
[r, p, k, e] = residue (b, a)
   ⇒ r = [-2; 7; 3]
   ⇒ p = [2; 2; 1]
   ⇒ k = [](0x0)
   ⇒ e = [1; 2; 1]</pre> <p>which represents the following partial fraction expansion </p> <pre class="example" data-language="matlab">s^2 + s + 1       -2        7        3
   ------------------- = ----- + ------- + -----
   s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)</pre> <p>The second calling form performs the inverse operation and computes the reconstituted quotient of polynomials, <var>b</var>(s)/<var>a</var>(s), from the partial fraction expansion; represented by the residues, poles, and a direct polynomial specified by <var>r</var>, <var>p</var> and <var>k</var>, and the pole multiplicity <var>e</var>. </p> <p>If the multiplicity, <var>e</var>, is not explicitly specified the multiplicity is determined by the function <code>mpoles</code>. </p> <p>For example: </p> <pre class="example" data-language="matlab">r = [-2; 7; 3];
p = [2; 2; 1];
k = [1, 0];
[b, a] = residue (r, p, k)
   ⇒ b = [1, -5, 9, -3, 1]
   ⇒ a = [1, -5, 8, -4]

where mpoles is used to determine e = [1; 2; 1]</pre> <p>Alternatively the multiplicity may be defined explicitly, for example, </p> <pre class="example" data-language="matlab">r = [7; 3; -2];
p = [2; 1; 2];
k = [1, 0];
e = [2; 1; 1];
[b, a] = residue (r, p, k, e)
   ⇒ b = [1, -5, 9, -3, 1]
   ⇒ a = [1, -5, 8, -4]</pre> <p>which represents the following partial fraction expansion </p> <pre class="example" data-language="matlab">-2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
----- + ------- + ----- + s = --------------------------
(s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4</pre> <p><strong>See also:</strong> <a href="finding-roots.html#XREFmpoles">mpoles</a>, <a href="miscellaneous-functions.html#XREFpoly">poly</a>, <a href="finding-roots.html#XREFroots">roots</a>, <a href="#XREFconv">conv</a>, <a href="#XREFdeconv">deconv</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Products-of-Polynomials.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Products-of-Polynomials.html</a>
  </p>
</div>
