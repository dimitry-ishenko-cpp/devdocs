<div class="section-level-extent" id="Products-of-Polynomials"> <div class="nav-panel"> <p> Next: <a href="derivatives-_002f-integrals-_002f-transforms.html" accesskey="n" rel="next">Derivatives / Integrals / Transforms</a>, Previous: <a href="finding-roots.html" accesskey="p" rel="prev">Finding Roots</a>, Up: <a href="polynomial-manipulations.html" accesskey="u" rel="up">Polynomial Manipulations</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Products-of-Polynomials-1"><span>28.3 Products of Polynomials<a class="copiable-link" href="#Products-of-Polynomials-1"> ¶</a></span></h1>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-conv">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">conv</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-conv"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-conv-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">conv</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>, <var class="var">shape</var>)</code><a class="copiable-link" href="#index-conv-1"> ¶</a></span>
</dt> <dd>
<p>Convolve two vectors <var class="var">a</var> and <var class="var">b</var>. </p> <p>When <var class="var">a</var> and <var class="var">b</var> are the coefficient vectors of two polynomials, the convolution represents the coefficient vector of the product polynomial. </p> <p>The size of the result is determined by the optional <var class="var">shape</var> argument which takes the following values </p> <dl class="table"> <dt>
<var class="var">shape</var> = <code class="code">"full"</code>
</dt> <dd>
<p>Return the full convolution. (default) The result is a vector with length equal to <code class="code">length (<var class="var">a</var>) + length (<var class="var">b</var>) - 1</code>. </p> </dd> <dt>
<var class="var">shape</var> = <code class="code">"same"</code>
</dt> <dd>
<p>Return the central part of the convolution with the same size as <var class="var">a</var>. </p> </dd> <dt>
<var class="var">shape</var> = <code class="code">"valid"</code>
</dt> <dd><p>Return only the parts which do not include zero-padded edges. The size of the result is <code class="code">max (size (<var class="var">a</var>) - size (<var class="var">b</var>) + 1, 0)</code>. </p></dd> </dl> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFdeconv">deconv</a>, <a class="ref" href="#XREFconv2">conv2</a>, <a class="ref" href="#XREFconvn">convn</a>, <a class="ref" href="signal-processing.html#XREFfftconv">fftconv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-convn">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">convn</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-convn"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-convn-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">convn</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, <var class="var">shape</var>)</code><a class="copiable-link" href="#index-convn-1"> ¶</a></span>
</dt> <dd>
<p>Return the n-D convolution of <var class="var">A</var> and <var class="var">B</var>. </p> <p>The size of the result is determined by the optional <var class="var">shape</var> argument which takes the following values </p> <dl class="table"> <dt>
<var class="var">shape</var> = <code class="code">"full"</code>
</dt> <dd>
<p>Return the full convolution. (default) </p> </dd> <dt>
<var class="var">shape</var> = <code class="code">"same"</code>
</dt> <dd>
<p>Return central part of the convolution with the same size as <var class="var">A</var>. The central part of the convolution begins at the indices <code class="code">floor ([size(<var class="var">B</var>)/2] + 1)</code>. </p> </dd> <dt>
<var class="var">shape</var> = <code class="code">"valid"</code>
</dt> <dd><p>Return only the parts which do not include zero-padded edges. The size of the result is <code class="code">max (size (A) - size (B) + 1, 0)</code>. </p></dd> </dl> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFconv2">conv2</a>, <a class="ref" href="#XREFconv">conv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-deconv">
<span class="category-def">: </span><span><code class="def-type"><var class="var">b</var> =</code> <strong class="def-name">deconv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>)</code><a class="copiable-link" href="#index-deconv"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-deconv-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">b</var>, <var class="var">r</var>] =</code> <strong class="def-name">deconv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>)</code><a class="copiable-link" href="#index-deconv-1"> ¶</a></span>
</dt> <dd>
<p>Deconvolve two vectors (polynomial division). </p> <p><code class="code">[<var class="var">b</var>, <var class="var">r</var>] = deconv (<var class="var">y</var>, <var class="var">a</var>)</code> solves for <var class="var">b</var> and <var class="var">r</var> such that <code class="code"><var class="var">y</var> = conv (<var class="var">a</var>, <var class="var">b</var>) + <var class="var">r</var></code>. </p> <p>If <var class="var">y</var> and <var class="var">a</var> are polynomial coefficient vectors, <var class="var">b</var> will contain the coefficients of the polynomial quotient and <var class="var">r</var> will be a remainder polynomial of lowest order. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFconv">conv</a>, <a class="ref" href="#XREFresidue">residue</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-conv2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">conv2</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-conv2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-conv2-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">conv2</strong> <code class="def-code-arguments">(<var class="var">v1</var>, <var class="var">v2</var>, <var class="var">m</var>)</code><a class="copiable-link" href="#index-conv2-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-conv2-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">conv2</strong> <code class="def-code-arguments">(…, <var class="var">shape</var>)</code><a class="copiable-link" href="#index-conv2-2"> ¶</a></span>
</dt> <dd>
<p>Return the 2-D convolution of <var class="var">A</var> and <var class="var">B</var>. </p> <p>The size of the result is determined by the optional <var class="var">shape</var> argument which takes the following values </p> <dl class="table"> <dt>
<var class="var">shape</var> = <code class="code">"full"</code>
</dt> <dd>
<p>Return the full convolution. (default) </p> </dd> <dt>
<var class="var">shape</var> = <code class="code">"same"</code>
</dt> <dd>
<p>Return the central part of the convolution with the same size as <var class="var">A</var>. The central part of the convolution begins at the indices <code class="code">floor ([size(<var class="var">B</var>)/2] + 1)</code>. </p> </dd> <dt>
<var class="var">shape</var> = <code class="code">"valid"</code>
</dt> <dd><p>Return only the parts which do not include zero-padded edges. The size of the result is <code class="code">max (size (A) - size (B) + 1, 0)</code>. </p></dd> </dl> <p>When the third argument is a matrix, return the convolution of the matrix <var class="var">m</var> by the vector <var class="var">v1</var> in the column direction and by the vector <var class="var">v2</var> in the row direction. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFconv">conv</a>, <a class="ref" href="#XREFconvn">convn</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-polygcd">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">polygcd</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>)</code><a class="copiable-link" href="#index-polygcd"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-polygcd-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">polygcd</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-polygcd-1"> ¶</a></span>
</dt> <dd> <p>Find the greatest common divisor of two polynomials. </p> <p>This is equivalent to the polynomial found by multiplying together all the common roots. Together with deconv, you can reduce a ratio of two polynomials. </p> <p>The tolerance <var class="var">tol</var> defaults to <code class="code">sqrt (eps)</code>. </p> <p><strong class="strong">Caution:</strong> This is a numerically unstable algorithm and should not be used on large polynomials. </p> <p>Example code: </p> <pre class="example" data-language="matlab">polygcd (poly (1:8), poly (3:12)) - poly (3:8)
⇒ [ 0, 0, 0, 0, 0, 0, 0 ]
deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))) - poly (1:2)
⇒ [ 0, 0, 0 ]</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="miscellaneous-functions.html#XREFpoly">poly</a>, <a class="ref" href="finding-roots.html#XREFroots">roots</a>, <a class="ref" href="#XREFconv">conv</a>, <a class="ref" href="#XREFdeconv">deconv</a>, <a class="ref" href="#XREFresidue">residue</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-residue">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">r</var>, <var class="var">p</var>, <var class="var">k</var>, <var class="var">e</var>] =</code> <strong class="def-name">residue</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>)</code><a class="copiable-link" href="#index-residue"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-residue-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">b</var>, <var class="var">a</var>] =</code> <strong class="def-name">residue</strong> <code class="def-code-arguments">(<var class="var">r</var>, <var class="var">p</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-residue-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-residue-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">b</var>, <var class="var">a</var>] =</code> <strong class="def-name">residue</strong> <code class="def-code-arguments">(<var class="var">r</var>, <var class="var">p</var>, <var class="var">k</var>, <var class="var">e</var>)</code><a class="copiable-link" href="#index-residue-2"> ¶</a></span>
</dt> <dd>
<p>The first calling form computes the partial fraction expansion for the quotient of the polynomials, <var class="var">b</var> and <var class="var">a</var>. </p> <p>The quotient is defined as </p> <pre class="example" data-language="matlab">B(s)    M       r(m)        N
---- = SUM ------------- + SUM k(i)*s^(N-i)
A(s)   m=1 (s-p(m))^e(m)   i=1</pre> <p>where <em class="math">M</em> is the number of poles (the length of the <var class="var">r</var>, <var class="var">p</var>, and <var class="var">e</var>), the <var class="var">k</var> vector is a polynomial of order <em class="math">N-1</em> representing the direct contribution, and the <var class="var">e</var> vector specifies the multiplicity of the m-th residue’s pole. </p> <p>For example, </p> <pre class="example" data-language="matlab">b = [1, 1, 1];
a = [1, -5, 8, -4];
[r, p, k, e] = residue (b, a)
   ⇒ r = [-2; 7; 3]
   ⇒ p = [2; 2; 1]
   ⇒ k = [](0x0)
   ⇒ e = [1; 2; 1]</pre> <p>which represents the following partial fraction expansion </p> <pre class="example" data-language="matlab">s^2 + s + 1       -2        7        3
   ------------------- = ----- + ------- + -----
   s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)</pre> <p>The second calling form performs the inverse operation and computes the reconstituted quotient of polynomials, <var class="var">b</var>(s)/<var class="var">a</var>(s), from the partial fraction expansion; represented by the residues, poles, and a direct polynomial specified by <var class="var">r</var>, <var class="var">p</var> and <var class="var">k</var>, and the pole multiplicity <var class="var">e</var>. </p> <p>If the multiplicity, <var class="var">e</var>, is not explicitly specified the multiplicity is determined by the function <code class="code">mpoles</code>. </p> <p>For example: </p> <pre class="example" data-language="matlab">r = [-2; 7; 3];
p = [2; 2; 1];
k = [1, 0];
[b, a] = residue (r, p, k)
   ⇒ b = [1, -5, 9, -3, 1]
   ⇒ a = [1, -5, 8, -4]

where mpoles is used to determine e = [1; 2; 1]</pre> <p>Alternatively the multiplicity may be defined explicitly, for example, </p> <pre class="example" data-language="matlab">r = [7; 3; -2];
p = [2; 1; 2];
k = [1, 0];
e = [2; 1; 1];
[b, a] = residue (r, p, k, e)
   ⇒ b = [1, -5, 9, -3, 1]
   ⇒ a = [1, -5, 8, -4]</pre> <p>which represents the following partial fraction expansion </p> <pre class="example" data-language="matlab">-2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
----- + ------- + ----- + s = --------------------------
(s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="finding-roots.html#XREFmpoles">mpoles</a>, <a class="ref" href="miscellaneous-functions.html#XREFpoly">poly</a>, <a class="ref" href="finding-roots.html#XREFroots">roots</a>, <a class="ref" href="#XREFconv">conv</a>, <a class="ref" href="#XREFdeconv">deconv</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="derivatives-_002f-integrals-_002f-transforms.html">Derivatives / Integrals / Transforms</a>, Previous: <a href="finding-roots.html">Finding Roots</a>, Up: <a href="polynomial-manipulations.html">Polynomial Manipulations</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Products-of-Polynomials.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Products-of-Polynomials.html</a>
  </p>
</div>
