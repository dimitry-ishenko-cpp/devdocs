<div class="chapter-level-extent" id="Signal-Processing"> <div class="nav-panel"> <p> Next: <a href="image-processing.html" accesskey="n" rel="next">Image Processing</a>, Previous: <a href="geometry.html" accesskey="p" rel="prev">Geometry</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="chapter" id="Signal-Processing-1"><span>31 Signal Processing<a class="copiable-link" href="#Signal-Processing-1"> ¶</a></span></h1> <p>This chapter describes the signal processing and fast Fourier transform functions available in Octave. Fast Fourier transforms are computed with the <small class="sc">FFTW</small> or <small class="sc">FFTPACK</small> libraries depending on how Octave is built. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fft">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fft</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-fft"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fft-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-fft-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fft-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-fft-2"> ¶</a></span>
</dt> <dd>
<p>Compute the discrete Fourier transform of <var class="var">x</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The FFT is calculated along the first non-singleton dimension of the array. Thus if <var class="var">x</var> is a matrix, <code class="code">fft (<var class="var">x</var>)</code> computes the FFT for each column of <var class="var">x</var>. </p> <p>If called with two arguments, <var class="var">n</var> is expected to be an integer specifying the number of elements of <var class="var">x</var> to use, or an empty matrix to specify that its value should be ignored. If <var class="var">n</var> is larger than the dimension along which the FFT is calculated, then <var class="var">x</var> is resized and padded with zeros. Otherwise, if <var class="var">n</var> is smaller than the dimension along which the FFT is calculated, then <var class="var">x</var> is truncated. </p> <p>If called with three arguments, <var class="var">dim</var> is an integer specifying the dimension of the matrix along which the FFT is performed. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFifft">ifft</a>, <a class="ref" href="#XREFfft2">fft2</a>, <a class="ref" href="#XREFfftn">fftn</a>, <a class="ref" href="#XREFfftw">fftw</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ifft">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">ifft</strong> <code class="def-code-arguments">(<var class="var">y</var>)</code><a class="copiable-link" href="#index-ifft"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ifft-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">ifft</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-ifft-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ifft-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">ifft</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">n</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-ifft-2"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse discrete Fourier transform of <var class="var">y</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The inverse FFT is calculated along the first non-singleton dimension of the array. Thus if <var class="var">y</var> is a matrix, <code class="code">ifft (<var class="var">y</var>)</code> computes the inverse FFT for each column of <var class="var">y</var>. </p> <p>If called with two arguments, <var class="var">n</var> is expected to be an integer specifying the number of elements of <var class="var">y</var> to use, or an empty matrix to specify that its value should be ignored. If <var class="var">n</var> is larger than the dimension along which the inverse FFT is calculated, then <var class="var">y</var> is resized and padded with zeros. Otherwise, if <var class="var">n</var> is smaller than the dimension along which the inverse FFT is calculated, then <var class="var">y</var> is truncated. </p> <p>If called with three arguments, <var class="var">dim</var> is an integer specifying the dimension of the matrix along which the inverse FFT is performed. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfft">fft</a>, <a class="ref" href="#XREFifft2">ifft2</a>, <a class="ref" href="#XREFifftn">ifftn</a>, <a class="ref" href="#XREFfftw">fftw</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fft2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">fft2</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-fft2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fft2-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">fft2</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">m</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-fft2-1"> ¶</a></span>
</dt> <dd>
<p>Compute the two-dimensional discrete Fourier transform of <var class="var">A</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The optional arguments <var class="var">m</var> and <var class="var">n</var> may be used specify the number of rows and columns of <var class="var">A</var> to use. If either of these is larger than the size of <var class="var">A</var>, <var class="var">A</var> is resized and padded with zeros. </p> <p>If <var class="var">A</var> is a multi-dimensional matrix, each two-dimensional sub-matrix of <var class="var">A</var> is treated separately. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFifft2">ifft2</a>, <a class="ref" href="#XREFfft">fft</a>, <a class="ref" href="#XREFfftn">fftn</a>, <a class="ref" href="#XREFfftw">fftw</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ifft2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">ifft2</strong> <code class="def-code-arguments">(<var class="var">B</var>)</code><a class="copiable-link" href="#index-ifft2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ifft2-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">ifft2</strong> <code class="def-code-arguments">(<var class="var">B</var>, <var class="var">m</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-ifft2-1"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse two-dimensional discrete Fourier transform of <var class="var">B</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The optional arguments <var class="var">m</var> and <var class="var">n</var> may be used specify the number of rows and columns of <var class="var">B</var> to use. If either of these is larger than the size of <var class="var">B</var>, <var class="var">B</var> is resized and padded with zeros. </p> <p>If <var class="var">B</var> is a multi-dimensional matrix, each two-dimensional sub-matrix of <var class="var">B</var> is treated separately. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfft2">fft2</a>, <a class="ref" href="#XREFifft">ifft</a>, <a class="ref" href="#XREFifftn">ifftn</a>, <a class="ref" href="#XREFfftw">fftw</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fftn">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">fftn</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-fftn"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fftn-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">fftn</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">size</var>)</code><a class="copiable-link" href="#index-fftn-1"> ¶</a></span>
</dt> <dd>
<p>Compute the N-dimensional discrete Fourier transform of <var class="var">A</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The optional vector argument <var class="var">size</var> may be used specify the dimensions of the array to be used. If an element of <var class="var">size</var> is smaller than the corresponding dimension of <var class="var">A</var>, then the dimension of <var class="var">A</var> is truncated prior to performing the FFT. Otherwise, if an element of <var class="var">size</var> is larger than the corresponding dimension then <var class="var">A</var> is resized and padded with zeros. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFifftn">ifftn</a>, <a class="ref" href="#XREFfft">fft</a>, <a class="ref" href="#XREFfft2">fft2</a>, <a class="ref" href="#XREFfftw">fftw</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ifftn">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">ifftn</strong> <code class="def-code-arguments">(<var class="var">B</var>)</code><a class="copiable-link" href="#index-ifftn"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ifftn-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">ifftn</strong> <code class="def-code-arguments">(<var class="var">B</var>, <var class="var">size</var>)</code><a class="copiable-link" href="#index-ifftn-1"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse N-dimensional discrete Fourier transform of <var class="var">B</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The optional vector argument <var class="var">size</var> may be used specify the dimensions of the array to be used. If an element of <var class="var">size</var> is smaller than the corresponding dimension of <var class="var">B</var>, then the dimension of <var class="var">B</var> is truncated prior to performing the inverse FFT. Otherwise, if an element of <var class="var">size</var> is larger than the corresponding dimension then <var class="var">B</var> is resized and padded with zeros. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfftn">fftn</a>, <a class="ref" href="#XREFifft">ifft</a>, <a class="ref" href="#XREFifft2">ifft2</a>, <a class="ref" href="#XREFfftw">fftw</a>. </p>
</dd>
</dl> <p>Octave uses the <small class="sc">FFTW</small> libraries to perform FFT computations. When Octave starts up and initializes the <small class="sc">FFTW</small> libraries, they read a system wide file (on a Unix system, it is typically <samp class="file">/etc/fftw/wisdom</samp>) that contains information useful to speed up FFT computations. This information is called the <em class="emph">wisdom</em>. The system-wide file allows wisdom to be shared between all applications using the <small class="sc">FFTW</small> libraries. </p> <p>Use the <code class="code">fftw</code> function to generate and save wisdom. Using the utilities provided together with the <small class="sc">FFTW</small> libraries (<code class="command">fftw-wisdom</code> on Unix systems), you can even add wisdom generated by Octave to the system-wide wisdom file. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fftw">
<span class="category-def">: </span><span><code class="def-type"><var class="var">method</var> =</code> <strong class="def-name">fftw</strong> <code class="def-code-arguments">("planner")</code><a class="copiable-link" href="#index-fftw"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fftw-1">
<span class="category-def">: </span><span><strong class="def-name">fftw</strong> <code class="def-code-arguments">("planner", <var class="var">method</var>)</code><a class="copiable-link" href="#index-fftw-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fftw-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">wisdom</var> =</code> <strong class="def-name">fftw</strong> <code class="def-code-arguments">("dwisdom")</code><a class="copiable-link" href="#index-fftw-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fftw-3">
<span class="category-def">: </span><span><strong class="def-name">fftw</strong> <code class="def-code-arguments">("dwisdom", <var class="var">wisdom</var>)</code><a class="copiable-link" href="#index-fftw-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fftw-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">nthreads</var> =</code> <strong class="def-name">fftw</strong> <code class="def-code-arguments">("threads")</code><a class="copiable-link" href="#index-fftw-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fftw-5">
<span class="category-def">: </span><span><strong class="def-name">fftw</strong> <code class="def-code-arguments">("threads", <var class="var">nthreads</var>)</code><a class="copiable-link" href="#index-fftw-5"> ¶</a></span>
</dt> <dd> <p>Manage <small class="sc">FFTW</small> wisdom data. </p> <p>Wisdom data can be used to significantly accelerate the calculation of the FFTs, but implies an initial cost in its calculation. When the <small class="sc">FFTW</small> libraries are initialized, they read a system wide wisdom file (typically in <samp class="file">/etc/fftw/wisdom</samp>), allowing wisdom to be shared between applications other than Octave. Alternatively, the <code class="code">fftw</code> function can be used to import wisdom. For example, </p> <pre class="example" data-language="matlab">wisdom = fftw ("dwisdom")</pre> <p>will save the existing wisdom used by Octave to the string <var class="var">wisdom</var>. This string can then be saved to a file and restored using the <code class="code">save</code> and <code class="code">load</code> commands respectively. This existing wisdom can be re-imported as follows </p> <pre class="example" data-language="matlab">fftw ("dwisdom", wisdom)</pre> <p>If <var class="var">wisdom</var> is an empty string, then the wisdom used is cleared. </p> <p>During the calculation of Fourier transforms further wisdom is generated. The fashion in which this wisdom is generated is also controlled by the <code class="code">fftw</code> function. There are five different manners in which the wisdom can be treated: </p> <dl class="table"> <dt><code class="code">"estimate"</code></dt> <dd>
<p>Specifies that no run-time measurement of the optimal means of calculating a particular is performed, and a simple heuristic is used to pick a (probably sub-optimal) plan. The advantage of this method is that there is little or no overhead in the generation of the plan, which is appropriate for a Fourier transform that will be calculated once. </p> </dd> <dt><code class="code">"measure"</code></dt> <dd>
<p>In this case a range of algorithms to perform the transform is considered and the best is selected based on their execution time. </p> </dd> <dt><code class="code">"patient"</code></dt> <dd>
<p>Similar to <code class="code">"measure"</code>, but a wider range of algorithms is considered. </p> </dd> <dt><code class="code">"exhaustive"</code></dt> <dd>
<p>Like <code class="code">"measure"</code>, but all possible algorithms that may be used to treat the transform are considered. </p> </dd> <dt><code class="code">"hybrid"</code></dt> <dd><p>As run-time measurement of the algorithm can be expensive, this is a compromise where <code class="code">"measure"</code> is used for transforms up to the size of 8192 and beyond that the <code class="code">"estimate"</code> method is used. </p></dd> </dl> <p>The default method is <code class="code">"estimate"</code>. The current method can be queried with </p> <pre class="example" data-language="matlab">method = fftw ("planner")</pre> <p>or set by using </p> <pre class="example" data-language="matlab">fftw ("planner", method)</pre> <p>Note that calculated wisdom will be lost when restarting Octave. However, the wisdom data can be reloaded if it is saved to a file as described above. Saved wisdom files should not be used on different platforms since they will not be efficient and the point of calculating the wisdom is lost. </p> <p>The number of threads used for computing the plans and executing the transforms can be set with </p> <pre class="example" data-language="matlab">fftw ("threads", NTHREADS)</pre> <p>Note that Octave must be compiled with multi-threaded <small class="sc">FFTW</small> support for this feature. By default, the number of (logical) processors available to the current process or <var class="var">3</var> is used (whichever is smaller). </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfft">fft</a>, <a class="ref" href="#XREFifft">ifft</a>, <a class="ref" href="#XREFfft2">fft2</a>, <a class="ref" href="#XREFifft2">ifft2</a>, <a class="ref" href="#XREFfftn">fftn</a>, <a class="ref" href="#XREFifftn">ifftn</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fftconv">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">fftconv</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-fftconv"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fftconv-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">fftconv</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-fftconv-1"> ¶</a></span>
</dt> <dd>
<p>Convolve two vectors using the FFT for computation. </p> <p><code class="code">c = fftconv (<var class="var">x</var>, <var class="var">y</var>)</code> returns a vector of length equal to <code class="code">length (<var class="var">x</var>) + length (<var class="var">y</var>) - 1</code>. If <var class="var">x</var> and <var class="var">y</var> are the coefficient vectors of two polynomials, the returned value is the coefficient vector of the product polynomial. </p> <p>The computation uses the FFT by calling the function <code class="code">fftfilt</code>. If the optional argument <var class="var">n</var> is specified, an N-point FFT is used. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="products-of-polynomials.html#XREFdeconv">deconv</a>, <a class="ref" href="products-of-polynomials.html#XREFconv">conv</a>, <a class="ref" href="products-of-polynomials.html#XREFconv2">conv2</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fftfilt">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fftfilt</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-fftfilt"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fftfilt-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fftfilt</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">x</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-fftfilt-1"> ¶</a></span>
</dt> <dd>
<p>Filter <var class="var">x</var> with the FIR filter <var class="var">b</var> using the FFT. </p> <p>If <var class="var">x</var> is a matrix, filter each column of the matrix. </p> <p>Given the optional third argument, <var class="var">n</var>, <code class="code">fftfilt</code> uses the overlap-add method to filter <var class="var">x</var> with <var class="var">b</var> using an N-point FFT. The FFT size must be an even power of 2 and must be greater than or equal to the length of <var class="var">b</var>. If the specified <var class="var">n</var> does not meet these criteria, it is automatically adjusted to the nearest value that does. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfilter">filter</a>, <a class="ref" href="#XREFfilter2">filter2</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-filter">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">filter</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-filter"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-filter-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">y</var>, <var class="var">sf</var>] =</code> <strong class="def-name">filter</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">x</var>, <var class="var">si</var>)</code><a class="copiable-link" href="#index-filter-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-filter-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">y</var>, <var class="var">sf</var>] =</code> <strong class="def-name">filter</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">x</var>, [], <var class="var">dim</var>)</code><a class="copiable-link" href="#index-filter-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-filter-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">y</var>, <var class="var">sf</var>] =</code> <strong class="def-name">filter</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">x</var>, <var class="var">si</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-filter-3"> ¶</a></span>
</dt> <dd>
<p>Apply a 1-D digital filter to the data <var class="var">x</var>. </p> <p><code class="code">filter</code> returns the solution to the following linear, time-invariant difference equation: </p> <pre class="example smallexample" data-language="matlab">N                   M
SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)    for 1&lt;=n&lt;=length(x)
k=0                 k=0</pre> <p>where N=length(a)-1 and M=length(b)-1. The result is calculated over the first non-singleton dimension of <var class="var">x</var> or over <var class="var">dim</var> if supplied. </p> <p>An equivalent form of the equation is: </p> <pre class="example smallexample" data-language="matlab">N                   M
y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1&lt;=n&lt;=length(x)
         k=1                 k=0</pre> <p>where c = a/a(1) and d = b/a(1). </p> <p>If the fourth argument <var class="var">si</var> is provided, it is taken as the initial state of the system and the final state is returned as <var class="var">sf</var>. The state vector is a column vector whose length is equal to the length of the longest coefficient vector minus one. If <var class="var">si</var> is not supplied, the initial state vector is set to all zeros. </p> <p>In terms of the Z Transform, <var class="var">y</var> is the result of passing the discrete-time signal <var class="var">x</var> through a system characterized by the following rational system function: </p> <pre class="example" data-language="matlab">M
         SUM d(k+1) z^(-k)
         k=0
H(z) = ---------------------
            N
       1 + SUM c(k+1) z^(-k)
           k=1</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfilter2">filter2</a>, <a class="ref" href="#XREFfftfilt">fftfilt</a>, <a class="ref" href="#XREFfreqz">freqz</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-filter2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">filter2</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-filter2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-filter2-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">filter2</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">x</var>, <var class="var">shape</var>)</code><a class="copiable-link" href="#index-filter2-1"> ¶</a></span>
</dt> <dd>
<p>Apply the 2-D FIR filter <var class="var">b</var> to <var class="var">x</var>. </p> <p>If the argument <var class="var">shape</var> is specified, return an array of the desired shape. Possible values are: </p> <dl class="table"> <dt><code class="code">"full"</code></dt> <dd>
<p>pad <var class="var">x</var> with zeros on all sides before filtering. </p> </dd> <dt><code class="code">"same"</code></dt> <dd>
<p>unpadded <var class="var">x</var> (default) </p> </dd> <dt><code class="code">"valid"</code></dt> <dd><p>trim <var class="var">x</var> after filtering so edge effects are no included. </p></dd> </dl> <p>Note this is just a variation on convolution, with the parameters reversed and <var class="var">b</var> rotated 180 degrees. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="products-of-polynomials.html#XREFconv2">conv2</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-freqz">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">h</var>, <var class="var">w</var>] =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">n</var>, "whole")</code><a class="copiable-link" href="#index-freqz"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">h</var>, <var class="var">w</var>] =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(<var class="var">b</var>)</code><a class="copiable-link" href="#index-freqz-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">h</var>, <var class="var">w</var>] =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>)</code><a class="copiable-link" href="#index-freqz-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">h</var>, <var class="var">w</var>] =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-freqz-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">w</var>)</code><a class="copiable-link" href="#index-freqz-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-5">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">h</var>, <var class="var">w</var>] =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(…, <var class="var">Fs</var>)</code><a class="copiable-link" href="#index-freqz-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-6">
<span class="category-def">: </span><span><strong class="def-name">freqz</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-freqz-6"> ¶</a></span>
</dt> <dd> <p>Return the complex frequency response <var class="var">h</var> of the rational IIR filter whose numerator and denominator coefficients are <var class="var">b</var> and <var class="var">a</var>, respectively. </p> <p>The response is evaluated at <var class="var">n</var> angular frequencies between 0 and 2*pi. </p> <p>The output value <var class="var">w</var> is a vector of the frequencies. </p> <p>If <var class="var">a</var> is omitted, the denominator is assumed to be 1 (this corresponds to a simple FIR filter). </p> <p>If <var class="var">n</var> is omitted, a value of 512 is assumed. For fastest computation, <var class="var">n</var> should factor into a small number of small primes. </p> <p>If the fourth argument, <code class="code">"whole"</code>, is omitted the response is evaluated at frequencies between 0 and pi. </p> <p><code class="code">freqz (<var class="var">b</var>, <var class="var">a</var>, <var class="var">w</var>)</code> </p> <p>Evaluate the response at the specific frequencies in the vector <var class="var">w</var>. The values for <var class="var">w</var> are measured in radians. </p> <p><code class="code">[…] = freqz (…, <var class="var">Fs</var>)</code> </p> <p>Return frequencies in Hz instead of radians assuming a sampling rate <var class="var">Fs</var>. If you are evaluating the response at specific frequencies <var class="var">w</var>, those frequencies should be requested in Hz rather than radians. </p> <p><code class="code">freqz (…)</code> </p> <p>Plot the magnitude and phase response of <var class="var">h</var> rather than returning them. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfreqz_005fplot">freqz_plot</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-freqz_005fplot">
<span class="category-def">: </span><span><strong class="def-name">freqz_plot</strong> <code class="def-code-arguments">(<var class="var">w</var>, <var class="var">h</var>)</code><a class="copiable-link" href="#index-freqz_005fplot"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-freqz_005fplot-1">
<span class="category-def">: </span><span><strong class="def-name">freqz_plot</strong> <code class="def-code-arguments">(<var class="var">w</var>, <var class="var">h</var>, <var class="var">freq_norm</var>)</code><a class="copiable-link" href="#index-freqz_005fplot-1"> ¶</a></span>
</dt> <dd>
<p>Plot the magnitude and phase response of <var class="var">h</var>. </p> <p>If the optional <var class="var">freq_norm</var> argument is true, the frequency vector <var class="var">w</var> is in units of normalized radians. If <var class="var">freq_norm</var> is false, or not given, then <var class="var">w</var> is measured in Hertz. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfreqz">freqz</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sinc">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">sinc</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-sinc"> ¶</a></span>
</dt> <dd>
<p>Compute the sinc function. </p> <p>Return sin (pi*x) / (pi*x). </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-unwrap">
<span class="category-def">: </span><span><code class="def-type"><var class="var">b</var> =</code> <strong class="def-name">unwrap</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-unwrap"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-unwrap-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">b</var> =</code> <strong class="def-name">unwrap</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-unwrap-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-unwrap-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">b</var> =</code> <strong class="def-name">unwrap</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">tol</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-unwrap-2"> ¶</a></span>
</dt> <dd>
<p>Unwrap radian phases by adding or subtracting multiples of 2*pi as appropriate to remove jumps greater than <var class="var">tol</var>. </p> <p><var class="var">tol</var> defaults to pi. </p> <p><code class="code">unwrap</code> will work along the dimension <var class="var">dim</var>. If <var class="var">dim</var> is unspecified it defaults to the first non-singleton dimension. </p> <p><code class="code">unwrap</code> ignores all non-finite input values (Inf, NaN, NA). </p> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-arch_005ffit">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">a</var>, <var class="var">b</var>] =</code> <strong class="def-name">arch_fit</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">x</var>, <var class="var">p</var>, <var class="var">iter</var>, <var class="var">gamma</var>, <var class="var">a0</var>, <var class="var">b0</var>)</code><a class="copiable-link" href="#index-arch_005ffit"> ¶</a></span>
</dt> <dd>
<p>Fit an ARCH regression model to the time series <var class="var">y</var> using the scoring algorithm in Engle’s original ARCH paper. </p> <p>The model is </p> <pre class="example" data-language="matlab">y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(p+1) * e(t-p)^2</pre> <p>in which <em class="math">e(t)</em> is <em class="math">N(0, h(t))</em>, given a time-series vector <var class="var">y</var> up to time <em class="math">t-1</em> and a matrix of (ordinary) regressors <var class="var">x</var> up to <em class="math">t</em>. The order of the regression of the residual variance is specified by <var class="var">p</var>. </p> <p>If invoked as <code class="code">arch_fit (<var class="var">y</var>, <var class="var">k</var>, <var class="var">p</var>)</code> with a positive integer <var class="var">k</var>, fit an ARCH(<var class="var">k</var>, <var class="var">p</var>) process, i.e., do the above with the <em class="math">t</em>-th row of <var class="var">x</var> given by </p> <pre class="example" data-language="matlab">[1, y(t-1), ..., y(t-k)]</pre> <p>Optionally, one can specify the number of iterations <var class="var">iter</var>, the updating factor <var class="var">gamma</var>, and initial values <em class="math">a0</em> and <em class="math">b0</em> for the scoring algorithm. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-arch_005frnd">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">arch_rnd</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>, <var class="var">t</var>)</code><a class="copiable-link" href="#index-arch_005frnd"> ¶</a></span>
</dt> <dd>
<p>Simulate an ARCH sequence of length <var class="var">t</var> with AR coefficients <var class="var">b</var> and CH coefficients <var class="var">a</var>. </p> <p>The result <em class="math">y(t)</em> follows the model </p> <pre class="example smallexample" data-language="matlab">y(t) = b(1) + b(2) * y(t-1) + ... + b(lb) * y(t-lb+1) + e(t),</pre> <p>where <em class="math">e(t)</em>, given <var class="var">y</var> up to time <em class="math">t-1</em>, is <em class="math">N(0, h(t))</em>, with </p> <pre class="example smallexample" data-language="matlab">h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(la) * e(t-la+1)^2</pre> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-arch_005ftest">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">pval</var>, <var class="var">lm</var>] =</code> <strong class="def-name">arch_test</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">x</var>, <var class="var">p</var>)</code><a class="copiable-link" href="#index-arch_005ftest"> ¶</a></span>
</dt> <dd>
<p>For a linear regression model </p> <pre class="example" data-language="matlab">y = x * b + e</pre> <p>perform a Lagrange Multiplier (LM) test of the null hypothesis of no conditional heteroscedascity against the alternative of CH(<var class="var">p</var>). </p> <p>I.e., the model is </p> <pre class="example" data-language="matlab">y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),</pre> <p>given <var class="var">y</var> up to <em class="math">t-1</em> and <var class="var">x</var> up to <em class="math">t</em>, <em class="math">e</em>(t) is <em class="math">N(0, h(t))</em> with </p> <pre class="example" data-language="matlab">h(t) = v + a(1) * e(t-1)^2 + ... + a(p) * e(t-p)^2,</pre> <p>and the null is <em class="math">a(1)</em> == … == <em class="math">a(p)</em> == 0. </p> <p>If the second argument is a scalar integer, <em class="math">k</em>, perform the same test in a linear autoregression model of order <em class="math">k</em>, i.e., with </p> <pre class="example" data-language="matlab">[1, y(t-1), ..., y(t-k)]</pre> <p>as the <em class="math">t</em>-th row of <var class="var">x</var>. </p> <p>Under the null, LM approximately has a chisquare distribution with <var class="var">p</var> degrees of freedom and <var class="var">pval</var> is the <em class="math">p</em>-value (1 minus the CDF of this distribution at LM) of the test. </p> <p>If no output argument is given, the <em class="math">p</em>-value is displayed. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-arma_005frnd">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">arma_rnd</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>, <var class="var">v</var>, <var class="var">t</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-arma_005frnd"> ¶</a></span>
</dt> <dd>
<p>Return a simulation of the ARMA model. </p> <p>The ARMA model is defined by </p> <pre class="example" data-language="matlab">x(n) = a(1) * x(n-1) + ... + a(k) * x(n-k)
     + e(n) + b(1) * e(n-1) + ... + b(l) * e(n-l)</pre> <p>in which <var class="var">k</var> is the length of vector <var class="var">a</var>, <var class="var">l</var> is the length of vector <var class="var">b</var> and <var class="var">e</var> is Gaussian white noise with variance <var class="var">v</var>. The function returns a vector of length <var class="var">t</var>. </p> <p>The optional parameter <var class="var">n</var> gives the number of dummy <var class="var">x</var>(<var class="var">i</var>) used for initialization, i.e., a sequence of length <var class="var">t</var>+<var class="var">n</var> is generated and <var class="var">x</var>(<var class="var">n</var>+1:<var class="var">t</var>+<var class="var">n</var>) is returned. If <var class="var">n</var> is omitted, <var class="var">n</var> = 100 is used. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-autoreg_005fmatrix">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">autoreg_matrix</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-autoreg_005fmatrix"> ¶</a></span>
</dt> <dd>
<p>Given a time series (vector) <var class="var">y</var>, return a matrix with ones in the first column and the first <var class="var">k</var> lagged values of <var class="var">y</var> in the other columns. </p> <p>In other words, for <var class="var">t</var> &gt; <var class="var">k</var>, <code class="code">[1, <var class="var">y</var>(<var class="var">t</var>-1), …, <var class="var">y</var>(<var class="var">t</var>-<var class="var">k</var>)]</code> is the t-th row of the result. </p> <p>The resulting matrix may be used as a regressor matrix in autoregressions. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-bartlett">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">bartlett</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-bartlett"> ¶</a></span>
</dt> <dd>
<p>Return the filter coefficients of a Bartlett (triangular) window of length <var class="var">m</var>. </p> <p>For a definition of the Bartlett window see, e.g., A.V. Oppenheim &amp; R. W. Schafer, <cite class="cite">Discrete-Time Signal Processing</cite>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-blackman">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">blackman</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-blackman"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-blackman-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">blackman</strong> <code class="def-code-arguments">(<var class="var">m</var>, "periodic")</code><a class="copiable-link" href="#index-blackman-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-blackman-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">blackman</strong> <code class="def-code-arguments">(<var class="var">m</var>, "symmetric")</code><a class="copiable-link" href="#index-blackman-2"> ¶</a></span>
</dt> <dd>
<p>Return the filter coefficients of a Blackman window of length <var class="var">m</var>. </p> <p>If the optional argument <code class="code">"periodic"</code> is given, the periodic form of the window is returned. This is equivalent to the window of length <var class="var">m</var>+1 with the last coefficient removed. The optional argument <code class="code">"symmetric"</code> is equivalent to not specifying a second argument. </p> <p>For a definition of the Blackman window, see, e.g., A.V. Oppenheim &amp; R. W. Schafer, <cite class="cite">Discrete-Time Signal Processing</cite>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-detrend">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">detrend</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>)</code><a class="copiable-link" href="#index-detrend"> ¶</a></span>
</dt> <dd>
<p>If <var class="var">x</var> is a vector, <code class="code">detrend (<var class="var">x</var>, <var class="var">p</var>)</code> removes the best fit of a polynomial of order <var class="var">p</var> from the data <var class="var">x</var>. </p> <p>If <var class="var">x</var> is a matrix, <code class="code">detrend (<var class="var">x</var>, <var class="var">p</var>)</code> does the same for each column in <var class="var">x</var>. </p> <p>The second argument <var class="var">p</var> is optional. If it is not specified, a value of 1 is assumed. This corresponds to removing a linear trend. </p> <p>The order of the polynomial can also be given as a string, in which case <var class="var">p</var> must be either <code class="code">"constant"</code> (corresponds to <code class="code"><var class="var">p</var>=0</code>) or <code class="code">"linear"</code> (corresponds to <code class="code"><var class="var">p</var>=1</code>). </p> <p><strong class="strong">See also:</strong> <a class="ref" href="polynomial-interpolation.html#XREFpolyfit">polyfit</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-diffpara">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">d</var>, <var class="var">dd</var>] =</code> <strong class="def-name">diffpara</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-diffpara"> ¶</a></span>
</dt> <dd>
<p>Return the estimator <var class="var">d</var> for the differencing parameter of an integrated time series. </p> <p>The frequencies from <em class="math">[2*pi*a/t, 2*pi*b/T]</em> are used for the estimation. If <var class="var">b</var> is omitted, the interval <em class="math">[2*pi/T, 2*pi*a/T]</em> is used. If both <var class="var">b</var> and <var class="var">a</var> are omitted then <em class="math">a = 0.5 * sqrt (T)</em> and <em class="math">b = 1.5 * sqrt (T)</em> is used, where <em class="math">T</em> is the sample size. If <var class="var">x</var> is a matrix, the differencing parameter of each column is estimated. </p> <p>The estimators for all frequencies in the intervals described above is returned in <var class="var">dd</var>. </p> <p>The value of <var class="var">d</var> is simply the mean of <var class="var">dd</var>. </p> <p>Reference: P.J. Brockwell &amp; R.A. Davis. <cite class="cite">Time Series: Theory and Methods</cite>. Springer 1987. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-durbinlevinson">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">newphi</var>, <var class="var">newv</var>] =</code> <strong class="def-name">durbinlevinson</strong> <code class="def-code-arguments">(<var class="var">c</var>, <var class="var">oldphi</var>, <var class="var">oldv</var>)</code><a class="copiable-link" href="#index-durbinlevinson"> ¶</a></span>
</dt> <dd>
<p>Perform one step of the Durbin-Levinson algorithm. </p> <p>The vector <var class="var">c</var> specifies the autocovariances <code class="code">[gamma_0, …, gamma_t]</code> from lag 0 to <var class="var">t</var>, <var class="var">oldphi</var> specifies the coefficients based on <var class="var">c</var>(<var class="var">t</var>-1) and <var class="var">oldv</var> specifies the corresponding error. </p> <p>If <var class="var">oldphi</var> and <var class="var">oldv</var> are omitted, all steps from 1 to <var class="var">t</var> of the algorithm are performed. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fftshift">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fftshift</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-fftshift"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-fftshift-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fftshift</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-fftshift-1"> ¶</a></span>
</dt> <dd>
<p>Perform a shift of the vector <var class="var">x</var>, for use with the <code class="code">fft</code> and <code class="code">ifft</code> functions, in order to move the frequency 0 to the center of the vector or matrix. </p> <p>If <var class="var">x</var> is a vector of <em class="math">N</em> elements corresponding to <em class="math">N</em> time samples spaced by <em class="math">dt</em>, then <code class="code">fftshift (fft (<var class="var">x</var>))</code> corresponds to frequencies </p> <pre class="example" data-language="matlab">f = [ -(ceil((N-1)/2):-1:1), 0, (1:floor((N-1)/2)) ] * df</pre> <p>where <em class="math">df = 1 / (N * dt)</em>. </p> <p>If <var class="var">x</var> is a matrix, the same holds for rows and columns. If <var class="var">x</var> is an array, then the same holds along each dimension. </p> <p>The optional <var class="var">dim</var> argument can be used to limit the dimension along which the permutation occurs. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFifftshift">ifftshift</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ifftshift">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">ifftshift</strong> <code class="def-code-arguments">(<var class="var">y</var>)</code><a class="copiable-link" href="#index-ifftshift"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ifftshift-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">ifftshift</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-ifftshift-1"> ¶</a></span>
</dt> <dd>
<p>Undo the action of the <code class="code">fftshift</code> function. </p> <p>For even length <var class="var">x</var>, <code class="code">fftshift</code> is its own inverse, but odd lengths differ slightly. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfftshift">fftshift</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fractdiff">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fd</var> =</code> <strong class="def-name">fractdiff</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">d</var>)</code><a class="copiable-link" href="#index-fractdiff"> ¶</a></span>
</dt> <dd><p>Compute the fractional differences <em class="math">(1-L)^d x</em> where <em class="math">L</em> denotes the lag-operator and <em class="math">d</em> is greater than -1. </p></dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-hamming">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hamming</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-hamming"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-hamming-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hamming</strong> <code class="def-code-arguments">(<var class="var">m</var>, "periodic")</code><a class="copiable-link" href="#index-hamming-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-hamming-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hamming</strong> <code class="def-code-arguments">(<var class="var">m</var>, "symmetric")</code><a class="copiable-link" href="#index-hamming-2"> ¶</a></span>
</dt> <dd>
<p>Return the filter coefficients of a Hamming window of length <var class="var">m</var>. </p> <p>If the optional argument <code class="code">"periodic"</code> is given, the periodic form of the window is returned. This is equivalent to the window of length <var class="var">m</var>+1 with the last coefficient removed. The optional argument <code class="code">"symmetric"</code> is equivalent to not specifying a second argument. </p> <p>For a definition of the Hamming window see, e.g., A.V. Oppenheim &amp; R. W. Schafer, <cite class="cite">Discrete-Time Signal Processing</cite>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-hanning">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hanning</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-hanning"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-hanning-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hanning</strong> <code class="def-code-arguments">(<var class="var">m</var>, "periodic")</code><a class="copiable-link" href="#index-hanning-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-hanning-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hanning</strong> <code class="def-code-arguments">(<var class="var">m</var>, "symmetric")</code><a class="copiable-link" href="#index-hanning-2"> ¶</a></span>
</dt> <dd>
<p>Return the filter coefficients of a Hanning window of length <var class="var">m</var>. </p> <p>If the optional argument <code class="code">"periodic"</code> is given, the periodic form of the window is returned. This is equivalent to the window of length <var class="var">m</var>+1 with the last coefficient removed. The optional argument <code class="code">"symmetric"</code> is equivalent to not specifying a second argument. </p> <p>For a definition of the Hanning window see, e.g., A.V. Oppenheim &amp; R. W. Schafer, <cite class="cite">Discrete-Time Signal Processing</cite>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-hurst">
<span class="category-def">: </span><span><code class="def-type"><var class="var">H</var> =</code> <strong class="def-name">hurst</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-hurst"> ¶</a></span>
</dt> <dd>
<p>Estimate the Hurst parameter of sample <var class="var">x</var> via the rescaled range statistic. </p> <p>If <var class="var">x</var> is a matrix, the parameter is estimated for every column. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-pchip">
<span class="category-def">: </span><span><code class="def-type"><var class="var">pp</var> =</code> <strong class="def-name">pchip</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-pchip"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-pchip-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">pchip</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">xi</var>)</code><a class="copiable-link" href="#index-pchip-1"> ¶</a></span>
</dt> <dd>
<p>Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip) of points <var class="var">x</var> and <var class="var">y</var>. </p> <p>If called with two arguments, return the piecewise polynomial <var class="var">pp</var> that may be used with <code class="code">ppval</code> to evaluate the polynomial at specific points. </p> <p>When called with a third input argument, <code class="code">pchip</code> evaluates the pchip polynomial at the points <var class="var">xi</var>. The third calling form is equivalent to <code class="code">ppval (pchip (<var class="var">x</var>, <var class="var">y</var>), <var class="var">xi</var>)</code>. </p> <p>The variable <var class="var">x</var> must be a strictly monotonic vector (either increasing or decreasing) of length <var class="var">n</var>. </p> <p><var class="var">y</var> can be either a vector or array. If <var class="var">y</var> is a vector then it must be the same length <var class="var">n</var> as <var class="var">x</var>. If <var class="var">y</var> is an array then the size of <var class="var">y</var> must have the form <code class="code">[<var class="var">s1</var>, <var class="var">s2</var>, …, <var class="var">sk</var>, <var class="var">n</var>]</code> The array is reshaped internally to a matrix where the leading dimension is given by <code class="code"><var class="var">s1</var> * <var class="var">s2</var> * … * <var class="var">sk</var></code> and each row of this matrix is then treated separately. Note that this is exactly opposite to <code class="code">interp1</code> but is done for <small class="sc">MATLAB</small> compatibility. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="one_002ddimensional-interpolation.html#XREFspline">spline</a>, <a class="ref" href="polynomial-interpolation.html#XREFppval">ppval</a>, <a class="ref" href="polynomial-interpolation.html#XREFmkpp">mkpp</a>, <a class="ref" href="polynomial-interpolation.html#XREFunmkpp">unmkpp</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-periodogram">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Pxx</var>, <var class="var">w</var>] =</code> <strong class="def-name">periodogram</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-periodogram"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-periodogram-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Pxx</var>, <var class="var">w</var>] =</code> <strong class="def-name">periodogram</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win</var>)</code><a class="copiable-link" href="#index-periodogram-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-periodogram-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Pxx</var>, <var class="var">w</var>] =</code> <strong class="def-name">periodogram</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win</var>, <var class="var">nfft</var>)</code><a class="copiable-link" href="#index-periodogram-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-periodogram-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Pxx</var>, <var class="var">f</var>] =</code> <strong class="def-name">periodogram</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win</var>, <var class="var">nfft</var>, <var class="var">Fs</var>)</code><a class="copiable-link" href="#index-periodogram-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-periodogram-4">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Pxx</var>, <var class="var">f</var>] =</code> <strong class="def-name">periodogram</strong> <code class="def-code-arguments">(…, "<var class="var">range</var>")</code><a class="copiable-link" href="#index-periodogram-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-periodogram-5">
<span class="category-def">: </span><span><strong class="def-name">periodogram</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-periodogram-5"> ¶</a></span>
</dt> <dd>
<p>Return the periodogram (Power Spectral Density) of <var class="var">x</var>. </p> <p>The possible inputs are: </p> <dl class="table"> <dt><var class="var">x</var></dt> <dd> <p>data vector. If <var class="var">x</var> is real-valued a one-sided spectrum is estimated. If <var class="var">x</var> is complex-valued, or <code class="code">"<var class="var">range</var>"</code> specifies <code class="code">"twosided"</code>, the full spectrum is estimated. </p> </dd> <dt><var class="var">win</var></dt> <dd>
<p>window weight data. If window is empty or unspecified a default rectangular window is used. Otherwise, the window is applied to the signal (<code class="code"><var class="var">x</var> .* <var class="var">win</var></code>) before computing the periodogram. The window data must be a vector of the same length as <var class="var">x</var>. </p> </dd> <dt><var class="var">nfft</var></dt> <dd>
<p>number of frequency bins. The default is 256 or the next higher power of 2 greater than the length of <var class="var">x</var> (<code class="code">max (256, 2.^nextpow2 (length (x)))</code>). If <var class="var">nfft</var> is greater than the length of the input then <var class="var">x</var> will be zero-padded to the length of <var class="var">nfft</var>. </p> </dd> <dt><var class="var">Fs</var></dt> <dd>
<p>sampling rate. The default is 1. </p> </dd> <dt><var class="var">range</var></dt> <dd><p>range of spectrum. <code class="code">"onesided"</code> computes spectrum from [0:nfft/2+1]. <code class="code">"twosided"</code> computes spectrum from [0:nfft-1]. </p></dd> </dl> <p>The optional second output <var class="var">w</var> are the normalized angular frequencies. For a one-sided calculation <var class="var">w</var> is in the range [0, pi] if <var class="var">nfft</var> is even and [0, pi) if <var class="var">nfft</var> is odd. Similarly, for a two-sided calculation <var class="var">w</var> is in the range [0, 2*pi] or [0, 2*pi) depending on <var class="var">nfft</var>. </p> <p>If a sampling frequency is specified, <var class="var">Fs</var>, then the output frequencies <var class="var">f</var> will be in the range [0, <var class="var">Fs</var>/2] or [0, <var class="var">Fs</var>/2) for one-sided calculations. For two-sided calculations the range will be [0, <var class="var">Fs</var>). </p> <p>When called with no outputs the periodogram is immediately plotted in the current figure window. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfft">fft</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sinetone">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">sinetone</strong> <code class="def-code-arguments">(<var class="var">freq</var>, <var class="var">rate</var>, <var class="var">sec</var>, <var class="var">ampl</var>)</code><a class="copiable-link" href="#index-sinetone"> ¶</a></span>
</dt> <dd>
<p>Return a sinetone of frequency <var class="var">freq</var> with a length of <var class="var">sec</var> seconds at sampling rate <var class="var">rate</var> and with amplitude <var class="var">ampl</var>. </p> <p>The arguments <var class="var">freq</var> and <var class="var">ampl</var> may be vectors of common size. </p> <p>The defaults are <var class="var">rate</var> = 8000, <var class="var">sec</var> = 1, and <var class="var">ampl</var> = 64. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsinewave">sinewave</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sinewave">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">sinewave</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">n</var>, <var class="var">d</var>)</code><a class="copiable-link" href="#index-sinewave"> ¶</a></span>
</dt> <dd>
<p>Return an <var class="var">m</var>-element vector with <var class="var">i</var>-th element given by <code class="code">sin (2 * pi * (<var class="var">i</var>+<var class="var">d</var>-1) / <var class="var">n</var>)</code>. </p> <p>The default value for <var class="var">d</var> is 0 and the default value for <var class="var">n</var> is <var class="var">m</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsinetone">sinetone</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-spectral_005fadf">
<span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_adf</strong> <code class="def-code-arguments">(<var class="var">c</var>)</code><a class="copiable-link" href="#index-spectral_005fadf"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-spectral_005fadf-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_adf</strong> <code class="def-code-arguments">(<var class="var">c</var>, <var class="var">win</var>)</code><a class="copiable-link" href="#index-spectral_005fadf-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-spectral_005fadf-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_adf</strong> <code class="def-code-arguments">(<var class="var">c</var>, <var class="var">win</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-spectral_005fadf-2"> ¶</a></span>
</dt> <dd>
<p>Return the spectral density estimator given a vector of autocovariances <var class="var">c</var>, window name <var class="var">win</var>, and bandwidth, <var class="var">b</var>. </p> <p>The window name, e.g., <code class="code">"triangle"</code> or <code class="code">"rectangle"</code> is used to search for a function called <code class="code"><var class="var">win</var>_lw</code>. </p> <p>If <var class="var">win</var> is omitted, the triangle window is used. </p> <p>If <var class="var">b</var> is omitted, <code class="code">1 / sqrt (length (<var class="var">x</var>))</code> is used. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFspectral_005fxdf">spectral_xdf</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-spectral_005fxdf">
<span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_xdf</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-spectral_005fxdf"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-spectral_005fxdf-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_xdf</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win</var>)</code><a class="copiable-link" href="#index-spectral_005fxdf-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-spectral_005fxdf-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_xdf</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-spectral_005fxdf-2"> ¶</a></span>
</dt> <dd>
<p>Return the spectral density estimator given a data vector <var class="var">x</var>, window name <var class="var">win</var>, and bandwidth, <var class="var">b</var>. </p> <p>The window name, e.g., <code class="code">"triangle"</code> or <code class="code">"rectangle"</code> is used to search for a function called <code class="code"><var class="var">win</var>_sw</code>. </p> <p>If <var class="var">win</var> is omitted, the triangle window is used. </p> <p>If <var class="var">b</var> is omitted, <code class="code">1 / sqrt (length (<var class="var">x</var>))</code> is used. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFspectral_005fadf">spectral_adf</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-spencer">
<span class="category-def">: </span><span><code class="def-type"><var class="var">savg</var> =</code> <strong class="def-name">spencer</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-spencer"> ¶</a></span>
</dt> <dd><p>Return Spencer’s 15-point moving average of each column of <var class="var">x</var>. </p></dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-stft">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-stft"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-stft-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win_size</var>)</code><a class="copiable-link" href="#index-stft-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-stft-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win_size</var>, <var class="var">inc</var>)</code><a class="copiable-link" href="#index-stft-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-stft-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win_size</var>, <var class="var">inc</var>, <var class="var">num_coef</var>)</code><a class="copiable-link" href="#index-stft-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-stft-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win_size</var>, <var class="var">inc</var>, <var class="var">num_coef</var>, <var class="var">win_type</var>)</code><a class="copiable-link" href="#index-stft-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-stft-5">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">y</var>, <var class="var">c</var>] =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-stft-5"> ¶</a></span>
</dt> <dd>
<p>Compute the short-time Fourier transform of the vector <var class="var">x</var> with <var class="var">num_coef</var> coefficients by applying a window of <var class="var">win_size</var> data points and an increment of <var class="var">inc</var> points. </p> <p>Before computing the Fourier transform, one of the following windows is applied: </p> <dl class="table"> <dt><code class="code">"hanning"</code></dt> <dd>
<p>win_type = 1 </p> </dd> <dt><code class="code">"hamming"</code></dt> <dd>
<p>win_type = 2 </p> </dd> <dt><code class="code">"rectangle"</code></dt> <dd><p>win_type = 3 </p></dd> </dl> <p>The window names can be passed as strings or by the <var class="var">win_type</var> number. </p> <p>The following defaults are used for unspecified arguments: <var class="var">win_size</var> = 80, <var class="var">inc</var> = 24, <var class="var">num_coef</var> = 64, and <var class="var">win_type</var> = 1. </p> <p><code class="code"><var class="var">y</var> = stft (<var class="var">x</var>, …)</code> returns the absolute values of the Fourier coefficients according to the <var class="var">num_coef</var> positive frequencies. </p> <p><code class="code">[<var class="var">y</var>, <var class="var">c</var>] = stft (<var class="var">x</var>, …)</code> returns the entire STFT-matrix <var class="var">y</var> and a 3-element vector <var class="var">c</var> containing the window size, increment, and window type, which is needed by the <code class="code">synthesis</code> function. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsynthesis">synthesis</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-synthesis">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">synthesis</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">c</var>)</code><a class="copiable-link" href="#index-synthesis"> ¶</a></span>
</dt> <dd>
<p>Compute a signal from its short-time Fourier transform <var class="var">y</var> and a 3-element vector <var class="var">c</var> specifying window size, increment, and window type. </p> <p>The values <var class="var">y</var> and <var class="var">c</var> can be derived by </p> <pre class="example" data-language="matlab">[y, c] = stft (x , ...)</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstft">stft</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-yulewalker">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">a</var>, <var class="var">v</var>] =</code> <strong class="def-name">yulewalker</strong> <code class="def-code-arguments">(<var class="var">c</var>)</code><a class="copiable-link" href="#index-yulewalker"> ¶</a></span>
</dt> <dd>
<p>Fit an AR (p)-model with Yule-Walker estimates given a vector <var class="var">c</var> of autocovariances <code class="code">[gamma_0, …, gamma_p]</code>. </p> <p>Returns the AR coefficients, <var class="var">a</var>, and the variance of white noise, <var class="var">v</var>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="image-processing.html">Image Processing</a>, Previous: <a href="geometry.html">Geometry</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Signal-Processing.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Signal-Processing.html</a>
  </p>
</div>
