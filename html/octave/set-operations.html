<div class="section-level-extent" id="Set-Operations"> <div class="nav-panel"> <p> Up: <a href="sets.html" accesskey="u" rel="up">Sets</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Set-Operations-1"><span>27.1 Set Operations<a class="copiable-link" href="#Set-Operations-1"> ¶</a></span></h1> <p>Octave supports several basic set operations. Octave can compute the union, intersection, and difference of two sets. Octave also supports the <em class="emph">Exclusive Or</em> set operation. </p> <p>The functions for set operations all work in the same way by accepting two input sets and returning a third set. As an example, assume that <code class="code">a</code> and <code class="code">b</code> contains two sets, then </p> <pre class="example" data-language="matlab">union (a, b)</pre> <p>computes the union of the two sets. </p> <p>Finally, determining whether elements belong to a set can be done with the <code class="code">ismember</code> function. Because sets are ordered this operation is very efficient and is of order O(log2(n)) which is preferable to the <code class="code">find</code> function which is of order O(n). </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-intersect">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">intersect</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-intersect"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-intersect-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">intersect</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>, "rows")</code><a class="copiable-link" href="#index-intersect-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-intersect-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">intersect</strong> <code class="def-code-arguments">(…, "sorted")</code><a class="copiable-link" href="#index-intersect-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-intersect-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">intersect</strong> <code class="def-code-arguments">(…, "stable")</code><a class="copiable-link" href="#index-intersect-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-intersect-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">intersect</strong> <code class="def-code-arguments">(…, "legacy")</code><a class="copiable-link" href="#index-intersect-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-intersect-5">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">c</var>, <var class="var">ia</var>, <var class="var">ib</var>] =</code> <strong class="def-name">intersect</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-intersect-5"> ¶</a></span>
</dt> <dd> <p>Return the unique elements common to both <var class="var">a</var> and <var class="var">b</var>. </p> <p>If <var class="var">a</var> and <var class="var">b</var> are both row vectors then return a row vector; Otherwise, return a column vector. The inputs may also be cell arrays of strings. </p> <p>If the optional input <code class="code">"rows"</code> is given then return the common rows of <var class="var">a</var> and <var class="var">b</var>. The inputs must be 2-D numeric matrices to use this option. </p> <p>The optional argument <code class="code">"sorted"</code>/<code class="code">"stable"</code> controls the order in which unique values appear in the output. The default is <code class="code">"sorted"</code> and values in the output are placed in ascending order. The alternative <code class="code">"stable"</code> preserves the order found in the input. </p> <p>If requested, return column index vectors <var class="var">ia</var> and <var class="var">ib</var> such that <code class="code"><var class="var">c</var> = <var class="var">a</var>(<var class="var">ia</var>)</code> and <code class="code"><var class="var">c</var> = <var class="var">b</var>(<var class="var">ib</var>)</code>. </p> <p>Programming Note: The input flag <code class="code">"legacy"</code> changes the algorithm to be compatible with <small class="sc">MATLAB</small> releases prior to R2012b. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="sets.html#XREFunique">unique</a>, <a class="ref" href="#XREFunion">union</a>, <a class="ref" href="#XREFsetdiff">setdiff</a>, <a class="ref" href="#XREFsetxor">setxor</a>, <a class="ref" href="#XREFismember">ismember</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-union">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">union</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-union"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-union-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">union</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>, "rows")</code><a class="copiable-link" href="#index-union-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-union-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">union</strong> <code class="def-code-arguments">(…, "sorted")</code><a class="copiable-link" href="#index-union-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-union-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">union</strong> <code class="def-code-arguments">(…, "stable")</code><a class="copiable-link" href="#index-union-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-union-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">union</strong> <code class="def-code-arguments">(…, "legacy")</code><a class="copiable-link" href="#index-union-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-union-5">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">c</var>, <var class="var">ia</var>, <var class="var">ib</var>] =</code> <strong class="def-name">union</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-union-5"> ¶</a></span>
</dt> <dd> <p>Return the unique elements that are in either <var class="var">a</var> or <var class="var">b</var>. </p> <p>If <var class="var">a</var> and <var class="var">b</var> are both row vectors then return a row vector; Otherwise, return a column vector. The inputs may also be cell arrays of strings. </p> <p>If the optional input <code class="code">"rows"</code> is given then return rows that are in either <var class="var">a</var> or <var class="var">b</var>. The inputs must be 2-D numeric matrices to use this option. </p> <p>The optional argument <code class="code">"sorted"</code>/<code class="code">"stable"</code> controls the order in which unique values appear in the output. The default is <code class="code">"sorted"</code> and values in the output are placed in ascending order. The alternative <code class="code">"stable"</code> preserves the order found in the input. </p> <p>The optional outputs <var class="var">ia</var> and <var class="var">ib</var> are column index vectors such that <code class="code"><var class="var">a</var>(<var class="var">ia</var>)</code> and <code class="code"><var class="var">b</var>(<var class="var">ib</var>)</code> are disjoint sets whose union is <var class="var">c</var>. </p> <p>Programming Note: The input flag <code class="code">"legacy"</code> changes the algorithm to be compatible with <small class="sc">MATLAB</small> releases prior to R2012b. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="sets.html#XREFunique">unique</a>, <a class="ref" href="#XREFintersect">intersect</a>, <a class="ref" href="#XREFsetdiff">setdiff</a>, <a class="ref" href="#XREFsetxor">setxor</a>, <a class="ref" href="#XREFismember">ismember</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-setdiff">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">setdiff</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-setdiff"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-setdiff-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">setdiff</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>, "rows")</code><a class="copiable-link" href="#index-setdiff-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-setdiff-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">setdiff</strong> <code class="def-code-arguments">(…, "sorted")</code><a class="copiable-link" href="#index-setdiff-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-setdiff-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">setdiff</strong> <code class="def-code-arguments">(…, "stable")</code><a class="copiable-link" href="#index-setdiff-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-setdiff-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">setdiff</strong> <code class="def-code-arguments">(…, "legacy")</code><a class="copiable-link" href="#index-setdiff-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-setdiff-5">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">c</var>, <var class="var">ia</var>] =</code> <strong class="def-name">setdiff</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-setdiff-5"> ¶</a></span>
</dt> <dd>
<p>Return the unique elements in <var class="var">a</var> that are not in <var class="var">b</var>. </p> <p>If <var class="var">a</var> is a row vector return a row vector; Otherwise, return a column vector. The inputs may also be cell arrays of strings. </p> <p>If the optional input <code class="code">"rows"</code> is given then return the rows in <var class="var">a</var> that are not in <var class="var">b</var>. The inputs must be 2-D numeric matrices to use this option. </p> <p>The optional argument <code class="code">"sorted"</code>/<code class="code">"stable"</code> controls the order in which unique values appear in the output. The default is <code class="code">"sorted"</code> and values in the output are placed in ascending order. The alternative <code class="code">"stable"</code> preserves the order found in the input. </p> <p>If requested, return the index vector <var class="var">ia</var> such that <code class="code"><var class="var">c</var> = <var class="var">a</var>(<var class="var">ia</var>)</code>. </p> <p>Programming Note: The input flag <code class="code">"legacy"</code> changes the algorithm to be compatible with <small class="sc">MATLAB</small> releases prior to R2012b. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="sets.html#XREFunique">unique</a>, <a class="ref" href="#XREFunion">union</a>, <a class="ref" href="#XREFintersect">intersect</a>, <a class="ref" href="#XREFsetxor">setxor</a>, <a class="ref" href="#XREFismember">ismember</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-setxor">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">setxor</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-setxor"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-setxor-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">setxor</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>, "rows")</code><a class="copiable-link" href="#index-setxor-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-setxor-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">setxor</strong> <code class="def-code-arguments">(…, "sorted")</code><a class="copiable-link" href="#index-setxor-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-setxor-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">setxor</strong> <code class="def-code-arguments">(…, "stable")</code><a class="copiable-link" href="#index-setxor-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-setxor-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">setxor</strong> <code class="def-code-arguments">(…, "legacy")</code><a class="copiable-link" href="#index-setxor-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-setxor-5">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">c</var>, <var class="var">ia</var>, <var class="var">ib</var>] =</code> <strong class="def-name">setxor</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-setxor-5"> ¶</a></span>
</dt> <dd> <p>Return the unique elements exclusive to sets <var class="var">a</var> or <var class="var">b</var>. </p> <p>If <var class="var">a</var> and <var class="var">b</var> are both row vectors then return a row vector; Otherwise, return a column vector. The inputs may also be cell arrays of strings. </p> <p>If the optional input <code class="code">"rows"</code> is given then return the rows exclusive to sets <var class="var">a</var> and <var class="var">b</var>. The inputs must be 2-D numeric matrices to use this option. </p> <p>The optional argument <code class="code">"sorted"</code>/<code class="code">"stable"</code> controls the order in which unique values appear in the output. The default is <code class="code">"sorted"</code> and values in the output are placed in ascending order. The alternative <code class="code">"stable"</code> preserves the order found in the input. </p> <p>The optional outputs <var class="var">ia</var> and <var class="var">ib</var> are column index vectors such that <code class="code"><var class="var">a</var>(<var class="var">ia</var>)</code> and <code class="code"><var class="var">b</var>(<var class="var">ib</var>)</code> are disjoint sets whose union is <var class="var">c</var>. </p> <p>Programming Note: The input flag <code class="code">"legacy"</code> changes the algorithm to be compatible with <small class="sc">MATLAB</small> releases prior to R2012b. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="sets.html#XREFunique">unique</a>, <a class="ref" href="#XREFunion">union</a>, <a class="ref" href="#XREFintersect">intersect</a>, <a class="ref" href="#XREFsetdiff">setdiff</a>, <a class="ref" href="#XREFismember">ismember</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ismember">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">ismember</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">s</var>)</code><a class="copiable-link" href="#index-ismember"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ismember-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">ismember</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">s</var>, "rows")</code><a class="copiable-link" href="#index-ismember-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ismember-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">tf</var>, <var class="var">s_idx</var>] =</code> <strong class="def-name">ismember</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-ismember-2"> ¶</a></span>
</dt> <dd> <p>Return a logical matrix <var class="var">tf</var> with the same shape as <var class="var">a</var> which is true (1) if the element in <var class="var">a</var> is found in <var class="var">s</var> and false (0) if it is not. </p> <p>If a second output argument is requested then the index into <var class="var">s</var> of each matching element is also returned. </p> <pre class="example" data-language="matlab">a = [3, 10, 1];
s = [0:9];
[tf, s_idx] = ismember (a, s)
     ⇒ tf = [1, 0, 1]
     ⇒ s_idx = [4, 0, 2]</pre> <p>The inputs <var class="var">a</var> and <var class="var">s</var> may also be cell arrays. </p> <pre class="example" data-language="matlab">a = {"abc"};
s = {"abc", "def"};
[tf, s_idx] = ismember (a, s)
     ⇒ tf = 1
     ⇒ s_idx = 1</pre> <p>If the optional third argument <code class="code">"rows"</code> is given then compare rows in <var class="var">a</var> with rows in <var class="var">s</var>. The inputs must be 2-D matrices with the same number of columns to use this option. </p> <pre class="example" data-language="matlab">a = [1:3; 5:7; 4:6];
s = [0:2; 1:3; 2:4; 3:5; 4:6];
[tf, s_idx] = ismember (a, s, "rows")
     ⇒ tf = logical ([1; 0; 1])
     ⇒ s_idx = [2; 0; 5];</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="finding-elements-and-checking-conditions.html#XREFlookup">lookup</a>, <a class="ref" href="sets.html#XREFunique">unique</a>, <a class="ref" href="#XREFunion">union</a>, <a class="ref" href="#XREFintersect">intersect</a>, <a class="ref" href="#XREFsetdiff">setdiff</a>, <a class="ref" href="#XREFsetxor">setxor</a>, <a class="ref" href="#XREFismembertol">ismembertol</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ismembertol">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">ismembertol</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">s</var>)</code><a class="copiable-link" href="#index-ismembertol"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ismembertol-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">ismembertol</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">s</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-ismembertol-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ismembertol-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">ismembertol</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">s</var>, <var class="var">name</var>, <var class="var">value</var>)</code><a class="copiable-link" href="#index-ismembertol-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ismembertol-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">tf</var>, <var class="var">s_idx</var>] =</code> <strong class="def-name">ismembertol</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-ismembertol-3"> ¶</a></span>
</dt> <dd>
<p>Check if values are members of a set within a tolerance. </p> <p>This functions returns a logical matrix <var class="var">tf</var> with the same shape as <var class="var">a</var> which is true (1) where the element in <var class="var">a</var> is close to <var class="var">s</var> within a tolerance <var class="var">tol</var> and false (0) if it is not. If <var class="var">tol</var> is not specified, a default tolerance of <code class="code">1e-6</code> is used. </p> <p>If a second output argument is requested then the index into <var class="var">s</var> of each matching element is also returned. </p> <p>The inputs <var class="var">a</var> and <var class="var">s</var> must be numeric values. </p> <pre class="example" data-language="matlab">a = [3, 10, 1];
s = [0:9];
[tf, s_idx] = ismembertol (a, s)
     ⇒ tf = [1, 0, 1]
     ⇒ s_idx = [4, 0, 2]</pre> <p>Optional property/value pairs may be given to change the function’s behavior. The property may be one of following strings: </p> <dl class="table"> <dt><code class="code">"ByRows"</code></dt> <dd>
<p>If set to <code class="code">false</code> (default), all elements in <var class="var">a</var> and <var class="var">s</var> are treated separately. If set to <code class="code">true</code>, <var class="var">tf</var> will be <code class="code">true</code> for each row in <var class="var">a</var> that matches a row in <var class="var">s</var> within the given tolerance. Two rows, <var class="var">u</var> and <var class="var">v</var>, are within tolerance if they fulfill the condition <code class="code">all (abs (u-v) &lt;= tol*max (abs ([a;s])))</code>. </p> </dd> <dt><code class="code">"OutputAllIndices"</code></dt> <dd>
<p>If set to <code class="code">false</code> (default), <var class="var">s_idx</var> contains indices for one of the matches. If set to <code class="code">true</code>, <var class="var">s_idx</var> is a cell array containing the indices for all elements in <var class="var">s</var> that are within tolerance of the corresponding value in <var class="var">a</var>. </p> </dd> <dt><code class="code">"DataScale"</code></dt> <dd><p>The provided value <var class="var">DS</var> is used to change the scale factor in the tolerance test to <code class="code">abs (u-v) &lt;= tol*<var class="var">DS</var></code>. By default, the maximum absolute value in <var class="var">a</var> and <var class="var">s</var> is used as the scale factor. </p></dd> </dl> <p>Example: </p> <pre class="example" data-language="matlab">s = [1:6].' * pi;
a = 10.^log10 (x);
[tf, s_idx] = ismembertol (a, s);</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFismember">ismember</a>, <a class="ref" href="finding-elements-and-checking-conditions.html#XREFlookup">lookup</a>, <a class="ref" href="sets.html#XREFunique">unique</a>, <a class="ref" href="#XREFunion">union</a>, <a class="ref" href="#XREFintersect">intersect</a>, <a class="ref" href="#XREFsetdiff">setdiff</a>, <a class="ref" href="#XREFsetxor">setxor</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-powerset">
<span class="category-def">: </span><span><code class="def-type"><var class="var">p</var> =</code> <strong class="def-name">powerset</strong> <code class="def-code-arguments">(<var class="var">a</var>)</code><a class="copiable-link" href="#index-powerset"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-powerset-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">p</var> =</code> <strong class="def-name">powerset</strong> <code class="def-code-arguments">(<var class="var">a</var>, "rows")</code><a class="copiable-link" href="#index-powerset-1"> ¶</a></span>
</dt> <dd>
<p>Compute the powerset (all subsets) of the set <var class="var">a</var>. </p> <p>The set <var class="var">a</var> must be a numerical matrix or a cell array of strings. The output will always be a cell array of either vectors or strings. </p> <p>With the optional argument <code class="code">"rows"</code>, each row of the set <var class="var">a</var> is considered one element of the set. The input must be a 2-D numeric matrix to use this argument. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="sets.html#XREFunique">unique</a>, <a class="ref" href="#XREFunion">union</a>, <a class="ref" href="#XREFintersect">intersect</a>, <a class="ref" href="#XREFsetdiff">setdiff</a>, <a class="ref" href="#XREFsetxor">setxor</a>, <a class="ref" href="#XREFismember">ismember</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Up: <a href="sets.html">Sets</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Set-Operations.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Set-Operations.html</a>
  </p>
</div>
