<div class="section" id="Bit-Manipulations">   <h1 class="section">4.5 Bit Manipulations</h1> <p>Octave provides a number of functions for the manipulation of numeric values on a bit by bit basis. The basic functions to set and obtain the values of individual bits are <code>bitset</code> and <code>bitget</code>. </p> <dl class="def"> <dt id="index-bitset">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>bitset</strong> <em>(<var>A</var>, <var>n</var>)</em><a href="#index-bitset" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bitset-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>bitset</strong> <em>(<var>A</var>, <var>n</var>, <var>val</var>)</em><a href="#index-bitset-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Set or reset bit(s) at position <var>n</var> of the unsigned integers in <var>A</var>. </p> <p>The least significant bit is <var>n</var> = 1. <var>val</var> = 0 resets bits and <var>val</var> = 1 sets bits. If no <var>val</var> is specified it defaults to 1 (set bit). All inputs must be the same size or scalars. </p> <p>Example 1: Set multiple bits </p> <pre class="example" data-language="matlab">x = bitset (1, 3:5)
  ⇒ x =

   5    9   17

dec2bin (x)
  ⇒
     00101
     01001
     10001</pre> <p>Example 2: Reset and set bits </p> <pre class="example" data-language="matlab">x = bitset ([15 14], 1, [0 1])
  ⇒ x =

   14    15</pre> <p><strong>See also:</strong> <a href="#XREFbitand">bitand</a>, <a href="#XREFbitor">bitor</a>, <a href="#XREFbitxor">bitxor</a>, <a href="#XREFbitget">bitget</a>, <a href="#XREFbitcmp">bitcmp</a>, <a href="#XREFbitshift">bitshift</a>, <a href="integer-data-types.html#XREFintmax">intmax</a>, <a href="integer-data-types.html#XREFflintmax">flintmax</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-bitget">
<span class="category">: </span><span><em><var>b</var> =</em> <strong>bitget</strong> <em>(<var>A</var>, <var>n</var>)</em><a href="#index-bitget" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the bit value at position(s) <var>n</var> of the unsigned integers in <var>A</var>. </p> <p>The least significant bit is <var>n</var> = 1. </p> <pre class="example" data-language="matlab">bitget (100, 8:-1:1)
⇒ 0  1  1  0  0  1  0  0</pre> <p><strong>See also:</strong> <a href="#XREFbitand">bitand</a>, <a href="#XREFbitor">bitor</a>, <a href="#XREFbitxor">bitxor</a>, <a href="#XREFbitset">bitset</a>, <a href="#XREFbitcmp">bitcmp</a>, <a href="#XREFbitshift">bitshift</a>, <a href="integer-data-types.html#XREFintmax">intmax</a>, <a href="integer-data-types.html#XREFflintmax">flintmax</a>. </p>
</dd>
</dl> <p>The arguments to all of Octave’s bitwise operations can be scalar or arrays, except for <code>bitcmp</code>, whose <var>k</var> argument must a scalar. In the case where more than one argument is an array, then all arguments must have the same shape, and the bitwise operator is applied to each of the elements of the argument individually. If at least one argument is a scalar and one an array, then the scalar argument is duplicated. Therefore </p> <pre class="example" data-language="matlab">bitget (100, 8:-1:1)</pre> <p>is the same as </p> <pre class="example" data-language="matlab">bitget (100 * ones (1, 8), 8:-1:1)</pre> <p>It should be noted that all values passed to the bit manipulation functions of Octave are treated as integers. Therefore, even though the example for <code>bitset</code> above passes the floating point value <code>10</code>, it is treated as the bits <code>[1, 0, 1, 0]</code> rather than the bits of the native floating point format representation of <code>10</code>. </p> <p>As the maximum value that can be represented by a number is important for bit manipulation, particularly when forming masks, Octave supplies two utility functions: <code>flintmax</code> for floating point integers, and <code>intmax</code> for integer objects (<code>uint8</code>, <code>int64</code>, etc.). </p> <p>Octave also includes the basic bitwise ’and’, ’or’, and ’exclusive or’ operators. </p> <dl class="def"> <dt id="index-bitand">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>bitand</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-bitand" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the bitwise AND of non-negative integers. </p> <p><var>x</var>, <var>y</var> must be in the range [0,intmax] </p> <p><strong>See also:</strong> <a href="#XREFbitor">bitor</a>, <a href="#XREFbitxor">bitxor</a>, <a href="#XREFbitset">bitset</a>, <a href="#XREFbitget">bitget</a>, <a href="#XREFbitcmp">bitcmp</a>, <a href="#XREFbitshift">bitshift</a>, <a href="integer-data-types.html#XREFintmax">intmax</a>, <a href="integer-data-types.html#XREFflintmax">flintmax</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-bitor">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>bitor</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-bitor" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the bitwise OR of non-negative integers <var>x</var> and <var>y</var>. </p> <p><strong>See also:</strong> <a href="#XREFbitor">bitor</a>, <a href="#XREFbitxor">bitxor</a>, <a href="#XREFbitset">bitset</a>, <a href="#XREFbitget">bitget</a>, <a href="#XREFbitcmp">bitcmp</a>, <a href="#XREFbitshift">bitshift</a>, <a href="integer-data-types.html#XREFintmax">intmax</a>, <a href="integer-data-types.html#XREFflintmax">flintmax</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-bitxor">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>bitxor</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-bitxor" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the bitwise XOR of non-negative integers <var>x</var> and <var>y</var>. </p> <p><strong>See also:</strong> <a href="#XREFbitand">bitand</a>, <a href="#XREFbitor">bitor</a>, <a href="#XREFbitset">bitset</a>, <a href="#XREFbitget">bitget</a>, <a href="#XREFbitcmp">bitcmp</a>, <a href="#XREFbitshift">bitshift</a>, <a href="integer-data-types.html#XREFintmax">intmax</a>, <a href="integer-data-types.html#XREFflintmax">flintmax</a>. </p>
</dd>
</dl> <p>The bitwise ’not’ operator is a unary operator that performs a logical negation of each of the bits of the value. For this to make sense, the mask against which the value is negated must be defined. Octave’s bitwise ’not’ operator is <code>bitcmp</code>. </p> <dl class="def"> <dt id="index-bitcmp">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>bitcmp</strong> <em>(<var>A</var>, <var>k</var>)</em><a href="#index-bitcmp" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the <var>k</var>-bit complement of integers in <var>A</var>. </p> <p>If <var>k</var> is omitted <code>k = log2 (flintmax) + 1</code> is assumed. </p> <pre class="example" data-language="matlab">bitcmp (7,4)
  ⇒ 8
dec2bin (11)
  ⇒ 1011
dec2bin (bitcmp (11, 6))
  ⇒ 110100</pre> <p><strong>See also:</strong> <a href="#XREFbitand">bitand</a>, <a href="#XREFbitor">bitor</a>, <a href="#XREFbitxor">bitxor</a>, <a href="#XREFbitset">bitset</a>, <a href="#XREFbitget">bitget</a>, <a href="#XREFbitcmp">bitcmp</a>, <a href="#XREFbitshift">bitshift</a>, <a href="integer-data-types.html#XREFflintmax">flintmax</a>. </p>
</dd>
</dl> <p>Octave also includes the ability to left-shift and right-shift values bitwise. </p> <dl class="def"> <dt id="index-bitshift">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>bitshift</strong> <em>(<var>A</var>, <var>k</var>)</em><a href="#index-bitshift" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bitshift-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>bitshift</strong> <em>(<var>A</var>, <var>k</var>, <var>n</var>)</em><a href="#index-bitshift-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a <var>k</var> bit shift of <var>n</var>-digit unsigned integers in <var>A</var>. </p> <p>A positive <var>k</var> leads to a left shift; A negative value to a right shift. </p> <p>If <var>n</var> is omitted it defaults to 64. <var>n</var> must be in the range [1,64]. </p> <pre class="example" data-language="matlab">bitshift (eye (3), 1)
⇒
2 0 0
0 2 0
0 0 2


bitshift (10, [-2, -1, 0, 1, 2])
⇒ 2   5  10  20  40</pre> <p><strong>See also:</strong> <a href="#XREFbitand">bitand</a>, <a href="#XREFbitor">bitor</a>, <a href="#XREFbitxor">bitxor</a>, <a href="#XREFbitset">bitset</a>, <a href="#XREFbitget">bitget</a>, <a href="#XREFbitcmp">bitcmp</a>, <a href="integer-data-types.html#XREFintmax">intmax</a>, <a href="integer-data-types.html#XREFflintmax">flintmax</a>. </p>
</dd>
</dl> <p>Bits that are shifted out of either end of the value are lost. Octave also uses arithmetic shifts, where the sign bit of the value is kept during a right shift. For example: </p> <pre class="example" data-language="matlab">bitshift (-10, -1)
⇒ -5
bitshift (int8 (-1), -1)
⇒ -1</pre> <p>Note that <code>bitshift (int8 (-1), -1)</code> is <code>-1</code> since the bit representation of <code>-1</code> in the <code>int8</code> data type is <code>[1, 1,
1, 1, 1, 1, 1, 1]</code>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Bit-Manipulations.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Bit-Manipulations.html</a>
  </p>
</div>
