<div class="section-level-extent" id="Finding-Elements-and-Checking-Conditions"> <div class="nav-panel"> <p> Next: <a href="rearranging-matrices.html" accesskey="n" rel="next">Rearranging Matrices</a>, Up: <a href="matrix-manipulation.html" accesskey="u" rel="up">Matrix Manipulation</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Finding-Elements-and-Checking-Conditions-1"><span>16.1 Finding Elements and Checking Conditions<a class="copiable-link" href="#Finding-Elements-and-Checking-Conditions-1"> ¶</a></span></h1> <p>The functions <code class="code">any</code> and <code class="code">all</code> are useful for determining whether any or all of the elements of a matrix satisfy some condition. The <code class="code">find</code> function is also useful in determining which elements of a matrix meet a specified condition. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-any">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">any</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-any"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-any-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">any</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-any-1"> ¶</a></span>
</dt> <dd>
<p>For a vector argument, return true (logical 1) if any element of the vector is nonzero. </p> <p>For a matrix argument, return a row vector of logical ones and zeros with each element indicating whether any of the elements of the corresponding column of the matrix are nonzero. For example: </p> <pre class="example" data-language="matlab">any (eye (2, 4))
 ⇒ [ 1, 1, 0, 0 ]</pre> <p>If the optional argument <var class="var">dim</var> is supplied, work along dimension <var class="var">dim</var>. For example: </p> <pre class="example" data-language="matlab">any (eye (2, 4), 2)
 ⇒ [ 1; 1 ]</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFall">all</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-all">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">all</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-all"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-all-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">all</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-all-1"> ¶</a></span>
</dt> <dd>
<p>For a vector argument, return true (logical 1) if all elements of the vector are nonzero. </p> <p>For a matrix argument, return a row vector of logical ones and zeros with each element indicating whether all of the elements of the corresponding column of the matrix are nonzero. For example: </p> <pre class="example" data-language="matlab">all ([2, 3; 1, 0])
    ⇒ [ 1, 0 ]</pre> <p>If the optional argument <var class="var">dim</var> is supplied, work along dimension <var class="var">dim</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFany">any</a>. </p>
</dd>
</dl> <p>Since the comparison operators (see <a class="pxref" href="comparison-ops.html">Comparison Operators</a>) return matrices of ones and zeros, it is easy to test a matrix for many things, not just whether the elements are nonzero. For example, </p> <pre class="example" data-language="matlab">all (all (rand (5) &lt; 0.9))
     ⇒ 0</pre> <p>tests a random 5 by 5 matrix to see if all of its elements are less than 0.9. </p> <p>Note that in conditional contexts (like the test clause of <code class="code">if</code> and <code class="code">while</code> statements) Octave treats the test as if you had typed <code class="code">all (all (condition))</code>. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-xor">
<span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">xor</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-xor"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-xor-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">xor</strong> <code class="def-code-arguments">(<var class="var">x1</var>, <var class="var">x2</var>, …)</code><a class="copiable-link" href="#index-xor-1"> ¶</a></span>
</dt> <dd>
<p>Return the <em class="dfn">exclusive or</em> of <var class="var">x</var> and <var class="var">y</var>. </p> <p>For boolean expressions <var class="var">x</var> and <var class="var">y</var>, <code class="code">xor (<var class="var">x</var>, <var class="var">y</var>)</code> is true if and only if one of <var class="var">x</var> or <var class="var">y</var> is true. Otherwise, if <var class="var">x</var> and <var class="var">y</var> are both true or both false, <code class="code">xor</code> returns false. </p> <p>The truth table for the xor operation is </p> <table class="multitable"> <tbody>
<tr>
<td width="44%"></td>
<td width="3%"><var class="var">x</var></td>
<td width="5%"><var class="var">y</var></td>
<td width="3%"><var class="var">z</var></td>
<td width="44%"></td>
</tr> <tr>
<td width="44%"></td>
<td width="3%">-</td>
<td width="5%">-</td>
<td width="3%">-</td>
<td width="44%"></td>
</tr> <tr>
<td width="44%"></td>
<td width="3%">0</td>
<td width="5%">0</td>
<td width="3%">0</td>
<td width="44%"></td>
</tr> <tr>
<td width="44%"></td>
<td width="3%">1</td>
<td width="5%">0</td>
<td width="3%">1</td>
<td width="44%"></td>
</tr> <tr>
<td width="44%"></td>
<td width="3%">0</td>
<td width="5%">1</td>
<td width="3%">1</td>
<td width="44%"></td>
</tr> <tr>
<td width="44%"></td>
<td width="3%">1</td>
<td width="5%">1</td>
<td width="3%">0</td>
<td width="44%"></td>
</tr> </tbody> </table> <p>If more than two arguments are given the xor operation is applied cumulatively from left to right: </p> <pre class="example" data-language="matlab">(...((x1 XOR x2) XOR x3) XOR ...)</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="element_002dby_002delement-boolean-operators.html#XREFand">and</a>, <a class="ref" href="element_002dby_002delement-boolean-operators.html#XREFor">or</a>, <a class="ref" href="element_002dby_002delement-boolean-operators.html#XREFnot">not</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-diff">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">diff</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-diff"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-diff-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">diff</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-diff-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-diff-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">diff</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">k</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-diff-2"> ¶</a></span>
</dt> <dd>
<p>If <var class="var">x</var> is a vector of length <em class="math">n</em>, <code class="code">diff (<var class="var">x</var>)</code> is the vector of first differences <var class="var">x</var>(2) - <var class="var">x</var>(1), …, <var class="var">x</var>(n) - <var class="var">x</var>(n-1). </p> <p>If <var class="var">x</var> is a matrix, <code class="code">diff (<var class="var">x</var>)</code> is the matrix of column differences along the first non-singleton dimension. </p> <p>The second argument is optional. If supplied, <code class="code">diff (<var class="var">x</var>, <var class="var">k</var>)</code>, where <var class="var">k</var> is a non-negative integer, returns the <var class="var">k</var>-th differences. It is possible that <var class="var">k</var> is larger than the first non-singleton dimension of the matrix. In this case, <code class="code">diff</code> continues to take the differences along the next non-singleton dimension. </p> <p>The dimension along which to take the difference can be explicitly stated with the optional variable <var class="var">dim</var>. In this case the <var class="var">k</var>-th order differences are calculated along this dimension. In the case where <var class="var">k</var> exceeds <code class="code">size (<var class="var">x</var>, <var class="var">dim</var>)</code> an empty matrix is returned. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="rearranging-matrices.html#XREFsort">sort</a>, <a class="ref" href="short_002dcircuit-boolean-operators.html#XREFmerge">merge</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-isinf">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">isinf</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-isinf"> ¶</a></span>
</dt> <dd>
<p>Return a logical array which is true where the elements of <var class="var">x</var> are infinite and false where they are not. </p> <p>For example: </p> <pre class="example" data-language="matlab">isinf ([13, Inf, NA, NaN])
      ⇒ [ 0, 1, 0, 0 ]</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisfinite">isfinite</a>, <a class="ref" href="#XREFisnan">isnan</a>, <a class="ref" href="missing-data.html#XREFisna">isna</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-isnan">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">isnan</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-isnan"> ¶</a></span>
</dt> <dd>
<p>Return a logical array which is true where the elements of <var class="var">x</var> are NaN values and false where they are not. </p> <p>NA values are also considered NaN values. For example: </p> <pre class="example" data-language="matlab">isnan ([13, Inf, NA, NaN])
      ⇒ [ 0, 0, 1, 1 ]</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="missing-data.html#XREFisna">isna</a>, <a class="ref" href="#XREFisinf">isinf</a>, <a class="ref" href="#XREFisfinite">isfinite</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-isfinite">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">isfinite</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-isfinite"> ¶</a></span>
</dt> <dd>
<p>Return a logical array which is true where the elements of <var class="var">x</var> are finite values and false where they are not. </p> <p>For example: </p> <pre class="example" data-language="matlab">isfinite ([13, Inf, NA, NaN])
     ⇒ [ 1, 0, 0, 0 ]</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisinf">isinf</a>, <a class="ref" href="#XREFisnan">isnan</a>, <a class="ref" href="missing-data.html#XREFisna">isna</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-common_005fsize">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">err</var>, <var class="var">yi</var>, …] =</code> <strong class="def-name">common_size</strong> <code class="def-code-arguments">(<var class="var">xi</var>, …)</code><a class="copiable-link" href="#index-common_005fsize"> ¶</a></span>
</dt> <dd>
<p>Determine if all input arguments are either scalar or of common size. </p> <p>If true, <var class="var">err</var> is zero, and <var class="var">yi</var> is a matrix of the common size with all entries equal to <var class="var">xi</var> if this is a scalar or <var class="var">xi</var> otherwise. If the inputs cannot be brought to a common size, <var class="var">err</var> is 1, and <var class="var">yi</var> is <var class="var">xi</var>. For example: </p> <pre class="example" data-language="matlab">[err, a, b] = common_size ([1 2; 3 4], 5)
     ⇒ err = 0
     ⇒ a = [ 1, 2; 3, 4 ]
     ⇒ b = [ 5, 5; 5, 5 ]</pre> <p>This is useful for implementing functions where arguments can either be scalars or of common size. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="object-sizes.html#XREFsize">size</a>, <a class="ref" href="object-sizes.html#XREFsize_005fequal">size_equal</a>, <a class="ref" href="object-sizes.html#XREFnumel">numel</a>, <a class="ref" href="object-sizes.html#XREFndims">ndims</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-find">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">find</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-find"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-find-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">find</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-find-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-find-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">find</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>, <var class="var">direction</var>)</code><a class="copiable-link" href="#index-find-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-find-3">
<span class="category-def">: </span><span><code class="def-type">[i, j] =</code> <strong class="def-name">find</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-find-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-find-4">
<span class="category-def">: </span><span><code class="def-type">[i, j, v] =</code> <strong class="def-name">find</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-find-4"> ¶</a></span>
</dt> <dd>
<p>Return a vector of indices of nonzero elements of a matrix, as a row if <var class="var">x</var> is a row vector or as a column otherwise. </p> <p>To obtain a single index for each matrix element, Octave pretends that the columns of a matrix form one long vector (like Fortran arrays are stored). For example: </p> <pre class="example" data-language="matlab">find (eye (2))
  ⇒ [ 1; 4 ]</pre> <p>If two inputs are given, <var class="var">n</var> indicates the maximum number of elements to find from the beginning of the matrix or vector. </p> <p>If three inputs are given, <var class="var">direction</var> should be one of <code class="code">"first"</code> or <code class="code">"last"</code>, requesting only the first or last <var class="var">n</var> indices, respectively. However, the indices are always returned in ascending order. </p> <p>If two outputs are requested, <code class="code">find</code> returns the row and column indices of nonzero elements of a matrix. For example: </p> <pre class="example" data-language="matlab">[i, j] = find (2 * eye (2))
    ⇒ i = [ 1; 2 ]
    ⇒ j = [ 1; 2 ]</pre> <p>If three outputs are requested, <code class="code">find</code> also returns a vector containing the nonzero values. For example: </p> <pre class="example" data-language="matlab">[i, j, v] = find (3 * eye (2))
       ⇒ i = [ 1; 2 ]
       ⇒ j = [ 1; 2 ]
       ⇒ v = [ 3; 3 ]</pre> <p>If <var class="var">x</var> is a multi-dimensional array of size m x n x p x …, <var class="var">j</var> contains the column locations as if <var class="var">x</var> was flattened into a two-dimensional matrix of size m x (n + p + …). </p> <p>Note that this function is particularly useful for sparse matrices, as it extracts the nonzero elements as vectors, which can then be used to create the original matrix. For example: </p> <pre class="example" data-language="matlab">sz = size (a);
[i, j, v] = find (a);
b = sparse (i, j, v, sz(1), sz(2));</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="information.html#XREFnonzeros">nonzeros</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-lookup">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">lookup</strong> <code class="def-code-arguments">(<var class="var">table</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-lookup"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lookup-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">lookup</strong> <code class="def-code-arguments">(<var class="var">table</var>, <var class="var">y</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-lookup-1"> ¶</a></span>
</dt> <dd>
<p>Lookup values in a <strong class="strong">sorted</strong> table. </p> <p>This function is usually used as a prelude to interpolation. </p> <p>If table is increasing, of length N and <code class="code">idx = lookup (table, y)</code>, then <code class="code">table(idx(i)) &lt;= y(i) &lt; table(idx(i+1))</code> for all <code class="code">y(i)</code> within the table. If <code class="code">y(i) &lt; table(1)</code> then <code class="code">idx(i)</code> is 0. If <code class="code">y(i) &gt;= table(end)</code> or <code class="code">isnan (y(i))</code> then <code class="code">idx(i)</code> is N. </p> <p>If the table is decreasing, then the tests are reversed. For non-strictly monotonic tables, empty intervals are always skipped. The result is undefined if <var class="var">table</var> is not monotonic, or if <var class="var">table</var> contains a NaN. </p> <p>The complexity of the lookup is O(M*log(N)) where M is the size of <var class="var">y</var>. In the special case when <var class="var">y</var> is also sorted, the complexity is O(min (M*log(N), M+N)). </p> <p><var class="var">table</var> and <var class="var">y</var> can also be cell arrays of strings (or <var class="var">y</var> can be a single string). In this case, string lookup is performed using lexicographical comparison. </p> <p>If <var class="var">opts</var> is specified, it must be a string with letters indicating additional options. </p> <dl class="table"> <dt><code class="code">m</code></dt> <dd>
<p>Match. <code class="code">table(idx(i)) == y(i)</code> if <code class="code">y(i)</code> occurs in table; otherwise, <code class="code">idx(i)</code> is zero. </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>Boolean. <code class="code">idx(i)</code> is a logical 1 or 0, indicating whether <code class="code">y(i)</code> is contained in table or not. </p> </dd> <dt><code class="code">l</code></dt> <dd>
<p>Left. For numeric lookups the leftmost subinterval shall be extended to minus infinity (i.e., all indices at least 1). </p> </dd> <dt><code class="code">r</code></dt> <dd><p>Right. For numeric lookups the rightmost subinterval shall be extended to infinity (i.e., all indices at most N-1). </p></dd> </dl> <p><strong class="strong">Note</strong>: If <var class="var">table</var> is not sorted the results from <code class="code">lookup</code> will be unpredictable. </p>
</dd>
</dl> <p>If you wish to check if a variable exists at all, instead of properties its elements may have, consult <a class="ref" href="status-of-variables.html">Status of Variables</a>. </p> </div>  <div class="nav-panel"> <p> Next: <a href="rearranging-matrices.html">Rearranging Matrices</a>, Up: <a href="matrix-manipulation.html">Matrix Manipulation</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Finding-Elements-and-Checking-Conditions.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Finding-Elements-and-Checking-Conditions.html</a>
  </p>
</div>
