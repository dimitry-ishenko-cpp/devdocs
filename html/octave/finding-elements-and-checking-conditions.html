<div class="section" id="Finding-Elements-and-Checking-Conditions">   <h1 class="section">16.1 Finding Elements and Checking Conditions</h1> <p>The functions <code>any</code> and <code>all</code> are useful for determining whether any or all of the elements of a matrix satisfy some condition. The <code>find</code> function is also useful in determining which elements of a matrix meet a specified condition. </p> <dl class="def"> <dt id="index-any">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>any</strong> <em>(<var>x</var>)</em><a href="#index-any" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-any-1">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>any</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-any-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>For a vector argument, return true (logical 1) if any element of the vector is nonzero. </p> <p>For a matrix argument, return a row vector of logical ones and zeros with each element indicating whether any of the elements of the corresponding column of the matrix are nonzero. For example: </p> <pre class="example" data-language="matlab">any (eye (2, 4))
 ⇒ [ 1, 1, 0, 0 ]</pre> <p>If the optional argument <var>dim</var> is supplied, work along dimension <var>dim</var>. For example: </p> <pre class="example" data-language="matlab">any (eye (2, 4), 2)
 ⇒ [ 1; 1 ]</pre> <p><strong>See also:</strong> <a href="#XREFall">all</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-all">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>all</strong> <em>(<var>x</var>)</em><a href="#index-all" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-all-1">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>all</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-all-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>For a vector argument, return true (logical 1) if all elements of the vector are nonzero. </p> <p>For a matrix argument, return a row vector of logical ones and zeros with each element indicating whether all of the elements of the corresponding column of the matrix are nonzero. For example: </p> <pre class="example" data-language="matlab">all ([2, 3; 1, 0])
    ⇒ [ 1, 0 ]</pre> <p>If the optional argument <var>dim</var> is supplied, work along dimension <var>dim</var>. </p> <p><strong>See also:</strong> <a href="#XREFany">any</a>. </p>
</dd>
</dl> <p>Since the comparison operators (see <a href="comparison-ops.html">Comparison Operators</a>) return matrices of ones and zeros, it is easy to test a matrix for many things, not just whether the elements are nonzero. For example, </p> <pre class="example" data-language="matlab">all (all (rand (5) &lt; 0.9))
     ⇒ 0</pre> <p>tests a random 5 by 5 matrix to see if all of its elements are less than 0.9. </p> <p>Note that in conditional contexts (like the test clause of <code>if</code> and <code>while</code> statements) Octave treats the test as if you had typed <code>all (all (condition))</code>. </p> <dl class="def"> <dt id="index-xor">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>xor</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-xor" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-xor-1">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>xor</strong> <em>(<var>x1</var>, <var>x2</var>, …)</em><a href="#index-xor-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the <em>exclusive or</em> of <var>x</var> and <var>y</var>. </p> <p>For boolean expressions <var>x</var> and <var>y</var>, <code>xor (<var>x</var>, <var>y</var>)</code> is true if and only if one of <var>x</var> or <var>y</var> is true. Otherwise, if <var>x</var> and <var>y</var> are both true or both false, <code>xor</code> returns false. </p> <p>The truth table for the xor operation is </p> <table> <tr>
<td width="44%"></td>
<td width="3%"><var>x</var></td>
<td width="5%"><var>y</var></td>
<td width="3%"><var>z</var></td>
<td width="44%"></td>
</tr> <tr>
<td width="44%"></td>
<td width="3%">-</td>
<td width="5%">-</td>
<td width="3%">-</td>
<td width="44%"></td>
</tr> <tr>
<td width="44%"></td>
<td width="3%">0</td>
<td width="5%">0</td>
<td width="3%">0</td>
<td width="44%"></td>
</tr> <tr>
<td width="44%"></td>
<td width="3%">1</td>
<td width="5%">0</td>
<td width="3%">1</td>
<td width="44%"></td>
</tr> <tr>
<td width="44%"></td>
<td width="3%">0</td>
<td width="5%">1</td>
<td width="3%">1</td>
<td width="44%"></td>
</tr> <tr>
<td width="44%"></td>
<td width="3%">1</td>
<td width="5%">1</td>
<td width="3%">0</td>
<td width="44%"></td>
</tr> </table> <p>If more than two arguments are given the xor operation is applied cumulatively from left to right: </p> <pre class="example" data-language="matlab">(…((x1 XOR x2) XOR x3) XOR …)</pre> <p><strong>See also:</strong> <a href="element_002dby_002delement-boolean-operators.html#XREFand">and</a>, <a href="element_002dby_002delement-boolean-operators.html#XREFor">or</a>, <a href="element_002dby_002delement-boolean-operators.html#XREFnot">not</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-diff">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>diff</strong> <em>(<var>x</var>)</em><a href="#index-diff" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-diff-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>diff</strong> <em>(<var>x</var>, <var>k</var>)</em><a href="#index-diff-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-diff-2">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>diff</strong> <em>(<var>x</var>, <var>k</var>, <var>dim</var>)</em><a href="#index-diff-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>If <var>x</var> is a vector of length <em class="math">n</em>, <code>diff (<var>x</var>)</code> is the vector of first differences <var>x</var>(2) - <var>x</var>(1), …, <var>x</var>(n) - <var>x</var>(n-1). </p> <p>If <var>x</var> is a matrix, <code>diff (<var>x</var>)</code> is the matrix of column differences along the first non-singleton dimension. </p> <p>The second argument is optional. If supplied, <code>diff (<var>x</var>, <var>k</var>)</code>, where <var>k</var> is a non-negative integer, returns the <var>k</var>-th differences. It is possible that <var>k</var> is larger than the first non-singleton dimension of the matrix. In this case, <code>diff</code> continues to take the differences along the next non-singleton dimension. </p> <p>The dimension along which to take the difference can be explicitly stated with the optional variable <var>dim</var>. In this case the <var>k</var>-th order differences are calculated along this dimension. In the case where <var>k</var> exceeds <code>size (<var>x</var>, <var>dim</var>)</code> an empty matrix is returned. </p> <p><strong>See also:</strong> <a href="rearranging-matrices.html#XREFsort">sort</a>, <a href="short_002dcircuit-boolean-operators.html#XREFmerge">merge</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isinf">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isinf</strong> <em>(<var>x</var>)</em><a href="#index-isinf" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a logical array which is true where the elements of <var>x</var> are infinite and false where they are not. </p> <p>For example: </p> <pre class="example" data-language="matlab">isinf ([13, Inf, NA, NaN])
      ⇒ [ 0, 1, 0, 0 ]</pre> <p><strong>See also:</strong> <a href="#XREFisfinite">isfinite</a>, <a href="#XREFisnan">isnan</a>, <a href="missing-data.html#XREFisna">isna</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isnan">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isnan</strong> <em>(<var>x</var>)</em><a href="#index-isnan" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a logical array which is true where the elements of <var>x</var> are NaN values and false where they are not. </p> <p>NA values are also considered NaN values. For example: </p> <pre class="example" data-language="matlab">isnan ([13, Inf, NA, NaN])
      ⇒ [ 0, 0, 1, 1 ]</pre> <p><strong>See also:</strong> <a href="missing-data.html#XREFisna">isna</a>, <a href="#XREFisinf">isinf</a>, <a href="#XREFisfinite">isfinite</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-isfinite">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>isfinite</strong> <em>(<var>x</var>)</em><a href="#index-isfinite" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a logical array which is true where the elements of <var>x</var> are finite values and false where they are not. </p> <p>For example: </p> <pre class="example" data-language="matlab">isfinite ([13, Inf, NA, NaN])
     ⇒ [ 1, 0, 0, 0 ]</pre> <p><strong>See also:</strong> <a href="#XREFisinf">isinf</a>, <a href="#XREFisnan">isnan</a>, <a href="missing-data.html#XREFisna">isna</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-common_005fsize">
<span class="category">: </span><span><em>[<var>err</var>, <var>yi</var>, …] =</em> <strong>common_size</strong> <em>(<var>xi</var>, …)</em><a href="#index-common_005fsize" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Determine if all input arguments are either scalar or of common size. </p> <p>If true, <var>err</var> is zero, and <var>yi</var> is a matrix of the common size with all entries equal to <var>xi</var> if this is a scalar or <var>xi</var> otherwise. If the inputs cannot be brought to a common size, <var>err</var> is 1, and <var>yi</var> is <var>xi</var>. For example: </p> <pre class="example" data-language="matlab">[err, a, b] = common_size ([1 2; 3 4], 5)
     ⇒ err = 0
     ⇒ a = [ 1, 2; 3, 4 ]
     ⇒ b = [ 5, 5; 5, 5 ]</pre> <p>This is useful for implementing functions where arguments can either be scalars or of common size. </p> <p><strong>See also:</strong> <a href="object-sizes.html#XREFsize">size</a>, <a href="object-sizes.html#XREFsize_005fequal">size_equal</a>, <a href="object-sizes.html#XREFnumel">numel</a>, <a href="object-sizes.html#XREFndims">ndims</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-find">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>find</strong> <em>(<var>x</var>)</em><a href="#index-find" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-find-1">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>find</strong> <em>(<var>x</var>, <var>n</var>)</em><a href="#index-find-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-find-2">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>find</strong> <em>(<var>x</var>, <var>n</var>, <var>direction</var>)</em><a href="#index-find-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-find-3">
<span class="category">: </span><span><em>[i, j] =</em> <strong>find</strong> <em>(…)</em><a href="#index-find-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-find-4">
<span class="category">: </span><span><em>[i, j, v] =</em> <strong>find</strong> <em>(…)</em><a href="#index-find-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a vector of indices of nonzero elements of a matrix, as a row if <var>x</var> is a row vector or as a column otherwise. </p> <p>To obtain a single index for each matrix element, Octave pretends that the columns of a matrix form one long vector (like Fortran arrays are stored). For example: </p> <pre class="example" data-language="matlab">find (eye (2))
  ⇒ [ 1; 4 ]</pre> <p>If two inputs are given, <var>n</var> indicates the maximum number of elements to find from the beginning of the matrix or vector. </p> <p>If three inputs are given, <var>direction</var> should be one of <code>"first"</code> or <code>"last"</code>, requesting only the first or last <var>n</var> indices, respectively. However, the indices are always returned in ascending order. </p> <p>If two outputs are requested, <code>find</code> returns the row and column indices of nonzero elements of a matrix. For example: </p> <pre class="example" data-language="matlab">[i, j] = find (2 * eye (2))
    ⇒ i = [ 1; 2 ]
    ⇒ j = [ 1; 2 ]</pre> <p>If three outputs are requested, <code>find</code> also returns a vector containing the nonzero values. For example: </p> <pre class="example" data-language="matlab">[i, j, v] = find (3 * eye (2))
       ⇒ i = [ 1; 2 ]
       ⇒ j = [ 1; 2 ]
       ⇒ v = [ 3; 3 ]</pre> <p>If <var>x</var> is a multi-dimensional array of size m x n x p x …, <var>j</var> contains the column locations as if <var>x</var> was flattened into a two-dimensional matrix of size m x (n + p + …). </p> <p>Note that this function is particularly useful for sparse matrices, as it extracts the nonzero elements as vectors, which can then be used to create the original matrix. For example: </p> <pre class="example" data-language="matlab">sz = size (a);
[i, j, v] = find (a);
b = sparse (i, j, v, sz(1), sz(2));</pre> <p><strong>See also:</strong> <a href="information.html#XREFnonzeros">nonzeros</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-lookup">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>lookup</strong> <em>(<var>table</var>, <var>y</var>)</em><a href="#index-lookup" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-lookup-1">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>lookup</strong> <em>(<var>table</var>, <var>y</var>, <var>opt</var>)</em><a href="#index-lookup-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Lookup values in a <strong>sorted</strong> table. </p> <p>This function is usually used as a prelude to interpolation. </p> <p>If table is increasing, of length N and <code>idx = lookup (table, y)</code>, then <code>table(idx(i)) &lt;= y(i) &lt; table(idx(i+1))</code> for all <code>y(i)</code> within the table. If <code>y(i) &lt; table(1)</code> then <code>idx(i)</code> is 0. If <code>y(i) &gt;= table(end)</code> or <code>isnan (y(i))</code> then <code>idx(i)</code> is N. </p> <p>If the table is decreasing, then the tests are reversed. For non-strictly monotonic tables, empty intervals are always skipped. The result is undefined if <var>table</var> is not monotonic, or if <var>table</var> contains a NaN. </p> <p>The complexity of the lookup is O(M*log(N)) where M is the size of <var>y</var>. In the special case when <var>y</var> is also sorted, the complexity is O(min (M*log(N), M+N)). </p> <p><var>table</var> and <var>y</var> can also be cell arrays of strings (or <var>y</var> can be a single string). In this case, string lookup is performed using lexicographical comparison. </p> <p>If <var>opts</var> is specified, it must be a string with letters indicating additional options. </p> <dl compact> <dt><span><code>m</code></span></dt> <dd>
<p>Match. <code>table(idx(i)) == y(i)</code> if <code>y(i)</code> occurs in table; otherwise, <code>idx(i)</code> is zero. </p> </dd> <dt><span><code>b</code></span></dt> <dd>
<p>Boolean. <code>idx(i)</code> is a logical 1 or 0, indicating whether <code>y(i)</code> is contained in table or not. </p> </dd> <dt><span><code>l</code></span></dt> <dd>
<p>Left. For numeric lookups the leftmost subinterval shall be extended to minus infinity (i.e., all indices at least 1). </p> </dd> <dt><span><code>r</code></span></dt> <dd><p>Right. For numeric lookups the rightmost subinterval shall be extended to infinity (i.e., all indices at most N-1). </p></dd> </dl> <p><strong>Note</strong>: If <var>table</var> is not sorted the results from <code>lookup</code> will be unpredictable. </p>
</dd>
</dl> <p>If you wish to check if a variable exists at all, instead of properties its elements may have, consult <a href="status-of-variables.html">Status of Variables</a>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Finding-Elements-and-Checking-Conditions.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Finding-Elements-and-Checking-Conditions.html</a>
  </p>
</div>
