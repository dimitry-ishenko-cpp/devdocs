<div class="subsection" id="Short_002dcircuit-Boolean-Operators">   <h1 class="subsection">8.5.2 Short-circuit Boolean Operators</h1>  <p>Combined with the implicit conversion to scalar values in <code>if</code> and <code>while</code> conditions, Octave’s element-by-element boolean operators are often sufficient for performing most logical operations. However, it is sometimes desirable to stop evaluating a boolean expression as soon as the overall truth value can be determined. Octave’s <em>short-circuit</em> boolean operators work this way. </p> <dl compact> <dt id="index-_0026_0026"><span><code><var>boolean1</var> &amp;&amp; <var>boolean2</var></code><a href="#index-_0026_0026" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>The expression <var>boolean1</var> is evaluated and converted to a scalar using the equivalent of the operation <code>all (<var>boolean1</var>(:))</code>. If <var>boolean1</var> is not a logical value, it is considered true if its value is nonzero, and false if its value is zero. If <var>boolean1</var> is an array, it is considered true only if it is non-empty and all elements are non-zero. If <var>boolean1</var> evaluates to false, the result of the overall expression is false. If it is true, the expression <var>boolean2</var> is evaluated in the same way as <var>boolean1</var>. If it is true, the result of the overall expression is true. Otherwise the result of the overall expression is false. </p> <p><strong>Warning:</strong> the one exception to the equivalence with evaluating <code>all (<var>boolean1</var>(:))</code> is when <code>boolean1</code> an the empty array. For <small>MATLAB</small> compatibility, the truth value of an empty array is always <code>false</code> so <code>[] &amp;&amp; true</code> evaluates to <code>false</code> even though <code>all ([])</code> is <code>true</code>. </p> </dd> <dt id="index-_007c_007c"><span><code><var>boolean1</var> || <var>boolean2</var></code><a href="#index-_007c_007c" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>The expression <var>boolean1</var> is evaluated and converted to a scalar using the equivalent of the operation <code>all (<var>boolean1</var>(:))</code>. If <var>boolean1</var> is not a logical value, it is considered true if its value is nonzero, and false if its value is zero. If <var>boolean1</var> is an array, it is considered true only if it is non-empty and all elements are non-zero. If <var>boolean1</var> evaluates to true, the result of the overall expression is true. If it is false, the expression <var>boolean2</var> is evaluated in the same way as <var>boolean1</var>. If it is true, the result of the overall expression is true. Otherwise the result of the overall expression is false. </p> <p><strong>Warning:</strong> the truth value of an empty matrix is always <code>false</code>, see the previous list item for details. </p>
</dd> </dl> <p>The fact that both operands may not be evaluated before determining the overall truth value of the expression can be important. For example, in the expression </p> <pre class="example" data-language="matlab">a &amp;&amp; b++</pre> <p>the value of the variable <var>b</var> is only incremented if the variable <var>a</var> is nonzero. </p> <p>This can be used to write somewhat more concise code. For example, it is possible write </p> <pre class="example" data-language="matlab">function f (a, b, c)
  if (nargin &gt; 2 &amp;&amp; ischar (c))
    …</pre> <p>instead of having to use two <code>if</code> statements to avoid attempting to evaluate an argument that doesn’t exist. For example, without the short-circuit feature, it would be necessary to write </p> <pre class="example" data-language="matlab">function f (a, b, c)
  if (nargin &gt; 2)
    if (ischar (c))
      …</pre> <p>Writing </p> <pre class="example" data-language="matlab">function f (a, b, c)
  if (nargin &gt; 2 &amp; ischar (c))
    …</pre> <p>would result in an error if <code>f</code> were called with one or two arguments because Octave would be forced to try to evaluate both of the operands for the operator ‘<samp>&amp;</samp>’. </p> <p><small>MATLAB</small> has special behavior that allows the operators ‘<samp>&amp;</samp>’ and ‘<samp>|</samp>’ to short-circuit when used in the truth expression for <code>if</code> and <code>while</code> statements. Octave behaves the same way for compatibility, however, the use of the ‘<samp>&amp;</samp>’ and ‘<samp>|</samp>’ operators in this way is strongly discouraged and a warning will be issued. Instead, you should use the ‘<samp>&amp;&amp;</samp>’ and ‘<samp>||</samp>’ operators that always have short-circuit behavior. </p> <p>Finally, the ternary operator (?:) is not supported in Octave. If short-circuiting is not important, it can be replaced by the <code>ifelse</code> function. </p> <dl class="def"> <dt id="index-merge">
<span class="category">: </span><span><em><var>M</var> =</em> <strong>merge</strong> <em>(<var>mask</var>, <var>tval</var>, <var>fval</var>)</em><a href="#index-merge" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ifelse">
<span class="category">: </span><span><em><var>M</var> =</em> <strong>ifelse</strong> <em>(<var>mask</var>, <var>tval</var>, <var>fval</var>)</em><a href="#index-ifelse" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Merge elements of <var>true_val</var> and <var>false_val</var>, depending on the value of <var>mask</var>. </p> <p>If <var>mask</var> is a logical scalar, the other two arguments can be arbitrary values. Otherwise, <var>mask</var> must be a logical array, and <var>tval</var>, <var>fval</var> should be arrays of matching class, or cell arrays. In the scalar mask case, <var>tval</var> is returned if <var>mask</var> is true, otherwise <var>fval</var> is returned. </p> <p>In the array mask case, both <var>tval</var> and <var>fval</var> must be either scalars or arrays with dimensions equal to <var>mask</var>. The result is constructed as follows: </p> <pre class="example" data-language="matlab">result(mask) = tval(mask);
result(! mask) = fval(! mask);</pre> <p><var>mask</var> can also be arbitrary numeric type, in which case it is first converted to logical. </p> <p><strong>See also:</strong> <a href="logical-values.html#XREFlogical">logical</a>, <a href="finding-elements-and-checking-conditions.html#XREFdiff">diff</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Short_002dcircuit-Boolean-Operators.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Short_002dcircuit-Boolean-Operators.html</a>
  </p>
</div>
