<div class="subsection-level-extent" id="Splitting-and-Joining-Strings"> <div class="nav-panel"> <p> Next: <a href="searching-in-strings.html" accesskey="n" rel="next">Searching in Strings</a>, Previous: <a href="concatenating-strings.html" accesskey="p" rel="prev">Concatenating Strings</a>, Up: <a href="string-operations.html" accesskey="u" rel="up">String Operations</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="Splitting-and-Joining-Strings-1"><span>5.3.3 Splitting and Joining Strings<a class="copiable-link" href="#Splitting-and-Joining-Strings-1"> ¶</a></span></h1>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-substr">
<span class="category-def">: </span><span><code class="def-type"><var class="var">str</var> =</code> <strong class="def-name">substr</strong> <code class="def-code-arguments">(<var class="var">s</var>, <var class="var">offset</var>)</code><a class="copiable-link" href="#index-substr"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-substr-1">
<span class="category-def">: </span><span><strong class="def-name">substr</strong> <code class="def-code-arguments">(<var class="var">s</var>, <var class="var">offset</var>, <var class="var">len</var>)</code><a class="copiable-link" href="#index-substr-1"> ¶</a></span>
</dt> <dd>
<p>Return the substring of <var class="var">s</var> which starts at character number <var class="var">offset</var> and is <var class="var">len</var> characters long. </p> <p>Position numbering for offsets begins with 1. If <var class="var">offset</var> is negative, extraction starts that far from the end of the string. </p> <p>If <var class="var">len</var> is omitted, the substring extends to the end of <var class="var">s</var>. A negative value for <var class="var">len</var> extracts to within <var class="var">len</var> characters of the end of the string </p> <p>Examples: </p> <pre class="example" data-language="matlab">substr ("This is a test string", 6, 9)
     ⇒ "is a test"
substr ("This is a test string", -11)
     ⇒ "test string"
substr ("This is a test string", -11, -7)
     ⇒ "test"</pre> <p>This function is patterned after the equivalent function in Perl. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-strtok">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">tok</var>, <var class="var">rem</var>] =</code> <strong class="def-name">strtok</strong> <code class="def-code-arguments">(<var class="var">str</var>)</code><a class="copiable-link" href="#index-strtok"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strtok-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">tok</var>, <var class="var">rem</var>] =</code> <strong class="def-name">strtok</strong> <code class="def-code-arguments">(<var class="var">str</var>, <var class="var">delim</var>)</code><a class="copiable-link" href="#index-strtok-1"> ¶</a></span>
</dt> <dd> <p>Find all characters in the string <var class="var">str</var> up to, but not including, the first character which is in the string <var class="var">delim</var>. </p> <p><var class="var">str</var> may also be a cell array of strings in which case the function executes on every individual string and returns a cell array of tokens and remainders. </p> <p>Leading delimiters are ignored. If <var class="var">delim</var> is not specified, whitespace is assumed. </p> <p>If <var class="var">rem</var> is requested, it contains the remainder of the string, starting at the first delimiter. </p> <p>Examples: </p> <pre class="example" data-language="matlab">strtok ("this is the life")
     ⇒ "this"

[tok, rem] = strtok ("14*27+31", "+-*/")
     ⇒
        tok = 14
        rem = *27+31</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="searching-in-strings.html#XREFindex">index</a>, <a class="ref" href="#XREFstrsplit">strsplit</a>, <a class="ref" href="searching-in-strings.html#XREFstrchr">strchr</a>, <a class="ref" href="character-class-functions.html#XREFisspace">isspace</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-strsplit">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">cstr</var>] =</code> <strong class="def-name">strsplit</strong> <code class="def-code-arguments">(<var class="var">str</var>)</code><a class="copiable-link" href="#index-strsplit"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strsplit-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">cstr</var>] =</code> <strong class="def-name">strsplit</strong> <code class="def-code-arguments">(<var class="var">str</var>, <var class="var">del</var>)</code><a class="copiable-link" href="#index-strsplit-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strsplit-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">cstr</var>] =</code> <strong class="def-name">strsplit</strong> <code class="def-code-arguments">(…, <var class="var">name</var>, <var class="var">value</var>)</code><a class="copiable-link" href="#index-strsplit-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strsplit-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">cstr</var>, <var class="var">matches</var>] =</code> <strong class="def-name">strsplit</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-strsplit-3"> ¶</a></span>
</dt> <dd>
<p>Split the string <var class="var">str</var> using the delimiters specified by <var class="var">del</var> and return a cell string array of substrings. </p> <p>If a delimiter is not specified the string is split at whitespace <code class="code">{" ", "\f", "\n", "\r", "\t", "\v"}</code>. Otherwise, the delimiter, <var class="var">del</var> must be a string or cell array of strings. By default, consecutive delimiters in the input string <var class="var">s</var> are collapsed into one resulting in a single split. </p> <p>Supported <var class="var">name</var>/<var class="var">value</var> pair arguments are: </p> <ul class="itemize mark-bullet"> <li>
<var class="var">collapsedelimiters</var> which may take the value of <code class="code">true</code> (default) or <code class="code">false</code>. </li>
<li>
<var class="var">delimitertype</var> which may take the value of <code class="code">"simple"</code> (default) or <code class="code">"regularexpression"</code>. A simple delimiter matches the text exactly as written. Otherwise, the syntax for regular expressions outlined in <code class="code">regexp</code> is used. </li>
</ul> <p>The optional second output, <var class="var">matches</var>, returns the delimiters which were matched in the original string. </p> <p>Examples with simple delimiters: </p> <pre class="example" data-language="matlab">strsplit ("a b c")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

strsplit ("a,b,c", ",")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

strsplit ("a foo b,bar c", {" ", ",", "foo", "bar"})
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

strsplit ("a,,b, c", {",", " "}, "collapsedelimiters", false)
      ⇒
          {
            [1,1] = a
            [1,2] =
            [1,3] = b
            [1,4] =
            [1,5] = c
          }</pre> <p>Examples with regularexpression delimiters: </p> <pre class="example smallexample" data-language="matlab">strsplit ("a foo b,bar c", ',|\s|foo|bar', ...
          "delimitertype", "regularexpression")
⇒
{
            [1,1] = a
            [1,2] = b
            [1,3] = c
}

strsplit ("a,,b, c", '[, ]', "collapsedelimiters", false, ...
          "delimitertype", "regularexpression")
⇒
{
            [1,1] = a
            [1,2] =
            [1,3] = b
            [1,4] =
            [1,5] = c
}

strsplit ("a,\t,b, c", {',', '\s'}, "delimitertype", "regularexpression")
⇒
{
            [1,1] = a
            [1,2] = b
            [1,3] = c
}

strsplit ("a,\t,b, c", {',', ' ', '\t'}, "collapsedelimiters", false)
⇒
{
            [1,1] = a
            [1,2] =
            [1,3] =
            [1,4] = b
            [1,5] =
            [1,6] = c
}</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFostrsplit">ostrsplit</a>, <a class="ref" href="#XREFstrjoin">strjoin</a>, <a class="ref" href="#XREFstrtok">strtok</a>, <a class="ref" href="searching-and-replacing-in-strings.html#XREFregexp">regexp</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ostrsplit">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">cstr</var>] =</code> <strong class="def-name">ostrsplit</strong> <code class="def-code-arguments">(<var class="var">s</var>, <var class="var">sep</var>)</code><a class="copiable-link" href="#index-ostrsplit"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ostrsplit-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">cstr</var>] =</code> <strong class="def-name">ostrsplit</strong> <code class="def-code-arguments">(<var class="var">s</var>, <var class="var">sep</var>, <var class="var">strip_empty</var>)</code><a class="copiable-link" href="#index-ostrsplit-1"> ¶</a></span>
</dt> <dd>
<p>Split the string <var class="var">s</var> using one or more separators <var class="var">sep</var> and return a cell array of strings. </p> <p>Consecutive separators and separators at boundaries result in empty strings, unless <var class="var">strip_empty</var> is true. The default value of <var class="var">strip_empty</var> is false. </p> <p>2-D character arrays are split at separators and at the original column boundaries. </p> <p>Example: </p> <pre class="example" data-language="matlab">ostrsplit ("a,b,c", ",")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

ostrsplit (["a,b" ; "cde"], ",")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = cde
          }</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstrsplit">strsplit</a>, <a class="ref" href="#XREFstrtok">strtok</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-strjoin">
<span class="category-def">: </span><span><code class="def-type"><var class="var">str</var> =</code> <strong class="def-name">strjoin</strong> <code class="def-code-arguments">(<var class="var">cstr</var>)</code><a class="copiable-link" href="#index-strjoin"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strjoin-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">str</var> =</code> <strong class="def-name">strjoin</strong> <code class="def-code-arguments">(<var class="var">cstr</var>, <var class="var">delimiter</var>)</code><a class="copiable-link" href="#index-strjoin-1"> ¶</a></span>
</dt> <dd>
<p>Join the elements of the cell string array, <var class="var">cstr</var>, into a single string. </p> <p>If no <var class="var">delimiter</var> is specified, the elements of <var class="var">cstr</var> are separated by a space. </p> <p>If <var class="var">delimiter</var> is specified as a string, the cell string array is joined using the string. Escape sequences are supported. </p> <p>If <var class="var">delimiter</var> is a cell string array whose length is one less than <var class="var">cstr</var>, then the elements of <var class="var">cstr</var> are joined by interleaving the cell string elements of <var class="var">delimiter</var>. Escape sequences are not supported. </p> <pre class="example" data-language="matlab">strjoin ({'Octave','Scilab','Lush','Yorick'}, '*')
      ⇒ 'Octave*Scilab*Lush*Yorick'</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstrsplit">strsplit</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="searching-in-strings.html">Searching in Strings</a>, Previous: <a href="concatenating-strings.html">Concatenating Strings</a>, Up: <a href="string-operations.html">String Operations</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Splitting-and-Joining-Strings.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Splitting-and-Joining-Strings.html</a>
  </p>
</div>
