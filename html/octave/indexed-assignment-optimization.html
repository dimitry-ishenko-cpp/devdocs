<div class="subsection-level-extent" id="Indexed-Assignment-Optimization"> <div class="nav-panel"> <p> Previous: <a href="defining-indexing-and-indexed-assignment.html" accesskey="p" rel="prev">Defining Indexing And Indexed Assignment</a>, Up: <a href="indexing-objects.html" accesskey="u" rel="up">Indexing Objects</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="Indexed-Assignment-Optimization-1"><span>34.3.2 Indexed Assignment Optimization<a class="copiable-link" href="#Indexed-Assignment-Optimization-1"> ¶</a></span></h1> <p>Octave’s ubiquitous lazily-copied pass-by-value semantics implies a problem for performance of user-defined <code class="code">subsasgn</code> methods. Imagine the following call to <code class="code">subsasgn</code> </p> <pre class="example" data-language="matlab">ss = substruct ("()", {1});
x = subsasgn (x, ss, 1);</pre> <p>where the corresponding method looking like this: </p> <pre class="example" data-language="matlab">function x = subsasgn (x, ss, val)
  ...
  x.myfield (ss.subs{1}) = val;
endfunction</pre> <p>The problem is that on entry to the <code class="code">subsasgn</code> method, <code class="code">x</code> is still referenced from the caller’s scope, which means that the method will first need to unshare (copy) <code class="code">x</code> and <code class="code">x.myfield</code> before performing the assignment. Upon completing the call, unless an error occurs, the result is immediately assigned to <code class="code">x</code> in the caller’s scope, so that the previous value of <code class="code">x.myfield</code> is forgotten. Hence, the Octave language implies a copy of N elements (N being the size of <code class="code">x.myfield</code>), where modifying just a single element would actually suffice. In other words, a constant-time operation is degraded to linear-time one. This may be a real problem for user classes that intrinsically store large arrays. </p> <p>To partially solve the problem Octave uses a special optimization for user-defined <code class="code">subsasgn</code> methods coded as m-files. When the method gets called as a result of the built-in assignment syntax (not a direct <code class="code">subsasgn</code> call as shown above), i.e., <code class="code">x(1) = 1</code>, <b class="b">AND</b> if the <code class="code">subsasgn</code> method is declared with identical input and output arguments, as in the example above, then Octave will ignore the copy of <code class="code">x</code> inside the caller’s scope; therefore, any changes made to <code class="code">x</code> during the method execution will directly affect the caller’s copy as well. This allows, for instance, defining a polynomial class where modifying a single element takes constant time. </p> <p>It is important to understand the implications that this optimization brings. Since no extra copy of <code class="code">x</code> will exist in the caller’s scope, it is <em class="emph">solely</em> the callee’s responsibility to not leave <code class="code">x</code> in an invalid state if an error occurs during the execution. Also, if the method partially changes <code class="code">x</code> and then errors out, the changes <em class="emph">will</em> affect <code class="code">x</code> in the caller’s scope. Deleting or completely replacing <code class="code">x</code> inside subsasgn will not do anything, however, only indexed assignments matter. </p> <p>Since this optimization may change the way code works (especially if badly written), a function <code class="code">optimize_subsasgn_calls</code> is provided to control it. This feature is enabled by default. Another way to avoid the optimization is to declare subsasgn methods with different output and input arguments like this: </p> <pre class="example" data-language="matlab">function y = subsasgn (x, ss, val)
  ...
endfunction</pre> </div>  <div class="nav-panel"> <p> Previous: <a href="defining-indexing-and-indexed-assignment.html">Defining Indexing And Indexed Assignment</a>, Up: <a href="indexing-objects.html">Indexing Objects</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Indexed-Assignment-Optimization.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Indexed-Assignment-Optimization.html</a>
  </p>
</div>
