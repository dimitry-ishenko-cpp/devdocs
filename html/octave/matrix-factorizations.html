<div class="section-level-extent" id="Matrix-Factorizations"> <div class="nav-panel"> <p> Next: <a href="functions-of-a-matrix.html" accesskey="n" rel="next">Functions of a Matrix</a>, Previous: <a href="basic-matrix-functions.html" accesskey="p" rel="prev">Basic Matrix Functions</a>, Up: <a href="linear-algebra.html" accesskey="u" rel="up">Linear Algebra</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Matrix-Factorizations-1"><span>18.3 Matrix Factorizations<a class="copiable-link" href="#Matrix-Factorizations-1"> ¶</a></span></h1>   <dl class="first-deftypefn"> <dt class="deftypefn" id="index-chol">
<span class="category-def">: </span><span><code class="def-type"><var class="var">R</var> =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-chol"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-chol-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">R</var>, <var class="var">p</var>] =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-chol-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-chol-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">R</var>, <var class="var">p</var>, <var class="var">Q</var>] =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-chol-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-chol-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">R</var>, <var class="var">p</var>, <var class="var">Q</var>] =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(<var class="var">A</var>, "vector")</code><a class="copiable-link" href="#index-chol-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-chol-4">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, …] =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(…, "lower")</code><a class="copiable-link" href="#index-chol-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-chol-5">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">R</var>, …] =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(…, "upper")</code><a class="copiable-link" href="#index-chol-5"> ¶</a></span>
</dt> <dd>
 <p>Compute the upper Cholesky factor, <var class="var">R</var>, of the real symmetric or complex Hermitian positive definite matrix <var class="var">A</var>. </p> <p>The upper Cholesky factor <var class="var">R</var> is computed by using the upper triangular part of matrix <var class="var">A</var> and is defined by </p> <pre class="example" data-language="matlab">R' * R = A.</pre> <p>Calling <code class="code">chol</code> using the optional <code class="code">"upper"</code> flag has the same behavior. In contrast, using the optional <code class="code">"lower"</code> flag, <code class="code">chol</code> returns the lower triangular factorization, computed by using the lower triangular part of matrix <var class="var">A</var>, such that </p> <pre class="example" data-language="matlab">L * L' = A.</pre> <p>Called with one output argument <code class="code">chol</code> fails if matrix <var class="var">A</var> is not positive definite. Note that if matrix <var class="var">A</var> is not real symmetric or complex Hermitian then the lower triangular part is considered to be the (complex conjugate) transpose of the upper triangular part, or vice versa, given the <code class="code">"lower"</code> flag. </p> <p>Called with two or more output arguments <var class="var">p</var> flags whether the matrix <var class="var">A</var> was positive definite and <code class="code">chol</code> does not fail. A zero value of <var class="var">p</var> indicates that matrix <var class="var">A</var> is positive definite and <var class="var">R</var> gives the factorization. Otherwise, <var class="var">p</var> will have a positive value. </p> <p>If called with three output arguments matrix <var class="var">A</var> must be sparse and a sparsity preserving row/column permutation is applied to matrix <var class="var">A</var> prior to the factorization. That is <var class="var">R</var> is the factorization of <code class="code"><var class="var">A</var>(<var class="var">Q</var>,<var class="var">Q</var>)</code> such that </p> <pre class="example" data-language="matlab">R' * R = Q' * A * Q.</pre> <p>The sparsity preserving permutation is generally returned as a matrix. However, given the optional flag <code class="code">"vector"</code>, <var class="var">Q</var> will be returned as a vector such that </p> <pre class="example" data-language="matlab">R' * R = A(Q, Q).</pre> <p>In general the lower triangular factorization is significantly faster for sparse matrices. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFsvd">svd</a>, <a class="ref" href="iterative-techniques.html#XREFichol">ichol</a>, <a class="ref" href="#XREFcholinv">cholinv</a>, <a class="ref" href="#XREFchol2inv">chol2inv</a>, <a class="ref" href="#XREFcholupdate">cholupdate</a>, <a class="ref" href="#XREFcholinsert">cholinsert</a>, <a class="ref" href="#XREFcholdelete">choldelete</a>, <a class="ref" href="#XREFcholshift">cholshift</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-cholinv">
<span class="category-def">: </span><span><code class="def-type"><var class="var">Ainv</var> =</code> <strong class="def-name">cholinv</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-cholinv"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse of the symmetric positive definite matrix <var class="var">A</var> using the Cholesky factorization. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFchol2inv">chol2inv</a>, <a class="ref" href="basic-matrix-functions.html#XREFinv">inv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-chol2inv">
<span class="category-def">: </span><span><code class="def-type"><var class="var">Ainv</var> =</code> <strong class="def-name">chol2inv</strong> <code class="def-code-arguments">(<var class="var">R</var>)</code><a class="copiable-link" href="#index-chol2inv"> ¶</a></span>
</dt> <dd>
<p>Invert a symmetric, positive definite square matrix from its Cholesky decomposition, <var class="var">R</var>. </p> <p>Note that <var class="var">R</var> should be an upper-triangular matrix with positive diagonal elements. <code class="code">chol2inv (<var class="var">U</var>)</code> provides <code class="code">inv (<var class="var">R</var>'*<var class="var">R</var>)</code> but is much faster than using <code class="code">inv</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFcholinv">cholinv</a>, <a class="ref" href="basic-matrix-functions.html#XREFinv">inv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-cholupdate">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">R1</var>, <var class="var">info</var>] =</code> <strong class="def-name">cholupdate</strong> <code class="def-code-arguments">(<var class="var">R</var>, <var class="var">u</var>, <var class="var">op</var>)</code><a class="copiable-link" href="#index-cholupdate"> ¶</a></span>
</dt> <dd>
<p>Update or downdate a Cholesky factorization. </p> <p>Given an upper triangular matrix <var class="var">R</var> and a column vector <var class="var">u</var>, attempt to determine another upper triangular matrix <var class="var">R1</var> such that </p> <ul class="itemize mark-bullet"> <li>
<var class="var">R1</var>’*<var class="var">R1</var> = <var class="var">R</var>’*<var class="var">R</var> + <var class="var">u</var>*<var class="var">u</var>’ if <var class="var">op</var> is <code class="code">"+"</code> </li>
<li>
<var class="var">R1</var>’*<var class="var">R1</var> = <var class="var">R</var>’*<var class="var">R</var> - <var class="var">u</var>*<var class="var">u</var>’ if <var class="var">op</var> is <code class="code">"-"</code> </li>
</ul> <p>If <var class="var">op</var> is <code class="code">"-"</code>, <var class="var">info</var> is set to </p> <ul class="itemize mark-bullet"> <li>0 if the downdate was successful, </li>
<li>1 if <var class="var">R</var>’*<var class="var">R</var> - <var class="var">u</var>*<var class="var">u</var>’ is not positive definite, </li>
<li>2 if <var class="var">R</var> is singular. </li>
</ul> <p>If <var class="var">info</var> is not present, an error message is printed in cases 1 and 2. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFcholinsert">cholinsert</a>, <a class="ref" href="#XREFcholdelete">choldelete</a>, <a class="ref" href="#XREFcholshift">cholshift</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-cholinsert">
<span class="category-def">: </span><span><code class="def-type"><var class="var">R1</var> =</code> <strong class="def-name">cholinsert</strong> <code class="def-code-arguments">(<var class="var">R</var>, <var class="var">j</var>, <var class="var">u</var>)</code><a class="copiable-link" href="#index-cholinsert"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-cholinsert-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">R1</var>, <var class="var">info</var>] =</code> <strong class="def-name">cholinsert</strong> <code class="def-code-arguments">(<var class="var">R</var>, <var class="var">j</var>, <var class="var">u</var>)</code><a class="copiable-link" href="#index-cholinsert-1"> ¶</a></span>
</dt> <dd>
<p>Update a Cholesky factorization given a row or column to insert in the original factored matrix. </p> <p>Given a Cholesky factorization of a real symmetric or complex Hermitian positive definite matrix <var class="var">A</var> = <var class="var">R</var>’*<var class="var">R</var>, <var class="var">R</var> upper triangular, return the Cholesky factorization of <var class="var">A1</var>, where A1(p,p) = A, A1(:,j) = A1(j,:)’ = u and p = [1:j-1,j+1:n+1]. u(j) should be positive. </p> <p>On return, <var class="var">info</var> is set to </p> <ul class="itemize mark-bullet"> <li>0 if the insertion was successful, </li>
<li>1 if <var class="var">A1</var> is not positive definite, </li>
<li>2 if <var class="var">R</var> is singular. </li>
</ul> <p>If <var class="var">info</var> is not present, an error message is printed in cases 1 and 2. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFcholupdate">cholupdate</a>, <a class="ref" href="#XREFcholdelete">choldelete</a>, <a class="ref" href="#XREFcholshift">cholshift</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-choldelete">
<span class="category-def">: </span><span><code class="def-type"><var class="var">R1</var> =</code> <strong class="def-name">choldelete</strong> <code class="def-code-arguments">(<var class="var">R</var>, <var class="var">j</var>)</code><a class="copiable-link" href="#index-choldelete"> ¶</a></span>
</dt> <dd>
<p>Update a Cholesky factorization given a row or column to delete from the original factored matrix. </p> <p>Given a Cholesky factorization of a real symmetric or complex Hermitian positive definite matrix <var class="var">A</var> = <var class="var">R</var>’*<var class="var">R</var>, <var class="var">R</var> upper triangular, return the Cholesky factorization of A(p,p), where p = [1:j-1,j+1:n+1]. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFcholupdate">cholupdate</a>, <a class="ref" href="#XREFcholinsert">cholinsert</a>, <a class="ref" href="#XREFcholshift">cholshift</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-cholshift">
<span class="category-def">: </span><span><code class="def-type"><var class="var">R1</var> =</code> <strong class="def-name">cholshift</strong> <code class="def-code-arguments">(<var class="var">R</var>, <var class="var">i</var>, <var class="var">j</var>)</code><a class="copiable-link" href="#index-cholshift"> ¶</a></span>
</dt> <dd>
<p>Update a Cholesky factorization given a range of columns to shift in the original factored matrix. </p> <p>Given a Cholesky factorization of a real symmetric or complex Hermitian positive definite matrix <var class="var">A</var> = <var class="var">R</var>’*<var class="var">R</var>, <var class="var">R</var> upper triangular, return the Cholesky factorization of <var class="var">A</var>(p,p), where p is the permutation <br> <code class="code">p = [1:i-1, shift(i:j, 1), j+1:n]</code> if <var class="var">i</var> &lt; <var class="var">j</var> <br> or <br> <code class="code">p = [1:j-1, shift(j:i,-1), i+1:n]</code> if <var class="var">j</var> &lt; <var class="var">i</var>. <br> </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFcholupdate">cholupdate</a>, <a class="ref" href="#XREFcholinsert">cholinsert</a>, <a class="ref" href="#XREFcholdelete">choldelete</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-hess">
<span class="category-def">: </span><span><code class="def-type"><var class="var">H</var> =</code> <strong class="def-name">hess</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-hess"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-hess-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">P</var>, <var class="var">H</var>] =</code> <strong class="def-name">hess</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-hess-1"> ¶</a></span>
</dt> <dd>
 <p>Compute the Hessenberg decomposition of the matrix <var class="var">A</var>. </p> <p>The Hessenberg decomposition is <code class="code"><var class="var">P</var> * <var class="var">H</var> * <var class="var">P</var>' = <var class="var">A</var></code> where <var class="var">P</var> is a square unitary matrix (<code class="code"><var class="var">P</var>' * <var class="var">P</var> = I</code>, using complex-conjugate transposition) and <var class="var">H</var> is upper Hessenberg (<code class="code"><var class="var">H</var>(i, j) = 0 forall i &gt; j+1)</code>. </p> <p>The Hessenberg decomposition is usually used as the first step in an eigenvalue computation, but has other applications as well (see Golub, Nash, and Van Loan, IEEE Transactions on Automatic Control, 1979). </p> <p><strong class="strong">See also:</strong> <a class="ref" href="basic-matrix-functions.html#XREFeig">eig</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFsvd">svd</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-lu">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-lu"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lu-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-lu-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lu-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>, <var class="var">Q</var>] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(<var class="var">S</var>)</code><a class="copiable-link" href="#index-lu-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lu-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>, <var class="var">Q</var>, <var class="var">R</var>] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(<var class="var">S</var>)</code><a class="copiable-link" href="#index-lu-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lu-4">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(<var class="var">S</var>, <var class="var">thresh</var>)</code><a class="copiable-link" href="#index-lu-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lu-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-lu-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lu-6">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(…, "vector")</code><a class="copiable-link" href="#index-lu-6"> ¶</a></span>
</dt> <dd>
 <p>Compute the LU decomposition of <var class="var">A</var>. </p> <p>If <var class="var">A</var> is full then subroutines from <small class="sc">LAPACK</small> are used, and if <var class="var">A</var> is sparse then <small class="sc">UMFPACK</small> is used. </p> <p>The result is returned in a permuted form, according to the optional return value <var class="var">P</var>. For example, given the matrix <code class="code"><var class="var">A</var> = [1, 2; 3, 4]</code>, </p> <pre class="example" data-language="matlab">[L, U, P] = lu (A)</pre> <p>returns </p> <pre class="example" data-language="matlab">L =

  1.00000  0.00000
  0.33333  1.00000

U =

  3.00000  4.00000
  0.00000  0.66667

P =

  0  1
  1  0</pre> <p>The matrix is not required to be square. </p> <p>When called with two or three output arguments and a sparse input matrix, <code class="code">lu</code> does not attempt to perform sparsity preserving column permutations. Called with a fourth output argument, the sparsity preserving column transformation <var class="var">Q</var> is returned, such that <code class="code"><var class="var">P</var> * <var class="var">A</var> * <var class="var">Q</var> = <var class="var">L</var> * <var class="var">U</var></code>. This is the <strong class="strong">preferred</strong> way to call <code class="code">lu</code> with sparse input matrices. </p> <p>Called with a fifth output argument and a sparse input matrix, <code class="code">lu</code> attempts to use a scaling factor <var class="var">R</var> on the input matrix such that <code class="code"><var class="var">P</var> * (<var class="var">R</var> \ <var class="var">A</var>) * <var class="var">Q</var> = <var class="var">L</var> * <var class="var">U</var></code>. This typically leads to a sparser and more stable factorization. </p> <p>An additional input argument <var class="var">thresh</var> that defines the pivoting threshold can be given. <var class="var">thresh</var> can be a scalar, in which case it defines the <small class="sc">UMFPACK</small> pivoting tolerance for both symmetric and unsymmetric cases. If <var class="var">thresh</var> is a 2-element vector, then the first element defines the pivoting tolerance for the unsymmetric <small class="sc">UMFPACK</small> pivoting strategy and the second for the symmetric strategy. By default, the values defined by <code class="code">spparms</code> are used ([0.1, 0.001]). </p> <p>Given the string argument <code class="code">"vector"</code>, <code class="code">lu</code> returns the values of <var class="var">P</var> and <var class="var">Q</var> as vector values, such that for full matrix, <code class="code"><var class="var">A</var>(<var class="var">P</var>,:) = <var class="var">L</var> * <var class="var">U</var></code>, and <code class="code"><var class="var">R</var>(<var class="var">P</var>,:)
* <var class="var">A</var>(:,<var class="var">Q</var>) = <var class="var">L</var> * <var class="var">U</var></code>. </p> <p>With two output arguments, returns the permuted forms of the upper and lower triangular matrices, such that <code class="code"><var class="var">A</var> = <var class="var">L</var> * <var class="var">U</var></code>. With one output argument <var class="var">y</var>, then the matrix returned by the <small class="sc">LAPACK</small> routines is returned. If the input matrix is sparse then the matrix <var class="var">L</var> is embedded into <var class="var">U</var> to give a return value similar to the full case. For both full and sparse matrices, <code class="code">lu</code> loses the permutation information. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFluupdate">luupdate</a>, <a class="ref" href="iterative-techniques.html#XREFilu">ilu</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFsvd">svd</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-luupdate">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>] =</code> <strong class="def-name">luupdate</strong> <code class="def-code-arguments">(<var class="var">L</var>, <var class="var">U</var>, <var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-luupdate"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-luupdate-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>] =</code> <strong class="def-name">luupdate</strong> <code class="def-code-arguments">(<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>, <var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-luupdate-1"> ¶</a></span>
</dt> <dd>
<p>Given an LU factorization of a real or complex matrix <var class="var">A</var> = <var class="var">L</var>*<var class="var">U</var>, <var class="var">L</var> lower unit trapezoidal and <var class="var">U</var> upper trapezoidal, return the LU factorization of <var class="var">A</var> + <var class="var">x</var>*<var class="var">y</var>.’, where <var class="var">x</var> and <var class="var">y</var> are column vectors (rank-1 update) or matrices with equal number of columns (rank-k update). </p> <p>Optionally, row-pivoted updating can be used by supplying a row permutation (pivoting) matrix <var class="var">P</var>; in that case, an updated permutation matrix is returned. Note that if <var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var> is a pivoted LU factorization as obtained by <code class="code">lu</code>: </p> <pre class="example" data-language="matlab">[L, U, P] = lu (A);</pre> <p>then a factorization of <code class="code"><var class="var">A</var>+<var class="var">x</var>*<var class="var">y</var>.'</code> can be obtained either as </p> <pre class="example" data-language="matlab">[L1, U1] = lu (L, U, P*x, y)</pre> <p>or </p> <pre class="example" data-language="matlab">[L1, U1, P1] = lu (L, U, P, x, y)</pre> <p>The first form uses the unpivoted algorithm, which is faster, but less stable. The second form uses a slower pivoted algorithm, which is more stable. </p> <p>The matrix case is done as a sequence of rank-1 updates; thus, for large enough k, it will be both faster and more accurate to recompute the factorization from scratch. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFcholupdate">cholupdate</a>, <a class="ref" href="#XREFqrupdate">qrupdate</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-qr">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Q</var>, <var class="var">R</var>] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-qr"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qr-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Q</var>, <var class="var">R</var>, <var class="var">P</var>] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-qr-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qr-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">X</var> =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>)  # non-sparse A</code><a class="copiable-link" href="#index-qr-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qr-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">R</var> =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>)  # sparse A</code><a class="copiable-link" href="#index-qr-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qr-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">X</var> =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>) # sparse A</code><a class="copiable-link" href="#index-qr-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qr-5">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">C</var>, <var class="var">R</var>] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-qr-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qr-6">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(…, 0)</code><a class="copiable-link" href="#index-qr-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qr-7">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(…, "econ")</code><a class="copiable-link" href="#index-qr-7"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qr-8">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(…, "vector")</code><a class="copiable-link" href="#index-qr-8"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qr-9">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(…, "matrix")</code><a class="copiable-link" href="#index-qr-9"> ¶</a></span>
</dt> <dd>
 <p>Compute the QR factorization of <var class="var">A</var>, using standard <small class="sc">LAPACK</small> subroutines. </p> <p>The QR factorization is </p> <pre class="example" data-language="matlab">Q * R = A</pre> <p>where <var class="var">Q</var> is an orthogonal matrix and <var class="var">R</var> is upper triangular. </p> <p>For example, given the matrix <code class="code"><var class="var">A</var> = [1, 2; 3, 4]</code>, </p> <pre class="example" data-language="matlab">[Q, R] = qr (A)</pre> <p>returns </p> <pre class="example" data-language="matlab">Q =

  -0.31623  -0.94868
  -0.94868   0.31623

R =

  -3.16228  -4.42719
   0.00000  -0.63246</pre> <p>which multiplied together return the original matrix </p> <pre class="example" data-language="matlab">Q * R
  ⇒
     1.0000   2.0000
     3.0000   4.0000</pre> <p>If just a single return value is requested then it is either <var class="var">R</var>, if <var class="var">A</var> is sparse, or <var class="var">X</var>, such that <code class="code"><var class="var">R</var> = triu (<var class="var">X</var>)</code> if <var class="var">A</var> is full. (Note: unlike most commands, the single return value is not the first return value when multiple values are requested.) </p> <p>If a third output <var class="var">P</var> is requested, then <code class="code">qr</code> calculates the permuted QR factorization </p> <pre class="example" data-language="matlab">Q * R = A * P</pre> <p>where <var class="var">Q</var> is an orthogonal matrix, <var class="var">R</var> is upper triangular, and <var class="var">P</var> is a permutation matrix. </p> <p>If <var class="var">A</var> is dense, the permuted QR factorization has the additional property that the diagonal entries of <var class="var">R</var> are ordered by decreasing magnitude. In other words, <code class="code">abs (diag (<var class="var">R</var>))</code> will be ordered from largest to smallest. </p> <p>If <var class="var">A</var> is sparse, <var class="var">P</var> is a fill-reducing ordering of the columns of <var class="var">A</var>. In that case, the diagonal entries of <var class="var">R</var> are not ordered by decreasing magnitude. </p> <p>For example, given the matrix <code class="code"><var class="var">A</var> = [1, 2; 3, 4]</code>, </p> <pre class="example" data-language="matlab">[Q, R, P] = qr (A)</pre> <p>returns </p> <pre class="example" data-language="matlab">Q =

  -0.44721  -0.89443
  -0.89443   0.44721

R =

  -4.47214  -3.13050
   0.00000   0.44721

P =

   0  1
   1  0</pre> <p>If the input matrix <var class="var">A</var> is sparse, the sparse QR factorization is computed by using <small class="sc">SPQR</small> or <small class="sc">CXSPARSE</small> (e.g., if <small class="sc">SPQR</small> is not available). Because the matrix <var class="var">Q</var> is, in general, a full matrix, it is recommended to request only one return value <var class="var">R</var>. In that case, the computation avoids the construction of <var class="var">Q</var> and returns a sparse <var class="var">R</var> such that <code class="code"><var class="var">R</var> = chol (<var class="var">A</var>' * <var class="var">A</var>)</code>. </p> <p>If <var class="var">A</var> is dense, an additional matrix <var class="var">B</var> is supplied and two return values are requested, then <code class="code">qr</code> returns <var class="var">C</var>, where <code class="code"><var class="var">C</var> = <var class="var">Q</var>' * <var class="var">B</var></code>. This allows the least squares approximation of <code class="code"><var class="var">A</var> \ <var class="var">B</var></code> to be calculated as </p> <pre class="example" data-language="matlab">[C, R] = qr (A, B)
X = R \ C</pre> <p>If <var class="var">A</var> is a sparse MxN matrix and an additional matrix <var class="var">B</var> is supplied, one or two return values are possible. If one return value <var class="var">X</var> is requested and M &lt; N, then <var class="var">X</var> is the minimum 2-norm solution of <code class="code"><var class="var">A</var> \ <var class="var">B</var></code>. If M &gt;= N, <var class="var">X</var> is the least squares approximation of <code class="code"><var class="var">A</var> \ <var class="var">B</var></code>. If two return values are requested, <var class="var">C</var> and <var class="var">R</var> have the same meaning as in the dense case (<var class="var">C</var> is dense and <var class="var">R</var> is sparse). The version with one return parameter should be preferred because it uses less memory and can handle rank-deficient matrices better. </p> <p>If the final argument is the string <code class="code">"vector"</code> then <var class="var">P</var> is a permutation vector (of the columns of <var class="var">A</var>) instead of a permutation matrix. In this case, the defining relationship is: </p> <pre class="example" data-language="matlab">Q * R = A(:, P)</pre> <p>The default, however, is to return a permutation matrix and this may be explicitly specified by using a final argument of <code class="code">"matrix"</code>. </p> <p>If the final argument is the scalar 0 or the string <code class="code">"econ"</code>, an economy factorization is returned. If the original matrix <var class="var">A</var> has size MxN and M &gt; N, then the economy factorization will calculate just N rows in <var class="var">R</var> and N columns in <var class="var">Q</var> and omit the zeros in <var class="var">R</var>. If M ≤ N, there is no difference between the economy and standard factorizations. When calculating an economy factorization and <var class="var">A</var> is dense, the output <var class="var">P</var> is always a vector rather than a matrix. If <var class="var">A</var> is sparse, output <var class="var">P</var> is a sparse permutation matrix. </p> <p>Background: The QR factorization has applications in the solution of least squares problems </p> <pre class="example" data-language="matlab">min norm (A*x - b)</pre> <p>for overdetermined systems of equations (i.e., <var class="var">A</var> is a tall, thin matrix). </p> <p>The permuted QR factorization <code class="code">[<var class="var">Q</var>, <var class="var">R</var>, <var class="var">P</var>] = qr (<var class="var">A</var>)</code> allows the construction of an orthogonal basis of <code class="code">span (A)</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFsvd">svd</a>, <a class="ref" href="#XREFqrupdate">qrupdate</a>, <a class="ref" href="#XREFqrinsert">qrinsert</a>, <a class="ref" href="#XREFqrdelete">qrdelete</a>, <a class="ref" href="#XREFqrshift">qrshift</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-qrupdate">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Q1</var>, <var class="var">R1</var>] =</code> <strong class="def-name">qrupdate</strong> <code class="def-code-arguments">(<var class="var">Q</var>, <var class="var">R</var>, <var class="var">u</var>, <var class="var">v</var>)</code><a class="copiable-link" href="#index-qrupdate"> ¶</a></span>
</dt> <dd>
<p>Update a QR factorization given update vectors or matrices. </p> <p>Given a QR factorization of a real or complex matrix <var class="var">A</var> = <var class="var">Q</var>*<var class="var">R</var>, <var class="var">Q</var> unitary and <var class="var">R</var> upper trapezoidal, return the QR factorization of <var class="var">A</var> + <var class="var">u</var>*<var class="var">v</var>’, where <var class="var">u</var> and <var class="var">v</var> are column vectors (rank-1 update) or matrices with equal number of columns (rank-k update). Notice that the latter case is done as a sequence of rank-1 updates; thus, for k large enough, it will be both faster and more accurate to recompute the factorization from scratch. </p> <p>The QR factorization supplied may be either full (Q is square) or economized (R is square). </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqrinsert">qrinsert</a>, <a class="ref" href="#XREFqrdelete">qrdelete</a>, <a class="ref" href="#XREFqrshift">qrshift</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-qrinsert">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Q1</var>, <var class="var">R1</var>] =</code> <strong class="def-name">qrinsert</strong> <code class="def-code-arguments">(<var class="var">Q</var>, <var class="var">R</var>, <var class="var">j</var>, <var class="var">x</var>, <var class="var">orient</var>)</code><a class="copiable-link" href="#index-qrinsert"> ¶</a></span>
</dt> <dd>
<p>Update a QR factorization given a row or column to insert in the original factored matrix. </p> <p>Given a QR factorization of a real or complex matrix <var class="var">A</var> = <var class="var">Q</var>*<var class="var">R</var>, <var class="var">Q</var> unitary and <var class="var">R</var> upper trapezoidal, return the QR factorization of [A(:,1:j-1) x A(:,j:n)], where <var class="var">u</var> is a column vector to be inserted into <var class="var">A</var> (if <var class="var">orient</var> is <code class="code">"col"</code>), or the QR factorization of [A(1:j-1,:);x;A(:,j:n)], where <var class="var">x</var> is a row vector to be inserted into <var class="var">A</var> (if <var class="var">orient</var> is <code class="code">"row"</code>). </p> <p>The default value of <var class="var">orient</var> is <code class="code">"col"</code>. If <var class="var">orient</var> is <code class="code">"col"</code>, <var class="var">u</var> may be a matrix and <var class="var">j</var> an index vector resulting in the QR factorization of a matrix <var class="var">B</var> such that B(:,<var class="var">j</var>) gives <var class="var">u</var> and B(:,<var class="var">j</var>) = [] gives <var class="var">A</var>. Notice that the latter case is done as a sequence of k insertions; thus, for k large enough, it will be both faster and more accurate to recompute the factorization from scratch. </p> <p>If <var class="var">orient</var> is <code class="code">"col"</code>, the QR factorization supplied may be either full (Q is square) or economized (R is square). </p> <p>If <var class="var">orient</var> is <code class="code">"row"</code>, full factorization is needed. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqrupdate">qrupdate</a>, <a class="ref" href="#XREFqrdelete">qrdelete</a>, <a class="ref" href="#XREFqrshift">qrshift</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-qrdelete">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Q1</var>, <var class="var">R1</var>] =</code> <strong class="def-name">qrdelete</strong> <code class="def-code-arguments">(<var class="var">Q</var>, <var class="var">R</var>, <var class="var">j</var>, <var class="var">orient</var>)</code><a class="copiable-link" href="#index-qrdelete"> ¶</a></span>
</dt> <dd>
<p>Update a QR factorization given a row or column to delete from the original factored matrix. </p> <p>Given a QR factorization of a real or complex matrix <var class="var">A</var> = <var class="var">Q</var>*<var class="var">R</var>, <var class="var">Q</var> unitary and <var class="var">R</var> upper trapezoidal, return the QR factorization of [A(:,1:j-1), U, A(:,j:n)], where <var class="var">u</var> is a column vector to be inserted into <var class="var">A</var> (if <var class="var">orient</var> is <code class="code">"col"</code>), or the QR factorization of [A(1:j-1,:);X;A(:,j:n)], where <var class="var">x</var> is a row <var class="var">orient</var> is <code class="code">"row"</code>). The default value of <var class="var">orient</var> is <code class="code">"col"</code>. </p> <p>If <var class="var">orient</var> is <code class="code">"col"</code>, <var class="var">j</var> may be an index vector resulting in the QR factorization of a matrix <var class="var">B</var> such that A(:,<var class="var">j</var>) = [] gives <var class="var">B</var>. Notice that the latter case is done as a sequence of k deletions; thus, for k large enough, it will be both faster and more accurate to recompute the factorization from scratch. </p> <p>If <var class="var">orient</var> is <code class="code">"col"</code>, the QR factorization supplied may be either full (Q is square) or economized (R is square). </p> <p>If <var class="var">orient</var> is <code class="code">"row"</code>, full factorization is needed. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqrupdate">qrupdate</a>, <a class="ref" href="#XREFqrinsert">qrinsert</a>, <a class="ref" href="#XREFqrshift">qrshift</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-qrshift">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Q1</var>, <var class="var">R1</var>] =</code> <strong class="def-name">qrshift</strong> <code class="def-code-arguments">(<var class="var">Q</var>, <var class="var">R</var>, <var class="var">i</var>, <var class="var">j</var>)</code><a class="copiable-link" href="#index-qrshift"> ¶</a></span>
</dt> <dd>
<p>Update a QR factorization given a range of columns to shift in the original factored matrix. </p> <p>Given a QR factorization of a real or complex matrix <var class="var">A</var> = <var class="var">Q</var>*<var class="var">R</var>, <var class="var">Q</var> unitary and <var class="var">R</var> upper trapezoidal, return the QR factorization of <var class="var">A</var>(:,p), where p is the permutation <br> <code class="code">p = [1:i-1, shift(i:j, 1), j+1:n]</code> if <var class="var">i</var> &lt; <var class="var">j</var> <br> or <br> <code class="code">p = [1:j-1, shift(j:i,-1), i+1:n]</code> if <var class="var">j</var> &lt; <var class="var">i</var>. <br> </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqrupdate">qrupdate</a>, <a class="ref" href="#XREFqrinsert">qrinsert</a>, <a class="ref" href="#XREFqrdelete">qrdelete</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-qz">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>, <var class="var">V</var>, <var class="var">W</var>] =</code> <strong class="def-name">qz</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-qz"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qz-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>, <var class="var">V</var>, <var class="var">W</var>] =</code> <strong class="def-name">qz</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-qz-1"> ¶</a></span>
</dt> <dd>
<p>Compute the QZ decomposition of a generalized eigenvalue problem. </p> <p>The generalized eigenvalue problem is defined as </p> <p><em class="math">A x = <var class="var">lambda</var> B x</em> </p> <p>There are two calling forms of the function: </p> <ol class="enumerate"> <li> <code class="code">[<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>, <var class="var">V</var>, <var class="var">W</var>, <var class="var">lambda</var>] = qz (<var class="var">A</var>, <var class="var">B</var>)</code> <p>Compute the complex QZ decomposition, generalized eigenvectors, and generalized eigenvalues. </p> <pre class="example" data-language="matlab">AA = Q * A * Z, BB = Q * B * Z
A * V * diag (diag (BB)) = B * V * diag (diag (AA))
diag (diag (BB)) * W' * A = diag (diag (AA)) * W' * B</pre> <p>with <var class="var">AA</var> and <var class="var">BB</var> upper triangular, and <var class="var">Q</var> and <var class="var">Z</var> unitary. The matrices <var class="var">V</var> and <var class="var">W</var> respectively contain the right and left generalized eigenvectors. </p> </li>
<li> <code class="code">[<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Z</var> {, <var class="var">lambda</var>}] = qz (<var class="var">A</var>, <var class="var">B</var>, <var class="var">opt</var>)</code> <p>The <var class="var">opt</var> argument must be equal to either <code class="code">"real"</code> or <code class="code">"complex"</code>. If it is equal to <code class="code">"complex"</code>, then this calling form is equivalent to the first one with only two input arguments. </p> <p>If <var class="var">opt</var> is equal to <code class="code">"real"</code>, then the real QZ decomposition is computed. In particular, <var class="var">AA</var> is only guaranteed to be quasi-upper triangular with 1-by-1 and 2-by-2 blocks on the diagonal, and <var class="var">Q</var> and <var class="var">Z</var> are orthogonal. The identities mentioned above for right and left generalized eigenvectors are only verified if <var class="var">AA</var> is upper triangular (i.e., when all the generalized eigenvalues are real, in which case the real and complex QZ coincide). </p> </li>
</ol> <p>Note: <code class="code">qz</code> performs permutation balancing, but not scaling (see <a class="pxref" href="basic-matrix-functions.html#XREFbalance"><code class="code">balance</code></a>), which may be lead to less accurate results than <code class="code">eig</code>. The order of output arguments was selected for compatibility with <small class="sc">MATLAB</small>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="basic-matrix-functions.html#XREFeig">eig</a>, <a class="ref" href="basic-matrix-functions.html#XREFgsvd">gsvd</a>, <a class="ref" href="basic-matrix-functions.html#XREFbalance">balance</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqzhess">qzhess</a>, <a class="ref" href="#XREFschur">schur</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-qzhess">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">aa</var>, <var class="var">bb</var>, <var class="var">q</var>, <var class="var">z</var>] =</code> <strong class="def-name">qzhess</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-qzhess"> ¶</a></span>
</dt> <dd>
<p>Compute the Hessenberg-triangular decomposition of the matrix pencil <code class="code">(<var class="var">A</var>, <var class="var">B</var>)</code>, returning <code class="code"><var class="var">aa</var> = <var class="var">q</var> * <var class="var">A</var> * <var class="var">z</var></code>, <code class="code"><var class="var">bb</var> = <var class="var">q</var> * <var class="var">B</var> * <var class="var">z</var></code>, with <var class="var">q</var> and <var class="var">z</var> orthogonal. </p> <p>For example: </p> <pre class="example" data-language="matlab">[aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
  ⇒ aa =
      -3.02244  -4.41741
       0.92998   0.69749
  ⇒ bb =
      -8.60233  -9.99730
       0.00000  -0.23250
  ⇒ q =
      -0.58124  -0.81373
      -0.81373   0.58124
  ⇒ z =
     Diagonal Matrix
       1   0
       0   1</pre> <p>The Hessenberg-triangular decomposition is the first step in Moler and Stewart’s QZ decomposition algorithm. </p> <p>Algorithm taken from Golub and Van Loan, <cite class="cite">Matrix Computations, 2nd edition</cite>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFsvd">svd</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-schur">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">schur</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-schur"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-schur-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">schur</strong> <code class="def-code-arguments">(<var class="var">A</var>, "real")</code><a class="copiable-link" href="#index-schur-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-schur-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">schur</strong> <code class="def-code-arguments">(<var class="var">A</var>, "complex")</code><a class="copiable-link" href="#index-schur-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-schur-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">schur</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-schur-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-schur-4">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">U</var>, <var class="var">S</var>] =</code> <strong class="def-name">schur</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-schur-4"> ¶</a></span>
</dt> <dd>
 <p>Compute the Schur decomposition of <var class="var">A</var>. </p> <p>The Schur decomposition of a square matrix <var class="var">A</var> is defined as </p> <pre class="example" data-language="matlab">S = U' * A * U</pre> <p>where <var class="var">U</var> is a unitary matrix (<code class="code"><var class="var">U</var>'* <var class="var">U</var></code> is identity) and <var class="var">S</var> is upper triangular. The eigenvalues of <var class="var">A</var> (and <var class="var">S</var>) are the diagonal elements of <var class="var">S</var>. If the matrix <var class="var">A</var> is real, then the real Schur decomposition is computed, in which the matrix <var class="var">U</var> is orthogonal and <var class="var">S</var> is block upper triangular with blocks of size at most <code class="code">2 x 2</code> along the diagonal. </p> <p>The default for real matrices is a real Schur decomposition. A complex decomposition may be forced by passing the flag <code class="code">"complex"</code>. </p> <p>The eigenvalues are optionally ordered along the diagonal according to the value of <var class="var">opt</var>: </p> <dl class="table"> <dt><code class="code"><var class="var">opt</var> = "a"</code></dt> <dd>
<p>Move eigenvalues with negative real parts to the leading block of <var class="var">S</var>. Mnemonic: <code class="code">"a"</code> for Algebraic Riccati Equations, where this ordering is useful. </p> </dd> <dt><code class="code"><var class="var">opt</var> = "d"</code></dt> <dd>
<p>Move eigenvalues with magnitude less than one to the leading block of <var class="var">S</var>. Mnemonic: <code class="code">"d"</code> for Discrete Algebraic Riccati Equations, where this ordering is useful. </p> </dd> <dt><code class="code"><var class="var">opt</var> = "u"</code></dt> <dd><p>Unordered. No particular ordering of eigenvalues (default). </p></dd> </dl> <p>The leading <var class="var">k</var> columns of <var class="var">U</var> always span the <var class="var">A</var>-invariant subspace corresponding to the <var class="var">k</var> leading eigenvalues of <var class="var">S</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFrsf2csf">rsf2csf</a>, <a class="ref" href="#XREFordschur">ordschur</a>, <a class="ref" href="#XREFordeig">ordeig</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFsvd">svd</a>, <a class="ref" href="basic-matrix-functions.html#XREFeig">eig</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-rsf2csf">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">U</var>, <var class="var">T</var>] =</code> <strong class="def-name">rsf2csf</strong> <code class="def-code-arguments">(<var class="var">UR</var>, <var class="var">TR</var>)</code><a class="copiable-link" href="#index-rsf2csf"> ¶</a></span>
</dt> <dd>
<p>Convert a real, upper quasi-triangular Schur form <var class="var">TR</var> to a complex, upper triangular Schur form <var class="var">T</var>. </p> <p>Note that the following relations hold: </p> <p><code class="code"><var class="var">UR</var> * <var class="var">TR</var> * <var class="var">UR</var>' = <var class="var">U</var> * <var class="var">T</var> * <var class="var">U</var>'</code> and <code class="code"><var class="var">U</var>' * <var class="var">U</var></code> is the identity matrix I. </p> <p>Note also that <var class="var">U</var> and <var class="var">T</var> are not unique. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFschur">schur</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ordschur">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">UR</var>, <var class="var">SR</var>] =</code> <strong class="def-name">ordschur</strong> <code class="def-code-arguments">(<var class="var">U</var>, <var class="var">S</var>, <var class="var">select</var>)</code><a class="copiable-link" href="#index-ordschur"> ¶</a></span>
</dt> <dd>
<p>Reorder the real Schur factorization (<var class="var">U</var>,<var class="var">S</var>) obtained with the <code class="code">schur</code> function, so that selected eigenvalues appear in the upper left diagonal blocks of the quasi triangular Schur matrix. </p> <p>The logical vector <var class="var">select</var> specifies the selected eigenvalues as they appear along <var class="var">S</var>’s diagonal. </p> <p>For example, given the matrix <code class="code"><var class="var">A</var> = [1, 2; 3, 4]</code>, and its Schur decomposition </p> <pre class="example" data-language="matlab">[U, S] = schur (A)</pre> <p>which returns </p> <pre class="example" data-language="matlab">U =

  -0.82456  -0.56577
   0.56577  -0.82456

S =

  -0.37228  -1.00000
   0.00000   5.37228</pre> <p>It is possible to reorder the decomposition so that the positive eigenvalue is in the upper left corner, by doing: </p> <pre class="example" data-language="matlab">[U, S] = ordschur (U, S, [0,1])</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFordeig">ordeig</a>, <a class="ref" href="#XREFordqz">ordqz</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ordqz">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">AR</var>, <var class="var">BR</var>, <var class="var">QR</var>, <var class="var">ZR</var>] =</code> <strong class="def-name">ordqz</strong> <code class="def-code-arguments">(<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>, <var class="var">keyword</var>)</code><a class="copiable-link" href="#index-ordqz"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ordqz-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">AR</var>, <var class="var">BR</var>, <var class="var">QR</var>, <var class="var">ZR</var>] =</code> <strong class="def-name">ordqz</strong> <code class="def-code-arguments">(<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>, <var class="var">select</var>)</code><a class="copiable-link" href="#index-ordqz-1"> ¶</a></span>
</dt> <dd>
<p>Reorder the QZ decomposition of a generalized eigenvalue problem. </p> <p>The generalized eigenvalue problem is defined as </p> <p><em class="math">A x = <var class="var">lambda</var> B x</em> </p> <p>Its generalized Schur decomposition is computed using the <code class="code">qz</code> algorithm: </p> <p><code class="code">[<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>] = qz (<var class="var">A</var>, <var class="var">B</var>)</code> </p> <p>where <var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, and <var class="var">Z</var> fulfill </p> <pre class="example" data-language="matlab">AA = Q * A * Z, BB = Q * B * Z</pre> <p>The <code class="code">ordqz</code> function computes a unitary transformation <var class="var">QR</var> and <var class="var">ZR</var> such that the order of the eigenvalue on the diagonal of <var class="var">AA</var> and <var class="var">BB</var> is changed. The resulting reordered matrices <var class="var">AR</var> and <var class="var">BR</var> fulfill: </p> <pre class="example" data-language="matlab">AR = QR * A * ZR, BR = QR * B * ZR</pre> <p>The function can either be called with the <var class="var">keyword</var> argument which selects the eigenvalues in the top left block of <var class="var">AR</var> and <var class="var">BR</var> in the following way: </p> <dl class="table"> <dt>
<code class="code">"S"</code>, <code class="code">"udi"</code>
</dt> <dd>
<p>small: leading block has all |<var class="var">lambda</var>| &lt; 1 </p> </dd> <dt>
<code class="code">"B"</code>, <code class="code">"udo"</code>
</dt> <dd>
<p>big: leading block has all |<var class="var">lambda</var>| ≥ 1 </p> </dd> <dt>
<code class="code">"-"</code>, <code class="code">"lhp"</code>
</dt> <dd>
<p>negative real part: leading block has all eigenvalues in the open left half-plane </p> </dd> <dt>
<code class="code">"+"</code>, <code class="code">"rhp"</code>
</dt> <dd><p>non-negative real part: leading block has all eigenvalues in the closed right half-plane </p></dd> </dl> <p>If a logical vector <var class="var">select</var> is given instead of a keyword the <code class="code">ordqz</code> function reorders all eigenvalues <code class="code">k</code> to the left block for which <code class="code">select(k)</code> is true. </p> <p>Note: The keywords are compatible with the ones from <code class="code">qr</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="basic-matrix-functions.html#XREFeig">eig</a>, <a class="ref" href="#XREFordeig">ordeig</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFordschur">ordschur</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ordeig">
<span class="category-def">: </span><span><code class="def-type"><var class="var">lambda</var> =</code> <strong class="def-name">ordeig</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-ordeig"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ordeig-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">lambda</var> =</code> <strong class="def-name">ordeig</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-ordeig-1"> ¶</a></span>
</dt> <dd>
<p>Return the eigenvalues of quasi-triangular matrices in their order of appearance in the matrix <var class="var">A</var>. </p> <p>The quasi-triangular matrix <var class="var">A</var> is usually the result of a Schur factorization. If called with a second input <var class="var">B</var> then the generalized eigenvalues of the pair <var class="var">A</var>, <var class="var">B</var> are returned in the order of appearance of the matrix <code class="code"><var class="var">A</var>-<var class="var">lambda</var>*<var class="var">B</var></code>. The pair <var class="var">A</var>, <var class="var">B</var> is usually the result of a QZ decomposition. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFordschur">ordschur</a>, <a class="ref" href="#XREFordqz">ordqz</a>, <a class="ref" href="basic-matrix-functions.html#XREFeig">eig</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFqz">qz</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-subspace">
<span class="category-def">: </span><span><code class="def-type"><var class="var">angle</var> =</code> <strong class="def-name">subspace</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-subspace"> ¶</a></span>
</dt> <dd><p>Determine the largest principal angle between two subspaces spanned by the columns of matrices <var class="var">A</var> and <var class="var">B</var>. </p></dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-svd">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">svd</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-svd"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-svd-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">U</var>, <var class="var">S</var>, <var class="var">V</var>] =</code> <strong class="def-name">svd</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-svd-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-svd-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">U</var>, <var class="var">S</var>, <var class="var">V</var>] =</code> <strong class="def-name">svd</strong> <code class="def-code-arguments">(<var class="var">A</var>, "econ")</code><a class="copiable-link" href="#index-svd-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-svd-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">U</var>, <var class="var">S</var>, <var class="var">V</var>] =</code> <strong class="def-name">svd</strong> <code class="def-code-arguments">(<var class="var">A</var>, 0)</code><a class="copiable-link" href="#index-svd-3"> ¶</a></span>
</dt> <dd>
 <p>Compute the singular value decomposition of <var class="var">A</var>. </p> <p>The singular value decomposition is defined by the relation </p> <pre class="example" data-language="matlab">A = U*S*V'</pre> <p>The function <code class="code">svd</code> normally returns only the vector of singular values. When called with three return values, it computes <var class="var">U</var>, <var class="var">S</var>, and <var class="var">V</var>. For example, </p> <pre class="example" data-language="matlab">svd (hilb (3))</pre> <p>returns </p> <pre class="example" data-language="matlab">ans =

  1.4083189
  0.1223271
  0.0026873</pre> <p>and </p> <pre class="example" data-language="matlab">[u, s, v] = svd (hilb (3))</pre> <p>returns </p> <pre class="example" data-language="matlab">u =

  -0.82704   0.54745   0.12766
  -0.45986  -0.52829  -0.71375
  -0.32330  -0.64901   0.68867

s =

  1.40832  0.00000  0.00000
  0.00000  0.12233  0.00000
  0.00000  0.00000  0.00269

v =

  -0.82704   0.54745   0.12766
  -0.45986  -0.52829  -0.71375
  -0.32330  -0.64901   0.68867</pre> <p>When given a second argument that is not 0, <code class="code">svd</code> returns an economy-sized decomposition, eliminating the unnecessary rows or columns of <var class="var">U</var> or <var class="var">V</var>. </p> <p>If the second argument is exactly 0, then the choice of decomposition is based on the matrix <var class="var">A</var>. If <var class="var">A</var> has more rows than columns then an economy-sized decomposition is returned, otherwise a regular decomposition is calculated. </p> <p>Algorithm Notes: When calculating the full decomposition (left and right singular matrices in addition to singular values) there is a choice of two routines in <small class="sc">LAPACK</small>. The default routine used by Octave is <code class="code">gesvd</code>. The alternative is <code class="code">gesdd</code> which is 5X faster, but may use more memory and may be inaccurate for some input matrices. There is a third routine <code class="code">gejsv</code>, suitable for better accuracy at extreme scale. See the documentation for <code class="code">svd_driver</code> for more information on choosing a driver. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsvd_005fdriver">svd_driver</a>, <a class="ref" href="sparse-linear-algebra.html#XREFsvds">svds</a>, <a class="ref" href="basic-matrix-functions.html#XREFeig">eig</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-svd_005fdriver">
<span class="category-def">: </span><span><code class="def-type"><var class="var">val</var> =</code> <strong class="def-name">svd_driver</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-svd_005fdriver"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-svd_005fdriver-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">old_val</var> =</code> <strong class="def-name">svd_driver</strong> <code class="def-code-arguments">(<var class="var">new_val</var>)</code><a class="copiable-link" href="#index-svd_005fdriver-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-svd_005fdriver-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">old_val</var> =</code> <strong class="def-name">svd_driver</strong> <code class="def-code-arguments">(<var class="var">new_val</var>, "local")</code><a class="copiable-link" href="#index-svd_005fdriver-2"> ¶</a></span>
</dt> <dd>
<p>Query or set the underlying <small class="sc">LAPACK</small> driver used by <code class="code">svd</code>. </p> <p>Currently recognized values are <code class="code">"gesdd"</code>, <code class="code">"gesvd"</code>, and <code class="code">"gejsv"</code>. The default is <code class="code">"gesvd"</code>. </p> <p>When called from inside a function with the <code class="code">"local"</code> option, the variable is changed locally for the function and any subroutines it calls. The original variable value is restored when exiting the function. </p> <p>Algorithm Notes: The <small class="sc">LAPACK</small> library routines <code class="code">gesvd</code> and <code class="code">gesdd</code> are different only when calculating the full singular value decomposition (left and right singular matrices as well as singular values). When calculating just the singular values the following discussion is not relevant. </p> <p>The newer <code class="code">gesdd</code> routine is based on a Divide-and-Conquer algorithm that is 5X faster than the alternative <code class="code">gesvd</code>, which is based on QR factorization. However, the new algorithm can use significantly more memory. For an MxN input matrix the memory usage is of order O(min(M,N) ^ 2), whereas the alternative is of order O(max(M,N)). </p> <p>The routine <code class="code">gejsv</code> uses a preconditioned Jacobi SVD algorithm. Unlike <code class="code">gesvd</code> and <code class="code">gesdd</code>, in <code class="code">gejsv</code>, there is no bidiagonalization step that could contaminate accuracy in some extreme cases. Also, <code class="code">gejsv</code> is known to be optimally accurate in some sense. However, the speed is slower (single threaded at its core) and uses more memory (O(min(M,N) ^ 2 + M + N)). </p> <p>Beyond speed and memory issues, there have been instances where some input matrices were not accurately decomposed by <code class="code">gesdd</code>. See currently active bug <a class="url" href="https://savannah.gnu.org/bugs/?55564">https://savannah.gnu.org/bugs/?55564</a>. Until these accuracy issues are resolved in a new version of the <small class="sc">LAPACK</small> library, the default driver in Octave has been set to <code class="code">"gesvd"</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsvd">svd</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-housh">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">housv</var>, <var class="var">beta</var>, <var class="var">zer</var>] =</code> <strong class="def-name">housh</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">j</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-housh"> ¶</a></span>
</dt> <dd>
<p>Compute Householder reflection vector <var class="var">housv</var> to reflect <var class="var">x</var> to be the j-th column of identity, i.e., </p> <pre class="example" data-language="matlab">(I - beta*housv*housv')x =  norm (x)*e(j) if x(j) &lt; 0,
(I - beta*housv*housv')x = -norm (x)*e(j) if x(j) &gt;= 0</pre> <p>Inputs </p> <dl class="table"> <dt><var class="var">x</var></dt> <dd>
<p>vector </p> </dd> <dt><var class="var">j</var></dt> <dd>
<p>index into vector </p> </dd> <dt><var class="var">z</var></dt> <dd><p>threshold for zero (usually should be the number 0) </p></dd> </dl> <p>Outputs (see Golub and Van Loan): </p> <dl class="table"> <dt><var class="var">beta</var></dt> <dd>
<p>If beta = 0, then no reflection need be applied (zer set to 0) </p> </dd> <dt><var class="var">housv</var></dt> <dd><p>householder vector </p></dd> </dl> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-krylov">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">u</var>, <var class="var">h</var>, <var class="var">nu</var>] =</code> <strong class="def-name">krylov</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">V</var>, <var class="var">k</var>, <var class="var">eps1</var>, <var class="var">pflg</var>)</code><a class="copiable-link" href="#index-krylov"> ¶</a></span>
</dt> <dd>
<p>Construct an orthogonal basis <var class="var">u</var> of a block Krylov subspace. </p> <p>The block Krylov subspace has the following form: </p> <pre class="example" data-language="matlab">[v a*v a^2*v ... a^(k+1)*v]</pre> <p>The construction is made with Householder reflections to guard against loss of orthogonality. </p> <p>If <var class="var">V</var> is a vector, then <var class="var">h</var> contains the Hessenberg matrix such that <code class="code">a*u == u*h+rk*ek'</code>, in which <code class="code">rk = a*u(:,k)-u*h(:,k)</code>, and <code class="code">ek'</code> is the vector <code class="code">[0, 0, …, 1]</code> of length <var class="var">k</var>. Otherwise, <var class="var">h</var> is meaningless. </p> <p>If <var class="var">V</var> is a vector and <var class="var">k</var> is greater than <code class="code">length (A) - 1</code>, then <var class="var">h</var> contains the Hessenberg matrix such that <code class="code">a*u == u*h</code>. </p> <p>The value of <var class="var">nu</var> is the dimension of the span of the Krylov subspace (based on <var class="var">eps1</var>). </p> <p>If <var class="var">b</var> is a vector and <var class="var">k</var> is greater than <var class="var">m-1</var>, then <var class="var">h</var> contains the Hessenberg decomposition of <var class="var">A</var>. </p> <p>The optional parameter <var class="var">eps1</var> is the threshold for zero. The default value is 1e-12. </p> <p>If the optional parameter <var class="var">pflg</var> is nonzero, row pivoting is used to improve numerical behavior. The default value is 0. </p> <p>Reference: A. Hodel, P. Misra, <cite class="cite">Partial Pivoting in the Computation of Krylov Subspaces of Large Sparse Systems</cite>, Proceedings of the 42nd IEEE Conference on Decision and Control, December 2003. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="functions-of-a-matrix.html">Functions of a Matrix</a>, Previous: <a href="basic-matrix-functions.html">Basic Matrix Functions</a>, Up: <a href="linear-algebra.html">Linear Algebra</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Matrix-Factorizations.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Matrix-Factorizations.html</a>
  </p>
</div>
