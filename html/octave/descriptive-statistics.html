<div class="section" id="Descriptive-Statistics">   <h1 class="section">26.1 Descriptive Statistics</h1> <p>One principal goal of descriptive statistics is to represent the essence of a large data set concisely. Octave provides the mean, median, and mode functions which all summarize a data set with just a single number corresponding to the central tendency of the data. </p> <dl class="def"> <dt id="index-mean">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>mean</strong> <em>(<var>x</var>)</em><a href="#index-mean" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-mean-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>mean</strong> <em>(<var>x</var>, 'all')</em><a href="#index-mean-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-mean-2">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>mean</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-mean-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-mean-3">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>mean</strong> <em>(…, '<var>outtype</var>')</em><a href="#index-mean-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-mean-4">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>mean</strong> <em>(…, '<var>nanflag</var>')</em><a href="#index-mean-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the mean of the elements of <var>x</var>. </p> <ul> <li> If <var>x</var> is a vector, then <code>mean (<var>x</var>)</code> returns the mean of the elements in <var>x</var> defined as <pre class="example" data-language="matlab">mean (x) = SUM_i x(i) / N</pre> <p>where <em class="math">N</em> is the number of elements in the <var>x</var> vector. </p> </li>
<li> If <var>x</var> is a matrix, then <code>mean</code> returns a row vector with the mean of each column in <var>x</var>. </li>
<li> If <var>x</var> is a multi-dimensional array, then <code>mean</code> operates along the first non-singleton dimension of <var>x</var>. </li>
</ul> <p>The optional input <var>dim</var> forces <code>mean</code> to operate over the specified dimension(s). <var>dim</var> can either be a scalar dimension or a vector of non-repeating dimensions. Dimensions must be positive integers, and the mean is calculated over the array slice defined by <var>dim</var>. </p> <p>Specifying dimension <code>"all"</code> will force <code>mean</code> to operate on all elements of <var>x</var>, and is equivalent to <code>mean (<var>x</var>(:))</code>. </p> <p>The optional input <var>outtype</var> specifies the data type that is returned. Valid values are: </p> <dl compact> <dt><span><code>'default'</code> : Output is of type double, unless the input is</span></dt> <dd>
<p>single in which case the output is of type single. </p> </dd> <dt><span><code>'double'</code> : Output is of type double.</span></dt> <dt><span><code>'native'</code> : Output is of the same type as the input</span></dt> <dd>
<p>(<code>class (<var>x</var>)</code>), unless the input is logical in which case the output is of type double. </p> </dd> </dl> <p>The optional input <var>nanflag</var> specifies whether to include/exclude NaN values from the calculation. By default, NaN values are included in the calculation (<var>nanflag</var> has the value <code>'includenan'</code>). To exclude NaN values, set the value of <var>nanflag</var> to <code>'omitnan'</code>. </p> <p><strong>See also:</strong> <a href="#XREFmedian">median</a>, <a href="#XREFmode">mode</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-median">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>median</strong> <em>(<var>x</var>)</em><a href="#index-median" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-median-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>median</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-median-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the median value of the elements of the vector <var>x</var>. </p> <p>When the elements of <var>x</var> are sorted, say <code><var>s</var> = sort (<var>x</var>)</code>, the median is defined as </p> <pre class="example" data-language="matlab">|  s(ceil(N/2))           N odd
median (x) = |
             | (s(N/2) + s(N/2+1))/2   N even</pre> <p>If <var>x</var> is of a discrete type such as integer or logical, then the case of even <em class="math">N</em> rounds up (or toward <code>true</code>). </p> <p>If <var>x</var> is a matrix, compute the median value for each column and return them in a row vector. </p> <p>If the optional <var>dim</var> argument is given, operate along this dimension. </p> <p><strong>See also:</strong> <a href="#XREFmean">mean</a>, <a href="#XREFmode">mode</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-mode">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>mode</strong> <em>(<var>x</var>)</em><a href="#index-mode" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-mode-1">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>mode</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-mode-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-mode-2">
<span class="category">: </span><span><em>[<var>m</var>, <var>f</var>, <var>c</var>] =</em> <strong>mode</strong> <em>(…)</em><a href="#index-mode-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the most frequently occurring value in a dataset (mode). </p> <p><code>mode</code> determines the frequency of values along the first non-singleton dimension and returns the value with the highest frequency. If two, or more, values have the same frequency <code>mode</code> returns the smallest. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The return variable <var>f</var> is the number of occurrences of the mode in the dataset. </p> <p>The cell array <var>c</var> contains all of the elements with the maximum frequency. </p> <p><strong>See also:</strong> <a href="#XREFmean">mean</a>, <a href="#XREFmedian">median</a>. </p>
</dd>
</dl> <p>Using just one number, such as the mean, to represent an entire data set may not give an accurate picture of the data. One way to characterize the fit is to measure the dispersion of the data. Octave provides several functions for measuring dispersion. </p> <dl class="def"> <dt id="index-bounds">
<span class="category">: </span><span><em>[<var>s</var>, <var>l</var>] =</em> <strong>bounds</strong> <em>(<var>x</var>)</em><a href="#index-bounds" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bounds-1">
<span class="category">: </span><span><em>[<var>s</var>, <var>l</var>] =</em> <strong>bounds</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-bounds-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bounds-2">
<span class="category">: </span><span><em>[<var>s</var>, <var>l</var>] =</em> <strong>bounds</strong> <em>(…, "nanflag")</em><a href="#index-bounds-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the smallest and largest values of the input data <var>x</var>. </p> <p>If <var>x</var> is a vector, the bounds are calculated over the elements of <var>x</var>. If <var>x</var> is a matrix, the bounds are calculated for each column. For a multi-dimensional array, the bounds are calculated over the first non-singleton dimension. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional argument <code>"nanflag"</code> defaults to <code>"omitnan"</code> which does not include NaN values in the result. If the argument <code>"includenan"</code> is given, and there is a NaN present, then the result for both smallest (<var>s</var>) and largest (<var>l</var>) elements will be NaN. </p> <p>The bounds are a quickly computed measure of the dispersion of a data set, but are less accurate than <code>iqr</code> if there are outlying data points. </p> <p><strong>See also:</strong> <a href="#XREFrange">range</a>, <a href="#XREFiqr">iqr</a>, <a href="#XREFmad">mad</a>, <a href="#XREFstd">std</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-range">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>range</strong> <em>(<var>x</var>)</em><a href="#index-range" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-range-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>range</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-range-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the range, i.e., the difference between the maximum and the minimum of the input data. </p> <p>If <var>x</var> is a vector, the range is calculated over the elements of <var>x</var>. If <var>x</var> is a matrix, the range is calculated over each column of <var>x</var>. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The range is a quickly computed measure of the dispersion of a data set, but is less accurate than <code>iqr</code> if there are outlying data points. </p> <p><strong>See also:</strong> <a href="#XREFbounds">bounds</a>, <a href="#XREFiqr">iqr</a>, <a href="#XREFmad">mad</a>, <a href="#XREFstd">std</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-iqr">
<span class="category">: </span><span><em><var>Z</var> =</em> <strong>iqr</strong> <em>(<var>x</var>)</em><a href="#index-iqr" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-iqr-1">
<span class="category">: </span><span><em><var>Z</var> =</em> <strong>iqr</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-iqr-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-iqr-2">
<span class="category">: </span><span><em><var>Z</var> =</em> <strong>iqr</strong> <em>(<var>x</var>, <code>"ALL"</code>)</em><a href="#index-iqr-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the interquartile range of <var>x</var>, defined as the distance between the 25th and 75th percentile values of <var>x</var> calculated using: quantile (x, [0.25 0.75]) </p> <p>If <var>x</var> is a vector, <code>iqr (<var>x</var>)</code> will operate on the data in <var>x</var>. </p> <p>If <var>x</var> is a matrix, <code>iqr (<var>x</var>)</code> will operate independently on each column in <var>x</var> returning a row vector <var>Z</var>. </p> <p>If <var>x</var> is a n-dimensional array, <code>iqr (<var>x</var>)</code> will operate independently on the first non-singleton dimension in <var>x</var>, returning an array <var>Z</var> the same shape as <var>x</var> with the non-singleton dimenion reduced to 1. </p> <p>The optional variable <var>dim</var> can be used to force <code>iqr</code> to operate over the specified dimension. <var>dim</var> can either be a scalar dimension or a vector of non-repeating dimensions over which to operate. In either case <var>dim</var> must be positive integers. A vector <var>dim</var> concatenates all specified dimensions for independent operation by <code>iqr</code>. </p> <p>Specifying dimension <code>"ALL"</code> will force <code>iqr</code> to operate on all elements of <var>x</var>, and is equivalent to <code>iqr (<var>x</var>(:))</code>. Similarly, specifying a vector dimension including all non-singleton dimensions of <var>x</var> is equivalent to <code>iqr (<var>x</var>, <code>"ALL"</code>)</code>. </p> <p>If <var>x</var> is a scalar, or only singleton dimensions are specified for <var>dim</var>, the output will be <code>zeros (size (<var>x</var>))</code>. </p> <p>As a measure of dispersion, the interquartile range is less affected by outliers than either <code>range</code> or <code>std</code>. </p> <p><strong>See also:</strong> <a href="#XREFbounds">bounds</a>, <a href="#XREFmad">mad</a>, <a href="#XREFrange">range</a>, <a href="#XREFstd">std</a>, <a href="#XREFprctile">prctile</a>, <a href="#XREFquantile">quantile</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-mad">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>mad</strong> <em>(<var>x</var>)</em><a href="#index-mad" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-mad-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>mad</strong> <em>(<var>x</var>, <var>opt</var>)</em><a href="#index-mad-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-mad-2">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>mad</strong> <em>(<var>x</var>, <var>opt</var>, <var>dim</var>)</em><a href="#index-mad-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the mean or median absolute deviation of the elements of <var>x</var>. </p> <p>The mean absolute deviation is defined as </p> <pre class="example" data-language="matlab">mad = mean (abs (x - mean (x)))</pre> <p>The median absolute deviation is defined as </p> <pre class="example" data-language="matlab">mad = median (abs (x - median (x)))</pre> <p>If <var>x</var> is a matrix, compute <code>mad</code> for each column and return results in a row vector. For a multi-dimensional array, the calculation is done over the first non-singleton dimension. </p> <p>The optional argument <var>opt</var> determines whether mean or median absolute deviation is calculated. The default is 0 which corresponds to mean absolute deviation; A value of 1 corresponds to median absolute deviation. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>As a measure of dispersion, <code>mad</code> is less affected by outliers than <code>std</code>. </p> <p><strong>See also:</strong> <a href="#XREFbounds">bounds</a>, <a href="#XREFrange">range</a>, <a href="#XREFiqr">iqr</a>, <a href="#XREFstd">std</a>, <a href="#XREFmean">mean</a>, <a href="#XREFmedian">median</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-meansq">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>meansq</strong> <em>(<var>x</var>)</em><a href="#index-meansq" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-meansq-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>meansq</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-meansq-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the mean square of the elements of the vector <var>x</var>. </p> <p>The mean square is defined as </p> <pre class="example" data-language="matlab">meansq (x) = 1/N SUM_i x(i)^2</pre> <p>where <em class="math">N</em> is the length of the <var>x</var> vector. </p> <p>If <var>x</var> is a matrix, return a row vector containing the mean square of each column. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p><strong>See also:</strong> <a href="#XREFvar">var</a>, <a href="#XREFstd">std</a>, <a href="#XREFmoment">moment</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-std">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>std</strong> <em>(<var>x</var>)</em><a href="#index-std" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-std-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>std</strong> <em>(<var>x</var>, <var>w</var>)</em><a href="#index-std-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-std-2">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>std</strong> <em>(<var>x</var>, <var>w</var>, <var>dim</var>)</em><a href="#index-std-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-std-3">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>std</strong> <em>(<var>x</var>, <var>w</var>, <code>"ALL"</code>)</em><a href="#index-std-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-std-4">
<span class="category">: </span><span><em>[<var>y</var>, <var>mu</var>] =</em> <strong>std</strong> <em>(…)</em><a href="#index-std-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the standard deviation of the elements of the vector <var>x</var>. </p> <p>The standard deviation is defined as </p> <pre class="example" data-language="matlab">std (x) = sqrt ( 1/(N-1) SUM_i (x(i) - mean(x))^2 )</pre> <p>where <em class="math">N</em> is the number of elements of the <var>x</var> vector. </p> <p>If <var>x</var> is an array, compute the standard deviation for each column and return them in a row vector (or for an n-D array, the result is returned as an array of dimension 1 x n x m x …). </p> <p>The optional argument <var>w</var> determines the weighting scheme to use. Valid values are: </p> <dl compact> <dt><span>0 [default]:</span></dt> <dd>
<p>Normalize with <em class="math">N-1</em>. This provides the square root of the best unbiased estimator of the variance. </p> </dd> <dt><span>1:</span></dt> <dd>
<p>Normalize with <em class="math">N</em>. This provides the square root of the second moment around the mean. </p> </dd> <dt><span>a vector:</span></dt> <dd><p>Compute the weighted standard deviation with non-negative scalar weights. The length of <var>w</var> must equal the size of <var>x</var> along dimension <var>dim</var>. </p></dd> </dl> <p>If <em class="math">N</em> is equal to 1 the value of <var>W</var> is ignored and normalization by <em class="math">N</em> is used. </p> <p>The optional variable <var>dim</var> forces <code>std</code> to operate over the specified dimension(s). <var>dim</var> can either be a scalar dimension or a vector of non-repeating dimensions. Dimensions must be positive integers, and the standard deviation is calculated over the array slice defined by <var>dim</var>. </p> <p>Specifying dimension <code>"all"</code> will force <code>std</code> to operate on all elements of <var>x</var>, and is equivalent to <code>std (<var>x</var>(:))</code>. </p> <p>When <var>dim</var> is a vector or <code>"all"</code>, <var>w</var> must be either 0 or 1. </p> <p>The optional second output variable <var>mu</var> contains the mean or weighted mean used to calculate <var>y</var>, and will be the same size as <var>y</var>. </p> <p><strong>See also:</strong> <a href="#XREFvar">var</a>, <a href="#XREFbounds">bounds</a>, <a href="#XREFmad">mad</a>, <a href="#XREFrange">range</a>, <a href="#XREFiqr">iqr</a>, <a href="#XREFmean">mean</a>, <a href="#XREFmedian">median</a>. </p>
</dd>
</dl> <p>In addition to knowing the size of a dispersion it is useful to know the shape of the data set. For example, are data points massed to the left or right of the mean? Octave provides several common measures to describe the shape of the data set. Octave can also calculate moments allowing arbitrary shape measures to be developed. </p> <dl class="def"> <dt id="index-var">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>var</strong> <em>(<var>x</var>)</em><a href="#index-var" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-var-1">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>var</strong> <em>(<var>x</var>, <var>w</var>)</em><a href="#index-var-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-var-2">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>var</strong> <em>(<var>x</var>, <var>w</var>, <var>dim</var>)</em><a href="#index-var-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-var-3">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>var</strong> <em>(<var>x</var>, <var>w</var>, <code>"ALL"</code>)</em><a href="#index-var-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-var-4">
<span class="category">: </span><span><em>[<var>v</var>, <var>m</var>] =</em> <strong>var</strong> <em>(…)</em><a href="#index-var-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the variance of the elements of the vector <var>x</var>. </p> <p>The variance is defined as </p> <pre class="example" data-language="matlab">var (x) = 1/(N-1) SUM_i (x(i) - mean(x))^2</pre> <p>where <em class="math">N</em> is the length of the <var>x</var> vector. </p> <p>If <var>x</var> is an array, compute the variance for each column and return them in a row vector (or for an n-D array, the result is returned as an array of dimension 1 x n x m x …). </p> <p>The optional argument <var>w</var> determines the weighting scheme to use. Valid values are </p> <dl compact> <dt><span>0 [default]:</span></dt> <dd>
<p>Normalize with <em class="math">N-1</em>. This provides the square root of the best unbiased estimator of the variance. </p> </dd> <dt><span>1:</span></dt> <dd>
<p>Normalize with <em class="math">N</em>. This provides the square root of the second moment around the mean. </p> </dd> <dt><span>a vector:</span></dt> <dd><p>Compute the weighted variance with non-negative scalar weights. The length of <var>w</var> must equal the size of <var>x</var> along dimension <var>dim</var>. </p></dd> </dl> <p>If <em class="math">N</em> is equal to 1 the value of <var>W</var> is ignored and normalization by <em class="math">N</em> is used. </p> <p>The optional variable <var>dim</var> forces <code>var</code> to operate over the specified dimension(s). <var>dim</var> can either be a scalar dimension or a vector of non-repeating dimensions. Dimensions must be positive integers, and the variance is calculated over the array slice defined by <var>dim</var>. </p> <p>Specifying dimension <code>"all"</code> will force <code>var</code> to operate on all elements of <var>x</var>, and is equivalent to <code>var (<var>x</var>(:))</code>. </p> <p>When <var>dim</var> is a vector or <code>"all"</code>, <var>w</var> must be either 0 or 1. </p> <p>The optional second output variable <var>mu</var> contains the mean or weighted mean used to calculate <var>v</var>, and will be the same size as <var>v</var>. </p> <p><strong>See also:</strong> <a href="correlation-and-regression-analysis.html#XREFcov">cov</a>, <a href="#XREFstd">std</a>, <a href="#XREFskewness">skewness</a>, <a href="#XREFkurtosis">kurtosis</a>, <a href="#XREFmoment">moment</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-skewness">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>skewness</strong> <em>(<var>x</var>)</em><a href="#index-skewness" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-skewness-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>skewness</strong> <em>(<var>x</var>, <var>flag</var>)</em><a href="#index-skewness-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-skewness-2">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>skewness</strong> <em>(<var>x</var>, <var>flag</var>, <var>dim</var>)</em><a href="#index-skewness-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the sample skewness of the elements of <var>x</var>. </p> <p>The sample skewness is defined as </p> <pre class="example" data-language="matlab">mean ((x - mean (x)).^3)
skewness (X) = ------------------------.
                      std (x).^3</pre> <p>The optional argument <var>flag</var> controls which normalization is used. If <var>flag</var> is equal to 1 (default value, used when <var>flag</var> is omitted or empty), return the sample skewness as defined above. If <var>flag</var> is equal to 0, return the adjusted skewness coefficient instead: </p> <pre class="example" data-language="matlab">sqrt (N*(N-1))   mean ((x - mean (x)).^3)
skewness (X, 0) = -------------- * ------------------------.
                      (N - 2)             std (x).^3</pre> <p>where <em class="math">N</em> is the length of the <var>x</var> vector. </p> <p>The adjusted skewness coefficient is obtained by replacing the sample second and third central moments by their bias-corrected versions. </p> <p>If <var>x</var> is a matrix, or more generally a multi-dimensional array, return the skewness along the first non-singleton dimension. If the optional <var>dim</var> argument is given, operate along this dimension. </p> <p><strong>See also:</strong> <a href="#XREFvar">var</a>, <a href="#XREFkurtosis">kurtosis</a>, <a href="#XREFmoment">moment</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-kurtosis">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>kurtosis</strong> <em>(<var>x</var>)</em><a href="#index-kurtosis" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-kurtosis-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>kurtosis</strong> <em>(<var>x</var>, <var>flag</var>)</em><a href="#index-kurtosis-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-kurtosis-2">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>kurtosis</strong> <em>(<var>x</var>, <var>flag</var>, <var>dim</var>)</em><a href="#index-kurtosis-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the sample kurtosis of the elements of <var>x</var>. </p> <p>The sample kurtosis is defined as </p> <pre class="example" data-language="matlab">mean ((x - mean (x)).^4)
k1 = ------------------------
            std (x).^4</pre> <p>The optional argument <var>flag</var> controls which normalization is used. If <var>flag</var> is equal to 1 (default value, used when <var>flag</var> is omitted or empty), return the sample kurtosis as defined above. If <var>flag</var> is equal to 0, return the <span class="nolinebreak">"bias-corrected"</span> kurtosis coefficient instead: </p> <pre class="example" data-language="matlab">N - 1
k0 = 3 + -------------- * ((N + 1) * k1 - 3 * (N - 1))
         (N - 2)(N - 3)</pre> <p>where <em class="math">N</em> is the length of the <var>x</var> vector. </p> <p>The bias-corrected kurtosis coefficient is obtained by replacing the sample second and fourth central moments by their unbiased versions. It is an unbiased estimate of the population kurtosis for normal populations. </p> <p>If <var>x</var> is a matrix, or more generally a multi-dimensional array, return the kurtosis along the first non-singleton dimension. If the optional <var>dim</var> argument is given, operate along this dimension. </p> <p><strong>See also:</strong> <a href="#XREFvar">var</a>, <a href="#XREFskewness">skewness</a>, <a href="#XREFmoment">moment</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-moment">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>moment</strong> <em>(<var>x</var>, <var>p</var>)</em><a href="#index-moment" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-moment-1">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>moment</strong> <em>(<var>x</var>, <var>p</var>, <var>type</var>)</em><a href="#index-moment-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-moment-2">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>moment</strong> <em>(<var>x</var>, <var>p</var>, <var>dim</var>)</em><a href="#index-moment-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-moment-3">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>moment</strong> <em>(<var>x</var>, <var>p</var>, <var>type</var>, <var>dim</var>)</em><a href="#index-moment-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-moment-4">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>moment</strong> <em>(<var>x</var>, <var>p</var>, <var>dim</var>, <var>type</var>)</em><a href="#index-moment-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the <var>p</var>-th central moment of the vector <var>x</var>. </p> <p>The <var>p</var>-th central moment of <var>x</var> is defined as: </p> <pre class="example" data-language="matlab">1/N SUM_i (x(i) - mean(x))^p</pre> <p>where <em class="math">N</em> is the length of the <var>x</var> vector. </p> <p>If <var>x</var> is a matrix, return the row vector containing the <var>p</var>-th central moment of each column. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional string <var>type</var> specifies the type of moment to be computed. Valid options are: </p> <dl compact> <dt><span><code>"c"</code></span></dt> <dd>
<p>Central Moment (default). </p> </dd> <dt><span><code>"a"</code></span></dt> <dt><span><code>"ac"</code></span></dt> <dd>
<p>Absolute Central Moment. The moment about the mean ignoring sign defined as </p> <pre class="example" data-language="matlab">1/N SUM_i (abs (x(i) - mean(x)))^p</pre> </dd> <dt><span><code>"r"</code></span></dt> <dd>
<p>Raw Moment. The moment about zero defined as </p> <pre class="example" data-language="matlab">moment (x) = 1/N SUM_i x(i)^p</pre> </dd> <dt><span><code>"ar"</code></span></dt> <dd>
<p>Absolute Raw Moment. The moment about zero ignoring sign defined as </p> <pre class="example" data-language="matlab">1/N SUM_i ( abs (x(i)) )^p</pre> </dd> </dl> <p>If both <var>type</var> and <var>dim</var> are given they may appear in any order. </p> <p><strong>See also:</strong> <a href="#XREFvar">var</a>, <a href="#XREFskewness">skewness</a>, <a href="#XREFkurtosis">kurtosis</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-quantile">
<span class="category">: </span><span><em><var>q</var> =</em> <strong>quantile</strong> <em>(<var>x</var>)</em><a href="#index-quantile" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-quantile-1">
<span class="category">: </span><span><em><var>q</var> =</em> <strong>quantile</strong> <em>(<var>x</var>, <var>p</var>)</em><a href="#index-quantile-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-quantile-2">
<span class="category">: </span><span><em><var>q</var> =</em> <strong>quantile</strong> <em>(<var>x</var>, <var>p</var>, <var>dim</var>)</em><a href="#index-quantile-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-quantile-3">
<span class="category">: </span><span><em><var>q</var> =</em> <strong>quantile</strong> <em>(<var>x</var>, <var>p</var>, <var>dim</var>, <var>method</var>)</em><a href="#index-quantile-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>For a sample, <var>x</var>, calculate the quantiles, <var>q</var>, corresponding to the cumulative probability values in <var>p</var>. All non-numeric values (NaNs) of <var>x</var> are ignored. </p> <p>If <var>x</var> is a matrix, compute the quantiles for each column and return them in a matrix, such that the i-th row of <var>q</var> contains the <var>p</var>(i)th quantiles of each column of <var>x</var>. </p> <p>If <var>p</var> is unspecified, return the quantiles for <code>[0.00 0.25 0.50 0.75 1.00]</code>. The optional argument <var>dim</var> determines the dimension along which the quantiles are calculated. If <var>dim</var> is omitted it defaults to the first non-singleton dimension. </p> <p>The methods available to calculate sample quantiles are the nine methods used by R (<a href="https://www.r-project.org/">https://www.r-project.org/</a>). The default value is <var>method</var> = 5. </p> <p>Discontinuous sample quantile methods 1, 2, and 3 </p> <ol> <li> Method 1: Inverse of empirical distribution function. </li>
<li> Method 2: Similar to method 1 but with averaging at discontinuities. </li>
<li> Method 3: SAS definition: nearest even order statistic. </li>
</ol> <p>Continuous sample quantile methods 4 through 9, where <var>p</var>(k) is the linear interpolation function respecting each method’s representative cdf. </p> <ol start="4"> <li> Method 4: <var>p</var>(k) = k / N. That is, linear interpolation of the empirical cdf, where <em class="math">N</em> is the length of <var>P</var>. </li>
<li> Method 5: <var>p</var>(k) = (k - 0.5) / N. That is, a piecewise linear function where the knots are the values midway through the steps of the empirical cdf. </li>
<li> Method 6: <var>p</var>(k) = k / (N + 1). </li>
<li> Method 7: <var>p</var>(k) = (k - 1) / (N - 1). </li>
<li> Method 8: <var>p</var>(k) = (k - 1/3) / (N + 1/3). The resulting quantile estimates are approximately median-unbiased regardless of the distribution of <var>x</var>. </li>
<li> Method 9: <var>p</var>(k) = (k - 3/8) / (N + 1/4). The resulting quantile estimates are approximately unbiased for the expected order statistics if <var>x</var> is normally distributed. </li>
</ol> <p>Hyndman and Fan (1996) recommend method 8. Maxima, S, and R (versions prior to 2.0.0) use 7 as their default. Minitab and SPSS use method 6. <small>MATLAB</small> uses method 5. </p> <p>References: </p> <ul> <li> Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New S Language. Wadsworth &amp; Brooks/Cole. </li>
<li> Hyndman, R. J. and Fan, Y. (1996) Sample quantiles in statistical packages, American Statistician, 50, 361–365. </li>
<li> R: A Language and Environment for Statistical Computing; <a href="https://cran.r-project.org/doc/manuals/fullrefman.pdf">https://cran.r-project.org/doc/manuals/fullrefman.pdf</a>. </li>
</ul> <p>Examples: </p> <pre class="example" data-language="matlab">x = randi (1000, [10, 1]);  # Create empirical data in range 1-1000
q = quantile (x, [0, 1]);   # Return minimum, maximum of distribution
q = quantile (x, [0.25 0.5 0.75]); # Return quartiles of distribution</pre> <p><strong>See also:</strong> <a href="#XREFprctile">prctile</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-prctile">
<span class="category">: </span><span><em><var>q</var> =</em> <strong>prctile</strong> <em>(<var>x</var>)</em><a href="#index-prctile" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-prctile-1">
<span class="category">: </span><span><em><var>q</var> =</em> <strong>prctile</strong> <em>(<var>x</var>, <var>p</var>)</em><a href="#index-prctile-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-prctile-2">
<span class="category">: </span><span><em><var>q</var> =</em> <strong>prctile</strong> <em>(<var>x</var>, <var>p</var>, <var>dim</var>)</em><a href="#index-prctile-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>For a sample <var>x</var>, compute the quantiles, <var>q</var>, corresponding to the cumulative probability values, <var>p</var>, in percent. </p> <p>If <var>x</var> is a matrix, compute the percentiles for each column and return them in a matrix, such that the i-th row of <var>q</var> contains the <var>p</var>(i)th percentiles of each column of <var>x</var>. </p> <p>If <var>p</var> is unspecified, return the quantiles for <code>[0 25 50 75 100]</code>. </p> <p>The optional argument <var>dim</var> determines the dimension along which the percentiles are calculated. If <var>dim</var> is omitted it defaults to the first non-singleton dimension. </p> <p>Programming Note: All non-numeric values (NaNs) of <var>x</var> are ignored. </p> <p><strong>See also:</strong> <a href="#XREFquantile">quantile</a>. </p>
</dd>
</dl> <p>A summary view of a data set can be generated quickly with the <code>statistics</code> function. </p> <dl class="def"> <dt id="index-statistics">
<span class="category">: </span><span><em><var>stats</var> =</em> <strong>statistics</strong> <em>(<var>x</var>)</em><a href="#index-statistics" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-statistics-1">
<span class="category">: </span><span><em><var>stats</var> =</em> <strong>statistics</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-statistics-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a vector with the minimum, first quartile, median, third quartile, maximum, mean, standard deviation, skewness, and kurtosis of the elements of the vector <var>x</var>. </p> <p>If <var>x</var> is a matrix, calculate statistics over the first non-singleton dimension. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p><strong>See also:</strong> <a href="utility-functions.html#XREFmin">min</a>, <a href="utility-functions.html#XREFmax">max</a>, <a href="#XREFmedian">median</a>, <a href="#XREFmean">mean</a>, <a href="#XREFstd">std</a>, <a href="#XREFskewness">skewness</a>, <a href="#XREFkurtosis">kurtosis</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Descriptive-Statistics.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Descriptive-Statistics.html</a>
  </p>
</div>
