<div class="section-level-extent" id="Descriptive-Statistics"> <div class="nav-panel"> <p> Next: <a href="statistics-on-sliding-windows-of-data.html" accesskey="n" rel="next">Statistics on Sliding Windows of Data</a>, Up: <a href="statistics.html" accesskey="u" rel="up">Statistics</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Descriptive-Statistics-1"><span>26.1 Descriptive Statistics<a class="copiable-link" href="#Descriptive-Statistics-1"> ¶</a></span></h1> <p>One principal goal of descriptive statistics is to represent the essence of a large data set concisely. Octave provides the mean, median, and mode functions which all summarize a data set with just a single number corresponding to the central tendency of the data. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-mean">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mean</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-mean"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mean-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mean</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-mean-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mean-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mean</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">vecdim</var>)</code><a class="copiable-link" href="#index-mean-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mean-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mean</strong> <code class="def-code-arguments">(<var class="var">x</var>, "all")</code><a class="copiable-link" href="#index-mean-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mean-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mean</strong> <code class="def-code-arguments">(…, <var class="var">nanflag</var>)</code><a class="copiable-link" href="#index-mean-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mean-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mean</strong> <code class="def-code-arguments">(…, <var class="var">outtype</var>)</code><a class="copiable-link" href="#index-mean-5"> ¶</a></span>
</dt> <dd>
<p>Compute the mean of the elements of <var class="var">x</var>. </p> <p>If <var class="var">x</var> is a vector, then <code class="code">mean (<var class="var">x</var>)</code> returns the mean of the elements in <var class="var">x</var> defined as </p> <pre class="example" data-language="matlab">mean (x) = SUM_i x(i) / N</pre> <p>where <em class="math">N</em> is the number of elements in <var class="var">x</var>. </p> <p>If <var class="var">x</var> is an array, then <code class="code">mean(<var class="var">x</var>)</code> computes the mean along the first non-singleton dimension of <var class="var">x</var>. </p> <p>The optional variable <var class="var">dim</var> forces <code class="code">mean</code> to operate over the specified dimension, which must be a positive integer-valued number. Specifying any singleton dimension in <var class="var">x</var>, including any dimension exceeding <code class="code">ndims (<var class="var">x</var>)</code>, will result in a mean equal to <var class="var">x</var>. </p> <p>Specifying the dimensions as <var class="var">vecdim</var>, a vector of non-repeating dimensions, will return the mean over the array slice defined by <var class="var">vecdim</var>. If <var class="var">vecdim</var> indexes all dimensions of <var class="var">x</var>, then it is equivalent to the option <code class="code">"all"</code>. Any dimension in <var class="var">vecdim</var> greater than <code class="code">ndims (<var class="var">x</var>)</code> is ignored. </p> <p>Specifying the dimension as <code class="code">"all"</code> will force <code class="code">mean</code> to operate on all elements of <var class="var">x</var>, and is equivalent to <code class="code">mean (<var class="var">x</var>(:))</code>. </p> <p>The optional input <var class="var">outtype</var> specifies the data type that is returned. <var class="var">outtype</var> can take the following values: </p> <dl class="table"> <dt>
<code class="code">'default'</code> : Output is of type double, unless the input is</dt> <dd>
<p>single in which case the output is of type single. </p> </dd> <dt>
<code class="code">'double'</code> : Output is of type double.</dt> <dt>
<code class="code">'native'</code> : Output is of the same type as the input as reported</dt> <dd><p>by (<code class="code">class (<var class="var">x</var>)</code>), unless the input is logical in which case the output is of type double. </p></dd> </dl> <p>The optional variable <var class="var">nanflag</var> specifies whether to include or exclude NaN values from the calculation using any of the previously specified input argument combinations. The default value for <var class="var">nanflag</var> is <code class="code">"includenan"</code> which keeps NaN values in the calculation. To exclude NaN values set the value of <var class="var">nanflag</var> to <code class="code">"omitnan"</code>. The output will still contain NaN values if <var class="var">x</var> consists of all NaN values in the operating dimension. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmedian">median</a>, <a class="ref" href="#XREFmode">mode</a>, <a class="ref" href="statistics-on-sliding-windows-of-data.html#XREFmovmean">movmean</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-median">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">median</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-median"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-median-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">median</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-median-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-median-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">median</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">vecdim</var>)</code><a class="copiable-link" href="#index-median-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-median-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">median</strong> <code class="def-code-arguments">(<var class="var">x</var>, "all")</code><a class="copiable-link" href="#index-median-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-median-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">median</strong> <code class="def-code-arguments">(…, <var class="var">nanflag</var>)</code><a class="copiable-link" href="#index-median-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-median-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">median</strong> <code class="def-code-arguments">(…, <var class="var">outtype</var>)</code><a class="copiable-link" href="#index-median-5"> ¶</a></span>
</dt> <dd>
<p>Compute the median value of the elements of <var class="var">x</var>. </p> <p>When the elements of <var class="var">x</var> are sorted, say <code class="code"><var class="var">s</var> = sort (<var class="var">x</var>)</code>, the median is defined as </p> <pre class="example" data-language="matlab">|  s(ceil (N/2))          N odd
median (x) = |
             | (s(N/2) + s(N/2+1))/2   N even</pre> <p>If <var class="var">x</var> is an array, then <code class="code">median (<var class="var">x</var>)</code> operates along the first non-singleton dimension of <var class="var">x</var>. </p> <p>The optional variable <var class="var">dim</var> forces <code class="code">median</code> to operate over the specified dimension, which must be a positive integer-valued number. Specifying any singleton dimension in <var class="var">x</var>, including any dimension exceeding <code class="code">ndims (<var class="var">x</var>)</code>, will result in a median equal to <var class="var">x</var>. </p> <p>Specifying the dimensions as <var class="var">vecdim</var>, a vector of non-repeating dimensions, will return the median over the array slice defined by <var class="var">vecdim</var>. If <var class="var">vecdim</var> indexes all dimensions of <var class="var">x</var>, then it is equivalent to the option <code class="code">"all"</code>. Any dimension in <var class="var">vecdim</var> greater than <code class="code">ndims (<var class="var">x</var>)</code> is ignored. </p> <p>Specifying the dimension as <code class="code">"all"</code> will force <code class="code">median</code> to operate on all elements of <var class="var">x</var>, and is equivalent to <code class="code">median (<var class="var">x</var>(:))</code>. </p> <p><code class="code">median (…, <var class="var">outtype</var>)</code> returns the median with a specified data type, using any of the input arguments in the previous syntaxes. <var class="var">outtype</var> can take the following values: </p> <dl class="table"> <dt><code class="code">"default"</code></dt> <dd>
<p>Output is of type double, unless the input is single in which case the output is of type single. </p> </dd> <dt><code class="code">"double"</code></dt> <dd>
<p>Output is of type double. </p> </dd> <dt>
<code class="code">"native"</code>.</dt> <dd><p>Output is of the same type as the input (<code class="code">class (<var class="var">x</var>)</code>), unless the input is logical in which case the output is of type double. </p></dd> </dl> <p>The optional variable <var class="var">nanflag</var> specifies whether to include or exclude NaN values from the calculation using any of the previously specified input argument combinations. The default value for <var class="var">nanflag</var> is <code class="code">"includenan"</code> which keeps NaN values in the calculation. To exclude NaN values set the value of <var class="var">nanflag</var> to <code class="code">"omitnan"</code>. The output will still contain NaN values if <var class="var">x</var> consists of all NaN values in the operating dimension. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmean">mean</a>, <a class="ref" href="#XREFmode">mode</a>, <a class="ref" href="statistics-on-sliding-windows-of-data.html#XREFmovmedian">movmedian</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-mode">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mode</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-mode"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mode-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mode</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-mode-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mode-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">m</var>, <var class="var">f</var>, <var class="var">c</var>] =</code> <strong class="def-name">mode</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-mode-2"> ¶</a></span>
</dt> <dd>
<p>Compute the most frequently occurring value in a dataset (mode). </p> <p><code class="code">mode</code> determines the frequency of values along the first non-singleton dimension and returns the value with the highest frequency. If two, or more, values have the same frequency <code class="code">mode</code> returns the smallest. </p> <p>If the optional argument <var class="var">dim</var> is given, operate along this dimension. </p> <p>The return variable <var class="var">f</var> is the number of occurrences of the mode in the dataset. </p> <p>The cell array <var class="var">c</var> contains all of the elements with the maximum frequency. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmean">mean</a>, <a class="ref" href="#XREFmedian">median</a>. </p>
</dd>
</dl> <p>Using just one number, such as the mean, to represent an entire data set may not give an accurate picture of the data. One way to characterize the fit is to measure the dispersion of the data. Octave provides several functions for measuring dispersion. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-bounds">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">l</var>] =</code> <strong class="def-name">bounds</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-bounds"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bounds-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">l</var>] =</code> <strong class="def-name">bounds</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-bounds-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bounds-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">l</var>] =</code> <strong class="def-name">bounds</strong> <code class="def-code-arguments">(…, "nanflag")</code><a class="copiable-link" href="#index-bounds-2"> ¶</a></span>
</dt> <dd>
<p>Return the smallest and largest values of the input data <var class="var">x</var>. </p> <p>If <var class="var">x</var> is a vector, the bounds are calculated over the elements of <var class="var">x</var>. If <var class="var">x</var> is a matrix, the bounds are calculated for each column. For a multi-dimensional array, the bounds are calculated over the first non-singleton dimension. </p> <p>If the optional argument <var class="var">dim</var> is given, operate along this dimension. </p> <p>The optional argument <code class="code">"nanflag"</code> defaults to <code class="code">"omitnan"</code> which does not include NaN values in the result. If the argument <code class="code">"includenan"</code> is given, and there is a NaN present, then the result for both smallest (<var class="var">s</var>) and largest (<var class="var">l</var>) elements will be NaN. </p> <p>The bounds are a quickly computed measure of the dispersion of a data set, but are less accurate than <code class="code">iqr</code> if there are outlying data points. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFrange">range</a>, <a class="ref" href="#XREFiqr">iqr</a>, <a class="ref" href="#XREFmad">mad</a>, <a class="ref" href="#XREFstd">std</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-range">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">range</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-range"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-range-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">range</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-range-1"> ¶</a></span>
</dt> <dd>
<p>Return the range, i.e., the difference between the maximum and the minimum of the input data. </p> <p>If <var class="var">x</var> is a vector, the range is calculated over the elements of <var class="var">x</var>. If <var class="var">x</var> is a matrix, the range is calculated over each column of <var class="var">x</var>. </p> <p>If the optional argument <var class="var">dim</var> is given, operate along this dimension. </p> <p>The range is a quickly computed measure of the dispersion of a data set, but is less accurate than <code class="code">iqr</code> if there are outlying data points. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbounds">bounds</a>, <a class="ref" href="#XREFiqr">iqr</a>, <a class="ref" href="#XREFmad">mad</a>, <a class="ref" href="#XREFstd">std</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-iqr">
<span class="category-def">: </span><span><code class="def-type"><var class="var">Z</var> =</code> <strong class="def-name">iqr</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-iqr"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-iqr-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">Z</var> =</code> <strong class="def-name">iqr</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-iqr-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-iqr-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">Z</var> =</code> <strong class="def-name">iqr</strong> <code class="def-code-arguments">(<var class="var">x</var>, <code class="code">"ALL"</code>)</code><a class="copiable-link" href="#index-iqr-2"> ¶</a></span>
</dt> <dd>
<p>Return the interquartile range of <var class="var">x</var>, defined as the distance between the 25th and 75th percentile values of <var class="var">x</var> calculated using: quantile (x, [0.25 0.75]) </p> <p>If <var class="var">x</var> is a vector, <code class="code">iqr (<var class="var">x</var>)</code> will operate on the data in <var class="var">x</var>. </p> <p>If <var class="var">x</var> is a matrix, <code class="code">iqr (<var class="var">x</var>)</code> will operate independently on each column in <var class="var">x</var> returning a row vector <var class="var">Z</var>. </p> <p>If <var class="var">x</var> is a n-dimensional array, <code class="code">iqr (<var class="var">x</var>)</code> will operate independently on the first non-singleton dimension in <var class="var">x</var>, returning an array <var class="var">Z</var> the same shape as <var class="var">x</var> with the non-singleton dimenion reduced to 1. </p> <p>The optional variable <var class="var">dim</var> can be used to force <code class="code">iqr</code> to operate over the specified dimension. <var class="var">dim</var> can either be a scalar dimension or a vector of non-repeating dimensions over which to operate. In either case <var class="var">dim</var> must be positive integers. A vector <var class="var">dim</var> concatenates all specified dimensions for independent operation by <code class="code">iqr</code>. </p> <p>Specifying dimension <code class="code">"ALL"</code> will force <code class="code">iqr</code> to operate on all elements of <var class="var">x</var>, and is equivalent to <code class="code">iqr (<var class="var">x</var>(:))</code>. Similarly, specifying a vector dimension including all non-singleton dimensions of <var class="var">x</var> is equivalent to <code class="code">iqr (<var class="var">x</var>, <code class="code">"ALL"</code>)</code>. </p> <p>If <var class="var">x</var> is a scalar, or only singleton dimensions are specified for <var class="var">dim</var>, the output will be <code class="code">zeros (size (<var class="var">x</var>))</code>. </p> <p>As a measure of dispersion, the interquartile range is less affected by outliers than either <code class="code">range</code> or <code class="code">std</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbounds">bounds</a>, <a class="ref" href="#XREFmad">mad</a>, <a class="ref" href="#XREFrange">range</a>, <a class="ref" href="#XREFstd">std</a>, <a class="ref" href="#XREFprctile">prctile</a>, <a class="ref" href="#XREFquantile">quantile</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-mad">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mad</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-mad"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mad-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mad</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-mad-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mad-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mad</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">opt</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-mad-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mad-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mad</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">opt</var>, <var class="var">vecdim</var>)</code><a class="copiable-link" href="#index-mad-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mad-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mad</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">opt</var>, "all")</code><a class="copiable-link" href="#index-mad-4"> ¶</a></span>
</dt> <dd>
<p>Compute the mean or median absolute deviation (MAD) of the elements of <var class="var">x</var>. </p> <p>The mean absolute deviation is defined as </p> <pre class="example" data-language="matlab">mad = mean (abs (x - mean (x)))</pre> <p>The median absolute deviation is defined as </p> <pre class="example" data-language="matlab">mad = median (abs (x - median (x)))</pre> <p>If <var class="var">x</var> is a vector, compute <code class="code">mad</code> for each element in <var class="var">x</var>. If <var class="var">x</var> is an array the calculation is performed over the first non-singleton dimension. </p> <p><code class="code">mad</code> excludes NaN values from calculation similar to using the <code class="code">omitnan</code> option in <code class="code">var</code>, <code class="code">mean</code>, and <code class="code">median</code>. </p> <p>The optional argument <var class="var">opt</var> determines whether mean or median absolute deviation is calculated. The default is 0 which corresponds to mean absolute deviation; a value of 1 corresponds to median absolute deviation. Passing an empty input [] defaults to mean absolute deviation (<var class="var">opt</var> = 0). </p> <p>The optional argument <var class="var">dim</var> forces <code class="code">mad</code> to operate along the specified dimension. Specifying any singleton dimension in <var class="var">x</var>, including any dimension exceeding <code class="code">ndims (<var class="var">x</var>)</code>, will result in an output of 0. </p> <p>Specifying the dimension as <var class="var">vecdim</var>, a vector of non-repeating dimensions, will return the <code class="code">mad</code> over the array slice defined by <var class="var">vecdim</var>. If <var class="var">vecdim</var> indexes all dimensions of <var class="var">x</var>, then it is equivalent to the option <code class="code">"all"</code>. Any dimension included in <var class="var">vecdim</var> greater than <code class="code">ndims (<var class="var">x</var>)</code> is ignored. </p> <p>Specifying the dimension as <code class="code">"all"</code> will force <code class="code">mad</code> to operate on all elements of <var class="var">x</var>, and is equivalent to <code class="code">mad (<var class="var">x</var>(:))</code>. </p> <p>As a measure of dispersion, <code class="code">mad</code> is less affected by outliers than <code class="code">std</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbounds">bounds</a>, <a class="ref" href="#XREFrange">range</a>, <a class="ref" href="#XREFiqr">iqr</a>, <a class="ref" href="#XREFstd">std</a>, <a class="ref" href="#XREFmean">mean</a>, <a class="ref" href="#XREFmedian">median</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-meansq">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">meansq</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-meansq"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meansq-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">meansq</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-meansq-1"> ¶</a></span>
</dt> <dd>
<p>Compute the mean square of the elements of the vector <var class="var">x</var>. </p> <p>The mean square is defined as </p> <pre class="example" data-language="matlab">meansq (x) = 1/N SUM_i x(i)^2</pre> <p>where <em class="math">N</em> is the length of the <var class="var">x</var> vector. </p> <p>If <var class="var">x</var> is a matrix, return a row vector containing the mean square of each column. </p> <p>If the optional argument <var class="var">dim</var> is given, operate along this dimension. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFvar">var</a>, <a class="ref" href="#XREFstd">std</a>, <a class="ref" href="#XREFmoment">moment</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-std">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">std</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-std"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-std-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">std</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">w</var>)</code><a class="copiable-link" href="#index-std-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-std-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">std</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">w</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-std-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-std-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">std</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">w</var>, <var class="var">vecdim</var>)</code><a class="copiable-link" href="#index-std-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-std-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">std</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">w</var>, <code class="code">"ALL"</code>)</code><a class="copiable-link" href="#index-std-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-std-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">std</strong> <code class="def-code-arguments">(…, <var class="var">nanflag</var>)</code><a class="copiable-link" href="#index-std-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-std-6">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">m</var>] =</code> <strong class="def-name">std</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-std-6"> ¶</a></span>
</dt> <dd>
<p>Compute the standard deviation of the elements of the vector <var class="var">x</var>. </p> <p>The standard deviation is defined as </p> <pre class="example" data-language="matlab">std (x) = sqrt ((1 / (N-1)) * SUM_i ((x(i) - mean(x))^2))</pre> <p>where <em class="math">N</em> is the number of elements of <var class="var">x</var>. </p> <p>If <var class="var">x</var> is an array, compute the standard deviation along the first non-singleton dimensions of <var class="var">x</var>. </p> <p>The optional argument <var class="var">w</var> determines the weighting scheme to use. Valid values are: </p> <dl class="table"> <dt>0 [default]:</dt> <dd>
<p>Normalize with <em class="math">N-1</em> (population standard deviation). This provides the square root of the best unbiased estimator of the standard deviation. </p> </dd> <dt>1:</dt> <dd>
<p>Normalize with <em class="math">N</em> (sample standard deviation). This provides the square root of the second moment around the mean. </p> </dd> <dt>a vector:</dt> <dd>
<p>Compute the weighted standard deviation with non-negative weights. The length of <var class="var">w</var> must equal the size of <var class="var">x</var> in the operating dimension. NaN values are permitted in <var class="var">w</var>, will be multiplied with the associated values in <var class="var">x</var>, and can be excluded by the <var class="var">nanflag</var> option. </p> </dd> <dt>an array:</dt> <dd><p>Similar to vector weights, but <var class="var">w</var> must be the same size as <var class="var">x</var>. If the operating dimension is supplied as <var class="var">vecdim</var> or <code class="code">"all"</code> and <var class="var">w</var> is not a scalar, <var class="var">w</var> must be an same-sized array. </p></dd> </dl> <p>Note: <var class="var">w</var> must always be specified before specifying any of the following dimension options. To use the default value for <var class="var">w</var> you may pass an empty input argument []. </p> <p>The optional variable <var class="var">dim</var> forces <code class="code">std</code> to operate over the specified dimension, which must be a positive integer-valued number. Specifying any singleton dimension in <var class="var">x</var>, including any dimension exceeding <code class="code">ndims (<var class="var">x</var>)</code>, will result in a standard deviation of 0. </p> <p>Specifying the dimensions as <var class="var">vecdim</var>, a vector of non-repeating dimensions, will return the standard deviation calculated over the array slice defined by <var class="var">vecdim</var>. If <var class="var">vecdim</var> indexes all dimensions of <var class="var">x</var>, then it is equivalent to the option <code class="code">"all"</code>. Any dimension in <var class="var">vecdim</var> greater than <code class="code">ndims (<var class="var">x</var>)</code> is ignored. </p> <p>Specifying the dimension as <code class="code">"all"</code> will force <code class="code">std</code> to operate on all elements of <var class="var">x</var>, and is equivalent to <code class="code">std (<var class="var">x</var>(:))</code>. </p> <p>The optional variable <var class="var">nanflag</var> specifies whether to include or exclude NaN values from the calculation using any of the previously specified input argument combinations. The default value for <var class="var">nanflag</var> is <code class="code">"includenan"</code> which keeps NaN values in the calculation. To exclude NaN values set the value of <var class="var">nanflag</var> to <code class="code">"omitnan"</code>. The output will still contain NaN values if <var class="var">x</var> consists of all NaN values in the operating dimension. </p> <p>The optional second output variable <var class="var">m</var> contains the mean of the elements of <var class="var">x</var> used to calculate the standard deviation. If <var class="var">v</var> is the weighted standard deviation, then <var class="var">m</var> is also the weighted mean. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFvar">var</a>, <a class="ref" href="#XREFbounds">bounds</a>, <a class="ref" href="#XREFmad">mad</a>, <a class="ref" href="#XREFrange">range</a>, <a class="ref" href="#XREFiqr">iqr</a>, <a class="ref" href="#XREFmean">mean</a>, <a class="ref" href="#XREFmedian">median</a>. </p>
</dd>
</dl> <p>In addition to knowing the size of a dispersion it is useful to know the shape of the data set. For example, are data points massed to the left or right of the mean? Octave provides several common measures to describe the shape of the data set. Octave can also calculate moments allowing arbitrary shape measures to be developed. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-var">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">var</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-var"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-var-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">var</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">w</var>)</code><a class="copiable-link" href="#index-var-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-var-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">var</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">w</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-var-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-var-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">var</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">w</var>, <var class="var">vecdim</var>)</code><a class="copiable-link" href="#index-var-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-var-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">var</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">w</var>, <code class="code">"all"</code>)</code><a class="copiable-link" href="#index-var-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-var-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">var</strong> <code class="def-code-arguments">(…, <var class="var">nanflag</var>)</code><a class="copiable-link" href="#index-var-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-var-6">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">v</var>, <var class="var">m</var>] =</code> <strong class="def-name">var</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-var-6"> ¶</a></span>
</dt> <dd>
<p>Compute the variance of the elements of the vector <var class="var">x</var>. </p> <p>The variance is defined as </p> <pre class="example" data-language="matlab">var (x) = (1 / (N-1)) * SUM_i ((x(i) - mean(x))^2)</pre> <p>where <em class="math">N</em> is the number of elements of <var class="var">x</var>. </p> <p>If <var class="var">x</var> is an array, compute the variance along the first non-singleton dimensions of <var class="var">x</var>. </p> <p>The optional argument <var class="var">w</var> determines the weighting scheme to use. Valid values are: </p> <dl class="table"> <dt>0 [default]:</dt> <dd>
<p>Normalize with <em class="math">N-1</em> (population variance). This provides the square root of the best unbiased estimator of the variance. </p> </dd> <dt>1:</dt> <dd>
<p>Normalize with <em class="math">N</em> (sample variance). This provides the square root of the second moment around the mean. </p> </dd> <dt>a vector:</dt> <dd>
<p>Compute the weighted variance with non-negative weights. The length of <var class="var">w</var> must equal the size of <var class="var">x</var> in the operating dimension. NaN values are permitted in <var class="var">w</var>, will be multiplied with the associated values in <var class="var">x</var>, and can be excluded by the <var class="var">nanflag</var> option. </p> </dd> <dt>an array:</dt> <dd><p>Similar to vector weights, but <var class="var">w</var> must be the same size as <var class="var">x</var>. If the operating dimension is supplied as <var class="var">vecdim</var> or <code class="code">"all"</code> and <var class="var">w</var> is not a scalar, <var class="var">w</var> must be an same-sized array. </p></dd> </dl> <p>Note: <var class="var">w</var> must always be specified before specifying any of the following dimension options. To use the default value for <var class="var">w</var> you may pass an empty input argument []. </p> <p>The optional variable <var class="var">dim</var> forces <code class="code">var</code> to operate over the specified dimension, which must be a positive integer-valued number. Specifying any singleton dimension in <var class="var">x</var>, including any dimension exceeding <code class="code">ndims (<var class="var">x</var>)</code>, will result in a variance of 0. </p> <p>Specifying the dimensions as <var class="var">vecdim</var>, a vector of non-repeating dimensions, will return the variance calculated over the array slice defined by <var class="var">vecdim</var>. If <var class="var">vecdim</var> indexes all dimensions of <var class="var">x</var>, then it is equivalent to the option <code class="code">"all"</code>. Any dimension in <var class="var">vecdim</var> greater than <code class="code">ndims (<var class="var">x</var>)</code> is ignored. </p> <p>Specifying the dimension as <code class="code">"all"</code> will force <code class="code">var</code> to operate on all elements of <var class="var">x</var>, and is equivalent to <code class="code">var
(<var class="var">x</var>(:))</code>. </p> <p>The optional variable <var class="var">nanflag</var> specifies whether to include or exclude NaN values from the calculation using any of the previously specified input argument combinations. The default value for <var class="var">nanflag</var> is <code class="code">"includenan"</code> which keeps NaN values in the calculation. To exclude NaN values set the value of <var class="var">nanflag</var> to <code class="code">"omitnan"</code>. The output will still contain NaN values if <var class="var">x</var> consists of all NaN values in the operating dimension. </p> <p>The optional second output variable <var class="var">m</var> contains the mean of the elements of <var class="var">x</var> used to calculate the variance. If <var class="var">v</var> is the weighted variance, then <var class="var">m</var> is also the weighted mean. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstd">std</a>, <a class="ref" href="#XREFmean">mean</a>, <a class="ref" href="correlation-and-regression-analysis.html#XREFcov">cov</a>, <a class="ref" href="#XREFskewness">skewness</a>, <a class="ref" href="#XREFkurtosis">kurtosis</a>, <a class="ref" href="#XREFmoment">moment</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-skewness">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">skewness</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-skewness"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-skewness-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">skewness</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">flag</var>)</code><a class="copiable-link" href="#index-skewness-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-skewness-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">skewness</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">flag</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-skewness-2"> ¶</a></span>
</dt> <dd>
<p>Compute the sample skewness of the elements of <var class="var">x</var>. </p> <p>The sample skewness is defined as </p> <pre class="example" data-language="matlab">mean ((x - mean (x)).^3)
skewness (X) = ------------------------.
                      std (x).^3</pre> <p>The optional argument <var class="var">flag</var> controls which normalization is used. If <var class="var">flag</var> is equal to 1 (default value, used when <var class="var">flag</var> is omitted or empty), return the sample skewness as defined above. If <var class="var">flag</var> is equal to 0, return the adjusted skewness coefficient instead: </p> <pre class="example" data-language="matlab">sqrt (N*(N-1))   mean ((x - mean (x)).^3)
skewness (X, 0) = -------------- * ------------------------.
                      (N - 2)             std (x).^3</pre> <p>where <em class="math">N</em> is the length of the <var class="var">x</var> vector. </p> <p>The adjusted skewness coefficient is obtained by replacing the sample second and third central moments by their bias-corrected versions. </p> <p>If <var class="var">x</var> is a matrix, or more generally a multi-dimensional array, return the skewness along the first non-singleton dimension. If the optional <var class="var">dim</var> argument is given, operate along this dimension. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFvar">var</a>, <a class="ref" href="#XREFkurtosis">kurtosis</a>, <a class="ref" href="#XREFmoment">moment</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-kurtosis">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">kurtosis</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-kurtosis"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-kurtosis-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">kurtosis</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">flag</var>)</code><a class="copiable-link" href="#index-kurtosis-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-kurtosis-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">kurtosis</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">flag</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-kurtosis-2"> ¶</a></span>
</dt> <dd>
<p>Compute the sample kurtosis of the elements of <var class="var">x</var>. </p> <p>The sample kurtosis is defined as </p> <pre class="example" data-language="matlab">mean ((x - mean (x)).^4)
k1 = ------------------------
            std (x).^4</pre> <p>The optional argument <var class="var">flag</var> controls which normalization is used. If <var class="var">flag</var> is equal to 1 (default value, used when <var class="var">flag</var> is omitted or empty), return the sample kurtosis as defined above. If <var class="var">flag</var> is equal to 0, return the "bias-corrected" kurtosis coefficient instead: </p> <pre class="example" data-language="matlab">N - 1
k0 = 3 + -------------- * ((N + 1) * k1 - 3 * (N - 1))
         (N - 2)(N - 3)</pre> <p>where <em class="math">N</em> is the length of the <var class="var">x</var> vector. </p> <p>The bias-corrected kurtosis coefficient is obtained by replacing the sample second and fourth central moments by their unbiased versions. It is an unbiased estimate of the population kurtosis for normal populations. </p> <p>If <var class="var">x</var> is a matrix, or more generally a multi-dimensional array, return the kurtosis along the first non-singleton dimension. If the optional <var class="var">dim</var> argument is given, operate along this dimension. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFvar">var</a>, <a class="ref" href="#XREFskewness">skewness</a>, <a class="ref" href="#XREFmoment">moment</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-moment">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">moment</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>)</code><a class="copiable-link" href="#index-moment"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-moment-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">moment</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>, <var class="var">type</var>)</code><a class="copiable-link" href="#index-moment-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-moment-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">moment</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-moment-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-moment-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">moment</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>, <var class="var">type</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-moment-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-moment-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">moment</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>, <var class="var">dim</var>, <var class="var">type</var>)</code><a class="copiable-link" href="#index-moment-4"> ¶</a></span>
</dt> <dd>
<p>Compute the <var class="var">p</var>-th central moment of the vector <var class="var">x</var>. </p> <p>The <var class="var">p</var>-th central moment of <var class="var">x</var> is defined as: </p> <pre class="example" data-language="matlab">1/N SUM_i (x(i) - mean(x))^p</pre> <p>where <em class="math">N</em> is the length of the <var class="var">x</var> vector. </p> <p>If <var class="var">x</var> is a matrix, return the row vector containing the <var class="var">p</var>-th central moment of each column. </p> <p>If the optional argument <var class="var">dim</var> is given, operate along this dimension. </p> <p>The optional string <var class="var">type</var> specifies the type of moment to be computed. Valid options are: </p> <dl class="table"> <dt><code class="code">"c"</code></dt> <dd>
<p>Central Moment (default). </p> </dd> <dt><code class="code">"a"</code></dt> <dt><code class="code">"ac"</code></dt> <dd>
<p>Absolute Central Moment. The moment about the mean ignoring sign defined as </p> <pre class="example" data-language="matlab">1/N SUM_i (abs (x(i) - mean(x)))^p</pre> </dd> <dt><code class="code">"r"</code></dt> <dd>
<p>Raw Moment. The moment about zero defined as </p> <pre class="example" data-language="matlab">moment (x) = 1/N SUM_i x(i)^p</pre> </dd> <dt><code class="code">"ar"</code></dt> <dd>
<p>Absolute Raw Moment. The moment about zero ignoring sign defined as </p> <pre class="example" data-language="matlab">1/N SUM_i ( abs (x(i)) )^p</pre> </dd> </dl> <p>If both <var class="var">type</var> and <var class="var">dim</var> are given they may appear in any order. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFvar">var</a>, <a class="ref" href="#XREFskewness">skewness</a>, <a class="ref" href="#XREFkurtosis">kurtosis</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-quantile">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quantile</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-quantile"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quantile-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quantile</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>)</code><a class="copiable-link" href="#index-quantile-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quantile-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quantile</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-quantile-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-quantile-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">quantile</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>, <var class="var">dim</var>, <var class="var">method</var>)</code><a class="copiable-link" href="#index-quantile-3"> ¶</a></span>
</dt> <dd>
<p>For a sample, <var class="var">x</var>, calculate the quantiles, <var class="var">q</var>, corresponding to the cumulative probability values in <var class="var">p</var>. All non-numeric values (NaNs) of <var class="var">x</var> are ignored. </p> <p>If <var class="var">x</var> is a matrix, compute the quantiles for each column and return them in a matrix, such that the i-th row of <var class="var">q</var> contains the <var class="var">p</var>(i)th quantiles of each column of <var class="var">x</var>. </p> <p>If <var class="var">p</var> is unspecified, return the quantiles for <code class="code">[0.00 0.25 0.50 0.75 1.00]</code>. The optional argument <var class="var">dim</var> determines the dimension along which the quantiles are calculated. If <var class="var">dim</var> is omitted it defaults to the first non-singleton dimension. </p> <p>The methods available to calculate sample quantiles are the nine methods used by R (<a class="url" href="https://www.r-project.org/">https://www.r-project.org/</a>). The default value is <var class="var">method</var> = 5. </p> <p>Discontinuous sample quantile methods 1, 2, and 3 </p> <ol class="enumerate"> <li> Method 1: Inverse of empirical distribution function. </li>
<li> Method 2: Similar to method 1 but with averaging at discontinuities. </li>
<li> Method 3: SAS definition: nearest even order statistic. </li>
</ol> <p>Continuous sample quantile methods 4 through 9, where <var class="var">p</var>(k) is the linear interpolation function respecting each method’s representative cdf. </p> <ol class="enumerate" start="4"> <li> Method 4: <var class="var">p</var>(k) = k / N. That is, linear interpolation of the empirical cdf, where <em class="math">N</em> is the length of <var class="var">P</var>. </li>
<li> Method 5: <var class="var">p</var>(k) = (k - 0.5) / N. That is, a piecewise linear function where the knots are the values midway through the steps of the empirical cdf. </li>
<li> Method 6: <var class="var">p</var>(k) = k / (N + 1). </li>
<li> Method 7: <var class="var">p</var>(k) = (k - 1) / (N - 1). </li>
<li> Method 8: <var class="var">p</var>(k) = (k - 1/3) / (N + 1/3). The resulting quantile estimates are approximately median-unbiased regardless of the distribution of <var class="var">x</var>. </li>
<li> Method 9: <var class="var">p</var>(k) = (k - 3/8) / (N + 1/4). The resulting quantile estimates are approximately unbiased for the expected order statistics if <var class="var">x</var> is normally distributed. </li>
</ol> <p>Hyndman and Fan (1996) recommend method 8. Maxima, S, and R (versions prior to 2.0.0) use 7 as their default. Minitab and SPSS use method 6. <small class="sc">MATLAB</small> uses method 5. </p> <p>References: </p> <ul class="itemize mark-bullet"> <li>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New S Language. Wadsworth &amp; Brooks/Cole. </li>
<li>Hyndman, R. J. and Fan, Y. (1996) Sample quantiles in statistical packages, American Statistician, 50, 361–365. </li>
<li>R: A Language and Environment for Statistical Computing; <a class="url" href="https://cran.r-project.org/doc/manuals/fullrefman.pdf">https://cran.r-project.org/doc/manuals/fullrefman.pdf</a>. </li>
</ul> <p>Examples: </p> <pre class="example smallexample" data-language="matlab">x = randi (1000, [10, 1]);  # Create empirical data in range 1-1000
q = quantile (x, [0, 1]);   # Return minimum, maximum of distribution
q = quantile (x, [0.25 0.5 0.75]); # Return quartiles of distribution</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFprctile">prctile</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-prctile">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">prctile</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-prctile"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-prctile-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">prctile</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>)</code><a class="copiable-link" href="#index-prctile-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-prctile-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">q</var> =</code> <strong class="def-name">prctile</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-prctile-2"> ¶</a></span>
</dt> <dd>
<p>For a sample <var class="var">x</var>, compute the quantiles, <var class="var">q</var>, corresponding to the cumulative probability values, <var class="var">p</var>, in percent. </p> <p>If <var class="var">x</var> is a matrix, compute the percentiles for each column and return them in a matrix, such that the i-th row of <var class="var">q</var> contains the <var class="var">p</var>(i)th percentiles of each column of <var class="var">x</var>. </p> <p>If <var class="var">p</var> is unspecified, return the quantiles for <code class="code">[0 25 50 75 100]</code>. </p> <p>The optional argument <var class="var">dim</var> determines the dimension along which the percentiles are calculated. If <var class="var">dim</var> is omitted it defaults to the first non-singleton dimension. </p> <p>Programming Note: All non-numeric values (NaNs) of <var class="var">x</var> are ignored. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFquantile">quantile</a>. </p>
</dd>
</dl> <p>A summary view of a data set can be generated quickly with the <code class="code">statistics</code> function. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-statistics">
<span class="category-def">: </span><span><code class="def-type"><var class="var">stats</var> =</code> <strong class="def-name">statistics</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-statistics"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-statistics-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">stats</var> =</code> <strong class="def-name">statistics</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-statistics-1"> ¶</a></span>
</dt> <dd>
<p>Return a vector with the minimum, first quartile, median, third quartile, maximum, mean, standard deviation, skewness, and kurtosis of the elements of the vector <var class="var">x</var>. </p> <p>If <var class="var">x</var> is a matrix, calculate statistics over the first non-singleton dimension. </p> <p>If the optional argument <var class="var">dim</var> is given, operate along this dimension. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="utility-functions.html#XREFmin">min</a>, <a class="ref" href="utility-functions.html#XREFmax">max</a>, <a class="ref" href="#XREFmedian">median</a>, <a class="ref" href="#XREFmean">mean</a>, <a class="ref" href="#XREFstd">std</a>, <a class="ref" href="#XREFskewness">skewness</a>, <a class="ref" href="#XREFkurtosis">kurtosis</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="statistics-on-sliding-windows-of-data.html">Statistics on Sliding Windows of Data</a>, Up: <a href="statistics.html">Statistics</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Descriptive-Statistics.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Descriptive-Statistics.html</a>
  </p>
</div>
