<div class="section" id="Special-Utility-Matrices">   <h1 class="section">16.3 Special Utility Matrices</h1> <dl class="def"> <dt id="index-eye">
<span class="category">: </span><span><em><var>I</var> =</em> <strong>eye</strong> <em>(<var>n</var>)</em><a href="#index-eye" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-eye-1">
<span class="category">: </span><span><em><var>I</var> =</em> <strong>eye</strong> <em>(<var>m</var>, <var>n</var>)</em><a href="#index-eye-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-eye-2">
<span class="category">: </span><span><em><var>I</var> =</em> <strong>eye</strong> <em>([<var>m</var> <var>n</var>])</em><a href="#index-eye-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-eye-3">
<span class="category">: </span><span><em><var>I</var> =</em> <strong>eye</strong> <em>(…, <var>class</var>)</em><a href="#index-eye-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return an identity matrix. </p> <p>If invoked with a single scalar argument <var>n</var>, return a square NxN identity matrix. </p> <p>If supplied two scalar arguments (<var>m</var>, <var>n</var>), <code>eye</code> takes them to be the number of rows and columns. If given a vector with two elements, <code>eye</code> uses the values of the elements as the number of rows and columns, respectively. For example: </p> <pre class="example" data-language="matlab">eye (3)
 ⇒  1  0  0
     0  1  0
     0  0  1</pre> <p>The following expressions all produce the same result: </p> <pre class="example" data-language="matlab">eye (2)
≡
eye (2, 2)
≡
eye (size ([1, 2; 3, 4]))</pre> <p>The optional argument <var>class</var>, allows <code>eye</code> to return an array of the specified type, like </p> <pre class="example" data-language="matlab">val = zeros (n,m, "uint8")</pre> <p>Calling <code>eye</code> with no arguments is equivalent to calling it with an argument of 1. Any negative dimensions are treated as zero. These odd definitions are for compatibility with <small>MATLAB</small>. </p> <p><strong>See also:</strong> <a href="creating-sparse-matrices.html#XREFspeye">speye</a>, <a href="#XREFones">ones</a>, <a href="#XREFzeros">zeros</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ones">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>ones</strong> <em>(<var>n</var>)</em><a href="#index-ones" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ones-1">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>ones</strong> <em>(<var>m</var>, <var>n</var>)</em><a href="#index-ones-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ones-2">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>ones</strong> <em>(<var>m</var>, <var>n</var>, <var>k</var>, …)</em><a href="#index-ones-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ones-3">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>ones</strong> <em>([<var>m</var> <var>n</var> …])</em><a href="#index-ones-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ones-4">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>ones</strong> <em>(…, "like", <var>var</var>)</em><a href="#index-ones-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ones-5">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>ones</strong> <em>(…, <var>class</var>)</em><a href="#index-ones-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a matrix or N-dimensional array whose elements are all 1. </p> <p>If invoked with a single scalar integer argument <var>n</var>, return a square NxN matrix. </p> <p>If invoked with two or more scalar integer arguments, or a vector of integer values, return an array with the given dimensions. </p> <p>To create a constant matrix whose values are all the same use an expression such as </p> <pre class="example" data-language="matlab">val_matrix = val * ones (m, n)</pre> <p>If a variable <var>var</var> is specified after <code>"like"</code>, the output <var>val</var> will have the same data type, complexity, and sparsity as <var>var</var>. </p> <p>The optional argument <var>class</var> specifies the class of the return array and defaults to double. For example: </p> <pre class="example" data-language="matlab">val = ones (m,n, "uint8")</pre> <p><strong>See also:</strong> <a href="#XREFzeros">zeros</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-zeros">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>zeros</strong> <em>(<var>n</var>)</em><a href="#index-zeros" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-zeros-1">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>zeros</strong> <em>(<var>m</var>, <var>n</var>)</em><a href="#index-zeros-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-zeros-2">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>zeros</strong> <em>(<var>m</var>, <var>n</var>, <var>k</var>, …)</em><a href="#index-zeros-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-zeros-3">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>zeros</strong> <em>([<var>m</var> <var>n</var> …])</em><a href="#index-zeros-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-zeros-4">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>zeros</strong> <em>(…, "like", <var>var</var>)</em><a href="#index-zeros-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-zeros-5">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>zeros</strong> <em>(…, <var>class</var>)</em><a href="#index-zeros-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a matrix or N-dimensional array whose elements are all 0. </p> <p>If invoked with a single scalar integer argument, return a square NxN matrix. </p> <p>If invoked with two or more scalar integer arguments, or a vector of integer values, return an array with the given dimensions. </p> <p>If a variable <var>var</var> is specified after <code>"like"</code>, the output <var>val</var> will have the same data type, complexity, and sparsity as <var>var</var>. </p> <p>The optional argument <var>class</var> specifies the class of the return array and defaults to double. For example: </p> <pre class="example" data-language="matlab">val = zeros (m,n, "uint8")</pre> <p><strong>See also:</strong> <a href="#XREFones">ones</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-repmat">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>repmat</strong> <em>(<var>A</var>, <var>m</var>)</em><a href="#index-repmat" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-repmat-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>repmat</strong> <em>(<var>A</var>, <var>m</var>, <var>n</var>)</em><a href="#index-repmat-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-repmat-2">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>repmat</strong> <em>(<var>A</var>, <var>m</var>, <var>n</var>, <var>p</var> …)</em><a href="#index-repmat-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-repmat-3">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>repmat</strong> <em>(<var>A</var>, [<var>m</var> <var>n</var>])</em><a href="#index-repmat-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-repmat-4">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>repmat</strong> <em>(<var>A</var>, [<var>m</var> <var>n</var> <var>p</var> …])</em><a href="#index-repmat-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Repeat matrix or N-D array. </p> <p>Form a block matrix of size <var>m</var> by <var>n</var>, with a copy of matrix <var>A</var> as each element. </p> <p>If <var>n</var> is not specified, form an <var>m</var> by <var>m</var> block matrix. For copying along more than two dimensions, specify the number of times to copy across each dimension <var>m</var>, <var>n</var>, <var>p</var>, …, in a vector in the second argument. </p> <p><strong>See also:</strong> <a href="broadcasting.html#XREFbsxfun">bsxfun</a>, <a href="functions-of-a-matrix.html#XREFkron">kron</a>, <a href="#XREFrepelems">repelems</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-repelems">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>repelems</strong> <em>(<var>x</var>, <var>r</var>)</em><a href="#index-repelems" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Construct a vector of repeated elements from <var>x</var>. </p> <p><var>r</var> is a 2x<var>N</var> integer matrix specifying which elements to repeat and how often to repeat each element. Entries in the first row, <var>r</var>(1,j), select an element to repeat. The corresponding entry in the second row, <var>r</var>(2,j), specifies the repeat count. If <var>x</var> is a matrix then the columns of <var>x</var> are imagined to be stacked on top of each other for purposes of the selection index. A row vector is always returned. </p> <p>Conceptually the result is calculated as follows: </p> <pre class="example" data-language="matlab">y = [];
for i = 1:columns (r)
  y = [y, x(r(1,i)*ones(1, r(2,i)))];
endfor</pre> <p><strong>See also:</strong> <a href="#XREFrepmat">repmat</a>, <a href="rearranging-matrices.html#XREFcat">cat</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-repelem">
<span class="category">: </span><span><em><var>xxx</var> =</em> <strong>repelem</strong> <em>(<var>x</var>, <var>R</var>)</em><a href="#index-repelem" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-repelem-1">
<span class="category">: </span><span><em><var>xxx</var> =</em> <strong>repelem</strong> <em>(<var>x</var>, <var>R_1</var>, …, <var>R_n</var>)</em><a href="#index-repelem-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Construct an array of repeated elements from <var>x</var> and repeat instructions <var>R_1</var>, …. </p> <p><var>x</var> must be a scalar, vector, or N-dimensional array. </p> <p>A repeat instruction <var>R_j</var> must either be a scalar or a vector. If the instruction is a scalar then each component of <var>x</var> in dimension <var>j</var> is repeated <var>R_j</var> times. If the instruction is a vector then it must have the same number of elements as the corresponding dimension <var>j</var> of <var>x</var>. In this case, the <var>k</var>th component of dimension <var>j</var> is repeated <code><var>R_j</var>(<var>k</var>)</code> times. </p> <p>If <var>x</var> is a scalar or vector then <code>repelem</code> may be called with just a single repeat instruction <var>R</var> and <code>repelem</code> will return a vector with the same orientation as the input. </p> <p>If <var>x</var> is a matrix then at least two <var>R_j</var>s must be specified. </p> <p>Note: Using <code>repelem</code> with a vector <var>x</var> and a vector for <var>R_j</var> is equivalent to Run Length Decoding. </p> <p>Examples: </p> <pre class="example" data-language="matlab">A = [1 2 3 4 5];
B = [2 1 0 1 2];
repelem (A, B)
  ⇒   1   1   2   4   5   5</pre> <pre class="example" data-language="matlab">A = magic (3)
  ⇒ A =
       8   1   6
       3   5   7
       4   9   2
B1 = [1 2 3];
B2 = 2;
repelem (A, B1, B2)
  ⇒     8   8   1   1   6   6
         3   3   5   5   7   7
         3   3   5   5   7   7
         4   4   9   9   2   2
         4   4   9   9   2   2
         4   4   9   9   2   2</pre> <p>More <var>R_j</var> may be specified than the number of dimensions of <var>x</var>. Any excess <var>R_j</var> must be scalars (because <var>x</var>’s size in those dimensions is only 1), and <var>x</var> will be replicated in those dimensions accordingly. </p> <pre class="example" data-language="matlab">A = [1 2 3 4 5];
B1 = 2;
B2 = [2 1 3 0 2];
B3 = 3;
repelem (A, B1, B2, B3)
  ⇒    ans(:,:,1) =
           1   1   2   3   3   3   5   5
           1   1   2   3   3   3   5   5

        ans(:,:,2) =

           1   1   2   3   3   3   5   5
           1   1   2   3   3   3   5   5

        ans(:,:,3) =
           1   1   2   3   3   3   5   5
           1   1   2   3   3   3   5   5</pre> <p><var>R_j</var> must be specified in order. A placeholder of 1 may be used for dimensions which do not need replication. </p> <pre class="example" data-language="matlab">repelem ([-1, 0; 0, 1], 1, 2, 1, 2)
  ⇒  ans(:,:,1,1) =
        -1  -1   0   0
         0   0   1   1

      ans(:,:,1,2) =
        -1  -1   0   0
         0   0   1   1</pre> <p>If fewer <var>R_j</var> are given than the number of dimensions in <var>x</var>, <code>repelem</code> will assume <var>R_j</var> is 1 for those dimensions. </p> <pre class="example" data-language="matlab">A = cat (3, [-1 0; 0 1], [-1 0; 0 1])
  ⇒  ans(:,:,1) =
        -1   0
         0   1

      ans(:,:,2) =
        -1   0
         0   1

repelem (A,2,3)
  ⇒  ans(:,:,1) =
        -1  -1  -1   0   0   0
        -1  -1  -1   0   0   0
         0   0   0   1   1   1
         0   0   0   1   1   1

      ans(:,:,2) =
        -1  -1  -1   0   0   0
        -1  -1  -1   0   0   0
         0   0   0   1   1   1
         0   0   0   1   1   1</pre> <p><code>repelem</code> preserves the class of <var>x</var>, and works with strings, cell arrays, NA, and NAN inputs. If any <var>R_j</var> is 0 the output will be an empty array. </p> <pre class="example" data-language="matlab">repelem ("Octave", 2, 3)
  ⇒    OOOccctttaaavvveee
        OOOccctttaaavvveee

repelem ([1 2 3; 1 2 3], 2, 0)
  ⇒    [](4x0)</pre> <p><strong>See also:</strong> <a href="rearranging-matrices.html#XREFcat">cat</a>, <a href="functions-of-a-matrix.html#XREFkron">kron</a>, <a href="#XREFrepmat">repmat</a>. </p>
</dd>
</dl> <p>The functions <code>linspace</code> and <code>logspace</code> make it very easy to create vectors with evenly or logarithmically spaced elements. See <a href="ranges.html">Ranges</a>. </p> <dl class="def"> <dt id="index-linspace">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>linspace</strong> <em>(<var>start</var>, <var>end</var>)</em><a href="#index-linspace" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-linspace-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>linspace</strong> <em>(<var>start</var>, <var>end</var>, <var>n</var>)</em><a href="#index-linspace-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a row vector with <var>n</var> linearly spaced elements between <var>start</var> and <var>end</var>. </p> <p>If the number of elements is greater than one, then the endpoints <var>start</var> and <var>end</var> are always included in the range. If <var>start</var> is greater than <var>end</var>, the elements are stored in decreasing order. If the number of points is not specified, a value of 100 is used. </p> <p>The <code>linspace</code> function returns a row vector when both <var>start</var> and <var>end</var> are scalars. If one, or both, inputs are vectors, then <code>linspace</code> transforms them to column vectors and returns a matrix where each row is an independent sequence between <code><var>start</var>(<var><span class="nolinebreak">row_n</span></var>), <var>end</var>(<var><span class="nolinebreak">row_n</span></var>)</code>. </p> <p>For compatibility with <small>MATLAB</small>, return the second argument (<var>end</var>) when only a single value (<var>n</var> = 1) is requested. </p> <p><strong>See also:</strong> <a href="defining-indexing-and-indexed-assignment.html#XREFcolon">colon</a>, <a href="#XREFlogspace">logspace</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-logspace">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>logspace</strong> <em>(<var>a</var>, <var>b</var>)</em><a href="#index-logspace" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-logspace-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>logspace</strong> <em>(<var>a</var>, <var>b</var>, <var>n</var>)</em><a href="#index-logspace-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-logspace-2">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>logspace</strong> <em>(<var>a</var>, pi, <var>n</var>)</em><a href="#index-logspace-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a row vector with <var>n</var> elements logarithmically spaced from 10^<var>a</var> to 10^<var>b</var>. </p> <p>If <var>n</var> is unspecified it defaults to 50. </p> <p>If <var>b</var> is equal to pi, the points are between 10^<var>a</var> and pi, <em>not</em> 10^<var>a</var> and 10^pi, in order to be compatible with the corresponding <small>MATLAB</small> function. </p> <p>Also for compatibility with <small>MATLAB</small>, return the right-hand side of the range (10^<var>b</var>) when just a single value is requested. </p> <p><strong>See also:</strong> <a href="#XREFlinspace">linspace</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-rand">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>rand</strong> <em>(<var>n</var>)</em><a href="#index-rand" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rand-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>rand</strong> <em>(<var>m</var>, <var>n</var>, …)</em><a href="#index-rand-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rand-2">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>rand</strong> <em>([<var>m</var> <var>n</var> …])</em><a href="#index-rand-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rand-3">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>rand</strong> <em>(…, "single")</em><a href="#index-rand-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rand-4">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>rand</strong> <em>(…, "double")</em><a href="#index-rand-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rand-5">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>rand</strong> <em>("state")</em><a href="#index-rand-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rand-6">
<span class="category">: </span><span> <strong>rand</strong> <em>("state", <var>v</var>)</em><a href="#index-rand-6" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rand-7">
<span class="category">: </span><span> <strong>rand</strong> <em>("state", "reset")</em><a href="#index-rand-7" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rand-8">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>rand</strong> <em>("seed")</em><a href="#index-rand-8" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rand-9">
<span class="category">: </span><span> <strong>rand</strong> <em>("seed", <var>v</var>)</em><a href="#index-rand-9" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rand-10">
<span class="category">: </span><span> <strong>rand</strong> <em>("seed", "reset")</em><a href="#index-rand-10" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a matrix with random elements uniformly distributed on the interval (0, 1). </p> <p>The arguments are handled the same as the arguments for <code>eye</code>. </p> <p>You can query the state of the random number generator using the form </p> <pre class="example" data-language="matlab">v = rand ("state")</pre> <p>This returns a column vector <var>v</var> of length 625. Later, you can restore the random number generator to the state <var>v</var> using the form </p> <pre class="example" data-language="matlab">rand ("state", v)</pre> <p>You may also initialize the state vector from an arbitrary vector of length ≤ 625 for <var>v</var>. This new state will be a hash based on the value of <var>v</var>, not <var>v</var> itself. </p> <p>By default, the generator is initialized by contributing entropy from the wall clock time, the CPU time, the current fraction of a second, the process ID and—if available—up to 1024 bits from the C++ random numbers source <code>random_device</code>, which might be non-deterministic (implementation specific). Note that this differs from <small>MATLAB</small>, which always initializes the state to the same state at startup. To obtain behavior comparable to <small>MATLAB</small>, initialize with a deterministic state vector in Octave’s startup files (see <a href="startup-files.html">Startup Files</a>). </p> <p>To compute the pseudo-random sequence, <code>rand</code> uses the Mersenne Twister with a period of <em class="math">2^{19937}-1</em> (See M. Matsumoto and T. Nishimura, <cite>Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator</cite>, ACM Trans. on Modeling and Computer Simulation Vol. 8, No. 1, pp. 3–30, January 1998, <a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html">http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html</a>). Do <strong>not</strong> use for cryptography without securely hashing several returned values together, otherwise the generator state can be learned after reading 624 consecutive values. </p> <p>Older versions of Octave used a different random number generator. The new generator is used by default as it is significantly faster than the old generator, and produces random numbers with a significantly longer cycle time. However, in some circumstances it might be desirable to obtain the same random sequences as produced by the old generators. To do this the keyword <code>"seed"</code> is used to specify that the old generators should be used, as in </p> <pre class="example" data-language="matlab">rand ("seed", val)</pre> <p>which sets the seed of the generator to <var>val</var>. The seed of the generator can be queried with </p> <pre class="example" data-language="matlab">s = rand ("seed")</pre> <p>However, it should be noted that querying the seed will not cause <code>rand</code> to use the old generators, only setting the seed will. To cause <code>rand</code> to once again use the new generators, the keyword <code>"state"</code> should be used to reset the state of the <code>rand</code>. </p> <p>The state or seed of the generator can be reset to a new random value using the <code>"reset"</code> keyword. </p> <p>The class of the value returned can be controlled by a trailing <code>"double"</code> or <code>"single"</code> argument. These are the only valid classes. </p> <p><strong>See also:</strong> <a href="#XREFrandn">randn</a>, <a href="#XREFrande">rande</a>, <a href="#XREFrandg">randg</a>, <a href="#XREFrandp">randp</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-randi">
<span class="category">: </span><span><em><var>R</var> =</em> <strong>randi</strong> <em>(<var>imax</var>)</em><a href="#index-randi" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randi-1">
<span class="category">: </span><span><em><var>R</var> =</em> <strong>randi</strong> <em>(<var>imax</var>, <var>n</var>)</em><a href="#index-randi-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randi-2">
<span class="category">: </span><span><em><var>R</var> =</em> <strong>randi</strong> <em>(<var>imax</var>, <var>m</var>, <var>n</var>, …)</em><a href="#index-randi-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randi-3">
<span class="category">: </span><span><em><var>R</var> =</em> <strong>randi</strong> <em>([<var>imin</var> <var>imax</var>], …)</em><a href="#index-randi-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randi-4">
<span class="category">: </span><span><em><var>R</var> =</em> <strong>randi</strong> <em>(…, "<var>class</var>")</em><a href="#index-randi-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return random integers in the range 1:<var>imax</var>. </p> <p>Additional arguments determine the shape of the return matrix. When no arguments are specified a single random integer is returned. If one argument <var>n</var> is specified then a square matrix (<var>n</var> x <var>n</var>) is returned. Two or more arguments will return a multi-dimensional matrix (<var>m</var> x <var>n</var> x …). </p> <p>The integer range may optionally be described by a two-element matrix with a lower and upper bound in which case the returned integers will be on the interval [<var>imin</var>, <var>imax</var>]. </p> <p>The optional argument <var>class</var> will return a matrix of the requested type. The default is <code>"double"</code>. </p> <p>The following example returns 150 integers in the range 1–10. </p> <pre class="example" data-language="matlab">ri = randi (10, 150, 1)</pre> <p>Implementation Note: <code>randi</code> relies internally on <code>rand</code> which uses class <code>"double"</code> to represent numbers. This limits the maximum integer (<var>imax</var>) and range (<var>imax</var> - <var>imin</var>) to the value returned by the <code>flintmax</code> function. For IEEE floating point numbers this value is <em class="math">2^{53} - 1</em>. </p> <p><strong>See also:</strong> <a href="#XREFrand">rand</a>, <a href="#XREFrandn">randn</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-randn">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randn</strong> <em>(<var>n</var>)</em><a href="#index-randn" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randn-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randn</strong> <em>(<var>m</var>, <var>n</var>, …)</em><a href="#index-randn-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randn-2">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randn</strong> <em>([<var>m</var> <var>n</var> …])</em><a href="#index-randn-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randn-3">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randn</strong> <em>(…, "single")</em><a href="#index-randn-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randn-4">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randn</strong> <em>(…, "double")</em><a href="#index-randn-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randn-5">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>randn</strong> <em>("state")</em><a href="#index-randn-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randn-6">
<span class="category">: </span><span> <strong>randn</strong> <em>("state", <var>v</var>)</em><a href="#index-randn-6" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randn-7">
<span class="category">: </span><span> <strong>randn</strong> <em>("state", "reset")</em><a href="#index-randn-7" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randn-8">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>randn</strong> <em>("seed")</em><a href="#index-randn-8" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randn-9">
<span class="category">: </span><span> <strong>randn</strong> <em>("seed", <var>v</var>)</em><a href="#index-randn-9" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randn-10">
<span class="category">: </span><span> <strong>randn</strong> <em>("seed", "reset")</em><a href="#index-randn-10" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a matrix with normally distributed random elements having zero mean and variance one. </p> <p>The arguments are handled the same as the arguments for <code>rand</code>. </p> <p>By default, <code>randn</code> uses the Marsaglia and Tsang “Ziggurat technique” to transform from a uniform to a normal distribution. </p> <p>The class of the value returned can be controlled by a trailing <code>"double"</code> or <code>"single"</code> argument. These are the only valid classes. </p> <p>Reference: G. Marsaglia and W.W. Tsang, <cite>Ziggurat Method for Generating Random Variables</cite>, J. Statistical Software, vol 5, 2000, <a href="https://www.jstatsoft.org/v05/i08/">https://www.jstatsoft.org/v05/i08/</a> </p> <p><strong>See also:</strong> <a href="#XREFrand">rand</a>, <a href="#XREFrande">rande</a>, <a href="#XREFrandg">randg</a>, <a href="#XREFrandp">randp</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-rande">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>rande</strong> <em>(<var>n</var>)</em><a href="#index-rande" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rande-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>rande</strong> <em>(<var>m</var>, <var>n</var>, …)</em><a href="#index-rande-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rande-2">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>rande</strong> <em>([<var>m</var> <var>n</var> …])</em><a href="#index-rande-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rande-3">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>rande</strong> <em>(…, "single")</em><a href="#index-rande-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rande-4">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>rande</strong> <em>(…, "double")</em><a href="#index-rande-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rande-5">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>rande</strong> <em>("state")</em><a href="#index-rande-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rande-6">
<span class="category">: </span><span> <strong>rande</strong> <em>("state", <var>v</var>)</em><a href="#index-rande-6" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rande-7">
<span class="category">: </span><span> <strong>rande</strong> <em>("state", "reset")</em><a href="#index-rande-7" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rande-8">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>rande</strong> <em>("seed")</em><a href="#index-rande-8" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rande-9">
<span class="category">: </span><span> <strong>rande</strong> <em>("seed", <var>v</var>)</em><a href="#index-rande-9" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rande-10">
<span class="category">: </span><span> <strong>rande</strong> <em>("seed", "reset")</em><a href="#index-rande-10" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a matrix with exponentially distributed random elements. </p> <p>The arguments are handled the same as the arguments for <code>rand</code>. </p> <p>By default, <code>rande</code> uses the Marsaglia and Tsang “Ziggurat technique” to transform from a uniform to an exponential distribution. </p> <p>The class of the value returned can be controlled by a trailing <code>"double"</code> or <code>"single"</code> argument. These are the only valid classes. </p> <p>Reference: G. Marsaglia and W.W. Tsang, <cite>Ziggurat Method for Generating Random Variables</cite>, J. Statistical Software, vol 5, 2000, <a href="https://www.jstatsoft.org/v05/i08/">https://www.jstatsoft.org/v05/i08/</a> </p> <p><strong>See also:</strong> <a href="#XREFrand">rand</a>, <a href="#XREFrandn">randn</a>, <a href="#XREFrandg">randg</a>, <a href="#XREFrandp">randp</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-randp">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randp</strong> <em>(<var>l</var>, <var>n</var>)</em><a href="#index-randp" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randp-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randp</strong> <em>(<var>l</var>, <var>m</var>, <var>n</var>, …)</em><a href="#index-randp-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randp-2">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randp</strong> <em>(<var>l</var>, [<var>m</var> <var>n</var> …])</em><a href="#index-randp-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randp-3">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randp</strong> <em>(…, "single")</em><a href="#index-randp-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randp-4">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randp</strong> <em>(…, "double")</em><a href="#index-randp-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randp-5">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>randp</strong> <em>("state")</em><a href="#index-randp-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randp-6">
<span class="category">: </span><span> <strong>randp</strong> <em>("state", <var>v</var>)</em><a href="#index-randp-6" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randp-7">
<span class="category">: </span><span> <strong>randp</strong> <em>("state", "reset")</em><a href="#index-randp-7" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randp-8">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>randp</strong> <em>("seed")</em><a href="#index-randp-8" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randp-9">
<span class="category">: </span><span> <strong>randp</strong> <em>("seed", <var>v</var>)</em><a href="#index-randp-9" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randp-10">
<span class="category">: </span><span> <strong>randp</strong> <em>("seed", "reset")</em><a href="#index-randp-10" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a matrix with Poisson distributed random elements with mean value parameter given by the first argument, <var>l</var>. </p> <p>The arguments are handled the same as the arguments for <code>rand</code>, except for the argument <var>l</var>. </p> <p>Five different algorithms are used depending on the range of <var>l</var> and whether or not <var>l</var> is a scalar or a matrix. </p> <dl compact> <dt><span>For scalar <var>l</var> ≤ 12, use direct method.</span></dt> <dd>
<p>W.H. Press, et al., <cite>Numerical Recipes in C</cite>, Cambridge University Press, 1992. </p> </dd> <dt><span>For scalar <var>l</var> &gt; 12, use rejection method.[1]</span></dt> <dd>
<p>W.H. Press, et al., <cite>Numerical Recipes in C</cite>, Cambridge University Press, 1992. </p> </dd> <dt><span>For matrix <var>l</var> ≤ 10, use inversion method.[2]</span></dt> <dd>
<p>E. Stadlober, et al., WinRand source code, available via FTP. </p> </dd> <dt><span>For matrix <var>l</var> &gt; 10, use patchwork rejection method.</span></dt> <dd>
<p>E. Stadlober, et al., WinRand source code, available via FTP, or H. Zechner, <cite>Efficient sampling from continuous and discrete unimodal distributions</cite>, Doctoral Dissertation, 156pp., Technical University Graz, Austria, 1994. </p> </dd> <dt><span>For <var>l</var> &gt; 1e8, use normal approximation.</span></dt> <dd><p>L. Montanet, et al., <cite>Review of Particle Properties</cite>, Physical Review D 50 p1284, 1994. </p></dd> </dl> <p>The class of the value returned can be controlled by a trailing <code>"double"</code> or <code>"single"</code> argument. These are the only valid classes. </p> <p><strong>See also:</strong> <a href="#XREFrand">rand</a>, <a href="#XREFrandn">randn</a>, <a href="#XREFrande">rande</a>, <a href="#XREFrandg">randg</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-randg">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randg</strong> <em>(<var>a</var>, <var>n</var>)</em><a href="#index-randg" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randg-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randg</strong> <em>(<var>a</var>, <var>m</var>, <var>n</var>, …)</em><a href="#index-randg-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randg-2">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randg</strong> <em>(<var>a</var>, [<var>m</var> <var>n</var> …])</em><a href="#index-randg-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randg-3">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randg</strong> <em>(…, "single")</em><a href="#index-randg-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randg-4">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>randg</strong> <em>(…, "double")</em><a href="#index-randg-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randg-5">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>randg</strong> <em>("state")</em><a href="#index-randg-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randg-6">
<span class="category">: </span><span> <strong>randg</strong> <em>("state", <var>v</var>)</em><a href="#index-randg-6" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randg-7">
<span class="category">: </span><span> <strong>randg</strong> <em>("state", "reset")</em><a href="#index-randg-7" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randg-8">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>randg</strong> <em>("seed")</em><a href="#index-randg-8" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randg-9">
<span class="category">: </span><span> <strong>randg</strong> <em>("seed", <var>v</var>)</em><a href="#index-randg-9" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randg-10">
<span class="category">: </span><span> <strong>randg</strong> <em>("seed", "reset")</em><a href="#index-randg-10" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Return a matrix with <code>gamma (<var>a</var>,1)</code> distributed random elements. </p> <p>The arguments are handled the same as the arguments for <code>rand</code>, except for the argument <var>a</var>. </p> <p>This can be used to generate many distributions: </p> <dl compact> <dt><span><code>gamma (a, b)</code> for <code>a &gt; -1</code>, <code>b &gt; 0</code></span></dt> <dd> <pre class="example" data-language="matlab">r = b * randg (a)</pre> </dd> <dt><span><code>beta (a, b)</code> for <code>a &gt; -1</code>, <code>b &gt; -1</code></span></dt> <dd> <pre class="example" data-language="matlab">r1 = randg (a, 1)
r = r1 / (r1 + randg (b, 1))</pre> </dd> <dt><span><code>Erlang (a, n)</code></span></dt> <dd> <pre class="example" data-language="matlab">r = a * randg (n)</pre> </dd> <dt><span><code>chisq (df)</code> for <code>df &gt; 0</code></span></dt> <dd> <pre class="example" data-language="matlab">r = 2 * randg (df / 2)</pre> </dd> <dt><span><code>t (df)</code> for <code>0 &lt; df &lt; inf</code> (use randn if df is infinite)</span></dt> <dd> <pre class="example" data-language="matlab">r = randn () / sqrt (2 * randg (df / 2) / df)</pre> </dd> <dt><span><code>F (n1, n2)</code> for <code>0 &lt; n1</code>, <code>0 &lt; n2</code></span></dt> <dd> <pre class="example" data-language="matlab">## r1 equals 1 if n1 is infinite
r1 = 2 * randg (n1 / 2) / n1
## r2 equals 1 if n2 is infinite
r2 = 2 * randg (n2 / 2) / n2
r = r1 / r2</pre> </dd> <dt><span>negative <code>binomial (n, p)</code> for <code>n &gt; 0</code>, <code>0 &lt; p &lt;= 1</code></span></dt> <dd> <pre class="example" data-language="matlab">r = randp ((1 - p) / p * randg (n))</pre> </dd> <dt><span>non-central <code>chisq (df, L)</code>, for <code>df &gt;= 0</code> and <code>L &gt; 0</code></span></dt> <dd>
<p>(use chisq if <code>L = 0</code>) </p> <pre class="example" data-language="matlab">r = randp (L / 2)
r(r &gt; 0) = 2 * randg (r(r &gt; 0))
r(df &gt; 0) += 2 * randg (df(df &gt; 0)/2)</pre> </dd> <dt><span><code>Dirichlet (a1, … ak)</code></span></dt> <dd> <pre class="example" data-language="matlab">r = (randg (a1), …, randg (ak))
r = r / sum (r)</pre> </dd> </dl> <p>The class of the value returned can be controlled by a trailing <code>"double"</code> or <code>"single"</code> argument. These are the only valid classes. </p> <p><strong>See also:</strong> <a href="#XREFrand">rand</a>, <a href="#XREFrandn">randn</a>, <a href="#XREFrande">rande</a>, <a href="#XREFrandp">randp</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-rng">
<span class="category">: </span><span> <strong>rng</strong> <em>(<var>seed</var>)</em><a href="#index-rng" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rng-1">
<span class="category">: </span><span> <strong>rng</strong> <em>(<var>seed</var>, "<var>generator</var>")</em><a href="#index-rng-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rng-2">
<span class="category">: </span><span> <strong>rng</strong> <em>("shuffle")</em><a href="#index-rng-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rng-3">
<span class="category">: </span><span> <strong>rng</strong> <em>("shuffle", "<var>generator</var>")</em><a href="#index-rng-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rng-4">
<span class="category">: </span><span> <strong>rng</strong> <em>("default")</em><a href="#index-rng-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rng-5">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>rng</strong> <em>()</em><a href="#index-rng-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rng-6">
<span class="category">: </span><span> <strong>rng</strong> <em>(<var>s</var>)</em><a href="#index-rng-6" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rng-7">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>rng</strong> <em>(…)</em><a href="#index-rng-7" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Set or query the seed of the random number generator used by <code>rand</code> and <code>randn</code>. </p> <p>The input <var>seed</var> is a scalar numeric value used to initialize the state vector of the random number generator. </p> <p>The optional string <var>generator</var> specifies the type of random number generator to be used. Its value can be <code>"twister"</code>, <code>"v5uniform"</code>, or <code>"v5normal"</code>. The <code>"twister"</code> keyword is described below. <code>"v5uniform"</code> and <code>"v5normal"</code> refer to older versions of Octave that used to use a different random number generator. </p> <p>The state or seed of the random number generator can be reset to a new random value using the <code>"shuffle"</code> keyword. </p> <p>The random number generator can be reset to default values using the <code>"default"</code> keyword. The default values are to use the Mersenne Twister generator with a seed of 0. </p> <p>The optional return value <var>s</var> contains the state of the random number generator at the time the function is called (i.e., before it might be modified according to the input arguments). It is encoded as a structure variable with three fields: <code>"Type"</code>, <code>"Seed"</code>, and <code>"State"</code>. The random number generator can be restored to the state <var>s</var> using <code>rng (<var>s</var>)</code>. This is useful when the identical sequence of pseudo-random numbers is required for an algorithm. </p> <p>By default, and with the <code>"twister"</code> option, pseudo-random sequences are computed using the Mersenne Twister with a period of <em class="math">2^{19937}-1</em> (See M. Matsumoto and T. Nishimura, <cite>Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator</cite>, ACM Trans. on Modeling and Computer Simulation Vol. 8, No. 1, pp. 3–30, January 1998, <a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html">http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html</a>). Do <strong>not</strong> use for cryptography without securely hashing several returned values together, otherwise the generator state can be learned after reading 624 consecutive values. </p> <p><strong>See also:</strong> <a href="#XREFrand">rand</a>, <a href="#XREFrandn">randn</a>. </p>
</dd>
</dl> <p>The generators operate in the new or old style together, it is not possible to mix the two. Initializing any generator with <code>"state"</code> or <code>"seed"</code> causes the others to switch to the same style for future calls. </p> <p>The state of each generator is independent and calls to different generators can be interleaved without affecting the final result. For example, </p> <pre class="example" data-language="matlab">rand ("state", [11, 22, 33]);
randn ("state", [44, 55, 66]);
u = rand (100, 1);
n = randn (100, 1);</pre> <p>and </p> <pre class="example" data-language="matlab">rand ("state", [11, 22, 33]);
randn ("state", [44, 55, 66]);
u = zeros (100, 1);
n = zeros (100, 1);
for i = 1:100
  u(i) = rand ();
  n(i) = randn ();
end</pre> <p>produce equivalent results. When the generators are initialized in the old style with <code>"seed"</code> only <code>rand</code> and <code>randn</code> are independent, because the old <code>rande</code>, <code>randg</code> and <code>randp</code> generators make calls to <code>rand</code> and <code>randn</code>. </p> <p>The generators are initialized with random states at start-up, so that the sequences of random numbers are not the same each time you run Octave.<a id="DOCF7" href="#FOOT7"><sup>7</sup></a> If you really do need to reproduce a sequence of numbers exactly, you can set the state or seed to a specific value. </p> <p>If invoked without arguments, <code>rand</code> and <code>randn</code> return a single element of a random sequence. </p> <p>The original <code>rand</code> and <code>randn</code> functions use Fortran code from <small>RANLIB</small>, a library of Fortran routines for random number generation, compiled by Barry W. Brown and James Lovato of the Department of Biomathematics at The University of Texas, M.D. Anderson Cancer Center, Houston, TX 77030. </p> <dl class="def"> <dt id="index-randperm">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>randperm</strong> <em>(<var>n</var>)</em><a href="#index-randperm" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-randperm-1">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>randperm</strong> <em>(<var>n</var>, <var>m</var>)</em><a href="#index-randperm-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a row vector containing a random permutation of <code>1:<var>n</var></code>. </p> <p>If <var>m</var> is supplied, return <var>m</var> unique entries, sampled without replacement from <code>1:<var>n</var></code>. </p> <p>The complexity is O(<var>n</var>) in memory and O(<var>m</var>) in time, unless <var>m</var> &lt; <var>n</var>/5, in which case O(<var>m</var>) memory is used as well. The randomization is performed using rand(). All permutations are equally likely. </p> <p><strong>See also:</strong> <a href="basic-statistical-functions.html#XREFperms">perms</a>. </p>
</dd>
</dl> </div> <div class="footnote">  <h4 class="footnotes-heading">Footnotes</h4> <h5 id="">(7)</h5> <p>The old versions of <code>rand</code> and <code>randn</code> obtain their initial seeds from the system clock.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Special-Utility-Matrices.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Special-Utility-Matrices.html</a>
  </p>
</div>
