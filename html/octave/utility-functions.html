<div class="section-level-extent" id="Utility-Functions"> <div class="nav-panel"> <p> Next: <a href="special-functions.html" accesskey="n" rel="next">Special Functions</a>, Previous: <a href="sums-and-products.html" accesskey="p" rel="prev">Sums and Products</a>, Up: <a href="arithmetic.html" accesskey="u" rel="up">Arithmetic</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Utility-Functions-1"><span>17.5 Utility Functions<a class="copiable-link" href="#Utility-Functions-1"> ¶</a></span></h1>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ceil">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">ceil</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-ceil"> ¶</a></span>
</dt> <dd>
<p>Return the smallest integer not less than <var class="var">x</var>. </p> <p>This is equivalent to rounding towards positive infinity. </p> <p>If <var class="var">x</var> is complex, return <code class="code">ceil (real (<var class="var">x</var>)) + ceil (imag (<var class="var">x</var>)) * I</code>. </p> <pre class="example" data-language="matlab">ceil ([-2.7, 2.7])
    ⇒ -2    3</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfloor">floor</a>, <a class="ref" href="#XREFround">round</a>, <a class="ref" href="#XREFfix">fix</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fix">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fix</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-fix"> ¶</a></span>
</dt> <dd>
<p>Truncate fractional portion of <var class="var">x</var> and return the integer portion. </p> <p>This is equivalent to rounding towards zero. If <var class="var">x</var> is complex, return <code class="code">fix (real (<var class="var">x</var>)) + fix (imag (<var class="var">x</var>)) * I</code>. </p> <pre class="example" data-language="matlab">fix ([-2.7, 2.7])
   ⇒ -2    2</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFceil">ceil</a>, <a class="ref" href="#XREFfloor">floor</a>, <a class="ref" href="#XREFround">round</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-floor">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">floor</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-floor"> ¶</a></span>
</dt> <dd>
<p>Return the largest integer not greater than <var class="var">x</var>. </p> <p>This is equivalent to rounding towards negative infinity. If <var class="var">x</var> is complex, return <code class="code">floor (real (<var class="var">x</var>)) + floor (imag (<var class="var">x</var>)) * I</code>. </p> <pre class="example" data-language="matlab">floor ([-2.7, 2.7])
     ⇒ -3    2</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFceil">ceil</a>, <a class="ref" href="#XREFround">round</a>, <a class="ref" href="#XREFfix">fix</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-round">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">round</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-round"> ¶</a></span>
</dt> <dd>
<p>Return the integer nearest to <var class="var">x</var>. </p> <p>If <var class="var">x</var> is complex, return <code class="code">round (real (<var class="var">x</var>)) + round (imag (<var class="var">x</var>)) * I</code>. If there are two nearest integers, return the one further away from zero. </p> <pre class="example" data-language="matlab">round ([-2.7, 2.7])
     ⇒ -3    3</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFceil">ceil</a>, <a class="ref" href="#XREFfloor">floor</a>, <a class="ref" href="#XREFfix">fix</a>, <a class="ref" href="#XREFroundb">roundb</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-roundb">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">roundb</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-roundb"> ¶</a></span>
</dt> <dd>
<p>Return the integer nearest to <var class="var">x</var>. If there are two nearest integers, return the even one (banker’s rounding). </p> <p>If <var class="var">x</var> is complex, return <code class="code">roundb (real (<var class="var">x</var>)) + roundb (imag (<var class="var">x</var>)) * I</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFround">round</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-max">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">max</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-max"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-max-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">max</strong> <code class="def-code-arguments">(<var class="var">x</var>, [], <var class="var">dim</var>)</code><a class="copiable-link" href="#index-max-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-max-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">m</var>, <var class="var">im</var>] =</code> <strong class="def-name">max</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-max-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-max-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">max</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-max-3"> ¶</a></span>
</dt> <dd>
<p>Find maximum values in the array <var class="var">x</var>. </p> <p>For a vector argument, return the maximum value. For a matrix argument, return a row vector with the maximum value of each column. For a multi-dimensional array, <code class="code">max</code> operates along the first non-singleton dimension. </p> <p>If the optional third argument <var class="var">dim</var> is present then operate along this dimension. In this case the second argument is ignored and should be set to the empty matrix. </p> <p>For two inputs (<var class="var">x</var> and <var class="var">y</var>), return the pairwise maximum according to the rules for <a class="ref" href="broadcasting.html">Broadcasting</a>. </p> <p>Thus, </p> <pre class="example" data-language="matlab">max (max (x))</pre> <p>returns the largest element of the 2-D matrix <var class="var">x</var>, and </p> <pre class="example" data-language="matlab">max (2:5, pi)
    ⇒  3.1416  3.1416  4.0000  5.0000</pre> <p>compares each element of the range <code class="code">2:5</code> with <code class="code">pi</code>, and returns a row vector of the maximum values. </p> <p>For complex arguments, the magnitude of the elements are used for comparison. If the magnitudes are identical, then the results are ordered by phase angle in the range (-pi, pi]. Hence, </p> <pre class="example" data-language="matlab">max ([-1 i 1 -i])
    ⇒ -1</pre> <p>because all entries have magnitude 1, but -1 has the largest phase angle with value pi. </p> <p>If called with one input and two output arguments, <code class="code">max</code> also returns the first index of the maximum value(s). Thus, </p> <pre class="example" data-language="matlab">[x, ix] = max ([1, 3, 5, 2, 5])
    ⇒  x = 5
        ix = 3</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmin">min</a>, <a class="ref" href="#XREFcummax">cummax</a>, <a class="ref" href="#XREFcummin">cummin</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-min">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">min</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-min"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-min-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">min</strong> <code class="def-code-arguments">(<var class="var">x</var>, [], <var class="var">dim</var>)</code><a class="copiable-link" href="#index-min-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-min-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">m</var>, <var class="var">im</var>] =</code> <strong class="def-name">min</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-min-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-min-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">min</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-min-3"> ¶</a></span>
</dt> <dd>
<p>Find minimum values in the array <var class="var">x</var>. </p> <p>For a vector argument, return the minimum value. For a matrix argument, return a row vector with the minimum value of each column. For a multi-dimensional array, <code class="code">min</code> operates along the first non-singleton dimension. </p> <p>If the optional third argument <var class="var">dim</var> is present then operate along this dimension. In this case the second argument is ignored and should be set to the empty matrix. </p> <p>For two inputs (<var class="var">x</var> and <var class="var">y</var>), return the pairwise minimum according to the rules for <a class="ref" href="broadcasting.html">Broadcasting</a>. </p> <p>Thus, </p> <pre class="example" data-language="matlab">min (min (x))</pre> <p>returns the smallest element of the 2-D matrix <var class="var">x</var>, and </p> <pre class="example" data-language="matlab">min (2:5, pi)
    ⇒  2.0000  3.0000  3.1416  3.1416</pre> <p>compares each element of the range <code class="code">2:5</code> with <code class="code">pi</code>, and returns a row vector of the minimum values. </p> <p>For complex arguments, the magnitude of the elements are used for comparison. If the magnitudes are identical, then the results are ordered by phase angle in the range (-pi, pi]. Hence, </p> <pre class="example" data-language="matlab">min ([-1 i 1 -i])
    ⇒ -i</pre> <p>because all entries have magnitude 1, but -i has the smallest phase angle with value -pi/2. </p> <p>If called with one input and two output arguments, <code class="code">min</code> also returns the first index of the minimum value(s). Thus, </p> <pre class="example" data-language="matlab">[x, ix] = min ([1, 3, 0, 2, 0])
    ⇒  x = 0
        ix = 3</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmax">max</a>, <a class="ref" href="#XREFcummin">cummin</a>, <a class="ref" href="#XREFcummax">cummax</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-cummax">
<span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">cummax</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-cummax"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-cummax-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">cummax</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-cummax-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-cummax-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">M</var>, <var class="var">IM</var>] =</code> <strong class="def-name">cummax</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-cummax-2"> ¶</a></span>
</dt> <dd>
<p>Return the cumulative maximum values along dimension <var class="var">dim</var>. </p> <p>If <var class="var">dim</var> is unspecified it defaults to column-wise operation. For example: </p> <pre class="example" data-language="matlab">cummax ([1 3 2 6 4 5])
   ⇒  1  3  3  6  6  6</pre> <p>If called with two output arguments the index of the maximum value is also returned. </p> <pre class="example" data-language="matlab">[w, iw] = cummax ([1 3 2 6 4 5])
⇒
M =  1  3  3  6  6  6
IM = 1  2  2  4  4  4</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcummin">cummin</a>, <a class="ref" href="#XREFmax">max</a>, <a class="ref" href="#XREFmin">min</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-cummin">
<span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">cummin</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-cummin"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-cummin-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">cummin</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-cummin-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-cummin-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">M</var>, <var class="var">IM</var>] =</code> <strong class="def-name">cummin</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-cummin-2"> ¶</a></span>
</dt> <dd>
<p>Return the cumulative minimum values along dimension <var class="var">dim</var>. </p> <p>If <var class="var">dim</var> is unspecified it defaults to column-wise operation. For example: </p> <pre class="example" data-language="matlab">cummin ([5 4 6 2 3 1])
   ⇒  5  4  4  2  2  1</pre> <p>If called with two output arguments the index of the minimum value is also returned. </p> <pre class="example" data-language="matlab">[M, IM] = cummin ([5 4 6 2 3 1])
⇒
M =  5  4  4  2  2  1
IM = 1  2  2  4  4  6</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcummax">cummax</a>, <a class="ref" href="#XREFmin">min</a>, <a class="ref" href="#XREFmax">max</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-hypot">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">hypot</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-hypot"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-hypot-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">hypot</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, …)</code><a class="copiable-link" href="#index-hypot-1"> ¶</a></span>
</dt> <dd>
<p>Compute the element-by-element square root of the sum of the squares of <var class="var">x</var> and <var class="var">y</var>. </p> <p>This is equivalent to <code class="code">sqrt (<var class="var">x</var>.^2 + <var class="var">y</var>.^2)</code>, but is calculated in a manner that avoids overflows for large values of <var class="var">x</var> or <var class="var">y</var>. </p> <p><code class="code">hypot</code> can also be called with more than 2 arguments; in this case, the arguments are accumulated from left to right: </p> <pre class="example" data-language="matlab">hypot (hypot (x, y), z)
hypot (hypot (hypot (x, y), z), w), etc.</pre> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-gradient">
<span class="category-def">: </span><span><code class="def-type"><var class="var">dx</var> =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-gradient"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">dx</var>, <var class="var">dy</var>, <var class="var">dz</var>, …] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-gradient-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-2">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">s</var>)</code><a class="copiable-link" href="#index-gradient-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-3">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, …)</code><a class="copiable-link" href="#index-gradient-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-4">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">x0</var>)</code><a class="copiable-link" href="#index-gradient-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-5">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">x0</var>, <var class="var">s</var>)</code><a class="copiable-link" href="#index-gradient-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-6">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">x0</var>, <var class="var">x</var>, <var class="var">y</var>, …)</code><a class="copiable-link" href="#index-gradient-6"> ¶</a></span>
</dt> <dd> <p>Calculate the gradient of sampled data or a function. </p> <p>If <var class="var">m</var> is a vector, calculate the one-dimensional gradient of <var class="var">m</var>. If <var class="var">m</var> is a matrix the gradient is calculated for each dimension. </p> <p><code class="code">[<var class="var">dx</var>, <var class="var">dy</var>] = gradient (<var class="var">m</var>)</code> calculates the one-dimensional gradient for <var class="var">x</var> and <var class="var">y</var> direction if <var class="var">m</var> is a matrix. Additional return arguments can be use for multi-dimensional matrices. </p> <p>A constant spacing between two points can be provided by the <var class="var">s</var> parameter. If <var class="var">s</var> is a scalar, it is assumed to be the spacing for all dimensions. Otherwise, separate values of the spacing can be supplied by the <var class="var">x</var>, … arguments. Scalar values specify an equidistant spacing. Vector values for the <var class="var">x</var>, … arguments specify the coordinate for that dimension. The length must match their respective dimension of <var class="var">m</var>. </p> <p>At boundary points a linear extrapolation is applied. Interior points are calculated with the first approximation of the numerical gradient </p> <pre class="example" data-language="matlab">y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).</pre> <p>If the first argument <var class="var">f</var> is a function handle, the gradient of the function at the points in <var class="var">x0</var> is approximated using central difference. For example, <code class="code">gradient (@cos, 0)</code> approximates the gradient of the cosine function in the point <em class="math">x0 = 0</em>. As with sampled data, the spacing values between the points from which the gradient is estimated can be set via the <var class="var">s</var> or <var class="var">dx</var>, <var class="var">dy</var>, … arguments. By default a spacing of 1 is used. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="finding-elements-and-checking-conditions.html#XREFdiff">diff</a>, <a class="ref" href="#XREFdel2">del2</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-dot">
<span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">dot</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-dot"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-dot-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">dot</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-dot-1"> ¶</a></span>
</dt> <dd>
<p>Compute the dot product of two vectors. </p> <p>If <var class="var">x</var> and <var class="var">y</var> are matrices, calculate the dot products along the first non-singleton dimension. </p> <p>If the optional argument <var class="var">dim</var> is given, calculate the dot products along this dimension. </p> <p>Implementation Note: This is equivalent to <code class="code">sum (conj (<var class="var">X</var>) .* <var class="var">Y</var>, <var class="var">dim</var>)</code>, but avoids forming a temporary array and is faster. When <var class="var">X</var> and <var class="var">Y</var> are column vectors, the result is equivalent to <code class="code"><var class="var">X</var>' * <var class="var">Y</var></code>. Although, <code class="code">dot</code> is defined for integer arrays, the output may differ from the expected result due to the limited range of integer objects. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcross">cross</a>, <a class="ref" href="#XREFdivergence">divergence</a>, <a class="ref" href="functions-of-a-matrix.html#XREFtensorprod">tensorprod</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-cross">
<span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">cross</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-cross"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-cross-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">cross</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-cross-1"> ¶</a></span>
</dt> <dd>
<p>Compute the vector cross product of two 3-dimensional vectors <var class="var">x</var> and <var class="var">y</var>. </p> <p>If <var class="var">x</var> and <var class="var">y</var> are arrays, the cross product is applied along the first dimension with three elements. </p> <p>The optional argument <var class="var">dim</var> forces the cross product to be calculated along the specified dimension. An error will be produced if the specified dimension is not three elements in size. </p> <p>Example Code: </p> <pre class="example" data-language="matlab">cross ([1, 1, 0], [0, 1, 1])
  ⇒
       1  -1   1</pre> <pre class="example" data-language="matlab">cross (magic (3), eye (3), 2)
  ⇒
       0   6  -1
      -7   0   3
       9  -4   0</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFdot">dot</a>, <a class="ref" href="#XREFcurl">curl</a>, <a class="ref" href="#XREFdivergence">divergence</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-divergence">
<span class="category-def">: </span><span><code class="def-type"><var class="var">div</var> =</code> <strong class="def-name">divergence</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">fx</var>, <var class="var">fy</var>, <var class="var">fz</var>)</code><a class="copiable-link" href="#index-divergence"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-divergence-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">div</var> =</code> <strong class="def-name">divergence</strong> <code class="def-code-arguments">(<var class="var">fx</var>, <var class="var">fy</var>, <var class="var">fz</var>)</code><a class="copiable-link" href="#index-divergence-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-divergence-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">div</var> =</code> <strong class="def-name">divergence</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">fx</var>, <var class="var">fy</var>)</code><a class="copiable-link" href="#index-divergence-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-divergence-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">div</var> =</code> <strong class="def-name">divergence</strong> <code class="def-code-arguments">(<var class="var">fx</var>, <var class="var">fy</var>)</code><a class="copiable-link" href="#index-divergence-3"> ¶</a></span>
</dt> <dd>
<p>Calculate divergence of a vector field given by the arrays <var class="var">fx</var>, <var class="var">fy</var>, and <var class="var">fz</var> or <var class="var">fx</var>, <var class="var">fy</var> respectively. </p> <pre class="example" data-language="matlab">d               d               d
div F(x,y,z)  =   -- F(x,y,z)  +  -- F(x,y,z)  +  -- F(x,y,z)
                  dx              dy              dz</pre> <p>The coordinates of the vector field can be given by the arguments <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var> or <var class="var">x</var>, <var class="var">y</var> respectively. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcurl">curl</a>, <a class="ref" href="#XREFgradient">gradient</a>, <a class="ref" href="#XREFdel2">del2</a>, <a class="ref" href="#XREFdot">dot</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-curl">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">cx</var>, <var class="var">cy</var>, <var class="var">cz</var>, <var class="var">v</var>] =</code> <strong class="def-name">curl</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">fx</var>, <var class="var">fy</var>, <var class="var">fz</var>)</code><a class="copiable-link" href="#index-curl"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-curl-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">cz</var>, <var class="var">v</var>] =</code> <strong class="def-name">curl</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">fx</var>, <var class="var">fy</var>)</code><a class="copiable-link" href="#index-curl-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-curl-2">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">curl</strong> <code class="def-code-arguments">(<var class="var">fx</var>, <var class="var">fy</var>, <var class="var">fz</var>)</code><a class="copiable-link" href="#index-curl-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-curl-3">
<span class="category-def">: </span><span><code class="def-type">[…] =</code> <strong class="def-name">curl</strong> <code class="def-code-arguments">(<var class="var">fx</var>, <var class="var">fy</var>)</code><a class="copiable-link" href="#index-curl-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-curl-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">curl</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-curl-4"> ¶</a></span>
</dt> <dd>
<p>Calculate curl of vector field given by the arrays <var class="var">fx</var>, <var class="var">fy</var>, and <var class="var">fz</var> or <var class="var">fx</var>, <var class="var">fy</var> respectively. </p> <pre class="example" data-language="matlab">/ d         d       d         d       d         d     \
curl F(x,y,z)  =  | -- Fz  -  -- Fy,  -- Fx  -  -- Fz,  -- Fy  -  -- Fx |
                  \ dy        dz      dz        dx      dx        dy    /</pre> <p>The coordinates of the vector field can be given by the arguments <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var> or <var class="var">x</var>, <var class="var">y</var> respectively. <var class="var">v</var> calculates the scalar component of the angular velocity vector in direction of the z-axis for two-dimensional input. For three-dimensional input the scalar rotation is calculated at each grid point in direction of the vector field at that point. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFdivergence">divergence</a>, <a class="ref" href="#XREFgradient">gradient</a>, <a class="ref" href="#XREFdel2">del2</a>, <a class="ref" href="#XREFcross">cross</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-del2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">L</var> =</code> <strong class="def-name">del2</strong> <code class="def-code-arguments">(<var class="var">M</var>)</code><a class="copiable-link" href="#index-del2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-del2-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">L</var> =</code> <strong class="def-name">del2</strong> <code class="def-code-arguments">(<var class="var">M</var>, <var class="var">h</var>)</code><a class="copiable-link" href="#index-del2-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-del2-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">L</var> =</code> <strong class="def-name">del2</strong> <code class="def-code-arguments">(<var class="var">M</var>, <var class="var">dx</var>, <var class="var">dy</var>, …)</code><a class="copiable-link" href="#index-del2-2"> ¶</a></span>
</dt> <dd> <p>Calculate the discrete Laplace operator. </p> <p>For a 2-dimensional matrix <var class="var">M</var> this is defined as </p> <pre class="example" data-language="matlab">1    / d^2            d^2         \
L  = --- * | ---  M(x,y) +  ---  M(x,y) |
      4    \ dx^2           dy^2        /</pre> <p>For N-dimensional arrays the sum in parentheses is expanded to include second derivatives over the additional higher dimensions. </p> <p>The spacing between evaluation points may be defined by <var class="var">h</var>, which is a scalar defining the equidistant spacing in all dimensions. Alternatively, the spacing in each dimension may be defined separately by <var class="var">dx</var>, <var class="var">dy</var>, etc. A scalar spacing argument defines equidistant spacing, whereas a vector argument can be used to specify variable spacing. The length of the spacing vectors must match the respective dimension of <var class="var">M</var>. The default spacing value is 1. </p> <p>Dimensions with fewer than 3 data points are skipped. Boundary points are calculated from the linear extrapolation of interior points. </p> <p>Example: Second derivative of 2*x^3 </p> <pre class="example" data-language="matlab">f = @(x) 2*x.^3;
dd = @(x) 12*x;
x = 1:6;
L = 4*del2 (f(x));
assert (L, dd (x));</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgradient">gradient</a>, <a class="ref" href="finding-elements-and-checking-conditions.html#XREFdiff">diff</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-factorial">
<span class="category-def">: </span><span><code class="def-type"><var class="var">f</var> =</code> <strong class="def-name">factorial</strong> <code class="def-code-arguments">(<var class="var">n</var>)</code><a class="copiable-link" href="#index-factorial"> ¶</a></span>
</dt> <dd>
<p>Return the factorial of <var class="var">n</var> where <var class="var">n</var> is a real non-negative integer. </p> <p>If <var class="var">n</var> is a scalar, this is equivalent to <code class="code">prod (1:<var class="var">n</var>)</code>. For vector or matrix arguments, return the factorial of each element in the array. </p> <p>For non-integers see the generalized factorial function <code class="code">gamma</code>. Note that the factorial function grows large quite quickly, and even with double precision values overflow will occur if <var class="var">n</var> &gt; 171. For such cases consider <code class="code">gammaln</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="sums-and-products.html#XREFprod">prod</a>, <a class="ref" href="special-functions.html#XREFgamma">gamma</a>, <a class="ref" href="special-functions.html#XREFgammaln">gammaln</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-factor">
<span class="category-def">: </span><span><code class="def-type"><var class="var">pf</var> =</code> <strong class="def-name">factor</strong> <code class="def-code-arguments">(<var class="var">q</var>)</code><a class="copiable-link" href="#index-factor"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-factor-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">pf</var>, <var class="var">n</var>] =</code> <strong class="def-name">factor</strong> <code class="def-code-arguments">(<var class="var">q</var>)</code><a class="copiable-link" href="#index-factor-1"> ¶</a></span>
</dt> <dd>
<p>Return the prime factorization of <var class="var">q</var>. </p> <p>The prime factorization is defined as <code class="code">prod (<var class="var">pf</var>) == <var class="var">q</var></code> where every element of <var class="var">pf</var> is a prime number. If <code class="code"><var class="var">q</var> == 1</code>, return 1. The output <var class="var">pf</var> is of the same numeric class as the input. </p> <p>With two output arguments, return the unique prime factors <var class="var">pf</var> and their multiplicities. That is, <code class="code">prod (<var class="var">pf</var> .^ <var class="var">n</var>) == <var class="var">q</var></code>. </p> <p>Implementation Note: If the input <var class="var">q</var> is <code class="code">single</code> or <code class="code">double</code>, then it must not exceed the corresponding <code class="code">flintmax</code>. For larger inputs, cast them to <code class="code">uint64</code> if they’re less than 2^64: </p> <pre class="example" data-language="matlab">factor (uint64 (18446744073709011493))
   ⇒     571111    761213  42431951</pre> <p>For even larger inputs, use <code class="code">sym</code> if you have the Symbolic package installed and loaded: </p> <pre class="example" data-language="matlab">factor (sym ('9444733049654361449941'))
   ⇒ (sym)
              1           1
 1099511627689 ⋅8589934669</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgcd">gcd</a>, <a class="ref" href="#XREFlcm">lcm</a>, <a class="ref" href="predicates-for-numeric-objects.html#XREFisprime">isprime</a>, <a class="ref" href="#XREFprimes">primes</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-gcd">
<span class="category-def">: </span><span><code class="def-type"><var class="var">g</var> =</code> <strong class="def-name">gcd</strong> <code class="def-code-arguments">(<var class="var">a1</var>, <var class="var">a2</var>, …)</code><a class="copiable-link" href="#index-gcd"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-gcd-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">g</var>, <var class="var">v1</var>, …] =</code> <strong class="def-name">gcd</strong> <code class="def-code-arguments">(<var class="var">a1</var>, <var class="var">a2</var>, …)</code><a class="copiable-link" href="#index-gcd-1"> ¶</a></span>
</dt> <dd>
<p>Compute the greatest common divisor of <var class="var">a1</var>, <var class="var">a2</var>, …. </p> <p>All arguments must be the same size or scalar. For arrays, the greatest common divisor is calculated for each element individually. All elements must be ordinary or Gaussian (complex) integers. Note that for Gaussian integers, the gcd is only unique up to a phase factor (multiplication by 1, -1, i, or -i), so an arbitrary greatest common divisor among the four possible is returned. </p> <p>Optional return arguments <var class="var">v1</var>, …, contain integer vectors such that, </p> <pre class="example" data-language="matlab">g = v1 .* a1 + v2 .* a2 + ...</pre> <p>Example code: </p> <pre class="example" data-language="matlab">gcd ([15, 9], [20, 18])
   ⇒  5  9</pre> <p>Programming tip: To find the GCD of all the elements of a single array, use <code class="code">num2cell</code> instead of nested calls or a loop: </p> <pre class="example" data-language="matlab">x = [30 42 70 105];    # vector or array of inputs
gcd (num2cell (x) {:})
   ⇒     1</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFlcm">lcm</a>, <a class="ref" href="#XREFfactor">factor</a>, <a class="ref" href="predicates-for-numeric-objects.html#XREFisprime">isprime</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-lcm">
<span class="category-def">: </span><span><code class="def-type"><var class="var">l</var> =</code> <strong class="def-name">lcm</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-lcm"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lcm-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">l</var> =</code> <strong class="def-name">lcm</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, …)</code><a class="copiable-link" href="#index-lcm-1"> ¶</a></span>
</dt> <dd>
<p>Compute the least common multiple of <var class="var">x</var> and <var class="var">y</var>, or of the list of all arguments. </p> <p>All inputs must be of the same size, or scalar. All elements must be real integer or Gaussian (complex) integer. For complex inputs, the result is unique only up to a phase factor (multiplication by +1, +i, -1, or -i), and one of the four is returned arbitrarily. </p> <p>Example code: </p> <pre class="example" data-language="matlab">lcm (5:8, 9:12)
   ⇒  45  30  77  24</pre> <p>Programming tip: To find the LCM of all the elements of a single array, use <code class="code">num2cell</code> instead of nested calls or a loop: </p> <pre class="example" data-language="matlab">x = 1:10;    # vector or array of inputs
lcm (num2cell (x) {:})
   ⇒     2520</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfactor">factor</a>, <a class="ref" href="#XREFgcd">gcd</a>, <a class="ref" href="predicates-for-numeric-objects.html#XREFisprime">isprime</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-rem">
<span class="category-def">: </span><span><code class="def-type"><var class="var">r</var> =</code> <strong class="def-name">rem</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-rem"> ¶</a></span>
</dt> <dd>
<p>Return the remainder of the division <code class="code"><var class="var">x</var> / <var class="var">y</var></code>. </p> <p>The remainder is computed using the expression </p> <pre class="example" data-language="matlab">x - y .* fix (x ./ y)</pre> <p>An error message is printed if the dimensions of the arguments do not agree, or if either argument is complex. </p> <p>Programming Notes: When calculating with floating point numbers (double, single), values within a few eps of an integer will be rounded to that integer before computation for compatibility with <small class="sc">MATLAB</small>. Any floating point integers greater than <code class="code">flintmax</code> (2^53 for double) will not compute correctly. For larger integer values convert the input to <code class="code">uint64</code> before calling this function. </p> <p>By convention, </p> <pre class="example" data-language="matlab">rem (x, 0) = NaN  if x is a floating point variable
rem (x, 0) = 0    if x is an integer variable
rem (x, y)  returns a value with the signbit from x</pre> <p>For the opposite conventions see the <code class="code">mod</code> function. In general, <code class="code">rem</code> is best when computing the remainder after division of two <em class="emph">positive</em> numbers. For negative numbers, or when the values are periodic, <code class="code">mod</code> is a better choice. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmod">mod</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-mod">
<span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mod</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-mod"> ¶</a></span>
</dt> <dd>
<p>Compute the modulo of <var class="var">x</var> and <var class="var">y</var>. </p> <p>Conceptually this is given by </p> <pre class="example" data-language="matlab">x - y .* floor (x ./ y)</pre> <p>and is written such that the correct modulus is returned for integer types. This function handles negative values correctly. That is, <code class="code">mod (-1, 3)</code> is 2, not -1, as <code class="code">rem (-1, 3)</code> returns. </p> <p>An error results if the dimensions of the arguments do not agree, or if either of the arguments is complex. </p> <p>Programming Notes: When calculating with floating point numbers (double, single), values within a few eps of an integer will be rounded to that integer before computation for compatibility with <small class="sc">MATLAB</small>. Any floating point integers greater than <code class="code">flintmax</code> (2^53 for double) will not compute correctly. For larger integer values convert the input to <code class="code">uint64</code> before calling this function. </p> <p>By convention, </p> <pre class="example" data-language="matlab">mod (x, 0) = x
mod (x, y)      returns a value with the signbit from y</pre> <p>For the opposite conventions see the <code class="code">rem</code> function. In general, <code class="code">mod</code> is a better choice than <code class="code">rem</code> when any of the inputs are negative numbers or when the values are periodic. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFrem">rem</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-primes">
<span class="category-def">: </span><span><code class="def-type"><var class="var">p</var> =</code> <strong class="def-name">primes</strong> <code class="def-code-arguments">(<var class="var">n</var>)</code><a class="copiable-link" href="#index-primes"> ¶</a></span>
</dt> <dd>
<p>Return all primes up to <var class="var">n</var>. </p> <p>The output data class (double, single, uint32, etc.) is the same as the input class of <var class="var">n</var>. The algorithm used is the Sieve of Eratosthenes. </p> <p>Note: For a specific number <var class="var">n</var> of primes, call <code class="code">list_primes (<var class="var">n</var>)</code>. Alternatively, call <code class="code">primes (<var class="var">n</var>*log (<var class="var">k</var>*<var class="var">n</var>))(1:<var class="var">n</var>)</code> where <var class="var">k</var> is about 5 or 6. This works because the distance from one prime to the next is proportional to the logarithm of the prime, on average. On integrating, there are about <var class="var">n</var> primes less than <code class="code"><var class="var">n</var> * log (5*<var class="var">n</var>)</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFlist_005fprimes">list_primes</a>, <a class="ref" href="predicates-for-numeric-objects.html#XREFisprime">isprime</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-list_005fprimes">
<span class="category-def">: </span><span><code class="def-type"><var class="var">p</var> =</code> <strong class="def-name">list_primes</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-list_005fprimes"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-list_005fprimes-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">p</var> =</code> <strong class="def-name">list_primes</strong> <code class="def-code-arguments">(<var class="var">n</var>)</code><a class="copiable-link" href="#index-list_005fprimes-1"> ¶</a></span>
</dt> <dd>
<p>List the first <var class="var">n</var> primes. </p> <p>If <var class="var">n</var> is unspecified, the first 25 primes are listed. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFprimes">primes</a>, <a class="ref" href="predicates-for-numeric-objects.html#XREFisprime">isprime</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sign">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">sign</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-sign"> ¶</a></span>
</dt> <dd>
<p>Compute the <em class="dfn">signum</em> function. </p> <p>This is defined as </p> <pre class="example" data-language="matlab">-1, x &lt; 0;
sign (x) =  0, x = 0;
            1, x &gt; 0.</pre> <p>For complex arguments, <code class="code">sign</code> returns <code class="code">x ./ abs (<var class="var">x</var>)</code>. </p> <p>Note that <code class="code">sign (-0.0)</code> is 0. Although IEEE 754 floating point allows zero to be signed, 0.0 and -0.0 compare equal. If you must test whether zero is signed, use the <code class="code">signbit</code> function. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsignbit">signbit</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-signbit">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">signbit</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-signbit"> ¶</a></span>
</dt> <dd>
<p>Return logical true if the value of <var class="var">x</var> has its sign bit set and false otherwise. </p> <p>This behavior is consistent with the other logical functions. See <a class="xref" href="logical-values.html">Logical Values</a>. The behavior differs from the C language function which returns nonzero if the sign bit is set. </p> <p>This is not the same as <code class="code">x &lt; 0.0</code>, because IEEE 754 floating point allows zero to be signed. The comparison <code class="code">-0.0 &lt; 0.0</code> is false, but <code class="code">signbit (-0.0)</code> will return a nonzero value. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsign">sign</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="special-functions.html">Special Functions</a>, Previous: <a href="sums-and-products.html">Sums and Products</a>, Up: <a href="arithmetic.html">Arithmetic</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Utility-Functions.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Utility-Functions.html</a>
  </p>
</div>
