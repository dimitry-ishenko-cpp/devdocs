<div class="section" id="Utility-Functions">   <h1 class="section">17.5 Utility Functions</h1> <dl class="def"> <dt id="index-ceil">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>ceil</strong> <em>(<var>x</var>)</em><a href="#index-ceil" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the smallest integer not less than <var>x</var>. </p> <p>This is equivalent to rounding towards positive infinity. </p> <p>If <var>x</var> is complex, return <code>ceil (real (<var>x</var>)) + ceil (imag (<var>x</var>)) * I</code>. </p> <pre class="example" data-language="matlab">ceil ([-2.7, 2.7])
    ⇒ -2    3</pre> <p><strong>See also:</strong> <a href="#XREFfloor">floor</a>, <a href="#XREFround">round</a>, <a href="#XREFfix">fix</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-fix">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>fix</strong> <em>(<var>x</var>)</em><a href="#index-fix" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Truncate fractional portion of <var>x</var> and return the integer portion. </p> <p>This is equivalent to rounding towards zero. If <var>x</var> is complex, return <code>fix (real (<var>x</var>)) + fix (imag (<var>x</var>)) * I</code>. </p> <pre class="example" data-language="matlab">fix ([-2.7, 2.7])
   ⇒ -2    2</pre> <p><strong>See also:</strong> <a href="#XREFceil">ceil</a>, <a href="#XREFfloor">floor</a>, <a href="#XREFround">round</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-floor">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>floor</strong> <em>(<var>x</var>)</em><a href="#index-floor" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the largest integer not greater than <var>x</var>. </p> <p>This is equivalent to rounding towards negative infinity. If <var>x</var> is complex, return <code>floor (real (<var>x</var>)) + floor (imag (<var>x</var>)) * I</code>. </p> <pre class="example" data-language="matlab">floor ([-2.7, 2.7])
     ⇒ -3    2</pre> <p><strong>See also:</strong> <a href="#XREFceil">ceil</a>, <a href="#XREFround">round</a>, <a href="#XREFfix">fix</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-round">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>round</strong> <em>(<var>x</var>)</em><a href="#index-round" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the integer nearest to <var>x</var>. </p> <p>If <var>x</var> is complex, return <code>round (real (<var>x</var>)) + round (imag (<var>x</var>)) * I</code>. If there are two nearest integers, return the one further away from zero. </p> <pre class="example" data-language="matlab">round ([-2.7, 2.7])
     ⇒ -3    3</pre> <p><strong>See also:</strong> <a href="#XREFceil">ceil</a>, <a href="#XREFfloor">floor</a>, <a href="#XREFfix">fix</a>, <a href="#XREFroundb">roundb</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-roundb">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>roundb</strong> <em>(<var>x</var>)</em><a href="#index-roundb" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the integer nearest to <var>x</var>. If there are two nearest integers, return the even one (banker’s rounding). </p> <p>If <var>x</var> is complex, return <code>roundb (real (<var>x</var>)) + roundb (imag (<var>x</var>)) * I</code>. </p> <p><strong>See also:</strong> <a href="#XREFround">round</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-max">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>max</strong> <em>(<var>x</var>)</em><a href="#index-max" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-max-1">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>max</strong> <em>(<var>x</var>, [], <var>dim</var>)</em><a href="#index-max-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-max-2">
<span class="category">: </span><span><em>[<var>m</var>, <var>im</var>] =</em> <strong>max</strong> <em>(<var>x</var>)</em><a href="#index-max-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-max-3">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>max</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-max-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Find maximum values in the array <var>x</var>. </p> <p>For a vector argument, return the maximum value. For a matrix argument, return a row vector with the maximum value of each column. For a multi-dimensional array, <code>max</code> operates along the first non-singleton dimension. </p> <p>If the optional third argument <var>dim</var> is present then operate along this dimension. In this case the second argument is ignored and should be set to the empty matrix. </p> <p>For two inputs (<var>x</var> and <var>y</var>), return the pairwise maximum according to the rules for <a href="broadcasting.html">Broadcasting</a>. </p> <p>Thus, </p> <pre class="example" data-language="matlab">max (max (x))</pre> <p>returns the largest element of the 2-D matrix <var>x</var>, and </p> <pre class="example" data-language="matlab">max (2:5, pi)
    ⇒  3.1416  3.1416  4.0000  5.0000</pre> <p>compares each element of the range <code>2:5</code> with <code>pi</code>, and returns a row vector of the maximum values. </p> <p>For complex arguments, the magnitude of the elements are used for comparison. If the magnitudes are identical, then the results are ordered by phase angle in the range (-pi, pi]. Hence, </p> <pre class="example" data-language="matlab">max ([-1 i 1 -i])
    ⇒ -1</pre> <p>because all entries have magnitude 1, but -1 has the largest phase angle with value pi. </p> <p>If called with one input and two output arguments, <code>max</code> also returns the first index of the maximum value(s). Thus, </p> <pre class="example" data-language="matlab">[x, ix] = max ([1, 3, 5, 2, 5])
    ⇒  x = 5
        ix = 3</pre> <p><strong>See also:</strong> <a href="#XREFmin">min</a>, <a href="#XREFcummax">cummax</a>, <a href="#XREFcummin">cummin</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-min">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>min</strong> <em>(<var>x</var>)</em><a href="#index-min" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-min-1">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>min</strong> <em>(<var>x</var>, [], <var>dim</var>)</em><a href="#index-min-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-min-2">
<span class="category">: </span><span><em>[<var>m</var>, <var>im</var>] =</em> <strong>min</strong> <em>(<var>x</var>)</em><a href="#index-min-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-min-3">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>min</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-min-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Find minimum values in the array <var>x</var>. </p> <p>For a vector argument, return the minimum value. For a matrix argument, return a row vector with the minimum value of each column. For a multi-dimensional array, <code>min</code> operates along the first non-singleton dimension. </p> <p>If the optional third argument <var>dim</var> is present then operate along this dimension. In this case the second argument is ignored and should be set to the empty matrix. </p> <p>For two inputs (<var>x</var> and <var>y</var>), return the pairwise minimum according to the rules for <a href="broadcasting.html">Broadcasting</a>. </p> <p>Thus, </p> <pre class="example" data-language="matlab">min (min (x))</pre> <p>returns the smallest element of the 2-D matrix <var>x</var>, and </p> <pre class="example" data-language="matlab">min (2:5, pi)
    ⇒  2.0000  3.0000  3.1416  3.1416</pre> <p>compares each element of the range <code>2:5</code> with <code>pi</code>, and returns a row vector of the minimum values. </p> <p>For complex arguments, the magnitude of the elements are used for comparison. If the magnitudes are identical, then the results are ordered by phase angle in the range (-pi, pi]. Hence, </p> <pre class="example" data-language="matlab">min ([-1 i 1 -i])
    ⇒ -i</pre> <p>because all entries have magnitude 1, but -i has the smallest phase angle with value -pi/2. </p> <p>If called with one input and two output arguments, <code>min</code> also returns the first index of the minimum value(s). Thus, </p> <pre class="example" data-language="matlab">[x, ix] = min ([1, 3, 0, 2, 0])
    ⇒  x = 0
        ix = 3</pre> <p><strong>See also:</strong> <a href="#XREFmax">max</a>, <a href="#XREFcummin">cummin</a>, <a href="#XREFcummax">cummax</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-cummax">
<span class="category">: </span><span><em><var>M</var> =</em> <strong>cummax</strong> <em>(<var>x</var>)</em><a href="#index-cummax" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-cummax-1">
<span class="category">: </span><span><em><var>M</var> =</em> <strong>cummax</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-cummax-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-cummax-2">
<span class="category">: </span><span><em>[<var>M</var>, <var>IM</var>] =</em> <strong>cummax</strong> <em>(…)</em><a href="#index-cummax-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the cumulative maximum values along dimension <var>dim</var>. </p> <p>If <var>dim</var> is unspecified it defaults to column-wise operation. For example: </p> <pre class="example" data-language="matlab">cummax ([1 3 2 6 4 5])
   ⇒  1  3  3  6  6  6</pre> <p>If called with two output arguments the index of the maximum value is also returned. </p> <pre class="example" data-language="matlab">[w, iw] = cummax ([1 3 2 6 4 5])
⇒
M =  1  3  3  6  6  6
IM = 1  2  2  4  4  4</pre> <p><strong>See also:</strong> <a href="#XREFcummin">cummin</a>, <a href="#XREFmax">max</a>, <a href="#XREFmin">min</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-cummin">
<span class="category">: </span><span><em><var>M</var> =</em> <strong>cummin</strong> <em>(<var>x</var>)</em><a href="#index-cummin" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-cummin-1">
<span class="category">: </span><span><em><var>M</var> =</em> <strong>cummin</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-cummin-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-cummin-2">
<span class="category">: </span><span><em>[<var>M</var>, <var>IM</var>] =</em> <strong>cummin</strong> <em>(<var>x</var>)</em><a href="#index-cummin-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the cumulative minimum values along dimension <var>dim</var>. </p> <p>If <var>dim</var> is unspecified it defaults to column-wise operation. For example: </p> <pre class="example" data-language="matlab">cummin ([5 4 6 2 3 1])
   ⇒  5  4  4  2  2  1</pre> <p>If called with two output arguments the index of the minimum value is also returned. </p> <pre class="example" data-language="matlab">[M, IM] = cummin ([5 4 6 2 3 1])
⇒
M =  5  4  4  2  2  1
IM = 1  2  2  4  4  6</pre> <p><strong>See also:</strong> <a href="#XREFcummax">cummax</a>, <a href="#XREFmin">min</a>, <a href="#XREFmax">max</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-hypot">
<span class="category">: </span><span><em><var>h</var> =</em> <strong>hypot</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-hypot" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-hypot-1">
<span class="category">: </span><span><em><var>h</var> =</em> <strong>hypot</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, …)</em><a href="#index-hypot-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the element-by-element square root of the sum of the squares of <var>x</var> and <var>y</var>. </p> <p>This is equivalent to <code>sqrt (<var>x</var>.^2 + <var>y</var>.^2)</code>, but is calculated in a manner that avoids overflows for large values of <var>x</var> or <var>y</var>. </p> <p><code>hypot</code> can also be called with more than 2 arguments; in this case, the arguments are accumulated from left to right: </p> <pre class="example" data-language="matlab">hypot (hypot (x, y), z)
hypot (hypot (hypot (x, y), z), w), etc.</pre> </dd>
</dl> <dl class="def"> <dt id="index-gradient">
<span class="category">: </span><span><em><var>dx</var> =</em> <strong>gradient</strong> <em>(<var>m</var>)</em><a href="#index-gradient" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gradient-1">
<span class="category">: </span><span><em>[<var>dx</var>, <var>dy</var>, <var>dz</var>, …] =</em> <strong>gradient</strong> <em>(<var>m</var>)</em><a href="#index-gradient-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gradient-2">
<span class="category">: </span><span><em>[…] =</em> <strong>gradient</strong> <em>(<var>m</var>, <var>s</var>)</em><a href="#index-gradient-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gradient-3">
<span class="category">: </span><span><em>[…] =</em> <strong>gradient</strong> <em>(<var>m</var>, <var>x</var>, <var>y</var>, <var>z</var>, …)</em><a href="#index-gradient-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gradient-4">
<span class="category">: </span><span><em>[…] =</em> <strong>gradient</strong> <em>(<var>f</var>, <var>x0</var>)</em><a href="#index-gradient-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gradient-5">
<span class="category">: </span><span><em>[…] =</em> <strong>gradient</strong> <em>(<var>f</var>, <var>x0</var>, <var>s</var>)</em><a href="#index-gradient-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gradient-6">
<span class="category">: </span><span><em>[…] =</em> <strong>gradient</strong> <em>(<var>f</var>, <var>x0</var>, <var>x</var>, <var>y</var>, …)</em><a href="#index-gradient-6" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Calculate the gradient of sampled data or a function. </p> <p>If <var>m</var> is a vector, calculate the one-dimensional gradient of <var>m</var>. If <var>m</var> is a matrix the gradient is calculated for each dimension. </p> <p><code>[<var>dx</var>, <var>dy</var>] = gradient (<var>m</var>)</code> calculates the one-dimensional gradient for <var>x</var> and <var>y</var> direction if <var>m</var> is a matrix. Additional return arguments can be use for multi-dimensional matrices. </p> <p>A constant spacing between two points can be provided by the <var>s</var> parameter. If <var>s</var> is a scalar, it is assumed to be the spacing for all dimensions. Otherwise, separate values of the spacing can be supplied by the <var>x</var>, … arguments. Scalar values specify an equidistant spacing. Vector values for the <var>x</var>, … arguments specify the coordinate for that dimension. The length must match their respective dimension of <var>m</var>. </p> <p>At boundary points a linear extrapolation is applied. Interior points are calculated with the first approximation of the numerical gradient </p> <pre class="example" data-language="matlab">y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).</pre> <p>If the first argument <var>f</var> is a function handle, the gradient of the function at the points in <var>x0</var> is approximated using central difference. For example, <code>gradient (@cos, 0)</code> approximates the gradient of the cosine function in the point <em class="math">x0 = 0</em>. As with sampled data, the spacing values between the points from which the gradient is estimated can be set via the <var>s</var> or <var>dx</var>, <var>dy</var>, … arguments. By default a spacing of 1 is used. </p> <p><strong>See also:</strong> <a href="finding-elements-and-checking-conditions.html#XREFdiff">diff</a>, <a href="#XREFdel2">del2</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-dot">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>dot</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-dot" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-dot-1">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>dot</strong> <em>(<var>x</var>, <var>y</var>, <var>dim</var>)</em><a href="#index-dot-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the dot product of two vectors. </p> <p>If <var>x</var> and <var>y</var> are matrices, calculate the dot products along the first non-singleton dimension. </p> <p>If the optional argument <var>dim</var> is given, calculate the dot products along this dimension. </p> <p>Implementation Note: This is equivalent to <code>sum (conj (<var>X</var>) .* <var>Y</var>, <var>dim</var>)</code>, but avoids forming a temporary array and is faster. When <var>X</var> and <var>Y</var> are column vectors, the result is equivalent to <code><var>X</var>' * <var>Y</var></code>. Although, <code>dot</code> is defined for integer arrays, the output may differ from the expected result due to the limited range of integer objects. </p> <p><strong>See also:</strong> <a href="#XREFcross">cross</a>, <a href="#XREFdivergence">divergence</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-cross">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>cross</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-cross" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-cross-1">
<span class="category">: </span><span><em><var>z</var> =</em> <strong>cross</strong> <em>(<var>x</var>, <var>y</var>, <var>dim</var>)</em><a href="#index-cross-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the vector cross product of two 3-dimensional vectors <var>x</var> and <var>y</var>. </p> <p>If <var>x</var> and <var>y</var> are matrices, the cross product is applied along the first dimension with three elements. </p> <p>The optional argument <var>dim</var> forces the cross product to be calculated along the specified dimension. </p> <p>Example Code: </p> <pre class="example" data-language="matlab">cross ([1, 1, 0], [0, 1, 1])
  ⇒
       1   -1   1</pre> <p><strong>See also:</strong> <a href="#XREFdot">dot</a>, <a href="#XREFcurl">curl</a>, <a href="#XREFdivergence">divergence</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-divergence">
<span class="category">: </span><span><em><var>div</var> =</em> <strong>divergence</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>fx</var>, <var>fy</var>, <var>fz</var>)</em><a href="#index-divergence" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-divergence-1">
<span class="category">: </span><span><em><var>div</var> =</em> <strong>divergence</strong> <em>(<var>fx</var>, <var>fy</var>, <var>fz</var>)</em><a href="#index-divergence-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-divergence-2">
<span class="category">: </span><span><em><var>div</var> =</em> <strong>divergence</strong> <em>(<var>x</var>, <var>y</var>, <var>fx</var>, <var>fy</var>)</em><a href="#index-divergence-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-divergence-3">
<span class="category">: </span><span><em><var>div</var> =</em> <strong>divergence</strong> <em>(<var>fx</var>, <var>fy</var>)</em><a href="#index-divergence-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Calculate divergence of a vector field given by the arrays <var>fx</var>, <var>fy</var>, and <var>fz</var> or <var>fx</var>, <var>fy</var> respectively. </p> <pre class="example" data-language="matlab">d               d               d
div F(x,y,z)  =   -- F(x,y,z)  +  -- F(x,y,z)  +  -- F(x,y,z)
                  dx              dy              dz</pre> <p>The coordinates of the vector field can be given by the arguments <var>x</var>, <var>y</var>, <var>z</var> or <var>x</var>, <var>y</var> respectively. </p> <p><strong>See also:</strong> <a href="#XREFcurl">curl</a>, <a href="#XREFgradient">gradient</a>, <a href="#XREFdel2">del2</a>, <a href="#XREFdot">dot</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-curl">
<span class="category">: </span><span><em>[<var>cx</var>, <var>cy</var>, <var>cz</var>, <var>v</var>] =</em> <strong>curl</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>fx</var>, <var>fy</var>, <var>fz</var>)</em><a href="#index-curl" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-curl-1">
<span class="category">: </span><span><em>[<var>cz</var>, <var>v</var>] =</em> <strong>curl</strong> <em>(<var>x</var>, <var>y</var>, <var>fx</var>, <var>fy</var>)</em><a href="#index-curl-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-curl-2">
<span class="category">: </span><span><em>[…] =</em> <strong>curl</strong> <em>(<var>fx</var>, <var>fy</var>, <var>fz</var>)</em><a href="#index-curl-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-curl-3">
<span class="category">: </span><span><em>[…] =</em> <strong>curl</strong> <em>(<var>fx</var>, <var>fy</var>)</em><a href="#index-curl-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-curl-4">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>curl</strong> <em>(…)</em><a href="#index-curl-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Calculate curl of vector field given by the arrays <var>fx</var>, <var>fy</var>, and <var>fz</var> or <var>fx</var>, <var>fy</var> respectively. </p> <pre class="example" data-language="matlab">/ d         d       d         d       d         d     \
curl F(x,y,z)  =  | -- Fz  -  -- Fy,  -- Fx  -  -- Fz,  -- Fy  -  -- Fx |
                  \ dy        dz      dz        dx      dx        dy    /</pre> <p>The coordinates of the vector field can be given by the arguments <var>x</var>, <var>y</var>, <var>z</var> or <var>x</var>, <var>y</var> respectively. <var>v</var> calculates the scalar component of the angular velocity vector in direction of the z-axis for two-dimensional input. For three-dimensional input the scalar rotation is calculated at each grid point in direction of the vector field at that point. </p> <p><strong>See also:</strong> <a href="#XREFdivergence">divergence</a>, <a href="#XREFgradient">gradient</a>, <a href="#XREFdel2">del2</a>, <a href="#XREFcross">cross</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-del2">
<span class="category">: </span><span><em><var>L</var> =</em> <strong>del2</strong> <em>(<var>M</var>)</em><a href="#index-del2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-del2-1">
<span class="category">: </span><span><em><var>L</var> =</em> <strong>del2</strong> <em>(<var>M</var>, <var>h</var>)</em><a href="#index-del2-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-del2-2">
<span class="category">: </span><span><em><var>L</var> =</em> <strong>del2</strong> <em>(<var>M</var>, <var>dx</var>, <var>dy</var>, …)</em><a href="#index-del2-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Calculate the discrete Laplace operator. </p> <p>For a 2-dimensional matrix <var>M</var> this is defined as </p> <pre class="example" data-language="matlab">1    / d^2            d^2         \
L  = --- * | ---  M(x,y) +  ---  M(x,y) |
      4    \ dx^2           dy^2        /</pre> <p>For N-dimensional arrays the sum in parentheses is expanded to include second derivatives over the additional higher dimensions. </p> <p>The spacing between evaluation points may be defined by <var>h</var>, which is a scalar defining the equidistant spacing in all dimensions. Alternatively, the spacing in each dimension may be defined separately by <var>dx</var>, <var>dy</var>, etc. A scalar spacing argument defines equidistant spacing, whereas a vector argument can be used to specify variable spacing. The length of the spacing vectors must match the respective dimension of <var>M</var>. The default spacing value is 1. </p> <p>Dimensions with fewer than 3 data points are skipped. Boundary points are calculated from the linear extrapolation of interior points. </p> <p>Example: Second derivative of 2*x^3 </p> <pre class="example" data-language="matlab">f = @(x) 2*x.^3;
dd = @(x) 12*x;
x = 1:6;
L = 4*del2 (f(x));
assert (L, dd (x));</pre> <p><strong>See also:</strong> <a href="#XREFgradient">gradient</a>, <a href="finding-elements-and-checking-conditions.html#XREFdiff">diff</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-factorial">
<span class="category">: </span><span><em><var>f</var> =</em> <strong>factorial</strong> <em>(<var>n</var>)</em><a href="#index-factorial" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the factorial of <var>n</var> where <var>n</var> is a real non-negative integer. </p> <p>If <var>n</var> is a scalar, this is equivalent to <code>prod (1:<var>n</var>)</code>. For vector or matrix arguments, return the factorial of each element in the array. </p> <p>For non-integers see the generalized factorial function <code>gamma</code>. Note that the factorial function grows large quite quickly, and even with double precision values overflow will occur if <var>n</var> &gt; 171. For such cases consider <code>gammaln</code>. </p> <p><strong>See also:</strong> <a href="sums-and-products.html#XREFprod">prod</a>, <a href="special-functions.html#XREFgamma">gamma</a>, <a href="special-functions.html#XREFgammaln">gammaln</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-factor">
<span class="category">: </span><span><em><var>pf</var> =</em> <strong>factor</strong> <em>(<var>q</var>)</em><a href="#index-factor" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-factor-1">
<span class="category">: </span><span><em>[<var>pf</var>, <var>n</var>] =</em> <strong>factor</strong> <em>(<var>q</var>)</em><a href="#index-factor-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the prime factorization of <var>q</var>. </p> <p>The prime factorization is defined as <code>prod (<var>pf</var>) == <var>q</var></code> where every element of <var>pf</var> is a prime number. If <code><var>q</var> == 1</code>, return 1. The output <var>pf</var> is of the same numeric class as the input. </p> <p>With two output arguments, return the unique prime factors <var>pf</var> and their multiplicities. That is, <code>prod (<var>pf</var> .^ <var>n</var>) == <var>q</var></code>. </p> <p>Implementation Note: If the input <var>q</var> is <code>single</code> or <code>double</code>, then it must not exceed the corresponding <code>flintmax</code>. For larger inputs, cast them to <code>uint64</code> if they’re less than 2^64: </p> <pre class="example" data-language="matlab">factor (uint64 (18446744073709011493))
   ⇒     571111    761213  42431951</pre> <p>For even larger inputs, use <code>sym</code> if you have the Symbolic package installed and loaded: </p> <pre class="example" data-language="matlab">factor (sym ('9444733049654361449941'))
   ⇒ (sym)
              1           1
 1099511627689 ⋅8589934669</pre> <p><strong>See also:</strong> <a href="#XREFgcd">gcd</a>, <a href="#XREFlcm">lcm</a>, <a href="predicates-for-numeric-objects.html#XREFisprime">isprime</a>, <a href="#XREFprimes">primes</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-gcd">
<span class="category">: </span><span><em><var>g</var> =</em> <strong>gcd</strong> <em>(<var>a1</var>, <var>a2</var>, …)</em><a href="#index-gcd" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gcd-1">
<span class="category">: </span><span><em>[<var>g</var>, <var>v1</var>, …] =</em> <strong>gcd</strong> <em>(<var>a1</var>, <var>a2</var>, …)</em><a href="#index-gcd-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the greatest common divisor of <var>a1</var>, <var>a2</var>, …. </p> <p>All arguments must be the same size or scalar. For arrays, the greatest common divisor is calculated for each element individually. All elements must be ordinary or Gaussian (complex) integers. Note that for Gaussian integers, the gcd is only unique up to a phase factor (multiplication by 1, -1, i, or -i), so an arbitrary greatest common divisor among the four possible is returned. </p> <p>Optional return arguments <var>v1</var>, …, contain integer vectors such that, </p> <pre class="example" data-language="matlab">g = v1 .* a1 + v2 .* a2 + …</pre> <p>Example code: </p> <pre class="example" data-language="matlab">gcd ([15, 9], [20, 18])
   ⇒  5  9</pre> <p><strong>See also:</strong> <a href="#XREFlcm">lcm</a>, <a href="#XREFfactor">factor</a>, <a href="predicates-for-numeric-objects.html#XREFisprime">isprime</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-lcm">
<span class="category">: </span><span><em><var>l</var> =</em> <strong>lcm</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-lcm" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-lcm-1">
<span class="category">: </span><span><em><var>l</var> =</em> <strong>lcm</strong> <em>(<var>x</var>, <var>y</var>, …)</em><a href="#index-lcm-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the least common multiple of <var>x</var> and <var>y</var>, or of the list of all arguments. </p> <p>All elements must be numeric and of the same size or scalar. </p> <p><strong>See also:</strong> <a href="#XREFfactor">factor</a>, <a href="#XREFgcd">gcd</a>, <a href="predicates-for-numeric-objects.html#XREFisprime">isprime</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-rem">
<span class="category">: </span><span><em><var>r</var> =</em> <strong>rem</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-rem" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the remainder of the division <code><var>x</var> / <var>y</var></code>. </p> <p>The remainder is computed using the expression </p> <pre class="example" data-language="matlab">x - y .* fix (x ./ y)</pre> <p>An error message is printed if the dimensions of the arguments do not agree, or if either argument is complex. </p> <p>Programming Notes: When calculating with floating point numbers (double, single), values within a few eps of an integer will be rounded to that integer before computation for compatibility with <small>MATLAB</small>. Any floating point integers greater than <code>flintmax</code> (2^53 for double) will not compute correctly. For larger integer values convert the input to <code>uint64</code> before calling this function. </p> <p>By convention, </p> <pre class="example" data-language="matlab">rem (x, 0) = NaN  if x is a floating point variable
rem (x, 0) = 0    if x is an integer variable
rem (x, y)  returns a value with the signbit from x</pre> <p>For the opposite conventions see the <code>mod</code> function. In general, <code>rem</code> is best when computing the remainder after division of two <em>positive</em> numbers. For negative numbers, or when the values are periodic, <code>mod</code> is a better choice. </p> <p><strong>See also:</strong> <a href="#XREFmod">mod</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-mod">
<span class="category">: </span><span><em><var>m</var> =</em> <strong>mod</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-mod" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the modulo of <var>x</var> and <var>y</var>. </p> <p>Conceptually this is given by </p> <pre class="example" data-language="matlab">x - y .* floor (x ./ y)</pre> <p>and is written such that the correct modulus is returned for integer types. This function handles negative values correctly. That is, <code>mod <span class="nolinebreak">(-1,</span> 3)</code> is 2, not -1, as <code>rem <span class="nolinebreak">(-1,</span> 3)</code> returns. </p> <p>An error results if the dimensions of the arguments do not agree, or if either of the arguments is complex. </p> <p>Programming Notes: When calculating with floating point numbers (double, single), values within a few eps of an integer will be rounded to that integer before computation for compatibility with <small>MATLAB</small>. Any floating point integers greater than <code>flintmax</code> (2^53 for double) will not compute correctly. For larger integer values convert the input to <code>uint64</code> before calling this function. </p> <p>By convention, </p> <pre class="example" data-language="matlab">mod (x, 0) = x
mod (x, y)      returns a value with the signbit from y</pre> <p>For the opposite conventions see the <code>rem</code> function. In general, <code>mod</code> is a better choice than <code>rem</code> when any of the inputs are negative numbers or when the values are periodic. </p> <p><strong>See also:</strong> <a href="#XREFrem">rem</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-primes">
<span class="category">: </span><span><em><var>p</var> =</em> <strong>primes</strong> <em>(<var>n</var>)</em><a href="#index-primes" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return all primes up to <var>n</var>. </p> <p>The output data class (double, single, uint32, etc.) is the same as the input class of <var>n</var>. The algorithm used is the Sieve of Eratosthenes. </p> <p>Note: For a specific number <var>n</var> of primes, call <code>list_primes (<var>n</var>)</code>. Alternatively, call <code>primes (<var>n</var>*log (<var>k</var>*<var>n</var>))(1:<var>n</var>)</code> where <var>k</var> is about 5 or 6. This works because the distance from one prime to the next is proportional to the logarithm of the prime, on average. On integrating, there are about <var>n</var> primes less than <code><var>n</var> * log (5*<var>n</var>)</code>. </p> <p><strong>See also:</strong> <a href="#XREFlist_005fprimes">list_primes</a>, <a href="predicates-for-numeric-objects.html#XREFisprime">isprime</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-list_005fprimes">
<span class="category">: </span><span><em><var>p</var> =</em> <strong>list_primes</strong> <em>()</em><a href="#index-list_005fprimes" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-list_005fprimes-1">
<span class="category">: </span><span><em><var>p</var> =</em> <strong>list_primes</strong> <em>(<var>n</var>)</em><a href="#index-list_005fprimes-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>List the first <var>n</var> primes. </p> <p>If <var>n</var> is unspecified, the first 25 primes are listed. </p> <p><strong>See also:</strong> <a href="#XREFprimes">primes</a>, <a href="predicates-for-numeric-objects.html#XREFisprime">isprime</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sign">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>sign</strong> <em>(<var>x</var>)</em><a href="#index-sign" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the <em>signum</em> function. </p> <p>This is defined as </p> <pre class="example" data-language="matlab">-1, x &lt; 0;
sign (x) =  0, x = 0;
            1, x &gt; 0.</pre> <p>For complex arguments, <code>sign</code> returns <code>x ./ abs (<var>x</var>)</code>. </p> <p>Note that <code>sign (-0.0)</code> is 0. Although IEEE 754 floating point allows zero to be signed, 0.0 and -0.0 compare equal. If you must test whether zero is signed, use the <code>signbit</code> function. </p> <p><strong>See also:</strong> <a href="#XREFsignbit">signbit</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-signbit">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>signbit</strong> <em>(<var>x</var>)</em><a href="#index-signbit" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return logical true if the value of <var>x</var> has its sign bit set and false otherwise. </p> <p>This behavior is consistent with the other logical functions. See <a href="logical-values.html">Logical Values</a>. The behavior differs from the C language function which returns nonzero if the sign bit is set. </p> <p>This is not the same as <code>x &lt; 0.0</code>, because IEEE 754 floating point allows zero to be signed. The comparison <code>-0.0 &lt; 0.0</code> is false, but <code>signbit (-0.0)</code> will return a nonzero value. </p> <p><strong>See also:</strong> <a href="#XREFsign">sign</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Utility-Functions.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Utility-Functions.html</a>
  </p>
</div>
