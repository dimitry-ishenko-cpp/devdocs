<div class="subsection" id="Searching-and-Replacing-in-Strings">   <h1 class="subsection">5.3.5 Searching and Replacing in Strings</h1> <dl class="def"> <dt id="index-strrep">
<span class="category">: </span><span><em><var>newstr</var> =</em> <strong>strrep</strong> <em>(<var>str</var>, <var>ptn</var>, <var>rep</var>)</em><a href="#index-strrep" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strrep-1">
<span class="category">: </span><span><em><var>newstr</var> =</em> <strong>strrep</strong> <em>(<var>cellstr</var>, <var>ptn</var>, <var>rep</var>)</em><a href="#index-strrep-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strrep-2">
<span class="category">: </span><span><em><var>newstr</var> =</em> <strong>strrep</strong> <em>(…, "overlaps", <var>val</var>)</em><a href="#index-strrep-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Replace all occurrences of the pattern <var>ptn</var> in the string <var>str</var> with the string <var>rep</var> and return the result. </p> <p>The optional argument <code>"overlaps"</code> determines whether the pattern can match at every position in <var>str</var> (true), or only for unique occurrences of the complete pattern (false). The default is true. </p> <p><var>s</var> may also be a cell array of strings, in which case the replacement is done for each element and a cell array is returned. </p> <p>Example: </p> <pre class="example" data-language="matlab">strrep ("This is a test string", "is", "&amp;%$")
    ⇒  "Th&amp;%$ &amp;%$ a test string"</pre> <p><strong>See also:</strong> <a href="#XREFregexprep">regexprep</a>, <a href="searching-in-strings.html#XREFstrfind">strfind</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-erase">
<span class="category">: </span><span><em><var>newstr</var> =</em> <strong>erase</strong> <em>(<var>str</var>, <var>ptn</var>)</em><a href="#index-erase" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Delete all occurrences of <var>ptn</var> within <var>str</var>. </p> <p><var>str</var> and <var>ptn</var> can be ordinary strings, cell array of strings, or character arrays. </p> <p>Examples </p> <pre class="example" data-language="matlab">## string, single pattern
erase ("Hello World!", " World")
    ⇒ "Hello!"

## cellstr, single pattern
erase ({"Hello", "World!"}, "World")
    ⇒ {"Hello", "!"}

## string, multiple patterns
erase ("The Octave interpreter is fabulous", ...
       {"interpreter ", "The "})
    ⇒ "Octave is fabulous"

## cellstr, multiple patterns
erase ({"The ", "Octave interpreter ", "is fabulous"}, ...
       {"interpreter ", "The "})
    ⇒ {"", "Octave ", "is fabulous"}</pre> <p>Programming Note: <code>erase</code> deletes the first instance of a pattern in a string when there are overlapping occurrences. For example: </p> <pre class="example" data-language="matlab">erase ("abababa", "aba")
    ⇒ "b"</pre> <p>For processing overlaps, see <a href="#XREFstrrep"><code>strrep</code></a>. </p> <p><strong>See also:</strong> <a href="#XREFstrrep">strrep</a>, <a href="#XREFregexprep">regexprep</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-regexp">
<span class="category">: </span><span><em>[<var>s</var>, <var>e</var>, <var>te</var>, <var>m</var>, <var>t</var>, <var>nm</var>, <var>sp</var>] =</em> <strong>regexp</strong> <em>(<var>str</var>, <var>pat</var>)</em><a href="#index-regexp" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-regexp-1">
<span class="category">: </span><span><em>[…] =</em> <strong>regexp</strong> <em>(<var>str</var>, <var>pat</var>, "<var>opt1</var>", …)</em><a href="#index-regexp-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Regular expression string matching. </p> <p>Search for <var>pat</var> in UTF-8 encoded <var>str</var> and return the positions and substrings of any matches, or empty values if there are none. </p> <p>The matched pattern <var>pat</var> can include any of the standard regex operators, including: </p> <dl compact> <dt><span><code>.</code></span></dt> <dd>
<p>Match any character </p> </dd> <dt><span><code>* + ? {}</code></span></dt> <dd>
<p>Repetition operators, representing </p> <dl compact> <dt><span><code>*</code></span></dt> <dd>
<p>Match zero or more times </p> </dd> <dt><span><code>+</code></span></dt> <dd>
<p>Match one or more times </p> </dd> <dt><span><code>?</code></span></dt> <dd>
<p>Match zero or one times </p> </dd> <dt><span><code>{<var>n</var>}</code></span></dt> <dd>
<p>Match exactly <var>n</var> times </p> </dd> <dt><span><code>{<var>n</var>,}</code></span></dt> <dd>
<p>Match <var>n</var> or more times </p> </dd> <dt><span><code>{<var>m</var>,<var>n</var>}</code></span></dt> <dd><p>Match between <var>m</var> and <var>n</var> times </p></dd> </dl> </dd> <dt><span><code>[…] [^…]</code></span></dt> <dd> <p>List operators. The pattern will match any character listed between <code>"["</code> and <code>"]"</code>. If the first character is <code>"^"</code> then the pattern is inverted and any character except those listed between brackets will match. </p> <p>Escape sequences defined below can also be used inside list operators. For example, a template for a floating point number might be <code>[-+.\d]+</code>. </p> </dd> <dt><span><code>() (?:)</code></span></dt> <dd>
<p>Grouping operator. The first form, parentheses only, also creates a token. </p> </dd> <dt><span><code>|</code></span></dt> <dd>
<p>Alternation operator. Match one of a choice of regular expressions. The alternatives must be delimited by the grouping operator <code>()</code> above. </p> </dd> <dt><span><code>^ $</code></span></dt> <dd><p>Anchoring operators. Requires pattern to occur at the start (<code>^</code>) or end (<code>$</code>) of the string. </p></dd> </dl> <p>In addition, the following escaped characters have special meaning. </p> <dl compact> <dt><span><code>\d</code></span></dt> <dd>
<p>Match any digit </p> </dd> <dt><span><code>\D</code></span></dt> <dd>
<p>Match any non-digit </p> </dd> <dt><span><code>\s</code></span></dt> <dd>
<p>Match any whitespace character </p> </dd> <dt><span><code>\S</code></span></dt> <dd>
<p>Match any non-whitespace character </p> </dd> <dt><span><code>\w</code></span></dt> <dd>
<p>Match any word character </p> </dd> <dt><span><code>\W</code></span></dt> <dd>
<p>Match any non-word character </p> </dd> <dt><span><code>\&lt;</code></span></dt> <dd>
<p>Match the beginning of a word </p> </dd> <dt><span><code>\&gt;</code></span></dt> <dd>
<p>Match the end of a word </p> </dd> <dt><span><code>\B</code></span></dt> <dd><p>Match within a word </p></dd> </dl> <p>Implementation Note: For compatibility with <small>MATLAB</small>, escape sequences in <var>pat</var> (e.g., <code>"\n"</code> =&gt; newline) are expanded even when <var>pat</var> has been defined with single quotes. To disable expansion use a second backslash before the escape sequence (e.g., "\\n") or use the <code>regexptranslate</code> function. </p> <p>The outputs of <code>regexp</code> default to the order given below </p> <dl compact> <dt><span><var>s</var></span></dt> <dd>
<p>The start indices of each matching substring </p> </dd> <dt><span><var>e</var></span></dt> <dd>
<p>The end indices of each matching substring </p> </dd> <dt><span><var>te</var></span></dt> <dd>
<p>The extents of each matched token surrounded by <code>(…)</code> in <var>pat</var> </p> </dd> <dt><span><var>m</var></span></dt> <dd>
<p>A cell array of the text of each match </p> </dd> <dt><span><var>t</var></span></dt> <dd>
<p>A cell array of the text of each token matched </p> </dd> <dt><span><var>nm</var></span></dt> <dd>
<p>A structure containing the text of each matched named token, with the name being used as the fieldname. A named token is denoted by <code>(?&lt;name&gt;…)</code>. </p> </dd> <dt><span><var>sp</var></span></dt> <dd><p>A cell array of the text not returned by match, i.e., what remains if you split the string based on <var>pat</var>. </p></dd> </dl> <p>Particular output arguments, or the order of the output arguments, can be selected by additional <var>opt</var> arguments. These are strings and the correspondence between the output arguments and the optional argument are </p> <table> <tr>
<td width="20%"></td>
<td width="30%"><code>'start'</code></td>
<td width="30%"><var>s</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'end'</code></td>
<td width="30%"><var>e</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'tokenExtents'</code></td>
<td width="30%"><var>te</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'match'</code></td>
<td width="30%"><var>m</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'tokens'</code></td>
<td width="30%"><var>t</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'names'</code></td>
<td width="30%"><var>nm</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'split'</code></td>
<td width="30%"><var>sp</var></td>
<td width="20%"></td>
</tr> </table> <p>Additional arguments are summarized below. </p> <dl compact> <dt><span>‘<samp>once</samp>’</span></dt> <dd>
<p>Return only the first occurrence of the pattern. </p> </dd> <dt><span>‘<samp>matchcase</samp>’</span></dt> <dd>
<p>Make the matching case sensitive. (default) </p> <p>Alternatively, use (?-i) in the pattern. </p> </dd> <dt><span>‘<samp>ignorecase</samp>’</span></dt> <dd>
<p>Ignore case when matching the pattern to the string. </p> <p>Alternatively, use (?i) in the pattern. </p> </dd> <dt><span>‘<samp>stringanchors</samp>’</span></dt> <dd>
<p>Match the anchor characters at the beginning and end of the string. (default) </p> <p>Alternatively, use (?-m) in the pattern. </p> </dd> <dt><span>‘<samp>lineanchors</samp>’</span></dt> <dd>
<p>Match the anchor characters at the beginning and end of the line. </p> <p>Alternatively, use (?m) in the pattern. </p> </dd> <dt><span>‘<samp>dotall</samp>’</span></dt> <dd>
<p>The pattern <code>.</code> matches all characters including the newline character. (default) </p> <p>Alternatively, use (?s) in the pattern. </p> </dd> <dt><span>‘<samp>dotexceptnewline</samp>’</span></dt> <dd>
<p>The pattern <code>.</code> matches all characters except the newline character. </p> <p>Alternatively, use (?-s) in the pattern. </p> </dd> <dt><span>‘<samp>literalspacing</samp>’</span></dt> <dd>
<p>All characters in the pattern, including whitespace, are significant and are used in pattern matching. (default) </p> <p>Alternatively, use (?-x) in the pattern. </p> </dd> <dt><span>‘<samp>freespacing</samp>’</span></dt> <dd>
<p>The pattern may include arbitrary whitespace and also comments beginning with the character ‘<samp>#</samp>’. </p> <p>Alternatively, use (?x) in the pattern. </p> </dd> <dt><span>‘<samp>noemptymatch</samp>’</span></dt> <dd>
<p>Zero-length matches are not returned. (default) </p> </dd> <dt><span>‘<samp>emptymatch</samp>’</span></dt> <dd>
<p>Return zero-length matches. </p> <p><code>regexp ('a', 'b*', 'emptymatch')</code> returns <code>[1 2]</code> because there are zero or more <code>'b'</code> characters at positions 1 and end-of-string. </p> </dd> </dl> <p>Stack Limitation Note: Pattern searches are done with a recursive function which can overflow the program stack when there are a high number of matches. For example, </p> <pre class="example" data-language="matlab">regexp (repmat ('a', 1, 1e5), '(a)+')</pre> <p>may lead to a segfault. As an alternative, consider constructing pattern searches that reduce the number of matches (e.g., by creatively using set complement), and then further processing the return variables (now reduced in size) with successive <code>regexp</code> searches. </p> <p><strong>See also:</strong> <a href="#XREFregexpi">regexpi</a>, <a href="searching-in-strings.html#XREFstrfind">strfind</a>, <a href="#XREFregexprep">regexprep</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-regexpi">
<span class="category">: </span><span><em>[<var>s</var>, <var>e</var>, <var>te</var>, <var>m</var>, <var>t</var>, <var>nm</var>, <var>sp</var>] =</em> <strong>regexpi</strong> <em>(<var>str</var>, <var>pat</var>)</em><a href="#index-regexpi" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-regexpi-1">
<span class="category">: </span><span><em>[…] =</em> <strong>regexpi</strong> <em>(<var>str</var>, <var>pat</var>, "<var>opt1</var>", …)</em><a href="#index-regexpi-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Case insensitive regular expression string matching. </p> <p>Search for <var>pat</var> in UTF-8 encoded <var>str</var> and return the positions and substrings of any matches, or empty values if there are none. See <a href="#XREFregexp"><code>regexp</code></a>, for details on the syntax of the search pattern. </p> <p><strong>See also:</strong> <a href="#XREFregexp">regexp</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-regexprep">
<span class="category">: </span><span><em><var>outstr</var> =</em> <strong>regexprep</strong> <em>(<var>string</var>, <var>pat</var>, <var>repstr</var>)</em><a href="#index-regexprep" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-regexprep-1">
<span class="category">: </span><span><em><var>outstr</var> =</em> <strong>regexprep</strong> <em>(<var>string</var>, <var>pat</var>, <var>repstr</var>, "<var>opt1</var>", …)</em><a href="#index-regexprep-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Replace occurrences of pattern <var>pat</var> in <var>string</var> with <var>repstr</var>. </p> <p>The pattern is a regular expression as documented for <code>regexp</code>. See <a href="#XREFregexp"><code>regexp</code></a>. </p> <p>All strings must be UTF-8 encoded. </p> <p>The replacement string may contain <code>$i</code>, which substitutes for the ith set of parentheses in the match string. For example, </p> <pre class="example" data-language="matlab">regexprep ("Bill Dunn", '(\w+) (\w+)', '$2, $1')</pre> <p>returns <code>"Dunn, Bill"</code> </p> <p>Options in addition to those of <code>regexp</code> are </p> <dl compact> <dt><span>‘<samp>once</samp>’</span></dt> <dd>
<p>Replace only the first occurrence of <var>pat</var> in the result. </p> </dd> <dt><span>‘<samp>warnings</samp>’</span></dt> <dd>
<p>This option is present for compatibility but is ignored. </p> </dd> </dl> <p>Implementation Note: For compatibility with <small>MATLAB</small>, escape sequences in <var>pat</var> (e.g., <code>"\n"</code> =&gt; newline) are expanded even when <var>pat</var> has been defined with single quotes. To disable expansion use a second backslash before the escape sequence (e.g., "\\n") or use the <code>regexptranslate</code> function. </p> <p><strong>See also:</strong> <a href="#XREFregexp">regexp</a>, <a href="#XREFregexpi">regexpi</a>, <a href="#XREFstrrep">strrep</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-regexptranslate">
<span class="category">: </span><span><em><var>str</var> =</em> <strong>regexptranslate</strong> <em>(<var>op</var>, <var>s</var>)</em><a href="#index-regexptranslate" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Translate a string for use in a regular expression. </p> <p>This may include either wildcard replacement or special character escaping. </p> <p>The behavior is controlled by <var>op</var> which can take the following values </p> <dl compact> <dt><span><code>"wildcard"</code></span></dt> <dd>
<p>The wildcard characters <code>.</code>, <code>*</code>, and <code>?</code> are replaced with wildcards that are appropriate for a regular expression. For example: </p> <pre class="example" data-language="matlab">regexptranslate ("wildcard", "*.m")
     ⇒ '.*\.m'</pre> </dd> <dt><span><code>"escape"</code></span></dt> <dd>
<p>The characters <code>$.?[]</code>, that have special meaning for regular expressions are escaped so that they are treated literally. For example: </p> <pre class="example" data-language="matlab">regexptranslate ("escape", "12.5")
     ⇒ '12\.5'</pre> </dd> </dl> <p><strong>See also:</strong> <a href="#XREFregexp">regexp</a>, <a href="#XREFregexpi">regexpi</a>, <a href="#XREFregexprep">regexprep</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Searching-and-Replacing-in-Strings.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Searching-and-Replacing-in-Strings.html</a>
  </p>
</div>
