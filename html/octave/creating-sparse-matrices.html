<div class="subsection" id="Creating-Sparse-Matrices">   <h1 class="subsection">22.1.2 Creating Sparse Matrices</h1> <p>There are several means to create sparse matrix. </p> <dl compact> <dt><span>Returned from a function</span></dt> <dd>
<p>There are many functions that directly return sparse matrices. These include <em>speye</em>, <em>sprand</em>, <em>diag</em>, etc. </p> </dd> <dt><span>Constructed from matrices or vectors</span></dt> <dd>
<p>The function <em>sparse</em> allows a sparse matrix to be constructed from three vectors representing the row, column and data. Alternatively, the function <em>spconvert</em> uses a three column matrix format to allow easy importation of data from elsewhere. </p> </dd> <dt><span>Created and then filled</span></dt> <dd>
<p>The function <em>sparse</em> or <em>spalloc</em> can be used to create an empty matrix that is then filled by the user </p> </dd> <dt><span>From a user binary program</span></dt> <dd><p>The user can directly create the sparse matrix within an oct-file. </p></dd> </dl> <p>There are several basic functions to return specific sparse matrices. For example the sparse identity matrix, is a matrix that is often needed. It therefore has its own function to create it as <code>speye (<var>n</var>)</code> or <code>speye (<var>r</var>, <var>c</var>)</code>, which creates an <var>n</var>-by-<var>n</var> or <var>r</var>-by-<var>c</var> sparse identity matrix. </p> <p>Another typical sparse matrix that is often needed is a random distribution of random elements. The functions <em>sprand</em> and <em>sprandn</em> perform this for uniform and normal random distributions of elements. They have exactly the same calling convention, where <code>sprand (<var>r</var>, <var>c</var>,
<var>d</var>)</code>, creates an <var>r</var>-by-<var>c</var> sparse matrix with a density of filled elements of <var>d</var>. </p> <p>Other functions of interest that directly create sparse matrices, are <em>diag</em> or its generalization <em>spdiags</em>, that can take the definition of the diagonals of the matrix and create the sparse matrix that corresponds to this. For example, </p> <pre class="example" data-language="matlab">s = diag (sparse (randn (1,n)), -1);</pre> <p>creates a sparse (<var>n</var>+1)-by-(<var>n</var>+1) sparse matrix with a single diagonal defined. </p> <dl class="def"> <dt id="index-spdiags">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>spdiags</strong> <em>(<var>A</var>)</em><a href="#index-spdiags" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-spdiags-1">
<span class="category">: </span><span><em>[<var>B</var>, <var>d</var>] =</em> <strong>spdiags</strong> <em>(<var>A</var>)</em><a href="#index-spdiags-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-spdiags-2">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>spdiags</strong> <em>(<var>A</var>, <var>d</var>)</em><a href="#index-spdiags-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-spdiags-3">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>spdiags</strong> <em>(<var>v</var>, <var>d</var>, <var>A</var>)</em><a href="#index-spdiags-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-spdiags-4">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>spdiags</strong> <em>(<var>v</var>, <var>d</var>, <var>m</var>, <var>n</var>)</em><a href="#index-spdiags-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>A generalization of the function <code>diag</code>. </p> <p>Called with a single input argument, the nonzero diagonals <var>d</var> of <var>A</var> are extracted. </p> <p>With two arguments the diagonals to extract are given by the vector <var>d</var>. </p> <p>The other two forms of <code>spdiags</code> modify the input matrix by replacing the diagonals. They use the columns of <var>v</var> to replace the diagonals represented by the vector <var>d</var>. If the sparse matrix <var>A</var> is defined then the diagonals of this matrix are replaced. Otherwise a matrix of <var>m</var> by <var>n</var> is created with the diagonals given by the columns of <var>v</var>. </p> <p>Negative values of <var>d</var> represent diagonals below the main diagonal, and positive values of <var>d</var> diagonals above the main diagonal. </p> <p>For example: </p> <pre class="example" data-language="matlab">spdiags (reshape (1:12, 4, 3), [-1 0 1], 5, 4)
   ⇒ 5 10  0  0
      1  6 11  0
      0  2  7 12
      0  0  3  8
      0  0  0  4</pre> <p><strong>See also:</strong> <a href="rearranging-matrices.html#XREFdiag">diag</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-speye">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>speye</strong> <em>(<var>m</var>, <var>n</var>)</em><a href="#index-speye" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-speye-1">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>speye</strong> <em>(<var>m</var>)</em><a href="#index-speye-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-speye-2">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>speye</strong> <em>(<var>sz</var>)</em><a href="#index-speye-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a sparse identity matrix of size <var>m</var>x<var>n</var>. </p> <p>The implementation is significantly more efficient than <code>sparse (eye (<var>m</var>))</code> as the full matrix is not constructed. </p> <p>Called with a single argument a square matrix of size <var>m</var>-by-<var>m</var> is created. If called with a single vector argument <var>sz</var>, this argument is taken to be the size of the matrix to create. </p> <p><strong>See also:</strong> <a href="#XREFsparse">sparse</a>, <a href="#XREFspdiags">spdiags</a>, <a href="special-utility-matrices.html#XREFeye">eye</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-spones">
<span class="category">: </span><span><em><var>r</var> =</em> <strong>spones</strong> <em>(<var>S</var>)</em><a href="#index-spones" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Replace the nonzero entries of <var>S</var> with ones. </p> <p>This creates a sparse matrix with the same structure as <var>S</var>. </p> <p><strong>See also:</strong> <a href="#XREFsparse">sparse</a>, <a href="#XREFsprand">sprand</a>, <a href="#XREFsprandn">sprandn</a>, <a href="#XREFsprandsym">sprandsym</a>, <a href="function-application.html#XREFspfun">spfun</a>, <a href="information.html#XREFspy">spy</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sprand">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sprand</strong> <em>(<var>m</var>, <var>n</var>, <var>d</var>)</em><a href="#index-sprand" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sprand-1">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sprand</strong> <em>(<var>m</var>, <var>n</var>, <var>d</var>, <var>rc</var>)</em><a href="#index-sprand-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sprand-2">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sprand</strong> <em>(<var>s</var>)</em><a href="#index-sprand-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Generate a sparse matrix with uniformly distributed random values. </p> <p>The size of the matrix is <var>m</var>x<var>n</var> with a density of values <var>d</var>. <var>d</var> must be between 0 and 1. Values will be uniformly distributed on the interval (0, 1). </p> <p>If called with a single matrix argument, a sparse matrix is generated with random values wherever the matrix <var>s</var> is nonzero. </p> <p>If called with a scalar fourth argument <var>rc</var>, a random sparse matrix with reciprocal condition number <var>rc</var> is generated. If <var>rc</var> is a vector, then it specifies the first singular values of the generated matrix (<code>length (<var>rc</var>) &lt;= min (<var>m</var>, <var>n</var>)</code>). </p> <p><strong>See also:</strong> <a href="#XREFsprandn">sprandn</a>, <a href="#XREFsprandsym">sprandsym</a>, <a href="special-utility-matrices.html#XREFrand">rand</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sprandn">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sprandn</strong> <em>(<var>m</var>, <var>n</var>, <var>d</var>)</em><a href="#index-sprandn" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sprandn-1">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sprandn</strong> <em>(<var>m</var>, <var>n</var>, <var>d</var>, <var>rc</var>)</em><a href="#index-sprandn-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sprandn-2">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sprandn</strong> <em>(<var>s</var>)</em><a href="#index-sprandn-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Generate a sparse matrix with normally distributed random values. </p> <p>The size of the matrix is <var>m</var>x<var>n</var> with a density of values <var>d</var>. <var>d</var> must be between 0 and 1. Values will be normally distributed with a mean of 0 and a variance of 1. </p> <p>If called with a single matrix argument, a sparse matrix is generated with random values wherever the matrix <var>s</var> is nonzero. </p> <p>If called with a scalar fourth argument <var>rc</var>, a random sparse matrix with reciprocal condition number <var>rc</var> is generated. If <var>rc</var> is a vector, then it specifies the first singular values of the generated matrix (<code>length (<var>rc</var>) &lt;= min (<var>m</var>, <var>n</var>)</code>). </p> <p><strong>See also:</strong> <a href="#XREFsprand">sprand</a>, <a href="#XREFsprandsym">sprandsym</a>, <a href="special-utility-matrices.html#XREFrandn">randn</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sprandsym">
<span class="category">: </span><span><em><var>S</var> =</em> <strong>sprandsym</strong> <em>(<var>n</var>, <var>d</var>)</em><a href="#index-sprandsym" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sprandsym-1">
<span class="category">: </span><span><em><var>S</var> =</em> <strong>sprandsym</strong> <em>(<var>s</var>)</em><a href="#index-sprandsym-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Generate a symmetric random sparse matrix. </p> <p>The size of the matrix will be <var>n</var>x<var>n</var>, with a density of values given by <var>d</var>. <var>d</var> must be between 0 and 1 inclusive. Values will be normally distributed with a mean of zero and a variance of 1. </p> <p>If called with a single matrix argument, a random sparse matrix is generated wherever the matrix <var>s</var> is nonzero in its lower triangular part. </p> <p><strong>See also:</strong> <a href="#XREFsprand">sprand</a>, <a href="#XREFsprandn">sprandn</a>, <a href="#XREFspones">spones</a>, <a href="#XREFsparse">sparse</a>. </p>
</dd>
</dl> <p>The recommended way for the user to create a sparse matrix, is to create two vectors containing the row and column index of the data and a third vector of the same size containing the data to be stored. For example, </p> <pre class="example" data-language="matlab">ri = ci = d = [];
  for j = 1:c
    ri = [ri; randperm(r,n)'];
    ci = [ci; j*ones(n,1)];
    d = [d; rand(n,1)];
  endfor
  s = sparse (ri, ci, d, r, c);</pre> <p>creates an <var>r</var>-by-<var>c</var> sparse matrix with a random distribution of <var>n</var> (&lt;<var>r</var>) elements per column. The elements of the vectors do not need to be sorted in any particular order as Octave will sort them prior to storing the data. However, pre-sorting the data will make the creation of the sparse matrix faster. </p> <p>The function <em>spconvert</em> takes a three or four column real matrix. The first two columns represent the row and column index respectively and the third and four columns, the real and imaginary parts of the sparse matrix. The matrix can contain zero elements and the elements can be sorted in any order. Adding zero elements is a convenient way to define the size of the sparse matrix. For example: </p> <pre class="example" data-language="matlab">s = spconvert ([1 2 3 4; 1 3 4 4; 1 2 3 0]')
⇒ Compressed Column Sparse (rows=4, cols=4, nnz=3)
      (1 , 1) -&gt; 1
      (2 , 3) -&gt; 2
      (3 , 4) -&gt; 3</pre> <p>An example of creating and filling a matrix might be </p> <pre class="example" data-language="matlab">k = 5;
nz = r * k;
s = spalloc (r, c, nz)
for j = 1:c
  idx = randperm (r);
  s (:, j) = [zeros(r - k, 1); ...
        rand(k, 1)] (idx);
endfor</pre> <p>It should be noted, that due to the way that the Octave assignment functions are written that the assignment will reallocate the memory used by the sparse matrix at each iteration of the above loop. Therefore the <em>spalloc</em> function ignores the <var>nz</var> argument and does not pre-assign the memory for the matrix. Therefore, it is vitally important that code using to above structure should be vectorized as much as possible to minimize the number of assignments and reduce the number of memory allocations. </p> <dl class="def"> <dt id="index-full">
<span class="category">: </span><span><em><var>FM</var> =</em> <strong>full</strong> <em>(<var>SM</var>)</em><a href="#index-full" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a full storage matrix from a sparse, diagonal, or permutation matrix, or from a range. </p> <p><strong>See also:</strong> <a href="#XREFsparse">sparse</a>, <a href="information.html#XREFissparse">issparse</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-spalloc">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>spalloc</strong> <em>(<var>m</var>, <var>n</var>, <var>nz</var>)</em><a href="#index-spalloc" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Create an <var>m</var>-by-<var>n</var> sparse matrix with pre-allocated space for at most <var>nz</var> nonzero elements. </p> <p>This is useful for building a matrix incrementally by a sequence of indexed assignments. Subsequent indexed assignments after <code>spalloc</code> will reuse the pre-allocated memory, provided they are of one of the simple forms </p> <ul> <li> <code><var>s</var>(I:J) = <var>x</var></code> </li>
<li> <code><var>s</var>(:,I:J) = <var>x</var></code> </li>
<li> <code><var>s</var>(K:L,I:J) = <var>x</var></code> </li>
</ul> <p><b>and</b> that the following conditions are met: </p> <ul> <li> the assignment does not decrease <code>nnz (<var>S</var>)</code>. </li>
<li> after the assignment, <code>nnz (<var>S</var>)</code> does not exceed <var>nz</var>. </li>
<li> no index is out of bounds. </li>
</ul> <p>Partial movement of data may still occur, but in general the assignment will be more memory and time efficient under these circumstances. In particular, it is possible to efficiently build a pre-allocated sparse matrix from a contiguous block of columns. </p> <p>The amount of pre-allocated memory for a given matrix may be queried using the function <code>nzmax</code>. </p> <p>Programming Note: Octave always reserves memory for at least one value, even if <var>nz</var> is 0. </p> <p><strong>See also:</strong> <a href="information.html#XREFnzmax">nzmax</a>, <a href="#XREFsparse">sparse</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sparse">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sparse</strong> <em>(<var>a</var>)</em><a href="#index-sparse" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sparse-1">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sparse</strong> <em>(<var>i</var>, <var>j</var>, <var>sv</var>, <var>m</var>, <var>n</var>)</em><a href="#index-sparse-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sparse-2">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sparse</strong> <em>(<var>i</var>, <var>j</var>, <var>sv</var>)</em><a href="#index-sparse-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sparse-3">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sparse</strong> <em>(<var>m</var>, <var>n</var>)</em><a href="#index-sparse-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sparse-4">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sparse</strong> <em>(<var>i</var>, <var>j</var>, <var>s</var>, <var>m</var>, <var>n</var>, "unique")</em><a href="#index-sparse-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sparse-5">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sparse</strong> <em>(<var>i</var>, <var>j</var>, <var>sv</var>, <var>m</var>, <var>n</var>, <var>nzmax</var>)</em><a href="#index-sparse-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Create a sparse matrix from a full matrix, or row, column, value triplets. </p> <p>If <var>a</var> is a full matrix, convert it to a sparse matrix representation, removing all zero values in the process. </p> <p>Given the integer index vectors <var>i</var> and <var>j</var>, and a 1-by-<code>nnz</code> vector of real or complex values <var>sv</var>, construct the sparse matrix <code>S(<var>i</var>(<var>k</var>),<var>j</var>(<var>k</var>)) = <var>sv</var>(<var>k</var>)</code> with overall dimensions <var>m</var> and <var>n</var>. If any of <var>sv</var>, <var>i</var> or <var>j</var> are scalars, they are expanded to have a common size. </p> <p>If <var>m</var> or <var>n</var> are not specified their values are derived from the maximum index in the vectors <var>i</var> and <var>j</var> as given by <code><var>m</var> = max (<var>i</var>)</code>, <code><var>n</var> = max (<var>j</var>)</code>. </p> <p><strong>Note</strong>: if multiple values are specified with the same <var>i</var>, <var>j</var> indices, the corresponding value in <var>s</var> will be the sum of the values at the repeated location. See <a href="accumulation.html#XREFaccumarray"><code>accumarray</code></a>, for an example of how to produce different behavior such as taking the minimum instead. </p> <p>If the option <code>"unique"</code> is given, and more than one value is specified at the same <var>i</var>, <var>j</var> indices, then the last specified value will be used. </p> <p><code>sparse (<var>m</var>, <var>n</var>)</code> will create an empty <var>m</var>x<var>n</var> sparse matrix and is equivalent to <code>sparse ([], [], [], <var>m</var>, <var>n</var>)</code> </p> <p>The argument <var>nzmax</var> is ignored but accepted for compatibility with <small>MATLAB</small>. </p> <p>Example 1 (sum at repeated indices): </p> <pre class="example" data-language="matlab">i = [1 1 2]; j = [1 1 2]; sv = [3 4 5];
sparse (i, j, sv, 3, 4)
⇒
   Compressed Column Sparse (rows = 3, cols = 4, nnz = 2 [17%])

     (1, 1) -&gt;  7
     (2, 2) -&gt;  5</pre> <p>Example 2 ("unique" option): </p> <pre class="example" data-language="matlab">i = [1 1 2]; j = [1 1 2]; sv = [3 4 5];
sparse (i, j, sv, 3, 4, "unique")
⇒
   Compressed Column Sparse (rows = 3, cols = 4, nnz = 2 [17%])

     (1, 1) -&gt;  4
     (2, 2) -&gt;  5</pre> <p><strong>See also:</strong> <a href="#XREFfull">full</a>, <a href="accumulation.html#XREFaccumarray">accumarray</a>, <a href="#XREFspalloc">spalloc</a>, <a href="#XREFspdiags">spdiags</a>, <a href="#XREFspeye">speye</a>, <a href="#XREFspones">spones</a>, <a href="#XREFsprand">sprand</a>, <a href="#XREFsprandn">sprandn</a>, <a href="#XREFsprandsym">sprandsym</a>, <a href="#XREFspconvert">spconvert</a>, <a href="function-application.html#XREFspfun">spfun</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-spconvert">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>spconvert</strong> <em>(<var>m</var>)</em><a href="#index-spconvert" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Convert a simple sparse matrix format easily generated by other programs into Octave’s internal sparse format. </p> <p>The input <var>m</var> is either a 3 or 4 column real matrix, containing the row, column, real, and imaginary parts of the elements of the sparse matrix. An element with a zero real and imaginary part can be used to force a particular matrix size. </p> <p><strong>See also:</strong> <a href="#XREFsparse">sparse</a>. </p>
</dd>
</dl> <p>The above problem of memory reallocation can be avoided in oct-files. However, the construction of a sparse matrix from an oct-file is more complex than can be discussed here. See <a href="external-code-interface.html">External Code Interface</a>, for a full description of the techniques involved. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Creating-Sparse-Matrices.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Creating-Sparse-Matrices.html</a>
  </p>
</div>
