<div class="subsection-level-extent" id="Creating-Sparse-Matrices"> <div class="nav-panel"> <p> Next: <a href="information.html" accesskey="n" rel="next">Finding Information about Sparse Matrices</a>, Previous: <a href="storage-of-sparse-matrices.html" accesskey="p" rel="prev">Storage of Sparse Matrices</a>, Up: <a href="basics.html" accesskey="u" rel="up">Creation and Manipulation of Sparse Matrices</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="Creating-Sparse-Matrices-1"><span>22.1.2 Creating Sparse Matrices<a class="copiable-link" href="#Creating-Sparse-Matrices-1"> ¶</a></span></h1> <p>There are several means to create sparse matrix. </p> <dl class="table"> <dt>Returned from a function</dt> <dd>
<p>There are many functions that directly return sparse matrices. These include <em class="dfn">speye</em>, <em class="dfn">sprand</em>, <em class="dfn">diag</em>, etc. </p> </dd> <dt>Constructed from matrices or vectors</dt> <dd>
<p>The function <em class="dfn">sparse</em> allows a sparse matrix to be constructed from three vectors representing the row, column and data. Alternatively, the function <em class="dfn">spconvert</em> uses a three column matrix format to allow easy importation of data from elsewhere. </p> </dd> <dt>Created and then filled</dt> <dd>
<p>The function <em class="dfn">sparse</em> or <em class="dfn">spalloc</em> can be used to create an empty matrix that is then filled by the user </p> </dd> <dt>From a user binary program</dt> <dd><p>The user can directly create the sparse matrix within an oct-file. </p></dd> </dl> <p>There are several basic functions to return specific sparse matrices. For example the sparse identity matrix, is a matrix that is often needed. It therefore has its own function to create it as <code class="code">speye (<var class="var">n</var>)</code> or <code class="code">speye (<var class="var">r</var>, <var class="var">c</var>)</code>, which creates an <var class="var">n</var>-by-<var class="var">n</var> or <var class="var">r</var>-by-<var class="var">c</var> sparse identity matrix. </p> <p>Another typical sparse matrix that is often needed is a random distribution of random elements. The functions <em class="dfn">sprand</em> and <em class="dfn">sprandn</em> perform this for uniform and normal random distributions of elements. They have exactly the same calling convention, where <code class="code">sprand (<var class="var">r</var>, <var class="var">c</var>,
<var class="var">d</var>)</code>, creates an <var class="var">r</var>-by-<var class="var">c</var> sparse matrix with a density of filled elements of <var class="var">d</var>. </p> <p>Other functions of interest that directly create sparse matrices, are <em class="dfn">diag</em> or its generalization <em class="dfn">spdiags</em>, that can take the definition of the diagonals of the matrix and create the sparse matrix that corresponds to this. For example, </p> <pre class="example" data-language="matlab">s = diag (sparse (randn (1,n)), -1);</pre> <p>creates a sparse (<var class="var">n</var>+1)-by-(<var class="var">n</var>+1) sparse matrix with a single diagonal defined. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-spdiags">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">spdiags</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-spdiags"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-spdiags-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">B</var>, <var class="var">d</var>] =</code> <strong class="def-name">spdiags</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-spdiags-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-spdiags-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">spdiags</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">d</var>)</code><a class="copiable-link" href="#index-spdiags-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-spdiags-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">spdiags</strong> <code class="def-code-arguments">(<var class="var">v</var>, <var class="var">d</var>, <var class="var">A</var>)</code><a class="copiable-link" href="#index-spdiags-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-spdiags-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">spdiags</strong> <code class="def-code-arguments">(<var class="var">v</var>, <var class="var">d</var>, <var class="var">m</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-spdiags-4"> ¶</a></span>
</dt> <dd>
<p>A generalization of the function <code class="code">diag</code>. </p> <p>Called with a single input argument, the nonzero diagonals <var class="var">d</var> of <var class="var">A</var> are extracted. </p> <p>With two arguments the diagonals to extract are given by the vector <var class="var">d</var>. </p> <p>The other two forms of <code class="code">spdiags</code> modify the input matrix by replacing the diagonals. They use the columns of <var class="var">v</var> to replace the diagonals represented by the vector <var class="var">d</var>. If the sparse matrix <var class="var">A</var> is defined then the diagonals of this matrix are replaced. Otherwise a matrix of <var class="var">m</var> by <var class="var">n</var> is created with the diagonals given by the columns of <var class="var">v</var>. </p> <p>Negative values of <var class="var">d</var> represent diagonals below the main diagonal, and positive values of <var class="var">d</var> diagonals above the main diagonal. </p> <p>For example: </p> <pre class="example" data-language="matlab">spdiags (reshape (1:12, 4, 3), [-1 0 1], 5, 4)
   ⇒ 5 10  0  0
      1  6 11  0
      0  2  7 12
      0  0  3  8
      0  0  0  4</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="rearranging-matrices.html#XREFdiag">diag</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-speye">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">speye</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-speye"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-speye-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">speye</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-speye-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-speye-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">speye</strong> <code class="def-code-arguments">([<var class="var">m</var>, <var class="var">n</var>])</code><a class="copiable-link" href="#index-speye-2"> ¶</a></span>
</dt> <dd>
<p>Return a sparse identity matrix of size <var class="var">m</var>x<var class="var">n</var>. </p> <p>The implementation is significantly more efficient than <code class="code">sparse (eye (<var class="var">m</var>))</code> as the full matrix is not constructed. </p> <p>When called with a single argument, a square matrix of size <var class="var">m</var>-by-<var class="var">m</var> is created. If called with a single vector argument, this argument is taken to be the size of the matrix to create. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsparse">sparse</a>, <a class="ref" href="#XREFspdiags">spdiags</a>, <a class="ref" href="special-utility-matrices.html#XREFeye">eye</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-spones">
<span class="category-def">: </span><span><code class="def-type"><var class="var">r</var> =</code> <strong class="def-name">spones</strong> <code class="def-code-arguments">(<var class="var">S</var>)</code><a class="copiable-link" href="#index-spones"> ¶</a></span>
</dt> <dd>
<p>Replace the nonzero entries of <var class="var">S</var> with ones. </p> <p>This creates a sparse matrix with the same structure as <var class="var">S</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsparse">sparse</a>, <a class="ref" href="#XREFsprand">sprand</a>, <a class="ref" href="#XREFsprandn">sprandn</a>, <a class="ref" href="#XREFsprandsym">sprandsym</a>, <a class="ref" href="function-application.html#XREFspfun">spfun</a>, <a class="ref" href="information.html#XREFspy">spy</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sprand">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">sprand</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">n</var>, <var class="var">d</var>)</code><a class="copiable-link" href="#index-sprand"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sprand-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">sprand</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">n</var>, <var class="var">d</var>, <var class="var">rc</var>)</code><a class="copiable-link" href="#index-sprand-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sprand-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">sprand</strong> <code class="def-code-arguments">(<var class="var">s</var>)</code><a class="copiable-link" href="#index-sprand-2"> ¶</a></span>
</dt> <dd>
<p>Generate a sparse matrix with uniformly distributed random values. </p> <p>The size of the matrix is <var class="var">m</var>x<var class="var">n</var> with a density of values <var class="var">d</var>. <var class="var">d</var> must be between 0 and 1. Values will be uniformly distributed on the interval (0, 1). </p> <p>If called with a single matrix argument, a sparse matrix is generated with random values wherever the matrix <var class="var">s</var> is nonzero. </p> <p>If called with a scalar fourth argument <var class="var">rc</var>, a random sparse matrix with reciprocal condition number <var class="var">rc</var> is generated. If <var class="var">rc</var> is a vector, then it specifies the first singular values of the generated matrix (<code class="code">length (<var class="var">rc</var>) &lt;= min (<var class="var">m</var>, <var class="var">n</var>)</code>). </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsprandn">sprandn</a>, <a class="ref" href="#XREFsprandsym">sprandsym</a>, <a class="ref" href="special-utility-matrices.html#XREFrand">rand</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sprandn">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">sprandn</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">n</var>, <var class="var">d</var>)</code><a class="copiable-link" href="#index-sprandn"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sprandn-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">sprandn</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">n</var>, <var class="var">d</var>, <var class="var">rc</var>)</code><a class="copiable-link" href="#index-sprandn-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sprandn-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">sprandn</strong> <code class="def-code-arguments">(<var class="var">s</var>)</code><a class="copiable-link" href="#index-sprandn-2"> ¶</a></span>
</dt> <dd>
<p>Generate a sparse matrix with normally distributed random values. </p> <p>The size of the matrix is <var class="var">m</var>x<var class="var">n</var> with a density of values <var class="var">d</var>. <var class="var">d</var> must be between 0 and 1. Values will be normally distributed with a mean of 0 and a variance of 1. </p> <p>If called with a single matrix argument, a sparse matrix is generated with random values wherever the matrix <var class="var">s</var> is nonzero. </p> <p>If called with a scalar fourth argument <var class="var">rc</var>, a random sparse matrix with reciprocal condition number <var class="var">rc</var> is generated. If <var class="var">rc</var> is a vector, then it specifies the first singular values of the generated matrix (<code class="code">length (<var class="var">rc</var>) &lt;= min (<var class="var">m</var>, <var class="var">n</var>)</code>). </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsprand">sprand</a>, <a class="ref" href="#XREFsprandsym">sprandsym</a>, <a class="ref" href="special-utility-matrices.html#XREFrandn">randn</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sprandsym">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">sprandsym</strong> <code class="def-code-arguments">(<var class="var">n</var>, <var class="var">d</var>)</code><a class="copiable-link" href="#index-sprandsym"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sprandsym-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">sprandsym</strong> <code class="def-code-arguments">(<var class="var">s</var>)</code><a class="copiable-link" href="#index-sprandsym-1"> ¶</a></span>
</dt> <dd>
<p>Generate a symmetric random sparse matrix. </p> <p>The size of the matrix will be <var class="var">n</var>x<var class="var">n</var>, with a density of values given by <var class="var">d</var>. <var class="var">d</var> must be between 0 and 1 inclusive. Values will be normally distributed with a mean of zero and a variance of 1. </p> <p>If called with a single matrix argument, a random sparse matrix is generated wherever the matrix <var class="var">s</var> is nonzero in its lower triangular part. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsprand">sprand</a>, <a class="ref" href="#XREFsprandn">sprandn</a>, <a class="ref" href="#XREFspones">spones</a>, <a class="ref" href="#XREFsparse">sparse</a>. </p>
</dd>
</dl> <p>The recommended way for the user to create a sparse matrix, is to create two vectors containing the row and column index of the data and a third vector of the same size containing the data to be stored. For example, </p> <pre class="example" data-language="matlab">ri = ci = d = [];
  for j = 1:c
    ri = [ri; randperm(r,n)'];
    ci = [ci; j*ones(n,1)];
    d = [d; rand(n,1)];
  endfor
  s = sparse (ri, ci, d, r, c);</pre> <p>creates an <var class="var">r</var>-by-<var class="var">c</var> sparse matrix with a random distribution of <var class="var">n</var> (&lt;<var class="var">r</var>) elements per column. The elements of the vectors do not need to be sorted in any particular order as Octave will sort them prior to storing the data. However, pre-sorting the data will make the creation of the sparse matrix faster. </p> <p>The function <em class="dfn">spconvert</em> takes a three or four column real matrix. The first two columns represent the row and column index respectively and the third and four columns, the real and imaginary parts of the sparse matrix. The matrix can contain zero elements and the elements can be sorted in any order. Adding zero elements is a convenient way to define the size of the sparse matrix. For example: </p> <pre class="example" data-language="matlab">s = spconvert ([1 2 3 4; 1 3 4 4; 1 2 3 0]')
⇒ Compressed Column Sparse (rows=4, cols=4, nnz=3)
      (1 , 1) -&gt; 1
      (2 , 3) -&gt; 2
      (3 , 4) -&gt; 3</pre> <p>An example of creating and filling a matrix might be </p> <pre class="example" data-language="matlab">k = 5;
nz = r * k;
s = spalloc (r, c, nz)
for j = 1:c
  idx = randperm (r);
  s (:, j) = [zeros(r - k, 1); ...
        rand(k, 1)] (idx);
endfor</pre> <p>It should be noted, that due to the way that the Octave assignment functions are written that the assignment will reallocate the memory used by the sparse matrix at each iteration of the above loop. Therefore the <em class="dfn">spalloc</em> function ignores the <var class="var">nz</var> argument and does not pre-assign the memory for the matrix. Therefore, it is vitally important that code using to above structure should be vectorized as much as possible to minimize the number of assignments and reduce the number of memory allocations. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-full">
<span class="category-def">: </span><span><code class="def-type"><var class="var">FM</var> =</code> <strong class="def-name">full</strong> <code class="def-code-arguments">(<var class="var">SM</var>)</code><a class="copiable-link" href="#index-full"> ¶</a></span>
</dt> <dd>
<p>Return a full storage matrix from a sparse, diagonal, or permutation matrix, or from a range. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsparse">sparse</a>, <a class="ref" href="information.html#XREFissparse">issparse</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-spalloc">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">spalloc</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">n</var>, <var class="var">nz</var>)</code><a class="copiable-link" href="#index-spalloc"> ¶</a></span>
</dt> <dd>
<p>Create an <var class="var">m</var>-by-<var class="var">n</var> sparse matrix with pre-allocated space for at most <var class="var">nz</var> nonzero elements. </p> <p>This is useful for building a matrix incrementally by a sequence of indexed assignments. Subsequent indexed assignments after <code class="code">spalloc</code> will reuse the pre-allocated memory, provided they are of one of the simple forms </p> <ul class="itemize mark-bullet"> <li>
<code class="code"><var class="var">s</var>(I:J) = <var class="var">x</var></code> </li>
<li>
<code class="code"><var class="var">s</var>(:,I:J) = <var class="var">x</var></code> </li>
<li>
<code class="code"><var class="var">s</var>(K:L,I:J) = <var class="var">x</var></code> </li>
</ul> <p><b class="b">and</b> that the following conditions are met: </p> <ul class="itemize mark-bullet"> <li>the assignment does not decrease <code class="code">nnz (<var class="var">S</var>)</code>. </li>
<li>after the assignment, <code class="code">nnz (<var class="var">S</var>)</code> does not exceed <var class="var">nz</var>. </li>
<li>no index is out of bounds. </li>
</ul> <p>Partial movement of data may still occur, but in general the assignment will be more memory and time efficient under these circumstances. In particular, it is possible to efficiently build a pre-allocated sparse matrix from a contiguous block of columns. </p> <p>The amount of pre-allocated memory for a given matrix may be queried using the function <code class="code">nzmax</code>. </p> <p>Programming Note: Octave always reserves memory for at least one value, even if <var class="var">nz</var> is 0. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="information.html#XREFnzmax">nzmax</a>, <a class="ref" href="#XREFsparse">sparse</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sparse">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">sparse</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-sparse"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sparse-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">sparse</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-sparse-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sparse-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">sparse</strong> <code class="def-code-arguments">(<var class="var">i</var>, <var class="var">j</var>, <var class="var">sv</var>)</code><a class="copiable-link" href="#index-sparse-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sparse-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">sparse</strong> <code class="def-code-arguments">(<var class="var">i</var>, <var class="var">j</var>, <var class="var">sv</var>, <var class="var">m</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-sparse-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sparse-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">sparse</strong> <code class="def-code-arguments">(<var class="var">i</var>, <var class="var">j</var>, <var class="var">sv</var>, <var class="var">m</var>, <var class="var">n</var>, "unique")</code><a class="copiable-link" href="#index-sparse-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sparse-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">sparse</strong> <code class="def-code-arguments">(<var class="var">i</var>, <var class="var">j</var>, <var class="var">sv</var>, <var class="var">m</var>, <var class="var">n</var>, <var class="var">nzmax</var>)</code><a class="copiable-link" href="#index-sparse-5"> ¶</a></span>
</dt> <dd>
<p>Create a sparse matrix from a full matrix <var class="var">A</var> or row, column, value triplets. </p> <p>If <var class="var">A</var> is a full matrix, convert it to a sparse matrix representation, removing all zero values in the process. The matrix <var class="var">A</var> should be of type logical or double. </p> <p>If two inputs <var class="var">m</var> (rows) and <var class="var">n</var> (columns) are specified then create an empty sparse matrix with the specified dimensions. </p> <p>Given the integer index vectors <var class="var">i</var> and <var class="var">j</var>, and a 1-by-<code class="code">nnz</code> vector of real or complex values <var class="var">sv</var>, construct the sparse matrix <code class="code">S(<var class="var">i</var>(<var class="var">k</var>),<var class="var">j</var>(<var class="var">k</var>)) = <var class="var">sv</var>(<var class="var">k</var>)</code> with overall dimensions <var class="var">m</var> and <var class="var">n</var>. If any of <var class="var">i</var>, <var class="var">j</var>, or <var class="var">sv</var> are scalars, they are expanded to have a common size. </p> <p>If <var class="var">m</var> or <var class="var">n</var> are not specified then their values are derived from the maximum index in the vectors <var class="var">i</var> and <var class="var">j</var> as given by <code class="code"><var class="var">m</var> = max (<var class="var">i</var>)</code>, <code class="code"><var class="var">n</var> = max (<var class="var">j</var>)</code>. </p> <p><strong class="strong">Note</strong>: If multiple values are specified with the same <var class="var">i</var>, <var class="var">j</var> indices, the corresponding value in <var class="var">S</var> will be the sum of the values at the repeated location. See <a class="xref" href="accumulation.html#XREFaccumarray"><code class="code">accumarray</code></a>, for an example of how to produce different behavior such as taking the minimum instead. </p> <p>If the option <code class="code">"unique"</code> is given, and more than one value is specified at the same <var class="var">i</var>, <var class="var">j</var> indices, then only the last specified value will be used. For completeness, the option <code class="code">"sum"</code> can be given and will be ignored as the default behavior is to sum values at repeated locations. </p> <p><code class="code">sparse (<var class="var">m</var>, <var class="var">n</var>)</code> will create an empty <var class="var">m</var>x<var class="var">n</var> sparse matrix and is equivalent to <code class="code">sparse ([], [], [], <var class="var">m</var>, <var class="var">n</var>)</code> </p> <p>The optional final argument reserves space for <var class="var">nzmax</var> values in the sparse array and is useful if the eventual number of nonzero values will be greater than the number of values in <var class="var">sv</var> used during the initial construction of the array. See <a class="xref" href="#XREFspalloc"><code class="code">spalloc</code></a>, for more information and usage instructions. </p> <p>Example 1 (convert full matrix to sparse to save memory): </p> <pre class="example" data-language="matlab">x = full (diag (1:1000));
sizeof (x)
⇒  8000000
s = sparse (x);
sizeof (xs)
⇒  24008</pre> <p>Example 2 (sum at repeated indices): </p> <pre class="example" data-language="matlab">i = [1 1 2]; j = [1 1 2]; sv = [3 4 5];
sparse (i, j, sv, 3, 4)
⇒
   Compressed Column Sparse (rows = 3, cols = 4, nnz = 2 [17%])

     (1, 1) -&gt;  7
     (2, 2) -&gt;  5</pre> <p>Example 3 ("unique" option): </p> <pre class="example" data-language="matlab">i = [1 1 2]; j = [1 1 2]; sv = [3 4 5];
sparse (i, j, sv, 3, 4, "unique")
⇒
   Compressed Column Sparse (rows = 3, cols = 4, nnz = 2 [17%])

     (1, 1) -&gt;  4
     (2, 2) -&gt;  5</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfull">full</a>, <a class="ref" href="accumulation.html#XREFaccumarray">accumarray</a>, <a class="ref" href="#XREFspalloc">spalloc</a>, <a class="ref" href="#XREFspdiags">spdiags</a>, <a class="ref" href="#XREFspeye">speye</a>, <a class="ref" href="#XREFspones">spones</a>, <a class="ref" href="#XREFsprand">sprand</a>, <a class="ref" href="#XREFsprandn">sprandn</a>, <a class="ref" href="#XREFsprandsym">sprandsym</a>, <a class="ref" href="#XREFspconvert">spconvert</a>, <a class="ref" href="function-application.html#XREFspfun">spfun</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-spconvert">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">spconvert</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-spconvert"> ¶</a></span>
</dt> <dd>
<p>Convert a simple sparse matrix format easily generated by other programs into Octave’s internal sparse format. </p> <p>The input <var class="var">m</var> is either a 3 or 4 column real matrix, containing the row, column, real, and imaginary parts of the elements of the sparse matrix. An element with a zero real and imaginary part can be used to force a particular matrix size. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsparse">sparse</a>. </p>
</dd>
</dl> <p>The above problem of memory reallocation can be avoided in oct-files. However, the construction of a sparse matrix from an oct-file is more complex than can be discussed here. See <a class="xref" href="external-code-interface.html">External Code Interface</a>, for a full description of the techniques involved. </p> </div>  <div class="nav-panel"> <p> Next: <a href="information.html">Finding Information about Sparse Matrices</a>, Previous: <a href="storage-of-sparse-matrices.html">Storage of Sparse Matrices</a>, Up: <a href="basics.html">Creation and Manipulation of Sparse Matrices</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Creating-Sparse-Matrices.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Creating-Sparse-Matrices.html</a>
  </p>
</div>
