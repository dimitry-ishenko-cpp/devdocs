<div class="section" id="Multi_002ddimensional-Interpolation">   <h1 class="section">29.2 Multi-dimensional Interpolation</h1> <p>There are three multi-dimensional interpolation functions in Octave, with similar capabilities. Methods using Delaunay tessellation are described in <a href="interpolation-on-scattered-data.html">Interpolation on Scattered Data</a>. </p> <dl class="def"> <dt id="index-interp2">
<span class="category">: </span><span><em><var>zi</var> =</em> <strong>interp2</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>xi</var>, <var>yi</var>)</em><a href="#index-interp2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interp2-1">
<span class="category">: </span><span><em><var>zi</var> =</em> <strong>interp2</strong> <em>(<var>z</var>, <var>xi</var>, <var>yi</var>)</em><a href="#index-interp2-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interp2-2">
<span class="category">: </span><span><em><var>zi</var> =</em> <strong>interp2</strong> <em>(<var>z</var>, <var>n</var>)</em><a href="#index-interp2-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interp2-3">
<span class="category">: </span><span><em><var>zi</var> =</em> <strong>interp2</strong> <em>(<var>z</var>)</em><a href="#index-interp2-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interp2-4">
<span class="category">: </span><span><em><var>zi</var> =</em> <strong>interp2</strong> <em>(…, <var>method</var>)</em><a href="#index-interp2-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interp2-5">
<span class="category">: </span><span><em><var>zi</var> =</em> <strong>interp2</strong> <em>(…, <var>method</var>, <var>extrap</var>)</em><a href="#index-interp2-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Two-dimensional interpolation. </p> <p>Interpolate reference data <var>x</var>, <var>y</var>, <var>z</var> to determine <var>zi</var> at the coordinates <var>xi</var>, <var>yi</var>. The reference data <var>x</var>, <var>y</var> can be matrices, as returned by <code>meshgrid</code>, in which case the sizes of <var>x</var>, <var>y</var>, and <var>z</var> must be equal. If <var>x</var>, <var>y</var> are vectors describing a grid then <code>length (<var>x</var>) == columns (<var>z</var>)</code> and <code>length (<var>y</var>) == rows (<var>z</var>)</code>. In either case the input data must be strictly monotonic. </p> <p>If called without <var>x</var>, <var>y</var>, and just a single reference data matrix <var>z</var>, the 2-D region <code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code> is assumed. This saves memory if the grid is regular and the distance between points is not important. </p> <p>If called with a single reference data matrix <var>z</var> and a refinement value <var>n</var>, then perform interpolation over a grid where each original interval has been recursively subdivided <var>n</var> times. This results in <code>2^<var>n</var>-1</code> additional points for every interval in the original grid. If <var>n</var> is omitted a value of 1 is used. As an example, the interval [0,1] with <code><var>n</var>==2</code> results in a refined interval with points at [0, 1/4, 1/2, 3/4, 1]. </p> <p>The interpolation <var>method</var> is one of: </p> <dl compact> <dt><span><code>"nearest"</code></span></dt> <dd>
<p>Return the nearest neighbor. </p> </dd> <dt><span><code>"linear"</code> (default)</span></dt> <dd>
<p>Linear interpolation from nearest neighbors. </p> </dd> <dt><span><code>"pchip"</code></span></dt> <dd>
<p>Piecewise cubic Hermite interpolating polynomial—shape-preserving interpolation with smooth first derivative. </p> </dd> <dt><span><code>"cubic"</code></span></dt> <dd>
<p>Cubic interpolation using a convolution kernel function—third order method with smooth first derivative. </p> </dd> <dt><span><code>"spline"</code></span></dt> <dd><p>Cubic spline interpolation—smooth first and second derivatives throughout the curve. </p></dd> </dl> <p><var>extrap</var> is a scalar number. It replaces values beyond the endpoints with <var>extrap</var>. Note that if <var>extrap</var> is used, <var>method</var> must be specified as well. If <var>extrap</var> is omitted and the <var>method</var> is <code>"spline"</code>, then the extrapolated values of the <code>"spline"</code> are used. Otherwise the default <var>extrap</var> value for any other <var>method</var> is <code>"NA"</code>. </p> <p><strong>See also:</strong> <a href="one_002ddimensional-interpolation.html#XREFinterp1">interp1</a>, <a href="#XREFinterp3">interp3</a>, <a href="#XREFinterpn">interpn</a>, <a href="three_002ddimensional-plots.html#XREFmeshgrid">meshgrid</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-interp3">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interp3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>)</em><a href="#index-interp3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interp3-1">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interp3</strong> <em>(<var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>)</em><a href="#index-interp3-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interp3-2">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interp3</strong> <em>(<var>v</var>, <var>n</var>)</em><a href="#index-interp3-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interp3-3">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interp3</strong> <em>(<var>v</var>)</em><a href="#index-interp3-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interp3-4">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interp3</strong> <em>(…, <var>method</var>)</em><a href="#index-interp3-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interp3-5">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interp3</strong> <em>(…, <var>method</var>, <var>extrapval</var>)</em><a href="#index-interp3-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Three-dimensional interpolation. </p> <p>Interpolate reference data <var>x</var>, <var>y</var>, <var>z</var>, <var>v</var> to determine <var>vi</var> at the coordinates <var>xi</var>, <var>yi</var>, <var>zi</var>. The reference data <var>x</var>, <var>y</var>, <var>z</var> can be matrices, as returned by <code>meshgrid</code>, in which case the sizes of <var>x</var>, <var>y</var>, <var>z</var>, and <var>v</var> must be equal. If <var>x</var>, <var>y</var>, <var>z</var> are vectors describing a cubic grid then <code>length (<var>x</var>) == columns (<var>v</var>)</code>, <code>length (<var>y</var>) == rows (<var>v</var>)</code>, and <code>length (<var>z</var>) == size (<var>v</var>, 3)</code>. In either case the input data must be strictly monotonic. </p> <p>If called without <var>x</var>, <var>y</var>, <var>z</var>, and just a single reference data matrix <var>v</var>, the 3-D region <code><var>x</var> = 1:columns (<var>v</var>), <var>y</var> = 1:rows (<var>v</var>),
<var>z</var> = 1:size (<var>v</var>, 3)</code> is assumed. This saves memory if the grid is regular and the distance between points is not important. </p> <p>If called with a single reference data matrix <var>v</var> and a refinement value <var>n</var>, then perform interpolation over a 3-D grid where each original interval has been recursively subdivided <var>n</var> times. This results in <code>2^<var>n</var>-1</code> additional points for every interval in the original grid. If <var>n</var> is omitted a value of 1 is used. As an example, the interval [0,1] with <code><var>n</var>==2</code> results in a refined interval with points at [0, 1/4, 1/2, 3/4, 1]. </p> <p>The interpolation <var>method</var> is one of: </p> <dl compact> <dt><span><code>"nearest"</code></span></dt> <dd>
<p>Return the nearest neighbor. </p> </dd> <dt><span><code>"linear"</code> (default)</span></dt> <dd>
<p>Linear interpolation from nearest neighbors. </p> </dd> <dt><span><code>"cubic"</code></span></dt> <dd>
<p>Piecewise cubic Hermite interpolating polynomial—shape-preserving interpolation with smooth first derivative (not implemented yet). </p> </dd> <dt><span><code>"spline"</code></span></dt> <dd><p>Cubic spline interpolation—smooth first and second derivatives throughout the curve. </p></dd> </dl> <p><var>extrapval</var> is a scalar number. It replaces values beyond the endpoints with <var>extrapval</var>. Note that if <var>extrapval</var> is used, <var>method</var> must be specified as well. If <var>extrapval</var> is omitted and the <var>method</var> is <code>"spline"</code>, then the extrapolated values of the <code>"spline"</code> are used. Otherwise the default <var>extrapval</var> value for any other <var>method</var> is <code>"NA"</code>. </p> <p><strong>See also:</strong> <a href="one_002ddimensional-interpolation.html#XREFinterp1">interp1</a>, <a href="#XREFinterp2">interp2</a>, <a href="#XREFinterpn">interpn</a>, <a href="three_002ddimensional-plots.html#XREFmeshgrid">meshgrid</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-interpn">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interpn</strong> <em>(<var>x1</var>, <var>x2</var>, …, <var>v</var>, <var>y1</var>, <var>y2</var>, …)</em><a href="#index-interpn" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interpn-1">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interpn</strong> <em>(<var>v</var>, <var>y1</var>, <var>y2</var>, …)</em><a href="#index-interpn-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interpn-2">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interpn</strong> <em>(<var>v</var>, <var>m</var>)</em><a href="#index-interpn-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interpn-3">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interpn</strong> <em>(<var>v</var>)</em><a href="#index-interpn-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interpn-4">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interpn</strong> <em>(…, <var>method</var>)</em><a href="#index-interpn-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-interpn-5">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>interpn</strong> <em>(…, <var>method</var>, <var>extrapval</var>)</em><a href="#index-interpn-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Perform <var>n</var>-dimensional interpolation, where <var>n</var> is at least two. </p> <p>Each element of the <var>n</var>-dimensional array <var>v</var> represents a value at a location given by the parameters <var>x1</var>, <var>x2</var>, …, <var>xn</var>. The parameters <var>x1</var>, <var>x2</var>, …, <var>xn</var> are either <var>n</var>-dimensional arrays of the same size as the array <var>v</var> in the <code>"ndgrid"</code> format or vectors. </p> <p>The parameters <var>y1</var>, <var>y2</var>, …, <var>yn</var> represent the points at which the array <var>vi</var> is interpolated. They can be vectors of the same length and orientation in which case they are interpreted as coordinates of scattered points. If they are vectors of differing orientation or length, they are used to form a grid in <code>"ndgrid"</code> format. They can also be <var>n</var>-dimensional arrays of equal size. </p> <p>If <var>x1</var>, …, <var>xn</var> are omitted, they are assumed to be <code>x1 = 1 : size (<var>v</var>, 1)</code>, etc. If <var>m</var> is specified, then the interpolation adds a point half way between each of the interpolation points. This process is performed <var>m</var> times. If only <var>v</var> is specified, then <var>m</var> is assumed to be <code>1</code>. </p> <p>The interpolation <var>method</var> is one of: </p> <dl compact> <dt><span><code>"nearest"</code></span></dt> <dd>
<p>Return the nearest neighbor. </p> </dd> <dt><span><code>"linear"</code> (default)</span></dt> <dd>
<p>Linear interpolation from nearest neighbors. </p> </dd> <dt><span><code>"pchip"</code></span></dt> <dd>
<p>Piecewise cubic Hermite interpolating polynomial—shape-preserving interpolation with smooth first derivative (not implemented yet). </p> </dd> <dt><span><code>"cubic"</code></span></dt> <dd>
<p>Cubic interpolation (same as <code>"pchip"</code> [not implemented yet]). </p> </dd> <dt><span><code>"spline"</code></span></dt> <dd><p>Cubic spline interpolation—smooth first and second derivatives throughout the curve. </p></dd> </dl> <p>The default method is <code>"linear"</code>. </p> <p><var>extrapval</var> is a scalar number. It replaces values beyond the endpoints with <var>extrapval</var>. Note that if <var>extrapval</var> is used, <var>method</var> must be specified as well. If <var>extrapval</var> is omitted and the <var>method</var> is <code>"spline"</code>, then the extrapolated values of the <code>"spline"</code> are used. Otherwise the default <var>extrapval</var> value for any other <var>method</var> is <code>NA</code>. </p> <p><strong>See also:</strong> <a href="one_002ddimensional-interpolation.html#XREFinterp1">interp1</a>, <a href="#XREFinterp2">interp2</a>, <a href="#XREFinterp3">interp3</a>, <a href="one_002ddimensional-interpolation.html#XREFspline">spline</a>, <a href="three_002ddimensional-plots.html#XREFndgrid">ndgrid</a>. </p>
</dd>
</dl> <p>A significant difference between <code>interpn</code> and the other two multi-dimensional interpolation functions is the fashion in which the dimensions are treated. For <code>interp2</code> and <code>interp3</code>, the y-axis is considered to be the columns of the matrix, whereas the x-axis corresponds to the rows of the array. As Octave indexes arrays in column major order, the first dimension of any array is the columns, and so <code>interpn</code> effectively reverses the ’x’ and ’y’ dimensions. Consider the example, </p> <pre class="example" data-language="matlab">x = y = z = -1:1;
f = @(x,y,z) x.^2 - y - z.^2;
[xx, yy, zz] = meshgrid (x, y, z);
v = f (xx,yy,zz);
xi = yi = zi = -1:0.1:1;
[xxi, yyi, zzi] = meshgrid (xi, yi, zi);
vi = interp3 (x, y, z, v, xxi, yyi, zzi, "spline");
[xxi, yyi, zzi] = ndgrid (xi, yi, zi);
vi2 = interpn (x, y, z, v, xxi, yyi, zzi, "spline");
mesh (zi, yi, squeeze (vi2(1,:,:)));</pre> <p>where <code>vi</code> and <code>vi2</code> are identical. The reversal of the dimensions is treated in the <code>meshgrid</code> and <code>ndgrid</code> functions respectively. The result of this code can be seen in <a href="#fig_003ainterpn">Figure 29.4</a>. </p> <div class="float">
 <div align="center">
<img src="https://docs.octave.org/v8.1.0/interpn.png" alt="interpn"> </div> <div class="float-caption"><p><strong>Figure 29.4: </strong>Demonstration of the use of <code>interpn</code></p></div>
</div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Multi_002ddimensional-Interpolation.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Multi_002ddimensional-Interpolation.html</a>
  </p>
</div>
