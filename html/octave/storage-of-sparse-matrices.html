<div class="subsection-level-extent" id="Storage-of-Sparse-Matrices"> <div class="nav-panel"> <p> Next: <a href="creating-sparse-matrices.html" accesskey="n" rel="next">Creating Sparse Matrices</a>, Up: <a href="basics.html" accesskey="u" rel="up">Creation and Manipulation of Sparse Matrices</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="Storage-of-Sparse-Matrices-1"><span>22.1.1 Storage of Sparse Matrices<a class="copiable-link" href="#Storage-of-Sparse-Matrices-1"> ¶</a></span></h1> <p>It is not strictly speaking necessary for the user to understand how sparse matrices are stored. However, such an understanding will help to get an understanding of the size of sparse matrices. Understanding the storage technique is also necessary for those users wishing to create their own oct-files. </p> <p>There are many different means of storing sparse matrix data. What all of the methods have in common is that they attempt to reduce the complexity and storage given a priori knowledge of the particular class of problems that will be solved. A good summary of the available techniques for storing sparse matrix is given by Saad <a class="footnote" id="DOCF8" href="#FOOT8"><sup>8</sup></a>. With full matrices, knowledge of the point of an element of the matrix within the matrix is implied by its position in the computers memory. However, this is not the case for sparse matrices, and so the positions of the nonzero elements of the matrix must equally be stored. </p> <p>An obvious way to do this is by storing the elements of the matrix as triplets, with two elements being their position in the array (rows and column) and the third being the data itself. This is conceptually easy to grasp, but requires more storage than is strictly needed. </p> <p>The storage technique used within Octave is the compressed column format. It is similar to the Yale format. <a class="footnote" id="DOCF9" href="#FOOT9"><sup>9</sup></a> In this format the position of each element in a row and the data are stored as previously. However, if we assume that all elements in the same column are stored adjacent in the computers memory, then we only need to store information on the number of nonzero elements in each column, rather than their positions. Thus assuming that the matrix has more nonzero elements than there are columns in the matrix, we win in terms of the amount of memory used. </p> <p>In fact, the column index contains one more element than the number of columns, with the first element always being zero. The advantage of this is a simplification in the code, in that there is no special case for the first or last columns. A short example, demonstrating this in C is. </p> <pre class="example" data-language="matlab">for (j = 0; j &lt; nc; j++)
    for (i = cidx(j); i &lt; cidx(j+1); i++)
       printf ("nonzero element (%i,%i) is %d\n",
           ridx(i), j, data(i));</pre> <p>A clear understanding might be had by considering an example of how the above applies to an example matrix. Consider the matrix </p> <pre class="example" data-language="matlab">1   2   0  0
    0   0   0  3
    0   0   0  4</pre> <p>The nonzero elements of this matrix are </p> <pre class="example" data-language="matlab">(1, 1)  ⇒ 1
   (1, 2)  ⇒ 2
   (2, 4)  ⇒ 3
   (3, 4)  ⇒ 4</pre> <p>This will be stored as three vectors <var class="var">cidx</var>, <var class="var">ridx</var> and <var class="var">data</var>, representing the column indexing, row indexing and data respectively. The contents of these three vectors for the above matrix will be </p> <pre class="example" data-language="matlab">cidx = [0, 1, 2, 2, 4]
  ridx = [0, 0, 1, 2]
  data = [1, 2, 3, 4]</pre> <p>Note that this is the representation of these elements with the first row and column assumed to start at zero, while in Octave itself the row and column indexing starts at one. Thus, the number of elements in the <var class="var">i</var>-th column is given by <code class="code"><var class="var">cidx</var> (<var class="var">i</var> + 1) - <var class="var">cidx</var> (<var class="var">i</var>)</code>. </p> <p>Although Octave uses a compressed column format, it should be noted that compressed row formats are equally possible. However, in the context of mixed operations between mixed sparse and dense matrices, it makes sense that the elements of the sparse matrices are in the same order as the dense matrices. Octave stores dense matrices in column major ordering, and so sparse matrices are equally stored in this manner. </p> <p>A further constraint on the sparse matrix storage used by Octave is that all elements in the rows are stored in increasing order of their row index, which makes certain operations faster. However, it imposes the need to sort the elements on the creation of sparse matrices. Having disordered elements is potentially an advantage in that it makes operations such as concatenating two sparse matrices together easier and faster, however it adds complexity and speed problems elsewhere. </p> </div> <div class="footnotes-segment">  <h4 class="footnotes-heading">Footnotes</h4> <h5 class="footnote-body-heading" id="">(8)</h5> <p>Y. Saad "SPARSKIT: A basic toolkit for sparse matrix computation", 1994, <a class="url" href="https://www-users.cs.umn.edu/~saad/software/SPARSKIT/paper.ps">https://www-users.cs.umn.edu/~saad/software/SPARSKIT/paper.ps</a></p> <h5 class="footnote-body-heading" id="">(9)</h5> <p><a class="url" href="https://en.wikipedia.org/wiki/Sparse_matrix#Yale_format">https://en.wikipedia.org/wiki/Sparse_matrix#Yale_format</a></p> </div>  <div class="nav-panel"> <p> Next: <a href="creating-sparse-matrices.html">Creating Sparse Matrices</a>, Up: <a href="basics.html">Creation and Manipulation of Sparse Matrices</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Storage-of-Sparse-Matrices.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Storage-of-Sparse-Matrices.html</a>
  </p>
</div>
