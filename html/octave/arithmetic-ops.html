<div class="section" id="Arithmetic-Ops">   <h1 class="section">8.3 Arithmetic Operators</h1>                <p>The following arithmetic operators are available, and work on scalars and matrices. The element-by-element operators and functions broadcast (see <a href="broadcasting.html">Broadcasting</a>). </p> <dl compact> <dt id="index-_002b"><span><var>x</var> + <var>y</var><a href="#index-_002b" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Addition (always works element by element). If both operands are matrices, the number of rows and columns must both agree, or they must be broadcastable to the same shape. </p> </dd> <dt id="index-_002d"><span><var>x</var> - <var>y</var><a href="#index-_002d" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Subtraction (always works element by element). If both operands are matrices, the number of rows and columns of both must agree, or they must be broadcastable to the same shape. </p> </dd> <dt id="index-_002a"><span><var>x</var> * <var>y</var><a href="#index-_002a" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Matrix multiplication. The number of columns of <var>x</var> must agree with the number of rows of <var>y</var>. </p> </dd> <dt id="index-_002e_002a"><span><var>x</var> .* <var>y</var><a href="#index-_002e_002a" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Element-by-element multiplication. If both operands are matrices, the number of rows and columns must both agree, or they must be broadcastable to the same shape. </p> </dd> <dt id="index-_002f"><span><var>x</var> / <var>y</var><a href="#index-_002f" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Right division. This is conceptually equivalent to the expression </p> <pre class="example" data-language="matlab">(inv (y') * x')'</pre> <p>but it is computed without forming the inverse of <var>y’</var>. </p> <p>If the system is not square, or if the coefficient matrix is singular, a minimum norm solution is computed. </p> </dd> <dt id="index-_002e_002f"><span><var>x</var> ./ <var>y</var><a href="#index-_002e_002f" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Element-by-element right division. </p> </dd> <dt id="index-_005c"><span><var>x</var> \ <var>y</var><a href="#index-_005c" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Left division. This is conceptually equivalent to the expression </p> <pre class="example" data-language="matlab">inv (x) * y</pre> <p>but it is computed without forming the inverse of <var>x</var>. </p> <p>If the system is not square, or if the coefficient matrix is singular, a minimum norm solution is computed. </p> </dd> <dt id="index-_002e_005c"><span><var>x</var> .\ <var>y</var><a href="#index-_002e_005c" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Element-by-element left division. Each element of <var>y</var> is divided by each corresponding element of <var>x</var>. </p> </dd> <dt id="index-_005e"><span><var>x</var> ^ <var>y</var><a href="#index-_005e" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Power operator. If <var>x</var> and <var>y</var> are both scalars, this operator returns <var>x</var> raised to the power <var>y</var>. If <var>x</var> is a scalar and <var>y</var> is a square matrix, the result is computed using an eigenvalue expansion. If <var>x</var> is a square matrix, the result is computed by repeated multiplication if <var>y</var> is an integer, and by an eigenvalue expansion if <var>y</var> is not an integer. An error results if both <var>x</var> and <var>y</var> are matrices. </p> <p>The implementation of this operator needs to be improved. </p> </dd> <dt id="index-_002e_005e"><span><var>x</var> .^ <var>y</var><a href="#index-_002e_005e" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Element-by-element power operator. If both operands are matrices, the number of rows and columns must both agree, or they must be broadcastable to the same shape. If several complex results are possible, the one with smallest non-negative argument (angle) is taken. This rule may return a complex root even when a real root is also possible. Use <code>realpow</code>, <code>realsqrt</code>, <code>cbrt</code>, or <code>nthroot</code> if a real result is preferred. </p> </dd> <dt id="index-_002d-1"><span>-<var>x</var><a href="#index-_002d-1" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Negation. </p> </dd> <dt id="index-_002b-1"><span>+<var>x</var><a href="#index-_002b-1" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Unary plus. This operator has no effect on the operand. </p> </dd> <dt id="index-_0027-2"><span><var>x</var>’<a href="#index-_0027-2" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Complex conjugate transpose. For real arguments, this operator is the same as the transpose operator. For complex arguments, this operator is equivalent to the expression </p> <pre class="example" data-language="matlab">conj (x.')</pre> </dd> <dt id="index-_002e_0027"><span><var>x</var>.’<a href="#index-_002e_0027" class="copiable-anchor"> ¶</a></span></dt> <dd><p>Transpose. </p></dd> </dl> <p>Note that because Octave’s element-by-element operators begin with a ‘<samp>.</samp>’, there is a possible ambiguity for statements like </p> <pre class="example" data-language="matlab">1./m</pre> <p>because the period could be interpreted either as part of the constant or as part of the operator. To resolve this conflict, Octave treats the expression as if you had typed </p> <pre class="example" data-language="matlab">(1) ./ m</pre> <p>and not </p> <pre class="example" data-language="matlab">(1.) / m</pre> <p>Although this is inconsistent with the normal behavior of Octave’s lexer, which usually prefers to break the input into tokens by preferring the longest possible match at any given point, it is more useful in this case. </p> <p>Note also that some combinations of binary operators and whitespace can create apparent ambiguities with the Command Syntax form of calling functions. See <a href="command-syntax-and-function-syntax.html">Command Syntax and Function Syntax</a> for a description of how Octave treats that syntax. </p>  <dl class="def"> <dt id="index-ctranspose">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>ctranspose</strong> <em>(<var>A</var>)</em><a href="#index-ctranspose" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the complex conjugate transpose of <var>A</var>. </p> <p>This function and <code><var>A</var>'</code> are equivalent. </p> <p><strong>See also:</strong> <a href="#XREFtranspose">transpose</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-pagectranspose">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>pagectranspose</strong> <em>(<var>A</var>)</em><a href="#index-pagectranspose" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the page-wise complex conjugate transpose of the N-dimensional array <var>A</var>. </p> <p>This is equivalent to <code><var>A</var>(:,:, <var>k</var>)'</code> for each page <var>k</var>. </p> <p><strong>See also:</strong> <a href="#XREFpagetranspose">pagetranspose</a>, <a href="#XREFctranspose">ctranspose</a>, <a href="rearranging-matrices.html#XREFpermute">permute</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-ldivide">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>ldivide</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-ldivide" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the element-by-element left division of <var>A</var> and <var>B</var>. </p> <p>This function and <code><var>A</var> .\ <var>B</var></code> are equivalent. </p> <p><strong>See also:</strong> <a href="#XREFrdivide">rdivide</a>, <a href="#XREFmldivide">mldivide</a>, <a href="#XREFtimes">times</a>, <a href="#XREFplus">plus</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-minus">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>minus</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-minus" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>This function and <code><var>A</var> <span class="nolinebreak">-</span> <var>B</var></code> are equivalent. </p> <p><strong>See also:</strong> <a href="#XREFplus">plus</a>, <a href="#XREFuminus">uminus</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-mldivide">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>mldivide</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-mldivide" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the matrix left division of <var>A</var> and <var>B</var>. </p> <p>This function and <code><var>A</var> \ <var>B</var></code> are equivalent. </p> <p>If the system is not square, or if the coefficient matrix is singular, a minimum norm solution is computed. </p> <p><strong>See also:</strong> <a href="#XREFmrdivide">mrdivide</a>, <a href="#XREFldivide">ldivide</a>, <a href="#XREFrdivide">rdivide</a>, <a href="basic-matrix-functions.html#XREFlinsolve">linsolve</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-mpower">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>mpower</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-mpower" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the matrix power operation of <var>A</var> raised to the <var>B</var> power. </p> <p>This function and <code><var>A</var> ^ <var>B</var></code> are equivalent. </p> <p><strong>See also:</strong> <a href="#XREFpower">power</a>, <a href="#XREFmtimes">mtimes</a>, <a href="#XREFplus">plus</a>, <a href="#XREFminus">minus</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-mrdivide">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>mrdivide</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-mrdivide" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the matrix right division of <var>A</var> and <var>B</var>. </p> <p>This function and <code><var>A</var> / <var>B</var></code> are equivalent. </p> <p>If the system is not square, or if the coefficient matrix is singular, a minimum norm solution is computed. </p> <p><strong>See also:</strong> <a href="#XREFmldivide">mldivide</a>, <a href="#XREFrdivide">rdivide</a>, <a href="#XREFplus">plus</a>, <a href="#XREFminus">minus</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-mtimes">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>mtimes</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-mtimes" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-mtimes-1">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>mtimes</strong> <em>(<var>A1</var>, <var>A2</var>, …)</em><a href="#index-mtimes-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the matrix multiplication product of inputs. </p> <p>This function and <code><var>A</var> * <var>B</var></code> are equivalent. If more arguments are given, the multiplication is applied cumulatively from left to right: </p> <pre class="example" data-language="matlab">(…((A1 * A2) * A3) * …)</pre> <p><strong>See also:</strong> <a href="#XREFtimes">times</a>, <a href="#XREFplus">plus</a>, <a href="#XREFminus">minus</a>, <a href="#XREFrdivide">rdivide</a>, <a href="#XREFmrdivide">mrdivide</a>, <a href="#XREFmldivide">mldivide</a>, <a href="#XREFmpower">mpower</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-plus">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>plus</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-plus" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-plus-1">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>plus</strong> <em>(<var>A1</var>, <var>A2</var>, …)</em><a href="#index-plus-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>This function and <code><var>A</var> + <var>B</var></code> are equivalent. </p> <p>If more arguments are given, the summation is applied cumulatively from left to right: </p> <pre class="example" data-language="matlab">(…((A1 + A2) + A3) + …)</pre> <p><strong>See also:</strong> <a href="#XREFminus">minus</a>, <a href="#XREFuplus">uplus</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-power">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>power</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-power" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the element-by-element operation of <var>A</var> raised to the <var>B</var> power. </p> <p>This function and <code><var>A</var> .^ <var>B</var></code> are equivalent. </p> <p>If several complex results are possible, returns the one with smallest non-negative argument (angle). Use <code>realpow</code>, <code>realsqrt</code>, <code>cbrt</code>, or <code>nthroot</code> if a real result is preferred. </p> <p><strong>See also:</strong> <a href="#XREFmpower">mpower</a>, <a href="exponents-and-logarithms.html#XREFrealpow">realpow</a>, <a href="exponents-and-logarithms.html#XREFrealsqrt">realsqrt</a>, <a href="exponents-and-logarithms.html#XREFcbrt">cbrt</a>, <a href="exponents-and-logarithms.html#XREFnthroot">nthroot</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-rdivide">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>rdivide</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-rdivide" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the element-by-element right division of <var>A</var> and <var>B</var>. </p> <p>This function and <code><var>A</var> ./ <var>B</var></code> are equivalent. </p> <p><strong>See also:</strong> <a href="#XREFldivide">ldivide</a>, <a href="#XREFmrdivide">mrdivide</a>, <a href="#XREFtimes">times</a>, <a href="#XREFplus">plus</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-times">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>times</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-times" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-times-1">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>times</strong> <em>(<var>A1</var>, <var>A2</var>, …)</em><a href="#index-times-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the element-by-element multiplication product of inputs. </p> <p>This function and <code><var>A</var> .* <var>B</var></code> are equivalent. If more arguments are given, the multiplication is applied cumulatively from left to right: </p> <pre class="example" data-language="matlab">(…((A1 .* A2) .* A3) .* …)</pre> <p><strong>See also:</strong> <a href="#XREFmtimes">mtimes</a>, <a href="#XREFrdivide">rdivide</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-transpose-2">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>transpose</strong> <em>(<var>A</var>)</em><a href="#index-transpose-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the transpose of <var>A</var>. </p> <p>This function and <code><var>A</var>.'</code> are equivalent. </p> <p><strong>See also:</strong> <a href="#XREFctranspose">ctranspose</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-pagetranspose">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>pagetranspose</strong> <em>(<var>A</var>)</em><a href="#index-pagetranspose" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the page-wise transpose of the N-dimensional array <var>A</var>. </p> <p>This is equivalent to <code><var>A</var>(:,:, <var>k</var>).'</code> for each page <var>k</var>. </p> <p><strong>See also:</strong> <a href="#XREFpagectranspose">pagectranspose</a>, <a href="#XREFtranspose">transpose</a>, <a href="rearranging-matrices.html#XREFpermute">permute</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-uminus">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>uminus</strong> <em>(<var>A</var>)</em><a href="#index-uminus" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>This function and <code><span class="nolinebreak">-</span> <var>A</var></code> are equivalent. </p> <p><strong>See also:</strong> <a href="#XREFuplus">uplus</a>, <a href="#XREFminus">minus</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-uplus">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>uplus</strong> <em>(<var>A</var>)</em><a href="#index-uplus" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>This function and <code>+ <var>A</var></code> are equivalent. </p> <p><strong>See also:</strong> <a href="#XREFuminus">uminus</a>, <a href="#XREFplus">plus</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Arithmetic-Ops.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Arithmetic-Ops.html</a>
  </p>
</div>
