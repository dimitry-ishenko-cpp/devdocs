<div class="section-level-extent" id="Differential_002dAlgebraic-Equations"> <div class="nav-panel"> <p> Next: <a href="matlab_002dcompatible-solvers.html" accesskey="n" rel="next">Matlab-compatible solvers</a>, Previous: <a href="ordinary-differential-equations.html" accesskey="p" rel="prev">Ordinary Differential Equations</a>, Up: <a href="differential-equations.html" accesskey="u" rel="up">Differential Equations</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Differential_002dAlgebraic-Equations-1"><span>24.2 Differential-Algebraic Equations<a class="copiable-link" href="#Differential_002dAlgebraic-Equations-1"> ¶</a></span></h1> <p>The function <code class="code">daspk</code> can be used to solve DAEs of the form </p> <pre class="example" data-language="matlab">0 = f (x-dot, x, t),    x(t=0) = x_0, x-dot(t=0) = x-dot_0</pre> <p>where <em class="math">x-dot</em> is the derivative of <em class="math">x</em>. The equation is solved using Petzold’s DAE solver <small class="sc">DASPK</small>. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-daspk">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">xdot</var>, <var class="var">istate</var>, <var class="var">msg</var>] =</code> <strong class="def-name">daspk</strong> <code class="def-code-arguments">(<var class="var">fcn</var>, <var class="var">x_0</var>, <var class="var">xdot_0</var>, <var class="var">t</var>, <var class="var">t_crit</var>)</code><a class="copiable-link" href="#index-daspk"> ¶</a></span>
</dt> <dd>
<p>Solve a set of differential-algebraic equations. </p> <p><code class="code">daspk</code> solves the set of equations </p> <pre class="example" data-language="matlab">0 = f (x, xdot, t)</pre> <p>with </p> <pre class="example" data-language="matlab">x(t_0) = x_0, xdot(t_0) = xdot_0</pre> <p>The solution is returned in the matrices <var class="var">x</var> and <var class="var">xdot</var>, with each row in the result matrices corresponding to one of the elements in the vector <var class="var">t</var>. The first element of <var class="var">t</var> should be <em class="math">t_0</em> and correspond to the initial state of the system <var class="var">x_0</var> and its derivative <var class="var">xdot_0</var>, so that the first row of the output <var class="var">x</var> is <var class="var">x_0</var> and the first row of the output <var class="var">xdot</var> is <var class="var">xdot_0</var>. </p> <p>The first argument, <var class="var">fcn</var>, is a string, inline, or function handle that names the function <em class="math">f</em> to call to compute the vector of residuals for the set of equations. It must have the form </p> <pre class="example" data-language="matlab">res = f (x, xdot, t)</pre> <p>in which <var class="var">x</var>, <var class="var">xdot</var>, and <var class="var">res</var> are vectors, and <var class="var">t</var> is a scalar. </p> <p>If <var class="var">fcn</var> is a two-element string array or a two-element cell array of strings, inline functions, or function handles, the first element names the function <em class="math">f</em> described above, and the second element names a function to compute the modified Jacobian </p> <pre class="example" data-language="matlab">df       df
jac = -- + c ------
      dx     d xdot</pre> <p>The modified Jacobian function must have the form </p> <pre class="example" data-language="matlab">jac = j (x, xdot, t, c)</pre> <p>The second and third arguments to <code class="code">daspk</code> specify the initial condition of the states and their derivatives, and the fourth argument specifies a vector of output times at which the solution is desired, including the time corresponding to the initial condition. </p> <p>The set of initial states and derivatives are not strictly required to be consistent. If they are not consistent, you must use the <code class="code">daspk_options</code> function to provide additional information so that <code class="code">daspk</code> can compute a consistent starting point. </p> <p>The fifth argument is optional, and may be used to specify a set of times that the DAE solver should not integrate past. It is useful for avoiding difficulties with singularities and points where there is a discontinuity in the derivative. </p> <p>After a successful computation, the value of <var class="var">istate</var> will be greater than zero (consistent with the Fortran version of <small class="sc">DASPK</small>). </p> <p>If the computation is not successful, the value of <var class="var">istate</var> will be less than zero and <var class="var">msg</var> will contain additional information. </p> <p>You can use the function <code class="code">daspk_options</code> to set optional parameters for <code class="code">daspk</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFdassl">dassl</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-daspk_005foptions">
<span class="category-def">: </span><span><strong class="def-name">daspk_options</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-daspk_005foptions"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-daspk_005foptions-1">
<span class="category-def">: </span><span><code class="def-type">val =</code> <strong class="def-name">daspk_options</strong> <code class="def-code-arguments">(<var class="var">opt</var>)</code><a class="copiable-link" href="#index-daspk_005foptions-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-daspk_005foptions-2">
<span class="category-def">: </span><span><strong class="def-name">daspk_options</strong> <code class="def-code-arguments">(<var class="var">opt</var>, <var class="var">val</var>)</code><a class="copiable-link" href="#index-daspk_005foptions-2"> ¶</a></span>
</dt> <dd>
<p>Query or set options for the function <code class="code">daspk</code>. </p> <p>When called with no arguments, the names of all available options and their current values are displayed. </p> <p>Given one argument, return the value of the option <var class="var">opt</var>. </p> <p>When called with two arguments, <code class="code">daspk_options</code> sets the option <var class="var">opt</var> to value <var class="var">val</var>. </p> <p>Options include </p> <dl class="table"> <dt><code class="code">"absolute tolerance"</code></dt> <dd>
<p>Absolute tolerance. May be either vector or scalar. If a vector, it must match the dimension of the state vector, and the relative tolerance must also be a vector of the same length. </p> </dd> <dt><code class="code">"relative tolerance"</code></dt> <dd>
<p>Relative tolerance. May be either vector or scalar. If a vector, it must match the dimension of the state vector, and the absolute tolerance must also be a vector of the same length. </p> <p>The local error test applied at each integration step is </p> <pre class="example" data-language="matlab">abs (local error in x(i))
       &lt;= rtol(i) * abs (Y(i)) + atol(i)</pre> </dd> <dt><code class="code">"compute consistent initial condition"</code></dt> <dd>
<p>Denoting the differential variables in the state vector by ‘<samp class="samp">Y_d</samp>’ and the algebraic variables by ‘<samp class="samp">Y_a</samp>’, <code class="code">ddaspk</code> can solve one of two initialization problems: </p> <ol class="enumerate"> <li> Given Y_d, calculate Y_a and Y’_d </li>
<li> Given Y’, calculate Y. </li>
</ol> <p>In either case, initial values for the given components are input, and initial guesses for the unknown components must also be provided as input. Set this option to 1 to solve the first problem, or 2 to solve the second (the default is 0, so you must provide a set of initial conditions that are consistent). </p> <p>If this option is set to a nonzero value, you must also set the <code class="code">"algebraic variables"</code> option to declare which variables in the problem are algebraic. </p> </dd> <dt><code class="code">"use initial condition heuristics"</code></dt> <dd>
<p>Set to a nonzero value to use the initial condition heuristics options described below. </p> </dd> <dt><code class="code">"initial condition heuristics"</code></dt> <dd>
<p>A vector of the following parameters that can be used to control the initial condition calculation. </p> <dl class="table"> <dt><code class="code">MXNIT</code></dt> <dd>
<p>Maximum number of Newton iterations (default is 5). </p> </dd> <dt><code class="code">MXNJ</code></dt> <dd>
<p>Maximum number of Jacobian evaluations (default is 6). </p> </dd> <dt><code class="code">MXNH</code></dt> <dd>
<p>Maximum number of values of the artificial stepsize parameter to be tried if the <code class="code">"compute consistent initial condition"</code> option has been set to 1 (default is 5). </p> <p>Note that the maximum total number of Newton iterations allowed is <code class="code">MXNIT*MXNJ*MXNH</code> if the <code class="code">"compute consistent initial
condition"</code> option has been set to 1 and <code class="code">MXNIT*MXNJ</code> if it is set to 2. </p> </dd> <dt><code class="code">LSOFF</code></dt> <dd>
<p>Set to a nonzero value to disable the linesearch algorithm (default is 0). </p> </dd> <dt><code class="code">STPTOL</code></dt> <dd>
<p>Minimum scaled step in linesearch algorithm (default is eps^(2/3)). </p> </dd> <dt><code class="code">EPINIT</code></dt> <dd><p>Swing factor in the Newton iteration convergence test. The test is applied to the residual vector, premultiplied by the approximate Jacobian. For convergence, the weighted RMS norm of this vector (scaled by the error weights) must be less than <code class="code">EPINIT*EPCON</code>, where <code class="code">EPCON</code> = 0.33 is the analogous test constant used in the time steps. The default is <code class="code">EPINIT</code> = 0.01. </p></dd> </dl> </dd> <dt><code class="code">"print initial condition info"</code></dt> <dd>
<p>Set this option to a nonzero value to display detailed information about the initial condition calculation (default is 0). </p> </dd> <dt><code class="code">"exclude algebraic variables from error test"</code></dt> <dd>
<p>Set to a nonzero value to exclude algebraic variables from the error test. You must also set the <code class="code">"algebraic variables"</code> option to declare which variables in the problem are algebraic (default is 0). </p> </dd> <dt><code class="code">"algebraic variables"</code></dt> <dd>
<p>A vector of the same length as the state vector. A nonzero element indicates that the corresponding element of the state vector is an algebraic variable (i.e., its derivative does not appear explicitly in the equation set). </p> <p>This option is required by the <code class="code">"compute consistent initial condition"</code> and <code class="code">"exclude algebraic variables from error test"</code> options. </p> </dd> <dt><code class="code">"enforce inequality constraints"</code></dt> <dd>
<p>Set to one of the following values to enforce the inequality constraints specified by the <code class="code">"inequality constraint types"</code> option (default is 0). </p> <ol class="enumerate"> <li> To have constraint checking only in the initial condition calculation. </li>
<li> To enforce constraint checking during the integration. </li>
<li> To enforce both options 1 and 2. </li>
</ol> </dd> <dt><code class="code">"inequality constraint types"</code></dt> <dd>
<p>A vector of the same length as the state specifying the type of inequality constraint. Each element of the vector corresponds to an element of the state and should be assigned one of the following codes </p> <dl class="table"> <dt>-2</dt> <dd>
<p>Less than zero. </p> </dd> <dt>-1</dt> <dd>
<p>Less than or equal to zero. </p> </dd> <dt>0</dt> <dd>
<p>Not constrained. </p> </dd> <dt>1</dt> <dd>
<p>Greater than or equal to zero. </p> </dd> <dt>2</dt> <dd><p>Greater than zero. </p></dd> </dl> <p>This option only has an effect if the <code class="code">"enforce inequality constraints"</code> option is nonzero. </p> </dd> <dt><code class="code">"initial step size"</code></dt> <dd>
<p>Differential-algebraic problems may occasionally suffer from severe scaling difficulties on the first step. If you know a great deal about the scaling of your problem, you can help to alleviate this problem by specifying an initial stepsize (default is computed automatically). </p> </dd> <dt><code class="code">"maximum order"</code></dt> <dd>
<p>Restrict the maximum order of the solution method. This option must be between 1 and 5, inclusive (default is 5). </p> </dd> <dt><code class="code">"maximum step size"</code></dt> <dd><p>Setting the maximum stepsize will avoid passing over very large regions (default is not specified). </p></dd> </dl> </dd>
</dl> <p>Octave also includes <small class="sc">DASSL</small>, an earlier version of <small class="sc">DASPK</small>, and <small class="sc">DASRT</small>, which can be used to solve DAEs with constraints (stopping conditions). </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-dassl">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">xdot</var>, <var class="var">istate</var>, <var class="var">msg</var>] =</code> <strong class="def-name">dassl</strong> <code class="def-code-arguments">(<var class="var">fcn</var>, <var class="var">x_0</var>, <var class="var">xdot_0</var>, <var class="var">t</var>, <var class="var">t_crit</var>)</code><a class="copiable-link" href="#index-dassl"> ¶</a></span>
</dt> <dd>
<p>Solve a set of differential-algebraic equations. </p> <p><code class="code">dassl</code> solves the set of equations </p> <pre class="example" data-language="matlab">0 = f (x, xdot, t)</pre> <p>with </p> <pre class="example" data-language="matlab">x(t_0) = x_0, xdot(t_0) = xdot_0</pre> <p>The solution is returned in the matrices <var class="var">x</var> and <var class="var">xdot</var>, with each row in the result matrices corresponding to one of the elements in the vector <var class="var">t</var>. The first element of <var class="var">t</var> should be <em class="math">t_0</em> and correspond to the initial state of the system <var class="var">x_0</var> and its derivative <var class="var">xdot_0</var>, so that the first row of the output <var class="var">x</var> is <var class="var">x_0</var> and the first row of the output <var class="var">xdot</var> is <var class="var">xdot_0</var>. </p> <p>The first argument, <var class="var">fcn</var>, is a string, inline, or function handle that names the function <em class="math">f</em> to call to compute the vector of residuals for the set of equations. It must have the form </p> <pre class="example" data-language="matlab">res = f (x, xdot, t)</pre> <p>in which <var class="var">x</var>, <var class="var">xdot</var>, and <var class="var">res</var> are vectors, and <var class="var">t</var> is a scalar. </p> <p>If <var class="var">fcn</var> is a two-element string array or a two-element cell array of strings, inline functions, or function handles, the first element names the function <em class="math">f</em> described above, and the second element names a function to compute the modified Jacobian </p> <pre class="example" data-language="matlab">df       df
jac = -- + c ------
      dx     d xdot</pre> <p>The modified Jacobian function must have the form </p> <pre class="example" data-language="matlab">jac = j (x, xdot, t, c)</pre> <p>The second and third arguments to <code class="code">dassl</code> specify the initial condition of the states and their derivatives, and the fourth argument specifies a vector of output times at which the solution is desired, including the time corresponding to the initial condition. </p> <p>The set of initial states and derivatives are not strictly required to be consistent. In practice, however, <small class="sc">DASSL</small> is not very good at determining a consistent set for you, so it is best if you ensure that the initial values result in the function evaluating to zero. </p> <p>The fifth argument is optional, and may be used to specify a set of times that the DAE solver should not integrate past. It is useful for avoiding difficulties with singularities and points where there is a discontinuity in the derivative. </p> <p>After a successful computation, the value of <var class="var">istate</var> will be greater than zero (consistent with the Fortran version of <small class="sc">DASSL</small>). </p> <p>If the computation is not successful, the value of <var class="var">istate</var> will be less than zero and <var class="var">msg</var> will contain additional information. </p> <p>You can use the function <code class="code">dassl_options</code> to set optional parameters for <code class="code">dassl</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFdaspk">daspk</a>, <a class="ref" href="#XREFdasrt">dasrt</a>, <a class="ref" href="ordinary-differential-equations.html#XREFlsode">lsode</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-dassl_005foptions">
<span class="category-def">: </span><span><strong class="def-name">dassl_options</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-dassl_005foptions"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-dassl_005foptions-1">
<span class="category-def">: </span><span><code class="def-type">val =</code> <strong class="def-name">dassl_options</strong> <code class="def-code-arguments">(<var class="var">opt</var>)</code><a class="copiable-link" href="#index-dassl_005foptions-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-dassl_005foptions-2">
<span class="category-def">: </span><span><strong class="def-name">dassl_options</strong> <code class="def-code-arguments">(<var class="var">opt</var>, <var class="var">val</var>)</code><a class="copiable-link" href="#index-dassl_005foptions-2"> ¶</a></span>
</dt> <dd>
<p>Query or set options for the function <code class="code">dassl</code>. </p> <p>When called with no arguments, the names of all available options and their current values are displayed. </p> <p>Given one argument, return the value of the option <var class="var">opt</var>. </p> <p>When called with two arguments, <code class="code">dassl_options</code> sets the option <var class="var">opt</var> to value <var class="var">val</var>. </p> <p>Options include </p> <dl class="table"> <dt><code class="code">"absolute tolerance"</code></dt> <dd>
<p>Absolute tolerance. May be either vector or scalar. If a vector, it must match the dimension of the state vector, and the relative tolerance must also be a vector of the same length. </p> </dd> <dt><code class="code">"relative tolerance"</code></dt> <dd>
<p>Relative tolerance. May be either vector or scalar. If a vector, it must match the dimension of the state vector, and the absolute tolerance must also be a vector of the same length. </p> <p>The local error test applied at each integration step is </p> <pre class="example" data-language="matlab">abs (local error in x(i))
       &lt;= rtol(i) * abs (Y(i)) + atol(i)</pre> </dd> <dt><code class="code">"compute consistent initial condition"</code></dt> <dd>
<p>If nonzero, <code class="code">dassl</code> will attempt to compute a consistent set of initial conditions. This is generally not reliable, so it is best to provide a consistent set and leave this option set to zero. </p> </dd> <dt><code class="code">"enforce nonnegativity constraints"</code></dt> <dd>
<p>If you know that the solutions to your equations will always be non-negative, it may help to set this parameter to a nonzero value. However, it is probably best to try leaving this option set to zero first, and only setting it to a nonzero value if that doesn’t work very well. </p> </dd> <dt><code class="code">"initial step size"</code></dt> <dd>
<p>Differential-algebraic problems may occasionally suffer from severe scaling difficulties on the first step. If you know a great deal about the scaling of your problem, you can help to alleviate this problem by specifying an initial stepsize. </p> </dd> <dt><code class="code">"maximum order"</code></dt> <dd>
<p>Restrict the maximum order of the solution method. This option must be between 1 and 5, inclusive. </p> </dd> <dt><code class="code">"maximum step size"</code></dt> <dd>
<p>Setting the maximum stepsize will avoid passing over very large regions (default is not specified). </p> </dd> <dt><code class="code">"step limit"</code></dt> <dd><p>Maximum number of integration steps to attempt on a single call to the underlying Fortran code. </p></dd> </dl> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-dasrt">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">xdot</var>, <var class="var">t_out</var>, <var class="var">istat</var>, <var class="var">msg</var>] =</code> <strong class="def-name">dasrt</strong> <code class="def-code-arguments">(<var class="var">fcn</var>, <var class="var">g</var>, <var class="var">x_0</var>, <var class="var">xdot_0</var>, <var class="var">t</var>)</code><a class="copiable-link" href="#index-dasrt"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-dasrt-1">
<span class="category-def">: </span><span><code class="def-type">… =</code> <strong class="def-name">dasrt</strong> <code class="def-code-arguments">(<var class="var">fcn</var>, <var class="var">g</var>, <var class="var">x_0</var>, <var class="var">xdot_0</var>, <var class="var">t</var>, <var class="var">t_crit</var>)</code><a class="copiable-link" href="#index-dasrt-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-dasrt-2">
<span class="category-def">: </span><span><code class="def-type">… =</code> <strong class="def-name">dasrt</strong> <code class="def-code-arguments">(<var class="var">fcn</var>, <var class="var">x_0</var>, <var class="var">xdot_0</var>, <var class="var">t</var>)</code><a class="copiable-link" href="#index-dasrt-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-dasrt-3">
<span class="category-def">: </span><span><code class="def-type">… =</code> <strong class="def-name">dasrt</strong> <code class="def-code-arguments">(<var class="var">fcn</var>, <var class="var">x_0</var>, <var class="var">xdot_0</var>, <var class="var">t</var>, <var class="var">t_crit</var>)</code><a class="copiable-link" href="#index-dasrt-3"> ¶</a></span>
</dt> <dd>
<p>Solve a set of differential-algebraic equations. </p> <p><code class="code">dasrt</code> solves the set of equations </p> <pre class="example" data-language="matlab">0 = f (x, xdot, t)</pre> <p>with </p> <pre class="example" data-language="matlab">x(t_0) = x_0, xdot(t_0) = xdot_0</pre> <p>with functional stopping criteria (root solving). </p> <p>The solution is returned in the matrices <var class="var">x</var> and <var class="var">xdot</var>, with each row in the result matrices corresponding to one of the elements in the vector <var class="var">t_out</var>. The first element of <var class="var">t</var> should be <em class="math">t_0</em> and correspond to the initial state of the system <var class="var">x_0</var> and its derivative <var class="var">xdot_0</var>, so that the first row of the output <var class="var">x</var> is <var class="var">x_0</var> and the first row of the output <var class="var">xdot</var> is <var class="var">xdot_0</var>. </p> <p>The vector <var class="var">t</var> provides an upper limit on the length of the integration. If the stopping condition is met, the vector <var class="var">t_out</var> will be shorter than <var class="var">t</var>, and the final element of <var class="var">t_out</var> will be the point at which the stopping condition was met, and may not correspond to any element of the vector <var class="var">t</var>. </p> <p>The first argument, <var class="var">fcn</var>, is a string, inline, or function handle that names the function <em class="math">f</em> to call to compute the vector of residuals for the set of equations. It must have the form </p> <pre class="example" data-language="matlab">res = f (x, xdot, t)</pre> <p>in which <var class="var">x</var>, <var class="var">xdot</var>, and <var class="var">res</var> are vectors, and <var class="var">t</var> is a scalar. </p> <p>If <var class="var">fcn</var> is a two-element string array or a two-element cell array of strings, inline functions, or function handles, the first element names the function <em class="math">f</em> described above, and the second element names a function to compute the modified Jacobian </p> <pre class="example" data-language="matlab">df       df
jac = -- + c ------
      dx     d xdot</pre> <p>The modified Jacobian function must have the form </p> <pre class="example" data-language="matlab">jac = j (x, xdot, t, c)</pre> <p>The optional second argument names a function that defines the constraint functions whose roots are desired during the integration. This function must have the form </p> <pre class="example" data-language="matlab">g_out = g (x, t)</pre> <p>and return a vector of the constraint function values. If the value of any of the constraint functions changes sign, <small class="sc">DASRT</small> will attempt to stop the integration at the point of the sign change. </p> <p>If the name of the constraint function is omitted, <code class="code">dasrt</code> solves the same problem as <code class="code">daspk</code> or <code class="code">dassl</code>. </p> <p>Note that because of numerical errors in the constraint functions due to round-off and integration error, <small class="sc">DASRT</small> may return false roots, or return the same root at two or more nearly equal values of <var class="var">T</var>. If such false roots are suspected, the user should consider smaller error tolerances or higher precision in the evaluation of the constraint functions. </p> <p>If a root of some constraint function defines the end of the problem, the input to <small class="sc">DASRT</small> should nevertheless allow integration to a point slightly past that root, so that <small class="sc">DASRT</small> can locate the root by interpolation. </p> <p>The third and fourth arguments to <code class="code">dasrt</code> specify the initial condition of the states and their derivatives, and the fourth argument specifies a vector of output times at which the solution is desired, including the time corresponding to the initial condition. </p> <p>The set of initial states and derivatives are not strictly required to be consistent. In practice, however, <small class="sc">DASSL</small> is not very good at determining a consistent set for you, so it is best if you ensure that the initial values result in the function evaluating to zero. </p> <p>The sixth argument is optional, and may be used to specify a set of times that the DAE solver should not integrate past. It is useful for avoiding difficulties with singularities and points where there is a discontinuity in the derivative. </p> <p>After a successful computation, the value of <var class="var">istate</var> will be greater than zero (consistent with the Fortran version of <small class="sc">DASSL</small>). </p> <p>If the computation is not successful, the value of <var class="var">istate</var> will be less than zero and <var class="var">msg</var> will contain additional information. </p> <p>You can use the function <code class="code">dasrt_options</code> to set optional parameters for <code class="code">dasrt</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFdasrt_005foptions">dasrt_options</a>, <a class="ref" href="#XREFdaspk">daspk</a>, <a class="ref" href="#XREFdasrt">dasrt</a>, <a class="ref" href="ordinary-differential-equations.html#XREFlsode">lsode</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-dasrt_005foptions">
<span class="category-def">: </span><span><strong class="def-name">dasrt_options</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-dasrt_005foptions"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-dasrt_005foptions-1">
<span class="category-def">: </span><span><code class="def-type">val =</code> <strong class="def-name">dasrt_options</strong> <code class="def-code-arguments">(<var class="var">opt</var>)</code><a class="copiable-link" href="#index-dasrt_005foptions-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-dasrt_005foptions-2">
<span class="category-def">: </span><span><strong class="def-name">dasrt_options</strong> <code class="def-code-arguments">(<var class="var">opt</var>, <var class="var">val</var>)</code><a class="copiable-link" href="#index-dasrt_005foptions-2"> ¶</a></span>
</dt> <dd>
<p>Query or set options for the function <code class="code">dasrt</code>. </p> <p>When called with no arguments, the names of all available options and their current values are displayed. </p> <p>Given one argument, return the value of the option <var class="var">opt</var>. </p> <p>When called with two arguments, <code class="code">dasrt_options</code> sets the option <var class="var">opt</var> to value <var class="var">val</var>. </p> <p>Options include </p> <dl class="table"> <dt><code class="code">"absolute tolerance"</code></dt> <dd>
<p>Absolute tolerance. May be either vector or scalar. If a vector, it must match the dimension of the state vector, and the relative tolerance must also be a vector of the same length. </p> </dd> <dt><code class="code">"relative tolerance"</code></dt> <dd>
<p>Relative tolerance. May be either vector or scalar. If a vector, it must match the dimension of the state vector, and the absolute tolerance must also be a vector of the same length. </p> <p>The local error test applied at each integration step is </p> <pre class="example" data-language="matlab">abs (local error in x(i)) &lt;= ...
      rtol(i) * abs (Y(i)) + atol(i)</pre> </dd> <dt><code class="code">"initial step size"</code></dt> <dd>
<p>Differential-algebraic problems may occasionally suffer from severe scaling difficulties on the first step. If you know a great deal about the scaling of your problem, you can help to alleviate this problem by specifying an initial stepsize. </p> </dd> <dt><code class="code">"maximum order"</code></dt> <dd>
<p>Restrict the maximum order of the solution method. This option must be between 1 and 5, inclusive. </p> </dd> <dt><code class="code">"maximum step size"</code></dt> <dd>
<p>Setting the maximum stepsize will avoid passing over very large regions. </p> </dd> <dt><code class="code">"step limit"</code></dt> <dd><p>Maximum number of integration steps to attempt on a single call to the underlying Fortran code. </p></dd> </dl> </dd>
</dl> <p>See K. E. Brenan, et al., <cite class="cite">Numerical Solution of Initial-Value Problems in Differential-Algebraic Equations</cite>, North-Holland (1989), DOI: <a class="url" href="https://doi.org/10.1137/1.9781611971224">https://doi.org/10.1137/1.9781611971224</a>, for more information about the implementation of <small class="sc">DASSL</small>. </p> </div>  <div class="nav-panel"> <p> Next: <a href="matlab_002dcompatible-solvers.html">Matlab-compatible solvers</a>, Previous: <a href="ordinary-differential-equations.html">Ordinary Differential Equations</a>, Up: <a href="differential-equations.html">Differential Equations</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Differential_002dAlgebraic-Equations.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Differential_002dAlgebraic-Equations.html</a>
  </p>
</div>
