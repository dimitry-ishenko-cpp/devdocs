<div class="subsection-level-extent" id="Searching-in-Strings"> <div class="nav-panel"> <p> Next: <a href="searching-and-replacing-in-strings.html" accesskey="n" rel="next">Searching and Replacing in Strings</a>, Previous: <a href="splitting-and-joining-strings.html" accesskey="p" rel="prev">Splitting and Joining Strings</a>, Up: <a href="string-operations.html" accesskey="u" rel="up">String Operations</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="Searching-in-Strings-1"><span>5.3.4 Searching in Strings<a class="copiable-link" href="#Searching-in-Strings-1"> ¶</a></span></h1> <p>Since a string is a character array, comparisons between strings work element by element as the following example shows: </p> <pre class="example" data-language="matlab">GNU = "GNU's Not UNIX";
spaces = (GNU == " ")
     ⇒ spaces =
       0   0   0   0   0   1   0   0   0   1   0   0   0   0</pre> <p>To determine if two strings are identical it is necessary to use the <code class="code">strcmp</code> function. It compares complete strings and is case sensitive. <code class="code">strncmp</code> compares only the first <code class="code">N</code> characters (with <code class="code">N</code> given as a parameter). <code class="code">strcmpi</code> and <code class="code">strncmpi</code> are the corresponding functions for case-insensitive comparison. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-strcmp">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">strcmp</strong> <code class="def-code-arguments">(<var class="var">str1</var>, <var class="var">str2</var>)</code><a class="copiable-link" href="#index-strcmp"> ¶</a></span>
</dt> <dd>
<p>Return 1 if the character strings <var class="var">str1</var> and <var class="var">str2</var> are the same, and 0 otherwise. </p> <p>If either <var class="var">str1</var> or <var class="var">str2</var> is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array. The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string. </p> <p><strong class="strong">Caution:</strong> For compatibility with <small class="sc">MATLAB</small>, Octave’s strcmp function returns 1 if the character strings are equal, and 0 otherwise. This is just the opposite of the corresponding C library function. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstrcmpi">strcmpi</a>, <a class="ref" href="#XREFstrncmp">strncmp</a>, <a class="ref" href="#XREFstrncmpi">strncmpi</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-strncmp">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">strncmp</strong> <code class="def-code-arguments">(<var class="var">str1</var>, <var class="var">str2</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-strncmp"> ¶</a></span>
</dt> <dd>
<p>Return 1 if the first <var class="var">n</var> characters of strings <var class="var">str1</var> and <var class="var">str2</var> are the same, and 0 otherwise. </p> <pre class="example" data-language="matlab">strncmp ("abce", "abcd", 3)
      ⇒ 1</pre> <p>If either <var class="var">str1</var> or <var class="var">str2</var> is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array. The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string. </p> <pre class="example" data-language="matlab">strncmp ("abce", {"abcd", "bca", "abc"}, 3)
     ⇒ [1, 0, 1]</pre> <p><strong class="strong">Caution:</strong> For compatibility with <small class="sc">MATLAB</small>, Octave’s strncmp function returns 1 if the character strings are equal, and 0 otherwise. This is just the opposite of the corresponding C library function. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstrncmpi">strncmpi</a>, <a class="ref" href="#XREFstrcmp">strcmp</a>, <a class="ref" href="#XREFstrcmpi">strcmpi</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-strcmpi">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">strcmpi</strong> <code class="def-code-arguments">(<var class="var">str1</var>, <var class="var">str2</var>)</code><a class="copiable-link" href="#index-strcmpi"> ¶</a></span>
</dt> <dd>
<p>Return 1 if the character strings <var class="var">str1</var> and <var class="var">str2</var> are the same, disregarding case of alphabetic characters, and 0 otherwise. </p> <p>If either <var class="var">str1</var> or <var class="var">str2</var> is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array. The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string. </p> <p><strong class="strong">Caution:</strong> For compatibility with <small class="sc">MATLAB</small>, Octave’s strcmp function returns 1 if the character strings are equal, and 0 otherwise. This is just the opposite of the corresponding C library function. </p> <p><strong class="strong">Caution:</strong> National alphabets are not supported. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstrcmp">strcmp</a>, <a class="ref" href="#XREFstrncmp">strncmp</a>, <a class="ref" href="#XREFstrncmpi">strncmpi</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-strncmpi">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">strncmpi</strong> <code class="def-code-arguments">(<var class="var">str1</var>, <var class="var">str2</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-strncmpi"> ¶</a></span>
</dt> <dd>
<p>Return 1 if the first <var class="var">n</var> character of <var class="var">s1</var> and <var class="var">s2</var> are the same, disregarding case of alphabetic characters, and 0 otherwise. </p> <p>If either <var class="var">str1</var> or <var class="var">str2</var> is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array. The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string. </p> <p><strong class="strong">Caution:</strong> For compatibility with <small class="sc">MATLAB</small>, Octave’s strncmpi function returns 1 if the character strings are equal, and 0 otherwise. This is just the opposite of the corresponding C library function. </p> <p><strong class="strong">Caution:</strong> National alphabets are not supported. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstrncmp">strncmp</a>, <a class="ref" href="#XREFstrcmp">strcmp</a>, <a class="ref" href="#XREFstrcmpi">strcmpi</a>. </p>
</dd>
</dl> <p>Despite those comparison functions, there are more specialized function to find the index position of a search pattern within a string. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-startsWith">
<span class="category-def">: </span><span><code class="def-type"><var class="var">retval</var> =</code> <strong class="def-name">startsWith</strong> <code class="def-code-arguments">(<var class="var">str</var>, <var class="var">pattern</var>)</code><a class="copiable-link" href="#index-startsWith"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-startsWith-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">retval</var> =</code> <strong class="def-name">startsWith</strong> <code class="def-code-arguments">(<var class="var">str</var>, <var class="var">pattern</var>, "IgnoreCase", <var class="var">ignore_case</var>)</code><a class="copiable-link" href="#index-startsWith-1"> ¶</a></span>
</dt> <dd>
<p>Check whether string(s) start with pattern(s). </p> <p>Return an array of logical values that indicates which string(s) in the input <var class="var">str</var> (a single string or cell array of strings) begin with the input <var class="var">pattern</var> (a single string or cell array of strings). </p> <p>If the value of the parameter <code class="code">"IgnoreCase"</code> is true, then the function will ignore the letter case of <var class="var">str</var> and <var class="var">pattern</var>. By default, the comparison is case sensitive. </p> <p>Examples: </p> <pre class="example" data-language="matlab">## one string and one pattern while considering case
startsWith ("hello", "he")
      ⇒  1


## one string and one pattern while ignoring case
startsWith ("hello", "HE", "IgnoreCase", true)
      ⇒  1


## multiple strings and multiple patterns while considering case
startsWith ({"lab work.pptx", "data.txt", "foundations.ppt"},
            {"lab", "data"})
      ⇒  1  1  0


## multiple strings and one pattern while considering case
startsWith ({"DATASHEET.ods", "data.txt", "foundations.ppt"},
            "data", "IgnoreCase", false)
      ⇒  0  1  0


## multiple strings and one pattern while ignoring case
startsWith ({"DATASHEET.ods", "data.txt", "foundations.ppt"},
            "data", "IgnoreCase", true)
      ⇒  1  1  0</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFendsWith">endsWith</a>, <a class="ref" href="searching-and-replacing-in-strings.html#XREFregexp">regexp</a>, <a class="ref" href="#XREFstrncmp">strncmp</a>, <a class="ref" href="#XREFstrncmpi">strncmpi</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-endsWith">
<span class="category-def">: </span><span><code class="def-type"><var class="var">retval</var> =</code> <strong class="def-name">endsWith</strong> <code class="def-code-arguments">(<var class="var">str</var>, <var class="var">pattern</var>)</code><a class="copiable-link" href="#index-endsWith"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-endsWith-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">retval</var> =</code> <strong class="def-name">endsWith</strong> <code class="def-code-arguments">(<var class="var">str</var>, <var class="var">pattern</var>, "IgnoreCase", <var class="var">ignore_case</var>)</code><a class="copiable-link" href="#index-endsWith-1"> ¶</a></span>
</dt> <dd>
<p>Check whether string(s) end with pattern(s). </p> <p>Return an array of logical values that indicates which string(s) in the input <var class="var">str</var> (a single string or cell array of strings) end with the input <var class="var">pattern</var> (a single string or cell array of strings). </p> <p>If the value of the parameter <code class="code">"IgnoreCase"</code> is true, then the function will ignore the letter case of <var class="var">str</var> and <var class="var">pattern</var>. By default, the comparison is case sensitive. </p> <p>Examples: </p> <pre class="example" data-language="matlab">## one string and one pattern while considering case
endsWith ("hello", "lo")
      ⇒  1


## one string and one pattern while ignoring case
endsWith ("hello", "LO", "IgnoreCase", true)
      ⇒  1


## multiple strings and multiple patterns while considering case
endsWith ({"tests.txt", "mydoc.odt", "myFunc.m", "results.pptx"},
          {".docx", ".odt", ".txt"})
      ⇒  1  1  0  0


## multiple strings and one pattern while considering case
endsWith ({"TESTS.TXT", "mydoc.odt", "result.txt", "myFunc.m"},
          ".txt", "IgnoreCase", false)
      ⇒  0  0  1  0


## multiple strings and one pattern while ignoring case
endsWith ({"TESTS.TXT", "mydoc.odt", "result.txt", "myFunc.m"},
          ".txt", "IgnoreCase", true)
      ⇒  1  0  1  0</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstartsWith">startsWith</a>, <a class="ref" href="searching-and-replacing-in-strings.html#XREFregexp">regexp</a>, <a class="ref" href="#XREFstrncmp">strncmp</a>, <a class="ref" href="#XREFstrncmpi">strncmpi</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-findstr">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">findstr</strong> <code class="def-code-arguments">(<var class="var">s</var>, <var class="var">t</var>)</code><a class="copiable-link" href="#index-findstr"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-findstr-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">findstr</strong> <code class="def-code-arguments">(<var class="var">s</var>, <var class="var">t</var>, <var class="var">overlap</var>)</code><a class="copiable-link" href="#index-findstr-1"> ¶</a></span>
</dt> <dd> <p>This function is obsolete. Use <code class="code">strfind</code> instead. </p> <p>Return the vector of all positions in the longer of the two strings <var class="var">s</var> and <var class="var">t</var> where an occurrence of the shorter of the two starts. </p> <p>If the optional argument <var class="var">overlap</var> is true (default), the returned vector can include overlapping positions. For example: </p> <pre class="example" data-language="matlab">findstr ("ababab", "a")
     ⇒ [1, 3, 5];
findstr ("abababa", "aba", 0)
     ⇒ [1, 5]</pre> <p><strong class="strong">Caution:</strong> <code class="code">findstr</code> is obsolete. Use <code class="code">strfind</code> in all new code. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstrfind">strfind</a>, <a class="ref" href="#XREFstrmatch">strmatch</a>, <a class="ref" href="#XREFstrcmp">strcmp</a>, <a class="ref" href="#XREFstrncmp">strncmp</a>, <a class="ref" href="#XREFstrcmpi">strcmpi</a>, <a class="ref" href="#XREFstrncmpi">strncmpi</a>, <a class="ref" href="finding-elements-and-checking-conditions.html#XREFfind">find</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-strchr">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">strchr</strong> <code class="def-code-arguments">(<var class="var">str</var>, <var class="var">chars</var>)</code><a class="copiable-link" href="#index-strchr"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strchr-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">strchr</strong> <code class="def-code-arguments">(<var class="var">str</var>, <var class="var">chars</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-strchr-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strchr-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">strchr</strong> <code class="def-code-arguments">(<var class="var">str</var>, <var class="var">chars</var>, <var class="var">n</var>, <var class="var">direction</var>)</code><a class="copiable-link" href="#index-strchr-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strchr-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">i</var>, <var class="var">j</var>] =</code> <strong class="def-name">strchr</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-strchr-3"> ¶</a></span>
</dt> <dd>
<p>Search through the string <var class="var">str</var> for occurrences of characters from the set <var class="var">chars</var>. </p> <p>The return value(s), as well as the <var class="var">n</var> and <var class="var">direction</var> arguments behave identically as in <code class="code">find</code>. </p> <p>This will be faster than using <code class="code">regexp</code> in most cases. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="finding-elements-and-checking-conditions.html#XREFfind">find</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-index">
<span class="category-def">: </span><span><code class="def-type"><var class="var">n</var> =</code> <strong class="def-name">index</strong> <code class="def-code-arguments">(<var class="var">s</var>, <var class="var">t</var>)</code><a class="copiable-link" href="#index-index"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-index-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">n</var> =</code> <strong class="def-name">index</strong> <code class="def-code-arguments">(<var class="var">s</var>, <var class="var">t</var>, <var class="var">direction</var>)</code><a class="copiable-link" href="#index-index-1"> ¶</a></span>
</dt> <dd>
<p>Return the position of the first occurrence of the string <var class="var">t</var> in the string <var class="var">s</var>, or 0 if no occurrence is found. </p> <p><var class="var">s</var> may also be a string array or cell array of strings. </p> <p>For example: </p> <pre class="example" data-language="matlab">index ("Teststring", "t")
    ⇒ 4</pre> <p>If <var class="var">direction</var> is <code class="code">"first"</code>, return the first element found. If <var class="var">direction</var> is <code class="code">"last"</code>, return the last element found. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="finding-elements-and-checking-conditions.html#XREFfind">find</a>, <a class="ref" href="#XREFrindex">rindex</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-rindex">
<span class="category-def">: </span><span><code class="def-type"><var class="var">n</var> =</code> <strong class="def-name">rindex</strong> <code class="def-code-arguments">(<var class="var">s</var>, <var class="var">t</var>)</code><a class="copiable-link" href="#index-rindex"> ¶</a></span>
</dt> <dd>
<p>Return the position of the last occurrence of the character string <var class="var">t</var> in the character string <var class="var">s</var>, or 0 if no occurrence is found. </p> <p><var class="var">s</var> may also be a string array or cell array of strings. </p> <p>For example: </p> <pre class="example" data-language="matlab">rindex ("Teststring", "t")
     ⇒ 6</pre> <p>The <code class="code">rindex</code> function is equivalent to <code class="code">index</code> with <var class="var">direction</var> set to <code class="code">"last"</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="finding-elements-and-checking-conditions.html#XREFfind">find</a>, <a class="ref" href="#XREFindex">index</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-unicode_005fidx">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">unicode_idx</strong> <code class="def-code-arguments">(<var class="var">str</var>)</code><a class="copiable-link" href="#index-unicode_005fidx"> ¶</a></span>
</dt> <dd>
<p>Return an array with the indices for each UTF-8 encoded character in <var class="var">str</var>. </p> <pre class="example" data-language="matlab">unicode_idx ("aäbc")
     ⇒ [1, 2, 2, 3, 4]</pre> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-strfind">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">strfind</strong> <code class="def-code-arguments">(<var class="var">str</var>, <var class="var">pattern</var>)</code><a class="copiable-link" href="#index-strfind"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strfind-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">strfind</strong> <code class="def-code-arguments">(<var class="var">cellstr</var>, <var class="var">pattern</var>)</code><a class="copiable-link" href="#index-strfind-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strfind-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">strfind</strong> <code class="def-code-arguments">(…, "overlaps", <var class="var">val</var>)</code><a class="copiable-link" href="#index-strfind-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strfind-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">strfind</strong> <code class="def-code-arguments">(…, "forcecelloutput", <var class="var">val</var>)</code><a class="copiable-link" href="#index-strfind-3"> ¶</a></span>
</dt> <dd>
<p>Search for <var class="var">pattern</var> in the string <var class="var">str</var> and return the starting index of every such occurrence in the vector <var class="var">idx</var>. </p> <p>If there is no such occurrence, or if <var class="var">pattern</var> is longer than <var class="var">str</var>, or if <var class="var">pattern</var> itself is empty, then <var class="var">idx</var> is the empty array <code class="code">[]</code>. </p> <p>The optional argument <code class="code">"overlaps"</code> determines whether the pattern can match at every position in <var class="var">str</var> (true), or only for unique occurrences of the complete pattern (false). The default is true. </p> <p>If a cell array of strings <var class="var">cellstr</var> is specified then <var class="var">idx</var> is a cell array of vectors, as specified above. </p> <p>The optional argument <code class="code">"forcecelloutput"</code> forces <var class="var">idx</var> to be returned as a cell array of vectors. The default is false. </p> <p>Examples: </p> <pre class="example" data-language="matlab">strfind ("abababa", "aba")
     ⇒ [1, 3, 5]


strfind ("abababa", "aba", "overlaps", false)
     ⇒ [1, 5]


strfind ({"abababa", "bebebe", "ab"}, "aba")
     ⇒
        {
          [1,1] =

             1   3   5

          [1,2] = [](1x0)
          [1,3] = [](1x0)
        }


strfind ("abababa", "aba", "forcecelloutput", true)
     ⇒
        {
          [1,1] =

             1   3   5
        }</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="searching-and-replacing-in-strings.html#XREFregexp">regexp</a>, <a class="ref" href="searching-and-replacing-in-strings.html#XREFregexpi">regexpi</a>, <a class="ref" href="finding-elements-and-checking-conditions.html#XREFfind">find</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-strmatch">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">strmatch</strong> <code class="def-code-arguments">(<var class="var">s</var>, <var class="var">A</var>)</code><a class="copiable-link" href="#index-strmatch"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-strmatch-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">strmatch</strong> <code class="def-code-arguments">(<var class="var">s</var>, <var class="var">A</var>, "exact")</code><a class="copiable-link" href="#index-strmatch-1"> ¶</a></span>
</dt> <dd> <p>This function is obsolete. <strong class="strong">Use an alternative</strong> such as <code class="code">strncmp</code> or <code class="code">strcmp</code> instead. </p> <p>Return indices of entries of <var class="var">A</var> which begin with the string <var class="var">s</var>. </p> <p>The second argument <var class="var">A</var> must be a string, character matrix, or a cell array of strings. </p> <p>If the third argument <code class="code">"exact"</code> is not given, then <var class="var">s</var> only needs to match <var class="var">A</var> up to the length of <var class="var">s</var>. Trailing spaces and nulls in <var class="var">s</var> and <var class="var">A</var> are ignored when matching. </p> <p>For example: </p> <pre class="example" data-language="matlab">strmatch ("apple", "apple juice")
     ⇒ 1

strmatch ("apple", ["apple  "; "apple juice"; "an apple"])
     ⇒ [1; 2]

strmatch ("apple", ["apple  "; "apple juice"; "an apple"], "exact")
     ⇒ [1]</pre> <p><strong class="strong">Caution:</strong> <code class="code">strmatch</code> is obsolete (and can produce incorrect results in <small class="sc">MATLAB</small> when used with cell arrays of strings. Use <code class="code">strncmp</code> (normal case) or <code class="code">strcmp</code> (<code class="code">"exact"</code> case) in all new code. Other replacement possibilities, depending on application, include <code class="code">regexp</code> or <code class="code">validatestring</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstrncmp">strncmp</a>, <a class="ref" href="#XREFstrcmp">strcmp</a>, <a class="ref" href="searching-and-replacing-in-strings.html#XREFregexp">regexp</a>, <a class="ref" href="#XREFstrfind">strfind</a>, <a class="ref" href="validating-the-type-of-arguments.html#XREFvalidatestring">validatestring</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="searching-and-replacing-in-strings.html">Searching and Replacing in Strings</a>, Previous: <a href="splitting-and-joining-strings.html">Splitting and Joining Strings</a>, Up: <a href="string-operations.html">String Operations</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Searching-in-Strings.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Searching-in-Strings.html</a>
  </p>
</div>
