<div class="section-level-extent" id="Special-Functions"> <div class="nav-panel"> <p> Next: <a href="rational-approximations.html" accesskey="n" rel="next">Rational Approximations</a>, Previous: <a href="utility-functions.html" accesskey="p" rel="prev">Utility Functions</a>, Up: <a href="arithmetic.html" accesskey="u" rel="up">Arithmetic</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Special-Functions-1"><span>17.6 Special Functions<a class="copiable-link" href="#Special-Functions-1"> ¶</a></span></h1>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-airy">
<span class="category-def">: </span><span><code class="def-type"><var class="var">a</var> =</code> <strong class="def-name">airy</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-airy"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-airy-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">a</var> =</code> <strong class="def-name">airy</strong> <code class="def-code-arguments">(<var class="var">k</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-airy-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-airy-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">a</var> =</code> <strong class="def-name">airy</strong> <code class="def-code-arguments">(<var class="var">k</var>, <var class="var">z</var>, <var class="var">scale</var>)</code><a class="copiable-link" href="#index-airy-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-airy-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">a</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">airy</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-airy-3"> ¶</a></span>
</dt> <dd> <p>Compute Airy functions of the first and second kind, and their derivatives. </p> <pre class="example" data-language="matlab">K   Function   Scale factor (if scale is true)
---  --------   ---------------------------------------
 0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
 1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
 2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))
 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))</pre> <p>The function call <code class="code">airy (<var class="var">z</var>)</code> is equivalent to <code class="code">airy (0, <var class="var">z</var>)</code>. </p> <p>The optional third input <var class="var">scale</var> determines whether to apply scaling as described above. It is false by default. </p> <p>The result <var class="var">a</var> is the same size as <var class="var">z</var>. </p> <p>The optional output <var class="var">ierr</var> contains the following status information and is the same size as the result. </p> <ol class="enumerate" start="0"> <li> Normal return. </li>
<li> Input error, return <code class="code">NaN</code>. </li>
<li> Overflow, return <code class="code">Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Loss of significance by argument reduction, output may be inaccurate. </li>
<li> Error—no computation, algorithm termination condition not met, return <code class="code">NaN</code>. </li>
</ol> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-besselj">
<span class="category-def">: </span><span><code class="def-type"><var class="var">J</var> =</code> <strong class="def-name">besselj</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-besselj"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-besselj-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">J</var> =</code> <strong class="def-name">besselj</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-besselj-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-besselj-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">J</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">besselj</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-besselj-2"> ¶</a></span>
</dt> <dd>
<p>Compute Bessel functions of the first kind. </p> <p>The order of the Bessel function <var class="var">alpha</var> must be real. The points for evaluation <var class="var">x</var> may be complex. </p> <p>If the optional argument <var class="var">opt</var> is 1 or true, the result <var class="var">J</var> is multiplied by <code class="code">exp (-abs (imag (<var class="var">x</var>)))</code>. </p> <p>If <var class="var">alpha</var> is a scalar, the result is the same size as <var class="var">x</var>. If <var class="var">x</var> is a scalar, the result is the same size as <var class="var">alpha</var>. If <var class="var">alpha</var> is a row vector and <var class="var">x</var> is a column vector, the result is a matrix with <code class="code">length (<var class="var">x</var>)</code> rows and <code class="code">length (<var class="var">alpha</var>)</code> columns. Otherwise, <var class="var">alpha</var> and <var class="var">x</var> must conform and the result will be the same size. </p> <p>If requested, <var class="var">ierr</var> contains the following status information and is the same size as the result. </p> <ol class="enumerate" start="0"> <li> Normal return. </li>
<li> Input error, return <code class="code">NaN</code>. </li>
<li> Overflow, return <code class="code">Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Loss of significance by argument reduction, output may be inaccurate. </li>
<li> Error—no computation, algorithm termination condition not met, return <code class="code">NaN</code>. </li>
</ol> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbessely">bessely</a>, <a class="ref" href="#XREFbesseli">besseli</a>, <a class="ref" href="#XREFbesselk">besselk</a>, <a class="ref" href="#XREFbesselh">besselh</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-bessely">
<span class="category-def">: </span><span><code class="def-type"><var class="var">Y</var> =</code> <strong class="def-name">bessely</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-bessely"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bessely-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">Y</var> =</code> <strong class="def-name">bessely</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-bessely-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bessely-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Y</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">bessely</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-bessely-2"> ¶</a></span>
</dt> <dd>
<p>Compute Bessel functions of the second kind. </p> <p>The order of the Bessel function <var class="var">alpha</var> must be real. The points for evaluation <var class="var">x</var> may be complex. </p> <p>If the optional argument <var class="var">opt</var> is 1 or true, the result <var class="var">Y</var> is multiplied by <code class="code">exp (-abs (imag (<var class="var">x</var>)))</code>. </p> <p>If <var class="var">alpha</var> is a scalar, the result is the same size as <var class="var">x</var>. If <var class="var">x</var> is a scalar, the result is the same size as <var class="var">alpha</var>. If <var class="var">alpha</var> is a row vector and <var class="var">x</var> is a column vector, the result is a matrix with <code class="code">length (<var class="var">x</var>)</code> rows and <code class="code">length (<var class="var">alpha</var>)</code> columns. Otherwise, <var class="var">alpha</var> and <var class="var">x</var> must conform and the result will be the same size. </p> <p>If requested, <var class="var">ierr</var> contains the following status information and is the same size as the result. </p> <ol class="enumerate" start="0"> <li> Normal return. </li>
<li> Input error, return <code class="code">NaN</code>. </li>
<li> Overflow, return <code class="code">Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Complete loss of significance by argument reduction, return <code class="code">NaN</code>. </li>
<li> Error—no computation, algorithm termination condition not met, return <code class="code">NaN</code>. </li>
</ol> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbesselj">besselj</a>, <a class="ref" href="#XREFbesseli">besseli</a>, <a class="ref" href="#XREFbesselk">besselk</a>, <a class="ref" href="#XREFbesselh">besselh</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-besseli">
<span class="category-def">: </span><span><code class="def-type"><var class="var">I</var> =</code> <strong class="def-name">besseli</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-besseli"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-besseli-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">I</var> =</code> <strong class="def-name">besseli</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-besseli-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-besseli-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">I</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">besseli</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-besseli-2"> ¶</a></span>
</dt> <dd>
<p>Compute modified Bessel functions of the first kind. </p> <p>The order of the Bessel function <var class="var">alpha</var> must be real. The points for evaluation <var class="var">x</var> may be complex. </p> <p>If the optional argument <var class="var">opt</var> is 1 or true, the result <var class="var">I</var> is multiplied by <code class="code">exp (-abs (real (<var class="var">x</var>)))</code>. </p> <p>If <var class="var">alpha</var> is a scalar, the result is the same size as <var class="var">x</var>. If <var class="var">x</var> is a scalar, the result is the same size as <var class="var">alpha</var>. If <var class="var">alpha</var> is a row vector and <var class="var">x</var> is a column vector, the result is a matrix with <code class="code">length (<var class="var">x</var>)</code> rows and <code class="code">length (<var class="var">alpha</var>)</code> columns. Otherwise, <var class="var">alpha</var> and <var class="var">x</var> must conform and the result will be the same size. </p> <p>If requested, <var class="var">ierr</var> contains the following status information and is the same size as the result. </p> <ol class="enumerate" start="0"> <li> Normal return. </li>
<li> Input error, return <code class="code">NaN</code>. </li>
<li> Overflow, return <code class="code">Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Complete loss of significance by argument reduction, return <code class="code">NaN</code>. </li>
<li> Error—no computation, algorithm termination condition not met, return <code class="code">NaN</code>. </li>
</ol> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbesselk">besselk</a>, <a class="ref" href="#XREFbesselj">besselj</a>, <a class="ref" href="#XREFbessely">bessely</a>, <a class="ref" href="#XREFbesselh">besselh</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-besselk">
<span class="category-def">: </span><span><code class="def-type"><var class="var">K</var> =</code> <strong class="def-name">besselk</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-besselk"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-besselk-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">K</var> =</code> <strong class="def-name">besselk</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-besselk-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-besselk-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">K</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">besselk</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-besselk-2"> ¶</a></span>
</dt> <dd> <p>Compute modified Bessel functions of the second kind. </p> <p>The order of the Bessel function <var class="var">alpha</var> must be real. The points for evaluation <var class="var">x</var> may be complex. </p> <p>If the optional argument <var class="var">opt</var> is 1 or true, the result <var class="var">K</var> is multiplied by <code class="code">exp (<var class="var">x</var>)</code>. </p> <p>If <var class="var">alpha</var> is a scalar, the result is the same size as <var class="var">x</var>. If <var class="var">x</var> is a scalar, the result is the same size as <var class="var">alpha</var>. If <var class="var">alpha</var> is a row vector and <var class="var">x</var> is a column vector, the result is a matrix with <code class="code">length (<var class="var">x</var>)</code> rows and <code class="code">length (<var class="var">alpha</var>)</code> columns. Otherwise, <var class="var">alpha</var> and <var class="var">x</var> must conform and the result will be the same size. </p> <p>If requested, <var class="var">ierr</var> contains the following status information and is the same size as the result. </p> <ol class="enumerate" start="0"> <li> Normal return. </li>
<li> Input error, return <code class="code">NaN</code>. </li>
<li> Overflow, return <code class="code">Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Complete loss of significance by argument reduction, return <code class="code">NaN</code>. </li>
<li> Error—no computation, algorithm termination condition not met, return <code class="code">NaN</code>. </li>
</ol> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbesseli">besseli</a>, <a class="ref" href="#XREFbesselj">besselj</a>, <a class="ref" href="#XREFbessely">bessely</a>, <a class="ref" href="#XREFbesselh">besselh</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-besselh">
<span class="category-def">: </span><span><code class="def-type"><var class="var">H</var> =</code> <strong class="def-name">besselh</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-besselh"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-besselh-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">H</var> =</code> <strong class="def-name">besselh</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">k</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-besselh-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-besselh-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">H</var> =</code> <strong class="def-name">besselh</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">k</var>, <var class="var">x</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-besselh-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-besselh-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">H</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">besselh</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-besselh-3"> ¶</a></span>
</dt> <dd>
<p>Compute Bessel functions of the third kind (Hankel functions). </p> <p>The order of the Bessel function <var class="var">alpha</var> must be real. The kind of Hankel function is specified by <var class="var">k</var> and may be either first (<var class="var">k</var> = 1) or second (<var class="var">k</var> = 2). The default is Hankel functions of the first kind. The points for evaluation <var class="var">x</var> may be complex. </p> <p>If the optional argument <var class="var">opt</var> is 1 or true, the result is multiplied by <code class="code">exp (-I*<var class="var">x</var>)</code> for <var class="var">k</var> = 1 or <code class="code">exp (I*<var class="var">x</var>)</code> for <var class="var">k</var> = 2. </p> <p>If <var class="var">alpha</var> is a scalar, the result is the same size as <var class="var">x</var>. If <var class="var">x</var> is a scalar, the result is the same size as <var class="var">alpha</var>. If <var class="var">alpha</var> is a row vector and <var class="var">x</var> is a column vector, the result is a matrix with <code class="code">length (<var class="var">x</var>)</code> rows and <code class="code">length (<var class="var">alpha</var>)</code> columns. Otherwise, <var class="var">alpha</var> and <var class="var">x</var> must conform and the result will be the same size. </p> <p>If requested, <var class="var">ierr</var> contains the following status information and is the same size as the result. </p> <ol class="enumerate" start="0"> <li> Normal return. </li>
<li> Input error, return <code class="code">NaN</code>. </li>
<li> Overflow, return <code class="code">Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Complete loss of significance by argument reduction, return <code class="code">NaN</code>. </li>
<li> Error—no computation, algorithm termination condition not met, return <code class="code">NaN</code>. </li>
</ol> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbesselj">besselj</a>, <a class="ref" href="#XREFbessely">bessely</a>, <a class="ref" href="#XREFbesseli">besseli</a>, <a class="ref" href="#XREFbesselk">besselk</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-beta">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">beta</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-beta"> ¶</a></span>
</dt> <dd>
<p>Compute the Beta function for real inputs <var class="var">a</var> and <var class="var">b</var>. </p> <p>The Beta function definition is </p> <pre class="example" data-language="matlab">beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).</pre> <p>The Beta function can grow quite large and it is often more useful to work with the logarithm of the output rather than the function directly. See <a class="xref" href="#XREFbetaln"><code class="code">betaln</code></a>, for computing the logarithm of the Beta function in an efficient manner. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbetaln">betaln</a>, <a class="ref" href="#XREFbetainc">betainc</a>, <a class="ref" href="#XREFbetaincinv">betaincinv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-betainc">
<span class="category-def">: </span><span><code class="def-type"><var class="var">I</var> =</code> <strong class="def-name">betainc</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-betainc"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-betainc-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">I</var> =</code> <strong class="def-name">betainc</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tail</var>)</code><a class="copiable-link" href="#index-betainc-1"> ¶</a></span>
</dt> <dd>
<p>Compute the incomplete beta function. </p> <p>This is defined as </p> <pre class="example" data-language="matlab">x
                         /
                 1       |
I_x (a, b) = ----------  | t^(a-1) (1-t)^(b-1) dt
             beta (a,b)  |
                         /
                        0</pre> <p>with real <var class="var">x</var> in the range [0,1]. The inputs <var class="var">a</var> and <var class="var">b</var> must be real and strictly positive (&gt; 0). If one of the inputs is not a scalar then the other inputs must be scalar or of compatible dimensions. </p> <p>By default, <var class="var">tail</var> is <code class="code">"lower"</code> and the incomplete beta function integrated from 0 to <var class="var">x</var> is computed. If <var class="var">tail</var> is <code class="code">"upper"</code> then the complementary function integrated from <var class="var">x</var> to 1 is calculated. The two choices are related by </p> <p>betainc (<var class="var">x</var>, <var class="var">a</var>, <var class="var">b</var>, <code class="code">"upper"</code>) = 1 - betainc (<var class="var">x</var>, <var class="var">a</var>, <var class="var">b</var>, <code class="code">"lower"</code>). </p> <p><code class="code">betainc</code> uses a more sophisticated algorithm than subtraction to get numerically accurate results when the <code class="code">"lower"</code> value is small. </p> <p>Reference: A. Cuyt, V. Brevik Petersen, B. Verdonk, H. Waadeland, W.B. Jones, <cite class="cite">Handbook of Continued Fractions for Special Functions</cite>, ch. 18. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbeta">beta</a>, <a class="ref" href="#XREFbetaincinv">betaincinv</a>, <a class="ref" href="#XREFbetaln">betaln</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-betaincinv">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">betaincinv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-betaincinv"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-betaincinv-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">betaincinv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>, <var class="var">b</var>, "lower")</code><a class="copiable-link" href="#index-betaincinv-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-betaincinv-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">betaincinv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>, <var class="var">b</var>, "upper")</code><a class="copiable-link" href="#index-betaincinv-2"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse of the normalized incomplete beta function. </p> <p>The normalized incomplete beta function is defined as </p> <pre class="example" data-language="matlab">x
                         /
                 1       |
I_x (a, b) = ----------  | t^(a-1) (1-t)^(b-1) dt
             beta (a,b)  |
                         /
                        0</pre> <p>If two inputs are scalar, then <code class="code">betaincinv (<var class="var">y</var>, <var class="var">a</var>, <var class="var">b</var>)</code> is returned for each of the other inputs. </p> <p>If two or more inputs are not scalar, the sizes of them must agree, and <code class="code">betaincinv</code> is applied element-by-element. </p> <p>The variable <var class="var">y</var> must be in the interval [0,1], while <var class="var">a</var> and <var class="var">b</var> must be real and strictly positive. </p> <p>By default, <var class="var">tail</var> is <code class="code">"lower"</code> and the inverse of the incomplete beta function integrated from 0 to <var class="var">x</var> is computed. If <var class="var">tail</var> is <code class="code">"upper"</code> then the complementary function integrated from <var class="var">x</var> to 1 is inverted. </p> <p>The function is computed by standard Newton’s method, by solving </p> <pre class="example" data-language="matlab">y - betainc (x, a, b) = 0</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbetainc">betainc</a>, <a class="ref" href="#XREFbeta">beta</a>, <a class="ref" href="#XREFbetaln">betaln</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-betaln">
<span class="category-def">: </span><span><code class="def-type"><var class="var">lnb</var> =</code> <strong class="def-name">betaln</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-betaln"> ¶</a></span>
</dt> <dd>
<p>Compute the natural logarithm of the Beta function for real inputs <var class="var">a</var> and <var class="var">b</var>. </p> <p><code class="code">betaln</code> is defined as </p> <pre class="example" data-language="matlab">betaln (a, b) = log (beta (a, b))</pre> <p>and is calculated in a way to reduce the occurrence of underflow. </p> <p>The Beta function can grow quite large and it is often more useful to work with the logarithm of the output rather than the function directly. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbeta">beta</a>, <a class="ref" href="#XREFbetainc">betainc</a>, <a class="ref" href="#XREFbetaincinv">betaincinv</a>, <a class="ref" href="#XREFgammaln">gammaln</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-bincoeff">
<span class="category-def">: </span><span><code class="def-type"><var class="var">b</var> =</code> <strong class="def-name">bincoeff</strong> <code class="def-code-arguments">(<var class="var">n</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-bincoeff"> ¶</a></span>
</dt> <dd>
<p>Return the binomial coefficient of <var class="var">n</var> and <var class="var">k</var>. </p> <p>The binomial coefficient is defined as </p> <pre class="example" data-language="matlab">/   \
 | n |    n (n-1) (n-2) ... (n-k+1)
 |   |  = -------------------------
 | k |               k!
 \   /</pre> <p>For example: </p> <pre class="example" data-language="matlab">bincoeff (5, 2)
   ⇒ 10</pre> <p>In most cases, the <code class="code">nchoosek</code> function is faster for small scalar integer arguments. It also warns about loss of precision for big arguments. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="basic-statistical-functions.html#XREFnchoosek">nchoosek</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-commutation_005fmatrix">
<span class="category-def">: </span><span><code class="def-type"><var class="var">k</var> =</code> <strong class="def-name">commutation_matrix</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-commutation_005fmatrix"> ¶</a></span>
</dt> <dd>
<p>Return the commutation matrix K(m,n) which is the unique <var class="var">m</var>*<var class="var">n</var> by <var class="var">m</var>*<var class="var">n</var> matrix such that <em class="math">K(m,n) * vec(A) = vec(A')</em> for all <em class="math">m</em> by <em class="math">n</em> matrices <em class="math">A</em>. </p> <p>If only one argument <var class="var">m</var> is given, <em class="math">K(m,m)</em> is returned. </p> <p>See Magnus and Neudecker (1988), <cite class="cite">Matrix Differential Calculus with Applications in Statistics and Econometrics</cite>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-cosint">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">cosint</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-cosint"> ¶</a></span>
</dt> <dd>
<p>Compute the cosine integral function: </p> <pre class="example" data-language="matlab">+oo
           /
Ci (x) = - | (cos (t)) / t dt
           /
          x</pre> <p>An equivalent definition is </p> <pre class="example" data-language="matlab">x
                            /
                            |  cos (t) - 1
Ci (x) = gamma + log (x) +  | -------------  dt
                            |        t
                            /
                           0</pre> <p>Reference: </p> <p>M. Abramowitz and I.A. Stegun, <cite class="cite">Handbook of Mathematical Functions</cite>, 1964. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsinint">sinint</a>, <a class="ref" href="#XREFexpint">expint</a>, <a class="ref" href="trigonometry.html#XREFcos">cos</a>. </p> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-duplication_005fmatrix">
<span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">duplication_matrix</strong> <code class="def-code-arguments">(<var class="var">n</var>)</code><a class="copiable-link" href="#index-duplication_005fmatrix"> ¶</a></span>
</dt> <dd>
<p>Return the duplication matrix <em class="math">Dn</em> which is the unique <em class="math">N^2</em>-by-<em class="math">N*(N+1)/2</em> matrix such that <code class="code">Dn * vech (A) = vec (A)</code> for all symmetric <em class="math">N</em>-by-<em class="math">N</em> matrices <em class="math">A</em>. </p> <p>See Magnus and Neudecker (1988), <cite class="cite">Matrix Differential Calculus with Applications in Statistics and Econometrics</cite>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-dawson">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">dawson</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-dawson"> ¶</a></span>
</dt> <dd>
<p>Compute the Dawson (scaled imaginary error) function. </p> <p>The Dawson function is defined as </p> <pre class="example" data-language="matlab">(sqrt (pi) / 2) * exp (-z^2) * erfi (z)</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFerfinv">erfinv</a>, <a class="ref" href="#XREFerfcinv">erfcinv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ellipj">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">sn</var>, <var class="var">cn</var>, <var class="var">dn</var>, <var class="var">err</var>] =</code> <strong class="def-name">ellipj</strong> <code class="def-code-arguments">(<var class="var">u</var>, <var class="var">m</var>)</code><a class="copiable-link" href="#index-ellipj"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ellipj-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">sn</var>, <var class="var">cn</var>, <var class="var">dn</var>, <var class="var">err</var>] =</code> <strong class="def-name">ellipj</strong> <code class="def-code-arguments">(<var class="var">u</var>, <var class="var">m</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-ellipj-1"> ¶</a></span>
</dt> <dd>
<p>Compute the Jacobi elliptic functions <var class="var">sn</var>, <var class="var">cn</var>, and <var class="var">dn</var> of complex argument <var class="var">u</var> and real parameter <var class="var">m</var>. </p> <p>If <var class="var">m</var> is a scalar, the results are the same size as <var class="var">u</var>. If <var class="var">u</var> is a scalar, the results are the same size as <var class="var">m</var>. If <var class="var">u</var> is a column vector and <var class="var">m</var> is a row vector, the results are matrices with <code class="code">length (<var class="var">u</var>)</code> rows and <code class="code">length (<var class="var">m</var>)</code> columns. Otherwise, <var class="var">u</var> and <var class="var">m</var> must conform in size and the results will be the same size as the inputs. </p> <p>The value of <var class="var">u</var> may be complex. The value of <var class="var">m</var> must be 0 ≤ <var class="var">m</var> ≤ 1. </p> <p>The optional input <var class="var">tol</var> is currently ignored (<small class="sc">MATLAB</small> uses this to allow faster, less accurate approximation). </p> <p>If requested, <var class="var">err</var> contains the following status information and is the same size as the result. </p> <ol class="enumerate" start="0"> <li> Normal return. </li>
<li> Error—no computation, algorithm termination condition not met, return <code class="code">NaN</code>. </li>
</ol> <p>Reference: Milton Abramowitz and Irene A Stegun, <cite class="cite">Handbook of Mathematical Functions</cite>, Chapter 16 (Sections 16.4, 16.13, and 16.15), Dover, 1965. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFellipke">ellipke</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ellipke">
<span class="category-def">: </span><span><code class="def-type"><var class="var">k</var> =</code> <strong class="def-name">ellipke</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-ellipke"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ellipke-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">k</var> =</code> <strong class="def-name">ellipke</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-ellipke-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ellipke-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">k</var>, <var class="var">e</var>] =</code> <strong class="def-name">ellipke</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-ellipke-2"> ¶</a></span>
</dt> <dd>
<p>Compute complete elliptic integrals of the first K(<var class="var">m</var>) and second E(<var class="var">m</var>) kind. </p> <p><var class="var">m</var> must be a scalar or real array with -Inf ≤ <var class="var">m</var> ≤ 1. </p> <p>The optional input <var class="var">tol</var> controls the stopping tolerance of the algorithm and defaults to <code class="code">eps (class (<var class="var">m</var>))</code>. The tolerance can be increased to compute a faster, less accurate approximation. </p> <p>When called with one output only elliptic integrals of the first kind are returned. </p> <p>Mathematical Note: </p> <p>Elliptic integrals of the first kind are defined as </p> <pre class="example" data-language="matlab">1
        /               dt
K (m) = | ------------------------------
        / sqrt ((1 - t^2)*(1 - m*t^2))
       0</pre> <p>Elliptic integrals of the second kind are defined as </p> <pre class="example" data-language="matlab">1
        /  sqrt (1 - m*t^2)
E (m) = |  ------------------ dt
        /  sqrt (1 - t^2)
       0</pre> <p>Reference: Milton Abramowitz and Irene A. Stegun, <cite class="cite">Handbook of Mathematical Functions</cite>, Chapter 17, Dover, 1965. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFellipj">ellipj</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-erf">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">erf</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-erf"> ¶</a></span>
</dt> <dd>
<p>Compute the error function. </p> <p>The error function is defined as </p> <pre class="example" data-language="matlab">z
              2        /
erf (z) = --------- *  | e^(-t^2) dt
          sqrt (pi)    /
                    t=0</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerfinv">erfinv</a>, <a class="ref" href="#XREFerfcinv">erfcinv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-erfc">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">erfc</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-erfc"> ¶</a></span>
</dt> <dd>
<p>Compute the complementary error function. </p> <p>The complementary error function is defined as <code class="code">1 - erf (<var class="var">z</var>)</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfcinv">erfcinv</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfinv">erfinv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-erfcx">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">erfcx</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-erfcx"> ¶</a></span>
</dt> <dd>
<p>Compute the scaled complementary error function. </p> <p>The scaled complementary error function is defined as </p> <pre class="example" data-language="matlab">exp (z^2) * erfc (z)</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerfinv">erfinv</a>, <a class="ref" href="#XREFerfcinv">erfcinv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-erfi">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">erfi</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-erfi"> ¶</a></span>
</dt> <dd>
<p>Compute the imaginary error function. </p> <p>The imaginary error function is defined as </p> <pre class="example" data-language="matlab">-i * erf (i*z)</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerfinv">erfinv</a>, <a class="ref" href="#XREFerfcinv">erfcinv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-erfinv">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">erfinv</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-erfinv"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse error function. </p> <p>The inverse error function is defined such that </p> <pre class="example" data-language="matlab">erf (y) == x</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerfcinv">erfcinv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-erfcinv">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">erfcinv</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-erfcinv"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse complementary error function. </p> <p>The inverse complementary error function is defined such that </p> <pre class="example" data-language="matlab">erfc (y) == x</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerfinv">erfinv</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-expint">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">expint</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-expint"> ¶</a></span>
</dt> <dd>
<p>Compute the exponential integral. </p> <p>The exponential integral is defined as: </p> <pre class="example" data-language="matlab">+oo
          /
          | exp (-t)
E_1 (x) = | -------- dt
          |    t
          /
         x</pre> <p>Note: For compatibility, this function uses the <small class="sc">MATLAB</small> definition of the exponential integral. Most other sources refer to this particular value as <em class="math">E_1 (x)</em>, and the exponential integral as </p> <pre class="example" data-language="matlab">+oo
           /
           | exp (-t)
Ei (x) = - | -------- dt
           |    t
           /
         -x</pre> <p>The two definitions are related, for positive real values of <var class="var">x</var>, by <code class="code">E_1 (-x) = -Ei (x) - i*pi</code>. </p> <p>References: </p> <p>M. Abramowitz and I.A. Stegun, <cite class="cite">Handbook of Mathematical Functions</cite>, 1964. </p> <p>N. Bleistein and R.A. Handelsman, <cite class="cite">Asymptotic expansions of integrals</cite>, 1986. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcosint">cosint</a>, <a class="ref" href="#XREFsinint">sinint</a>, <a class="ref" href="exponents-and-logarithms.html#XREFexp">exp</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-gamma">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">gamma</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-gamma"> ¶</a></span>
</dt> <dd>
<p>Compute the Gamma function. </p> <p>The Gamma function is defined as </p> <pre class="example" data-language="matlab">infinity
            /
gamma (z) = | t^(z-1) exp (-t) dt.
            /
         t=0</pre> <p>Programming Note: The gamma function can grow quite large even for small input values. In many cases it may be preferable to use the natural logarithm of the gamma function (<code class="code">gammaln</code>) in calculations to minimize loss of precision. The final result is then <code class="code">exp (<var class="var">result_using_gammaln</var>).</code> </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgammainc">gammainc</a>, <a class="ref" href="#XREFgammaln">gammaln</a>, <a class="ref" href="utility-functions.html#XREFfactorial">factorial</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-gammainc">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">gammainc</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">a</var>)</code><a class="copiable-link" href="#index-gammainc"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-gammainc-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">gammainc</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">a</var>, <var class="var">tail</var>)</code><a class="copiable-link" href="#index-gammainc-1"> ¶</a></span>
</dt> <dd>
<p>Compute the normalized incomplete gamma function. </p> <p>This is defined as </p> <pre class="example" data-language="matlab">x
                       1       /
gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                  gamma (a)    /
                            t=0</pre> <p>with the limiting value of 1 as <var class="var">x</var> approaches infinity. The standard notation is <em class="math">P(a,x)</em>, e.g., Abramowitz and Stegun (6.5.1). </p> <p>If <var class="var">a</var> is scalar, then <code class="code">gammainc (<var class="var">x</var>, <var class="var">a</var>)</code> is returned for each element of <var class="var">x</var> and vice versa. </p> <p>If neither <var class="var">x</var> nor <var class="var">a</var> is scalar then the sizes of <var class="var">x</var> and <var class="var">a</var> must agree, and <code class="code">gammainc</code> is applied element-by-element. The elements of <var class="var">a</var> must be non-negative. </p> <p>By default, <var class="var">tail</var> is <code class="code">"lower"</code> and the incomplete gamma function integrated from 0 to <var class="var">x</var> is computed. If <var class="var">tail</var> is <code class="code">"upper"</code> then the complementary function integrated from <var class="var">x</var> to infinity is calculated. </p> <p>If <var class="var">tail</var> is <code class="code">"scaledlower"</code>, then the lower incomplete gamma function is multiplied by <em class="math">gamma(a+1)*exp(x)/(x^a)</em>. If <var class="var">tail</var> is <code class="code">"scaledupper"</code>, then the upper incomplete gamma function is multiplied by the same quantity. </p> <p>References: </p> <p>M. Abramowitz and I.A. Stegun, <cite class="cite">Handbook of mathematical functions</cite>, Dover publications, Inc., 1972. </p> <p>W. Gautschi, <cite class="cite">A computational procedure for incomplete gamma functions</cite>, ACM Trans. Math Software, pp. 466–481, Vol 5, No. 4, 2012. </p> <p>W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery, <cite class="cite">Numerical Recipes in Fortran 77</cite>, ch. 6.2, Vol 1, 1992. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgamma">gamma</a>, <a class="ref" href="#XREFgammaincinv">gammaincinv</a>, <a class="ref" href="#XREFgammaln">gammaln</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-gammaincinv">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">gammaincinv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>)</code><a class="copiable-link" href="#index-gammaincinv"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-gammaincinv-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">gammaincinv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>, <var class="var">tail</var>)</code><a class="copiable-link" href="#index-gammaincinv-1"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse of the normalized incomplete gamma function. </p> <p>The normalized incomplete gamma function is defined as </p> <pre class="example" data-language="matlab">x
                       1       /
gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                  gamma (a)    /
                            t=0</pre> <p>and <code class="code">gammaincinv (gammainc (<var class="var">x</var>, <var class="var">a</var>), <var class="var">a</var>) = <var class="var">x</var></code> for each non-negative value of <var class="var">x</var>. If <var class="var">a</var> is scalar then <code class="code">gammaincinv (<var class="var">y</var>, <var class="var">a</var>)</code> is returned for each element of <var class="var">y</var> and vice versa. </p> <p>If neither <var class="var">y</var> nor <var class="var">a</var> is scalar then the sizes of <var class="var">y</var> and <var class="var">a</var> must agree, and <code class="code">gammaincinv</code> is applied element-by-element. The variable <var class="var">y</var> must be in the interval <em class="math">[0,1]</em> while <var class="var">a</var> must be real and positive. </p> <p>By default, <var class="var">tail</var> is <code class="code">"lower"</code> and the inverse of the incomplete gamma function integrated from 0 to <var class="var">x</var> is computed. If <var class="var">tail</var> is <code class="code">"upper"</code>, then the complementary function integrated from <var class="var">x</var> to infinity is inverted. </p> <p>The function is computed with Newton’s method by solving </p> <pre class="example" data-language="matlab">y - gammainc (x, a) = 0</pre> <p>Reference: A. Gil, J. Segura, and N. M. Temme, <cite class="cite">Efficient and accurate algorithms for the computation and inversion of the incomplete gamma function ratios</cite>, SIAM J. Sci. Computing, pp. A2965–A2981, Vol 34, 2012. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgammainc">gammainc</a>, <a class="ref" href="#XREFgamma">gamma</a>, <a class="ref" href="#XREFgammaln">gammaln</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-legendre">
<span class="category-def">: </span><span><code class="def-type"><var class="var">l</var> =</code> <strong class="def-name">legendre</strong> <code class="def-code-arguments">(<var class="var">n</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-legendre"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-legendre-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">l</var> =</code> <strong class="def-name">legendre</strong> <code class="def-code-arguments">(<var class="var">n</var>, <var class="var">x</var>, <var class="var">normalization</var>)</code><a class="copiable-link" href="#index-legendre-1"> ¶</a></span>
</dt> <dd>
<p>Compute the associated Legendre function of degree <var class="var">n</var> and order <var class="var">m</var> = 0 … <var class="var">n</var>. </p> <p>The value <var class="var">n</var> must be a real non-negative integer. </p> <p><var class="var">x</var> is a vector with real-valued elements in the range [-1, 1]. </p> <p>The optional argument <var class="var">normalization</var> may be one of <code class="code">"unnorm"</code>, <code class="code">"sch"</code>, or <code class="code">"norm"</code>. The default if no normalization is given is <code class="code">"unnorm"</code>. </p> <p>When the optional argument <var class="var">normalization</var> is <code class="code">"unnorm"</code>, compute the associated Legendre function of degree <var class="var">n</var> and order <var class="var">m</var> and return all values for <var class="var">m</var> = 0 … <var class="var">n</var>. The return value has one dimension more than <var class="var">x</var>. </p> <p>The associated Legendre function of degree <var class="var">n</var> and order <var class="var">m</var>: </p> <pre class="example" data-language="matlab">m         m      2  m/2   d^m
P(x) = (-1) * (1-x  )    * ----  P(x)
 n                         dx^m   n</pre> <p>with Legendre polynomial of degree <var class="var">n</var>: </p> <pre class="example" data-language="matlab">1    d^n   2    n
P(x) = ------ [----(x - 1) ]
 n     2^n n!  dx^n</pre> <p><code class="code">legendre (3, [-1.0, -0.9, -0.8])</code> returns the matrix: </p> <pre class="example" data-language="matlab">x  |   -1.0   |   -0.9   |   -0.8
------------------------------------
m=0 | -1.00000 | -0.47250 | -0.08000
m=1 |  0.00000 | -1.99420 | -1.98000
m=2 |  0.00000 | -2.56500 | -4.32000
m=3 |  0.00000 | -1.24229 | -3.24000</pre> <p>When the optional argument <var class="var">normalization</var> is <code class="code">"sch"</code>, compute the Schmidt semi-normalized associated Legendre function. The Schmidt semi-normalized associated Legendre function is related to the unnormalized Legendre functions by the following: </p> <p>For Legendre functions of degree <var class="var">n</var> and order 0: </p> <pre class="example" data-language="matlab">0      0
SP(x) = P(x)
  n      n</pre> <p>For Legendre functions of degree n and order m: </p> <pre class="example" data-language="matlab">m      m         m    2(n-m)! 0.5
SP(x) = P(x) * (-1)  * [-------]
  n      n              (n+m)!</pre> <p>When the optional argument <var class="var">normalization</var> is <code class="code">"norm"</code>, compute the fully normalized associated Legendre function. The fully normalized associated Legendre function is related to the unnormalized associated Legendre functions by the following: </p> <p>For Legendre functions of degree <var class="var">n</var> and order <var class="var">m</var> </p> <pre class="example" data-language="matlab">m      m         m    (n+0.5)(n-m)! 0.5
NP(x) = P(x) * (-1)  * [-------------]
  n      n                  (n+m)!</pre> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-gammaln">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">gammaln</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-gammaln"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lgamma">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">lgamma</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-lgamma"> ¶</a></span>
</dt> <dd>
<p>Return the natural logarithm of the gamma function of <var class="var">x</var>. </p> <p>Programming Note: <code class="code">lgamma</code> is an alias for <code class="code">gammaln</code> and either name can be used in Octave. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgamma">gamma</a>, <a class="ref" href="#XREFgammainc">gammainc</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-psi">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">psi</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-psi"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-psi-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">psi</strong> <code class="def-code-arguments">(<var class="var">k</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-psi-1"> ¶</a></span>
</dt> <dd>
<p>Compute the psi (polygamma) function. </p> <p>The polygamma functions are the <var class="var">k</var>th derivative of the logarithm of the gamma function. If unspecified, <var class="var">k</var> defaults to zero. A value of zero computes the digamma function, a value of 1, the trigamma function, and so on. </p> <p>The digamma function is defined: </p> <pre class="example" data-language="matlab">psi (z) = d (log (gamma (z))) / dx</pre> <p>When computing the digamma function (when <var class="var">k</var> equals zero), <var class="var">z</var> can have any value real or complex value. However, for polygamma functions (<var class="var">k</var> higher than 0), <var class="var">z</var> must be real and non-negative. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgamma">gamma</a>, <a class="ref" href="#XREFgammainc">gammainc</a>, <a class="ref" href="#XREFgammaln">gammaln</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sinint">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">sinint</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-sinint"> ¶</a></span>
</dt> <dd>
<p>Compute the sine integral function: </p> <pre class="example" data-language="matlab">x
          /
Si (x) =  | sin (t) / t dt
          /
         0</pre> <p>Reference: M. Abramowitz and I.A. Stegun, <cite class="cite">Handbook of Mathematical Functions</cite>, 1964. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcosint">cosint</a>, <a class="ref" href="#XREFexpint">expint</a>, <a class="ref" href="trigonometry.html#XREFsin">sin</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="rational-approximations.html">Rational Approximations</a>, Previous: <a href="utility-functions.html">Utility Functions</a>, Up: <a href="arithmetic.html">Arithmetic</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Special-Functions.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Special-Functions.html</a>
  </p>
</div>
