<div class="section" id="Specialized-Solvers">   <h1 class="section">18.5 Specialized Solvers</h1>  <dl class="def"> <dt id="index-bicg">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>bicg</strong> <em>(<var>A</var>, <var>b</var>)</em><a href="#index-bicg" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bicg-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>bicg</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>)</em><a href="#index-bicg-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bicg-2">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>bicg</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>)</em><a href="#index-bicg-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bicg-3">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>bicg</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M</var>)</em><a href="#index-bicg-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bicg-4">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>bicg</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M1</var>, <var>M2</var>)</em><a href="#index-bicg-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bicg-5">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>bicg</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M</var>, [], <var>x0</var>)</em><a href="#index-bicg-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bicg-6">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>bicg</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M1</var>, <var>M2</var>, <var>x0</var>)</em><a href="#index-bicg-6" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bicg-7">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>bicg</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M</var>, [], <var>x0</var>, …)</em><a href="#index-bicg-7" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bicg-8">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>bicg</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M1</var>, <var>M2</var>, <var>x0</var>, …)</em><a href="#index-bicg-8" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bicg-9">
<span class="category">: </span><span><em>[<var>x</var>, <var>flag</var>, <var>relres</var>, <var>iter</var>, <var>resvec</var>] =</em> <strong>bicg</strong> <em>(<var>A</var>, <var>b</var>, …)</em><a href="#index-bicg-9" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Solve the linear system of equations <code><var>A</var> * <var>x</var> = <var>b</var></code> by means of the Bi-Conjugate Gradient iterative method. </p> <p>The input arguments are: </p> <ul> <li> <var>A</var> is the matrix of the linear system and it must be square. <var>A</var> can be passed as a matrix, function handle, or inline function <code>Afcn</code> such that <code>Afcn (x, "notransp") = A * x</code> and <code>Afcn (x, "transp") = A' * x</code>. Additional parameters to <code>Afcn</code> may be passed after <var>x0</var>. </li>
<li> <var>b</var> is the right-hand side vector. It must be a column vector with the same number of rows as <var>A</var>. </li>
<li> <var>tol</var> is the required relative tolerance for the residual error, <code><var>b</var> <span class="nolinebreak">-</span> <var>A</var> * <var>x</var></code>. The iteration stops if <code>norm (<var>b</var> <span class="nolinebreak">-</span> <var>A</var> * <var>x</var>)</code> ≤ <code><var>tol</var> * norm (<var>b</var>)</code>. If <var>tol</var> is omitted or empty, then a tolerance of 1e-6 is used. </li>
<li> <var>maxit</var> is the maximum allowed number of iterations; if <var>maxit</var> is omitted or empty then a value of 20 is used. </li>
<li> <var>M1</var>, <var>M2</var> are the preconditioners. The preconditioner <var>M</var> is given as <code><var>M</var> = <var>M1</var> * <var>M2</var></code>. Both <var>M1</var> and <var>M2</var> can be passed as a matrix or as a function handle or inline function <code>g</code> such that <code>g (<var>x</var>, "notransp") = <var>M1</var> \ <var>x</var></code> or <code>g (<var>x</var>, "notransp") = <var>M2</var> \ <var>x</var></code> and <code>g (<var>x</var>, "transp") = <var>M1</var>' \ <var>x</var></code> or <code>g (<var>x</var>, "transp") = <var>M2</var>' \ <var>x</var></code>. If <var>M1</var> is omitted or empty, then preconditioning is not applied. The preconditioned system is theoretically equivalent to applying the <code>bicg</code> method to the linear system <code>inv (<var>M1</var>) * A * inv (<var>M2</var>) * <var>y</var> = inv
(<var>M1</var>) * <var>b</var></code> and <code>inv (<var>M2'</var>) * A' * inv (<var>M1'</var>) * <var>z</var> =
inv (<var>M2'</var>) * <var>b</var></code> and then setting <code><var>x</var> = inv (<var>M2</var>) * <var>y</var></code>. </li>
<li> <var>x0</var> is the initial guess. If <var>x0</var> is omitted or empty then the function sets <var>x0</var> to a zero vector by default. </li>
</ul> <p>Any arguments which follow <var>x0</var> are treated as parameters, and passed in an appropriate manner to any of the functions (<var>Afcn</var> or <var>Mfcn</var>) or that have been given to <code>bicg</code>. </p> <p>The output parameters are: </p> <ul> <li> <var>x</var> is the computed approximation to the solution of <code><var>A</var> * <var>x</var> = <var>b</var></code>. If the algorithm did not converge, then <var>x</var> is the iteration which has the minimum residual. </li>
<li> <var>flag</var> indicates the exit status: <ul> <li> 0: The algorithm converged to within the prescribed tolerance. </li>
<li> 1: The algorithm did not converge and it reached the maximum number of iterations. </li>
<li> 2: The preconditioner matrix is singular. </li>
<li> 3: The algorithm stagnated, i.e., the absolute value of the difference between the current iteration <var>x</var> and the previous is less than <code>eps * norm (<var>x</var>,2)</code>. </li>
<li> 4: The algorithm could not continue because intermediate values became too small or too large for reliable computation. </li>
</ul> </li>
<li> <var>relres</var> is the ratio of the final residual to its initial value, measured in the Euclidean norm. </li>
<li> <var>iter</var> is the iteration which <var>x</var> is computed. </li>
<li> <var>resvec</var> is a vector containing the residual at each iteration. The total number of iterations performed is given by <code>length (<var>resvec</var>) - 1</code>. </li>
</ul> <p>Consider a trivial problem with a tridiagonal matrix </p> <pre class="example" data-language="matlab">n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n)) + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
              sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A);  # in this tridiag case, it corresponds to lu (A)
M = M1 * M2;
Afcn = @(x, string) strcmp (string, "notransp") * (A * x) + ...
                     strcmp (string, "transp") * (A' * x);
Mfcn = @(x, string) strcmp (string, "notransp") * (M \ x) + ...
                     strcmp (string, "transp") * (M' \ x);
M1fcn = @(x, string) strcmp (string, "notransp") * (M1 \ x) + ...
                     strcmp (string, "transp") * (M1' \ x);
M2fcn = @(x, string) strcmp (string, "notransp") * (M2 \ x) + ...
                     strcmp (string, "transp") * (M2' \ x);</pre> <p><small>EXAMPLE 1:</small> simplest usage of <code>bicg</code> </p> <pre class="example" data-language="matlab">x = bicg (A, b)</pre> <p><small>EXAMPLE 2:</small> <code>bicg</code> with a function that computes <code><var>A</var>*<var>x</var></code> and <code><var>A'</var>*<var>x</var></code> </p> <pre class="example" data-language="matlab">x = bicg (Afcn, b, [], n)</pre> <p><small>EXAMPLE 3:</small> <code>bicg</code> with a preconditioner matrix <var>M</var> </p> <pre class="example" data-language="matlab">x = bicg (A, b, 1e-6, n, M)</pre> <p><small>EXAMPLE 4:</small> <code>bicg</code> with a function as preconditioner </p> <pre class="example" data-language="matlab">x = bicg (Afcn, b, 1e-6, n, Mfcn)</pre> <p><small>EXAMPLE 5:</small> <code>bicg</code> with preconditioner matrices <var>M1</var> and <var>M2</var> </p> <pre class="example" data-language="matlab">x = bicg (A, b, 1e-6, n, M1, M2)</pre> <p><small>EXAMPLE 6:</small> <code>bicg</code> with functions as preconditioners </p> <pre class="example" data-language="matlab">x = bicg (Afcn, b, 1e-6, n, M1fcn, M2fcn)</pre> <p><small>EXAMPLE 7:</small> <code>bicg</code> with as input a function requiring an argument </p> <pre class="example" data-language="matlab">function y = Ap (A, x, string, z)
  ## compute A^z * x or (A^z)' * x
  y = x;
  if (strcmp (string, "notransp"))
    for i = 1:z
      y = A * y;
    endfor
  elseif (strcmp (string, "transp"))
    for i = 1:z
      y = A' * y;
    endfor
  endif
endfunction

Apfcn = @(x, string, p) Ap (A, x, string, p);
x = bicg (Apfcn, b, [], [], [], [], [], 2);</pre> <p>Reference: </p> <p>Y. Saad, <cite>Iterative Methods for Sparse Linear Systems</cite>, Second edition, 2003, SIAM. </p> <p><strong>See also:</strong> <a href="#XREFbicgstab">bicgstab</a>, <a href="#XREFcgs">cgs</a>, <a href="#XREFgmres">gmres</a>, <a href="iterative-techniques.html#XREFpcg">pcg</a>, <a href="#XREFqmr">qmr</a>, <a href="#XREFtfqmr">tfqmr</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-bicgstab">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>bicgstab</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M1</var>, <var>M2</var>, <var>x0</var>, …)</em><a href="#index-bicgstab" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bicgstab-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>bicgstab</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M</var>, [], <var>x0</var>, …)</em><a href="#index-bicgstab-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bicgstab-2">
<span class="category">: </span><span><em>[<var>x</var>, <var>flag</var>, <var>relres</var>, <var>iter</var>, <var>resvec</var>] =</em> <strong>bicgstab</strong> <em>(<var>A</var>, <var>b</var>, …)</em><a href="#index-bicgstab-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Solve <code>A x = b</code> using the stabilized Bi-conjugate gradient iterative method. </p> <p>The input parameters are: </p> <ul class="no-bullet"> <li>- <var>A</var> is the matrix of the linear system and it must be square. <var>A</var> can be passed as a matrix, function handle, or inline function <code>Afcn</code> such that <code>Afcn(x) = A * x</code>. Additional parameters to <code>Afcn</code> are passed after <var>x0</var>. </li>
<li>- <var>b</var> is the right hand side vector. It must be a column vector with the same number of rows as <var>A</var>. </li>
<li>- <var>tol</var> is the required relative tolerance for the residual error, <code><var>b</var> <span class="nolinebreak">-</span> <var>A</var> * <var>x</var></code>. The iteration stops if <code>norm (<var>b</var> <span class="nolinebreak">-</span> <var>A</var> * <var>x</var>)</code> ≤ <code><var>tol</var> * norm (<var>b</var>)</code>. If <var>tol</var> is omitted or empty, then a tolerance of 1e-6 is used. </li>
<li>- <var>maxit</var> the maximum number of outer iterations, if not given or set to [] the default value <code>min (20, numel (b))</code> is used. </li>
<li>- <var>M1</var>, <var>M2</var> are the preconditioners. The preconditioner <var>M</var> is given as <code><var>M</var> = <var>M1</var> * <var>M2</var></code>. Both <var>M1</var> and <var>M2</var> can be passed as a matrix or as a function handle or inline function <code>g</code> such that <code>g(<var>x</var>) = <var>M1</var> \ <var>x</var></code> or <code>g(<var>x</var>) = <var>M2</var> \ <var>x</var></code>. The technique used is the right preconditioning, i.e., it is solved <code><var>A</var> * inv (<var>M</var>) * <var>y</var> = <var>b</var></code> and then <code><var>x</var> = inv (<var>M</var>) * <var>y</var></code>. </li>
<li>- <var>x0</var> the initial guess, if not given or set to [] the default value <code>zeros (size (<var>b</var>))</code> is used. </li>
</ul> <p>The arguments which follow <var>x0</var> are treated as parameters, and passed in a proper way to any of the functions (<var>A</var> or <var>M</var>) which are passed to <code>bicstab</code>. </p> <p>The output parameters are: </p> <ul class="no-bullet"> <li>- <var>x</var> is the approximation computed. If the method doesn’t converge then it is the iterated with the minimum residual. </li>
<li>- <var>flag</var> indicates the exit status: <ul class="no-bullet"> <li>- 0: iteration converged to the within the chosen tolerance </li>
<li>- 1: the maximum number of iterations was reached before convergence </li>
<li>- 2: the preconditioner matrix is singular </li>
<li>- 3: the algorithm reached stagnation </li>
<li>- 4: the algorithm can’t continue due to a division by zero </li>
</ul> </li>
<li>- <var>relres</var> is the relative residual obtained with as <code>(<var>A</var>*<var>x</var>-<var>b</var>) / <code>norm(<var>b</var>)</code></code>. </li>
<li>- <var>iter</var> is the (possibly half) iteration which <var>x</var> is computed. If it is an half iteration then it is <code><var>iter</var> + 0.5</code> </li>
<li>- <var>resvec</var> is a vector containing the residual of each half and total iteration (There are also the half iterations since <var>x</var> is computed in two steps at each iteration). Doing <code>(length(<var>resvec</var>) - 1) / 2</code> is possible to see the total number of (total) iterations performed. </li>
</ul> <p>Let us consider a trivial problem with a tridiagonal matrix </p> <pre class="example" data-language="matlab">n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case, it corresponds to lu (A)
M = M1 * M2;
Afcn = @(x) A * x;
Mfcn = @(x) M \ x;
M1fcn = @(x) M1 \ x;
M2fcn = @(x) M2 \ x;</pre> <p><small>EXAMPLE 1:</small> simplest usage of <code>bicgstab</code> </p> <pre class="example" data-language="matlab">x = bicgstab (A, b, [], n)</pre> <p><small>EXAMPLE 2:</small> <code>bicgstab</code> with a function which computes <code><var>A</var> * <var>x</var></code> </p> <pre class="example" data-language="matlab">x = bicgstab (Afcn, b, [], n)</pre> <p><small>EXAMPLE 3:</small> <code>bicgstab</code> with a preconditioner matrix <var>M</var> </p> <pre class="example" data-language="matlab">x = bicgstab (A, b, [], 1e-06, n, M)</pre> <p><small>EXAMPLE 4:</small> <code>bicgstab</code> with a function as preconditioner </p> <pre class="example" data-language="matlab">x = bicgstab (Afcn, b, 1e-6, n, Mfcn)</pre> <p><small>EXAMPLE 5:</small> <code>bicgstab</code> with preconditioner matrices <var>M1</var> and <var>M2</var> </p> <pre class="example" data-language="matlab">x = bicgstab (A, b, [], 1e-6, n, M1, M2)</pre> <p><small>EXAMPLE 6:</small> <code>bicgstab</code> with functions as preconditioners </p> <pre class="example" data-language="matlab">x = bicgstab (Afcn, b, 1e-6, n, M1fcn, M2fcn)</pre> <p><small>EXAMPLE 7:</small> <code>bicgstab</code> with as input a function requiring an argument </p> <pre class="example" data-language="matlab">function y = Ap (A, x, z) # compute A^z * x
   y = x;
   for i = 1:z
     y = A * y;
   endfor
 endfunction
Apfcn = @(x, string, p) Ap (A, x, string, p);
x = bicgstab (Apfcn, b, [], [], [], [], [], 2);</pre> <p><small>EXAMPLE 8:</small> explicit example to show that <code>bicgstab</code> uses a right preconditioner </p> <pre class="example" data-language="matlab">[M1, M2] = ilu (A + 0.1 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by bicgstab after one iteration
[x_ref, fl] = bicgstab (A, b, [], 1, M)

## right preconditioning
[y, fl] = bicgstab (A / M, b, [], 1)
x = M \ y # compare x and x_ref</pre> <p>Reference: </p> <p>Y. Saad, <cite>Iterative Methods for Sparse Linear Systems</cite>, Second edition, 2003, SIAM </p> <p><strong>See also:</strong> <a href="#XREFbicg">bicg</a>, <a href="#XREFcgs">cgs</a>, <a href="#XREFgmres">gmres</a>, <a href="iterative-techniques.html#XREFpcg">pcg</a>, <a href="#XREFqmr">qmr</a>, <a href="#XREFtfqmr">tfqmr</a>. </p> </dd>
</dl> <dl class="def"> <dt id="index-cgs">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>cgs</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M1</var>, <var>M2</var>, <var>x0</var>, …)</em><a href="#index-cgs" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-cgs-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>cgs</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M</var>, [], <var>x0</var>, …)</em><a href="#index-cgs-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-cgs-2">
<span class="category">: </span><span><em>[<var>x</var>, <var>flag</var>, <var>relres</var>, <var>iter</var>, <var>resvec</var>] =</em> <strong>cgs</strong> <em>(<var>A</var>, <var>b</var>, …)</em><a href="#index-cgs-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Solve <code>A x = b</code>, where <var>A</var> is a square matrix, using the Conjugate Gradients Squared method. </p> <p>The input arguments are: </p> <ul class="no-bullet"> <li>- <var>A</var> is the matrix of the linear system and it must be square. <var>A</var> can be passed as a matrix, function handle, or inline function <code>Afcn</code> such that <code>Afcn(x) = A * x</code>. Additional parameters to <code>Afcn</code> are passed after <var>x0</var>. </li>
<li>- <var>b</var> is the right hand side vector. It must be a column vector with same number of rows of <var>A</var>. </li>
<li>- <var>tol</var> is the relative tolerance, if not given or set to [] the default value 1e-6 is used. </li>
<li>- <var>maxit</var> the maximum number of outer iterations, if not given or set to [] the default value <code>min (20, numel (b))</code> is used. </li>
<li>- <var>M1</var>, <var>M2</var> are the preconditioners. The preconditioner matrix is given as <code>M = M1 * M2</code>. Both <var>M1</var> and <var>M2</var> can be passed as a matrix or as a function handle or inline function <code>g</code> such that <code>g(x) = M1 \ x</code> or <code>g(x) = M2 \ x</code>. If M1 is empty or not passed then no preconditioners are applied. The technique used is the right preconditioning, i.e., it is solved <code><var>A</var>*inv(<var>M</var>)*y = b</code> and then <code><var>x</var> = inv(<var>M</var>)*y</code>. </li>
<li>- <var>x0</var> the initial guess, if not given or set to [] the default value <code>zeros (size (b))</code> is used. </li>
</ul> <p>The arguments which follow <var>x0</var> are treated as parameters, and passed in a proper way to any of the functions (<var>A</var> or <var>P</var>) which are passed to <code>cgs</code>. </p> <p>The output parameters are: </p> <ul class="no-bullet"> <li>- <var>x</var> is the approximation computed. If the method doesn’t converge then it is the iterated with the minimum residual. </li>
<li>- <var>flag</var> indicates the exit status: <ul class="no-bullet"> <li>- 0: iteration converged to the within the chosen tolerance </li>
<li>- 1: the maximum number of iterations was reached before convergence </li>
<li>- 2: the preconditioner matrix is singular </li>
<li>- 3: the algorithm reached stagnation </li>
<li>- 4: the algorithm can’t continue due to a division by zero </li>
</ul> </li>
<li>- <var>relres</var> is the relative residual obtained with as <code>(<var>A</var>*<var>x</var>-<var>b</var>) / <code>norm(<var>b</var>)</code></code>. </li>
<li>- <var>iter</var> is the iteration which <var>x</var> is computed. </li>
<li>- <var>resvec</var> is a vector containing the residual at each iteration. Doing <code>length(<var>resvec</var>) - 1</code> is possible to see the total number of iterations performed. </li>
</ul> <p>Let us consider a trivial problem with a tridiagonal matrix </p> <pre class="example" data-language="matlab">n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case it corresponds to chol (A)'
M = M1 * M2;
Afcn = @(x) A * x;
Mfcn = @(x) M \ x;
M1fcn = @(x) M1 \ x;
M2fcn = @(x) M2 \ x;</pre> <p><small>EXAMPLE 1:</small> simplest usage of <code>cgs</code> </p> <pre class="example" data-language="matlab">x = cgs (A, b, [], n)</pre> <p><small>EXAMPLE 2:</small> <code>cgs</code> with a function which computes <code><var>A</var> * <var>x</var></code> </p> <pre class="example" data-language="matlab">x = cgs (Afcn, b, [], n)</pre> <p><small>EXAMPLE 3:</small> <code>cgs</code> with a preconditioner matrix <var>M</var> </p> <pre class="example" data-language="matlab">x = cgs (A, b, [], 1e-06, n, M)</pre> <p><small>EXAMPLE 4:</small> <code>cgs</code> with a function as preconditioner </p> <pre class="example" data-language="matlab">x = cgs (Afcn, b, 1e-6, n, Mfcn)</pre> <p><small>EXAMPLE 5:</small> <code>cgs</code> with preconditioner matrices <var>M1</var> and <var>M2</var> </p> <pre class="example" data-language="matlab">x = cgs (A, b, [], 1e-6, n, M1, M2)</pre> <p><small>EXAMPLE 6:</small> <code>cgs</code> with functions as preconditioners </p> <pre class="example" data-language="matlab">x = cgs (Afcn, b, 1e-6, n, M1fcn, M2fcn)</pre> <p><small>EXAMPLE 7:</small> <code>cgs</code> with as input a function requiring an argument </p> <pre class="example" data-language="matlab">function y = Ap (A, x, z) # compute A^z * x
   y = x;
   for i = 1:z
     y = A * y;
   endfor
 endfunction
Apfcn = @(x, string, p) Ap (A, x, string, p);
x = cgs (Apfcn, b, [], [], [], [], [], 2);</pre> <p><small>EXAMPLE 8:</small> explicit example to show that <code>cgs</code> uses a right preconditioner </p> <pre class="example" data-language="matlab">[M1, M2] = ilu (A + 0.3 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by cgs after one iteration
[x_ref, fl] = cgs (A, b, [], 1, M)

## right preconditioning
[y, fl] = cgs (A / M, b, [], 1)
x = M \ y # compare x and x_ref</pre> <p>References: </p> <p>Y. Saad, <cite>Iterative Methods for Sparse Linear Systems</cite>, Second edition, 2003, SIAM </p> <p><strong>See also:</strong> <a href="iterative-techniques.html#XREFpcg">pcg</a>, <a href="#XREFbicgstab">bicgstab</a>, <a href="#XREFbicg">bicg</a>, <a href="#XREFgmres">gmres</a>, <a href="#XREFqmr">qmr</a>, <a href="#XREFtfqmr">tfqmr</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-gmres">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>gmres</strong> <em>(<var>A</var>, <var>b</var>, <var>restart</var>, <var>tol</var>, <var>maxit</var>, <var>M1</var>, <var>M2</var>, <var>x0</var>, …)</em><a href="#index-gmres" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gmres-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>gmres</strong> <em>(<var>A</var>, <var>b</var>, <var>restart</var>, <var>tol</var>, <var>maxit</var>, <var>M</var>, [], <var>x0</var>, …)</em><a href="#index-gmres-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gmres-2">
<span class="category">: </span><span><em>[<var>x</var>, <var>flag</var>, <var>relres</var>, <var>iter</var>, <var>resvec</var>] =</em> <strong>gmres</strong> <em>(<var>A</var>, <var>b</var>, …)</em><a href="#index-gmres-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Solve <code>A x = b</code> using the Preconditioned GMRES iterative method with restart, a.k.a. PGMRES(restart). </p> <p>The input arguments are: </p> <ul class="no-bullet"> <li>- <var>A</var> is the matrix of the linear system and it must be square. <var>A</var> can be passed as a matrix, function handle, or inline function <code>Afcn</code> such that <code>Afcn(x) = A * x</code>. Additional parameters to <code>Afcn</code> are passed after <var>x0</var>. </li>
<li>- <var>b</var> is the right hand side vector. It must be a column vector with the same numbers of rows as <var>A</var>. </li>
<li>- <var>restart</var> is the number of iterations before that the method restarts. If it is [] or N = numel (b), then the restart is not applied. </li>
<li>- <var>tol</var> is the required relative tolerance for the preconditioned residual error, <code>inv (<var>M</var>) * (<var>b</var> - <var>a</var> * <var>x</var>)</code>. The iteration stops if <code>norm (inv (<var>M</var>) * (<var>b</var> - <var>a</var> * <var>x</var>))
≤ <var>tol</var> * norm (inv (<var>M</var>) * <var>B</var>)</code>. If <var>tol</var> is omitted or empty, then a tolerance of 1e-6 is used. </li>
<li>- <var>maxit</var> is the maximum number of outer iterations, if not given or set to [], then the default value <code>min (10, <var>N</var> / <var>restart</var>)</code> is used. Note that, if <var>restart</var> is empty, then <var>maxit</var> is the maximum number of iterations. If <var>restart</var> and <var>maxit</var> are not empty, then the maximum number of iterations is <code><var>restart</var> * <var>maxit</var></code>. If both <var>restart</var> and <var>maxit</var> are empty, then the maximum number of iterations is set to <code>min (10, <var>N</var>)</code>. </li>
<li>- <var>M1</var>, <var>M2</var> are the preconditioners. The preconditioner <var>M</var> is given as <code>M = M1 * M2</code>. Both <var>M1</var> and <var>M2</var> can be passed as a matrix, function handle, or inline function <code>g</code> such that <code>g(x) = M1 \ x</code> or <code>g(x) = M2 \ x</code>. If <var>M1</var> is [] or not given, then the preconditioner is not applied. The technique used is the left-preconditioning, i.e., it is solved <code>inv(<var>M</var>) * <var>A</var> * <var>x</var> = inv(<var>M</var>) * <var>b</var></code> instead of <code><var>A</var> * <var>x</var> = <var>b</var></code>. </li>
<li>- <var>x0</var> is the initial guess, if not given or set to [], then the default value <code>zeros (size (<var>b</var>))</code> is used. </li>
</ul> <p>The arguments which follow <var>x0</var> are treated as parameters, and passed in a proper way to any of the functions (<var>A</var> or <var>M</var> or <var>M1</var> or <var>M2</var>) which are passed to <code>gmres</code>. </p> <p>The outputs are: </p> <ul class="no-bullet"> <li>- <var>x</var> the computed approximation. If the method does not converge, then it is the iterated with minimum residual. </li>
<li>- <var>flag</var> indicates the exit status: <dl compact> <dt><span>0 : iteration converged to within the specified tolerance</span></dt> <dt><span>1 : maximum number of iterations exceeded</span></dt> <dt><span>2 : the preconditioner matrix is singular</span></dt> <dt><span>3 : algorithm reached stagnation (the relative difference between two</span></dt> <dd><p>consecutive iterations is less than eps) </p></dd> </dl> </li>
<li>- <var>relres</var> is the value of the relative preconditioned residual of the approximation <var>x</var>. </li>
<li>- <var>iter</var> is a vector containing the number of outer iterations and inner iterations performed to compute <var>x</var>. That is: <ul> <li> <var>iter(1)</var>: number of outer iterations, i.e., how many times the method restarted. (if <var>restart</var> is empty or <var>N</var>, then it is 1, if not 1 ≤ <var>iter(1)</var> ≤ <var>maxit</var>). </li>
<li> <var>iter(2)</var>: the number of iterations performed before the restart, i.e., the method restarts when <code><var>iter(2)</var> = <var>restart</var></code>. If <var>restart</var> is empty or <var>N</var>, then 1 ≤ <var>iter(2)</var> ≤ <var>maxit</var>. </li>
</ul> <p>To be more clear, the approximation <var>x</var> is computed at the iteration <code>(<var>iter(1)</var> - 1) * <var>restart</var> + <var>iter(2)</var></code>. Since the output <var>x</var> corresponds to the minimal preconditioned residual solution, the total number of iterations that the method performed is given by <code>length (resvec) - 1</code>. </p> </li>
<li>- <var>resvec</var> is a vector containing the preconditioned relative residual at each iteration, including the 0-th iteration <code>norm (<var>A</var> * <var>x0</var> - <var>b</var>)</code>. </li>
</ul> <p>Let us consider a trivial problem with a tridiagonal matrix </p> <pre class="example" data-language="matlab">n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case, it corresponds to lu (A)
M = M1 * M2;
Afcn = @(x) A * x;
Mfcn = @(x) M \ x;
M1fcn = @(x) M1 \ x;
M2fcn = @(x) M2 \ x;</pre> <p><small>EXAMPLE 1:</small> simplest usage of <code>gmres</code> </p> <pre class="example" data-language="matlab">x = gmres (A, b, [], [], n)</pre> <p><small>EXAMPLE 2:</small> <code>gmres</code> with a function which computes <code><var>A</var> * <var>x</var></code> </p> <pre class="example" data-language="matlab">x = gmres (Afcn, b, [], [], n)</pre> <p><small>EXAMPLE 3:</small> usage of <code>gmres</code> with the restart </p> <pre class="example" data-language="matlab">x = gmres (A, b, restart);</pre> <p><small>EXAMPLE 4:</small> <code>gmres</code> with a preconditioner matrix <var>M</var> with and without restart </p> <pre class="example" data-language="matlab">x = gmres (A, b, [], 1e-06, n, M)
x = gmres (A, b, restart, 1e-06, n, M)</pre> <p><small>EXAMPLE 5:</small> <code>gmres</code> with a function as preconditioner </p> <pre class="example" data-language="matlab">x = gmres (Afcn, b, [], 1e-6, n, Mfcn)</pre> <p><small>EXAMPLE 6:</small> <code>gmres</code> with preconditioner matrices <var>M1</var> and <var>M2</var> </p> <pre class="example" data-language="matlab">x = gmres (A, b, [], 1e-6, n, M1, M2)</pre> <p><small>EXAMPLE 7:</small> <code>gmres</code> with functions as preconditioners </p> <pre class="example" data-language="matlab">x = gmres (Afcn, b, 1e-6, n, M1fcn, M2fcn)</pre> <p><small>EXAMPLE 8:</small> <code>gmres</code> with as input a function requiring an argument </p> <pre class="example" data-language="matlab">function y = Ap (A, x, p) # compute A^p * x
     y = x;
     for i = 1:p
       y = A * y;
     endfor
  endfunction
Apfcn = @(x, p) Ap (A, x, p);
x = gmres (Apfcn, b, [], [], [], [], [], [], 2);</pre> <p><small>EXAMPLE 9:</small> explicit example to show that <code>gmres</code> uses a left preconditioner </p> <pre class="example" data-language="matlab">[M1, M2] = ilu (A + 0.1 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by gmres after two iterations
[x_ref, fl] = gmres (A, b, [], [], 1, M)

## left preconditioning
[x, fl] = gmres (M \ A, M \ b, [], [], 1)
x # compare x and x_ref</pre> <p>Reference: </p> <p>Y. Saad, <cite>Iterative Methods for Sparse Linear Systems</cite>, Second edition, 2003, SIAM </p> <p><strong>See also:</strong> <a href="#XREFbicg">bicg</a>, <a href="#XREFbicgstab">bicgstab</a>, <a href="#XREFcgs">cgs</a>, <a href="iterative-techniques.html#XREFpcg">pcg</a>, <a href="iterative-techniques.html#XREFpcr">pcr</a>, <a href="#XREFqmr">qmr</a>, <a href="#XREFtfqmr">tfqmr</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-qmr">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>qmr</strong> <em>(<var>A</var>, <var>b</var>, <var>rtol</var>, <var>maxit</var>, <var>M1</var>, <var>M2</var>, <var>x0</var>)</em><a href="#index-qmr" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-qmr-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>qmr</strong> <em>(<var>A</var>, <var>b</var>, <var>rtol</var>, <var>maxit</var>, <var>P</var>)</em><a href="#index-qmr-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-qmr-2">
<span class="category">: </span><span><em>[<var>x</var>, <var>flag</var>, <var>relres</var>, <var>iter</var>, <var>resvec</var>] =</em> <strong>qmr</strong> <em>(<var>A</var>, <var>b</var>, …)</em><a href="#index-qmr-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Solve <code>A x = b</code> using the Quasi-Minimal Residual iterative method (without look-ahead). </p> <ul class="no-bullet"> <li>- <var>rtol</var> is the relative tolerance, if not given or set to [] the default value 1e-6 is used. </li>
<li>- <var>maxit</var> the maximum number of outer iterations, if not given or set to [] the default value <code>min (20, numel (b))</code> is used. </li>
<li>- <var>x0</var> the initial guess, if not given or set to [] the default value <code>zeros (size (b))</code> is used. </li>
</ul> <p><var>A</var> can be passed as a matrix or as a function handle or inline function <code>f</code> such that <code>f(x, "notransp") = A*x</code> and <code>f(x, "transp") = A'*x</code>. </p> <p>The preconditioner <var>P</var> is given as <code>P = M1 * M2</code>. Both <var>M1</var> and <var>M2</var> can be passed as a matrix or as a function handle or inline function <code>g</code> such that <code>g(x, "notransp") = M1 \ x</code> or <code>g(x, "notransp") = M2 \ x</code> and <code>g(x, "transp") = M1' \ x</code> or <code>g(x, "transp") = M2' \ x</code>. </p> <p>If called with more than one output parameter </p> <ul class="no-bullet"> <li>- <var>flag</var> indicates the exit status: <ul class="no-bullet"> <li>- 0: iteration converged to the within the chosen tolerance </li>
<li>- 1: the maximum number of iterations was reached before convergence </li>
<li>- 3: the algorithm reached stagnation </li>
</ul> <p>(the value 2 is unused but skipped for compatibility). </p> </li>
<li>- <var>relres</var> is the final value of the relative residual. </li>
<li>- <var>iter</var> is the number of iterations performed. </li>
<li>- <var>resvec</var> is a vector containing the residual norms at each iteration. </li>
</ul> <p>References: </p> <ol> <li> R. Freund and N. Nachtigal, <cite>QMR: a quasi-minimal residual method for non-Hermitian linear systems</cite>, Numerische Mathematik, 1991, 60, pp. 315–339. </li>
<li> R. Barrett, M. Berry, T. Chan, J. Demmel, J. Donato, J. Dongarra, V. Eijkhour, R. Pozo, C. Romine, and H. van der Vorst, <cite>Templates for the solution of linear systems: Building blocks for iterative methods</cite>, SIAM, 2nd ed., 1994. </li>
</ol> <p><strong>See also:</strong> <a href="#XREFbicg">bicg</a>, <a href="#XREFbicgstab">bicgstab</a>, <a href="#XREFcgs">cgs</a>, <a href="#XREFgmres">gmres</a>, <a href="iterative-techniques.html#XREFpcg">pcg</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-tfqmr">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>tfqmr</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M1</var>, <var>M2</var>, <var>x0</var>, …)</em><a href="#index-tfqmr" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-tfqmr-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>tfqmr</strong> <em>(<var>A</var>, <var>b</var>, <var>tol</var>, <var>maxit</var>, <var>M</var>, [], <var>x0</var>, …)</em><a href="#index-tfqmr-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-tfqmr-2">
<span class="category">: </span><span><em>[<var>x</var>, <var>flag</var>, <var>relres</var>, <var>iter</var>, <var>resvec</var>] =</em> <strong>tfqmr</strong> <em>(<var>A</var>, <var>b</var>, …)</em><a href="#index-tfqmr-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Solve <code>A x = b</code> using the Transpose-Tree qmr method, based on the cgs. </p> <p>The input parameters are: </p> <ul class="no-bullet"> <li>- <var>A</var> is the matrix of the linear system and it must be square. <var>A</var> can be passed as a matrix, function handle, or inline function <code>Afcn</code> such that <code>Afcn(x) = A * x</code>. Additional parameters to <code>Afcn</code> are passed after <var>x0</var>. </li>
<li>- <var>b</var> is the right hand side vector. It must be a column vector with the same number of rows as <var>A</var>. </li>
<li>- <var>tol</var> is the relative tolerance, if not given or set to [] the default value 1e-6 is used. </li>
<li>- <var>maxit</var> the maximum number of outer iterations, if not given or set to [] the default value <code>min (20, numel (b))</code> is used. To be compatible, since the method as different behaviors in the iteration number is odd or even, is considered as iteration in <code>tfqmr</code> the entire odd-even cycle. That is, to make an entire iteration, the algorithm performs two sub-iterations: the odd one and the even one. </li>
<li>- <var>M1</var>, <var>M2</var> are the preconditioners. The preconditioner <var>M</var> is given as <code>M = M1 * M2</code>. Both <var>M1</var> and <var>M2</var> can be passed as a matrix or as a function handle or inline function <code>g</code> such that <code>g(x) = M1 \ x</code> or <code>g(x) = M2 \ x</code>. The technique used is the right-preconditioning, i.e., it is solved <code>A*inv(M)*y = b</code> and then <code>x = inv(M)*y</code>, instead of <code>A x = b</code>. </li>
<li>- <var>x0</var> the initial guess, if not given or set to [] the default value <code>zeros (size (b))</code> is used. </li>
</ul> <p>The arguments which follow <var>x0</var> are treated as parameters, and passed in a proper way to any of the functions (<var>A</var> or <var>M</var>) which are passed to <code>tfqmr</code>. </p> <p>The output parameters are: </p> <ul class="no-bullet"> <li>- <var>x</var> is the approximation computed. If the method doesn’t converge then it is the iterated with the minimum residual. </li>
<li>- <var>flag</var> indicates the exit status: <ul class="no-bullet"> <li>- 0: iteration converged to the within the chosen tolerance </li>
<li>- 1: the maximum number of iterations was reached before convergence </li>
<li>- 2: the preconditioner matrix is singular </li>
<li>- 3: the algorithm reached stagnation </li>
<li>- 4: the algorithm can’t continue due to a division by zero </li>
</ul> </li>
<li>- <var>relres</var> is the relative residual obtained as <code>(<var>A</var>*<var>x</var>-<var>b</var>) / <code>norm (<var>b</var>)</code></code>. </li>
<li>- <var>iter</var> is the iteration which <var>x</var> is computed. </li>
<li>- <var>resvec</var> is a vector containing the residual at each iteration (including <code>norm (b - A x0)</code>). Doing <code>length (<var>resvec</var>) - 1</code> is possible to see the total number of iterations performed. </li>
</ul> <p>Let us consider a trivial problem with a tridiagonal matrix </p> <pre class="example" data-language="matlab">n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case it corresponds to chol (A)'
M = M1 * M2;
Afcn = @(x) A * x;
Mfcn = @(x) M \ x;
M1fcn = @(x) M1 \ x;
M2fcn = @(x) M2 \ x;</pre> <p><small>EXAMPLE 1:</small> simplest usage of <code>tfqmr</code> </p> <pre class="example" data-language="matlab">x = tfqmr (A, b, [], n)</pre> <p><small>EXAMPLE 2:</small> <code>tfqmr</code> with a function which computes <code><var>A</var> * <var>x</var></code> </p> <pre class="example" data-language="matlab">x = tfqmr (Afcn, b, [], n)</pre> <p><small>EXAMPLE 3:</small> <code>tfqmr</code> with a preconditioner matrix <var>M</var> </p> <pre class="example" data-language="matlab">x = tfqmr (A, b, [], 1e-06, n, M)</pre> <p><small>EXAMPLE 4:</small> <code>tfqmr</code> with a function as preconditioner </p> <pre class="example" data-language="matlab">x = tfqmr (Afcn, b, 1e-6, n, Mfcn)</pre> <p><small>EXAMPLE 5:</small> <code>tfqmr</code> with preconditioner matrices <var>M1</var> and <var>M2</var> </p> <pre class="example" data-language="matlab">x = tfqmr (A, b, [], 1e-6, n, M1, M2)</pre> <p><small>EXAMPLE 6:</small> <code>tfmqr</code> with functions as preconditioners </p> <pre class="example" data-language="matlab">x = tfqmr (Afcn, b, 1e-6, n, M1fcn, M2fcn)</pre> <p><small>EXAMPLE 7:</small> <code>tfqmr</code> with as input a function requiring an argument </p> <pre class="example" data-language="matlab">function y = Ap (A, x, z) # compute A^z * x
   y = x;
   for i = 1:z
     y = A * y;
   endfor
 endfunction
Apfcn = @(x, string, p) Ap (A, x, string, p);
x = tfqmr (Apfcn, b, [], [], [], [], [], 2);</pre> <p><small>EXAMPLE 8:</small> explicit example to show that <code>tfqmr</code> uses a right preconditioner </p> <pre class="example" data-language="matlab">[M1, M2] = ilu (A + 0.3 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by tfqmr after one iteration
[x_ref, fl] = tfqmr (A, b, [], 1, M)

## right preconditioning
[y, fl] = tfqmr (A / M, b, [], 1)
x = M \ y # compare x and x_ref</pre> <p>Reference: </p> <p>Y. Saad, <cite>Iterative Methods for Sparse Linear Systems</cite>, Second edition, 2003, SIAM </p> <p><strong>See also:</strong> <a href="#XREFbicg">bicg</a>, <a href="#XREFbicgstab">bicgstab</a>, <a href="#XREFcgs">cgs</a>, <a href="#XREFgmres">gmres</a>, <a href="iterative-techniques.html#XREFpcg">pcg</a>, <a href="#XREFqmr">qmr</a>, <a href="iterative-techniques.html#XREFpcr">pcr</a>. </p> </dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Specialized-Solvers.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Specialized-Solvers.html</a>
  </p>
</div>
