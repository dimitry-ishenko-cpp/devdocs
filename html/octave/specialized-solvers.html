<div class="section-level-extent" id="Specialized-Solvers"> <div class="nav-panel"> <p> Previous: <a href="functions-of-a-matrix.html" accesskey="p" rel="prev">Functions of a Matrix</a>, Up: <a href="linear-algebra.html" accesskey="u" rel="up">Linear Algebra</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Specialized-Solvers-1"><span>18.5 Specialized Solvers<a class="copiable-link" href="#Specialized-Solvers-1"> ¶</a></span></h1>   <dl class="first-deftypefn"> <dt class="deftypefn" id="index-bicg">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">bicg</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-bicg"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bicg-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">bicg</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-bicg-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bicg-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">bicg</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>)</code><a class="copiable-link" href="#index-bicg-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bicg-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">bicg</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M</var>)</code><a class="copiable-link" href="#index-bicg-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bicg-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">bicg</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M1</var>, <var class="var">M2</var>)</code><a class="copiable-link" href="#index-bicg-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bicg-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">bicg</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M</var>, [], <var class="var">x0</var>)</code><a class="copiable-link" href="#index-bicg-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bicg-6">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">bicg</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M1</var>, <var class="var">M2</var>, <var class="var">x0</var>)</code><a class="copiable-link" href="#index-bicg-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bicg-7">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">bicg</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M</var>, [], <var class="var">x0</var>, …)</code><a class="copiable-link" href="#index-bicg-7"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bicg-8">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">bicg</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M1</var>, <var class="var">M2</var>, <var class="var">x0</var>, …)</code><a class="copiable-link" href="#index-bicg-8"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bicg-9">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">flag</var>, <var class="var">relres</var>, <var class="var">iter</var>, <var class="var">resvec</var>] =</code> <strong class="def-name">bicg</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, …)</code><a class="copiable-link" href="#index-bicg-9"> ¶</a></span>
</dt> <dd>
<p>Solve the linear system of equations <code class="code"><var class="var">A</var> * <var class="var">x</var> = <var class="var">b</var></code> by means of the Bi-Conjugate Gradient iterative method. </p> <p>The input arguments are: </p> <ul class="itemize mark-bullet"> <li>
<var class="var">A</var> is the matrix of the linear system and it must be square. <var class="var">A</var> can be passed as a matrix, function handle, or inline function <code class="code">Afcn</code> such that <code class="code">Afcn (x, "notransp") = A * x</code> and <code class="code">Afcn (x, "transp") = A' * x</code>. Additional parameters to <code class="code">Afcn</code> may be passed after <var class="var">x0</var>. </li>
<li>
<var class="var">b</var> is the right-hand side vector. It must be a column vector with the same number of rows as <var class="var">A</var>. </li>
<li>
<var class="var">tol</var> is the required relative tolerance for the residual error, <code class="code"><var class="var">b</var> - <var class="var">A</var> * <var class="var">x</var></code>. The iteration stops if <code class="code">norm (<var class="var">b</var> - <var class="var">A</var> * <var class="var">x</var>)</code> ≤ <code class="code"><var class="var">tol</var> * norm (<var class="var">b</var>)</code>. If <var class="var">tol</var> is omitted or empty, then a tolerance of 1e-6 is used. </li>
<li>
<var class="var">maxit</var> is the maximum allowed number of iterations; if <var class="var">maxit</var> is omitted or empty then a value of 20 is used. </li>
<li>
<var class="var">M1</var>, <var class="var">M2</var> are the preconditioners. The preconditioner <var class="var">M</var> is given as <code class="code"><var class="var">M</var> = <var class="var">M1</var> * <var class="var">M2</var></code>. Both <var class="var">M1</var> and <var class="var">M2</var> can be passed as a matrix or as a function handle or inline function <code class="code">g</code> such that <code class="code">g (<var class="var">x</var>, "notransp") = <var class="var">M1</var> \ <var class="var">x</var></code> or <code class="code">g (<var class="var">x</var>, "notransp") = <var class="var">M2</var> \ <var class="var">x</var></code> and <code class="code">g (<var class="var">x</var>, "transp") = <var class="var">M1</var>' \ <var class="var">x</var></code> or <code class="code">g (<var class="var">x</var>, "transp") = <var class="var">M2</var>' \ <var class="var">x</var></code>. If <var class="var">M1</var> is omitted or empty, then preconditioning is not applied. The preconditioned system is theoretically equivalent to applying the <code class="code">bicg</code> method to the linear system <code class="code">inv (<var class="var">M1</var>) * A * inv (<var class="var">M2</var>) * <var class="var">y</var> = inv
(<var class="var">M1</var>) * <var class="var">b</var></code> and <code class="code">inv (<var class="var">M2'</var>) * A' * inv (<var class="var">M1'</var>) * <var class="var">z</var> =
inv (<var class="var">M2'</var>) * <var class="var">b</var></code> and then setting <code class="code"><var class="var">x</var> = inv (<var class="var">M2</var>) * <var class="var">y</var></code>. </li>
<li>
<var class="var">x0</var> is the initial guess. If <var class="var">x0</var> is omitted or empty then the function sets <var class="var">x0</var> to a zero vector by default. </li>
</ul> <p>Any arguments which follow <var class="var">x0</var> are treated as parameters, and passed in an appropriate manner to any of the functions (<var class="var">Afcn</var> or <var class="var">Mfcn</var>) or that have been given to <code class="code">bicg</code>. </p> <p>The output parameters are: </p> <ul class="itemize mark-bullet"> <li>
<var class="var">x</var> is the computed approximation to the solution of <code class="code"><var class="var">A</var> * <var class="var">x</var> = <var class="var">b</var></code>. If the algorithm did not converge, then <var class="var">x</var> is the iteration which has the minimum residual. </li>
<li>
<var class="var">flag</var> indicates the exit status: <ul class="itemize mark-bullet"> <li>0: The algorithm converged to within the prescribed tolerance. </li>
<li>1: The algorithm did not converge and it reached the maximum number of iterations. </li>
<li>2: The preconditioner matrix is singular. </li>
<li>3: The algorithm stagnated, i.e., the absolute value of the difference between the current iteration <var class="var">x</var> and the previous is less than <code class="code">eps * norm (<var class="var">x</var>,2)</code>. </li>
<li>4: The algorithm could not continue because intermediate values became too small or too large for reliable computation. </li>
</ul> </li>
<li>
<var class="var">relres</var> is the ratio of the final residual to its initial value, measured in the Euclidean norm. </li>
<li>
<var class="var">iter</var> is the iteration which <var class="var">x</var> is computed. </li>
<li>
<var class="var">resvec</var> is a vector containing the residual at each iteration. The total number of iterations performed is given by <code class="code">length (<var class="var">resvec</var>) - 1</code>. </li>
</ul> <p>Consider a trivial problem with a tridiagonal matrix </p> <pre class="example" data-language="matlab">n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n)) + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
              sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A);  # in this tridiag case, it corresponds to lu (A)
M = M1 * M2;
Afcn = @(x, string) strcmp (string, "notransp") * (A * x) + ...
                     strcmp (string, "transp") * (A' * x);
Mfcn = @(x, string) strcmp (string, "notransp") * (M \ x) + ...
                     strcmp (string, "transp") * (M' \ x);
M1fcn = @(x, string) strcmp (string, "notransp") * (M1 \ x) + ...
                     strcmp (string, "transp") * (M1' \ x);
M2fcn = @(x, string) strcmp (string, "notransp") * (M2 \ x) + ...
                     strcmp (string, "transp") * (M2' \ x);</pre> <p><small class="sc">EXAMPLE 1:</small> simplest usage of <code class="code">bicg</code> </p> <pre class="example" data-language="matlab">x = bicg (A, b)</pre> <p><small class="sc">EXAMPLE 2:</small> <code class="code">bicg</code> with a function that computes <code class="code"><var class="var">A</var>*<var class="var">x</var></code> and <code class="code"><var class="var">A'</var>*<var class="var">x</var></code> </p> <pre class="example" data-language="matlab">x = bicg (Afcn, b, [], n)</pre> <p><small class="sc">EXAMPLE 3:</small> <code class="code">bicg</code> with a preconditioner matrix <var class="var">M</var> </p> <pre class="example" data-language="matlab">x = bicg (A, b, 1e-6, n, M)</pre> <p><small class="sc">EXAMPLE 4:</small> <code class="code">bicg</code> with a function as preconditioner </p> <pre class="example" data-language="matlab">x = bicg (Afcn, b, 1e-6, n, Mfcn)</pre> <p><small class="sc">EXAMPLE 5:</small> <code class="code">bicg</code> with preconditioner matrices <var class="var">M1</var> and <var class="var">M2</var> </p> <pre class="example" data-language="matlab">x = bicg (A, b, 1e-6, n, M1, M2)</pre> <p><small class="sc">EXAMPLE 6:</small> <code class="code">bicg</code> with functions as preconditioners </p> <pre class="example" data-language="matlab">x = bicg (Afcn, b, 1e-6, n, M1fcn, M2fcn)</pre> <p><small class="sc">EXAMPLE 7:</small> <code class="code">bicg</code> with as input a function requiring an argument </p> <pre class="example" data-language="matlab">function y = Ap (A, x, string, z)
  ## compute A^z * x or (A^z)' * x
  y = x;
  if (strcmp (string, "notransp"))
    for i = 1:z
      y = A * y;
    endfor
  elseif (strcmp (string, "transp"))
    for i = 1:z
      y = A' * y;
    endfor
  endif
endfunction

Apfcn = @(x, string, p) Ap (A, x, string, p);
x = bicg (Apfcn, b, [], [], [], [], [], 2);</pre> <p>Reference: </p> <p>Y. Saad, <cite class="cite">Iterative Methods for Sparse Linear Systems</cite>, Second edition, 2003, SIAM. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbicgstab">bicgstab</a>, <a class="ref" href="#XREFcgs">cgs</a>, <a class="ref" href="#XREFgmres">gmres</a>, <a class="ref" href="iterative-techniques.html#XREFpcg">pcg</a>, <a class="ref" href="#XREFqmr">qmr</a>, <a class="ref" href="#XREFtfqmr">tfqmr</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-bicgstab">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">bicgstab</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M1</var>, <var class="var">M2</var>, <var class="var">x0</var>, …)</code><a class="copiable-link" href="#index-bicgstab"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bicgstab-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">bicgstab</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M</var>, [], <var class="var">x0</var>, …)</code><a class="copiable-link" href="#index-bicgstab-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-bicgstab-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">flag</var>, <var class="var">relres</var>, <var class="var">iter</var>, <var class="var">resvec</var>] =</code> <strong class="def-name">bicgstab</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, …)</code><a class="copiable-link" href="#index-bicgstab-2"> ¶</a></span>
</dt> <dd>
<p>Solve <code class="code">A x = b</code> using the stabilized Bi-conjugate gradient iterative method. </p> <p>The input parameters are: </p> <ul class="itemize mark-minus"> <li>
<var class="var">A</var> is the matrix of the linear system and it must be square. <var class="var">A</var> can be passed as a matrix, function handle, or inline function <code class="code">Afcn</code> such that <code class="code">Afcn(x) = A * x</code>. Additional parameters to <code class="code">Afcn</code> are passed after <var class="var">x0</var>. </li>
<li>
<var class="var">b</var> is the right hand side vector. It must be a column vector with the same number of rows as <var class="var">A</var>. </li>
<li>
<var class="var">tol</var> is the required relative tolerance for the residual error, <code class="code"><var class="var">b</var> - <var class="var">A</var> * <var class="var">x</var></code>. The iteration stops if <code class="code">norm (<var class="var">b</var> - <var class="var">A</var> * <var class="var">x</var>)</code> ≤ <code class="code"><var class="var">tol</var> * norm (<var class="var">b</var>)</code>. If <var class="var">tol</var> is omitted or empty, then a tolerance of 1e-6 is used. </li>
<li>
<var class="var">maxit</var> the maximum number of outer iterations, if not given or set to [] the default value <code class="code">min (20, numel (b))</code> is used. </li>
<li>
<var class="var">M1</var>, <var class="var">M2</var> are the preconditioners. The preconditioner <var class="var">M</var> is given as <code class="code"><var class="var">M</var> = <var class="var">M1</var> * <var class="var">M2</var></code>. Both <var class="var">M1</var> and <var class="var">M2</var> can be passed as a matrix or as a function handle or inline function <code class="code">g</code> such that <code class="code">g(<var class="var">x</var>) = <var class="var">M1</var> \ <var class="var">x</var></code> or <code class="code">g(<var class="var">x</var>) = <var class="var">M2</var> \ <var class="var">x</var></code>. The technique used is the right preconditioning, i.e., it is solved <code class="code"><var class="var">A</var> * inv (<var class="var">M</var>) * <var class="var">y</var> = <var class="var">b</var></code> and then <code class="code"><var class="var">x</var> = inv (<var class="var">M</var>) * <var class="var">y</var></code>. </li>
<li>
<var class="var">x0</var> the initial guess, if not given or set to [] the default value <code class="code">zeros (size (<var class="var">b</var>))</code> is used. </li>
</ul> <p>The arguments which follow <var class="var">x0</var> are treated as parameters, and passed in a proper way to any of the functions (<var class="var">A</var> or <var class="var">M</var>) which are passed to <code class="code">bicstab</code>. </p> <p>The output parameters are: </p> <ul class="itemize mark-minus"> <li>
<var class="var">x</var> is the approximation computed. If the method doesn’t converge then it is the iterated with the minimum residual. </li>
<li>
<var class="var">flag</var> indicates the exit status: <ul class="itemize mark-minus"> <li>0: iteration converged to the within the chosen tolerance </li>
<li>1: the maximum number of iterations was reached before convergence </li>
<li>2: the preconditioner matrix is singular </li>
<li>3: the algorithm reached stagnation </li>
<li>4: the algorithm can’t continue due to a division by zero </li>
</ul> </li>
<li>
<var class="var">relres</var> is the relative residual obtained with as <code class="code">(<var class="var">A</var>*<var class="var">x</var>-<var class="var">b</var>) / <code class="code">norm(<var class="var">b</var>)</code></code>. </li>
<li>
<var class="var">iter</var> is the (possibly half) iteration which <var class="var">x</var> is computed. If it is an half iteration then it is <code class="code"><var class="var">iter</var> + 0.5</code> </li>
<li>
<var class="var">resvec</var> is a vector containing the residual of each half and total iteration (There are also the half iterations since <var class="var">x</var> is computed in two steps at each iteration). Doing <code class="code">(length(<var class="var">resvec</var>) - 1) / 2</code> is possible to see the total number of (total) iterations performed. </li>
</ul> <p>Let us consider a trivial problem with a tridiagonal matrix </p> <pre class="example" data-language="matlab">n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case, it corresponds to lu (A)
M = M1 * M2;
Afcn = @(x) A * x;
Mfcn = @(x) M \ x;
M1fcn = @(x) M1 \ x;
M2fcn = @(x) M2 \ x;</pre> <p><small class="sc">EXAMPLE 1:</small> simplest usage of <code class="code">bicgstab</code> </p> <pre class="example" data-language="matlab">x = bicgstab (A, b, [], n)</pre> <p><small class="sc">EXAMPLE 2:</small> <code class="code">bicgstab</code> with a function which computes <code class="code"><var class="var">A</var> * <var class="var">x</var></code> </p> <pre class="example" data-language="matlab">x = bicgstab (Afcn, b, [], n)</pre> <p><small class="sc">EXAMPLE 3:</small> <code class="code">bicgstab</code> with a preconditioner matrix <var class="var">M</var> </p> <pre class="example" data-language="matlab">x = bicgstab (A, b, [], 1e-06, n, M)</pre> <p><small class="sc">EXAMPLE 4:</small> <code class="code">bicgstab</code> with a function as preconditioner </p> <pre class="example" data-language="matlab">x = bicgstab (Afcn, b, 1e-6, n, Mfcn)</pre> <p><small class="sc">EXAMPLE 5:</small> <code class="code">bicgstab</code> with preconditioner matrices <var class="var">M1</var> and <var class="var">M2</var> </p> <pre class="example" data-language="matlab">x = bicgstab (A, b, [], 1e-6, n, M1, M2)</pre> <p><small class="sc">EXAMPLE 6:</small> <code class="code">bicgstab</code> with functions as preconditioners </p> <pre class="example" data-language="matlab">x = bicgstab (Afcn, b, 1e-6, n, M1fcn, M2fcn)</pre> <p><small class="sc">EXAMPLE 7:</small> <code class="code">bicgstab</code> with as input a function requiring an argument </p> <pre class="example" data-language="matlab">function y = Ap (A, x, z) # compute A^z * x
   y = x;
   for i = 1:z
     y = A * y;
   endfor
 endfunction
Apfcn = @(x, string, p) Ap (A, x, string, p);
x = bicgstab (Apfcn, b, [], [], [], [], [], 2);</pre> <p><small class="sc">EXAMPLE 8:</small> explicit example to show that <code class="code">bicgstab</code> uses a right preconditioner </p> <pre class="example" data-language="matlab">[M1, M2] = ilu (A + 0.1 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by bicgstab after one iteration
[x_ref, fl] = bicgstab (A, b, [], 1, M)

## right preconditioning
[y, fl] = bicgstab (A / M, b, [], 1)
x = M \ y # compare x and x_ref</pre> <p>Reference: </p> <p>Y. Saad, <cite class="cite">Iterative Methods for Sparse Linear Systems</cite>, Second edition, 2003, SIAM </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbicg">bicg</a>, <a class="ref" href="#XREFcgs">cgs</a>, <a class="ref" href="#XREFgmres">gmres</a>, <a class="ref" href="iterative-techniques.html#XREFpcg">pcg</a>, <a class="ref" href="#XREFqmr">qmr</a>, <a class="ref" href="#XREFtfqmr">tfqmr</a>. </p> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-cgs">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">cgs</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M1</var>, <var class="var">M2</var>, <var class="var">x0</var>, …)</code><a class="copiable-link" href="#index-cgs"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-cgs-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">cgs</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M</var>, [], <var class="var">x0</var>, …)</code><a class="copiable-link" href="#index-cgs-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-cgs-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">flag</var>, <var class="var">relres</var>, <var class="var">iter</var>, <var class="var">resvec</var>] =</code> <strong class="def-name">cgs</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, …)</code><a class="copiable-link" href="#index-cgs-2"> ¶</a></span>
</dt> <dd>
<p>Solve <code class="code">A x = b</code>, where <var class="var">A</var> is a square matrix, using the Conjugate Gradients Squared method. </p> <p>The input arguments are: </p> <ul class="itemize mark-minus"> <li>
<var class="var">A</var> is the matrix of the linear system and it must be square. <var class="var">A</var> can be passed as a matrix, function handle, or inline function <code class="code">Afcn</code> such that <code class="code">Afcn(x) = A * x</code>. Additional parameters to <code class="code">Afcn</code> are passed after <var class="var">x0</var>. </li>
<li>
<var class="var">b</var> is the right hand side vector. It must be a column vector with same number of rows of <var class="var">A</var>. </li>
<li>
<var class="var">tol</var> is the relative tolerance, if not given or set to [] the default value 1e-6 is used. </li>
<li>
<var class="var">maxit</var> the maximum number of outer iterations, if not given or set to [] the default value <code class="code">min (20, numel (b))</code> is used. </li>
<li>
<var class="var">M1</var>, <var class="var">M2</var> are the preconditioners. The preconditioner matrix is given as <code class="code">M = M1 * M2</code>. Both <var class="var">M1</var> and <var class="var">M2</var> can be passed as a matrix or as a function handle or inline function <code class="code">g</code> such that <code class="code">g(x) = M1 \ x</code> or <code class="code">g(x) = M2 \ x</code>. If M1 is empty or not passed then no preconditioners are applied. The technique used is the right preconditioning, i.e., it is solved <code class="code"><var class="var">A</var>*inv(<var class="var">M</var>)*y = b</code> and then <code class="code"><var class="var">x</var> = inv(<var class="var">M</var>)*y</code>. </li>
<li>
<var class="var">x0</var> the initial guess, if not given or set to [] the default value <code class="code">zeros (size (b))</code> is used. </li>
</ul> <p>The arguments which follow <var class="var">x0</var> are treated as parameters, and passed in a proper way to any of the functions (<var class="var">A</var> or <var class="var">P</var>) which are passed to <code class="code">cgs</code>. </p> <p>The output parameters are: </p> <ul class="itemize mark-minus"> <li>
<var class="var">x</var> is the approximation computed. If the method doesn’t converge then it is the iterated with the minimum residual. </li>
<li>
<var class="var">flag</var> indicates the exit status: <ul class="itemize mark-minus"> <li>0: iteration converged to the within the chosen tolerance </li>
<li>1: the maximum number of iterations was reached before convergence </li>
<li>2: the preconditioner matrix is singular </li>
<li>3: the algorithm reached stagnation </li>
<li>4: the algorithm can’t continue due to a division by zero </li>
</ul> </li>
<li>
<var class="var">relres</var> is the relative residual obtained with as <code class="code">(<var class="var">A</var>*<var class="var">x</var>-<var class="var">b</var>) / <code class="code">norm(<var class="var">b</var>)</code></code>. </li>
<li>
<var class="var">iter</var> is the iteration which <var class="var">x</var> is computed. </li>
<li>
<var class="var">resvec</var> is a vector containing the residual at each iteration. Doing <code class="code">length(<var class="var">resvec</var>) - 1</code> is possible to see the total number of iterations performed. </li>
</ul> <p>Let us consider a trivial problem with a tridiagonal matrix </p> <pre class="example" data-language="matlab">n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case it corresponds to chol (A)'
M = M1 * M2;
Afcn = @(x) A * x;
Mfcn = @(x) M \ x;
M1fcn = @(x) M1 \ x;
M2fcn = @(x) M2 \ x;</pre> <p><small class="sc">EXAMPLE 1:</small> simplest usage of <code class="code">cgs</code> </p> <pre class="example" data-language="matlab">x = cgs (A, b, [], n)</pre> <p><small class="sc">EXAMPLE 2:</small> <code class="code">cgs</code> with a function which computes <code class="code"><var class="var">A</var> * <var class="var">x</var></code> </p> <pre class="example" data-language="matlab">x = cgs (Afcn, b, [], n)</pre> <p><small class="sc">EXAMPLE 3:</small> <code class="code">cgs</code> with a preconditioner matrix <var class="var">M</var> </p> <pre class="example" data-language="matlab">x = cgs (A, b, [], 1e-06, n, M)</pre> <p><small class="sc">EXAMPLE 4:</small> <code class="code">cgs</code> with a function as preconditioner </p> <pre class="example" data-language="matlab">x = cgs (Afcn, b, 1e-6, n, Mfcn)</pre> <p><small class="sc">EXAMPLE 5:</small> <code class="code">cgs</code> with preconditioner matrices <var class="var">M1</var> and <var class="var">M2</var> </p> <pre class="example" data-language="matlab">x = cgs (A, b, [], 1e-6, n, M1, M2)</pre> <p><small class="sc">EXAMPLE 6:</small> <code class="code">cgs</code> with functions as preconditioners </p> <pre class="example" data-language="matlab">x = cgs (Afcn, b, 1e-6, n, M1fcn, M2fcn)</pre> <p><small class="sc">EXAMPLE 7:</small> <code class="code">cgs</code> with as input a function requiring an argument </p> <pre class="example" data-language="matlab">function y = Ap (A, x, z) # compute A^z * x
   y = x;
   for i = 1:z
     y = A * y;
   endfor
 endfunction
Apfcn = @(x, string, p) Ap (A, x, string, p);
x = cgs (Apfcn, b, [], [], [], [], [], 2);</pre> <p><small class="sc">EXAMPLE 8:</small> explicit example to show that <code class="code">cgs</code> uses a right preconditioner </p> <pre class="example" data-language="matlab">[M1, M2] = ilu (A + 0.3 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by cgs after one iteration
[x_ref, fl] = cgs (A, b, [], 1, M)

## right preconditioning
[y, fl] = cgs (A / M, b, [], 1)
x = M \ y # compare x and x_ref</pre> <p>References: </p> <p>Y. Saad, <cite class="cite">Iterative Methods for Sparse Linear Systems</cite>, Second edition, 2003, SIAM </p> <p><strong class="strong">See also:</strong> <a class="ref" href="iterative-techniques.html#XREFpcg">pcg</a>, <a class="ref" href="#XREFbicgstab">bicgstab</a>, <a class="ref" href="#XREFbicg">bicg</a>, <a class="ref" href="#XREFgmres">gmres</a>, <a class="ref" href="#XREFqmr">qmr</a>, <a class="ref" href="#XREFtfqmr">tfqmr</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-gmres">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">gmres</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">restart</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M1</var>, <var class="var">M2</var>, <var class="var">x0</var>, …)</code><a class="copiable-link" href="#index-gmres"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-gmres-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">gmres</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">restart</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M</var>, [], <var class="var">x0</var>, …)</code><a class="copiable-link" href="#index-gmres-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-gmres-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">flag</var>, <var class="var">relres</var>, <var class="var">iter</var>, <var class="var">resvec</var>] =</code> <strong class="def-name">gmres</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, …)</code><a class="copiable-link" href="#index-gmres-2"> ¶</a></span>
</dt> <dd>
<p>Solve <code class="code">A x = b</code> using the Preconditioned GMRES iterative method with restart, a.k.a. PGMRES(restart). </p> <p>The input arguments are: </p> <ul class="itemize mark-minus"> <li>
<var class="var">A</var> is the matrix of the linear system and it must be square. <var class="var">A</var> can be passed as a matrix, function handle, or inline function <code class="code">Afcn</code> such that <code class="code">Afcn(x) = A * x</code>. Additional parameters to <code class="code">Afcn</code> are passed after <var class="var">x0</var>. </li>
<li>
<var class="var">b</var> is the right hand side vector. It must be a column vector with the same numbers of rows as <var class="var">A</var>. </li>
<li>
<var class="var">restart</var> is the number of iterations before that the method restarts. If it is [] or N = numel (b), then the restart is not applied. </li>
<li>
<var class="var">tol</var> is the required relative tolerance for the preconditioned residual error, <code class="code">inv (<var class="var">M</var>) * (<var class="var">b</var> - <var class="var">a</var> * <var class="var">x</var>)</code>. The iteration stops if <code class="code">norm (inv (<var class="var">M</var>) * (<var class="var">b</var> - <var class="var">a</var> * <var class="var">x</var>))
≤ <var class="var">tol</var> * norm (inv (<var class="var">M</var>) * <var class="var">B</var>)</code>. If <var class="var">tol</var> is omitted or empty, then a tolerance of 1e-6 is used. </li>
<li>
<var class="var">maxit</var> is the maximum number of outer iterations, if not given or set to [], then the default value <code class="code">min (10, <var class="var">N</var> / <var class="var">restart</var>)</code> is used. Note that, if <var class="var">restart</var> is empty, then <var class="var">maxit</var> is the maximum number of iterations. If <var class="var">restart</var> and <var class="var">maxit</var> are not empty, then the maximum number of iterations is <code class="code"><var class="var">restart</var> * <var class="var">maxit</var></code>. If both <var class="var">restart</var> and <var class="var">maxit</var> are empty, then the maximum number of iterations is set to <code class="code">min (10, <var class="var">N</var>)</code>. </li>
<li>
<var class="var">M1</var>, <var class="var">M2</var> are the preconditioners. The preconditioner <var class="var">M</var> is given as <code class="code">M = M1 * M2</code>. Both <var class="var">M1</var> and <var class="var">M2</var> can be passed as a matrix, function handle, or inline function <code class="code">g</code> such that <code class="code">g(x) = M1 \ x</code> or <code class="code">g(x) = M2 \ x</code>. If <var class="var">M1</var> is [] or not given, then the preconditioner is not applied. The technique used is the left-preconditioning, i.e., it is solved <code class="code">inv(<var class="var">M</var>) * <var class="var">A</var> * <var class="var">x</var> = inv(<var class="var">M</var>) * <var class="var">b</var></code> instead of <code class="code"><var class="var">A</var> * <var class="var">x</var> = <var class="var">b</var></code>. </li>
<li>
<var class="var">x0</var> is the initial guess, if not given or set to [], then the default value <code class="code">zeros (size (<var class="var">b</var>))</code> is used. </li>
</ul> <p>The arguments which follow <var class="var">x0</var> are treated as parameters, and passed in a proper way to any of the functions (<var class="var">A</var> or <var class="var">M</var> or <var class="var">M1</var> or <var class="var">M2</var>) which are passed to <code class="code">gmres</code>. </p> <p>The outputs are: </p> <ul class="itemize mark-minus"> <li>
<var class="var">x</var> the computed approximation. If the method does not converge, then it is the iterated with minimum residual. </li>
<li>
<var class="var">flag</var> indicates the exit status: <dl class="table"> <dt>0 : iteration converged to within the specified tolerance</dt> <dt>1 : maximum number of iterations exceeded</dt> <dt>2 : the preconditioner matrix is singular</dt> <dt>3 : algorithm reached stagnation (the relative difference between two</dt> <dd><p>consecutive iterations is less than eps) </p></dd> </dl> </li>
<li>
<var class="var">relres</var> is the value of the relative preconditioned residual of the approximation <var class="var">x</var>. </li>
<li>
<var class="var">iter</var> is a vector containing the number of outer iterations and inner iterations performed to compute <var class="var">x</var>. That is: <ul class="itemize mark-bullet"> <li>
<var class="var">iter(1)</var>: number of outer iterations, i.e., how many times the method restarted. (if <var class="var">restart</var> is empty or <var class="var">N</var>, then it is 1, if not 1 ≤ <var class="var">iter(1)</var> ≤ <var class="var">maxit</var>). </li>
<li>
<var class="var">iter(2)</var>: the number of iterations performed before the restart, i.e., the method restarts when <code class="code"><var class="var">iter(2)</var> = <var class="var">restart</var></code>. If <var class="var">restart</var> is empty or <var class="var">N</var>, then 1 ≤ <var class="var">iter(2)</var> ≤ <var class="var">maxit</var>. </li>
</ul> <p>To be more clear, the approximation <var class="var">x</var> is computed at the iteration <code class="code">(<var class="var">iter(1)</var> - 1) * <var class="var">restart</var> + <var class="var">iter(2)</var></code>. Since the output <var class="var">x</var> corresponds to the minimal preconditioned residual solution, the total number of iterations that the method performed is given by <code class="code">length (resvec) - 1</code>. </p> </li>
<li>
<var class="var">resvec</var> is a vector containing the preconditioned relative residual at each iteration, including the 0-th iteration <code class="code">norm (<var class="var">A</var> * <var class="var">x0</var> - <var class="var">b</var>)</code>. </li>
</ul> <p>Let us consider a trivial problem with a tridiagonal matrix </p> <pre class="example" data-language="matlab">n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case, it corresponds to lu (A)
M = M1 * M2;
Afcn = @(x) A * x;
Mfcn = @(x) M \ x;
M1fcn = @(x) M1 \ x;
M2fcn = @(x) M2 \ x;</pre> <p><small class="sc">EXAMPLE 1:</small> simplest usage of <code class="code">gmres</code> </p> <pre class="example" data-language="matlab">x = gmres (A, b, [], [], n)</pre> <p><small class="sc">EXAMPLE 2:</small> <code class="code">gmres</code> with a function which computes <code class="code"><var class="var">A</var> * <var class="var">x</var></code> </p> <pre class="example" data-language="matlab">x = gmres (Afcn, b, [], [], n)</pre> <p><small class="sc">EXAMPLE 3:</small> usage of <code class="code">gmres</code> with the restart </p> <pre class="example" data-language="matlab">x = gmres (A, b, restart);</pre> <p><small class="sc">EXAMPLE 4:</small> <code class="code">gmres</code> with a preconditioner matrix <var class="var">M</var> with and without restart </p> <pre class="example" data-language="matlab">x = gmres (A, b, [], 1e-06, n, M)
x = gmres (A, b, restart, 1e-06, n, M)</pre> <p><small class="sc">EXAMPLE 5:</small> <code class="code">gmres</code> with a function as preconditioner </p> <pre class="example" data-language="matlab">x = gmres (Afcn, b, [], 1e-6, n, Mfcn)</pre> <p><small class="sc">EXAMPLE 6:</small> <code class="code">gmres</code> with preconditioner matrices <var class="var">M1</var> and <var class="var">M2</var> </p> <pre class="example" data-language="matlab">x = gmres (A, b, [], 1e-6, n, M1, M2)</pre> <p><small class="sc">EXAMPLE 7:</small> <code class="code">gmres</code> with functions as preconditioners </p> <pre class="example" data-language="matlab">x = gmres (Afcn, b, 1e-6, n, M1fcn, M2fcn)</pre> <p><small class="sc">EXAMPLE 8:</small> <code class="code">gmres</code> with as input a function requiring an argument </p> <pre class="example" data-language="matlab">function y = Ap (A, x, p) # compute A^p * x
     y = x;
     for i = 1:p
       y = A * y;
     endfor
  endfunction
Apfcn = @(x, p) Ap (A, x, p);
x = gmres (Apfcn, b, [], [], [], [], [], [], 2);</pre> <p><small class="sc">EXAMPLE 9:</small> explicit example to show that <code class="code">gmres</code> uses a left preconditioner </p> <pre class="example" data-language="matlab">[M1, M2] = ilu (A + 0.1 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by gmres after two iterations
[x_ref, fl] = gmres (A, b, [], [], 1, M)

## left preconditioning
[x, fl] = gmres (M \ A, M \ b, [], [], 1)
x # compare x and x_ref</pre> <p>Reference: </p> <p>Y. Saad, <cite class="cite">Iterative Methods for Sparse Linear Systems</cite>, Second edition, 2003, SIAM </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbicg">bicg</a>, <a class="ref" href="#XREFbicgstab">bicgstab</a>, <a class="ref" href="#XREFcgs">cgs</a>, <a class="ref" href="iterative-techniques.html#XREFpcg">pcg</a>, <a class="ref" href="iterative-techniques.html#XREFpcr">pcr</a>, <a class="ref" href="#XREFqmr">qmr</a>, <a class="ref" href="#XREFtfqmr">tfqmr</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-qmr">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">qmr</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">rtol</var>, <var class="var">maxit</var>, <var class="var">M1</var>, <var class="var">M2</var>, <var class="var">x0</var>)</code><a class="copiable-link" href="#index-qmr"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qmr-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">qmr</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">rtol</var>, <var class="var">maxit</var>, <var class="var">P</var>)</code><a class="copiable-link" href="#index-qmr-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-qmr-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">flag</var>, <var class="var">relres</var>, <var class="var">iter</var>, <var class="var">resvec</var>] =</code> <strong class="def-name">qmr</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, …)</code><a class="copiable-link" href="#index-qmr-2"> ¶</a></span>
</dt> <dd>
<p>Solve <code class="code">A x = b</code> using the Quasi-Minimal Residual iterative method (without look-ahead). </p> <ul class="itemize mark-minus"> <li>
<var class="var">rtol</var> is the relative tolerance, if not given or set to [] the default value 1e-6 is used. </li>
<li>
<var class="var">maxit</var> the maximum number of outer iterations, if not given or set to [] the default value <code class="code">min (20, numel (b))</code> is used. </li>
<li>
<var class="var">x0</var> the initial guess, if not given or set to [] the default value <code class="code">zeros (size (b))</code> is used. </li>
</ul> <p><var class="var">A</var> can be passed as a matrix or as a function handle or inline function <code class="code">f</code> such that <code class="code">f(x, "notransp") = A*x</code> and <code class="code">f(x, "transp") = A'*x</code>. </p> <p>The preconditioner <var class="var">P</var> is given as <code class="code">P = M1 * M2</code>. Both <var class="var">M1</var> and <var class="var">M2</var> can be passed as a matrix or as a function handle or inline function <code class="code">g</code> such that <code class="code">g(x, "notransp") = M1 \ x</code> or <code class="code">g(x, "notransp") = M2 \ x</code> and <code class="code">g(x, "transp") = M1' \ x</code> or <code class="code">g(x, "transp") = M2' \ x</code>. </p> <p>If called with more than one output parameter </p> <ul class="itemize mark-minus"> <li>
<var class="var">flag</var> indicates the exit status: <ul class="itemize mark-minus"> <li>0: iteration converged to the within the chosen tolerance </li>
<li>1: the maximum number of iterations was reached before convergence </li>
<li>3: the algorithm reached stagnation </li>
</ul> <p>(the value 2 is unused but skipped for compatibility). </p> </li>
<li>
<var class="var">relres</var> is the final value of the relative residual. </li>
<li>
<var class="var">iter</var> is the number of iterations performed. </li>
<li>
<var class="var">resvec</var> is a vector containing the residual norms at each iteration. </li>
</ul> <p>References: </p> <ol class="enumerate"> <li> R. Freund and N. Nachtigal, <cite class="cite">QMR: a quasi-minimal residual method for non-Hermitian linear systems</cite>, Numerische Mathematik, 1991, 60, pp. 315–339. </li>
<li> R. Barrett, M. Berry, T. Chan, J. Demmel, J. Donato, J. Dongarra, V. Eijkhour, R. Pozo, C. Romine, and H. van der Vorst, <cite class="cite">Templates for the solution of linear systems: Building blocks for iterative methods</cite>, SIAM, 2nd ed., 1994. </li>
</ol> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbicg">bicg</a>, <a class="ref" href="#XREFbicgstab">bicgstab</a>, <a class="ref" href="#XREFcgs">cgs</a>, <a class="ref" href="#XREFgmres">gmres</a>, <a class="ref" href="iterative-techniques.html#XREFpcg">pcg</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-tfqmr">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">tfqmr</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M1</var>, <var class="var">M2</var>, <var class="var">x0</var>, …)</code><a class="copiable-link" href="#index-tfqmr"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-tfqmr-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">tfqmr</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, <var class="var">tol</var>, <var class="var">maxit</var>, <var class="var">M</var>, [], <var class="var">x0</var>, …)</code><a class="copiable-link" href="#index-tfqmr-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-tfqmr-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">x</var>, <var class="var">flag</var>, <var class="var">relres</var>, <var class="var">iter</var>, <var class="var">resvec</var>] =</code> <strong class="def-name">tfqmr</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">b</var>, …)</code><a class="copiable-link" href="#index-tfqmr-2"> ¶</a></span>
</dt> <dd>
<p>Solve <code class="code">A x = b</code> using the Transpose-Tree qmr method, based on the cgs. </p> <p>The input parameters are: </p> <ul class="itemize mark-minus"> <li>
<var class="var">A</var> is the matrix of the linear system and it must be square. <var class="var">A</var> can be passed as a matrix, function handle, or inline function <code class="code">Afcn</code> such that <code class="code">Afcn(x) = A * x</code>. Additional parameters to <code class="code">Afcn</code> are passed after <var class="var">x0</var>. </li>
<li>
<var class="var">b</var> is the right hand side vector. It must be a column vector with the same number of rows as <var class="var">A</var>. </li>
<li>
<var class="var">tol</var> is the relative tolerance, if not given or set to [] the default value 1e-6 is used. </li>
<li>
<var class="var">maxit</var> the maximum number of outer iterations, if not given or set to [] the default value <code class="code">min (20, numel (b))</code> is used. To be compatible, since the method as different behaviors in the iteration number is odd or even, is considered as iteration in <code class="code">tfqmr</code> the entire odd-even cycle. That is, to make an entire iteration, the algorithm performs two sub-iterations: the odd one and the even one. </li>
<li>
<var class="var">M1</var>, <var class="var">M2</var> are the preconditioners. The preconditioner <var class="var">M</var> is given as <code class="code">M = M1 * M2</code>. Both <var class="var">M1</var> and <var class="var">M2</var> can be passed as a matrix or as a function handle or inline function <code class="code">g</code> such that <code class="code">g(x) = M1 \ x</code> or <code class="code">g(x) = M2 \ x</code>. The technique used is the right-preconditioning, i.e., it is solved <code class="code">A*inv(M)*y = b</code> and then <code class="code">x = inv(M)*y</code>, instead of <code class="code">A x = b</code>. </li>
<li>
<var class="var">x0</var> the initial guess, if not given or set to [] the default value <code class="code">zeros (size (b))</code> is used. </li>
</ul> <p>The arguments which follow <var class="var">x0</var> are treated as parameters, and passed in a proper way to any of the functions (<var class="var">A</var> or <var class="var">M</var>) which are passed to <code class="code">tfqmr</code>. </p> <p>The output parameters are: </p> <ul class="itemize mark-minus"> <li>
<var class="var">x</var> is the approximation computed. If the method doesn’t converge then it is the iterated with the minimum residual. </li>
<li>
<var class="var">flag</var> indicates the exit status: <ul class="itemize mark-minus"> <li>0: iteration converged to the within the chosen tolerance </li>
<li>1: the maximum number of iterations was reached before convergence </li>
<li>2: the preconditioner matrix is singular </li>
<li>3: the algorithm reached stagnation </li>
<li>4: the algorithm can’t continue due to a division by zero </li>
</ul> </li>
<li>
<var class="var">relres</var> is the relative residual obtained as <code class="code">(<var class="var">A</var>*<var class="var">x</var>-<var class="var">b</var>) / <code class="code">norm (<var class="var">b</var>)</code></code>. </li>
<li>
<var class="var">iter</var> is the iteration which <var class="var">x</var> is computed. </li>
<li>
<var class="var">resvec</var> is a vector containing the residual at each iteration (including <code class="code">norm (b - A x0)</code>). Doing <code class="code">length (<var class="var">resvec</var>) - 1</code> is possible to see the total number of iterations performed. </li>
</ul> <p>Let us consider a trivial problem with a tridiagonal matrix </p> <pre class="example" data-language="matlab">n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case it corresponds to chol (A)'
M = M1 * M2;
Afcn = @(x) A * x;
Mfcn = @(x) M \ x;
M1fcn = @(x) M1 \ x;
M2fcn = @(x) M2 \ x;</pre> <p><small class="sc">EXAMPLE 1:</small> simplest usage of <code class="code">tfqmr</code> </p> <pre class="example" data-language="matlab">x = tfqmr (A, b, [], n)</pre> <p><small class="sc">EXAMPLE 2:</small> <code class="code">tfqmr</code> with a function which computes <code class="code"><var class="var">A</var> * <var class="var">x</var></code> </p> <pre class="example" data-language="matlab">x = tfqmr (Afcn, b, [], n)</pre> <p><small class="sc">EXAMPLE 3:</small> <code class="code">tfqmr</code> with a preconditioner matrix <var class="var">M</var> </p> <pre class="example" data-language="matlab">x = tfqmr (A, b, [], 1e-06, n, M)</pre> <p><small class="sc">EXAMPLE 4:</small> <code class="code">tfqmr</code> with a function as preconditioner </p> <pre class="example" data-language="matlab">x = tfqmr (Afcn, b, 1e-6, n, Mfcn)</pre> <p><small class="sc">EXAMPLE 5:</small> <code class="code">tfqmr</code> with preconditioner matrices <var class="var">M1</var> and <var class="var">M2</var> </p> <pre class="example" data-language="matlab">x = tfqmr (A, b, [], 1e-6, n, M1, M2)</pre> <p><small class="sc">EXAMPLE 6:</small> <code class="code">tfmqr</code> with functions as preconditioners </p> <pre class="example" data-language="matlab">x = tfqmr (Afcn, b, 1e-6, n, M1fcn, M2fcn)</pre> <p><small class="sc">EXAMPLE 7:</small> <code class="code">tfqmr</code> with as input a function requiring an argument </p> <pre class="example" data-language="matlab">function y = Ap (A, x, z) # compute A^z * x
   y = x;
   for i = 1:z
     y = A * y;
   endfor
 endfunction
Apfcn = @(x, string, p) Ap (A, x, string, p);
x = tfqmr (Apfcn, b, [], [], [], [], [], 2);</pre> <p><small class="sc">EXAMPLE 8:</small> explicit example to show that <code class="code">tfqmr</code> uses a right preconditioner </p> <pre class="example" data-language="matlab">[M1, M2] = ilu (A + 0.3 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by tfqmr after one iteration
[x_ref, fl] = tfqmr (A, b, [], 1, M)

## right preconditioning
[y, fl] = tfqmr (A / M, b, [], 1)
x = M \ y # compare x and x_ref</pre> <p>Reference: </p> <p>Y. Saad, <cite class="cite">Iterative Methods for Sparse Linear Systems</cite>, Second edition, 2003, SIAM </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbicg">bicg</a>, <a class="ref" href="#XREFbicgstab">bicgstab</a>, <a class="ref" href="#XREFcgs">cgs</a>, <a class="ref" href="#XREFgmres">gmres</a>, <a class="ref" href="iterative-techniques.html#XREFpcg">pcg</a>, <a class="ref" href="#XREFqmr">qmr</a>, <a class="ref" href="iterative-techniques.html#XREFpcr">pcr</a>. </p> </dd>
</dl> </div>  <div class="nav-panel"> <p> Previous: <a href="functions-of-a-matrix.html">Functions of a Matrix</a>, Up: <a href="linear-algebra.html">Linear Algebra</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Specialized-Solvers.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Specialized-Solvers.html</a>
  </p>
</div>
