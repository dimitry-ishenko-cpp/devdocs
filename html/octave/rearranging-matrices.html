<div class="section-level-extent" id="Rearranging-Matrices"> <div class="nav-panel"> <p> Next: <a href="special-utility-matrices.html" accesskey="n" rel="next">Special Utility Matrices</a>, Previous: <a href="finding-elements-and-checking-conditions.html" accesskey="p" rel="prev">Finding Elements and Checking Conditions</a>, Up: <a href="matrix-manipulation.html" accesskey="u" rel="up">Matrix Manipulation</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Rearranging-Matrices-1"><span>16.2 Rearranging Matrices<a class="copiable-link" href="#Rearranging-Matrices-1"> ¶</a></span></h1>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-fliplr">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">fliplr</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-fliplr"> ¶</a></span>
</dt> <dd>
<p>Flip array left to right. </p> <p>Return a copy of <var class="var">A</var> with the order of the columns reversed. In other words, <var class="var">A</var> is flipped left-to-right about a vertical axis. For example: </p> <pre class="example" data-language="matlab">fliplr ([1, 2; 3, 4])
     ⇒  2  1
         4  3</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFflipud">flipud</a>, <a class="ref" href="#XREFflip">flip</a>, <a class="ref" href="#XREFrot90">rot90</a>, <a class="ref" href="#XREFrotdim">rotdim</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-flipud">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">flipud</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-flipud"> ¶</a></span>
</dt> <dd>
<p>Flip array upside down. </p> <p>Return a copy of <var class="var">A</var> with the order of the rows reversed. In other words, <var class="var">A</var> is flipped upside-down about a horizontal axis. For example: </p> <pre class="example" data-language="matlab">flipud ([1, 2; 3, 4])
     ⇒  3  4
         1  2</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfliplr">fliplr</a>, <a class="ref" href="#XREFflip">flip</a>, <a class="ref" href="#XREFrot90">rot90</a>, <a class="ref" href="#XREFrotdim">rotdim</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-flip">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">flip</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-flip"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-flip-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">flip</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-flip-1"> ¶</a></span>
</dt> <dd>
<p>Return a copy of array <var class="var">A</var> flipped across dimension <var class="var">dim</var>. </p> <p>If <var class="var">dim</var> is unspecified it defaults to the first non-singleton dimension. </p> <p>Examples: </p> <pre class="example" data-language="matlab">## row vector
flip ([1  2  3  4])
      ⇒  4  3  2  1

## column vector
flip ([1; 2; 3; 4])
      ⇒  4
          3
          2
          1

## 2-D matrix along dimension 1
flip ([1 2; 3 4])
      ⇒  3  4
          1  2

## 2-D matrix along dimension 2
flip ([1 2; 3 4], 2)
      ⇒  2  1
          4  3</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfliplr">fliplr</a>, <a class="ref" href="#XREFflipud">flipud</a>, <a class="ref" href="#XREFrot90">rot90</a>, <a class="ref" href="#XREFrotdim">rotdim</a>, <a class="ref" href="#XREFpermute">permute</a>, <a class="ref" href="arithmetic-ops.html#XREFtranspose">transpose</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-rot90">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">rot90</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-rot90"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-rot90-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">rot90</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-rot90-1"> ¶</a></span>
</dt> <dd>
<p>Rotate array by 90 degree increments. </p> <p>Return a copy of <var class="var">A</var> with the elements rotated counterclockwise in 90-degree increments. </p> <p>The second argument is optional, and specifies how many 90-degree rotations are to be applied (the default value is 1). Negative values of <var class="var">k</var> rotate the matrix in a clockwise direction. For example, </p> <pre class="example" data-language="matlab">rot90 ([1, 2; 3, 4], -1)
    ⇒  3  1
        4  2</pre> <p>rotates the given matrix clockwise by 90 degrees. The following are all equivalent statements: </p> <pre class="example" data-language="matlab">rot90 ([1, 2; 3, 4], -1)
rot90 ([1, 2; 3, 4], 3)
rot90 ([1, 2; 3, 4], 7)</pre> <p>The rotation is always performed on the plane of the first two dimensions, i.e., rows and columns. To perform a rotation on any other plane, use <code class="code">rotdim</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFrotdim">rotdim</a>, <a class="ref" href="#XREFfliplr">fliplr</a>, <a class="ref" href="#XREFflipud">flipud</a>, <a class="ref" href="#XREFflip">flip</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-rotdim">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">rotdim</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-rotdim"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-rotdim-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">rotdim</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-rotdim-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-rotdim-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">rotdim</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">n</var>, <var class="var">plane</var>)</code><a class="copiable-link" href="#index-rotdim-2"> ¶</a></span>
</dt> <dd>
<p>Return a copy of <var class="var">A</var> with the elements rotated counterclockwise in 90-degree increments. </p> <p>The second argument <var class="var">n</var> is optional, and specifies how many 90-degree rotations are to be applied (the default value is 1). Negative values of <var class="var">n</var> rotate the matrix in a clockwise direction. </p> <p>The third argument is also optional and defines the plane of the rotation. If present, <var class="var">plane</var> is a two element vector containing two different valid dimensions of the matrix. When <var class="var">plane</var> is not given the first two non-singleton dimensions are used. </p> <p>For example, </p> <pre class="example" data-language="matlab">rotdim ([1, 2; 3, 4], -1, [1, 2])
     ⇒  3  1
         4  2</pre> <p>rotates the given matrix clockwise by 90 degrees. The following are all equivalent statements: </p> <pre class="example" data-language="matlab">rotdim ([1, 2; 3, 4], -1, [1, 2])
rotdim ([1, 2; 3, 4], 3, [1, 2])
rotdim ([1, 2; 3, 4], 7, [1, 2])</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFrot90">rot90</a>, <a class="ref" href="#XREFfliplr">fliplr</a>, <a class="ref" href="#XREFflipud">flipud</a>, <a class="ref" href="#XREFflip">flip</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-cat">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">cat</strong> <code class="def-code-arguments">(<var class="var">dim</var>, <var class="var">array1</var>, <var class="var">array2</var>, …, <var class="var">arrayN</var>)</code><a class="copiable-link" href="#index-cat"> ¶</a></span>
</dt> <dd>
<p>Return the concatenation of N-D array objects, <var class="var">array1</var>, <var class="var">array2</var>, …, <var class="var">arrayN</var> along dimension <var class="var">dim</var>. </p> <pre class="example" data-language="matlab">A = ones (2, 2);
B = zeros (2, 2);
cat (2, A, B)
  ⇒ 1 1 0 0
     1 1 0 0</pre> <p>Alternatively, we can concatenate <var class="var">A</var> and <var class="var">B</var> along the second dimension in the following way: </p> <pre class="example" data-language="matlab">[A, B]</pre> <p><var class="var">dim</var> can be larger than the dimensions of the N-D array objects and the result will thus have <var class="var">dim</var> dimensions as the following example shows: </p> <pre class="example" data-language="matlab">cat (4, ones (2, 2), zeros (2, 2))
  ⇒ ans(:,:,1,1) =

       1 1
       1 1

     ans(:,:,1,2) =

       0 0
       0 0</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFhorzcat">horzcat</a>, <a class="ref" href="#XREFvertcat">vertcat</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-horzcat">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">horzcat</strong> <code class="def-code-arguments">(<var class="var">array1</var>, <var class="var">array2</var>, …, <var class="var">arrayN</var>)</code><a class="copiable-link" href="#index-horzcat"> ¶</a></span>
</dt> <dd>
<p>Return the horizontal concatenation of N-D array objects, <var class="var">array1</var>, <var class="var">array2</var>, …, <var class="var">arrayN</var> along dimension 2. </p> <p>Arrays may also be concatenated horizontally using the syntax for creating new matrices. For example: </p> <pre class="example" data-language="matlab">A = [ array1, array2, ... ]</pre> <p>This syntax is slightly more efficient because the Octave parser can concatenate the arrays without the overhead of a function call. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcat">cat</a>, <a class="ref" href="#XREFvertcat">vertcat</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-vertcat">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">vertcat</strong> <code class="def-code-arguments">(<var class="var">array1</var>, <var class="var">array2</var>, …, <var class="var">arrayN</var>)</code><a class="copiable-link" href="#index-vertcat"> ¶</a></span>
</dt> <dd>
<p>Return the vertical concatenation of N-D array objects, <var class="var">array1</var>, <var class="var">array2</var>, …, <var class="var">arrayN</var> along dimension 1. </p> <p>Arrays may also be concatenated vertically using the syntax for creating new matrices. For example: </p> <pre class="example" data-language="matlab">A = [ array1; array2; ... ]</pre> <p>This syntax is slightly more efficient because the Octave parser can concatenate the arrays without the overhead of a function call. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcat">cat</a>, <a class="ref" href="#XREFhorzcat">horzcat</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-permute">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">permute</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">perm</var>)</code><a class="copiable-link" href="#index-permute"> ¶</a></span>
</dt> <dd>
<p>Return the generalized transpose for an N-D array object <var class="var">A</var>. </p> <p>The permutation vector <var class="var">perm</var> must contain the elements <code class="code">1:ndims (A)</code> (in any order, but each element must appear only once). The <var class="var">N</var>th dimension of <var class="var">A</var> gets remapped to dimension <code class="code"><var class="var">PERM</var>(<var class="var">N</var>)</code>. For example: </p> <pre class="example" data-language="matlab">x = zeros ([2, 3, 5, 7]);
size (x)
   ⇒  2   3   5   7

size (permute (x, [2, 1, 3, 4]))
   ⇒  3   2   5   7

size (permute (x, [1, 3, 4, 2]))
   ⇒  2   5   7   3

## The identity permutation
size (permute (x, [1, 2, 3, 4]))
   ⇒  2   3   5   7</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFipermute">ipermute</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ipermute">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">ipermute</strong> <code class="def-code-arguments">(<var class="var">B</var>, <var class="var">iperm</var>)</code><a class="copiable-link" href="#index-ipermute"> ¶</a></span>
</dt> <dd>
<p>The inverse of the <code class="code">permute</code> function. </p> <p>The expression </p> <pre class="example" data-language="matlab">ipermute (permute (A, perm), perm)</pre> <p>returns the original array <var class="var">A</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFpermute">permute</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-reshape">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">reshape</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">m</var>, <var class="var">n</var>, …)</code><a class="copiable-link" href="#index-reshape"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reshape-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">reshape</strong> <code class="def-code-arguments">(<var class="var">A</var>, [<var class="var">m</var> <var class="var">n</var> …])</code><a class="copiable-link" href="#index-reshape-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reshape-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">reshape</strong> <code class="def-code-arguments">(<var class="var">A</var>, …, [], …)</code><a class="copiable-link" href="#index-reshape-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reshape-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">reshape</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">size</var>)</code><a class="copiable-link" href="#index-reshape-3"> ¶</a></span>
</dt> <dd>
<p>Return a matrix with the specified dimensions (<var class="var">m</var>, <var class="var">n</var>, …) whose elements are taken from the matrix <var class="var">A</var>. </p> <p>The elements of the matrix are accessed in column-major order (like Fortran arrays are stored). </p> <p>The following code demonstrates reshaping a 1x4 row vector into a 2x2 square matrix. </p> <pre class="example" data-language="matlab">reshape ([1, 2, 3, 4], 2, 2)
      ⇒  1  3
          2  4</pre> <p>Note that the total number of elements in the original matrix (<code class="code">prod (size (<var class="var">A</var>))</code>) must match the total number of elements in the new matrix (<code class="code">prod ([<var class="var">m</var> <var class="var">n</var> …])</code>). </p> <p>A single dimension of the return matrix may be left unspecified and Octave will determine its size automatically. An empty matrix ([]) is used to flag the unspecified dimension. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFresize">resize</a>, <a class="ref" href="#XREFvec">vec</a>, <a class="ref" href="#XREFpostpad">postpad</a>, <a class="ref" href="#XREFcat">cat</a>, <a class="ref" href="object-sizes.html#XREFsqueeze">squeeze</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-resize">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">resize</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">m</var>)</code><a class="copiable-link" href="#index-resize"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-resize-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">resize</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">m</var>, <var class="var">n</var>, …)</code><a class="copiable-link" href="#index-resize-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-resize-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">resize</strong> <code class="def-code-arguments">(<var class="var">A</var>, [<var class="var">m</var> <var class="var">n</var> …])</code><a class="copiable-link" href="#index-resize-2"> ¶</a></span>
</dt> <dd>
<p>Resize <var class="var">A</var> cutting off elements as necessary. </p> <p>In the result, element with certain indices is equal to the corresponding element of <var class="var">A</var> if the indices are within the bounds of <var class="var">A</var>; otherwise, the element is set to zero. </p> <p>In other words, the statement </p> <pre class="example" data-language="matlab">B = resize (A, dv)</pre> <p>is equivalent to the following code: </p> <pre class="example" data-language="matlab">B = zeros (dv, class (A));
sz = min (dv, size (A));
for i = 1:length (sz)
  idx{i} = 1:sz(i);
endfor
B(idx{:}) = A(idx{:});</pre> <p>but is performed more efficiently. </p> <p>If only <var class="var">m</var> is supplied, and it is a scalar, the dimension of the result is <var class="var">m</var>-by-<var class="var">m</var>. If <var class="var">m</var>, <var class="var">n</var>, … are all scalars, then the dimensions of the result are <var class="var">m</var>-by-<var class="var">n</var>-by-…. If given a vector as input, then the dimensions of the result are given by the elements of that vector. </p> <p>An object can be resized to more dimensions than it has; in such case the missing dimensions are assumed to be 1. Resizing an object to fewer dimensions is not possible. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFreshape">reshape</a>, <a class="ref" href="#XREFpostpad">postpad</a>, <a class="ref" href="#XREFprepad">prepad</a>, <a class="ref" href="#XREFcat">cat</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-circshift">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">circshift</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-circshift"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-circshift-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">circshift</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-circshift-1"> ¶</a></span>
</dt> <dd>
<p>Circularly shift the values of the array <var class="var">x</var>. </p> <p><var class="var">n</var> must be a vector of integers no longer than the number of dimensions in <var class="var">x</var>. The values of <var class="var">n</var> can be either positive or negative, which determines the direction in which the values of <var class="var">x</var> are shifted. If an element of <var class="var">n</var> is zero, then the corresponding dimension of <var class="var">x</var> will not be shifted. If <var class="var">n</var> is a scalar and no <var class="var">dim</var> is specified then the shift is applied to the first non-singular dimension. </p> <p>If a scalar <var class="var">dim</var> is given then operate along the specified dimension. In this case <var class="var">n</var> must be a scalar as well. </p> <p>Examples: </p> <pre class="example" data-language="matlab">x = [1, 2, 3;
     4, 5, 6;
     7, 8, 9];
## positive shift on rows (1st non-singular dim)
circshift (x, 1)
  ⇒
       7   8   9
       1   2   3
       4   5   6
## negative shift on rows (1st non-singular dim)
circshift (x, -2)
  ⇒
       7   8   9
       1   2   3
       4   5   6
## no shift of rows, shift columns by 1 (2nd dimension)
circshift (x, [0,1])
  ⇒
       3   1   2
       6   4   5
       9   7   8
## shift columns (2nd dimension)
circshift (x, 1, 2)
  ⇒
       3   1   2
       6   4   5
       9   7   8</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFpermute">permute</a>, <a class="ref" href="#XREFipermute">ipermute</a>, <a class="ref" href="#XREFshiftdim">shiftdim</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-shiftdim">
<span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">shiftdim</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-shiftdim"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-shiftdim-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">y</var>, <var class="var">ns</var>] =</code> <strong class="def-name">shiftdim</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-shiftdim-1"> ¶</a></span>
</dt> <dd>
<p>Shift the dimensions of <var class="var">x</var> by <var class="var">n</var>, where <var class="var">n</var> must be an integer scalar. </p> <p>When <var class="var">n</var> is positive, the dimensions of <var class="var">x</var> are shifted to the left, with the leading dimensions circulated to the end. If <var class="var">n</var> is negative, then the dimensions of <var class="var">x</var> are shifted to the right, with <var class="var">n</var> leading singleton dimensions added. </p> <p>Called with a single argument, <code class="code">shiftdim</code>, removes the leading singleton dimensions, returning the number of dimensions removed in the second output argument <var class="var">ns</var>. </p> <p>For example: </p> <pre class="example" data-language="matlab">x = ones (1, 2, 3);
size (shiftdim (x, -1))
  ⇒   1   1   2   3
size (shiftdim (x, 1))
  ⇒   2   3
[b, ns] = shiftdim (x)
  ⇒ b =
        1   1   1
        1   1   1
  ⇒ ns = 1</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFreshape">reshape</a>, <a class="ref" href="#XREFpermute">permute</a>, <a class="ref" href="#XREFipermute">ipermute</a>, <a class="ref" href="#XREFcircshift">circshift</a>, <a class="ref" href="object-sizes.html#XREFsqueeze">squeeze</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sort">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">i</var>] =</code> <strong class="def-name">sort</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-sort"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sort-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">i</var>] =</code> <strong class="def-name">sort</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-sort-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sort-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">i</var>] =</code> <strong class="def-name">sort</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">mode</var>)</code><a class="copiable-link" href="#index-sort-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sort-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">i</var>] =</code> <strong class="def-name">sort</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>, <var class="var">mode</var>)</code><a class="copiable-link" href="#index-sort-3"> ¶</a></span>
</dt> <dd>
<p>Return a copy of <var class="var">x</var> with the elements arranged in increasing order. </p> <p>For matrices, <code class="code">sort</code> orders the elements within columns </p> <p>For example: </p> <pre class="example" data-language="matlab">sort ([1, 2; 2, 3; 3, 1])
   ⇒  1  1
       2  2
       3  3</pre> <p>If the optional argument <var class="var">dim</var> is given, then the matrix is sorted along the dimension defined by <var class="var">dim</var>. The optional argument <var class="var">mode</var> defines the order in which the values will be sorted. Valid values of <var class="var">mode</var> are <code class="code">"ascend"</code> or <code class="code">"descend"</code>. </p> <p>The <code class="code">sort</code> function may also be used to produce a matrix containing the original row indices of the elements in the sorted matrix. For example: </p> <pre class="example" data-language="matlab">[s, i] = sort ([1, 2; 2, 3; 3, 1])
  ⇒ s = 1  1
         2  2
         3  3
  ⇒ i = 1  3
         2  1
         3  2</pre> <p>For equal elements, the indices are such that equal elements are listed in the order in which they appeared in the original list. </p> <p>Sorting of complex entries is done first by magnitude (<code class="code">abs (<var class="var">z</var>)</code>) and for any ties by phase angle (<code class="code">angle (z)</code>). For example: </p> <pre class="example" data-language="matlab">sort ([1+i; 1; 1-i])
    ⇒ 1 + 0i
       1 - 1i
       1 + 1i</pre> <p>NaN values are treated as being greater than any other value and are sorted to the end of the list. </p> <p>The <code class="code">sort</code> function may also be used to sort strings and cell arrays of strings, in which case ASCII dictionary order (uppercase ’A’ precedes lowercase ’a’) of the strings is used. </p> <p>The algorithm used in <code class="code">sort</code> is optimized for the sorting of partially ordered lists. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsortrows">sortrows</a>, <a class="ref" href="#XREFissorted">issorted</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sortrows">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">i</var>] =</code> <strong class="def-name">sortrows</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-sortrows"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sortrows-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">i</var>] =</code> <strong class="def-name">sortrows</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">c</var>)</code><a class="copiable-link" href="#index-sortrows-1"> ¶</a></span>
</dt> <dd>
<p>Sort the rows of the matrix <var class="var">A</var> according to the order of the columns specified in <var class="var">c</var>. </p> <p>By default (<var class="var">c</var> omitted, or a particular column unspecified in <var class="var">c</var>) an ascending sort order is used. However, if elements of <var class="var">c</var> are negative then the corresponding column is sorted in descending order. If the elements of <var class="var">A</var> are strings then a lexicographical sort is used. </p> <p>Example: sort by column 2 in descending order, then 3 in ascending order </p> <pre class="example" data-language="matlab">x = [ 7, 1, 4;
      8, 3, 5;
      9, 3, 6 ];
sortrows (x, [-2, 3])
   ⇒ 8  3  5
      9  3  6
      7  1  4</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsort">sort</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-issorted">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">issorted</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-issorted"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-issorted-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">issorted</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">mode</var>)</code><a class="copiable-link" href="#index-issorted-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-issorted-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">issorted</strong> <code class="def-code-arguments">(<var class="var">A</var>, "rows", <var class="var">mode</var>)</code><a class="copiable-link" href="#index-issorted-2"> ¶</a></span>
</dt> <dd>
<p>Return true if the vector <var class="var">A</var> is sorted according to <var class="var">mode</var>, which may be either <code class="code">"ascend"</code>, <code class="code">"descend"</code>, or <code class="code">"either"</code>. </p> <p>By default, <var class="var">mode</var> is <code class="code">"ascend"</code>. NaNs are treated in the same manner as <code class="code">sort</code>. </p> <p>If the optional argument <code class="code">"rows"</code> is supplied, check whether the matrix is sorted by rows as output by the function <code class="code">sortrows</code> (with no options). </p> <p>This function does not support sparse matrices. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsort">sort</a>, <a class="ref" href="#XREFsortrows">sortrows</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-nth_005felement">
<span class="category-def">: </span><span><code class="def-type"><var class="var">nel</var> =</code> <strong class="def-name">nth_element</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-nth_005felement"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-nth_005felement-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">nel</var> =</code> <strong class="def-name">nth_element</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-nth_005felement-1"> ¶</a></span>
</dt> <dd>
<p>Select the n-th smallest element of a vector, using the ordering defined by <code class="code">sort</code>. </p> <p>The result is equivalent to <code class="code">sort(<var class="var">x</var>)(<var class="var">n</var>)</code>. </p> <p><var class="var">n</var> can also be a contiguous range, either ascending <code class="code">l:u</code> or descending <code class="code">u:-1:l</code>, in which case a range of elements is returned. </p> <p>If <var class="var">x</var> is an array, <code class="code">nth_element</code> operates along the dimension defined by <var class="var">dim</var>, or the first non-singleton dimension if <var class="var">dim</var> is not given. </p> <p>Programming Note: nth_element encapsulates the C++ standard library algorithms nth_element and partial_sort. On average, the complexity of the operation is O(M*log(K)), where <code class="code">M = size (<var class="var">x</var>, <var class="var">dim</var>)</code> and <code class="code">K = length (<var class="var">n</var>)</code>. This function is intended for cases where the ratio K/M is small; otherwise, it may be better to use <code class="code">sort</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsort">sort</a>, <a class="ref" href="utility-functions.html#XREFmin">min</a>, <a class="ref" href="utility-functions.html#XREFmax">max</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-tril">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A_LO</var> =</code> <strong class="def-name">tril</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-tril"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-tril-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A_LO</var> =</code> <strong class="def-name">tril</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-tril-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-tril-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A_LO</var> =</code> <strong class="def-name">tril</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">k</var>, <var class="var">pack</var>)</code><a class="copiable-link" href="#index-tril-2"> ¶</a></span>
</dt> <dd>
<p>Return a new matrix formed by extracting the lower triangular part of the matrix <var class="var">A</var>, and setting all other elements to zero. </p> <p>The optional second argument specifies how many diagonals above or below the main diagonal should also be set to zero. The default value of <var class="var">k</var> is zero which includes the main diagonal as part of the result. If the value of <var class="var">k</var> is a nonzero integer then the selection of elements starts at an offset of <var class="var">k</var> diagonals above the main diagonal for positive <var class="var">k</var> or below the main diagonal for negative <var class="var">k</var>. The absolute value of <var class="var">k</var> may not be greater than the number of subdiagonals or superdiagonals. </p> <p>Example 1 : exclude main diagonal </p> <pre class="example" data-language="matlab">tril (ones (3), -1)
     ⇒  0  0  0
         1  0  0
         1  1  0</pre> <p>Example 2 : include first superdiagonal </p> <pre class="example" data-language="matlab">tril (ones (3), 1)
     ⇒  1  1  0
         1  1  1
         1  1  1</pre> <p>If the optional third argument <code class="code">"pack"</code> is given then the extracted elements are not inserted into a matrix, but instead stacked column-wise one above another, and returned as a column vector. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFtriu">triu</a>, <a class="ref" href="predicates-for-numeric-objects.html#XREFistril">istril</a>, <a class="ref" href="#XREFdiag">diag</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-triu">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A_UP</var> =</code> <strong class="def-name">triu</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-triu"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-triu-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A_UP</var> =</code> <strong class="def-name">triu</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-triu-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-triu-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A_UP</var> =</code> <strong class="def-name">triu</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">k</var>, <var class="var">pack</var>)</code><a class="copiable-link" href="#index-triu-2"> ¶</a></span>
</dt> <dd>
<p>Return a new matrix formed by extracting the upper triangular part of the matrix <var class="var">A</var>, and setting all other elements to zero. </p> <p>The optional second argument specifies how many diagonals above or below the main diagonal should also be set to zero. The default value of <var class="var">k</var> is zero which includes the main diagonal as part of the result. If the value of <var class="var">k</var> is a nonzero integer then the selection of elements starts at an offset of <var class="var">k</var> diagonals above the main diagonal for positive <var class="var">k</var> or below the main diagonal for negative <var class="var">k</var>. The absolute value of <var class="var">k</var> may not be greater than the number of subdiagonals or superdiagonals. </p> <p>Example 1 : exclude main diagonal </p> <pre class="example" data-language="matlab">triu (ones (3), 1)
     ⇒  0  1  1
         0  0  1
         0  0  0</pre> <p>Example 2 : include first subdiagonal </p> <pre class="example" data-language="matlab">triu (ones (3), -1)
     ⇒  1  1  1
         1  1  1
         0  1  1</pre> <p>If the optional third argument <code class="code">"pack"</code> is given then the extracted elements are not inserted into a matrix, but instead stacked column-wise one above another, and returned as a column vector. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFtril">tril</a>, <a class="ref" href="predicates-for-numeric-objects.html#XREFistriu">istriu</a>, <a class="ref" href="#XREFdiag">diag</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-vec">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">vec</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-vec"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-vec-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">vec</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-vec-1"> ¶</a></span>
</dt> <dd>
<p>Return the vector obtained by stacking the columns of the matrix <var class="var">x</var> one above the other. </p> <p>Without <var class="var">dim</var> this is equivalent to <code class="code"><var class="var">x</var>(:)</code>. </p> <p>If <var class="var">dim</var> is supplied, the dimensions of <var class="var">v</var> are set to <var class="var">dim</var> with all elements along the last dimension. This is equivalent to <code class="code">shiftdim (<var class="var">x</var>(:), 1-<var class="var">dim</var>)</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFvech">vech</a>, <a class="ref" href="#XREFresize">resize</a>, <a class="ref" href="#XREFcat">cat</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-vech">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">vech</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-vech"> ¶</a></span>
</dt> <dd>
<p>Return the vector obtained by eliminating all superdiagonal elements of the square matrix <var class="var">x</var> and stacking the result one column above the other. </p> <p>This has uses in matrix calculus where the underlying matrix is symmetric and it would be pointless to keep values above the main diagonal. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFvec">vec</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-prepad">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">prepad</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">l</var>)</code><a class="copiable-link" href="#index-prepad"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-prepad-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">prepad</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">l</var>, <var class="var">c</var>)</code><a class="copiable-link" href="#index-prepad-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-prepad-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">prepad</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">l</var>, <var class="var">c</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-prepad-2"> ¶</a></span>
</dt> <dd>
<p>Prepend the scalar value <var class="var">c</var> to the vector <var class="var">A</var> until it is of length <var class="var">l</var>. If <var class="var">c</var> is not given, a value of 0 is used. </p> <p>If <code class="code">length (<var class="var">A</var>) &gt; <var class="var">l</var></code>, elements from the beginning of <var class="var">A</var> are removed until a vector of length <var class="var">l</var> is obtained. </p> <p>If <var class="var">A</var> is a matrix, elements are prepended or removed from each row. </p> <p>If the optional argument <var class="var">dim</var> is given, operate along this dimension. </p> <p>If <var class="var">dim</var> is larger than the dimensions of <var class="var">A</var>, the result will have <var class="var">dim</var> dimensions. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFpostpad">postpad</a>, <a class="ref" href="#XREFcat">cat</a>, <a class="ref" href="#XREFresize">resize</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-postpad">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">postpad</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">l</var>)</code><a class="copiable-link" href="#index-postpad"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-postpad-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">postpad</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">l</var>, <var class="var">c</var>)</code><a class="copiable-link" href="#index-postpad-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-postpad-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">postpad</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">l</var>, <var class="var">c</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-postpad-2"> ¶</a></span>
</dt> <dd>
<p>Append the scalar value <var class="var">c</var> to the vector <var class="var">A</var> until it is of length <var class="var">l</var>. If <var class="var">c</var> is not given, a value of 0 is used. </p> <p>If <code class="code">length (<var class="var">A</var>) &gt; <var class="var">l</var></code>, elements from the end of <var class="var">A</var> are removed until a vector of length <var class="var">l</var> is obtained. </p> <p>If <var class="var">A</var> is a matrix, elements are appended or removed from each row. </p> <p>If the optional argument <var class="var">dim</var> is given, operate along this dimension. </p> <p>If <var class="var">dim</var> is larger than the dimensions of <var class="var">A</var>, the result will have <var class="var">dim</var> dimensions. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFprepad">prepad</a>, <a class="ref" href="#XREFcat">cat</a>, <a class="ref" href="#XREFresize">resize</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-diag">
<span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">diag</strong> <code class="def-code-arguments">(<var class="var">v</var>)</code><a class="copiable-link" href="#index-diag"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-diag-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">diag</strong> <code class="def-code-arguments">(<var class="var">v</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-diag-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-diag-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">diag</strong> <code class="def-code-arguments">(<var class="var">v</var>, <var class="var">m</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-diag-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-diag-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">diag</strong> <code class="def-code-arguments">(<var class="var">M</var>)</code><a class="copiable-link" href="#index-diag-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-diag-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">diag</strong> <code class="def-code-arguments">(<var class="var">M</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-diag-4"> ¶</a></span>
</dt> <dd>
<p>Return a diagonal matrix with vector <var class="var">v</var> on diagonal <var class="var">k</var>. </p> <p>The second argument is optional. If it is positive, the vector is placed on the <var class="var">k</var>-th superdiagonal. If it is negative, it is placed on the <var class="var">-k</var>-th subdiagonal. The default value of <var class="var">k</var> is 0, and the vector is placed on the main diagonal. For example: </p> <pre class="example" data-language="matlab">diag ([1, 2, 3], 1)
   ⇒  0  1  0  0
       0  0  2  0
       0  0  0  3
       0  0  0  0</pre> <p>The 3-input form returns a diagonal matrix with vector <var class="var">v</var> on the main diagonal and the resulting matrix being of size <var class="var">m</var> rows x <var class="var">n</var> columns. </p> <p>Given a matrix argument, instead of a vector, <code class="code">diag</code> extracts the <var class="var">k</var>-th diagonal of the matrix. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-blkdiag">
<span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">blkdiag</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, <var class="var">C</var>, …)</code><a class="copiable-link" href="#index-blkdiag"> ¶</a></span>
</dt> <dd>
<p>Build a block diagonal matrix from <var class="var">A</var>, <var class="var">B</var>, <var class="var">C</var>, … </p> <p>All arguments must be numeric and either two-dimensional matrices or scalars. If any argument is of type sparse, the output will also be sparse. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFdiag">diag</a>, <a class="ref" href="#XREFhorzcat">horzcat</a>, <a class="ref" href="#XREFvertcat">vertcat</a>, <a class="ref" href="creating-sparse-matrices.html#XREFsparse">sparse</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="special-utility-matrices.html">Special Utility Matrices</a>, Previous: <a href="finding-elements-and-checking-conditions.html">Finding Elements and Checking Conditions</a>, Up: <a href="matrix-manipulation.html">Matrix Manipulation</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Rearranging-Matrices.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Rearranging-Matrices.html</a>
  </p>
</div>
