<div class="section" id="Automatic-Conversion-of-Data-Types">   <h1 class="section">4.7 Automatic Conversion of Data Types</h1> <p>Many operators and functions can work with mixed data types. For example, </p> <pre class="example" data-language="matlab">uint8 (1) + 1
    ⇒ 2


single (1) + 1
    ⇒ 2


min (single (1), 0)
   ⇒ 0</pre> <p>where the results are respectively of types uint8, single, and single respectively. This is done for <small>MATLAB</small> compatibility. Valid mixed operations are defined as follows: </p> <table> <thead><tr>
<th width="20%"></th>
<th width="30%">Mixed Operation</th>
<th width="30%">Result</th>
<th width="20%"></th>
</tr></thead> <tr>
<td width="20%"></td>
<td width="30%">double OP single</td>
<td width="30%">single</td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%">double OP integer</td>
<td width="30%">integer</td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%">double OP char</td>
<td width="30%">double</td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%">double OP logical</td>
<td width="30%">double</td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%">single OP integer</td>
<td width="30%">integer</td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%">single OP char</td>
<td width="30%">single</td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%">single OP logical</td>
<td width="30%">single</td>
<td width="20%"></td>
</tr> </table> <p>When functions expect a double but are passed other types, automatic conversion is function-dependent: </p> <pre class="example" data-language="matlab">a = det (int8 ([1 2; 3 4]))
    ⇒ a = -2
class (a)
    ⇒ double


a = eig (int8 ([1 2; 3 4]))
    ⇒ error: eig: wrong type argument 'int8 matrix'</pre> <p>When two operands are both integers but of different widths, then some cases convert them to the wider bitwidth, and other cases throw an error: </p> <pre class="example" data-language="matlab">a = min (int8 (100), int16 (200))
    ⇒ 100
class (a)
    ⇒ int16


int8 (100) + int16 (200)
   ⇒ error: binary operator '+' not implemented
   for 'int8 scalar' by 'int16 scalar' operations</pre> <p>For two integer operands, they typically need to both be signed or both be unsigned. Mixing signed and unsigned usually causes an error, even if they are of the same bitwidth. </p> <pre class="example" data-language="matlab">min (int16 (100), uint16 (200))
   ⇒ error: min: cannot compute min (int16 scalar, uint16 scalar)</pre> <p>In the case of mixed type indexed assignments, the type is not changed. For example, </p> <pre class="example" data-language="matlab">x = ones (2, 2);
x(1, 1) = single (2)
   ⇒ x = 2   1
          1   1</pre> <p>where <code>x</code> remains of the double precision type. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Automatic-Conversion-of-Data-Types.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Automatic-Conversion-of-Data-Types.html</a>
  </p>
</div>
