<div class="section-level-extent" id="Interpolation-on-Scattered-Data"> <div class="nav-panel"> <p> Next: <a href="vector-rotation-matrices.html" accesskey="n" rel="next">Vector Rotation Matrices</a>, Previous: <a href="convex-hull.html" accesskey="p" rel="prev">Convex Hull</a>, Up: <a href="geometry.html" accesskey="u" rel="up">Geometry</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Interpolation-on-Scattered-Data-1"><span>30.4 Interpolation on Scattered Data<a class="copiable-link" href="#Interpolation-on-Scattered-Data-1"> ¶</a></span></h1> <p>An important use of the Delaunay tessellation is that it can be used to interpolate from scattered data to an arbitrary set of points. To do this the N-simplex of the known set of points is calculated with <code class="code">delaunay</code> or <code class="code">delaunayn</code>. Then the simplices in to which the desired points are found are identified. Finally the vertices of the simplices are used to interpolate to the desired points. The functions that perform this interpolation are <code class="code">griddata</code>, <code class="code">griddata3</code> and <code class="code">griddatan</code>. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-griddata">
<span class="category-def">: </span><span><code class="def-type"><var class="var">zi</var> =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">xi</var>, <var class="var">yi</var>)</code><a class="copiable-link" href="#index-griddata"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-griddata-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">zi</var> =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">method</var>)</code><a class="copiable-link" href="#index-griddata-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-griddata-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>] =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-griddata-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-griddata-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>)</code><a class="copiable-link" href="#index-griddata-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-griddata-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>, <var class="var">method</var>)</code><a class="copiable-link" href="#index-griddata-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-griddata-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>, <var class="var">method</var>, <var class="var">options</var>)</code><a class="copiable-link" href="#index-griddata-5"> ¶</a></span>
</dt> <dd> <p>Interpolate irregular 2-D and 3-D source data at specified points. </p> <p>For 2-D interpolation, the inputs <var class="var">x</var> and <var class="var">y</var> define the points where the function <code class="code"><var class="var">z</var> = f (<var class="var">x</var>, <var class="var">y</var>)</code> is evaluated. The inputs <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var> are either vectors of the same length, or the unequal vectors <var class="var">x</var>, <var class="var">y</var> are expanded to a 2-D grid with <code class="code">meshgrid</code> and <var class="var">z</var> is a 2-D matrix matching the resulting size of the X-Y grid. </p> <p>The interpolation points are (<var class="var">xi</var>, <var class="var">yi</var>). If, and only if, <var class="var">xi</var> is a row vector and <var class="var">yi</var> is a column vector, then <code class="code">meshgrid</code> will be used to create a mesh of interpolation points. </p> <p>For 3-D interpolation, the inputs <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var> define the points where the function <code class="code"><var class="var">v</var> = f (<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code> is evaluated. The inputs <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var> are either vectors of the same length, or if they are of unequal length, then they are expanded to a 3-D grid with <code class="code">meshgrid</code>. The size of the input <var class="var">v</var> must match the size of the original data, either as a vector or a matrix. </p> <p>The optional input interpolation <var class="var">method</var> can be <code class="code">"nearest"</code>, <code class="code">"linear"</code>, or for 2-D data <code class="code">"v4"</code>. When the method is <code class="code">"nearest"</code>, the output <var class="var">vi</var> will be the closest point in the original data (<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>) to the query point (<var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>). When the method is <code class="code">"linear"</code>, the output <var class="var">vi</var> will be a linear interpolation between the two closest points in the original source data in each dimension. For 2-D cases only, the <code class="code">"v4"</code> method is also available which implements a biharmonic spline interpolation. If <var class="var">method</var> is omitted or empty, it defaults to <code class="code">"linear"</code>. </p> <p>For 3-D interpolation, the optional argument <var class="var">options</var> is passed directly to Qhull when computing the Delaunay triangulation used for interpolation. For more information on the defaults and how to pass different values, see <a class="pxref" href="delaunay-triangulation.html#XREFdelaunayn"><code class="code">delaunayn</code></a>. </p> <p>Programming Notes: If the input is complex the real and imaginary parts are interpolated separately. Interpolation is normally based on a Delaunay triangulation. Any query values outside the convex hull of the input points will return <code class="code">NaN</code>. However, the <code class="code">"v4"</code> method does not use the triangulation and will return values outside the original data (extrapolation). </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgriddata3">griddata3</a>, <a class="ref" href="#XREFgriddatan">griddatan</a>, <a class="ref" href="delaunay-triangulation.html#XREFdelaunay">delaunay</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-griddata3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>)</code><a class="copiable-link" href="#index-griddata3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-griddata3-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>, <var class="var">method</var>)</code><a class="copiable-link" href="#index-griddata3-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-griddata3-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>, <var class="var">method</var>, <var class="var">options</var>)</code><a class="copiable-link" href="#index-griddata3-2"> ¶</a></span>
</dt> <dd> <p>Interpolate irregular 3-D source data at specified points. </p> <p>The inputs <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var> define the points where the function <code class="code"><var class="var">v</var> = f (<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code> is evaluated. The inputs <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var> are either vectors of the same length, or if they are of unequal length, then they are expanded to a 3-D grid with <code class="code">meshgrid</code>. The size of the input <var class="var">v</var> must match the size of the original data, either as a vector or a matrix. </p> <p>The interpolation points are specified by <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>. </p> <p>The optional input interpolation <var class="var">method</var> can be <code class="code">"nearest"</code> or <code class="code">"linear"</code>. When the method is <code class="code">"nearest"</code>, the output <var class="var">vi</var> will be the closest point in the original data (<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>) to the query point (<var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>). When the method is <code class="code">"linear"</code>, the output <var class="var">vi</var> will be a linear interpolation between the two closest points in the original source data in each dimension. If <var class="var">method</var> is omitted or empty, it defaults to <code class="code">"linear"</code>. </p> <p>The optional argument <var class="var">options</var> is passed directly to Qhull when computing the Delaunay triangulation used for interpolation. See <code class="code">delaunayn</code> for information on the defaults and how to pass different values. </p> <p>Programming Notes: If the input is complex the real and imaginary parts are interpolated separately. Interpolation is based on a Delaunay triangulation and any query values outside the convex hull of the input points will return <code class="code">NaN</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgriddata">griddata</a>, <a class="ref" href="#XREFgriddatan">griddatan</a>, <a class="ref" href="delaunay-triangulation.html#XREFdelaunayn">delaunayn</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-griddatan">
<span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">griddatan</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">xi</var>)</code><a class="copiable-link" href="#index-griddatan"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-griddatan-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">griddatan</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">xi</var>, <var class="var">method</var>)</code><a class="copiable-link" href="#index-griddatan-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-griddatan-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">griddatan</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">xi</var>, <var class="var">method</var>, <var class="var">options</var>)</code><a class="copiable-link" href="#index-griddatan-2"> ¶</a></span>
</dt> <dd> <p>Interpolate irregular source data <var class="var">x</var>, <var class="var">y</var> at points specified by <var class="var">xi</var>. </p> <p>The input <var class="var">x</var> is an MxN matrix representing M points in an N-dimensional space. The input <var class="var">y</var> is a single-valued column vector (Mx1) representing a function evaluated at the points <var class="var">x</var>, i.e., <code class="code"><var class="var">y</var> = fcn (<var class="var">x</var>)</code>. The input <var class="var">xi</var> is a list of points for which the function output <var class="var">yi</var> should be approximated through interpolation. <var class="var">xi</var> must have the same number of columns (<var class="var">N</var>) as <var class="var">x</var> so that the dimensionality matches. </p> <p>The optional input interpolation <var class="var">method</var> can be <code class="code">"nearest"</code> or <code class="code">"linear"</code>. When the method is <code class="code">"nearest"</code>, the output <var class="var">yi</var> will be the closest point in the original data <var class="var">x</var> to the query point <var class="var">xi</var>. When the method is <code class="code">"linear"</code>, the output <var class="var">yi</var> will be a linear interpolation between the two closest points in the original source data. If <var class="var">method</var> is omitted or empty, it defaults to <code class="code">"linear"</code>. </p> <p>The optional argument <var class="var">options</var> is passed directly to Qhull when computing the Delaunay triangulation used for interpolation. See <code class="code">delaunayn</code> for information on the defaults and how to pass different values. </p> <p>Example </p> <pre class="example" data-language="matlab">## Evaluate sombrero() function at irregular data points
x = 16*gallery ("uniformdata", [200,1], 1) - 8;
y = 16*gallery ("uniformdata", [200,1], 11) - 8;
z = sin (sqrt (x.^2 + y.^2)) ./ sqrt (x.^2 + y.^2);
## Create a regular grid and interpolate data
[xi, yi] = ndgrid (linspace (-8, 8, 50));
zi = griddatan ([x, y], z, [xi(:), yi(:)]);
zi = reshape (zi, size (xi));
## Plot results
clf ();
plot3 (x, y, z, "or");
hold on
surf (xi, yi, zi);
legend ("Original Data", "Interpolated Data");</pre> <p>Programming Notes: If the input is complex the real and imaginary parts are interpolated separately. Interpolation is based on a Delaunay triangulation and any query values outside the convex hull of the input points will return <code class="code">NaN</code>. For 2-D and 3-D data additional interpolation methods are available by using the <code class="code">griddata</code> function. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgriddata">griddata</a>, <a class="ref" href="#XREFgriddata3">griddata3</a>, <a class="ref" href="delaunay-triangulation.html#XREFdelaunayn">delaunayn</a>. </p>
</dd>
</dl> <p>An example of the use of the <code class="code">griddata</code> function is </p> <pre class="example" data-language="matlab">rand ("state", 1);
x = 2*rand (1000,1) - 1;
y = 2*rand (size (x)) - 1;
z = sin (2*(x.^2+y.^2));
[xx,yy] = meshgrid (linspace (-1,1,32));
zz = griddata (x, y, z, xx, yy);
mesh (xx, yy, zz);</pre> <p>that interpolates from a random scattering of points, to a uniform grid. The output of the above can be seen in <a class="ref" href="#fig_003agriddata">Figure 30.6</a>. </p> <div class="float" id="fig_003agriddata"> <div class="center">
<img class="image" src="https://docs.octave.org/v9.2.0/griddata.png" alt="griddata"> </div>
<div class="caption"><p><strong class="strong">Figure 30.6: </strong>Interpolation from a scattered data to a regular grid</p></div>
</div> </div>  <div class="nav-panel"> <p> Next: <a href="vector-rotation-matrices.html">Vector Rotation Matrices</a>, Previous: <a href="convex-hull.html">Convex Hull</a>, Up: <a href="geometry.html">Geometry</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Interpolation-on-Scattered-Data.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Interpolation-on-Scattered-Data.html</a>
  </p>
</div>
