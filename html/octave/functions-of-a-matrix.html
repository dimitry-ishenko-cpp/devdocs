<div class="section" id="Functions-of-a-Matrix">   <h1 class="section">18.4 Functions of a Matrix</h1>  <dl class="def"> <dt id="index-expm">
<span class="category">: </span><span><em><var>r</var> =</em> <strong>expm</strong> <em>(<var>A</var>)</em><a href="#index-expm" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the exponential of a matrix. </p> <p>The matrix exponential is defined as the infinite Taylor series </p> <pre class="example" data-language="matlab">expm (A) = I + A + A^2/2! + A^3/3! + …</pre> <p>However, the Taylor series is <em>not</em> the way to compute the matrix exponential; see Moler and Van Loan, <cite>Nineteen Dubious Ways to Compute the Exponential of a Matrix</cite>, SIAM Review, 1978. This routine uses Ward’s diagonal Padé approximation method with three step preconditioning (SIAM Journal on Numerical Analysis, 1977). Diagonal Padé approximations are rational polynomials of matrices </p> <pre class="example" data-language="matlab">-1
D (A)   N (A)</pre> <p>whose Taylor series matches the first <code>2q+1</code> terms of the Taylor series above; direct evaluation of the Taylor series (with the same preconditioning steps) may be desirable in lieu of the Padé approximation when <code>Dq(A)</code> is ill-conditioned. </p> <p><strong>See also:</strong> <a href="#XREFlogm">logm</a>, <a href="#XREFsqrtm">sqrtm</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-logm">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>logm</strong> <em>(<var>A</var>)</em><a href="#index-logm" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-logm-1">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>logm</strong> <em>(<var>A</var>, <var>opt_iters</var>)</em><a href="#index-logm-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-logm-2">
<span class="category">: </span><span><em>[<var>s</var>, <var>iters</var>] =</em> <strong>logm</strong> <em>(…)</em><a href="#index-logm-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the matrix logarithm of the square matrix <var>A</var>. </p> <p>The implementation utilizes a Padé approximant and the identity </p> <pre class="example" data-language="matlab">logm (A) = 2^k * logm (A^(1 / 2^k))</pre> <p>The optional input <var>opt_iters</var> is the maximum number of square roots to compute and defaults to 100. </p> <p>The optional output <var>iters</var> is the number of square roots actually computed. </p> <p><strong>See also:</strong> <a href="#XREFexpm">expm</a>, <a href="#XREFsqrtm">sqrtm</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sqrtm">
<span class="category">: </span><span><em><var>s</var> =</em> <strong>sqrtm</strong> <em>(<var>A</var>)</em><a href="#index-sqrtm" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sqrtm-1">
<span class="category">: </span><span><em>[<var>s</var>, <var>error_estimate</var>] =</em> <strong>sqrtm</strong> <em>(<var>A</var>)</em><a href="#index-sqrtm-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the matrix square root of the square matrix <var>A</var>. </p> <p>Ref: N.J. Higham. <cite>A New sqrtm for <small>MATLAB</small></cite>. Numerical Analysis Report No. 336, Manchester Centre for Computational Mathematics, Manchester, England, January 1999. </p> <p><strong>See also:</strong> <a href="#XREFexpm">expm</a>, <a href="#XREFlogm">logm</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-kron">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>kron</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-kron" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-kron-1">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>kron</strong> <em>(<var>A1</var>, <var>A2</var>, …)</em><a href="#index-kron-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Form the Kronecker product of two or more matrices. </p> <p>This is defined block by block as </p> <pre class="example" data-language="matlab">c = [ a(i,j)*b ]</pre> <p>For example: </p> <pre class="example" data-language="matlab">kron (1:4, ones (3, 1))
     ⇒  1  2  3  4
         1  2  3  4
         1  2  3  4</pre> <p>If there are more than two input arguments <var>A1</var>, <var>A2</var>, …, <var>An</var> the Kronecker product is computed as </p> <pre class="example" data-language="matlab">kron (kron (A1, A2), …, An)</pre> <p>Since the Kronecker product is associative, this is well-defined. </p>
</dd>
</dl> <dl class="def"> <dt id="index-blkmm">
<span class="category">: </span><span><em><var>C</var> =</em> <strong>blkmm</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-blkmm" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute products of matrix blocks. </p> <p>The blocks are given as 2-dimensional subarrays of the arrays <var>A</var>, <var>B</var>. The size of <var>A</var> must have the form <code>[m,k,…]</code> and size of <var>B</var> must be <code>[k,n,…]</code>. The result is then of size <code>[m,n,…]</code> and is computed as follows: </p> <pre class="example" data-language="matlab">for i = 1:prod (size (A)(3:end))
  C(:,:,i) = A(:,:,i) * B(:,:,i)
endfor</pre> </dd>
</dl> <dl class="def"> <dt id="index-sylvester">
<span class="category">: </span><span><em><var>X</var> =</em> <strong>sylvester</strong> <em>(<var>A</var>, <var>B</var>, <var>C</var>)</em><a href="#index-sylvester" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Solve the Sylvester equation. </p> <p>The Sylvester equation is defined as: </p> <pre class="example" data-language="matlab">A X + X B = C</pre> <p>The solution is computed using standard <small>LAPACK</small> subroutines. </p> <p>For example: </p> <pre class="example" data-language="matlab">sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])
   ⇒ [ 0.50000, 0.66667; 0.66667, 0.50000 ]</pre> </dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Functions-of-a-Matrix.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Functions-of-a-Matrix.html</a>
  </p>
</div>
