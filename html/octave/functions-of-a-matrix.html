<div class="section-level-extent" id="Functions-of-a-Matrix"> <div class="nav-panel"> <p> Next: <a href="specialized-solvers.html" accesskey="n" rel="next">Specialized Solvers</a>, Previous: <a href="matrix-factorizations.html" accesskey="p" rel="prev">Matrix Factorizations</a>, Up: <a href="linear-algebra.html" accesskey="u" rel="up">Linear Algebra</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Functions-of-a-Matrix-1"><span>18.4 Functions of a Matrix<a class="copiable-link" href="#Functions-of-a-Matrix-1"> ¶</a></span></h1>   <dl class="first-deftypefn"> <dt class="deftypefn" id="index-expm">
<span class="category-def">: </span><span><code class="def-type"><var class="var">r</var> =</code> <strong class="def-name">expm</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-expm"> ¶</a></span>
</dt> <dd>
<p>Return the exponential of a matrix. </p> <p>The matrix exponential is defined as the infinite Taylor series </p> <pre class="example" data-language="matlab">expm (A) = I + A + A^2/2! + A^3/3! + ...</pre> <p>However, the Taylor series is <em class="emph">not</em> the way to compute the matrix exponential; see Moler and Van Loan, <cite class="cite">Nineteen Dubious Ways to Compute the Exponential of a Matrix</cite>, SIAM Review, 1978. This routine uses Ward’s diagonal Padé approximation method with three step preconditioning (SIAM Journal on Numerical Analysis, 1977). Diagonal Padé approximations are rational polynomials of matrices </p> <pre class="example" data-language="matlab">-1
D (A)   N (A)</pre> <p>whose Taylor series matches the first <code class="code">2q+1</code> terms of the Taylor series above; direct evaluation of the Taylor series (with the same preconditioning steps) may be desirable in lieu of the Padé approximation when <code class="code">Dq(A)</code> is ill-conditioned. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFlogm">logm</a>, <a class="ref" href="#XREFsqrtm">sqrtm</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-logm">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">logm</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-logm"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-logm-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">logm</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">opt_iters</var>)</code><a class="copiable-link" href="#index-logm-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-logm-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">iters</var>] =</code> <strong class="def-name">logm</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-logm-2"> ¶</a></span>
</dt> <dd>
<p>Compute the matrix logarithm of the square matrix <var class="var">A</var>. </p> <p>The implementation utilizes a Padé approximant and the identity </p> <pre class="example" data-language="matlab">logm (A) = 2^k * logm (A^(1 / 2^k))</pre> <p>The optional input <var class="var">opt_iters</var> is the maximum number of square roots to compute and defaults to 100. </p> <p>The optional output <var class="var">iters</var> is the number of square roots actually computed. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFexpm">expm</a>, <a class="ref" href="#XREFsqrtm">sqrtm</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sqrtm">
<span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">sqrtm</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-sqrtm"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-sqrtm-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">s</var>, <var class="var">error_estimate</var>] =</code> <strong class="def-name">sqrtm</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-sqrtm-1"> ¶</a></span>
</dt> <dd>
<p>Compute the matrix square root of the square matrix <var class="var">A</var>. </p> <p>Ref: N.J. Higham. <cite class="cite">A New sqrtm for <small class="sc">MATLAB</small></cite>. Numerical Analysis Report No. 336, Manchester Centre for Computational Mathematics, Manchester, England, January 1999. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFexpm">expm</a>, <a class="ref" href="#XREFlogm">logm</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-kron">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">kron</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-kron"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-kron-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">kron</strong> <code class="def-code-arguments">(<var class="var">A1</var>, <var class="var">A2</var>, …)</code><a class="copiable-link" href="#index-kron-1"> ¶</a></span>
</dt> <dd>
<p>Form the Kronecker product of two or more matrices. </p> <p>This is defined block by block as </p> <pre class="example" data-language="matlab">c = [ a(i,j)*b ]</pre> <p>For example: </p> <pre class="example" data-language="matlab">kron (1:4, ones (3, 1))
     ⇒  1  2  3  4
         1  2  3  4
         1  2  3  4</pre> <p>If there are more than two input arguments <var class="var">A1</var>, <var class="var">A2</var>, …, <var class="var">An</var> the Kronecker product is computed as </p> <pre class="example" data-language="matlab">kron (kron (A1, A2), ..., An)</pre> <p>Since the Kronecker product is associative, this is well-defined. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFtensorprod">tensorprod</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-tensorprod">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">tensorprod</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, <var class="var">dimA</var>, <var class="var">dimB</var>)</code><a class="copiable-link" href="#index-tensorprod"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-tensorprod-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">tensorprod</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-tensorprod-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-tensorprod-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">tensorprod</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-tensorprod-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-tensorprod-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">tensorprod</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, "all")</code><a class="copiable-link" href="#index-tensorprod-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-tensorprod-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">tensorprod</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, …, "NumDimensionsA", <var class="var">value</var>)</code><a class="copiable-link" href="#index-tensorprod-4"> ¶</a></span>
</dt> <dd>
<p>Compute the tensor product between numeric tensors <var class="var">A</var> and <var class="var">B</var>. </p> <p>The dimensions of <var class="var">A</var> and <var class="var">B</var> that are contracted are defined by <var class="var">dimA</var> and <var class="var">dimB</var>, respectively. <var class="var">dimA</var> and <var class="var">dimB</var> are scalars or equal length vectors that define the dimensions to match up. The matched dimensions of <var class="var">A</var> and <var class="var">B</var> must have the same number of elements. </p> <p>When only <var class="var">dim</var> is used, it is equivalent to <code class="code"><var class="var">dimA</var> = <var class="var">dimB</var> = <var class="var">dim</var></code>. </p> <p>When no dimensions are specified, <code class="code"><var class="var">dimA</var> = <var class="var">dimB</var> = []</code>. This computes the outer product between <var class="var">A</var> and <var class="var">B</var>. </p> <p>Using the <code class="code">"all"</code> option results in the inner product between <var class="var">A</var> and <var class="var">B</var>. This requires <code class="code">size (<var class="var">A</var>) == size (<var class="var">B</var>)</code>. </p> <p>Use the property-value pair with the property name <code class="code">"NumDimensionsA"</code> when <var class="var">A</var> has trailing singleton dimensions that should be transferred to <var class="var">C</var>. The specified <var class="var">value</var> should be the total number of dimensions of <var class="var">A</var>. </p> <p><small class="sc">MATLAB</small> Compatibility: Octave does not currently support the <code class="code">"<var class="var">property_name</var>=<var class="var">value</var>"</code> syntax for the <code class="code">"NumDimensionsA"</code> parameter. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFkron">kron</a>, <a class="ref" href="utility-functions.html#XREFdot">dot</a>, <a class="ref" href="arithmetic-ops.html#XREFmtimes">mtimes</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-blkmm">
<span class="category-def">: </span><span><code class="def-type"><var class="var">C</var> =</code> <strong class="def-name">blkmm</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-blkmm"> ¶</a></span>
</dt> <dd>
<p>Compute products of matrix blocks. </p> <p>The blocks are given as 2-dimensional subarrays of the arrays <var class="var">A</var>, <var class="var">B</var>. The size of <var class="var">A</var> must have the form <code class="code">[m,k,…]</code> and size of <var class="var">B</var> must be <code class="code">[k,n,…]</code>. The result is then of size <code class="code">[m,n,…]</code> and is computed as follows: </p> <pre class="example" data-language="matlab">for i = 1:prod (size (A)(3:end))
  C(:,:,i) = A(:,:,i) * B(:,:,i)
endfor</pre> </dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-sylvester">
<span class="category-def">: </span><span><code class="def-type"><var class="var">X</var> =</code> <strong class="def-name">sylvester</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, <var class="var">C</var>)</code><a class="copiable-link" href="#index-sylvester"> ¶</a></span>
</dt> <dd>
<p>Solve the Sylvester equation. </p> <p>The Sylvester equation is defined as: </p> <pre class="example" data-language="matlab">A X + X B = C</pre> <p>The solution is computed using standard <small class="sc">LAPACK</small> subroutines. </p> <p>For example: </p> <pre class="example" data-language="matlab">sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])
   ⇒ [ 0.50000, 0.66667; 0.66667, 0.50000 ]</pre> </dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="specialized-solvers.html">Specialized Solvers</a>, Previous: <a href="matrix-factorizations.html">Matrix Factorizations</a>, Up: <a href="linear-algebra.html">Linear Algebra</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Functions-of-a-Matrix.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Functions-of-a-Matrix.html</a>
  </p>
</div>
