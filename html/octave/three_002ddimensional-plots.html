<div class="subsection-level-extent" id="Three_002dDimensional-Plots"> <div class="nav-panel"> <p> Next: <a href="plot-annotations.html" accesskey="n" rel="next">Plot Annotations</a>, Previous: <a href="two_002ddimensional-plots.html" accesskey="p" rel="prev">Two-Dimensional Plots</a>, Up: <a href="high_002dlevel-plotting.html" accesskey="u" rel="up">High-Level Plotting</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="Three_002dDimensional-Plots-1"><span>15.2.2 Three-Dimensional Plots<a class="copiable-link" href="#Three_002dDimensional-Plots-1"> ¶</a></span></h1>  <p>The function <code class="code">mesh</code> produces mesh surface plots. For example, </p> <pre class="example" data-language="matlab">tx = ty = linspace (-8, 8, 41)';
[xx, yy] = meshgrid (tx, ty);
r = sqrt (xx .^ 2 + yy .^ 2) + eps;
tz = sin (r) ./ r;
mesh (tx, ty, tz);
xlabel ("tx");
ylabel ("ty");
zlabel ("tz");
title ("3-D Sombrero plot");</pre> <p>produces the familiar “sombrero” plot shown in <a class="ref" href="#fig_003amesh">Figure 15.5</a>. Note the use of the function <code class="code">meshgrid</code> to create matrices of X and Y coordinates to use for plotting the Z data. The <code class="code">ndgrid</code> function is similar to <code class="code">meshgrid</code>, but works for N-dimensional matrices. </p> <div class="float" id="fig_003amesh"> <div class="center">
<img class="image" src="https://docs.octave.org/v9.2.0/mesh.png" alt="mesh"> </div>
<div class="caption"><p><strong class="strong">Figure 15.5: </strong>Mesh plot.</p></div>
</div> <p>The <code class="code">meshc</code> function is similar to <code class="code">mesh</code>, but also produces a plot of contours for the surface. </p> <p>The <code class="code">plot3</code> function displays arbitrary three-dimensional data, without requiring it to form a surface. For example, </p> <pre class="example" data-language="matlab">t = 0:0.1:10*pi;
r = linspace (0, 1, numel (t));
z = linspace (0, 1, numel (t));
plot3 (r.*sin (t), r.*cos (t), z);
xlabel ("r.*sin (t)");
ylabel ("r.*cos (t)");
zlabel ("z");
title ("plot3 display of 3-D helix");</pre> <p>displays the spiral in three dimensions shown in <a class="ref" href="#fig_003aplot3">Figure 15.6</a>. </p> <div class="float" id="fig_003aplot3"> <div class="center">
<img class="image" src="data:image/png;base64,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" alt="plot3"> </div>
<div class="caption"><p><strong class="strong">Figure 15.6: </strong>Three-dimensional spiral.</p></div>
</div> <p>Finally, the <code class="code">view</code> function changes the viewpoint for three-dimensional plots. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-mesh">
<span class="category-def">: </span><span><strong class="def-name">mesh</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-mesh"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mesh-1">
<span class="category-def">: </span><span><strong class="def-name">mesh</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-mesh-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mesh-2">
<span class="category-def">: </span><span><strong class="def-name">mesh</strong> <code class="def-code-arguments">(…, <var class="var">c</var>)</code><a class="copiable-link" href="#index-mesh-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mesh-3">
<span class="category-def">: </span><span><strong class="def-name">mesh</strong> <code class="def-code-arguments">(…, <var class="var">prop</var>, <var class="var">val</var>, …)</code><a class="copiable-link" href="#index-mesh-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mesh-4">
<span class="category-def">: </span><span><strong class="def-name">mesh</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-mesh-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-mesh-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">mesh</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-mesh-5"> ¶</a></span>
</dt> <dd>
<p>Plot a 3-D wireframe mesh. </p> <p>The wireframe mesh is plotted using rectangles. The vertices of the rectangles [<var class="var">x</var>, <var class="var">y</var>] are typically the output of <code class="code">meshgrid</code>. over a 2-D rectangular region in the x-y plane. <var class="var">z</var> determines the height above the plane of each vertex. If only a single <var class="var">z</var> matrix is given, then it is plotted over the meshgrid <code class="code"><var class="var">x</var> = 1:columns (<var class="var">z</var>), <var class="var">y</var> = 1:rows (<var class="var">z</var>)</code>. Thus, columns of <var class="var">z</var> correspond to different <var class="var">x</var> values and rows of <var class="var">z</var> correspond to different <var class="var">y</var> values. </p> <p>The color of the mesh is computed by linearly scaling the <var class="var">z</var> values to fit the range of the current colormap. Use <code class="code">caxis</code> and/or change the colormap to control the appearance. </p> <p>Optionally, the color of the mesh can be specified independently of <var class="var">z</var> by supplying a color matrix, <var class="var">c</var>. </p> <p>Any property/value pairs are passed directly to the underlying surface object. The full list of properties is documented at <a class="ref" href="surface-properties.html">Surface Properties</a>. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a graphics handle to the created surface object. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="three_002ddimensional-function-plotting.html#XREFezmesh">ezmesh</a>, <a class="ref" href="#XREFmeshc">meshc</a>, <a class="ref" href="#XREFmeshz">meshz</a>, <a class="ref" href="plotting-the-triangulation.html#XREFtrimesh">trimesh</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFcontour">contour</a>, <a class="ref" href="#XREFsurf">surf</a>, <a class="ref" href="graphics-objects.html#XREFsurface">surface</a>, <a class="ref" href="#XREFmeshgrid">meshgrid</a>, <a class="ref" href="#XREFhidden">hidden</a>, <a class="ref" href="#XREFshading">shading</a>, <a class="ref" href="representing-images.html#XREFcolormap">colormap</a>, <a class="ref" href="axis-configuration.html#XREFcaxis">caxis</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-meshc">
<span class="category-def">: </span><span><strong class="def-name">meshc</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-meshc"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshc-1">
<span class="category-def">: </span><span><strong class="def-name">meshc</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-meshc-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshc-2">
<span class="category-def">: </span><span><strong class="def-name">meshc</strong> <code class="def-code-arguments">(…, <var class="var">c</var>)</code><a class="copiable-link" href="#index-meshc-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshc-3">
<span class="category-def">: </span><span><strong class="def-name">meshc</strong> <code class="def-code-arguments">(…, <var class="var">prop</var>, <var class="var">val</var>, …)</code><a class="copiable-link" href="#index-meshc-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshc-4">
<span class="category-def">: </span><span><strong class="def-name">meshc</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-meshc-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshc-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">meshc</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-meshc-5"> ¶</a></span>
</dt> <dd>
<p>Plot a 3-D wireframe mesh with underlying contour lines. </p> <p>The wireframe mesh is plotted using rectangles. The vertices of the rectangles [<var class="var">x</var>, <var class="var">y</var>] are typically the output of <code class="code">meshgrid</code>. over a 2-D rectangular region in the x-y plane. <var class="var">z</var> determines the height above the plane of each vertex. If only a single <var class="var">z</var> matrix is given, then it is plotted over the meshgrid <code class="code"><var class="var">x</var> = 1:columns (<var class="var">z</var>), <var class="var">y</var> = 1:rows (<var class="var">z</var>)</code>. Thus, columns of <var class="var">z</var> correspond to different <var class="var">x</var> values and rows of <var class="var">z</var> correspond to different <var class="var">y</var> values. </p> <p>The color of the mesh is computed by linearly scaling the <var class="var">z</var> values to fit the range of the current colormap. Use <code class="code">caxis</code> and/or change the colormap to control the appearance. </p> <p>Optionally the color of the mesh can be specified independently of <var class="var">z</var> by supplying a color matrix, <var class="var">c</var>. </p> <p>Any property/value pairs are passed directly to the underlying surface object. The full list of properties is documented at <a class="ref" href="surface-properties.html">Surface Properties</a>. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a 2-element vector with a graphics handle to the created surface object and to the created contour plot. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="three_002ddimensional-function-plotting.html#XREFezmeshc">ezmeshc</a>, <a class="ref" href="#XREFmesh">mesh</a>, <a class="ref" href="#XREFmeshz">meshz</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFcontour">contour</a>, <a class="ref" href="#XREFsurfc">surfc</a>, <a class="ref" href="graphics-objects.html#XREFsurface">surface</a>, <a class="ref" href="#XREFmeshgrid">meshgrid</a>, <a class="ref" href="#XREFhidden">hidden</a>, <a class="ref" href="#XREFshading">shading</a>, <a class="ref" href="representing-images.html#XREFcolormap">colormap</a>, <a class="ref" href="axis-configuration.html#XREFcaxis">caxis</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-meshz">
<span class="category-def">: </span><span><strong class="def-name">meshz</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-meshz"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshz-1">
<span class="category-def">: </span><span><strong class="def-name">meshz</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-meshz-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshz-2">
<span class="category-def">: </span><span><strong class="def-name">meshz</strong> <code class="def-code-arguments">(…, <var class="var">c</var>)</code><a class="copiable-link" href="#index-meshz-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshz-3">
<span class="category-def">: </span><span><strong class="def-name">meshz</strong> <code class="def-code-arguments">(…, <var class="var">prop</var>, <var class="var">val</var>, …)</code><a class="copiable-link" href="#index-meshz-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshz-4">
<span class="category-def">: </span><span><strong class="def-name">meshz</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-meshz-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshz-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">meshz</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-meshz-5"> ¶</a></span>
</dt> <dd>
<p>Plot a 3-D wireframe mesh with a surrounding curtain. </p> <p>The wireframe mesh is plotted using rectangles. The vertices of the rectangles [<var class="var">x</var>, <var class="var">y</var>] are typically the output of <code class="code">meshgrid</code>. over a 2-D rectangular region in the x-y plane. <var class="var">z</var> determines the height above the plane of each vertex. If only a single <var class="var">z</var> matrix is given, then it is plotted over the meshgrid <code class="code"><var class="var">x</var> = 1:columns (<var class="var">z</var>), <var class="var">y</var> = 1:rows (<var class="var">z</var>)</code>. Thus, columns of <var class="var">z</var> correspond to different <var class="var">x</var> values and rows of <var class="var">z</var> correspond to different <var class="var">y</var> values. </p> <p>The color of the mesh is computed by linearly scaling the <var class="var">z</var> values to fit the range of the current colormap. Use <code class="code">caxis</code> and/or change the colormap to control the appearance. </p> <p>Optionally the color of the mesh can be specified independently of <var class="var">z</var> by supplying a color matrix, <var class="var">c</var>. </p> <p>Any property/value pairs are passed directly to the underlying surface object. The full list of properties is documented at <a class="ref" href="surface-properties.html">Surface Properties</a>. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a graphics handle to the created surface object. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmesh">mesh</a>, <a class="ref" href="#XREFmeshc">meshc</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFcontour">contour</a>, <a class="ref" href="#XREFsurf">surf</a>, <a class="ref" href="graphics-objects.html#XREFsurface">surface</a>, <a class="ref" href="#XREFwaterfall">waterfall</a>, <a class="ref" href="#XREFmeshgrid">meshgrid</a>, <a class="ref" href="#XREFhidden">hidden</a>, <a class="ref" href="#XREFshading">shading</a>, <a class="ref" href="representing-images.html#XREFcolormap">colormap</a>, <a class="ref" href="axis-configuration.html#XREFcaxis">caxis</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-hidden">
<span class="category-def">: </span><span><strong class="def-name">hidden</strong><a class="copiable-link" href="#index-hidden"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-hidden-1">
<span class="category-def">: </span><span><strong class="def-name">hidden</strong> <code class="def-code-arguments">on</code><a class="copiable-link" href="#index-hidden-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-hidden-2">
<span class="category-def">: </span><span><strong class="def-name">hidden</strong> <code class="def-code-arguments">off</code><a class="copiable-link" href="#index-hidden-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-hidden-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">mode</var> =</code> <strong class="def-name">hidden</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-hidden-3"> ¶</a></span>
</dt> <dd>
<p>Control mesh hidden line removal. </p> <p>When called with no argument the hidden line removal state is toggled. </p> <p>When called with one of the modes <code class="code">"on"</code> or <code class="code">"off"</code> the state is set accordingly. </p> <p>The optional output argument <var class="var">mode</var> is the current state. </p> <p>Hidden Line Removal determines what graphic objects behind a mesh plot are visible. The default is for the mesh to be opaque and lines behind the mesh are not visible. If hidden line removal is turned off then objects behind the mesh can be seen through the faces (openings) of the mesh, although the mesh grid lines are still opaque. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmesh">mesh</a>, <a class="ref" href="#XREFmeshc">meshc</a>, <a class="ref" href="#XREFmeshz">meshz</a>, <a class="ref" href="three_002ddimensional-function-plotting.html#XREFezmesh">ezmesh</a>, <a class="ref" href="three_002ddimensional-function-plotting.html#XREFezmeshc">ezmeshc</a>, <a class="ref" href="plotting-the-triangulation.html#XREFtrimesh">trimesh</a>, <a class="ref" href="#XREFwaterfall">waterfall</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-surf">
<span class="category-def">: </span><span><strong class="def-name">surf</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-surf"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surf-1">
<span class="category-def">: </span><span><strong class="def-name">surf</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-surf-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surf-2">
<span class="category-def">: </span><span><strong class="def-name">surf</strong> <code class="def-code-arguments">(…, <var class="var">c</var>)</code><a class="copiable-link" href="#index-surf-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surf-3">
<span class="category-def">: </span><span><strong class="def-name">surf</strong> <code class="def-code-arguments">(…, <var class="var">prop</var>, <var class="var">val</var>, …)</code><a class="copiable-link" href="#index-surf-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surf-4">
<span class="category-def">: </span><span><strong class="def-name">surf</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-surf-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surf-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">surf</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-surf-5"> ¶</a></span>
</dt> <dd>
<p>Plot a 3-D surface mesh. </p> <p>The surface mesh is plotted using shaded rectangles. The vertices of the rectangles [<var class="var">x</var>, <var class="var">y</var>] are typically the output of <code class="code">meshgrid</code>. over a 2-D rectangular region in the x-y plane. <var class="var">z</var> determines the height above the plane of each vertex. If only a single <var class="var">z</var> matrix is given, then it is plotted over the meshgrid <code class="code"><var class="var">x</var> = 1:columns (<var class="var">z</var>), <var class="var">y</var> = 1:rows (<var class="var">z</var>)</code>. Thus, columns of <var class="var">z</var> correspond to different <var class="var">x</var> values and rows of <var class="var">z</var> correspond to different <var class="var">y</var> values. </p> <p>The color of the surface is computed by linearly scaling the <var class="var">z</var> values to fit the range of the current colormap. Use <code class="code">caxis</code> and/or change the colormap to control the appearance. </p> <p>Optionally, the color of the surface can be specified independently of <var class="var">z</var> by supplying a color matrix, <var class="var">c</var>. </p> <p>Any property/value pairs are passed directly to the underlying surface object. The full list of properties is documented at <a class="ref" href="surface-properties.html">Surface Properties</a>. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a graphics handle to the created surface object. </p> <p>Note: The exact appearance of the surface can be controlled with the <code class="code">shading</code> command or by using <code class="code">set</code> to control surface object properties. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="three_002ddimensional-function-plotting.html#XREFezsurf">ezsurf</a>, <a class="ref" href="#XREFsurfc">surfc</a>, <a class="ref" href="#XREFsurfl">surfl</a>, <a class="ref" href="#XREFsurfnorm">surfnorm</a>, <a class="ref" href="plotting-the-triangulation.html#XREFtrisurf">trisurf</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFcontour">contour</a>, <a class="ref" href="#XREFmesh">mesh</a>, <a class="ref" href="graphics-objects.html#XREFsurface">surface</a>, <a class="ref" href="#XREFmeshgrid">meshgrid</a>, <a class="ref" href="#XREFhidden">hidden</a>, <a class="ref" href="#XREFshading">shading</a>, <a class="ref" href="representing-images.html#XREFcolormap">colormap</a>, <a class="ref" href="axis-configuration.html#XREFcaxis">caxis</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-surfc">
<span class="category-def">: </span><span><strong class="def-name">surfc</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-surfc"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfc-1">
<span class="category-def">: </span><span><strong class="def-name">surfc</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-surfc-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfc-2">
<span class="category-def">: </span><span><strong class="def-name">surfc</strong> <code class="def-code-arguments">(…, <var class="var">c</var>)</code><a class="copiable-link" href="#index-surfc-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfc-3">
<span class="category-def">: </span><span><strong class="def-name">surfc</strong> <code class="def-code-arguments">(…, <var class="var">prop</var>, <var class="var">val</var>, …)</code><a class="copiable-link" href="#index-surfc-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfc-4">
<span class="category-def">: </span><span><strong class="def-name">surfc</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-surfc-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfc-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">surfc</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-surfc-5"> ¶</a></span>
</dt> <dd>
<p>Plot a 3-D surface mesh with underlying contour lines. </p> <p>The surface mesh is plotted using shaded rectangles. The vertices of the rectangles [<var class="var">x</var>, <var class="var">y</var>] are typically the output of <code class="code">meshgrid</code>. over a 2-D rectangular region in the x-y plane. <var class="var">z</var> determines the height above the plane of each vertex. If only a single <var class="var">z</var> matrix is given, then it is plotted over the meshgrid <code class="code"><var class="var">x</var> = 1:columns (<var class="var">z</var>), <var class="var">y</var> = 1:rows (<var class="var">z</var>)</code>. Thus, columns of <var class="var">z</var> correspond to different <var class="var">x</var> values and rows of <var class="var">z</var> correspond to different <var class="var">y</var> values. </p> <p>The color of the surface is computed by linearly scaling the <var class="var">z</var> values to fit the range of the current colormap. Use <code class="code">caxis</code> and/or change the colormap to control the appearance. </p> <p>Optionally, the color of the surface can be specified independently of <var class="var">z</var> by supplying a color matrix, <var class="var">c</var>. </p> <p>Any property/value pairs are passed directly to the underlying surface object. The full list of properties is documented at <a class="ref" href="surface-properties.html">Surface Properties</a>. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a graphics handle to the created surface object. </p> <p>Note: The exact appearance of the surface can be controlled with the <code class="code">shading</code> command or by using <code class="code">set</code> to control surface object properties. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="three_002ddimensional-function-plotting.html#XREFezsurfc">ezsurfc</a>, <a class="ref" href="#XREFsurf">surf</a>, <a class="ref" href="#XREFsurfl">surfl</a>, <a class="ref" href="#XREFsurfnorm">surfnorm</a>, <a class="ref" href="plotting-the-triangulation.html#XREFtrisurf">trisurf</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFcontour">contour</a>, <a class="ref" href="#XREFmesh">mesh</a>, <a class="ref" href="graphics-objects.html#XREFsurface">surface</a>, <a class="ref" href="#XREFmeshgrid">meshgrid</a>, <a class="ref" href="#XREFhidden">hidden</a>, <a class="ref" href="#XREFshading">shading</a>, <a class="ref" href="representing-images.html#XREFcolormap">colormap</a>, <a class="ref" href="axis-configuration.html#XREFcaxis">caxis</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-surfl">
<span class="category-def">: </span><span><strong class="def-name">surfl</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-surfl"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfl-1">
<span class="category-def">: </span><span><strong class="def-name">surfl</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-surfl-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfl-2">
<span class="category-def">: </span><span><strong class="def-name">surfl</strong> <code class="def-code-arguments">(…, <var class="var">lsrc</var>)</code><a class="copiable-link" href="#index-surfl-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfl-3">
<span class="category-def">: </span><span><strong class="def-name">surfl</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">lsrc</var>, <var class="var">P</var>)</code><a class="copiable-link" href="#index-surfl-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfl-4">
<span class="category-def">: </span><span><strong class="def-name">surfl</strong> <code class="def-code-arguments">(…, "cdata")</code><a class="copiable-link" href="#index-surfl-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfl-5">
<span class="category-def">: </span><span><strong class="def-name">surfl</strong> <code class="def-code-arguments">(…, "light")</code><a class="copiable-link" href="#index-surfl-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfl-6">
<span class="category-def">: </span><span><strong class="def-name">surfl</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-surfl-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfl-7">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">surfl</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-surfl-7"> ¶</a></span>
</dt> <dd>
<p>Plot a 3-D surface using shading based on various lighting models. </p> <p>The surface mesh is plotted using shaded rectangles. The vertices of the rectangles [<var class="var">x</var>, <var class="var">y</var>] are typically the output of <code class="code">meshgrid</code>. over a 2-D rectangular region in the x-y plane. <var class="var">z</var> determines the height above the plane of each vertex. If only a single <var class="var">z</var> matrix is given, then it is plotted over the meshgrid <code class="code"><var class="var">x</var> = 1:columns (<var class="var">z</var>), <var class="var">y</var> = 1:rows (<var class="var">z</var>)</code>. Thus, columns of <var class="var">z</var> correspond to different <var class="var">x</var> values and rows of <var class="var">z</var> correspond to different <var class="var">y</var> values. </p> <p>The default lighting mode <code class="code">"cdata"</code>, changes the cdata property of the surface object to give the impression of a lighted surface. </p> <p>The alternate mode <code class="code">"light"</code> creates a light object to illuminate the surface. </p> <p>The light source location may be specified using <var class="var">lsrc</var> which can be a 2-element vector [azimuth, elevation] in degrees, or a 3-element vector [lx, ly, lz]. The default value is rotated 45 degrees counterclockwise to the current view. </p> <p>The material properties of the surface can specified using a 4-element vector <var class="var">P</var> = [<var class="var">AM</var> <var class="var">D</var> <var class="var">SP</var> <var class="var">exp</var>] which defaults to <var class="var">p</var> = [0.55 0.6 0.4 10]. </p> <dl class="table"> <dt>
<code class="code">"AM"</code> strength of ambient light</dt> <dt>
<code class="code">"D"</code> strength of diffuse reflection</dt> <dt>
<code class="code">"SP"</code> strength of specular reflection</dt> <dt>
<code class="code">"EXP"</code> specular exponent</dt> </dl> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a graphics handle to the created surface object. </p> <p>Example: </p> <pre class="example" data-language="matlab">colormap (bone (64));
surfl (peaks);
shading interp;</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFdiffuse">diffuse</a>, <a class="ref" href="#XREFspecular">specular</a>, <a class="ref" href="#XREFsurf">surf</a>, <a class="ref" href="#XREFshading">shading</a>, <a class="ref" href="representing-images.html#XREFcolormap">colormap</a>, <a class="ref" href="axis-configuration.html#XREFcaxis">caxis</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-surfnorm">
<span class="category-def">: </span><span><strong class="def-name">surfnorm</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-surfnorm"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfnorm-1">
<span class="category-def">: </span><span><strong class="def-name">surfnorm</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-surfnorm-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfnorm-2">
<span class="category-def">: </span><span><strong class="def-name">surfnorm</strong> <code class="def-code-arguments">(…, <var class="var">prop</var>, <var class="var">val</var>, …)</code><a class="copiable-link" href="#index-surfnorm-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfnorm-3">
<span class="category-def">: </span><span><strong class="def-name">surfnorm</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-surfnorm-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-surfnorm-4">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">Nx</var>, <var class="var">Ny</var>, <var class="var">Nz</var>] =</code> <strong class="def-name">surfnorm</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-surfnorm-4"> ¶</a></span>
</dt> <dd>
<p>Find the vectors normal to a meshgridded surface. </p> <p>If <var class="var">x</var> and <var class="var">y</var> are vectors, then a typical vertex is (<var class="var">x</var>(j), <var class="var">y</var>(i), <var class="var">z</var>(i,j)). Thus, columns of <var class="var">z</var> correspond to different <var class="var">x</var> values and rows of <var class="var">z</var> correspond to different <var class="var">y</var> values. If only a single input <var class="var">z</var> is given then <var class="var">x</var> is taken to be <code class="code">1:columns (<var class="var">z</var>)</code> and <var class="var">y</var> is <code class="code">1:rows (<var class="var">z</var>)</code>. </p> <p>If no return arguments are requested, a surface plot with the normal vectors to the surface is plotted. </p> <p>Any property/value input pairs are assigned to the surface object. The full list of properties is documented at <a class="ref" href="surface-properties.html">Surface Properties</a>. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>If output arguments are requested then the components of the normal vectors are returned in <var class="var">Nx</var>, <var class="var">Ny</var>, and <var class="var">Nz</var> and no plot is made. The normal vectors are unnormalized (magnitude != 1). To normalize, use </p> <pre class="example" data-language="matlab">len = sqrt (nx.^2 + ny.^2 + nz.^2);
nx ./= len;  ny ./= len;  nz ./= len;</pre> <p>An example of the use of <code class="code">surfnorm</code> is </p> <pre class="example" data-language="matlab">surfnorm (peaks (25));</pre> <p>Algorithm: The normal vectors are calculated by taking the cross product of the diagonals of each of the quadrilateral faces in the meshgrid to find the normal vectors at the center of each face. Next, for each meshgrid point the four nearest normal vectors are averaged to obtain the final normal to the surface at the meshgrid point. </p> <p>For surface objects, the <code class="code">"VertexNormals"</code> property contains equivalent information, except possibly near the boundary of the surface where different interpolation schemes may yield slightly different values. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisonormals">isonormals</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFquiver3">quiver3</a>, <a class="ref" href="#XREFsurf">surf</a>, <a class="ref" href="#XREFmeshgrid">meshgrid</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-isosurface">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fv</var> =</code> <strong class="def-name">isosurface</strong> <code class="def-code-arguments">(<var class="var">v</var>, <var class="var">isoval</var>)</code><a class="copiable-link" href="#index-isosurface"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isosurface-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fv</var> =</code> <strong class="def-name">isosurface</strong> <code class="def-code-arguments">(<var class="var">v</var>)</code><a class="copiable-link" href="#index-isosurface-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isosurface-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fv</var> =</code> <strong class="def-name">isosurface</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">isoval</var>)</code><a class="copiable-link" href="#index-isosurface-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isosurface-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fv</var> =</code> <strong class="def-name">isosurface</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>)</code><a class="copiable-link" href="#index-isosurface-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isosurface-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fvc</var> =</code> <strong class="def-name">isosurface</strong> <code class="def-code-arguments">(…, <var class="var">col</var>)</code><a class="copiable-link" href="#index-isosurface-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isosurface-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fv</var> =</code> <strong class="def-name">isosurface</strong> <code class="def-code-arguments">(…, "noshare")</code><a class="copiable-link" href="#index-isosurface-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isosurface-6">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fv</var> =</code> <strong class="def-name">isosurface</strong> <code class="def-code-arguments">(…, "verbose")</code><a class="copiable-link" href="#index-isosurface-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isosurface-7">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">f</var>, <var class="var">v</var>] =</code> <strong class="def-name">isosurface</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-isosurface-7"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isosurface-8">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">f</var>, <var class="var">v</var>, <var class="var">c</var>] =</code> <strong class="def-name">isosurface</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-isosurface-8"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isosurface-9">
<span class="category-def">: </span><span><strong class="def-name">isosurface</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-isosurface-9"> ¶</a></span>
</dt> <dd> <p>Calculate isosurface of 3-D volume data. </p> <p>An isosurface connects points with the same value and is analogous to a contour plot, but in three dimensions. </p> <p>The input argument <var class="var">v</var> is a three-dimensional array that contains data sampled over a volume. </p> <p>The input <var class="var">isoval</var> is a scalar that specifies the value for the isosurface. If <var class="var">isoval</var> is omitted or empty, a "good" value for an isosurface is determined from <var class="var">v</var>. </p> <p>When called with a single output argument <code class="code">isosurface</code> returns a structure array <var class="var">fv</var> that contains the fields <var class="var">faces</var> and <var class="var">vertices</var> computed at the points <code class="code">[<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>] = meshgrid (1:l, 1:m, 1:n)</code> where <code class="code">[l, m, n] = size (<var class="var">v</var>)</code>. The output <var class="var">fv</var> can be used directly as input to the <code class="code">patch</code> function. </p> <p>If called with additional input arguments <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var> that are three-dimensional arrays with the same size as <var class="var">v</var> or vectors with lengths corresponding to the dimensions of <var class="var">v</var>, then the volume data is taken at the specified points. If <var class="var">x</var>, <var class="var">y</var>, or <var class="var">z</var> are empty, the grid corresponds to the indices (<code class="code">1:n</code>) in the respective direction (see <a class="pxref" href="#XREFmeshgrid"><code class="code">meshgrid</code></a>). </p> <p>The optional input argument <var class="var">col</var>, which is a three-dimensional array of the same size as <var class="var">v</var>, specifies coloring of the isosurface. The color data is interpolated, as necessary, to match <var class="var">isoval</var>. The output structure array, in this case, has the additional field <var class="var">facevertexcdata</var>. </p> <p>If given the string input argument <code class="code">"noshare"</code>, vertices may be returned multiple times for different faces. The default behavior is to eliminate vertices shared by adjacent faces. </p> <p>The string input argument <code class="code">"verbose"</code> is supported for <small class="sc">MATLAB</small> compatibility, but has no effect. </p> <p>Any string arguments must be passed after the other arguments. </p> <p>If called with two or three output arguments, return the information about the faces <var class="var">f</var>, vertices <var class="var">v</var>, and color data <var class="var">c</var> as separate arrays instead of a single structure array. </p> <p>If called with no output argument, the isosurface geometry is directly plotted with the <code class="code">patch</code> command and a light object is added to the axes if not yet present. </p> <p>For example, </p> <pre class="example" data-language="matlab">[x, y, z] = meshgrid (1:5, 1:5, 1:5);
v = rand (5, 5, 5);
isosurface (x, y, z, v, .5);</pre> <p>will directly draw a random isosurface geometry in a graphics window. </p> <p>An example of an isosurface geometry with different additional coloring: </p> <pre class="example smallexample" data-language="matlab">N = 15;    # Increase number of vertices in each direction
iso = .4;  # Change isovalue to .1 to display a sphere
lin = linspace (0, 2, N);
[x, y, z] = meshgrid (lin, lin, lin);
v = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
figure ();

subplot (2,2,1); view (-38, 20);
[f, vert] = isosurface (x, y, z, v, iso);
p = patch ("Faces", f, "Vertices", vert, "EdgeColor", "none");
pbaspect ([1 1 1]);
isonormals (x, y, z, v, p)
set (p, "FaceColor", "green", "FaceLighting", "gouraud");
light ("Position", [1 1 5]);

subplot (2,2,2); view (-38, 20);
p = patch ("Faces", f, "Vertices", vert, "EdgeColor", "blue");
pbaspect ([1 1 1]);
isonormals (x, y, z, v, p)
set (p, "FaceColor", "none", "EdgeLighting", "gouraud");
light ("Position", [1 1 5]);

subplot (2,2,3); view (-38, 20);
[f, vert, c] = isosurface (x, y, z, v, iso, y);
p = patch ("Faces", f, "Vertices", vert, "FaceVertexCData", c, ...
           "FaceColor", "interp", "EdgeColor", "none");
pbaspect ([1 1 1]);
isonormals (x, y, z, v, p)
set (p, "FaceLighting", "gouraud");
light ("Position", [1 1 5]);

subplot (2,2,4); view (-38, 20);
p = patch ("Faces", f, "Vertices", vert, "FaceVertexCData", c, ...
           "FaceColor", "interp", "EdgeColor", "blue");
pbaspect ([1 1 1]);
isonormals (x, y, z, v, p)
set (p, "FaceLighting", "gouraud");
light ("Position", [1 1 5]);</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisonormals">isonormals</a>, <a class="ref" href="#XREFisocolors">isocolors</a>, <a class="ref" href="#XREFisocaps">isocaps</a>, <a class="ref" href="#XREFsmooth3">smooth3</a>, <a class="ref" href="#XREFreducevolume">reducevolume</a>, <a class="ref" href="#XREFreducepatch">reducepatch</a>, <a class="ref" href="graphics-objects.html#XREFpatch">patch</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-isonormals">
<span class="category-def">: </span><span><code class="def-type"><var class="var">vn</var> =</code> <strong class="def-name">isonormals</strong> <code class="def-code-arguments">(<var class="var">val</var>, <var class="var">vert</var>)</code><a class="copiable-link" href="#index-isonormals"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isonormals-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">vn</var> =</code> <strong class="def-name">isonormals</strong> <code class="def-code-arguments">(<var class="var">val</var>, <var class="var">hp</var>)</code><a class="copiable-link" href="#index-isonormals-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isonormals-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">vn</var> =</code> <strong class="def-name">isonormals</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">val</var>, <var class="var">vert</var>)</code><a class="copiable-link" href="#index-isonormals-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isonormals-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">vn</var> =</code> <strong class="def-name">isonormals</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">val</var>, <var class="var">hp</var>)</code><a class="copiable-link" href="#index-isonormals-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isonormals-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">vn</var> =</code> <strong class="def-name">isonormals</strong> <code class="def-code-arguments">(…, "negate")</code><a class="copiable-link" href="#index-isonormals-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isonormals-5">
<span class="category-def">: </span><span><strong class="def-name">isonormals</strong> <code class="def-code-arguments">(<var class="var">val</var>, <var class="var">hp</var>)</code><a class="copiable-link" href="#index-isonormals-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isonormals-6">
<span class="category-def">: </span><span><strong class="def-name">isonormals</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">val</var>, <var class="var">hp</var>)</code><a class="copiable-link" href="#index-isonormals-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isonormals-7">
<span class="category-def">: </span><span><strong class="def-name">isonormals</strong> <code class="def-code-arguments">(…, "negate")</code><a class="copiable-link" href="#index-isonormals-7"> ¶</a></span>
</dt> <dd> <p>Calculate normals to an isosurface. </p> <p>The vertex normals <var class="var">vn</var> are calculated from the gradient of the 3-dimensional array <var class="var">val</var> (size: lxmxn) containing the data for an isosurface geometry. The normals point towards smaller values in <var class="var">val</var>. </p> <p>If called with one output argument <var class="var">vn</var>, and the second input argument <var class="var">vert</var> holds the vertices of an isosurface, then the normals <var class="var">vn</var> are calculated at the vertices <var class="var">vert</var> on a grid given by <code class="code">[x, y, z] = meshgrid (1:l, 1:m, 1:n)</code>. The output argument <var class="var">vn</var> has the same size as <var class="var">vert</var> and can be used to set the <code class="code">"VertexNormals"</code> property of the corresponding patch. </p> <p>If called with additional input arguments <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var>, which are 3-dimensional arrays with the same size as <var class="var">val</var>, then the volume data is taken at these points. Instead of the vertex data <var class="var">vert</var>, a patch handle <var class="var">hp</var> can be passed to the function. </p> <p>If the last input argument is the string <code class="code">"negate"</code>, compute the reverse vector normals of an isosurface geometry (i.e., pointed towards larger values in <var class="var">val</var>). </p> <p>If no output argument is given, the property <code class="code">"VertexNormals"</code> of the patch associated with the patch handle <var class="var">hp</var> is changed directly. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisosurface">isosurface</a>, <a class="ref" href="#XREFisocolors">isocolors</a>, <a class="ref" href="#XREFsmooth3">smooth3</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-isocaps">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fvc</var> =</code> <strong class="def-name">isocaps</strong> <code class="def-code-arguments">(<var class="var">v</var>, <var class="var">isoval</var>)</code><a class="copiable-link" href="#index-isocaps"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocaps-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fvc</var> =</code> <strong class="def-name">isocaps</strong> <code class="def-code-arguments">(<var class="var">v</var>)</code><a class="copiable-link" href="#index-isocaps-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocaps-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fvc</var> =</code> <strong class="def-name">isocaps</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">isoval</var>)</code><a class="copiable-link" href="#index-isocaps-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocaps-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fvc</var> =</code> <strong class="def-name">isocaps</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>)</code><a class="copiable-link" href="#index-isocaps-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocaps-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fvc</var> =</code> <strong class="def-name">isocaps</strong> <code class="def-code-arguments">(…, <var class="var">which_caps</var>)</code><a class="copiable-link" href="#index-isocaps-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocaps-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fvc</var> =</code> <strong class="def-name">isocaps</strong> <code class="def-code-arguments">(…, <var class="var">which_plane</var>)</code><a class="copiable-link" href="#index-isocaps-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocaps-6">
<span class="category-def">: </span><span><code class="def-type"><var class="var">fvc</var> =</code> <strong class="def-name">isocaps</strong> <code class="def-code-arguments">(…, <code class="code">"verbose"</code>)</code><a class="copiable-link" href="#index-isocaps-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocaps-7">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">faces</var>, <var class="var">vertices</var>, <var class="var">fvcdata</var>] =</code> <strong class="def-name">isocaps</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-isocaps-7"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocaps-8">
<span class="category-def">: </span><span><strong class="def-name">isocaps</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-isocaps-8"> ¶</a></span>
</dt> <dd> <p>Create end-caps for isosurfaces of 3-D data. </p> <p>This function places caps at the open ends of isosurfaces. </p> <p>The input argument <var class="var">v</var> is a three-dimensional array that contains data sampled over a volume. </p> <p>The input <var class="var">isoval</var> is a scalar that specifies the value for the isosurface. If <var class="var">isoval</var> is omitted or empty, a "good" value for an isosurface is determined from <var class="var">v</var>. </p> <p>When called with a single output argument, <code class="code">isocaps</code> returns a structure array <var class="var">fvc</var> with the fields: <code class="code">faces</code>, <code class="code">vertices</code>, and <code class="code">facevertexcdata</code>. The results are computed at the points <code class="code">[<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>] = meshgrid (1:l, 1:m, 1:n)</code> where <code class="code">[l, m, n] = size (<var class="var">v</var>)</code>. The output <var class="var">fvc</var> can be used directly as input to the <code class="code">patch</code> function. </p> <p>If called with additional input arguments <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var> that are three-dimensional arrays with the same size as <var class="var">v</var> or vectors with lengths corresponding to the dimensions of <var class="var">v</var>, then the volume data is taken at the specified points. If <var class="var">x</var>, <var class="var">y</var>, or <var class="var">z</var> are empty, the grid corresponds to the indices (<code class="code">1:n</code>) in the respective direction (see <a class="pxref" href="#XREFmeshgrid"><code class="code">meshgrid</code></a>). </p> <p>The optional parameter <var class="var">which_caps</var> can have one of the following string values which defines how the data will be enclosed: </p> <dl class="table"> <dt>
<code class="code">"above"</code>, <code class="code">"a"</code> (default)</dt> <dd>
<p>for end-caps that enclose the data above <var class="var">isoval</var>. </p> </dd> <dt>
<code class="code">"below"</code>, <code class="code">"b"</code>
</dt> <dd><p>for end-caps that enclose the data below <var class="var">isoval</var>. </p></dd> </dl> <p>The optional parameter <var class="var">which_plane</var> can have one of the following string values to define which end-cap should be drawn: </p> <dl class="table"> <dt>
<code class="code">"all"</code> (default)</dt> <dd>
<p>for all of the end-caps. </p> </dd> <dt><code class="code">"xmin"</code></dt> <dd>
<p>for end-caps at the lower x-plane of the data. </p> </dd> <dt><code class="code">"xmax"</code></dt> <dd>
<p>for end-caps at the upper x-plane of the data. </p> </dd> <dt><code class="code">"ymin"</code></dt> <dd>
<p>for end-caps at the lower y-plane of the data. </p> </dd> <dt><code class="code">"ymax"</code></dt> <dd>
<p>for end-caps at the upper y-plane of the data. </p> </dd> <dt><code class="code">"zmin"</code></dt> <dd>
<p>for end-caps at the lower z-plane of the data. </p> </dd> <dt><code class="code">"zmax"</code></dt> <dd><p>for end-caps at the upper z-plane of the data. </p></dd> </dl> <p>The string input argument <code class="code">"verbose"</code> is supported for <small class="sc">MATLAB</small> compatibility, but has no effect. </p> <p>If called with two or three output arguments, the data for faces <var class="var">faces</var>, vertices <var class="var">vertices</var>, and the color data <var class="var">facevertexcdata</var> are returned in separate arrays instead of a single structure. </p> <p>If called with no output argument, the end-caps are drawn directly in the current figure with the <code class="code">patch</code> command. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisosurface">isosurface</a>, <a class="ref" href="#XREFisonormals">isonormals</a>, <a class="ref" href="graphics-objects.html#XREFpatch">patch</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-isocolors">
<span class="category-def">: </span><span><code class="def-type"><var class="var">cdat</var> =</code> <strong class="def-name">isocolors</strong> <code class="def-code-arguments">(<var class="var">c</var>, <var class="var">v</var>)</code><a class="copiable-link" href="#index-isocolors"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocolors-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">cdat</var> =</code> <strong class="def-name">isocolors</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">c</var>, <var class="var">v</var>)</code><a class="copiable-link" href="#index-isocolors-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocolors-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">cdat</var> =</code> <strong class="def-name">isocolors</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">r</var>, <var class="var">g</var>, <var class="var">b</var>, <var class="var">v</var>)</code><a class="copiable-link" href="#index-isocolors-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocolors-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">cdat</var> =</code> <strong class="def-name">isocolors</strong> <code class="def-code-arguments">(<var class="var">r</var>, <var class="var">g</var>, <var class="var">b</var>, <var class="var">v</var>)</code><a class="copiable-link" href="#index-isocolors-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocolors-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">cdat</var> =</code> <strong class="def-name">isocolors</strong> <code class="def-code-arguments">(…, <var class="var">hp</var>)</code><a class="copiable-link" href="#index-isocolors-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-isocolors-5">
<span class="category-def">: </span><span><strong class="def-name">isocolors</strong> <code class="def-code-arguments">(…, <var class="var">hp</var>)</code><a class="copiable-link" href="#index-isocolors-5"> ¶</a></span>
</dt> <dd> <p>Compute isosurface colors. </p> <p>If called with one output argument, and the first input argument <var class="var">c</var> is a three-dimensional array that contains indexed color values, and the second input argument <var class="var">v</var> are the vertices of an isosurface geometry, then return a matrix <var class="var">cdat</var> with color data information for the geometry at computed points <code class="code">[x, y, z] = meshgrid (1:l, 1:m, 1:n)</code>. The output argument <var class="var">cdat</var> can be used to manually set the <code class="code">"FaceVertexCData"</code> property of an isosurface patch object. </p> <p>If called with additional input arguments <var class="var">x</var>, <var class="var">y</var> and <var class="var">z</var> which are three-dimensional arrays of the same size as <var class="var">c</var> then the color data is taken at those specified points. </p> <p>Instead of indexed color data <var class="var">c</var>, <code class="code">isocolors</code> can also be called with RGB values <var class="var">r</var>, <var class="var">g</var>, <var class="var">b</var>. If input arguments <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var> are not given then <code class="code">meshgrid</code> computed values are used. </p> <p>Optionally, a patch handle <var class="var">hp</var> can be given as the last input argument to all function call variations and the vertex data will be extracted from the isosurface patch object. Finally, if no output argument is given then the colors of the patch given by the patch handle <var class="var">hp</var> are changed. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisosurface">isosurface</a>, <a class="ref" href="#XREFisonormals">isonormals</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-smooth3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">smoothed_data</var> =</code> <strong class="def-name">smooth3</strong> <code class="def-code-arguments">(<var class="var">data</var>)</code><a class="copiable-link" href="#index-smooth3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-smooth3-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">smoothed_data</var> =</code> <strong class="def-name">smooth3</strong> <code class="def-code-arguments">(<var class="var">data</var>, <var class="var">method</var>)</code><a class="copiable-link" href="#index-smooth3-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-smooth3-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">smoothed_data</var> =</code> <strong class="def-name">smooth3</strong> <code class="def-code-arguments">(<var class="var">data</var>, <var class="var">method</var>, <var class="var">sz</var>)</code><a class="copiable-link" href="#index-smooth3-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-smooth3-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">smoothed_data</var> =</code> <strong class="def-name">smooth3</strong> <code class="def-code-arguments">(<var class="var">data</var>, <var class="var">method</var>, <var class="var">sz</var>, <var class="var">std_dev</var>)</code><a class="copiable-link" href="#index-smooth3-3"> ¶</a></span>
</dt> <dd>
<p>Smooth values of 3-dimensional matrix <var class="var">data</var>. </p> <p>This function may be used, for example, to reduce the impact of noise in <var class="var">data</var> before calculating isosurfaces. </p> <p><var class="var">data</var> must be a non-singleton 3-dimensional matrix. The output <var class="var">smoothed_data</var> is a matrix of the same size as <var class="var">data</var>. </p> <p>The option input <var class="var">method</var> determines which convolution kernel is used for the smoothing process. Possible choices: </p> <dl class="table"> <dt>
<code class="code">"box"</code>, <code class="code">"b"</code> (default)</dt> <dd>
<p>a convolution kernel with sharp edges. </p> </dd> <dt>
<code class="code">"gaussian"</code>, <code class="code">"g"</code>
</dt> <dd><p>a convolution kernel that is represented by a non-correlated trivariate normal distribution function. </p></dd> </dl> <p><var class="var">sz</var> is either a 3-element vector specifying the size of the convolution kernel in the x-, y- and z-directions, or a scalar. In the scalar case the same size is used for all three dimensions (<code class="code">[<var class="var">sz</var>, <var class="var">sz</var>, <var class="var">sz</var>]</code>). The default value is 3. </p> <p>If <var class="var">method</var> is <code class="code">"gaussian"</code> then the optional input <var class="var">std_dev</var> defines the standard deviation of the trivariate normal distribution function. <var class="var">std_dev</var> is either a 3-element vector specifying the standard deviation of the Gaussian convolution kernel in x-, y- and z-directions, or a scalar. In the scalar case the same value is used for all three dimensions. The default value is 0.65. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisosurface">isosurface</a>, <a class="ref" href="#XREFisonormals">isonormals</a>, <a class="ref" href="graphics-objects.html#XREFpatch">patch</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-reducevolume">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">nx</var>, <var class="var">ny</var>, <var class="var">nz</var>, <var class="var">nv</var>] =</code> <strong class="def-name">reducevolume</strong> <code class="def-code-arguments">(<var class="var">v</var>, <var class="var">r</var>)</code><a class="copiable-link" href="#index-reducevolume"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reducevolume-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">nx</var>, <var class="var">ny</var>, <var class="var">nz</var>, <var class="var">nv</var>] =</code> <strong class="def-name">reducevolume</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">r</var>)</code><a class="copiable-link" href="#index-reducevolume-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reducevolume-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">nv</var> =</code> <strong class="def-name">reducevolume</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-reducevolume-2"> ¶</a></span>
</dt> <dd> <p>Reduce the volume of the dataset in <var class="var">v</var> according to the values in <var class="var">r</var>. </p> <p><var class="var">v</var> is a matrix that is non-singleton in the first 3 dimensions. </p> <p><var class="var">r</var> can either be a vector of 3 elements representing the reduction factors in the x-, y-, and z-directions or a scalar, in which case the same reduction factor is used in all three dimensions. </p> <p><code class="code">reducevolume</code> reduces the number of elements of <var class="var">v</var> by taking only every <var class="var">r</var>-th element in the respective dimension. </p> <p>Optionally, <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var> can be supplied to represent the set of coordinates of <var class="var">v</var>. They can either be matrices of the same size as <var class="var">v</var> or vectors with sizes according to the dimensions of <var class="var">v</var>, in which case they are expanded to matrices (see <a class="pxref" href="#XREFmeshgrid"><code class="code">meshgrid</code></a>). </p> <p>If <code class="code">reducevolume</code> is called with two arguments then <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var> are assumed to match the respective indices of <var class="var">v</var>. </p> <p>The reduced matrix is returned in <var class="var">nv</var>. </p> <p>Optionally, the reduced set of coordinates are returned in <var class="var">nx</var>, <var class="var">ny</var>, and <var class="var">nz</var>, respectively. </p> <p>Examples: </p> <pre class="example" data-language="matlab">v = reshape (1:6*8*4, [6 8 4]);
nv = reducevolume (v, [4 3 2]);</pre> <pre class="example" data-language="matlab">v = reshape (1:6*8*4, [6 8 4]);
x = 1:3:24;  y = -14:5:11;  z = linspace (16, 18, 4);
[nx, ny, nz, nv] = reducevolume (x, y, z, v, [4 3 2]);</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisosurface">isosurface</a>, <a class="ref" href="#XREFisonormals">isonormals</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-reducepatch">
<span class="category-def">: </span><span><code class="def-type"><var class="var">reduced_fv</var> =</code> <strong class="def-name">reducepatch</strong> <code class="def-code-arguments">(<var class="var">fv</var>)</code><a class="copiable-link" href="#index-reducepatch"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reducepatch-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">reduced_fv</var> =</code> <strong class="def-name">reducepatch</strong> <code class="def-code-arguments">(<var class="var">faces</var>, <var class="var">vertices</var>)</code><a class="copiable-link" href="#index-reducepatch-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reducepatch-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">reduced_fv</var> =</code> <strong class="def-name">reducepatch</strong> <code class="def-code-arguments">(<var class="var">patch_handle</var>)</code><a class="copiable-link" href="#index-reducepatch-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reducepatch-3">
<span class="category-def">: </span><span><strong class="def-name">reducepatch</strong> <code class="def-code-arguments">(<var class="var">patch_handle</var>)</code><a class="copiable-link" href="#index-reducepatch-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reducepatch-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">reduced_fv</var> =</code> <strong class="def-name">reducepatch</strong> <code class="def-code-arguments">(…, <var class="var">reduction_factor</var>)</code><a class="copiable-link" href="#index-reducepatch-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reducepatch-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">reduced_fv</var> =</code> <strong class="def-name">reducepatch</strong> <code class="def-code-arguments">(…, "fast")</code><a class="copiable-link" href="#index-reducepatch-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reducepatch-6">
<span class="category-def">: </span><span><code class="def-type"><var class="var">reduced_fv</var> =</code> <strong class="def-name">reducepatch</strong> <code class="def-code-arguments">(…, "verbose")</code><a class="copiable-link" href="#index-reducepatch-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-reducepatch-7">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">reduced_faces</var>, <var class="var">reduces_vertices</var>] =</code> <strong class="def-name">reducepatch</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-reducepatch-7"> ¶</a></span>
</dt> <dd> <p>Reduce the number of faces and vertices in a patch object while retaining the overall shape of the patch. </p> <p>The input patch can be represented by a structure <var class="var">fv</var> with the fields <code class="code">faces</code> and <code class="code">vertices</code>, by two matrices <var class="var">faces</var> and <var class="var">vertices</var> (see, e.g., the result of <code class="code">isosurface</code>), or by a handle to a patch object <var class="var">patch_handle</var> (see <a class="pxref" href="graphics-objects.html#XREFpatch"><code class="code">patch</code></a>). </p> <p>The number of faces and vertices in the patch is reduced by iteratively collapsing the shortest edge of the patch to its midpoint (as discussed, e.g., here: <a class="url" href="https://libigl.github.io/libigl/tutorial/tutorial.html#meshdecimation">https://libigl.github.io/libigl/tutorial/tutorial.html#meshdecimation</a>). </p> <p>Currently, only patches consisting of triangles are supported. The resulting patch also consists only of triangles. </p> <p>If <code class="code">reducepatch</code> is called with a handle to a valid patch <var class="var">patch_handle</var>, and without any output arguments, then the given patch is updated immediately. </p> <p>If the <var class="var">reduction_factor</var> is omitted, the resulting structure <var class="var">reduced_fv</var> includes approximately 50% of the faces of the original patch. If <var class="var">reduction_factor</var> is a fraction between 0 (excluded) and 1 (excluded), a patch with approximately the corresponding fraction of faces is determined. If <var class="var">reduction_factor</var> is an integer greater than or equal to 1, the resulting patch has approximately <var class="var">reduction_factor</var> faces. Depending on the geometry of the patch, the resulting number of faces can differ from the given value of <var class="var">reduction_factor</var>. This is especially true when many shared vertices are detected. </p> <p>For the reduction, it is necessary that vertices of touching faces are shared. Shared vertices are detected automatically. This detection can be skipped by passing the optional string argument <code class="code">"fast"</code>. </p> <p>With the optional string arguments <code class="code">"verbose"</code>, additional status messages are printed to the command window. </p> <p>Any string input arguments must be passed after all other arguments. </p> <p>If called with one output argument, the reduced faces and vertices are returned in a structure <var class="var">reduced_fv</var> with the fields <code class="code">faces</code> and <code class="code">vertices</code> (see the one output option of <code class="code">isosurface</code>). </p> <p>If called with two output arguments, the reduced faces and vertices are returned in two separate matrices <var class="var">reduced_faces</var> and <var class="var">reduced_vertices</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisosurface">isosurface</a>, <a class="ref" href="#XREFisonormals">isonormals</a>, <a class="ref" href="#XREFreducevolume">reducevolume</a>, <a class="ref" href="graphics-objects.html#XREFpatch">patch</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-shrinkfaces">
<span class="category-def">: </span><span><strong class="def-name">shrinkfaces</strong> <code class="def-code-arguments">(<var class="var">p</var>, <var class="var">sf</var>)</code><a class="copiable-link" href="#index-shrinkfaces"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-shrinkfaces-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">nfv</var> =</code> <strong class="def-name">shrinkfaces</strong> <code class="def-code-arguments">(<var class="var">p</var>, <var class="var">sf</var>)</code><a class="copiable-link" href="#index-shrinkfaces-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-shrinkfaces-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">nfv</var> =</code> <strong class="def-name">shrinkfaces</strong> <code class="def-code-arguments">(<var class="var">fv</var>, <var class="var">sf</var>)</code><a class="copiable-link" href="#index-shrinkfaces-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-shrinkfaces-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">nfv</var> =</code> <strong class="def-name">shrinkfaces</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">v</var>, <var class="var">sf</var>)</code><a class="copiable-link" href="#index-shrinkfaces-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-shrinkfaces-4">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">nf</var>, <var class="var">nv</var>] =</code> <strong class="def-name">shrinkfaces</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-shrinkfaces-4"> ¶</a></span>
</dt> <dd> <p>Reduce the size of faces in a patch by the shrink factor <var class="var">sf</var>. </p> <p>The patch object can be specified by a graphics handle (<var class="var">p</var>), a patch structure (<var class="var">fv</var>) with the fields <code class="code">"faces"</code> and <code class="code">"vertices"</code>, or as two separate matrices (<var class="var">f</var>, <var class="var">v</var>) of faces and vertices. </p> <p>The shrink factor <var class="var">sf</var> is a positive number specifying the percentage of the original area the new face will occupy. If no factor is given the default is 0.3 (a reduction to 30% of the original size). A factor greater than 1.0 will result in the expansion of faces. </p> <p>Given a patch handle as the first input argument and no output parameters, perform the shrinking of the patch faces in place and redraw the patch. </p> <p>If called with one output argument, return a structure with fields <code class="code">"faces"</code>, <code class="code">"vertices"</code>, and <code class="code">"facevertexcdata"</code> containing the data after shrinking. This structure can be used directly as an input argument to the <code class="code">patch</code> function. </p> <p><strong class="strong">Caution:</strong>: Performing the shrink operation on faces which are not convex can lead to undesirable results. </p> <p>Example: a triangulated 3/4 circle and the corresponding shrunken version. </p> <pre class="example" data-language="matlab">[phi r] = meshgrid (linspace (0, 1.5*pi, 16), linspace (1, 2, 4));
tri = delaunay (phi(:), r(:));
v = [r(:).*sin(phi(:)) r(:).*cos(phi(:))];
clf ()
p = patch ("Faces", tri, "Vertices", v, "FaceColor", "none");
fv = shrinkfaces (p);
patch (fv)
axis equal
grid on</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="graphics-objects.html#XREFpatch">patch</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-diffuse">
<span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">diffuse</strong> <code class="def-code-arguments">(<var class="var">sx</var>, <var class="var">sy</var>, <var class="var">sz</var>, <var class="var">lv</var>)</code><a class="copiable-link" href="#index-diffuse"> ¶</a></span>
</dt> <dd>
<p>Calculate the diffuse reflection strength of a surface defined by the normal vector elements <var class="var">sx</var>, <var class="var">sy</var>, <var class="var">sz</var>. </p> <p>The light source location vector <var class="var">lv</var> can be given as a 2-element vector [azimuth, elevation] in degrees or as a 3-element vector [x, y, z]. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFspecular">specular</a>, <a class="ref" href="#XREFsurfl">surfl</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-specular">
<span class="category-def">: </span><span><code class="def-type"><var class="var">refl</var> =</code> <strong class="def-name">specular</strong> <code class="def-code-arguments">(<var class="var">sx</var>, <var class="var">sy</var>, <var class="var">sz</var>, <var class="var">lv</var>, <var class="var">vv</var>)</code><a class="copiable-link" href="#index-specular"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-specular-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">refl</var> =</code> <strong class="def-name">specular</strong> <code class="def-code-arguments">(<var class="var">sx</var>, <var class="var">sy</var>, <var class="var">sz</var>, <var class="var">lv</var>, <var class="var">vv</var>, <var class="var">se</var>)</code><a class="copiable-link" href="#index-specular-1"> ¶</a></span>
</dt> <dd>
<p>Calculate the specular reflection strength of a surface defined by the normal vector elements <var class="var">sx</var>, <var class="var">sy</var>, <var class="var">sz</var> using Phong’s approximation. </p> <p>The light source location and viewer location vectors are specified using parameters <var class="var">lv</var> and <var class="var">vv</var> respectively. The location vectors can given as 2-element vectors [azimuth, elevation] in degrees or as 3-element vectors [x, y, z]. </p> <p>An optional sixth argument specifies the specular exponent (spread) <var class="var">se</var>. If not given, <var class="var">se</var> defaults to 10. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFdiffuse">diffuse</a>, <a class="ref" href="#XREFsurfl">surfl</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-lighting">
<span class="category-def">: </span><span><strong class="def-name">lighting</strong> <code class="def-code-arguments">(<var class="var">type</var>)</code><a class="copiable-link" href="#index-lighting"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lighting-1">
<span class="category-def">: </span><span><strong class="def-name">lighting</strong> <code class="def-code-arguments">(<var class="var">hax</var>, <var class="var">type</var>)</code><a class="copiable-link" href="#index-lighting-1"> ¶</a></span>
</dt> <dd>
<p>Set the lighting of patch or surface graphic objects. </p> <p>Valid arguments for <var class="var">type</var> are </p> <dl class="table"> <dt><code class="code">"flat"</code></dt> <dd>
<p>Draw objects with faceted lighting effects. </p> </dd> <dt><code class="code">"gouraud"</code></dt> <dd>
<p>Draw objects with linear interpolation of the lighting effects between the vertices. </p> </dd> <dt><code class="code">"none"</code></dt> <dd><p>Draw objects without light and shadow effects. </p></dd> </dl> <p>If the first argument <var class="var">hax</var> is an axes handle, then change the lighting effects of objects in this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The lighting effects are only visible if at least one light object is present and visible in the same axes. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="graphics-objects.html#XREFlight">light</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFfill">fill</a>, <a class="ref" href="#XREFmesh">mesh</a>, <a class="ref" href="graphics-objects.html#XREFpatch">patch</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFpcolor">pcolor</a>, <a class="ref" href="#XREFsurf">surf</a>, <a class="ref" href="graphics-objects.html#XREFsurface">surface</a>, <a class="ref" href="#XREFshading">shading</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-material">
<span class="category-def">: </span><span><strong class="def-name">material</strong> <code class="def-code-arguments">shiny</code><a class="copiable-link" href="#index-material"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-material-1">
<span class="category-def">: </span><span><strong class="def-name">material</strong> <code class="def-code-arguments">dull</code><a class="copiable-link" href="#index-material-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-material-2">
<span class="category-def">: </span><span><strong class="def-name">material</strong> <code class="def-code-arguments">metal</code><a class="copiable-link" href="#index-material-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-material-3">
<span class="category-def">: </span><span><strong class="def-name">material</strong> <code class="def-code-arguments">default</code><a class="copiable-link" href="#index-material-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-material-4">
<span class="category-def">: </span><span><strong class="def-name">material</strong> <code class="def-code-arguments">([<var class="var">as</var>, <var class="var">ds</var>, <var class="var">ss</var>])</code><a class="copiable-link" href="#index-material-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-material-5">
<span class="category-def">: </span><span><strong class="def-name">material</strong> <code class="def-code-arguments">([<var class="var">as</var>, <var class="var">ds</var>, <var class="var">ss</var>, <var class="var">se</var>])</code><a class="copiable-link" href="#index-material-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-material-6">
<span class="category-def">: </span><span><strong class="def-name">material</strong> <code class="def-code-arguments">([<var class="var">as</var>, <var class="var">ds</var>, <var class="var">ss</var>, <var class="var">se</var>, <var class="var">scr</var>])</code><a class="copiable-link" href="#index-material-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-material-7">
<span class="category-def">: </span><span><strong class="def-name">material</strong> <code class="def-code-arguments">(<var class="var">hlist</var>, …)</code><a class="copiable-link" href="#index-material-7"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-material-8">
<span class="category-def">: </span><span><code class="def-type"><var class="var">mtypes</var> =</code> <strong class="def-name">material</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-material-8"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-material-9">
<span class="category-def">: </span><span><code class="def-type"><var class="var">refl_props</var> =</code> <strong class="def-name">material</strong> <code class="def-code-arguments">(<var class="var">mtype_string</var>)</code><a class="copiable-link" href="#index-material-9"> ¶</a></span>
</dt> <dd>
<p>Set reflectance properties for the lighting of surfaces and patches. </p> <p>This function changes the ambient, diffuse, and specular strengths, as well as the specular exponent and specular color reflectance, of all <code class="code">patch</code> and <code class="code">surface</code> objects in the current axes. This can be used to simulate, to some extent, the reflectance properties of certain materials when used with <code class="code">light</code>. </p> <p>When called with a string, the aforementioned properties are set according to the values in the following table: </p> <table class="multitable"> <thead><tr>
<th width="0%"></th>
<th width="20%"><var class="var">mtype</var></th>
<th width="15%">ambient- strength</th>
<th width="15%">diffuse- strength</th>
<th width="15%">specular- strength</th>
<th width="15%">specular- exponent</th>
<th width="15%">specular- color- reflectance</th>
<th width="0%"></th>
</tr></thead> <tbody>
<tr>
<td width="0%"></td>
<td width="20%"><code class="code">"shiny"</code></td>
<td width="15%">0.3</td>
<td width="15%">0.6</td>
<td width="15%">0.9</td>
<td width="15%">20</td>
<td width="15%">1.0</td>
<td width="0%"></td>
</tr> <tr>
<td width="0%"></td>
<td width="20%"><code class="code">"dull"</code></td>
<td width="15%">0.3</td>
<td width="15%">0.8</td>
<td width="15%">0.0</td>
<td width="15%">10</td>
<td width="15%">1.0</td>
<td width="0%"></td>
</tr> <tr>
<td width="0%"></td>
<td width="20%"><code class="code">"metal"</code></td>
<td width="15%">0.3</td>
<td width="15%">0.3</td>
<td width="15%">1.0</td>
<td width="15%">25</td>
<td width="15%">0.5</td>
<td width="0%"></td>
</tr> <tr>
<td width="0%"></td>
<td width="20%"><code class="code">"default"</code></td>
<td width="15%"><code class="code">"default"</code></td>
<td width="15%"><code class="code">"default"</code></td>
<td width="15%"><code class="code">"default"</code></td>
<td width="15%"><code class="code">"default"</code></td>
<td width="15%"><code class="code">"default"</code></td>
<td width="0%"></td>
</tr> </tbody> </table> <p>When called with a vector of three elements, the ambient, diffuse, and specular strengths of all <code class="code">patch</code> and <code class="code">surface</code> objects in the current axes are updated. An optional fourth vector element updates the specular exponent, and an optional fifth vector element updates the specular color reflectance. </p> <p>A list of graphic handles can also be passed as the first argument. In this case, the properties of these handles and all child <code class="code">patch</code> and <code class="code">surface</code> objects will be updated. </p> <p>Additionally, <code class="code">material</code> can be called with a single output argument. If called without input arguments, a column cell vector <var class="var">mtypes</var> with the strings for all available materials is returned. If the one input argument <var class="var">mtype_string</var> is the name of a material, a 1x5 cell vector <var class="var">refl_props</var> with the reflectance properties of that material is returned. In both cases, no graphic properties are changed. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="graphics-objects.html#XREFlight">light</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFfill">fill</a>, <a class="ref" href="#XREFmesh">mesh</a>, <a class="ref" href="graphics-objects.html#XREFpatch">patch</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFpcolor">pcolor</a>, <a class="ref" href="#XREFsurf">surf</a>, <a class="ref" href="graphics-objects.html#XREFsurface">surface</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-camlight">
<span class="category-def">: </span><span><strong class="def-name">camlight</strong><a class="copiable-link" href="#index-camlight"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camlight-1">
<span class="category-def">: </span><span><strong class="def-name">camlight</strong> <code class="def-code-arguments">right</code><a class="copiable-link" href="#index-camlight-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camlight-2">
<span class="category-def">: </span><span><strong class="def-name">camlight</strong> <code class="def-code-arguments">left</code><a class="copiable-link" href="#index-camlight-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camlight-3">
<span class="category-def">: </span><span><strong class="def-name">camlight</strong> <code class="def-code-arguments">headlight</code><a class="copiable-link" href="#index-camlight-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camlight-4">
<span class="category-def">: </span><span><strong class="def-name">camlight</strong> <code class="def-code-arguments">(<var class="var">az</var>, <var class="var">el</var>)</code><a class="copiable-link" href="#index-camlight-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camlight-5">
<span class="category-def">: </span><span><strong class="def-name">camlight</strong> <code class="def-code-arguments">(…, <var class="var">style</var>)</code><a class="copiable-link" href="#index-camlight-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camlight-6">
<span class="category-def">: </span><span><strong class="def-name">camlight</strong> <code class="def-code-arguments">(<var class="var">hl</var>, …)</code><a class="copiable-link" href="#index-camlight-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camlight-7">
<span class="category-def">: </span><span><strong class="def-name">camlight</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-camlight-7"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camlight-8">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">camlight</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-camlight-8"> ¶</a></span>
</dt> <dd>
<p>Add a light object to a figure using a simple interface. </p> <p>When called with no arguments, a light object is added to the current plot and is placed slightly above and to the right of the camera’s current position: this is equivalent to <code class="code">camlight right</code>. The commands <code class="code">camlight left</code> and <code class="code">camlight headlight</code> behave similarly with the placement being either left of the camera position or centered on the camera position. </p> <p>For more control, the light position can be specified by an azimuthal rotation <var class="var">az</var> and an elevation angle <var class="var">el</var>, both in degrees, relative to the current properties of the camera. </p> <p>The optional string <var class="var">style</var> specifies whether the light is a local point source (<code class="code">"local"</code>, the default) or placed at infinite distance (<code class="code">"infinite"</code>). </p> <p>If the first argument <var class="var">hl</var> is a handle to a light object, then act on this light object rather than creating a new object. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then create a new light object in this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a graphics handle to the light object. This can be used to move or further change properties of the light object. </p> <p>Examples: </p> <p>Add a light object to a plot </p> <pre class="example" data-language="matlab">sphere (36);
camlight</pre> <p>Position the light source exactly </p> <pre class="example" data-language="matlab">camlight (45, 30);</pre> <p>Here the light is first pitched upwards (see <a class="pxref" href="#XREFcamup"><code class="code">camup</code></a>) from the camera position (see <a class="pxref" href="#XREFcampos"><code class="code">campos</code></a>) by 30 degrees. It is then yawed by 45 degrees to the right. Both rotations are centered around the camera target (see <a class="pxref" href="#XREFcamtarget"><code class="code">camtarget</code></a>). </p> <p>Return a handle to further manipulate the light object </p> <pre class="example" data-language="matlab">clf
sphere (36);
hl = camlight ("left");
set (hl, "color", "r");</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="graphics-objects.html#XREFlight">light</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-lightangle">
<span class="category-def">: </span><span><strong class="def-name">lightangle</strong> <code class="def-code-arguments">(<var class="var">az</var>, <var class="var">el</var>)</code><a class="copiable-link" href="#index-lightangle"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lightangle-1">
<span class="category-def">: </span><span><strong class="def-name">lightangle</strong> <code class="def-code-arguments">(<var class="var">hax</var>, <var class="var">az</var>, <var class="var">el</var>)</code><a class="copiable-link" href="#index-lightangle-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lightangle-2">
<span class="category-def">: </span><span><strong class="def-name">lightangle</strong> <code class="def-code-arguments">(<var class="var">hl</var>, <var class="var">az</var>, <var class="var">el</var>)</code><a class="copiable-link" href="#index-lightangle-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lightangle-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">hl</var> =</code> <strong class="def-name">lightangle</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-lightangle-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-lightangle-4">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">az</var>, <var class="var">el</var>] =</code> <strong class="def-name">lightangle</strong> <code class="def-code-arguments">(<var class="var">hl</var>)</code><a class="copiable-link" href="#index-lightangle-4"> ¶</a></span>
</dt> <dd>
<p>Add a light object to the current axes using spherical coordinates. </p> <p>The light position is specified by an azimuthal rotation <var class="var">az</var> and an elevation angle <var class="var">el</var>, both in degrees. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then create a new light object in this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>If the first argument <var class="var">hl</var> is a handle to a light object, then act on this light object rather than creating a new object. </p> <p>The optional return value <var class="var">hl</var> is a graphics handle to the light object. </p> <p>Example: </p> <p>Add a light object to a plot </p> <pre class="example" data-language="matlab">clf;
sphere (36);
lightangle (45, 30);</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="graphics-objects.html#XREFlight">light</a>, <a class="ref" href="#XREFview">view</a>, <a class="ref" href="#XREFcamlight">camlight</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-meshgrid">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">xx</var>, <var class="var">yy</var>] =</code> <strong class="def-name">meshgrid</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-meshgrid"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshgrid-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">xx</var>, <var class="var">yy</var>, <var class="var">zz</var>] =</code> <strong class="def-name">meshgrid</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-meshgrid-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshgrid-2">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">xx</var>, <var class="var">yy</var>] =</code> <strong class="def-name">meshgrid</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-meshgrid-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-meshgrid-3">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">xx</var>, <var class="var">yy</var>, <var class="var">zz</var>] =</code> <strong class="def-name">meshgrid</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-meshgrid-3"> ¶</a></span>
</dt> <dd>
<p>Given vectors of <var class="var">x</var> and <var class="var">y</var> coordinates, return matrices <var class="var">xx</var> and <var class="var">yy</var> corresponding to a full 2-D grid. </p> <p>The rows of <var class="var">xx</var> are copies of <var class="var">x</var>, and the columns of <var class="var">yy</var> are copies of <var class="var">y</var>. If <var class="var">y</var> is omitted, then it is assumed to be the same as <var class="var">x</var>. </p> <p>If the optional <var class="var">z</var> input is given, or <var class="var">zz</var> is requested, then the output will be a full 3-D grid. If <var class="var">z</var> is omitted and <var class="var">zz</var> is requested, it is assumed to be the same as <var class="var">y</var>. </p> <p><code class="code">meshgrid</code> is most frequently used to produce input for a 2-D or 3-D function that will be plotted. The following example creates a surface plot of the “sombrero” function. </p> <pre class="example" data-language="matlab">f = @(x,y) sin (sqrt (x.^2 + y.^2)) ./ sqrt (x.^2 + y.^2);
range = linspace (-8, 8, 41);
[X, Y] = meshgrid (range, range);
Z = f (X, Y);
surf (X, Y, Z);</pre> <p>Programming Note: <code class="code">meshgrid</code> is restricted to 2-D or 3-D grid generation. The <code class="code">ndgrid</code> function will generate 1-D through N-D grids. However, the functions are not completely equivalent. If <var class="var">x</var> is a vector of length M and <var class="var">y</var> is a vector of length N, then <code class="code">meshgrid</code> will produce an output grid which is NxM. <code class="code">ndgrid</code> will produce an output which is MxN (transpose) for the same input. Some core functions expect <code class="code">meshgrid</code> input and others expect <code class="code">ndgrid</code> input. Check the documentation for the function in question to determine the proper input format. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFndgrid">ndgrid</a>, <a class="ref" href="#XREFmesh">mesh</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFcontour">contour</a>, <a class="ref" href="#XREFsurf">surf</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ndgrid">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">y1</var>, <var class="var">y2</var>, …, <var class="var">y</var>n] =</code> <strong class="def-name">ndgrid</strong> <code class="def-code-arguments">(<var class="var">x1</var>, <var class="var">x2</var>, …, <var class="var">x</var>n)</code><a class="copiable-link" href="#index-ndgrid"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ndgrid-1">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">y1</var>, <var class="var">y2</var>, …, <var class="var">y</var>n] =</code> <strong class="def-name">ndgrid</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-ndgrid-1"> ¶</a></span>
</dt> <dd>
<p>Given n vectors <var class="var">x1</var>, …, <var class="var">x</var>n, <code class="code">ndgrid</code> returns n arrays of dimension n. </p> <p>The elements of the i-th output argument contains the elements of the vector <var class="var">x</var>i repeated over all dimensions different from the i-th dimension. Calling ndgrid with only one input argument <var class="var">x</var> is equivalent to calling ndgrid with all n input arguments equal to <var class="var">x</var>: </p> <p>[<var class="var">y1</var>, <var class="var">y2</var>, …, <var class="var">y</var>n] = ndgrid (<var class="var">x</var>, …, <var class="var">x</var>) </p> <p>Programming Note: <code class="code">ndgrid</code> is very similar to the function <code class="code">meshgrid</code> except that the first two dimensions are transposed in comparison to <code class="code">meshgrid</code>. Some core functions expect <code class="code">meshgrid</code> input and others expect <code class="code">ndgrid</code> input. Check the documentation for the function in question to determine the proper input format. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmeshgrid">meshgrid</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-plot3">
<span class="category-def">: </span><span><strong class="def-name">plot3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-plot3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-plot3-1">
<span class="category-def">: </span><span><strong class="def-name">plot3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">prop</var>, <var class="var">value</var>, …)</code><a class="copiable-link" href="#index-plot3-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-plot3-2">
<span class="category-def">: </span><span><strong class="def-name">plot3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">fmt</var>)</code><a class="copiable-link" href="#index-plot3-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-plot3-3">
<span class="category-def">: </span><span><strong class="def-name">plot3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">cplx</var>)</code><a class="copiable-link" href="#index-plot3-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-plot3-4">
<span class="category-def">: </span><span><strong class="def-name">plot3</strong> <code class="def-code-arguments">(<var class="var">cplx</var>)</code><a class="copiable-link" href="#index-plot3-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-plot3-5">
<span class="category-def">: </span><span><strong class="def-name">plot3</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-plot3-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-plot3-6">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">plot3</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-plot3-6"> ¶</a></span>
</dt> <dd>
<p>Produce 3-D plots. </p> <p>Many different combinations of arguments are possible. The simplest form is </p> <pre class="example" data-language="matlab">plot3 (x, y, z)</pre> <p>in which the arguments are taken to be the vertices of the points to be plotted in three dimensions. If all arguments are vectors of the same length, then a single continuous line is drawn. If all arguments are matrices, then each column of is treated as a separate line. No attempt is made to transpose the arguments to make the number of rows match. </p> <p>If only two arguments are given, as </p> <pre class="example" data-language="matlab">plot3 (x, cplx)</pre> <p>the real and imaginary parts of the second argument are used as the <var class="var">y</var> and <var class="var">z</var> coordinates, respectively. </p> <p>If only one argument is given, as </p> <pre class="example" data-language="matlab">plot3 (cplx)</pre> <p>the real and imaginary parts of the argument are used as the <var class="var">y</var> and <var class="var">z</var> values, and they are plotted versus their index. </p> <p>Arguments may also be given in groups of three as </p> <pre class="example" data-language="matlab">plot3 (x1, y1, z1, x2, y2, z2, ...)</pre> <p>in which each set of three arguments is treated as a separate line or set of lines in three dimensions. </p> <p>To plot multiple one- or two-argument groups, separate each group with an empty format string, as </p> <pre class="example" data-language="matlab">plot3 (x1, c1, "", c2, "", ...)</pre> <p>Multiple property-value pairs may be specified which will affect the line objects drawn by <code class="code">plot3</code>. If the <var class="var">fmt</var> argument is supplied it will format the line objects in the same manner as <code class="code">plot</code>. The full list of properties is documented at <a class="ref" href="line-properties.html">Line Properties</a>. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a graphics handle to the created plot. </p> <p>Example: </p> <pre class="example" data-language="matlab">z = [0:0.05:5];
plot3 (cos (2*pi*z), sin (2*pi*z), z, ";helix;");
plot3 (z, exp (2i*pi*z), ";complex sinusoid;");</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="three_002ddimensional-function-plotting.html#XREFezplot3">ezplot3</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFplot">plot</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-view">
<span class="category-def">: </span><span><strong class="def-name">view</strong> <code class="def-code-arguments">(<var class="var">azimuth</var>, <var class="var">elevation</var>)</code><a class="copiable-link" href="#index-view"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-view-1">
<span class="category-def">: </span><span><strong class="def-name">view</strong> <code class="def-code-arguments">([<var class="var">azimuth</var> <var class="var">elevation</var>])</code><a class="copiable-link" href="#index-view-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-view-2">
<span class="category-def">: </span><span><strong class="def-name">view</strong> <code class="def-code-arguments">([<var class="var">x</var> <var class="var">y</var> <var class="var">z</var>])</code><a class="copiable-link" href="#index-view-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-view-3">
<span class="category-def">: </span><span><strong class="def-name">view</strong> <code class="def-code-arguments">(2)</code><a class="copiable-link" href="#index-view-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-view-4">
<span class="category-def">: </span><span><strong class="def-name">view</strong> <code class="def-code-arguments">(3)</code><a class="copiable-link" href="#index-view-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-view-5">
<span class="category-def">: </span><span><strong class="def-name">view</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-view-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-view-6">
<span class="category-def">: </span><span><code class="def-type">[<var class="var">azimuth</var>, <var class="var">elevation</var>] =</code> <strong class="def-name">view</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-view-6"> ¶</a></span>
</dt> <dd>
<p>Query or set the viewpoint for the current axes. </p> <p>The parameters <var class="var">azimuth</var> and <var class="var">elevation</var> can be given as two arguments or as 2-element vector. The viewpoint can also be specified with Cartesian coordinates <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var>. </p> <p>The call <code class="code">view (2)</code> sets the viewpoint to <var class="var">azimuth</var> = 0 and <var class="var">elevation</var> = 90, which is the default for 2-D graphs. </p> <p>The call <code class="code">view (3)</code> sets the viewpoint to <var class="var">azimuth</var> = -37.5 and <var class="var">elevation</var> = 30, which is the default for 3-D graphs. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then operate on this axes rather than the current axes returned by <code class="code">gca</code>. </p> <p>If no inputs are given, return the current <var class="var">azimuth</var> and <var class="var">elevation</var>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-camlookat">
<span class="category-def">: </span><span><strong class="def-name">camlookat</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-camlookat"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camlookat-1">
<span class="category-def">: </span><span><strong class="def-name">camlookat</strong> <code class="def-code-arguments">(<var class="var">h</var>)</code><a class="copiable-link" href="#index-camlookat-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camlookat-2">
<span class="category-def">: </span><span><strong class="def-name">camlookat</strong> <code class="def-code-arguments">(<var class="var">handle_list</var>)</code><a class="copiable-link" href="#index-camlookat-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camlookat-3">
<span class="category-def">: </span><span><strong class="def-name">camlookat</strong> <code class="def-code-arguments">(<var class="var">hax</var>)</code><a class="copiable-link" href="#index-camlookat-3"> ¶</a></span>
</dt> <dd>
<p>Move the camera and adjust its properties to look at objects. </p> <p>When the input is a handle <var class="var">h</var>, the camera is set to point toward the center of the bounding box of <var class="var">h</var>. The camera’s position is adjusted so the bounding box approximately fills the field of view. </p> <p>This command fixes the camera’s viewing direction (<code class="code">camtarget() - campos()</code>), camera up vector (see <a class="pxref" href="#XREFcamup"><code class="code">camup</code></a>) and viewing angle (see <a class="pxref" href="#XREFcamva"><code class="code">camva</code></a>). The camera target (see <a class="pxref" href="#XREFcamtarget"><code class="code">camtarget</code></a>) and camera position (see <a class="pxref" href="#XREFcampos"><code class="code">campos</code></a>) are changed. </p> <p>If the argument is a list <var class="var">handle_list</var>, then a single bounding box for all the objects is computed and the camera is then adjusted as above. </p> <p>If the argument is an axis object <var class="var">hax</var>, then the children of the axis are used as <var class="var">handle_list</var>. When called with no inputs, it uses the current axis (see <a class="pxref" href="graphics-objects.html#XREFgca"><code class="code">gca</code></a>). </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcamorbit">camorbit</a>, <a class="ref" href="#XREFcamzoom">camzoom</a>, <a class="ref" href="#XREFcamroll">camroll</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-campos">
<span class="category-def">: </span><span><code class="def-type"><var class="var">p</var> =</code> <strong class="def-name">campos</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-campos"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-campos-1">
<span class="category-def">: </span><span><strong class="def-name">campos</strong> <code class="def-code-arguments">([<var class="var">x</var> <var class="var">y</var> <var class="var">z</var>])</code><a class="copiable-link" href="#index-campos-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-campos-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">mode</var> =</code> <strong class="def-name">campos</strong> <code class="def-code-arguments">("mode")</code><a class="copiable-link" href="#index-campos-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-campos-3">
<span class="category-def">: </span><span><strong class="def-name">campos</strong> <code class="def-code-arguments">(<var class="var">mode</var>)</code><a class="copiable-link" href="#index-campos-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-campos-4">
<span class="category-def">: </span><span><strong class="def-name">campos</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-campos-4"> ¶</a></span>
</dt> <dd>
<p>Get or set the camera position. </p> <p>The default camera position is determined automatically based on the scene. For example, to get the camera position: </p> <pre class="example" data-language="matlab">hf = figure();
peaks()
p = campos ()
  ⇒ p =
      -27.394  -35.701   64.079</pre> <p>We can then move the camera further up the z-axis: </p> <pre class="example" data-language="matlab">campos (p + [0 0 10])
campos ()
  ⇒ ans =
      -27.394  -35.701   74.079</pre> <p>Having made that change, the camera position <var class="var">mode</var> is now manual: </p> <pre class="example" data-language="matlab">campos ("mode")
  ⇒ manual</pre> <p>We can set it back to automatic: </p> <pre class="example" data-language="matlab">campos ("auto")
campos ()
  ⇒ ans =
      -27.394  -35.701   64.079
close (hf)</pre> <p>By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument <var class="var">hax</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcamup">camup</a>, <a class="ref" href="#XREFcamtarget">camtarget</a>, <a class="ref" href="#XREFcamva">camva</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-camorbit">
<span class="category-def">: </span><span><strong class="def-name">camorbit</strong> <code class="def-code-arguments">(<var class="var">theta</var>, <var class="var">phi</var>)</code><a class="copiable-link" href="#index-camorbit"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camorbit-1">
<span class="category-def">: </span><span><strong class="def-name">camorbit</strong> <code class="def-code-arguments">(<var class="var">theta</var>, <var class="var">phi</var>, <var class="var">coorsys</var>)</code><a class="copiable-link" href="#index-camorbit-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camorbit-2">
<span class="category-def">: </span><span><strong class="def-name">camorbit</strong> <code class="def-code-arguments">(<var class="var">theta</var>, <var class="var">phi</var>, <var class="var">coorsys</var>, <var class="var">dir</var>)</code><a class="copiable-link" href="#index-camorbit-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camorbit-3">
<span class="category-def">: </span><span><strong class="def-name">camorbit</strong> <code class="def-code-arguments">(<var class="var">theta</var>, <var class="var">phi</var>, "data")</code><a class="copiable-link" href="#index-camorbit-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camorbit-4">
<span class="category-def">: </span><span><strong class="def-name">camorbit</strong> <code class="def-code-arguments">(<var class="var">theta</var>, <var class="var">phi</var>, "data", "z")</code><a class="copiable-link" href="#index-camorbit-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camorbit-5">
<span class="category-def">: </span><span><strong class="def-name">camorbit</strong> <code class="def-code-arguments">(<var class="var">theta</var>, <var class="var">phi</var>, "data", "x")</code><a class="copiable-link" href="#index-camorbit-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camorbit-6">
<span class="category-def">: </span><span><strong class="def-name">camorbit</strong> <code class="def-code-arguments">(<var class="var">theta</var>, <var class="var">phi</var>, "data", "y")</code><a class="copiable-link" href="#index-camorbit-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camorbit-7">
<span class="category-def">: </span><span><strong class="def-name">camorbit</strong> <code class="def-code-arguments">(<var class="var">theta</var>, <var class="var">phi</var>, "data", [<var class="var">x</var> <var class="var">y</var> <var class="var">z</var>])</code><a class="copiable-link" href="#index-camorbit-7"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camorbit-8">
<span class="category-def">: </span><span><strong class="def-name">camorbit</strong> <code class="def-code-arguments">(<var class="var">theta</var>, <var class="var">phi</var>, "camera")</code><a class="copiable-link" href="#index-camorbit-8"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camorbit-9">
<span class="category-def">: </span><span><strong class="def-name">camorbit</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-camorbit-9"> ¶</a></span>
</dt> <dd>
<p>Rotate the camera up/down and left/right around its target. </p> <p>Move the camera <var class="var">phi</var> degrees up and <var class="var">theta</var> degrees to the right, as if it were in an orbit around its target. Example: </p> <pre class="example" data-language="matlab">sphere ()
camorbit (30, 20)</pre> <p>These rotations are centered around the camera target (see <a class="pxref" href="#XREFcamtarget"><code class="code">camtarget</code></a>). First the camera position is pitched up or down by rotating it <var class="var">phi</var> degrees around an axis orthogonal to both the viewing direction (specifically <code class="code">camtarget() - campos()</code>) and the camera “up vector” (see <a class="pxref" href="#XREFcamup"><code class="code">camup</code></a>). Example: </p> <pre class="example" data-language="matlab">camorbit (0, 20)</pre> <p>The second rotation depends on the coordinate system <var class="var">coorsys</var> and direction <var class="var">dir</var> inputs. The default for <var class="var">coorsys</var> is <code class="code">"data"</code>. In this case, the camera is yawed left or right by rotating it <var class="var">theta</var> degrees around an axis specified by <var class="var">dir</var>. The default for <var class="var">dir</var> is <code class="code">"z"</code>, corresponding to the vector <code class="code">[0, 0, 1]</code>. Example: </p> <pre class="example" data-language="matlab">camorbit (30, 0)</pre> <p>When <var class="var">coorsys</var> is set to <code class="code">"camera"</code>, the camera is moved left or right by rotating it around an axis parallel to the camera up vector (see <a class="pxref" href="#XREFcamup"><code class="code">camup</code></a>). The input <var class="var">dir</var> should not be specified in this case. Example: </p> <pre class="example" data-language="matlab">camorbit (30, 0, "camera")</pre> <p>(Note: the rotation by <var class="var">phi</var> is unaffected by <code class="code">"camera"</code>.) </p> <p>The <code class="code">camorbit</code> command modifies two camera properties: <a class="ref" href="#XREFcampos"><code class="code">campos</code></a> and <a class="ref" href="#XREFcamup"><code class="code">camup</code></a>. </p> <p>By default, this command affects the current axis; alternatively, an axis can be specified by the optional argument <var class="var">hax</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcamzoom">camzoom</a>, <a class="ref" href="#XREFcamroll">camroll</a>, <a class="ref" href="#XREFcamlookat">camlookat</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-camroll">
<span class="category-def">: </span><span><strong class="def-name">camroll</strong> <code class="def-code-arguments">(<var class="var">theta</var>)</code><a class="copiable-link" href="#index-camroll"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camroll-1">
<span class="category-def">: </span><span><strong class="def-name">camroll</strong> <code class="def-code-arguments">(<var class="var">hax</var>, <var class="var">theta</var>)</code><a class="copiable-link" href="#index-camroll-1"> ¶</a></span>
</dt> <dd>
<p>Roll the camera. </p> <p>Roll the camera clockwise by <var class="var">theta</var> degrees. For example, the following command will roll the camera by 30 degrees clockwise (to the right); this will cause the scene to appear to roll by 30 degrees to the left: </p> <pre class="example" data-language="matlab">peaks ()
camroll (30)</pre> <p>Roll the camera back: </p> <pre class="example" data-language="matlab">camroll (-30)</pre> <p>The following command restores the default camera roll: </p> <pre class="example" data-language="matlab">camup ("auto")</pre> <p>By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument <var class="var">hax</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcamzoom">camzoom</a>, <a class="ref" href="#XREFcamorbit">camorbit</a>, <a class="ref" href="#XREFcamlookat">camlookat</a>, <a class="ref" href="#XREFcamup">camup</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-camtarget">
<span class="category-def">: </span><span><code class="def-type"><var class="var">t</var> =</code> <strong class="def-name">camtarget</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-camtarget"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camtarget-1">
<span class="category-def">: </span><span><strong class="def-name">camtarget</strong> <code class="def-code-arguments">([<var class="var">x</var> <var class="var">y</var> <var class="var">z</var>])</code><a class="copiable-link" href="#index-camtarget-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camtarget-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">mode</var> =</code> <strong class="def-name">camtarget</strong> <code class="def-code-arguments">("mode")</code><a class="copiable-link" href="#index-camtarget-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camtarget-3">
<span class="category-def">: </span><span><strong class="def-name">camtarget</strong> <code class="def-code-arguments">(<var class="var">mode</var>)</code><a class="copiable-link" href="#index-camtarget-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camtarget-4">
<span class="category-def">: </span><span><strong class="def-name">camtarget</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-camtarget-4"> ¶</a></span>
</dt> <dd>
<p>Get or set where the camera is pointed. </p> <p>The camera target is a point in space where the camera is pointing. Usually, it is determined automatically based on the scene: </p> <pre class="example" data-language="matlab">hf = figure();
sphere (36)
v = camtarget ()
  ⇒ v =
      0   0   0</pre> <p>We can turn the camera to point at a new target: </p> <pre class="example" data-language="matlab">camtarget ([1 1 1])
camtarget ()
  ⇒   1   1   1</pre> <p>Having done so, the camera target <var class="var">mode</var> is manual: </p> <pre class="example" data-language="matlab">camtarget ("mode")
  ⇒ manual</pre> <p>This means, for example, adding new objects to the scene will not retarget the camera: </p> <pre class="example" data-language="matlab">hold on;
peaks ()
camtarget ()
  ⇒   1   1   1</pre> <p>We can reset it to be automatic: </p> <pre class="example" data-language="matlab">camtarget ("auto")
camtarget ()
  ⇒   0   0   0.76426
close (hf)</pre> <p>By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument <var class="var">hax</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcampos">campos</a>, <a class="ref" href="#XREFcamup">camup</a>, <a class="ref" href="#XREFcamva">camva</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-camup">
<span class="category-def">: </span><span><code class="def-type"><var class="var">up</var> =</code> <strong class="def-name">camup</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-camup"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camup-1">
<span class="category-def">: </span><span><strong class="def-name">camup</strong> <code class="def-code-arguments">([<var class="var">x</var> <var class="var">y</var> <var class="var">z</var>])</code><a class="copiable-link" href="#index-camup-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camup-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">mode</var> =</code> <strong class="def-name">camup</strong> <code class="def-code-arguments">("mode")</code><a class="copiable-link" href="#index-camup-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camup-3">
<span class="category-def">: </span><span><strong class="def-name">camup</strong> <code class="def-code-arguments">(<var class="var">mode</var>)</code><a class="copiable-link" href="#index-camup-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camup-4">
<span class="category-def">: </span><span><strong class="def-name">camup</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-camup-4"> ¶</a></span>
</dt> <dd>
<p>Get or set the camera up vector. </p> <p>By default, the camera is oriented so that “up” corresponds to the positive z-axis: </p> <pre class="example" data-language="matlab">hf = figure ();
sphere (36)
v = camup ()
  ⇒ v =
      0   0   1</pre> <p>Specifying a new “up vector” rolls the camera and sets the mode to manual: </p> <pre class="example" data-language="matlab">camup ([1 1 0])
camup ()
  ⇒   1   1   0
camup ("mode")
  ⇒ manual</pre> <p>Modifying the up vector does not modify the camera target (see <a class="pxref" href="#XREFcamtarget"><code class="code">camtarget</code></a>). Thus, the camera up vector might not be orthogonal to the direction of the camera’s view: </p> <pre class="example" data-language="matlab">camup ([1 2 3])
dot (camup (), camtarget () - campos ())
  ⇒ 6...</pre> <p>A consequence is that “pulling back” on the up vector does not pitch the camera view (as that would require changing the target). Setting the up vector is thus typically used only to roll the camera. A more intuitive command for this purpose is <a class="ref" href="#XREFcamroll"><code class="code">camroll</code></a>. </p> <p>Finally, we can reset the up vector to automatic mode: </p> <pre class="example" data-language="matlab">camup ("auto")
camup ()
  ⇒   0   0   1
close (hf)</pre> <p>By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument <var class="var">hax</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcampos">campos</a>, <a class="ref" href="#XREFcamtarget">camtarget</a>, <a class="ref" href="#XREFcamva">camva</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-camva">
<span class="category-def">: </span><span><code class="def-type"><var class="var">a</var> =</code> <strong class="def-name">camva</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-camva"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camva-1">
<span class="category-def">: </span><span><strong class="def-name">camva</strong> <code class="def-code-arguments">(<var class="var">a</var>)</code><a class="copiable-link" href="#index-camva-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camva-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">mode</var> =</code> <strong class="def-name">camva</strong> <code class="def-code-arguments">("mode")</code><a class="copiable-link" href="#index-camva-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camva-3">
<span class="category-def">: </span><span><strong class="def-name">camva</strong> <code class="def-code-arguments">(<var class="var">mode</var>)</code><a class="copiable-link" href="#index-camva-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camva-4">
<span class="category-def">: </span><span><strong class="def-name">camva</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-camva-4"> ¶</a></span>
</dt> <dd>
<p>Get or set the camera viewing angle. </p> <p>The camera has a viewing angle which determines how much can be seen. By default this is: </p> <pre class="example" data-language="matlab">hf = figure();
sphere (36)
a = camva ()
  ⇒ a =  10.340</pre> <p>To get a wider-angle view, we could double the viewing angle. This will also set the mode to manual: </p> <pre class="example" data-language="matlab">camva (2*a)
camva ("mode")
  ⇒ manual</pre> <p>We can set it back to automatic: </p> <pre class="example" data-language="matlab">camva ("auto")
camva ("mode")
  ⇒ auto
camva ()
  ⇒ ans =  10.340
close (hf)</pre> <p>By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument <var class="var">hax</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcampos">campos</a>, <a class="ref" href="#XREFcamtarget">camtarget</a>, <a class="ref" href="#XREFcamup">camup</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-camzoom">
<span class="category-def">: </span><span><strong class="def-name">camzoom</strong> <code class="def-code-arguments">(<var class="var">zf</var>)</code><a class="copiable-link" href="#index-camzoom"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-camzoom-1">
<span class="category-def">: </span><span><strong class="def-name">camzoom</strong> <code class="def-code-arguments">(<var class="var">hax</var>, <var class="var">zf</var>)</code><a class="copiable-link" href="#index-camzoom-1"> ¶</a></span>
</dt> <dd>
<p>Zoom the camera in or out. </p> <p>A value of <var class="var">zf</var> larger than 1 “zooms in” such that the scene appears magnified: </p> <pre class="example" data-language="matlab">hf = figure ();
sphere (36)
camzoom (1.2)</pre> <p>A value smaller than 1 “zooms out” so the camera can see more of the scene: </p> <pre class="example" data-language="matlab">camzoom (0.5)</pre> <p>Technically speaking, zooming affects the “viewing angle”. The following command resets to the default zoom: </p> <pre class="example" data-language="matlab">camva ("auto")
close (hf)</pre> <p>By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument <var class="var">hax</var>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcamroll">camroll</a>, <a class="ref" href="#XREFcamorbit">camorbit</a>, <a class="ref" href="#XREFcamlookat">camlookat</a>, <a class="ref" href="#XREFcamva">camva</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-slice">
<span class="category-def">: </span><span><strong class="def-name">slice</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">sx</var>, <var class="var">sy</var>, <var class="var">sz</var>)</code><a class="copiable-link" href="#index-slice"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-slice-1">
<span class="category-def">: </span><span><strong class="def-name">slice</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>)</code><a class="copiable-link" href="#index-slice-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-slice-2">
<span class="category-def">: </span><span><strong class="def-name">slice</strong> <code class="def-code-arguments">(<var class="var">v</var>, <var class="var">sx</var>, <var class="var">sy</var>, <var class="var">sz</var>)</code><a class="copiable-link" href="#index-slice-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-slice-3">
<span class="category-def">: </span><span><strong class="def-name">slice</strong> <code class="def-code-arguments">(<var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>)</code><a class="copiable-link" href="#index-slice-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-slice-4">
<span class="category-def">: </span><span><strong class="def-name">slice</strong> <code class="def-code-arguments">(…, <var class="var">method</var>)</code><a class="copiable-link" href="#index-slice-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-slice-5">
<span class="category-def">: </span><span><strong class="def-name">slice</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-slice-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-slice-6">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">slice</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-slice-6"> ¶</a></span>
</dt> <dd>
<p>Plot slices of 3-D data/scalar fields. </p> <p>Each element of the 3-dimensional array <var class="var">v</var> represents a scalar value at a location given by the parameters <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var>. The parameters <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var> are either 3-dimensional arrays of the same size as the array <var class="var">v</var> in the <code class="code">"meshgrid"</code> format or vectors. The parameters <var class="var">xi</var>, etc. respect a similar format to <var class="var">x</var>, etc., and they represent the points at which the array <var class="var">vi</var> is interpolated using interp3. The vectors <var class="var">sx</var>, <var class="var">sy</var>, and <var class="var">sz</var> contain points of orthogonal slices of the respective axes. </p> <p>If <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var> are omitted, they are assumed to be <code class="code">x = 1:size (<var class="var">v</var>, 2)</code>, <code class="code">y = 1:size (<var class="var">v</var>, 1)</code> and <code class="code">z = 1:size (<var class="var">v</var>, 3)</code>. </p> <p><var class="var">method</var> is one of: </p> <dl class="table"> <dt><code class="code">"nearest"</code></dt> <dd>
<p>Return the nearest neighbor. </p> </dd> <dt><code class="code">"linear"</code></dt> <dd>
<p>Linear interpolation from nearest neighbors. </p> </dd> <dt><code class="code">"cubic"</code></dt> <dd>
<p>Cubic interpolation from four nearest neighbors (not implemented yet). </p> </dd> <dt><code class="code">"spline"</code></dt> <dd><p>Cubic spline interpolation—smooth first and second derivatives throughout the curve. </p></dd> </dl> <p>The default method is <code class="code">"linear"</code>. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a graphics handle to the created surface object. </p> <p>Examples: </p> <pre class="example" data-language="matlab">[x, y, z] = meshgrid (linspace (-8, 8, 32));
v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
slice (x, y, z, v, [], 0, []);

[xi, yi] = meshgrid (linspace (-7, 7));
zi = xi + yi;
slice (x, y, z, v, xi, yi, zi);</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="multi_002ddimensional-interpolation.html#XREFinterp3">interp3</a>, <a class="ref" href="graphics-objects.html#XREFsurface">surface</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFpcolor">pcolor</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-ribbon">
<span class="category-def">: </span><span><strong class="def-name">ribbon</strong> <code class="def-code-arguments">(<var class="var">y</var>)</code><a class="copiable-link" href="#index-ribbon"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ribbon-1">
<span class="category-def">: </span><span><strong class="def-name">ribbon</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-ribbon-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ribbon-2">
<span class="category-def">: </span><span><strong class="def-name">ribbon</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">width</var>)</code><a class="copiable-link" href="#index-ribbon-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ribbon-3">
<span class="category-def">: </span><span><strong class="def-name">ribbon</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-ribbon-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-ribbon-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">ribbon</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-ribbon-4"> ¶</a></span>
</dt> <dd>
<p>Draw a ribbon plot for the columns of <var class="var">y</var> vs. <var class="var">x</var>. </p> <p>If <var class="var">x</var> is omitted, a vector containing the row numbers is assumed (<code class="code">1:rows (Y)</code>). Alternatively, <var class="var">x</var> can also be a vector with same number of elements as rows of <var class="var">y</var> in which case the same <var class="var">x</var> is used for each column of <var class="var">y</var>. </p> <p>The optional parameter <var class="var">width</var> specifies the width of a single ribbon (default is 0.75). </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a vector of graphics handles to the surface objects representing each ribbon. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="graphics-objects.html#XREFsurface">surface</a>, <a class="ref" href="#XREFwaterfall">waterfall</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-shading">
<span class="category-def">: </span><span><strong class="def-name">shading</strong> <code class="def-code-arguments">(<var class="var">type</var>)</code><a class="copiable-link" href="#index-shading"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-shading-1">
<span class="category-def">: </span><span><strong class="def-name">shading</strong> <code class="def-code-arguments">(<var class="var">hax</var>, <var class="var">type</var>)</code><a class="copiable-link" href="#index-shading-1"> ¶</a></span>
</dt> <dd>
<p>Set the shading of patch or surface graphic objects. </p> <p>Valid arguments for <var class="var">type</var> are </p> <dl class="table"> <dt><code class="code">"flat"</code></dt> <dd>
<p>Single colored patches with invisible edges. </p> </dd> <dt><code class="code">"faceted"</code></dt> <dd>
<p>Single colored patches with black edges. </p> </dd> <dt><code class="code">"interp"</code></dt> <dd><p>Colors between patch vertices are interpolated and the patch edges are invisible. </p></dd> </dl> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="two_002ddimensional-plots.html#XREFfill">fill</a>, <a class="ref" href="#XREFmesh">mesh</a>, <a class="ref" href="graphics-objects.html#XREFpatch">patch</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFpcolor">pcolor</a>, <a class="ref" href="#XREFsurf">surf</a>, <a class="ref" href="graphics-objects.html#XREFsurface">surface</a>, <a class="ref" href="#XREFhidden">hidden</a>, <a class="ref" href="#XREFlighting">lighting</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-scatter3">
<span class="category-def">: </span><span><strong class="def-name">scatter3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-scatter3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-scatter3-1">
<span class="category-def">: </span><span><strong class="def-name">scatter3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">s</var>)</code><a class="copiable-link" href="#index-scatter3-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-scatter3-2">
<span class="category-def">: </span><span><strong class="def-name">scatter3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">s</var>, <var class="var">c</var>)</code><a class="copiable-link" href="#index-scatter3-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-scatter3-3">
<span class="category-def">: </span><span><strong class="def-name">scatter3</strong> <code class="def-code-arguments">(…, <var class="var">style</var>)</code><a class="copiable-link" href="#index-scatter3-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-scatter3-4">
<span class="category-def">: </span><span><strong class="def-name">scatter3</strong> <code class="def-code-arguments">(…, "filled")</code><a class="copiable-link" href="#index-scatter3-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-scatter3-5">
<span class="category-def">: </span><span><strong class="def-name">scatter3</strong> <code class="def-code-arguments">(…, <var class="var">prop</var>, <var class="var">val</var>)</code><a class="copiable-link" href="#index-scatter3-5"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-scatter3-6">
<span class="category-def">: </span><span><strong class="def-name">scatter3</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-scatter3-6"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-scatter3-7">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">scatter3</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-scatter3-7"> ¶</a></span>
</dt> <dd>
<p>Draw a 3-D scatter plot. </p> <p>A marker is plotted at each point defined by the coordinates in the vectors <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var>. </p> <p>The size of the markers is determined by <var class="var">s</var>, which can be a scalar or a vector of the same length as <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var>. If <var class="var">s</var> is not given, or is an empty matrix, then a default value of 8 points is used. </p> <p>The color of the markers is determined by <var class="var">c</var>, which can be a string defining a fixed color; a 3-element vector giving the red, green, and blue components of the color; a vector of the same length as <var class="var">x</var> that gives a scaled index into the current colormap; or an Nx3 matrix defining the RGB color of each marker individually. </p> <p>The marker to use can be changed with the <var class="var">style</var> argument, that is a string defining a marker in the same manner as the <code class="code">plot</code> command. If no marker is specified it defaults to <code class="code">"o"</code> or circles. If the argument <code class="code">"filled"</code> is given then the markers are filled. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a graphics handle to the scatter object representing the points. </p> <pre class="example" data-language="matlab">[x, y, z] = peaks (20);
scatter3 (x(:), y(:), z(:), [], z(:));</pre> <p>Programming Note: The full list of properties is documented at <a class="ref" href="scatter-properties.html">Scatter Properties</a>. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="two_002ddimensional-plots.html#XREFscatter">scatter</a>, <a class="ref" href="graphics-objects.html#XREFpatch">patch</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFplot">plot</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-waterfall">
<span class="category-def">: </span><span><strong class="def-name">waterfall</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-waterfall"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-waterfall-1">
<span class="category-def">: </span><span><strong class="def-name">waterfall</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-waterfall-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-waterfall-2">
<span class="category-def">: </span><span><strong class="def-name">waterfall</strong> <code class="def-code-arguments">(…, <var class="var">c</var>)</code><a class="copiable-link" href="#index-waterfall-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-waterfall-3">
<span class="category-def">: </span><span><strong class="def-name">waterfall</strong> <code class="def-code-arguments">(…, <var class="var">prop</var>, <var class="var">val</var>, …)</code><a class="copiable-link" href="#index-waterfall-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-waterfall-4">
<span class="category-def">: </span><span><strong class="def-name">waterfall</strong> <code class="def-code-arguments">(<var class="var">hax</var>, …)</code><a class="copiable-link" href="#index-waterfall-4"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-waterfall-5">
<span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">waterfall</strong> <code class="def-code-arguments">(…)</code><a class="copiable-link" href="#index-waterfall-5"> ¶</a></span>
</dt> <dd>
<p>Plot a 3-D waterfall plot. </p> <p>A waterfall plot is similar to a <code class="code">meshz</code> plot except only mesh lines for the rows of <var class="var">z</var> (x-values) are shown. </p> <p>The wireframe mesh is plotted using rectangles. The vertices of the rectangles [<var class="var">x</var>, <var class="var">y</var>] are typically the output of <code class="code">meshgrid</code>. over a 2-D rectangular region in the x-y plane. <var class="var">z</var> determines the height above the plane of each vertex. If only a single <var class="var">z</var> matrix is given, then it is plotted over the meshgrid <code class="code"><var class="var">x</var> = 1:columns (<var class="var">z</var>), <var class="var">y</var> = 1:rows (<var class="var">z</var>)</code>. Thus, columns of <var class="var">z</var> correspond to different <var class="var">x</var> values and rows of <var class="var">z</var> correspond to different <var class="var">y</var> values. </p> <p>The color of the mesh is computed by linearly scaling the <var class="var">z</var> values to fit the range of the current colormap. Use <code class="code">caxis</code> and/or change the colormap to control the appearance. </p> <p>Optionally the color of the mesh can be specified independently of <var class="var">z</var> by supplying a color matrix, <var class="var">c</var>. </p> <p>Any property/value pairs are passed directly to the underlying surface object. The full list of properties is documented at <a class="ref" href="surface-properties.html">Surface Properties</a>. </p> <p>If the first argument <var class="var">hax</var> is an axes handle, then plot into this axes, rather than the current axes returned by <code class="code">gca</code>. </p> <p>The optional return value <var class="var">h</var> is a graphics handle to the created surface object. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmeshz">meshz</a>, <a class="ref" href="#XREFmesh">mesh</a>, <a class="ref" href="#XREFmeshc">meshc</a>, <a class="ref" href="two_002ddimensional-plots.html#XREFcontour">contour</a>, <a class="ref" href="#XREFsurf">surf</a>, <a class="ref" href="graphics-objects.html#XREFsurface">surface</a>, <a class="ref" href="#XREFribbon">ribbon</a>, <a class="ref" href="#XREFmeshgrid">meshgrid</a>, <a class="ref" href="#XREFhidden">hidden</a>, <a class="ref" href="#XREFshading">shading</a>, <a class="ref" href="representing-images.html#XREFcolormap">colormap</a>, <a class="ref" href="axis-configuration.html#XREFcaxis">caxis</a>. </p>
</dd>
</dl> <ul class="mini-toc"> <li><a href="aspect-ratio.html" accesskey="1">Aspect Ratio</a></li> <li><a href="three_002ddimensional-function-plotting.html" accesskey="2">Three-dimensional Function Plotting</a></li> <li><a href="three_002ddimensional-geometric-shapes.html" accesskey="3">Three-dimensional Geometric Shapes</a></li> </ul> </div>  <div class="nav-panel"> <p> Next: <a href="plot-annotations.html">Plot Annotations</a>, Previous: <a href="two_002ddimensional-plots.html">Two-Dimensional Plots</a>, Up: <a href="high_002dlevel-plotting.html">High-Level Plotting</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Three_002dDimensional-Plots.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Three_002dDimensional-Plots.html</a>
  </p>
</div>
