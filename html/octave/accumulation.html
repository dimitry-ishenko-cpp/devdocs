<div class="section-level-extent" id="Accumulation"> <div class="nav-panel"> <p> Next: <a href="memoization.html" accesskey="n" rel="next">Memoization</a>, Previous: <a href="function-application.html" accesskey="p" rel="prev">Function Application</a>, Up: <a href="vectorization-and-faster-code-execution.html" accesskey="u" rel="up">Vectorization and Faster Code Execution</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Accumulation-1"><span>19.4 Accumulation<a class="copiable-link" href="#Accumulation-1"> ¶</a></span></h1> <p>Whenever it’s possible to categorize according to indices the elements of an array when performing a computation, accumulation functions can be useful. </p>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-accumarray">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">accumarray</strong> <code class="def-code-arguments">(<var class="var">subs</var>, <var class="var">vals</var>)</code><a class="copiable-link" href="#index-accumarray"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-accumarray-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">accumarray</strong> <code class="def-code-arguments">(<var class="var">subs</var>, <var class="var">vals</var>, <var class="var">sz</var>)</code><a class="copiable-link" href="#index-accumarray-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-accumarray-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">accumarray</strong> <code class="def-code-arguments">(<var class="var">subs</var>, <var class="var">vals</var>, <var class="var">sz</var>, <var class="var">fcn</var>)</code><a class="copiable-link" href="#index-accumarray-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-accumarray-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">accumarray</strong> <code class="def-code-arguments">(<var class="var">subs</var>, <var class="var">vals</var>, <var class="var">sz</var>, <var class="var">fcn</var>, <var class="var">fillval</var>)</code><a class="copiable-link" href="#index-accumarray-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-accumarray-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">accumarray</strong> <code class="def-code-arguments">(<var class="var">subs</var>, <var class="var">vals</var>, <var class="var">sz</var>, <var class="var">fcn</var>, <var class="var">fillval</var>, <var class="var">issparse</var>)</code><a class="copiable-link" href="#index-accumarray-4"> ¶</a></span>
</dt> <dd> <p>Create an array by accumulating the elements of a vector into the positions defined by their subscripts. </p> <p>The subscripts are defined by the rows of the matrix <var class="var">subs</var> and the values by <var class="var">vals</var>. Each row of <var class="var">subs</var> corresponds to one of the values in <var class="var">vals</var>. If <var class="var">vals</var> is a scalar, it will be used for each of the row of <var class="var">subs</var>. If <var class="var">subs</var> is a cell array of vectors, all vectors must be of the same length, and the subscripts in the <var class="var">k</var>th vector must correspond to the <var class="var">k</var>th dimension of the result. </p> <p>The size of the matrix will be determined by the subscripts themselves. However, if <var class="var">sz</var> is defined it determines the matrix size. The length of <var class="var">sz</var> must correspond to the number of columns in <var class="var">subs</var>. An exception is if <var class="var">subs</var> has only one column, in which case <var class="var">sz</var> may be the dimensions of a vector and the subscripts of <var class="var">subs</var> are taken as the indices into it. </p> <p>The default action of <code class="code">accumarray</code> is to sum the elements with the same subscripts. This behavior can be modified by defining the <var class="var">fcn</var> function. This should be a function or function handle that accepts a column vector and returns a scalar. The result of the function should not depend on the order of the subscripts. </p> <p>The elements of the returned array that have no subscripts associated with them are set to zero. Defining <var class="var">fillval</var> to some other value allows these values to be defined. This behavior changes, however, for certain values of <var class="var">fcn</var>. If <var class="var">fcn</var> is <code class="code">@min</code> (respectively, <code class="code">@max</code>) then the result will be filled with the minimum (respectively, maximum) integer if <var class="var">vals</var> is of integral type, logical false (respectively, logical true) if <var class="var">vals</var> is of logical type, zero if <var class="var">fillval</var> is zero and all values are non-positive (respectively, non-negative), and NaN otherwise. </p> <p>By default <code class="code">accumarray</code> returns a full matrix. If <var class="var">issparse</var> is logically true, then a sparse matrix is returned instead. </p> <p>The following <code class="code">accumarray</code> example constructs a frequency table that in the first column counts how many occurrences each number in the second column has, taken from the vector <var class="var">x</var>. Note the usage of <code class="code">unique</code> for assigning to all repeated elements of <var class="var">x</var> the same index (see <a class="pxref" href="sets.html#XREFunique"><code class="code">unique</code></a>). </p> <pre class="example" data-language="matlab">x = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
[u, ~, j] = unique (x);
[accumarray(j', 1), u']
  ⇒  2    89
      3    90
      2    91
      2    92
      3   100</pre> <p>Another example, where the result is a multi-dimensional 3-D array and the default value (zero) appears in the output: </p> <pre class="example" data-language="matlab">accumarray ([1, 1, 1;
             2, 1, 2;
             2, 3, 2;
             2, 1, 2;
             2, 3, 2], 101:105)
⇒ ans(:,:,1) = [101, 0, 0; 0, 0, 0]
⇒ ans(:,:,2) = [0, 0, 0; 206, 0, 208]</pre> <p>The sparse option can be used as an alternative to the <code class="code">sparse</code> constructor (see <a class="pxref" href="creating-sparse-matrices.html#XREFsparse"><code class="code">sparse</code></a>). Thus </p> <pre class="example" data-language="matlab">sparse (i, j, sv)</pre> <p>can be written with <code class="code">accumarray</code> as </p> <pre class="example" data-language="matlab">accumarray ([i, j], sv', [], [], 0, true)</pre> <p>For repeated indices, <code class="code">sparse</code> adds the corresponding value. To take the minimum instead, use <code class="code">min</code> as an accumulator function: </p> <pre class="example" data-language="matlab">accumarray ([i, j], sv', [], @min, 0, true)</pre> <p>The complexity of accumarray in general for the non-sparse case is generally O(M+N), where N is the number of subscripts and M is the maximum subscript (linearized in multi-dimensional case). If <var class="var">fcn</var> is one of <code class="code">@sum</code> (default), <code class="code">@max</code>, <code class="code">@min</code> or <code class="code">@(x) {x}</code>, an optimized code path is used. Note that for general reduction function the interpreter overhead can play a major part and it may be more efficient to do multiple accumarray calls and compute the results in a vectorized manner. </p> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFaccumdim">accumdim</a>, <a class="ref" href="sets.html#XREFunique">unique</a>, <a class="ref" href="creating-sparse-matrices.html#XREFsparse">sparse</a>. </p>
</dd>
</dl>  <dl class="first-deftypefn"> <dt class="deftypefn" id="index-accumdim">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">accumdim</strong> <code class="def-code-arguments">(<var class="var">subs</var>, <var class="var">vals</var>)</code><a class="copiable-link" href="#index-accumdim"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-accumdim-1">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">accumdim</strong> <code class="def-code-arguments">(<var class="var">subs</var>, <var class="var">vals</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-accumdim-1"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-accumdim-2">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">accumdim</strong> <code class="def-code-arguments">(<var class="var">subs</var>, <var class="var">vals</var>, <var class="var">dim</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-accumdim-2"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-accumdim-3">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">accumdim</strong> <code class="def-code-arguments">(<var class="var">subs</var>, <var class="var">vals</var>, <var class="var">dim</var>, <var class="var">n</var>, <var class="var">fcn</var>)</code><a class="copiable-link" href="#index-accumdim-3"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-accumdim-4">
<span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">accumdim</strong> <code class="def-code-arguments">(<var class="var">subs</var>, <var class="var">vals</var>, <var class="var">dim</var>, <var class="var">n</var>, <var class="var">fcn</var>, <var class="var">fillval</var>)</code><a class="copiable-link" href="#index-accumdim-4"> ¶</a></span>
</dt> <dd>
<p>Create an array by accumulating the slices of an array into the positions defined by their subscripts along a specified dimension. </p> <p>The subscripts are defined by the index vector <var class="var">subs</var>. The dimension is specified by <var class="var">dim</var>. If not given, it defaults to the first non-singleton dimension. The length of <var class="var">subs</var> must be equal to <code class="code">size (<var class="var">vals</var>, <var class="var">dim</var>)</code>. </p> <p>The extent of the result matrix in the working dimension will be determined by the subscripts themselves. However, if <var class="var">n</var> is defined it determines this extent. </p> <p>The default action of <code class="code">accumdim</code> is to sum the subarrays with the same subscripts. This behavior can be modified by defining the <var class="var">fcn</var> function. This should be a function or function handle that accepts an array and a dimension, and reduces the array along this dimension. As a special exception, the built-in <code class="code">min</code> and <code class="code">max</code> functions can be used directly, and <code class="code">accumdim</code> accounts for the middle empty argument that is used in their calling. </p> <p>The slices of the returned array that have no subscripts associated with them are set to zero. Defining <var class="var">fillval</var> to some other value allows these values to be defined. </p> <p>An example of the use of <code class="code">accumdim</code> is: </p> <pre class="example" data-language="matlab">accumdim ([1, 2, 1, 2, 1], [ 7, -10,   4;
                            -5, -12,   8;
                           -12,   2,   8;
                           -10,   9,  -3;
                            -5,  -3, -13])
⇒ [-10,-11,-1;-15,-3,5]</pre> <p><strong class="strong">See also:</strong> <a class="ref" href="#XREFaccumarray">accumarray</a>. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="memoization.html">Memoization</a>, Previous: <a href="function-application.html">Function Application</a>, Up: <a href="vectorization-and-faster-code-execution.html">Vectorization and Faster Code Execution</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v9.2.0/Accumulation.html" class="_attribution-link">https://docs.octave.org/v9.2.0/Accumulation.html</a>
  </p>
</div>
