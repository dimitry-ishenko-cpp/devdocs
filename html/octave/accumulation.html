<div class="section" id="Accumulation">   <h1 class="section">19.4 Accumulation</h1> <p>Whenever it’s possible to categorize according to indices the elements of an array when performing a computation, accumulation functions can be useful. </p> <dl class="def"> <dt id="index-accumarray">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>accumarray</strong> <em>(<var>subs</var>, <var>vals</var>)</em><a href="#index-accumarray" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-accumarray-1">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>accumarray</strong> <em>(<var>subs</var>, <var>vals</var>, <var>sz</var>)</em><a href="#index-accumarray-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-accumarray-2">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>accumarray</strong> <em>(<var>subs</var>, <var>vals</var>, <var>sz</var>, <var>fcn</var>)</em><a href="#index-accumarray-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-accumarray-3">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>accumarray</strong> <em>(<var>subs</var>, <var>vals</var>, <var>sz</var>, <var>fcn</var>, <var>fillval</var>)</em><a href="#index-accumarray-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-accumarray-4">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>accumarray</strong> <em>(<var>subs</var>, <var>vals</var>, <var>sz</var>, <var>fcn</var>, <var>fillval</var>, <var>issparse</var>)</em><a href="#index-accumarray-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Create an array by accumulating the elements of a vector into the positions defined by their subscripts. </p> <p>The subscripts are defined by the rows of the matrix <var>subs</var> and the values by <var>vals</var>. Each row of <var>subs</var> corresponds to one of the values in <var>vals</var>. If <var>vals</var> is a scalar, it will be used for each of the row of <var>subs</var>. If <var>subs</var> is a cell array of vectors, all vectors must be of the same length, and the subscripts in the <var>k</var>th vector must correspond to the <var>k</var>th dimension of the result. </p> <p>The size of the matrix will be determined by the subscripts themselves. However, if <var>sz</var> is defined it determines the matrix size. The length of <var>sz</var> must correspond to the number of columns in <var>subs</var>. An exception is if <var>subs</var> has only one column, in which case <var>sz</var> may be the dimensions of a vector and the subscripts of <var>subs</var> are taken as the indices into it. </p> <p>The default action of <code>accumarray</code> is to sum the elements with the same subscripts. This behavior can be modified by defining the <var>fcn</var> function. This should be a function or function handle that accepts a column vector and returns a scalar. The result of the function should not depend on the order of the subscripts. </p> <p>The elements of the returned array that have no subscripts associated with them are set to zero. Defining <var>fillval</var> to some other value allows these values to be defined. This behavior changes, however, for certain values of <var>fcn</var>. If <var>fcn</var> is <code>@min</code> (respectively, <code>@max</code>) then the result will be filled with the minimum (respectively, maximum) integer if <var>vals</var> is of integral type, logical false (respectively, logical true) if <var>vals</var> is of logical type, zero if <var>fillval</var> is zero and all values are non-positive (respectively, non-negative), and NaN otherwise. </p> <p>By default <code>accumarray</code> returns a full matrix. If <var>issparse</var> is logically true, then a sparse matrix is returned instead. </p> <p>The following <code>accumarray</code> example constructs a frequency table that in the first column counts how many occurrences each number in the second column has, taken from the vector <var>x</var>. Note the usage of <code>unique</code> for assigning to all repeated elements of <var>x</var> the same index (see <a href="sets.html#XREFunique"><code>unique</code></a>). </p> <pre class="example" data-language="matlab">x = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
[u, ~, j] = unique (x);
[accumarray(j', 1), u']
  ⇒  2    89
      3    90
      2    91
      2    92
      3   100</pre> <p>Another example, where the result is a multi-dimensional 3-D array and the default value (zero) appears in the output: </p> <pre class="example" data-language="matlab">accumarray ([1, 1, 1;
             2, 1, 2;
             2, 3, 2;
             2, 1, 2;
             2, 3, 2], 101:105)
⇒ ans(:,:,1) = [101, 0, 0; 0, 0, 0]
⇒ ans(:,:,2) = [0, 0, 0; 206, 0, 208]</pre> <p>The sparse option can be used as an alternative to the <code>sparse</code> constructor (see <a href="creating-sparse-matrices.html#XREFsparse"><code>sparse</code></a>). Thus </p> <pre class="example" data-language="matlab">sparse (i, j, sv)</pre> <p>can be written with <code>accumarray</code> as </p> <pre class="example" data-language="matlab">accumarray ([i, j], sv', [], [], 0, true)</pre> <p>For repeated indices, <code>sparse</code> adds the corresponding value. To take the minimum instead, use <code>min</code> as an accumulator function: </p> <pre class="example" data-language="matlab">accumarray ([i, j], sv', [], @min, 0, true)</pre> <p>The complexity of accumarray in general for the non-sparse case is generally O(M+N), where N is the number of subscripts and M is the maximum subscript (linearized in multi-dimensional case). If <var>fcn</var> is one of <code>@sum</code> (default), <code>@max</code>, <code>@min</code> or <code>@(x) {x}</code>, an optimized code path is used. Note that for general reduction function the interpreter overhead can play a major part and it may be more efficient to do multiple accumarray calls and compute the results in a vectorized manner. </p> <p><strong>See also:</strong> <a href="#XREFaccumdim">accumdim</a>, <a href="sets.html#XREFunique">unique</a>, <a href="creating-sparse-matrices.html#XREFsparse">sparse</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-accumdim">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>accumdim</strong> <em>(<var>subs</var>, <var>vals</var>)</em><a href="#index-accumdim" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-accumdim-1">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>accumdim</strong> <em>(<var>subs</var>, <var>vals</var>, <var>dim</var>)</em><a href="#index-accumdim-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-accumdim-2">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>accumdim</strong> <em>(<var>subs</var>, <var>vals</var>, <var>dim</var>, <var>n</var>)</em><a href="#index-accumdim-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-accumdim-3">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>accumdim</strong> <em>(<var>subs</var>, <var>vals</var>, <var>dim</var>, <var>n</var>, <var>fcn</var>)</em><a href="#index-accumdim-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-accumdim-4">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>accumdim</strong> <em>(<var>subs</var>, <var>vals</var>, <var>dim</var>, <var>n</var>, <var>fcn</var>, <var>fillval</var>)</em><a href="#index-accumdim-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Create an array by accumulating the slices of an array into the positions defined by their subscripts along a specified dimension. </p> <p>The subscripts are defined by the index vector <var>subs</var>. The dimension is specified by <var>dim</var>. If not given, it defaults to the first non-singleton dimension. The length of <var>subs</var> must be equal to <code>size (<var>vals</var>, <var>dim</var>)</code>. </p> <p>The extent of the result matrix in the working dimension will be determined by the subscripts themselves. However, if <var>n</var> is defined it determines this extent. </p> <p>The default action of <code>accumdim</code> is to sum the subarrays with the same subscripts. This behavior can be modified by defining the <var>fcn</var> function. This should be a function or function handle that accepts an array and a dimension, and reduces the array along this dimension. As a special exception, the built-in <code>min</code> and <code>max</code> functions can be used directly, and <code>accumdim</code> accounts for the middle empty argument that is used in their calling. </p> <p>The slices of the returned array that have no subscripts associated with them are set to zero. Defining <var>fillval</var> to some other value allows these values to be defined. </p> <p>An example of the use of <code>accumdim</code> is: </p> <pre class="example" data-language="matlab">accumdim ([1, 2, 1, 2, 1], [ 7, -10,   4;
                            -5, -12,   8;
                           -12,   2,   8;
                           -10,   9,  -3;
                            -5,  -3, -13])
⇒ [-10,-11,-1;-15,-3,5]</pre> <p><strong>See also:</strong> <a href="#XREFaccumarray">accumarray</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Accumulation.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Accumulation.html</a>
  </p>
</div>
