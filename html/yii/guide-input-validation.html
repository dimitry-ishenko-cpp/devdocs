<h1>Validating Input 
</h1> <div class="toc"><ol>
<li><a href="#declaring-rules">Declaring Rules</a></li> <li><a href="#ad-hoc-validation">Ad Hoc Validation</a></li> <li><a href="#creating-validators">Creating Validators</a></li> <li><a href="#multiple-attributes-validation">Multiple Attributes Validation</a></li> <li><a href="#client-side-validation">Client-Side Validation</a></li>
</ol></div> <p>As a rule of thumb, you should never trust the data received from end users and should always validate it before putting it to good use.</p> <p>Given a <a href="guide-structure-models.html">model</a> populated with user inputs, you can validate the inputs by calling the <a href="yii-base-model.html#validate()-detail">yii\base\Model::validate()</a> method. The method will return a boolean value indicating whether the validation succeeded or not. If not, you may get the error messages from the <a href="yii-base-model.html#%24errors-detail">yii\base\Model::$errors</a> property. For example,</p> <pre data-language="php">$model = new \app\models\ContactForm();

// populate model attributes with user inputs
$model-&gt;load(\Yii::$app-&gt;request-&gt;post());
// which is equivalent to the following:
// $model-&gt;attributes = \Yii::$app-&gt;request-&gt;post('ContactForm');

if ($model-&gt;validate()) {
    // all inputs are valid
} else {
    // validation failed: $errors is an array containing error messages
    $errors = $model-&gt;errors;
}
</pre> <h2>Declaring Rules 
</h2>
<p>To make <code>validate()</code> really work, you should declare validation rules for the attributes you plan to validate. This should be done by overriding the <a href="yii-base-model.html#rules()-detail">yii\base\Model::rules()</a> method. The following example shows how the validation rules for the <code>ContactForm</code> model are declared:</p> <pre data-language="php">public function rules()
{
    return [
        // the name, email, subject and body attributes are required
        [['name', 'email', 'subject', 'body'], 'required'],

        // the email attribute should be a valid email address
        ['email', 'email'],
    ];
}
</pre> <p>The <a href="yii-base-model.html#rules()-detail">rules()</a> method should return an array of rules, each of which is an array of the following format:</p> <pre data-language="php">[
    // required, specifies which attributes should be validated by this rule.
    // For a single attribute, you can use the attribute name directly
    // without having it in an array
    ['attribute1', 'attribute2', ...],

    // required, specifies the type of this rule.
    // It can be a class name, validator alias, or a validation method name
    'validator',

    // optional, specifies in which scenario(s) this rule should be applied
    // if not given, it means the rule applies to all scenarios
    // You may also configure the "except" option if you want to apply the rule
    // to all scenarios except the listed ones
    'on' =&gt; ['scenario1', 'scenario2', ...],

    // optional, specifies additional configurations for the validator object
    'property1' =&gt; 'value1', 'property2' =&gt; 'value2', ...
]
</pre> <p>For each rule you must specify at least which attributes the rule applies to and what is the type of the rule. You can specify the rule type in one of the following forms:</p> <ul> <li>the alias of a core validator, such as <code>required</code>, <code>in</code>, <code>date</code>, etc. Please refer to the <a href="guide-tutorial-core-validators.html">Core Validators</a> for the complete list of core validators.</li> <li>the name of a validation method in the model class, or an anonymous function. Please refer to the <a href="#inline-validators">Inline Validators</a> subsection for more details.</li> <li>a fully qualified validator class name. Please refer to the <a href="#standalone-validators">Standalone Validators</a> subsection for more details.</li> </ul> <p>A rule can be used to validate one or multiple attributes, and an attribute may be validated by one or multiple rules. A rule may be applied in certain <a href="guide-structure-models.html#scenarios">scenarios</a> only by specifying the <code>on</code> option. If you do not specify an <code>on</code> option, it means the rule will be applied to all scenarios.</p> <p>When the <code>validate()</code> method is called, it does the following steps to perform validation:</p> <ol> <li>Determine which attributes should be validated by getting the attribute list from <a href="yii-base-model.html#scenarios()-detail">yii\base\Model::scenarios()</a> using the current <a href="yii-base-model.html#%24scenario-detail">scenario</a>. These attributes are called <em>active attributes</em>.</li> <li>Determine which validation rules should be used by getting the rule list from <a href="yii-base-model.html#rules()-detail">yii\base\Model::rules()</a> using the current <a href="yii-base-model.html#%24scenario-detail">scenario</a>. These rules are called <em>active rules</em>.</li> <li>Use each active rule to validate each active attribute which is associated with the rule. The validation rules are evaluated in the order they are listed.</li> </ol> <p>According to the above validation steps, an attribute will be validated if and only if it is an active attribute declared in <code>scenarios()</code> and is associated with one or multiple active rules declared in <code>rules()</code>.</p> <blockquote class="note">
<p><strong>Note: </strong>It is handy to give names to rules i.e.</p> <pre data-language="php">public function rules()
{
    return [
        // ...
        'password' =&gt; [['password'], 'string', 'max' =&gt; 60],
    ];
}
</pre> <p>You can use it in a child model:</p> <pre data-language="php">public function rules()
{
    $rules = parent::rules();
    unset($rules['password']);
    return $rules;
}
</pre> </blockquote> <h3>Customizing Error Messages 
</h3>
<p>Most validators have default error messages that will be added to the model being validated when its attributes fail the validation. For example, the <a href="yii-validators-requiredvalidator.html">required</a> validator will add a message "Username cannot be blank." to a model when the <code>username</code> attribute fails the rule using this validator.</p> <p>You can customize the error message of a rule by specifying the <code>message</code> property when declaring the rule, like the following,</p> <pre data-language="php">public function rules()
{
    return [
        ['username', 'required', 'message' =&gt; 'Please choose a username.'],
    ];
}
</pre> <p>Some validators may support additional error messages to more precisely describe different causes of validation failures. For example, the <a href="yii-validators-numbervalidator.html">number</a> validator supports <a href="yii-validators-numbervalidator.html#%24tooBig-detail">tooBig</a> and <a href="yii-validators-numbervalidator.html#%24tooSmall-detail">tooSmall</a> to describe the validation failure when the value being validated is too big and too small, respectively. You may configure these error messages like configuring other properties of validators in a validation rule.</p> <h3>Validation Events 
</h3>
<p>When <a href="yii-base-model.html#validate()-detail">yii\base\Model::validate()</a> is called, it will call two methods that you may override to customize the validation process:</p> <ul> <li>
<a href="yii-base-model.html#beforeValidate()-detail">yii\base\Model::beforeValidate()</a>: the default implementation will trigger a <a href="yii-base-model.html#EVENT_BEFORE_VALIDATE-detail">yii\base\Model::EVENT_BEFORE_VALIDATE</a> event. You may either override this method or respond to this event to do some preprocessing work (e.g. normalizing data inputs) before the validation occurs. The method should return a boolean value indicating whether the validation should proceed or not.</li> <li>
<a href="yii-base-model.html#afterValidate()-detail">yii\base\Model::afterValidate()</a>: the default implementation will trigger a <a href="yii-base-model.html#EVENT_AFTER_VALIDATE-detail">yii\base\Model::EVENT_AFTER_VALIDATE</a> event. You may either override this method or respond to this event to do some postprocessing work after the validation is completed.</li> </ul> <h3>Conditional Validation 
</h3>
<p>To validate attributes only when certain conditions apply, e.g. the validation of one attribute depends on the value of another attribute you can use the <a href="yii-validators-validator.html#%24when-detail">when</a> property to define such conditions. For example,</p> <pre data-language="php">    ['state', 'required', 'when' =&gt; function($model) {
        return $model-&gt;country == 'USA';
    }]
</pre> <p>The <a href="yii-validators-validator.html#%24when-detail">when</a> property takes a PHP callable with the following signature:</p> <pre data-language="php">/**
 * @param Model $model the model being validated
 * @param string $attribute the attribute being validated
 * @return bool whether the rule should be applied
 */
function ($model, $attribute)
</pre> <p>If you also need to support client-side conditional validation, you should configure the <a href="yii-validators-validator.html#%24whenClient-detail">whenClient</a> property which takes a string representing a JavaScript function whose return value determines whether to apply the rule or not. For example,</p> <pre data-language="php">    ['state', 'required', 'when' =&gt; function ($model) {
        return $model-&gt;country == 'USA';
    }, 'whenClient' =&gt; "function (attribute, value) {
        return $('#country').val() == 'USA';
    }"]
</pre> <h3>Data Filtering 
</h3>
<p>User inputs often need to be filtered or preprocessed. For example, you may want to trim the spaces around the <code>username</code> input. You may use validation rules to achieve this goal.</p> <p>The following examples shows how to trim the spaces in the inputs and turn empty inputs into nulls by using the <a href="guide-tutorial-core-validators.html#trim">trim</a> and <a href="tutorial-core-validators.md.html#default">default</a> core validators:</p> <pre data-language="php">return [
    [['username', 'email'], 'trim'],
    [['username', 'email'], 'default'],
];
</pre> <p>You may also use the more general <a href="guide-tutorial-core-validators.html#filter">filter</a> validator to perform more complex data filtering.</p> <p>As you can see, these validation rules do not really validate the inputs. Instead, they will process the values and save them back to the attributes being validated.</p> <p>A complete processing of user input is shown in the following example code, which will ensure only integer values are stored in an attribute:</p> <pre data-language="php">['age', 'trim'],
['age', 'default', 'value' =&gt; null],
['age', 'integer', 'integerOnly' =&gt; true, 'min' =&gt; 0],
['age', 'filter', 'filter' =&gt; 'intval', 'skipOnEmpty' =&gt; true],
</pre> <p>The above code will perform the following operations on the input:</p> <ol> <li>Trim whitespace from the input value.</li> <li>Make sure empty input is stored as <code>null</code> in the database; we differentiate between a value being "not set" and the actual value <code>0</code>. If <code>null</code> is not allowed you can set another default value here.</li> <li>Validate that the value is an integer greater than 0 if it is not empty. Normal validators have <a href="yii-validators-validator.html#%24skipOnEmpty-detail">$skipOnEmpty</a> set to <code>true</code>.</li> <li>Make sure the value is of type integer, e.g. casting a string <code>'42'</code> to integer <code>42</code>. Here we set <a href="yii-validators-filtervalidator.html#%24skipOnEmpty-detail">$skipOnEmpty</a> to <code>true</code>, which is <code>false</code> by default on the <a href="yii-validators-filtervalidator.html">filter</a> validator.</li> </ol> <h3>Handling Empty Inputs 
</h3>
<p>When input data are submitted from HTML forms, you often need to assign some default values to the inputs if they are empty. You can do so by using the <a href="guide-tutorial-core-validators.html#default">default</a> validator. For example,</p> <pre data-language="php">return [
    // set "username" and "email" as null if they are empty
    [['username', 'email'], 'default'],

    // set "level" to be 1 if it is empty
    ['level', 'default', 'value' =&gt; 1],
];
</pre> <p>By default, an input is considered empty if its value is an empty string, an empty array or a <code>null</code>. You may customize the default empty detection logic by configuring the <a href="yii-validators-validator.html#isEmpty()-detail">yii\validators\Validator::isEmpty()</a> property with a PHP callable. For example,</p> <pre data-language="php">    ['agree', 'required', 'isEmpty' =&gt; function ($value) {
        return empty($value);
    }]
</pre> <blockquote class="note">
<p><strong>Note: </strong>Most validators do not handle empty inputs if their <a href="yii-validators-validator.html#%24skipOnEmpty-detail">yii\validators\Validator::$skipOnEmpty</a> property takes the default value <code>true</code>. They will simply be skipped during validation if their associated attributes receive empty inputs. Among the <a href="guide-tutorial-core-validators.html">core validators</a>, only the <code>captcha</code>, <code>default</code>, <code>filter</code>, <code>required</code>, and <code>trim</code> validators will handle empty inputs.</p> </blockquote> <h2>Ad Hoc Validation 
</h2>
<p>Sometimes you need to do <em>ad hoc validation</em> for values that are not bound to any model.</p> <p>If you only need to perform one type of validation (e.g. validating email addresses), you may call the <a href="yii-validators-validator.html#validate()-detail">validate()</a> method of the desired validator, like the following:</p> <pre data-language="php">$email = 'test@example.com';
$validator = new yii\validators\EmailValidator();

if ($validator-&gt;validate($email, $error)) {
    echo 'Email is valid.';
} else {
    echo $error;
}
</pre> <blockquote class="note">
<p><strong>Note: </strong>Not all validators support this type of validation. An example is the <a href="guide-tutorial-core-validators.html#unique">unique</a> core validator which is designed to work with a model only.</p> </blockquote> <p>If you need to perform multiple validations against several values, you can use <a href="yii-base-dynamicmodel.html">yii\base\DynamicModel</a> which supports declaring both attributes and rules on the fly. Its usage is like the following:</p> <pre data-language="php">public function actionSearch($name, $email)
{
    $model = DynamicModel::validateData(compact('name', 'email'), [
        [['name', 'email'], 'string', 'max' =&gt; 128],
        ['email', 'email'],
    ]);

    if ($model-&gt;hasErrors()) {
        // validation fails
    } else {
        // validation succeeds
    }
}
</pre> <p>The <a href="yii-base-dynamicmodel.html#validateData()-detail">yii\base\DynamicModel::validateData()</a> method creates an instance of <code>DynamicModel</code>, defines the attributes using the given data (<code>name</code> and <code>email</code> in this example), and then calls <a href="yii-base-model.html#validate()-detail">yii\base\Model::validate()</a> with the given rules.</p> <p>Alternatively, you may use the following more "classic" syntax to perform ad hoc data validation:</p> <pre data-language="php">public function actionSearch($name, $email)
{
    $model = new DynamicModel(compact('name', 'email'));
    $model-&gt;addRule(['name', 'email'], 'string', ['max' =&gt; 128])
        -&gt;addRule('email', 'email')
        -&gt;validate();

    if ($model-&gt;hasErrors()) {
        // validation fails
    } else {
        // validation succeeds
    }
}
</pre> <p>After validation, you can check if the validation succeeded or not by calling the <a href="yii-base-model.html#hasErrors()-detail">hasErrors()</a> method, and then get the validation errors from the <a href="yii-base-model.html#%24errors-detail">errors</a> property, like you do with a normal model. You may also access the dynamic attributes defined through the model instance, e.g., <code>$model-&gt;name</code> and <code>$model-&gt;email</code>.</p> <h2>Creating Validators 
</h2>
<p>Besides using the <a href="guide-tutorial-core-validators.html">core validators</a> included in the Yii releases, you may also create your own validators. You may create inline validators or standalone validators.</p> <h3>Inline Validators 
</h3>
<p>An inline validator is one defined in terms of a model method or an anonymous function. The signature of the method/function is:</p> <pre data-language="php">/**
 * @param string $attribute the attribute currently being validated
 * @param mixed $params the value of the "params" given in the rule
 * @param \yii\validators\InlineValidator related InlineValidator instance.
 * This parameter is available since version 2.0.11.
 */
function ($attribute, $params, $validator)
</pre> <p>If an attribute fails the validation, the method/function should call <a href="yii-base-model.html#addError()-detail">yii\base\Model::addError()</a> to save the error message in the model so that it can be retrieved back later to present to end users.</p> <p>Below are some examples:</p> <pre data-language="php">use yii\base\Model;

class MyForm extends Model
{
    public $country;
    public $token;

    public function rules()
    {
        return [
            // an inline validator defined as the model method validateCountry()
            ['country', 'validateCountry'],

            // an inline validator defined as an anonymous function
            ['token', function ($attribute, $params, $validator) {
                if (!ctype_alnum($this-&gt;$attribute)) {
                    $this-&gt;addError($attribute, 'The token must contain letters or digits.');
                }
            }],
        ];
    }

    public function validateCountry($attribute, $params, $validator)
    {
        if (!in_array($this-&gt;$attribute, ['USA', 'Web'])) {
            $this-&gt;addError($attribute, 'The country must be either "USA" or "Web".');
        }
    }
}
</pre> <blockquote class="note">
<p><strong>Note: </strong>Since version 2.0.11 you can use <a href="yii-validators-validator.html#addError()-detail">yii\validators\InlineValidator::addError()</a> for adding errors instead. That way the error message can be formatted using <a href="yii-i18n-i18n.html#format()-detail">yii\i18n\I18N::format()</a> right away. Use <code>{attribute}</code> and <code>{value}</code> in the error message to refer to an attribute label (no need to get it manually) and attribute value accordingly:</p> <pre data-language="php">$validator-&gt;addError($this, $attribute, 'The value "{value}" is not acceptable for {attribute}.');
</pre> </blockquote> <blockquote class="note">
<p><strong>Note: </strong>By default, inline validators will not be applied if their associated attributes receive empty inputs or if they have already failed some validation rules. If you want to make sure a rule is always applied, you may configure the <a href="yii-validators-validator.html#%24skipOnEmpty-detail">skipOnEmpty</a> and/or <a href="yii-validators-validator.html#%24skipOnError-detail">skipOnError</a> properties to be <code>false</code> in the rule declarations. For example:</p> <pre data-language="php">[
    ['country', 'validateCountry', 'skipOnEmpty' =&gt; false, 'skipOnError' =&gt; false],
]
</pre> </blockquote> <h3>Standalone Validators 
</h3>
<p>A standalone validator is a class extending <a href="yii-validators-validator.html">yii\validators\Validator</a> or its child class. You may implement its validation logic by overriding the <a href="yii-validators-validator.html#validateAttribute()-detail">yii\validators\Validator::validateAttribute()</a> method. If an attribute fails the validation, call <a href="yii-base-model.html#addError()-detail">yii\base\Model::addError()</a> to save the error message in the model, like you do with <a href="#inline-validators">inline validators</a>.</p> <p>For example the inline validator above could be moved into new [[components/validators/CountryValidator]] class.</p> <pre data-language="php">namespace app\components;

use yii\validators\Validator;

class CountryValidator extends Validator
{
    public function validateAttribute($model, $attribute)
    {
        if (!in_array($model-&gt;$attribute, ['USA', 'Web'])) {
            $this-&gt;addError($model, $attribute, 'The country must be either "USA" or "Web".');
        }
    }
}
</pre> <p>If you want your validator to support validating a value without a model, you should also override <a href="yii-validators-validator.html#validate()-detail">yii\validators\Validator::validate()</a>. You may also override <a href="yii-validators-validator.html#validateValue()-detail">yii\validators\Validator::validateValue()</a> instead of <code>validateAttribute()</code> and <code>validate()</code> because by default the latter two methods are implemented by calling <code>validateValue()</code>.</p> <p>Below is an example of how you could use the above validator class within your model.</p> <pre data-language="php">namespace app\models;

use Yii;
use yii\base\Model;
use app\components\validators\CountryValidator;

class EntryForm extends Model
{
    public $name;
    public $email;
    public $country;

    public function rules()
    {
        return [
            [['name', 'email'], 'required'],
            ['country', CountryValidator::className()],
            ['email', 'email'],
        ];
    }
}
</pre> <h2>Multiple Attributes Validation 
</h2>
<p>Sometimes validators involve multiple attributes. Consider the following form:</p> <pre data-language="php">class MigrationForm extends \yii\base\Model
{
    /**
     * Minimal funds amount for one adult person
     */
    const MIN_ADULT_FUNDS = 3000;
    /**
     * Minimal funds amount for one child
     */
    const MIN_CHILD_FUNDS = 1500;

    public $personalSalary;
    public $spouseSalary;
    public $childrenCount;
    public $description;

    public function rules()
    {
        return [
            [['personalSalary', 'description'], 'required'],
            [['personalSalary', 'spouseSalary'], 'integer', 'min' =&gt; self::MIN_ADULT_FUNDS],
            ['childrenCount', 'integer', 'min' =&gt; 0, 'max' =&gt; 5],
            [['spouseSalary', 'childrenCount'], 'default', 'value' =&gt; 0],
            ['description', 'string'],
        ];
    }
}
</pre> <h3>Creating validator 
</h3>
<p>Let's say we need to check if the family income is enough for children. We can create inline validator <code>validateChildrenFunds</code> for that which will run only when <code>childrenCount</code> is more than 0.</p> <p>Note that we can't use all validated attributes (<code>['personalSalary', 'spouseSalary', 'childrenCount']</code>) when attaching validator. This is because the same validator will run for each attribute (3 times in total) and we only need to run it once for the whole attribute set.</p> <p>You can use any of these attributes instead (or use what you think is the most relevant):</p> <pre data-language="php">['childrenCount', 'validateChildrenFunds', 'when' =&gt; function ($model) {
    return $model-&gt;childrenCount &gt; 0;
}],
</pre> <p>Implementation of <code>validateChildrenFunds</code> can be like this:</p> <pre data-language="php">public function validateChildrenFunds($attribute, $params)
{
    $totalSalary = $this-&gt;personalSalary + $this-&gt;spouseSalary;
    // Double the minimal adult funds if spouse salary is specified
    $minAdultFunds = $this-&gt;spouseSalary ? self::MIN_ADULT_FUNDS * 2 : self::MIN_ADULT_FUNDS;
    $childFunds = $totalSalary - $minAdultFunds;
    if ($childFunds / $this-&gt;childrenCount &lt; self::MIN_CHILD_FUNDS) {
        $this-&gt;addError('childrenCount', 'Your salary is not enough for children.');
    }
}
</pre> <p>You can ignore <code>$attribute</code> parameter because validation is not related to just one attribute.</p> <h3>Adding errors 
</h3>
<p>Adding error in case of multiple attributes can vary depending on desired form design:</p> <ul> <li>Select the most relevant field in your opinion and add error to it's attribute:</li> </ul> <pre data-language="php">$this-&gt;addError('childrenCount', 'Your salary is not enough for children.');
</pre> <ul> <li>Select multiple important relevant attributes or all attributes and add the same error message to them. We can store message in separate variable before passing it to <code>addError</code> to keep code DRY.</li> </ul> <pre data-language="php">$message = 'Your salary is not enough for children.';
$this-&gt;addError('personalSalary', $message);
$this-&gt;addError('wifeSalary', $message);
$this-&gt;addError('childrenCount', $message);
</pre> <p>Or use a loop:</p> <pre data-language="php">$attributes = ['personalSalary, 'wifeSalary', 'childrenCount'];
foreach ($attributes as $attribute) {
    $this-&gt;addError($attribute, 'Your salary is not enough for children.');
}
</pre> <ul> <li>Add a common error (not related to particular attribute). We can use the not existing attribute name for adding error, for example <code>*</code>, because attribute existence is not checked at that point.</li> </ul> <pre data-language="php">$this-&gt;addError('*', 'Your salary is not enough for children.');
</pre> <p>As a result, we will not see error message near form fields. To display it, we can include the error summary in view:</p> <pre data-language="php">&lt;?= $form-&gt;errorSummary($model) ?&gt;
</pre> <blockquote class="note">
<p><strong>Note: </strong>Creating validator which validates multiple attributes at once is well described in the <a href="https://github.com/samdark/yii2-cookbook/blob/master/book/forms-validator-multiple-attributes.md">community cookbook</a>.</p> </blockquote> <h2>Client-Side Validation 
</h2>
<p>Client-side validation based on JavaScript is desirable when end users provide inputs via HTML forms, because it allows users to find out input errors faster and thus provides a better user experience. You may use or implement a validator that supports client-side validation <em>in addition to</em> server-side validation.</p> <blockquote class="info">
<p><strong>Info: </strong>While client-side validation is desirable, it is not a must. Its main purpose is to provide users with a better experience. Similar to input data coming from end users, you should never trust client-side validation. For this reason, you should always perform server-side validation by calling <a href="yii-base-model.html#validate()-detail">yii\base\Model::validate()</a>, as described in the previous subsections.</p> </blockquote> <h3>Using Client-Side Validation 
</h3>
<p>Many <a href="guide-tutorial-core-validators.html">core validators</a> support client-side validation out-of-the-box. All you need to do is just use <a href="yii-widgets-activeform.html">yii\widgets\ActiveForm</a> to build your HTML forms. For example, <code>LoginForm</code> below declares two rules: one uses the <a href="guide-tutorial-core-validators.html#required">required</a> core validator which is supported on both client and server-sides; the other uses the <code>validatePassword</code> inline validator which is only supported on the server side.</p> <pre data-language="php">namespace app\models;

use yii\base\Model;
use app\models\User;

class LoginForm extends Model
{
    public $username;
    public $password;

    public function rules()
    {
        return [
            // username and password are both required
            [['username', 'password'], 'required'],

            // password is validated by validatePassword()
            ['password', 'validatePassword'],
        ];
    }

    public function validatePassword()
    {
        $user = User::findByUsername($this-&gt;username);

        if (!$user || !$user-&gt;validatePassword($this-&gt;password)) {
            $this-&gt;addError('password', 'Incorrect username or password.');
        }
    }
}
</pre> <p>The HTML form built by the following code contains two input fields <code>username</code> and <code>password</code>. If you submit the form without entering anything, you will find the error messages requiring you to enter something appear right away without any communication with the server.</p> <pre data-language="php">&lt;?php $form = yii\widgets\ActiveForm::begin(); ?&gt;
    &lt;?= $form-&gt;field($model, 'username') ?&gt;
    &lt;?= $form-&gt;field($model, 'password')-&gt;passwordInput() ?&gt;
    &lt;?= Html::submitButton('Login') ?&gt;
&lt;?php yii\widgets\ActiveForm::end(); ?&gt;
</pre> <p>Behind the scene, <a href="yii-widgets-activeform.html">yii\widgets\ActiveForm</a> will read the validation rules declared in the model and generate appropriate JavaScript code for validators that support client-side validation. When a user changes the value of an input field or submit the form, the client-side validation JavaScript will be triggered.</p> <p>If you want to turn off client-side validation completely, you may configure the <a href="yii-widgets-activeform.html#%24enableClientValidation-detail">yii\widgets\ActiveForm::$enableClientValidation</a> property to be <code>false</code>. You may also turn off client-side validation of individual input fields by configuring their <a href="yii-widgets-activefield.html#%24enableClientValidation-detail">yii\widgets\ActiveField::$enableClientValidation</a> property to be false. When <code>enableClientValidation</code> is configured at both the input field level and the form level, the former will take precedence.</p> <blockquote class="info">
<p><strong>Info: </strong>Since version 2.0.11 all validators extending from <a href="yii-validators-validator.html">yii\validators\Validator</a> receive client-side options from separate method - <a href="yii-validators-validator.html#getClientOptions()-detail">yii\validators\Validator::getClientOptions()</a>. You can use it:</p> <ul> <li>if you want to implement your own custom client-side validation but leave the synchronization with server-side validator options;</li> <li>to extend or customize to fit your specific needs:</li> </ul> <pre data-language="php">public function getClientOptions($model, $attribute)
{
    $options = parent::getClientOptions($model, $attribute);
    // Modify $options here

    return $options;
}
</pre> </blockquote> <h3>Implementing Client-Side Validation 
</h3>
<p>To create a validator that supports client-side validation, you should implement the <a href="yii-validators-validator.html#clientValidateAttribute()-detail">yii\validators\Validator::clientValidateAttribute()</a> method which returns a piece of JavaScript code that performs the validation on the client-side. Within the JavaScript code, you may use the following predefined variables:</p> <ul> <li>
<code>attribute</code>: the name of the attribute being validated.</li> <li>
<code>value</code>: the value being validated.</li> <li>
<code>messages</code>: an array used to hold the validation error messages for the attribute.</li> <li>
<code>deferred</code>: an array which deferred objects can be pushed into (explained in the next subsection).</li> </ul> <p>In the following example, we create a <code>StatusValidator</code> which validates if an input is a valid status input against the existing status data. The validator supports both server-side and client-side validation.</p> <pre data-language="php">namespace app\components;

use yii\validators\Validator;
use app\models\Status;

class StatusValidator extends Validator
{
    public function init()
    {
        parent::init();
        $this-&gt;message = 'Invalid status input.';
    }

    public function validateAttribute($model, $attribute)
    {
        $value = $model-&gt;$attribute;
        if (!Status::find()-&gt;where(['id' =&gt; $value])-&gt;exists()) {
            $model-&gt;addError($attribute, $this-&gt;message);
        }
    }

    public function clientValidateAttribute($model, $attribute, $view)
    {
        $statuses = json_encode(Status::find()-&gt;select('id')-&gt;asArray()-&gt;column());
        $message = json_encode($this-&gt;message, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
        return &lt;&lt;&lt;JS
if ($.inArray(value, $statuses) === -1) {
    messages.push($message);
}
JS;
    }
}
</pre> <blockquote class="tip">
<p><strong>Tip: </strong>The above code is given mainly to demonstrate how to support client-side validation. In practice, you may use the <a href="guide-tutorial-core-validators.html#in">in</a> core validator to achieve the same goal. You may write the validation rule like the following:</p> <pre data-language="php">[
    ['status', 'in', 'range' =&gt; Status::find()-&gt;select('id')-&gt;asArray()-&gt;column()],
]
</pre> </blockquote> <blockquote class="tip">
<p><strong>Tip: </strong>If you need to work with client validation manually i.e. dynamically add fields or do some custom UI logic, refer to <a href="https://github.com/samdark/yii2-cookbook/blob/master/book/forms-activeform-js.md">Working with ActiveForm via JavaScript</a> in Yii 2.0 Cookbook.</p> </blockquote> <h3>Deferred Validation 
</h3>
<p>If you need to perform asynchronous client-side validation, you can create <a href="http://api.jquery.com/category/deferred-object/">Deferred objects</a>. For example, to perform a custom AJAX validation, you can use the following code:</p> <pre data-language="php">public function clientValidateAttribute($model, $attribute, $view)
{
    return &lt;&lt;&lt;JS
        deferred.push($.get("/check", {value: value}).done(function(data) {
            if ('' !== data) {
                messages.push(data);
            }
        }));
JS;
}
</pre> <p>In the above, the <code>deferred</code> variable is provided by Yii, which is an array of Deferred objects. The <code>$.get()</code> jQuery method creates a Deferred object which is pushed to the <code>deferred</code> array.</p> <p>You can also explicitly create a Deferred object and call its <code>resolve()</code> method when the asynchronous callback is hit. The following example shows how to validate the dimensions of an uploaded image file on the client-side.</p> <pre data-language="php">public function clientValidateAttribute($model, $attribute, $view)
{
    return &lt;&lt;&lt;JS
        var def = $.Deferred();
        var img = new Image();
        img.onload = function() {
            if (this.width &gt; 150) {
                messages.push('Image too wide!!');
            }
            def.resolve();
        }
        var reader = new FileReader();
        reader.onloadend = function() {
            img.src = reader.result;
        }
        reader.readAsDataURL(file);

        deferred.push(def);
JS;
}
</pre> <blockquote class="note">
<p><strong>Note: </strong>The <code>resolve()</code> method must be called after the attribute has been validated. Otherwise the main form validation will not complete.</p> </blockquote> <p>For simplicity, the <code>deferred</code> array is equipped with a shortcut method <code>add()</code> which automatically creates a Deferred object and adds it to the <code>deferred</code> array. Using this method, you can simplify the above example as follows,</p> <pre data-language="php">public function clientValidateAttribute($model, $attribute, $view)
{
    return &lt;&lt;&lt;JS
        deferred.add(function(def) {
            var img = new Image();
            img.onload = function() {
                if (this.width &gt; 150) {
                    messages.push('Image too wide!!');
                }
                def.resolve();
            }
            var reader = new FileReader();
            reader.onloadend = function() {
                img.src = reader.result;
            }
            reader.readAsDataURL(file);
        });
JS;
}
</pre> <h3>AJAX Validation 
</h3>
<p>Some validations can only be done on the server-side, because only the server has the necessary information. For example, to validate if a username is unique or not, it is necessary to check the user table on the server-side. You can use AJAX-based validation in this case. It will trigger an AJAX request in the background to validate the input while keeping the same user experience as the regular client-side validation.</p> <p>To enable AJAX validation for a single input field, configure the <a href="yii-widgets-activefield.html#%24enableAjaxValidation-detail">enableAjaxValidation</a> property of that field to be <code>true</code> and specify a unique form <code>id</code>:</p> <pre data-language="php">use yii\widgets\ActiveForm;

$form = ActiveForm::begin([
    'id' =&gt; 'registration-form',
]);

echo $form-&gt;field($model, 'username', ['enableAjaxValidation' =&gt; true]);

// ...

ActiveForm::end();
</pre> <p>To enable AJAX validation for the whole form, configure <a href="yii-widgets-activeform.html#%24enableAjaxValidation-detail">enableAjaxValidation</a> to be <code>true</code> at the form level:</p> <pre data-language="php">$form = ActiveForm::begin([
    'id' =&gt; 'contact-form',
    'enableAjaxValidation' =&gt; true,
]);
</pre> <blockquote class="note">
<p><strong>Note: </strong>When the <code>enableAjaxValidation</code> property is configured at both the input field level and the form level, the former will take precedence.</p> </blockquote> <p>You also need to prepare the server so that it can handle the AJAX validation requests. This can be achieved by a code snippet like the following in the controller actions:</p> <pre data-language="php">if (Yii::$app-&gt;request-&gt;isAjax &amp;&amp; $model-&gt;load(Yii::$app-&gt;request-&gt;post())) {
    Yii::$app-&gt;response-&gt;format = Response::FORMAT_JSON;
    return ActiveForm::validate($model);
}
</pre> <p>The above code will check whether the current request is an AJAX. If yes, it will respond to this request by running the validation and returning the errors in JSON format.</p> <blockquote class="info">
<p><strong>Info: </strong>You can also use <a href="#deferred-validation">Deferred Validation</a> to perform AJAX validation. However, the AJAX validation feature described here is more systematic and requires less coding effort.</p> </blockquote> <p>When both <code>enableClientValidation</code> and <code>enableAjaxValidation</code> are set to <code>true</code>, AJAX validation request will be triggered only after the successful client validation.</p> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2017 by Yii Software LLC<br>Licensed under the three clause BSD license.<br>
    <a href="http://www.yiiframework.com/doc-2.0/guide-input-validation.html" class="_attribution-link">http://www.yiiframework.com/doc-2.0/guide-input-validation.html</a>
  </p>
</div>
