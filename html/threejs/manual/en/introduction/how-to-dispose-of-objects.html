<h1 id="how-to-dispose-of-objects" class=" section-header"><span class="descname">How-to-dispose-of-objects</span></h1> <p> One important aspect in order to improve performance and avoid memory leaks in your application is the disposal of unused library entities. Whenever you create an instance of a *three.js* type, you allocate a certain amount of memory. However, *three.js* creates for specific objects like geometries or materials WebGL related entities like buffers or shader programs which are necessary for rendering. It's important to highlight that these objects are not released automatically. Instead, the application has to use a special API in order to free such resources. This guide provides a brief overview about how this API is used and what objects are relevant in this context. </p> <div class="section">
<h2 class="section-title section-header" id="geometries">Geometries</h2>
<p> A geometry usually represents vertex information defined as a collection of attributes. *three.js* internally creates an object of type <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer">WebGLBuffer</a> for each attribute. These entities are only deleted if you call <a class="reference internal" href="buffergeometry.dispose.html"><code class="xref js js-buffergeometry.dispose">BufferGeometry.dispose</code></a>(). If a geometry becomes obsolete in your application, execute the method to free all related resources. </p> </div> <div class="section">
<h2 class="section-title section-header" id="materials">Materials</h2>
<p> A material defines how objects are rendered. *three.js* uses the information of a material definition in order to construct a shader program for rendering. Shader programs can only be deleted if the respective material is disposed. For performance reasons, *three.js* tries to reuse existing shader programs if possible. So a shader program is only deleted if all related materials are disposed. You can indicate the disposal of a material by executing <a class="reference internal" href="material.dispose.html"><code class="xref js js-material.dispose">Material.dispose</code></a>(). </p> </div> <div class="section">
<h2 class="section-title section-header" id="textures">Textures</h2>
<p> The disposal of a material has no effect on textures. They are handled separately since a single texture can be used by multiple materials at the same time. Whenever you create an instance of <a class="reference internal" href="texture.html"><code class="xref js js-texture">Texture</code></a>, three.js internally creates an instance of <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture">WebGLTexture</a>. Similar to buffers, this object can only be deleted by calling <a class="reference internal" href="texture.dispose.html"><code class="xref js js-texture.dispose">Texture.dispose</code></a>(). </p> <p> If you use an <code class="docutils literal notranslate"><span class="pre">ImageBitmap</span></code> as the texture's data source, you have to call <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap/close">ImageBitmap.close</a>() at the application level to dispose of all CPU-side resources. An automated call of <code class="docutils literal notranslate"><span class="pre">ImageBitmap.close()</span></code> in <a class="reference internal" href="texture.dispose.html"><code class="xref js js-texture.dispose">Texture.dispose</code></a>() is not possible, since the image bitmap becomes unusable, and the engine has no way of knowing if the image bitmap is used elsewhere. </p> </div> <div class="section">
<h2 class="section-title section-header" id="render-targets">Render Targets</h2>
<p> Objects of type <a class="reference internal" href="webglrendertarget.html"><code class="xref js js-webglrendertarget">WebGLRenderTarget</code></a> not only allocate an instance of <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture">WebGLTexture</a> but also <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLFramebuffer">WebGLFramebuffer</a>s and <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderbuffer">WebGLRenderbuffer</a>s for realizing custom rendering destinations. These objects are only deallocated by executing <a class="reference internal" href="webglrendertarget.dispose.html"><code class="xref js js-webglrendertarget.dispose">WebGLRenderTarget.dispose</code></a>(). </p> </div> <div class="section">
<h2 class="section-title section-header" id="miscellaneous">Miscellaneous</h2>
<p> There are other classes from the examples directory like controls or post processing passes which provide <code class="docutils literal notranslate"><span class="pre">dispose()</span></code> methods in order to remove internal event listeners or render targets. In general, it's recommended to check the API or documentation of a class and watch for <code class="docutils literal notranslate"><span class="pre">dispose()</span></code>. If present, you should use it when cleaning things up. </p> </div> <div class="section">
<h2 class="section-title section-header" id="faq">FAQ</h2>
<h3 id="why-can-t-three-js-dispose-objects-automatically-" class=" section-header">Why can't *three.js* dispose objects automatically?</h3> <p> This question was asked many times by the community so it's important to clarify this matter. Fact is that *three.js* does not know the lifetime or scope of user-created entities like geometries or materials. This is the responsibility of the application. For example even if a material is currently not used for rendering, it might be necessary for the next frame. So if the application decides that a certain object can be deleted, it has to notify the engine via calling the respective <code class="docutils literal notranslate"><span class="pre">dispose()</span></code> method. </p> <h3 id="does-removing-a-mesh-from-the-scene-also-dispose-its-geometry-and-material-" class=" section-header">Does removing a mesh from the scene also dispose its geometry and material?</h3> <p> No, you have to explicitly dispose the geometry and material via *dispose()*. Keep in mind that geometries and materials can be shared among 3D objects like meshes. </p> <h3 id="does-three-js-provide-information-about-the-amount-of-cached-objects-" class=" section-header">Does *three.js* provide information about the amount of cached objects?</h3> <p> Yes. It's possible to evaluate <a class="reference internal" href="webglrenderer.info.html"><code class="xref js js-webglrenderer.info">WebGLRenderer.info</code></a>, a special property of the renderer with a series of statistical information about the graphics board memory and the rendering process. Among other things, it tells you how many textures, geometries and shader programs are internally stored. If you notice performance problems in your application, it's a good idea to debug this property in order to easily identify a memory leak. </p> <h3 id="what-happens-when-you-call-dispose-on-a-texture-but-the-image-is-not-loaded-yet-" class=" section-header">What happens when you call `dispose()` on a texture but the image is not loaded yet?</h3> <p> Internal resources for a texture are only allocated if the image has fully loaded. If you dispose a texture before the image was loaded, nothing happens. No resources were allocated so there is also no need for clean up. </p> <h3 id="what-happens-when-i-call-dispose-and-then-use-the-respective-object-at-a-later-point-" class=" section-header">What happens when I call `dispose()` and then use the respective object at a later point?</h3> <p> That depends. For geometries, materials, textures, render targets and post processing passes the deleted internal resources can be created again by the engine. So no runtime error will occur but you might notice a negative performance impact for the current frame, especially when shader programs have to be compiled. Controls and renderers are an exception. Instances of these classes can not be used after <code class="docutils literal notranslate"><span class="pre">dispose()</span></code> has been called. You have to create new instances in this case. </p> <h3 id="how-should-i-manage-three-js-objects-in-my-app-when-do-i-know-how-to-dispose-things-" class=" section-header">How should I manage *three.js* objects in my app? When do I know how to dispose things?</h3> <p> In general, there is no definite recommendation for this. It highly depends on the specific use case when calling <code class="docutils literal notranslate"><span class="pre">dispose()</span></code> is appropriate. It's important to highlight that it's not always necessary to dispose objects all the time. A good example for this is a game which consists of multiple levels. A good place for object disposal is when switching the level. The app could traverse through the old scene and dispose all obsolete materials, geometries and textures. As mentioned in the previous section, it does not produce a runtime error if you dispose an object that is actually still in use. The worst thing that can happen is performance drop for a single frame. </p> </div> <div class="section">
<h2 class="section-title section-header" id="examples-that-demonstrate-the-usage-of-dispose-">Examples that demonstrate the usage of dispose()</h2>
<p> <a class="reference external" href="https://threejs.org/examples/#webgl_test_memory">WebGL / test / memory</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_test_memory2">WebGL / test / memory2</a><br> </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2025 Three.js Authors<br>Licensed under the MIT License.<br>
    <a href="https://threejs.org/docs/manual/en/introduction/How-to-dispose-of-objects.html" class="_attribution-link">https://threejs.org/docs/manual/en/introduction/How-to-dispose-of-objects.html</a>
  </p>
</div>
