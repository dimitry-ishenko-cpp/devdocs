[page:Texture] â†’ <h1 id="datatexture" class=" section-header"><span class="descname">DataTexture</span></h1> <p class="section-desc"> Creates a texture directly from raw data, width and height. </p> <div class="section">
<h2 class="section-title section-header" id="constructor">Constructor</h2>
<h3 id="datatexture-data-width-height-format-type-mapping-wraps-wrapt-magfilter-minfilter-anisotropy-colorspace-" class=" section-header"> <span class="descname">DataTexture</span>( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) </h3> <p> The data argument must be an <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView">ArrayBufferView</a>. Further parameters correspond to the properties inherited from <a class="reference internal" href="texture.html"><code class="xref js js-texture">Texture</code></a>, where both magFilter and minFilter default to THREE.NearestFilter. </p> <p> The interpretation of the data depends on type and format: If the type is THREE.UnsignedByteType, a Uint8Array will be useful for addressing the texel data. If the format is THREE.RGBAFormat, data needs four values for one texel; Red, Green, Blue and Alpha (typically the opacity).<br> For the packed types, THREE.UnsignedShort4444Type and THREE.UnsignedShort5551Type all color components of one texel can be addressed as bitfields within an integer element of a Uint16Array.<br> In order to use the types THREE.FloatType and THREE.HalfFloatType, the WebGL implementation must support the respective extensions OES_texture_float and OES_texture_half_float. In order to use THREE.LinearFilter for component-wise, bilinear interpolation of the texels based on these types, the WebGL extensions OES_texture_float_linear or OES_texture_half_float_linear must also be present. </p> </div> <div class="section">
<h2 class="section-title section-header" id="code-example">Code Example</h2>
<pre data-language="javascript"><code>
		// create a buffer with color data

		const width = 512;
		const height = 512;

		const size = width * height;
		const data = new Uint8Array( 4 * size );
		const color = new THREE.Color( 0xffffff );

		const r = Math.floor( color.r * 255 );
		const g = Math.floor( color.g * 255 );
		const b = Math.floor( color.b * 255 );

		for ( let i = 0; i &lt; size; i ++ ) {
			const stride = i * 4;
			data[ stride ] = r;
			data[ stride + 1 ] = g;
			data[ stride + 2 ] = b;
			data[ stride + 3 ] = 255;
		}

		// used the buffer to create a [name]
		const texture = new THREE.DataTexture( data, width, height );
		texture.needsUpdate = true;
		</code></pre> </div> <div class="section">
<h2 class="section-title section-header" id="properties">Properties</h2>
<p>See the base <a class="reference internal" href="texture.html"><code class="xref js js-texture">Texture</code></a> class for common properties.</p> <h3 id="flipy-boolean" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">flipY</span><span class="sig-colon">:</span> <span class="sig-type">Boolean</span>
</dt></h3> <p> If set to <code class="docutils literal notranslate"><span class="pre">true</span></code>, the texture is flipped along the vertical axis when uploaded to the GPU. Default is <code class="docutils literal notranslate"><span class="pre">false</span></code>. </p> <h3 id="generatemipmaps-boolean" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">generateMipmaps</span><span class="sig-colon">:</span> <span class="sig-type">Boolean</span>
</dt></h3> <p> Whether to generate mipmaps (if possible) for a texture. False by default. </p> <h3 id="image-object" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">image</span><span class="sig-colon">:</span> <span class="sig-type">Object</span>
</dt></h3> <p>Overridden with a object holding data, width, and height.</p> <h3 id="isdatatexture-boolean" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">isDataTexture</span><span class="sig-colon">:</span> <span class="sig-type">Boolean</span>
</dt></h3> <p>Read-only flag to check if a given object is of type [name].</p> <h3 id="unpackalignment-number" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">unpackAlignment</span><span class="sig-colon">:</span> <span class="sig-type">number</span>
</dt></h3> <p> <code class="docutils literal notranslate"><span class="pre">1</span></code> by default. Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries). See <a class="reference external" href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml">glPixelStorei</a> for more information. </p> </div> <div class="section">
<h2 class="section-title section-header" id="methods">Methods</h2>
<p>See the base <a class="reference internal" href="texture.html"><code class="xref js js-texture">Texture</code></a> class for common methods.</p>   </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2025 Three.js Authors<br>Licensed under the MIT License.<br>
    <a href="https://threejs.org/docs/api/en/textures/DataTexture.html" class="_attribution-link">https://threejs.org/docs/api/en/textures/DataTexture.html</a>
  </p>
</div>
