[page:Material] â†’ <h1 id="shadermaterial" class=" section-header"><span class="descname">ShaderMaterial</span></h1> <p class="section-desc"> A material rendered with custom shaders. A shader is a small program written in <a class="reference external" href="https://www.khronos.org/files/opengles_shading_language.pdf">GLSL</a> that runs on the GPU. You may want to use a custom shader if you need to: </p> <ul> <li> implement an effect not included with any of the built-in <a class="reference internal" href="material.html"><code class="xref js js-material">materials</code></a> </li> <li> combine many objects into a single <a class="reference internal" href="buffergeometry.html"><code class="xref js js-buffergeometry">BufferGeometry</code></a> in order to improve performance </li> </ul> There are the following notes to bear in mind when using a `ShaderMaterial`: <ul> <li> A <code class="docutils literal notranslate"><span class="pre">ShaderMaterial</span></code> will only be rendered properly by <a class="reference internal" href="webglrenderer.html"><code class="xref js js-webglrenderer">WebGLRenderer</code></a>, since the GLSL code in the <a class="reference external" href="https://en.wikipedia.org/wiki/Shader#Vertex_shaders">vertexShader</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Shader#Pixel_shaders">fragmentShader</a> properties must be compiled and run on the GPU using WebGL. </li> <li> As of THREE r72, directly assigning attributes in a ShaderMaterial is no longer supported. A <a class="reference internal" href="buffergeometry.html"><code class="xref js js-buffergeometry">BufferGeometry</code></a> instance must be used instead, using <a class="reference internal" href="bufferattribute.html"><code class="xref js js-bufferattribute">BufferAttribute</code></a> instances to define custom attributes. </li> <li> As of THREE r77, <a class="reference internal" href="webglrendertarget.html"><code class="xref js js-webglrendertarget">WebGLRenderTarget</code></a> or <a class="reference internal" href="webglcuberendertarget.html"><code class="xref js js-webglcuberendertarget">WebGLCubeRenderTarget</code></a> instances are no longer supposed to be used as uniforms. Their <a class="reference internal" href="texture.html"><code class="xref js js-texture">texture</code></a> property must be used instead. </li> <li> Built in attributes and uniforms are passed to the shaders along with your code. If you don't want the <a class="reference internal" href="webglprogram.html"><code class="xref js js-webglprogram">WebGLProgram</code></a> to add anything to your shader code, you can use <a class="reference internal" href="rawshadermaterial.html"><code class="xref js js-rawshadermaterial">RawShaderMaterial</code></a> instead of this class. </li> <li> You can use the directive #pragma unroll_loop_start and #pragma unroll_loop_end in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has to be placed right above the loop. The loop formatting has to correspond to a defined standard. <ul> <li> The loop has to be <a class="reference external" href="https://en.wikipedia.org/wiki/Normalized_loop">normalized</a>. </li> <li>The loop variable has to be *i*.</li> <li> The value <code class="docutils literal notranslate"><span class="pre">UNROLLED_LOOP_INDEX</span></code> will be replaced with the explicitly value of *i* for the given iteration and can be used in preprocessor statements. </li> </ul> <pre data-language="javascript"><code>
					#pragma unroll_loop_start 
					for ( int i = 0; i &lt; 10; i ++ ) {
						 // ... 
					 }
					#pragma unroll_loop_end
				</code></pre> </li> </ul> <div class="section">
<h2 class="section-title section-header" id="code-example">Code Example</h2>
<pre data-language="javascript"><code>
		const material = new THREE.ShaderMaterial( {

			uniforms: {
				time: { value: 1.0 },
				resolution: { value: new THREE.Vector2() }
			},

			vertexShader: document.getElementById( 'vertexShader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentShader' ).textContent

		} );
		</code></pre> </div> <div class="section">
<h2 class="section-title section-header" id="examples">Examples</h2>
<p> <a class="reference external" href="https://threejs.org/examples/#webgl_buffergeometry_custom_attributes_particles">webgl / buffergeometry / custom / attributes / particles</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_buffergeometry_selective_draw">webgl / buffergeometry / selective / draw</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_custom_attributes">webgl / custom / attributes</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_custom_attributes_lines">webgl / custom / attributes / lines</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_custom_attributes_points">webgl / custom / attributes / points</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_custom_attributes_points2">webgl / custom / attributes / points2</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_custom_attributes_points3">webgl / custom / attributes / points3</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_depth_texture">webgl / depth / texture</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_gpgpu_birds">webgl / gpgpu / birds</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_gpgpu_protoplanet">webgl / gpgpu / protoplanet</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_gpgpu_water">webgl / gpgpu / water</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_interactive_points">webgl / interactive / points</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_video_kinect">webgl / video / kinect</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_lights_hemisphere">webgl / lights / hemisphere</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_marchingcubes">webgl / marchingcubes</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_materials_envmaps">webgl / materials / envmaps</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_materials_wireframe">webgl / materials / wireframe</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_modifier_tessellation">webgl / modifier / tessellation</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_postprocessing_dof2">webgl / postprocessing / dof2</a><br> <a class="reference external" href="https://threejs.org/examples/#webgl_postprocessing_godrays">webgl / postprocessing / godrays</a> </p> </div> <div class="section">
<h2 class="section-title section-header" id="vertex-shaders-and-fragment-shaders">Vertex shaders and fragment shaders</h2>
<div> <p>You can specify two different types of shaders for each material:</p> <ul> <li> The vertex shader runs first; it receives <code class="docutils literal notranslate"><span class="pre">attributes</span></code>, calculates / manipulates the position of each individual vertex, and passes additional data (<code class="docutils literal notranslate"><span class="pre">varying</span></code>s) to the fragment shader. </li> <li> The fragment ( or pixel ) shader runs second; it sets the color of each individual "fragment" (pixel) rendered to the screen. </li> </ul> <p> There are three types of variables in shaders: uniforms, attributes, and varyings: </p> <ul> <li> <code class="docutils literal notranslate"><span class="pre">Uniforms</span></code> are variables that have the same value for all vertices - lighting, fog, and shadow maps are examples of data that would be stored in uniforms. Uniforms can be accessed by both the vertex shader and the fragment shader. </li> <li> <code class="docutils literal notranslate"><span class="pre">Attributes</span></code> are variables associated with each vertex---for instance, the vertex position, face normal, and vertex color are all examples of data that would be stored in attributes. Attributes can <code class="docutils literal notranslate"><span class="pre">only</span></code> be accessed within the vertex shader. </li> <li> <code class="docutils literal notranslate"><span class="pre">Varyings</span></code> are variables that are passed from the vertex shader to the fragment shader. For each fragment, the value of each varying will be smoothly interpolated from the values of adjacent vertices. </li> </ul> <p> Note that <code class="docutils literal notranslate"><span class="pre">within</span></code> the shader itself, uniforms and attributes act like constants; you can only modify their values by passing different values to the buffers from your JavaScript code. </p> </div> </div> <div class="section">
<h2 class="section-title section-header" id="built-in-attributes-and-uniforms">Built-in attributes and uniforms</h2>
<div> <p> The <a class="reference internal" href="webglrenderer.html"><code class="xref js js-webglrenderer">WebGLRenderer</code></a> provides many attributes and uniforms to shaders by default; definitions of these variables are prepended to your <code class="docutils literal notranslate"><span class="pre">fragmentShader</span></code> and <code class="docutils literal notranslate"><span class="pre">vertexShader</span></code> code by the <a class="reference internal" href="webglprogram.html"><code class="xref js js-webglprogram">WebGLProgram</code></a> when the shader is compiled; you don't need to declare them yourself. See <a class="reference internal" href="webglprogram.html"><code class="xref js js-webglprogram">WebGLProgram</code></a> for details of these variables. </p> <p> Some of these uniforms or attributes (e.g. those pertaining lighting, fog, etc.) require properties to be set on the material in order for <a class="reference internal" href="webglrenderer.html"><code class="xref js js-webglrenderer">WebGLRenderer</code></a> to copy the appropriate values to the GPU - make sure to set these flags if you want to use these features in your own shader. </p> <p> If you don't want <a class="reference internal" href="webglprogram.html"><code class="xref js js-webglprogram">WebGLProgram</code></a> to add anything to your shader code, you can use <a class="reference internal" href="rawshadermaterial.html"><code class="xref js js-rawshadermaterial">RawShaderMaterial</code></a> instead of this class. </p> </div> </div> <div class="section">
<h2 class="section-title section-header" id="custom-attributes-and-uniforms">Custom attributes and uniforms</h2>
<div> <p> Both custom attributes and uniforms must be declared in your GLSL shader code (within <code class="docutils literal notranslate"><span class="pre">vertexShader</span></code> and/or <code class="docutils literal notranslate"><span class="pre">fragmentShader</span></code>). Custom uniforms must be defined in <code class="docutils literal notranslate"><span class="pre">both</span></code> the <code class="docutils literal notranslate"><span class="pre">uniforms</span></code> property of your <code class="docutils literal notranslate"><span class="pre">ShaderMaterial</span></code>, whereas any custom attributes must be defined via <a class="reference internal" href="bufferattribute.html"><code class="xref js js-bufferattribute">BufferAttribute</code></a> instances. Note that <code class="docutils literal notranslate"><span class="pre">varying</span></code>s only need to be declared within the shader code (not within the material). </p> <p> To declare a custom attribute, please reference the <a class="reference internal" href="buffergeometry.html"><code class="xref js js-buffergeometry">BufferGeometry</code></a> page for an overview, and the <a class="reference internal" href="bufferattribute.html"><code class="xref js js-bufferattribute">BufferAttribute</code></a> page for a detailed look at the <code class="docutils literal notranslate"><span class="pre">BufferAttribute</span></code> API. </p> <p> When creating your attributes, each typed array that you create to hold your attribute's data must be a multiple of your data type's size. For example, if your attribute is a <a class="reference internal" href="vector3.html"><code class="xref js js-vector3">THREE.Vector3</code></a> type, and you have 3000 vertices in your <a class="reference internal" href="buffergeometry.html"><code class="xref js js-buffergeometry">BufferGeometry</code></a>, your typed array value must be created with a length of 3000 * 3, or 9000 (one value per-component). A table of each data type's size is shown below for reference: </p> <table> <caption> <a id="attribute-sizes">Attribute sizes</a> </caption> <thead> <tr> <th>GLSL type</th> <th>JavaScript type</th> <th>Size</th> </tr> </thead> <tbody> <tr> <td>float</td> <td><a class="reference internal" href="number.html"><code class="xref js js-number">Number</code></a></td> <td>1</td> </tr> <tr> <td>vec2</td> <td><a class="reference internal" href="vector2.html"><code class="xref js js-vector2">THREE.Vector2</code></a></td> <td>2</td> </tr> <tr> <td>vec3</td> <td><a class="reference internal" href="vector3.html"><code class="xref js js-vector3">THREE.Vector3</code></a></td> <td>3</td> </tr> <tr> <td>vec3</td> <td><a class="reference internal" href="color.html"><code class="xref js js-color">THREE.Color</code></a></td> <td>3</td> </tr> <tr> <td>vec4</td> <td><a class="reference internal" href="vector4.html"><code class="xref js js-vector4">THREE.Vector4</code></a></td> <td>4</td> </tr> </tbody> </table> <p> Note that attribute buffers are <code class="docutils literal notranslate"><span class="pre">not</span></code> refreshed automatically when their values change. To update custom attributes, set the <code class="docutils literal notranslate"><span class="pre">needsUpdate</span></code> flag to true on the <a class="reference internal" href="bufferattribute.html"><code class="xref js js-bufferattribute">BufferAttribute</code></a> of the geometry (see <a class="reference internal" href="buffergeometry.html"><code class="xref js js-buffergeometry">BufferGeometry</code></a> for further details). </p> <p> To declare a custom <a class="reference internal" href="uniform.html"><code class="xref js js-uniform">Uniform</code></a>, use the <code class="docutils literal notranslate"><span class="pre">uniforms</span></code> property: </p>
<pre data-language="javascript"><code>
uniforms: { 
	time: { value: 1.0 },
	resolution: { value: new THREE.Vector2() } 
}
				</code></pre>  <p> You're recommended to update custom <a class="reference internal" href="uniform.html"><code class="xref js js-uniform">Uniform</code></a> values depending on <a class="reference internal" href="object3d.html"><code class="xref js js-object3d">object</code></a> and <a class="reference internal" href="camera.html"><code class="xref js js-camera">camera</code></a> in <a class="reference internal" href="object3d.onbeforerender.html"><code class="xref js js-object3d.onbeforerender">Object3D.onBeforeRender</code></a> because <a class="reference internal" href="material.html"><code class="xref js js-material">Material</code></a> can be shared among <a class="reference internal" href="mesh.html"><code class="xref js js-mesh">meshes</code></a>, <a class="reference internal" href="matrix4.html"><code class="xref js js-matrix4">matrixWorld</code></a> of <a class="reference internal" href="scene.html"><code class="xref js js-scene">Scene</code></a> and <a class="reference internal" href="camera.html"><code class="xref js js-camera">Camera</code></a> are updated in <a class="reference internal" href="webglrenderer.render.html"><code class="xref js js-webglrenderer.render">WebGLRenderer.render</code></a>, and some effects render a <a class="reference internal" href="scene.html"><code class="xref js js-scene">scene</code></a> with their own private <a class="reference internal" href="camera.html"><code class="xref js js-camera">cameras</code></a>. </p> </div> </div> <div class="section">
<h2 class="section-title section-header" id="constructor">Constructor</h2>
<h3 id="shadermaterial-object-parameters-" class=" section-header">
<span class="descname">ShaderMaterial</span>( <span class="sig-param"><span class="sig-type">Object</span> <code class="sig-name">parameters</code></span> )</h3> <p> <a class="reference internal" href="object.html"><code class="xref js js-object">parameters</code></a> - (optional) an object with one or more properties defining the material's appearance. Any property of the material (including any property inherited from <a class="reference internal" href="material.html"><code class="xref js js-material">Material</code></a>) can be passed in here. </p> </div> <div class="section">
<h2 class="section-title section-header" id="properties">Properties</h2>
<p>See the base <a class="reference internal" href="material.html"><code class="xref js js-material">Material</code></a> class for common properties.</p> <h3 id="clipping-boolean" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">clipping</span><span class="sig-colon">:</span> <span class="sig-type">Boolean</span>
</dt></h3> <p> Defines whether this material supports clipping; true to let the renderer pass the clippingPlanes uniform. Default is false. </p> <h3 id="defaultattributevalues-object" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">defaultAttributeValues</span><span class="sig-colon">:</span> <span class="sig-type">Object</span>
</dt></h3> <p> When the rendered geometry doesn't include these attributes but the material does, these default values will be passed to the shaders. This avoids errors when buffer data is missing. <pre data-language="javascript"><code>
this.defaultAttributeValues = { 
	'color': [ 1, 1, 1 ], 
	'uv': [ 0, 0 ],
	'uv1': [ 0, 0 ] 
};
			</code></pre> </p> <h3 id="defines-object" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">defines</span><span class="sig-colon">:</span> <span class="sig-type">Object</span>
</dt></h3> <p> Defines custom constants using `#define` directives within the GLSL code for both the vertex shader and the fragment shader; each key/value pair yields another directive: <pre data-language="javascript"><code> 
				defines: { 
					FOO: 15, 
					BAR: true 
				} 
			</code></pre> yields the lines <pre data-language="javascript"><code> 
				#define FOO 15 
				#define BAR true 
			</code></pre> in the GLSL code. </p> <h3 id="extensions-object" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">extensions</span><span class="sig-colon">:</span> <span class="sig-type">Object</span>
</dt></h3> <p> An object with the following properties: <pre data-language="javascript"><code>
this.extensions = { 
	clipCullDistance: false, // set to use vertex shader clipping
	multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
};
			</code></pre> </p> <h3 id="fog-boolean" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">fog</span><span class="sig-colon">:</span> <span class="sig-type">Boolean</span>
</dt></h3> <p> Define whether the material color is affected by global fog settings; true to pass fog uniforms to the shader. Default is false. </p> <h3 id="fragmentshader-string" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">fragmentShader</span><span class="sig-colon">:</span> <span class="sig-type">String</span>
</dt></h3> <p> Fragment shader GLSL code. This is the actual code for the shader. In the example above, the <code class="docutils literal notranslate"><span class="pre">vertexShader</span></code> and <code class="docutils literal notranslate"><span class="pre">fragmentShader</span></code> code is extracted from the DOM; it could be passed as a string directly or loaded via AJAX instead. </p> <h3 id="glslversion-string" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">glslVersion</span><span class="sig-colon">:</span> <span class="sig-type">String</span>
</dt></h3> <p> Defines the GLSL version of custom shader code. Valid values are <code class="docutils literal notranslate"><span class="pre">THREE.GLSL1</span></code> or <code class="docutils literal notranslate"><span class="pre">THREE.GLSL3</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">null</span></code>. </p> <h3 id="index0attributename-string" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">index0AttributeName</span><span class="sig-colon">:</span> <span class="sig-type">String</span>
</dt></h3> <p> If set, this calls <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation">gl.bindAttribLocation</a> to bind a generic vertex index to an attribute variable. Default is undefined. </p> <h3 id="isshadermaterial-boolean" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">isShaderMaterial</span><span class="sig-colon">:</span> <span class="sig-type">Boolean</span>
</dt></h3> <p>Read-only flag to check if a given object is of type [name].</p> <h3 id="lights-boolean" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">lights</span><span class="sig-colon">:</span> <span class="sig-type">Boolean</span>
</dt></h3> <p> Defines whether this material uses lighting; true to pass uniform data related to lighting to this shader. Default is false. </p> <h3 id="linewidth-float" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">linewidth</span><span class="sig-colon">:</span> <span class="sig-type">Float</span>
</dt></h3> <p> Controls wireframe thickness. Default is <code class="docutils literal notranslate"><span class="pre">1</span></code>.<br><br> Due to limitations of the <a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf">OpenGL Core Profile</a> with the <a class="reference internal" href="webglrenderer.html"><code class="xref js js-webglrenderer">WebGL</code></a> renderer on most platforms linewidth will always be <code class="docutils literal notranslate"><span class="pre">1</span></code> regardless of the set value. </p> <h3 id="flatshading-boolean" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">flatShading</span><span class="sig-colon">:</span> <span class="sig-type">Boolean</span>
</dt></h3> <p> Define whether the material is rendered with flat shading. Default is false. </p> <h3 id="uniforms-object" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">uniforms</span><span class="sig-colon">:</span> <span class="sig-type">Object</span>
</dt></h3> <p> An object of the form: <pre data-language="javascript"><code> 
				{ 
					"uniform1": { value: 1.0 }, 
					"uniform2": { value: 2 } 
				}
			</code></pre> specifying the uniforms to be passed to the shader code; keys are uniform names, values are definitions of the form <pre data-language="javascript"><code> 
				{
					value: 1.0 
				}
			</code></pre> where `value` is the value of the uniform. Names must match the name of the uniform, as defined in the GLSL code. Note that uniforms are refreshed on every frame, so updating the value of the uniform will immediately update the value available to the GLSL code. </p> <h3 id="uniformsneedupdate-boolean" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">uniformsNeedUpdate</span><span class="sig-colon">:</span> <span class="sig-type">Boolean</span>
</dt></h3> <p> Can be used to force a uniform update while changing uniforms in <a class="reference internal" href="object3d.onbeforerender.html"><code class="xref js js-object3d.onbeforerender">Object3D.onBeforeRender</code></a>(). Default is <code class="docutils literal notranslate"><span class="pre">false</span></code>. </p> <h3 id="vertexcolors-boolean" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">vertexColors</span><span class="sig-colon">:</span> <span class="sig-type">Boolean</span>
</dt></h3> <p>Defines whether vertex coloring is used. Default is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p> <h3 id="vertexshader-string" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">vertexShader</span><span class="sig-colon">:</span> <span class="sig-type">String</span>
</dt></h3> <p> Vertex shader GLSL code. This is the actual code for the shader. In the example above, the <code class="docutils literal notranslate"><span class="pre">vertexShader</span></code> and <code class="docutils literal notranslate"><span class="pre">fragmentShader</span></code> code is extracted from the DOM; it could be passed as a string directly or loaded via AJAX instead. </p> <h3 id="wireframe-boolean" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">wireframe</span><span class="sig-colon">:</span> <span class="sig-type">Boolean</span>
</dt></h3> <p> Render geometry as wireframe (using GL_LINES instead of GL_TRIANGLES). Default is false (i.e. render as flat polygons). </p> <h3 id="wireframelinewidth-float" class=" section-header"><dt class="sig sig-object js">
<span class="sig-name descname">wireframeLinewidth</span><span class="sig-colon">:</span> <span class="sig-type">Float</span>
</dt></h3> <p> Controls wireframe thickness. Default is <code class="docutils literal notranslate"><span class="pre">1</span></code>.<br><br> Due to limitations of the <a class="reference external" href="https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf">OpenGL Core Profile</a> with the <a class="reference internal" href="webglrenderer.html"><code class="xref js js-webglrenderer">WebGL</code></a> renderer on most platforms linewidth will always be <code class="docutils literal notranslate"><span class="pre">1</span></code> regardless of the set value. </p> </div> <div class="section">
<h2 class="section-title section-header" id="methods">Methods</h2>
<p>See the base <a class="reference internal" href="material.html"><code class="xref js js-material">Material</code></a> class for common methods.</p> <h3 id="clone-shadermaterial" class=" section-header"><dt class="sig sig-object js" id="clone">
<span class="sig-name descname">clone</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="sig-returns"><span class="sig-colon">:</span> <span class="sig-type">ShaderMaterial</span></span>
</dt></h3> <p> Generates a shallow copy of this material. Note that the vertexShader and fragmentShader are copied <code class="docutils literal notranslate"><span class="pre">by reference</span></code>, as are the definitions of the <code class="docutils literal notranslate"><span class="pre">attributes</span></code>; this means that clones of the material will share the same compiled <a class="reference internal" href="webglprogram.html"><code class="xref js js-webglprogram">WebGLProgram</code></a>. However, the <code class="docutils literal notranslate"><span class="pre">uniforms</span></code> are copied <code class="docutils literal notranslate"><span class="pre">by value</span></code>, which allows you to have different sets of uniforms for different copies of the material. </p>   </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2025 Three.js Authors<br>Licensed under the MIT License.<br>
    <a href="https://threejs.org/docs/api/en/materials/ShaderMaterial.html" class="_attribution-link">https://threejs.org/docs/api/en/materials/ShaderMaterial.html</a>
  </p>
</div>
