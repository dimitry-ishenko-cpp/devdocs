<h1 id="module-transform">Module: transform</h1> <table class="longtable docutils align-default" id="module-skimage.transform">   <tr>
<td><p><a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code>skimage.transform.downscale_local_mean</code></a>(…)</p></td> <td><p>Down-sample N-dimensional image by local averaging.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.estimate_transform" title="skimage.transform.estimate_transform"><code>skimage.transform.estimate_transform</code></a>(ttype, …)</p></td> <td><p>Estimate 2D geometric transformation parameters.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code>skimage.transform.frt2</code></a>(a)</p></td> <td><p>Compute the 2-dimensional finite radon transform (FRT) for an n x n integer array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><code>skimage.transform.hough_circle</code></a>(image, radius)</p></td> <td><p>Perform a circular Hough transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.hough_circle_peaks" title="skimage.transform.hough_circle_peaks"><code>skimage.transform.hough_circle_peaks</code></a>(…[, …])</p></td> <td><p>Return peaks in a circle Hough transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.hough_ellipse" title="skimage.transform.hough_ellipse"><code>skimage.transform.hough_ellipse</code></a>(image[, …])</p></td> <td><p>Perform an elliptical Hough transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code>skimage.transform.hough_line</code></a>(image[, theta])</p></td> <td><p>Perform a straight line Hough transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.hough_line_peaks" title="skimage.transform.hough_line_peaks"><code>skimage.transform.hough_line_peaks</code></a>(hspace, …)</p></td> <td><p>Return peaks in a straight line Hough transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code>skimage.transform.ifrt2</code></a>(a)</p></td> <td><p>Compute the 2-dimensional inverse finite radon transform (iFRT) for an (n+1) x n integer array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.integral_image" title="skimage.transform.integral_image"><code>skimage.transform.integral_image</code></a>(image)</p></td> <td><p>Integral image / summed area table.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.integrate" title="skimage.transform.integrate"><code>skimage.transform.integrate</code></a>(ii, start, end)</p></td> <td><p>Use an integral image to integrate over a given window.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.iradon" title="skimage.transform.iradon"><code>skimage.transform.iradon</code></a>(radon_image[, …])</p></td> <td><p>Inverse radon transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.iradon_sart" title="skimage.transform.iradon_sart"><code>skimage.transform.iradon_sart</code></a>(radon_image[, …])</p></td> <td><p>Inverse radon transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.matrix_transform" title="skimage.transform.matrix_transform"><code>skimage.transform.matrix_transform</code></a>(coords, …)</p></td> <td><p>Apply 2D matrix transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.order_angles_golden_ratio" title="skimage.transform.order_angles_golden_ratio"><code>skimage.transform.order_angles_golden_ratio</code></a>(theta)</p></td> <td><p>Order angles to reduce the amount of correlated information in subsequent projections.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.probabilistic_hough_line" title="skimage.transform.probabilistic_hough_line"><code>skimage.transform.probabilistic_hough_line</code></a>(image)</p></td> <td><p>Return lines from a progressive probabilistic line Hough transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.pyramid_expand" title="skimage.transform.pyramid_expand"><code>skimage.transform.pyramid_expand</code></a>(image[, …])</p></td> <td><p>Upsample and then smooth image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.pyramid_gaussian" title="skimage.transform.pyramid_gaussian"><code>skimage.transform.pyramid_gaussian</code></a>(image[, …])</p></td> <td><p>Yield images of the Gaussian pyramid formed by the input image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.pyramid_laplacian" title="skimage.transform.pyramid_laplacian"><code>skimage.transform.pyramid_laplacian</code></a>(image[, …])</p></td> <td><p>Yield images of the laplacian pyramid formed by the input image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><code>skimage.transform.pyramid_reduce</code></a>(image[, …])</p></td> <td><p>Smooth and then downsample image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.radon" title="skimage.transform.radon"><code>skimage.transform.radon</code></a>(image[, theta, …])</p></td> <td><p>Calculates the radon transform of an image given specified projection angles.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><code>skimage.transform.rescale</code></a>(image, scale[, …])</p></td> <td><p>Scale image by a certain factor.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code>skimage.transform.resize</code></a>(image, output_shape)</p></td> <td><p>Resize image to match a certain size.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.rotate" title="skimage.transform.rotate"><code>skimage.transform.rotate</code></a>(image, angle[, …])</p></td> <td><p>Rotate image by a certain angle around its center.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.swirl" title="skimage.transform.swirl"><code>skimage.transform.swirl</code></a>(image[, center, …])</p></td> <td><p>Perform a swirl transformation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a>(image, inverse_map[, …])</p></td> <td><p>Warp an image according to a given coordinate transformation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.warp_coords" title="skimage.transform.warp_coords"><code>skimage.transform.warp_coords</code></a>(coord_map, shape)</p></td> <td><p>Build the source coordinates for the output of a 2-D image warp.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.warp_polar" title="skimage.transform.warp_polar"><code>skimage.transform.warp_polar</code></a>(image[, …])</p></td> <td><p>Remap image to polar or log-polar coordinates space.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code>skimage.transform.AffineTransform</code></a>([matrix, …])</p></td> <td><p>2D affine transformation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code>skimage.transform.EssentialMatrixTransform</code></a>([…])</p></td> <td><p>Essential matrix transformation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.EuclideanTransform" title="skimage.transform.EuclideanTransform"><code>skimage.transform.EuclideanTransform</code></a>([…])</p></td> <td><p>2D Euclidean transformation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code>skimage.transform.FundamentalMatrixTransform</code></a>([…])</p></td> <td><p>Fundamental matrix transformation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.PiecewiseAffineTransform" title="skimage.transform.PiecewiseAffineTransform"><code>skimage.transform.PiecewiseAffineTransform</code></a>()</p></td> <td><p>2D piecewise affine transformation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><code>skimage.transform.PolynomialTransform</code></a>([params])</p></td> <td><p>2D polynomial transformation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code>skimage.transform.ProjectiveTransform</code></a>([matrix])</p></td> <td><p>Projective transformation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code>skimage.transform.SimilarityTransform</code></a>([…])</p></td> <td><p>2D similarity transformation.</p></td> </tr>  </table>  <h2 id="downscale-local-mean">downscale_local_mean</h2> <dl class="function"> <dt id="skimage.transform.downscale_local_mean">
<code>skimage.transform.downscale_local_mean(image, factors, cval=0, clip=True)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L407-L451"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Down-sample N-dimensional image by local averaging.</p> <p>The image is padded with <code>cval</code> if it is not perfectly divisible by the integer factors.</p> <p>In contrast to interpolation in <a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code>skimage.transform.resize</code></a> and <a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><code>skimage.transform.rescale</code></a> this function calculates the local mean of elements in each block of size <code>factors</code> in the input image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>N-dimensional input image.</p> </dd> <dt>
<code>factorsarray_like</code> </dt>
<dd>
<p>Array containing down-sampling integer factor along each axis.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Constant padding value if image is not perfectly divisible by the integer factors.</p> </dd> <dt>
<code>clipbool, optional</code> </dt>
<dd>
<p>Unused, but kept here for API consistency with the other transforms in this module. (The local mean will never fall outside the range of values in the input image, assuming the provided <code>cval</code> also falls within that range.)</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Down-sampled image with same number of dimensions as input image. For integer inputs, the output dtype will be <code>float64</code>. See <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.mean.html#numpy.mean" title="(in NumPy v1.19)"><code>numpy.mean()</code></a> for details.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.arange(15).reshape(3, 5)
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
&gt;&gt;&gt; downscale_local_mean(a, (2, 3))
array([[3.5, 4. ],
       [5.5, 4.5]])
</pre> </dd>
</dl>   <h2 id="estimate-transform">estimate_transform</h2> <dl class="function"> <dt id="skimage.transform.estimate_transform">
<code>skimage.transform.estimate_transform(ttype, src, dst, **kwargs)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1342-L1413"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate 2D geometric transformation parameters.</p> <p>You can determine the over-, well- and under-determined parameters with the total least-squares method.</p> <p>Number of source and destination coordinates must match.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>ttype{‘euclidean’, similarity’, ‘affine’, ‘piecewise-affine’, ‘projective’, ‘polynomial’}</code> </dt>
<dd>
<p>Type of transform.</p> </dd> <dt>
<code>kwargsarray or int</code> </dt>
<dd>
<p>Function parameters (src, dst, n, angle):</p> <pre data-language="python">NAME / TTYPE        FUNCTION PARAMETERS
'euclidean'         `src, `dst`
'similarity'        `src, `dst`
'affine'            `src, `dst`
'piecewise-affine'  `src, `dst`
'projective'        `src, `dst`
'polynomial'        `src, `dst`, `order` (polynomial order,
                                          default order is 2)
</pre> <p>Also see examples below.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>tformGeometricTransform</code> </dt>
<dd>
<p>Transform object containing the transformation parameters and providing access to forward and inverse transformation functions.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage import transform
</pre> <pre data-language="python">&gt;&gt;&gt; # estimate transformation parameters
&gt;&gt;&gt; src = np.array([0, 0, 10, 10]).reshape((2, 2))
&gt;&gt;&gt; dst = np.array([12, 14, 1, -20]).reshape((2, 2))
</pre> <pre data-language="python">&gt;&gt;&gt; tform = transform.estimate_transform('similarity', src, dst)
</pre> <pre data-language="python">&gt;&gt;&gt; np.allclose(tform.inverse(tform(src)), src)
True
</pre> <pre data-language="python">&gt;&gt;&gt; # warp image using the estimated transformation
&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; image = data.camera()
</pre> <pre data-language="python">&gt;&gt;&gt; warp(image, inverse_map=tform.inverse) 
</pre> <pre data-language="python">&gt;&gt;&gt; # create transformation with explicit parameters
&gt;&gt;&gt; tform2 = transform.SimilarityTransform(scale=1.1, rotation=1,
...     translation=(10, 20))
</pre> <pre data-language="python">&gt;&gt;&gt; # unite transformations, applied in order from left to right
&gt;&gt;&gt; tform3 = tform + tform2
&gt;&gt;&gt; np.allclose(tform3(src), tform2(tform(src)))
True
</pre> </dd>
</dl>   <h2 id="frt2">frt2</h2> <dl class="function"> <dt id="skimage.transform.frt2">
<code>skimage.transform.frt2(a)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/finite_radon_transform.py#L12-L68"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the 2-dimensional finite radon transform (FRT) for an n x n integer array.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>aarray_like</code> </dt>
<dd>
<p>A 2-D square n x n integer array.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>FRT2-D ndarray</code> </dt>
<dd>
<p>Finite Radon Transform array of (n+1) x n integer coefficients.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code>ifrt2</code></a>
</dt>
<dd>
<p>The two-dimensional inverse FRT.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>The FRT has a unique inverse if and only if n is prime. [FRT] The idea for this algorithm is due to Vlad Negnevitski.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rdb433381c1a5-frt">
<code>FRT</code> </dt> <dd>
<p>A. Kingston and I. Svalbe, “Projective transforms on periodic discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging and Electron Physics, 139 (2006)</p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>Generate a test image: Use a prime number for the array dimensions</p> <pre data-language="python">&gt;&gt;&gt; SIZE = 59
&gt;&gt;&gt; img = np.tri(SIZE, dtype=np.int32)
</pre> <p>Apply the Finite Radon Transform:</p> <pre data-language="python">&gt;&gt;&gt; f = frt2(img)
</pre> </dd>
</dl>   <h2 id="hough-circle">hough_circle</h2> <dl class="function"> <dt id="skimage.transform.hough_circle">
<code>skimage.transform.hough_circle(image, radius, normalize=True, full_output=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L72-L113"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform a circular Hough transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M, N) ndarray</code> </dt>
<dd>
<p>Input image with nonzero values representing edges.</p> </dd> <dt>
<code>radiusscalar or sequence of scalars</code> </dt>
<dd>
<p>Radii at which to compute the Hough transform. Floats are converted to integers.</p> </dd> <dt>
<code>normalizeboolean, optional (default True)</code> </dt>
<dd>
<p>Normalize the accumulator with the number of pixels used to draw the radius.</p> </dd> <dt>
<code>full_outputboolean, optional (default False)</code> </dt>
<dd>
<p>Extend the output size by twice the largest radius in order to detect centers outside the input picture.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>H3D ndarray (radius index, (M + 2R, N + 2R) ndarray)</code> </dt>
<dd>
<p>Hough transform accumulator for each radius. R designates the larger radius if full_output is True. Otherwise, R = 0.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import hough_circle
&gt;&gt;&gt; from skimage.draw import circle_perimeter
&gt;&gt;&gt; img = np.zeros((100, 100), dtype=bool)
&gt;&gt;&gt; rr, cc = circle_perimeter(25, 35, 23)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; try_radii = np.arange(5, 50)
&gt;&gt;&gt; res = hough_circle(img, try_radii)
&gt;&gt;&gt; ridx, r, c = np.unravel_index(np.argmax(res), res.shape)
&gt;&gt;&gt; r, c, try_radii[ridx]
(25, 35, 23)
</pre> </dd>
</dl>   <h2 id="hough-circle-peaks">hough_circle_peaks</h2> <dl class="function"> <dt id="skimage.transform.hough_circle_peaks">
<code>skimage.transform.hough_circle_peaks(hspaces, radii, min_xdistance=1, min_ydistance=1, threshold=None, num_peaks=inf, total_num_peaks=inf, normalize=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L271-L377"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return peaks in a circle Hough transform.</p> <p>Identifies most prominent circles separated by certain distances in given Hough spaces. Non-maximum suppression with different sizes is applied separately in the first and second dimension of the Hough space to identify peaks. For circles with different radius but close in distance, only the one with highest peak is kept.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>hspaces(N, M) array</code> </dt>
<dd>
<p>Hough spaces returned by the <a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><code>hough_circle</code></a> function.</p> </dd> <dt>
<code>radii(M,) array</code> </dt>
<dd>
<p>Radii corresponding to Hough spaces.</p> </dd> <dt>
<code>min_xdistanceint, optional</code> </dt>
<dd>
<p>Minimum distance separating centers in the x dimension.</p> </dd> <dt>
<code>min_ydistanceint, optional</code> </dt>
<dd>
<p>Minimum distance separating centers in the y dimension.</p> </dd> <dt>
<code>thresholdfloat, optional</code> </dt>
<dd>
<p>Minimum intensity of peaks in each Hough space. Default is <code>0.5 * max(hspace)</code>.</p> </dd> <dt>
<code>num_peaksint, optional</code> </dt>
<dd>
<p>Maximum number of peaks in each Hough space. When the number of peaks exceeds <code>num_peaks</code>, only <code>num_peaks</code> coordinates based on peak intensity are considered for the corresponding radius.</p> </dd> <dt>
<code>total_num_peaksint, optional</code> </dt>
<dd>
<p>Maximum number of peaks. When the number of peaks exceeds <code>num_peaks</code>, return <code>num_peaks</code> coordinates based on peak intensity.</p> </dd> <dt>
<code>normalizebool, optional</code> </dt>
<dd>
<p>If True, normalize the accumulator by the radius to sort the prominent peaks.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>accum, cx, cy, radtuple of array</code> </dt>
<dd>
<p>Peak values in Hough space, x and y center coordinates and radii.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Circles with bigger radius have higher peaks in Hough space. If larger circles are preferred over smaller ones, <code>normalize</code> should be False. Otherwise, circles will be returned in the order of decreasing voting number.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import transform, draw
&gt;&gt;&gt; img = np.zeros((120, 100), dtype=int)
&gt;&gt;&gt; radius, x_0, y_0 = (20, 99, 50)
&gt;&gt;&gt; y, x = draw.circle_perimeter(y_0, x_0, radius)
&gt;&gt;&gt; img[x, y] = 1
&gt;&gt;&gt; hspaces = transform.hough_circle(img, radius)
&gt;&gt;&gt; accum, cx, cy, rad = hough_circle_peaks(hspaces, [radius,])
</pre> </dd>
</dl>   <h2 id="hough-ellipse">hough_ellipse</h2> <dl class="function"> <dt id="skimage.transform.hough_ellipse">
<code>skimage.transform.hough_ellipse(image, threshold=4, accuracy=1, min_size=4, max_size=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L116-L165"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform an elliptical Hough transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M, N) ndarray</code> </dt>
<dd>
<p>Input image with nonzero values representing edges.</p> </dd> <dt>
<code>thresholdint, optional</code> </dt>
<dd>
<p>Accumulator threshold value.</p> </dd> <dt>
<code>accuracydouble, optional</code> </dt>
<dd>
<p>Bin size on the minor axis used in the accumulator.</p> </dd> <dt>
<code>min_sizeint, optional</code> </dt>
<dd>
<p>Minimal major axis length.</p> </dd> <dt>
<code>max_sizeint, optional</code> </dt>
<dd>
<p>Maximal minor axis length. If None, the value is set to the half of the smaller image dimension.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>resultndarray with fields [(accumulator, yc, xc, a, b, orientation)].</code> </dt>
<dd>
<p>Where <code>(yc, xc)</code> is the center, <code>(a, b)</code> the major and minor axes, respectively. The <code>orientation</code> value follows <a class="reference internal" href="skimage.draw.html#skimage.draw.ellipse_perimeter" title="skimage.draw.ellipse_perimeter"><code>skimage.draw.ellipse_perimeter</code></a> convention.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The accuracy must be chosen to produce a peak in the accumulator distribution. In other words, a flat accumulator distribution with low values may be caused by a too low bin size.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rf2ef66e2ec1f-1">
<code>1</code> </dt> <dd>
<p>Xie, Yonghong, and Qiang Ji. “A new efficient ellipse detection method.” Pattern Recognition, 2002. Proceedings. 16th International Conference on. Vol. 2. IEEE, 2002</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import hough_ellipse
&gt;&gt;&gt; from skimage.draw import ellipse_perimeter
&gt;&gt;&gt; img = np.zeros((25, 25), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = ellipse_perimeter(10, 10, 6, 8)
&gt;&gt;&gt; img[cc, rr] = 1
&gt;&gt;&gt; result = hough_ellipse(img, threshold=8)
&gt;&gt;&gt; result.tolist()
[(10, 10.0, 10.0, 8.0, 6.0, 0.0)]
</pre> </dd>
</dl>   <h2 id="hough-line">hough_line</h2> <dl class="function"> <dt id="skimage.transform.hough_line">
<code>skimage.transform.hough_line(image, theta=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L168-L223"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform a straight line Hough transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M, N) ndarray</code> </dt>
<dd>
<p>Input image with nonzero values representing edges.</p> </dd> <dt>
<code>theta1D ndarray of double, optional</code> </dt>
<dd>
<p>Angles at which to compute the transform, in radians. Defaults to a vector of 180 angles evenly spaced from -pi/2 to pi/2.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>hspace2-D ndarray of uint64</code> </dt>
<dd>
<p>Hough transform accumulator.</p> </dd> <dt>
<code>anglesndarray</code> </dt>
<dd>
<p>Angles at which the transform is computed, in radians.</p> </dd> <dt>
<code>distancesndarray</code> </dt>
<dd>
<p>Distance values.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The origin is the top left corner of the original image. X and Y axis are horizontal and vertical edges respectively. The distance is the minimal algebraic distance from the origin to the detected line. The angle accuracy can be improved by decreasing the step size in the <code>theta</code> array.</p> <h4 class="rubric">Examples</h4> <p>Generate a test image:</p> <pre data-language="python">&gt;&gt;&gt; img = np.zeros((100, 150), dtype=bool)
&gt;&gt;&gt; img[30, :] = 1
&gt;&gt;&gt; img[:, 65] = 1
&gt;&gt;&gt; img[35:45, 35:50] = 1
&gt;&gt;&gt; for i in range(90):
...     img[i, i] = 1
&gt;&gt;&gt; img += np.random.random(img.shape) &gt; 0.95
</pre> <p>Apply the Hough transform:</p> <pre data-language="python">&gt;&gt;&gt; out, angles, d = hough_line(img)
</pre> <pre data-language="python">import numpy as np
import matplotlib.pyplot as plt

from skimage.transform import hough_line
from skimage.draw import line

img = np.zeros((100, 150), dtype=bool)
img[30, :] = 1
img[:, 65] = 1
img[35:45, 35:50] = 1
rr, cc = line(60, 130, 80, 10)
img[rr, cc] = 1
img += np.random.random(img.shape) &gt; 0.95

out, angles, d = hough_line(img)

fix, axes = plt.subplots(1, 2, figsize=(7, 4))

axes[0].imshow(img, cmap=plt.cm.gray)
axes[0].set_title('Input image')

axes[1].imshow(
    out, cmap=plt.cm.bone,
    extent=(np.rad2deg(angles[-1]), np.rad2deg(angles[0]), d[-1], d[0]))
axes[1].set_title('Hough transform')
axes[1].set_xlabel('Angle (degree)')
axes[1].set_ylabel('Distance (pixel)')

plt.tight_layout()
plt.show()
</pre> <p>(<a class="reference external" href="https://scikit-image.org/docs/0.18.x/plots/hough_tf.py">Source code</a>, <a class="reference external" href="https://scikit-image.org/docs/0.18.x/plots/hough_tf.png">png</a>, <a class="reference external" href="https://scikit-image.org/docs/0.18.x/plots/hough_tf.pdf">pdf</a>)</p> <div class="figure align-default"> <img alt="../_images/hough_tf.png" src="data:image/png;base64,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"> </div> </dd>
</dl>   <h2 id="hough-line-peaks">hough_line_peaks</h2> <dl class="function"> <dt id="skimage.transform.hough_line_peaks">
<code>skimage.transform.hough_line_peaks(hspace, angles, dists, min_distance=9, min_angle=10, threshold=None, num_peaks=inf)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L9-L69"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return peaks in a straight line Hough transform.</p> <p>Identifies most prominent lines separated by a certain angle and distance in a Hough transform. Non-maximum suppression with different sizes is applied separately in the first (distances) and second (angles) dimension of the Hough space to identify peaks.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>hspace(N, M) array</code> </dt>
<dd>
<p>Hough space returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code>hough_line</code></a> function.</p> </dd> <dt>
<code>angles(M,) array</code> </dt>
<dd>
<p>Angles returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code>hough_line</code></a> function. Assumed to be continuous. (<code>angles[-1] - angles[0] == PI</code>).</p> </dd> <dt>
<code>dists(N, ) array</code> </dt>
<dd>
<p>Distances returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code>hough_line</code></a> function.</p> </dd> <dt>
<code>min_distanceint, optional</code> </dt>
<dd>
<p>Minimum distance separating lines (maximum filter size for first dimension of hough space).</p> </dd> <dt>
<code>min_angleint, optional</code> </dt>
<dd>
<p>Minimum angle separating lines (maximum filter size for second dimension of hough space).</p> </dd> <dt>
<code>thresholdfloat, optional</code> </dt>
<dd>
<p>Minimum intensity of peaks. Default is <code>0.5 * max(hspace)</code>.</p> </dd> <dt>
<code>num_peaksint, optional</code> </dt>
<dd>
<p>Maximum number of peaks. When the number of peaks exceeds <code>num_peaks</code>, return <code>num_peaks</code> coordinates based on peak intensity.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>accum, angles, diststuple of array</code> </dt>
<dd>
<p>Peak values in Hough space, angles and distances.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import hough_line, hough_line_peaks
&gt;&gt;&gt; from skimage.draw import line
&gt;&gt;&gt; img = np.zeros((15, 15), dtype=bool)
&gt;&gt;&gt; rr, cc = line(0, 0, 14, 14)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; rr, cc = line(0, 14, 14, 0)
&gt;&gt;&gt; img[cc, rr] = 1
&gt;&gt;&gt; hspace, angles, dists = hough_line(img)
&gt;&gt;&gt; hspace, angles, dists = hough_line_peaks(hspace, angles, dists)
&gt;&gt;&gt; len(angles)
2
</pre> </dd>
</dl>   <h2 id="ifrt2">ifrt2</h2> <dl class="function"> <dt id="skimage.transform.ifrt2">
<code>skimage.transform.ifrt2(a)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/finite_radon_transform.py#L71-L134"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the 2-dimensional inverse finite radon transform (iFRT) for an (n+1) x n integer array.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>aarray_like</code> </dt>
<dd>
<p>A 2-D (n+1) row x n column integer array.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>iFRT2-D n x n ndarray</code> </dt>
<dd>
<p>Inverse Finite Radon Transform array of n x n integer coefficients.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code>frt2</code></a>
</dt>
<dd>
<p>The two-dimensional FRT</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>The FRT has a unique inverse if and only if n is prime. See <a class="reference internal" href="#r3b76f892cb20-1" id="id3">[1]</a> for an overview. The idea for this algorithm is due to Vlad Negnevitski.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r3b76f892cb20-1">
<code>1</code> </dt> <dd>
<p>A. Kingston and I. Svalbe, “Projective transforms on periodic discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging and Electron Physics, 139 (2006)</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; SIZE = 59
&gt;&gt;&gt; img = np.tri(SIZE, dtype=np.int32)
</pre> <p>Apply the Finite Radon Transform:</p> <pre data-language="python">&gt;&gt;&gt; f = frt2(img)
</pre> <p>Apply the Inverse Finite Radon Transform to recover the input</p> <pre data-language="python">&gt;&gt;&gt; fi = ifrt2(f)
</pre> <p>Check that it’s identical to the original</p> <pre data-language="python">&gt;&gt;&gt; assert len(np.nonzero(img-fi)[0]) == 0
</pre> </dd>
</dl>   <h2 id="integral-image">integral_image</h2> <dl class="function"> <dt id="skimage.transform.integral_image">
<code>skimage.transform.integral_image(image)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/integral.py#L4-L33"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Integral image / summed area table.</p> <p>The integral image contains the sum of all elements above and to the left of it, i.e.:</p> <div class="math notranslate nohighlight"> \[S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]\]</div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>Sndarray</code> </dt>
<dd>
<p>Integral image/summed area table of same shape as input image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rd91ebd979f08-1">
<code>1</code> </dt> <dd>
<p>F.C. Crow, “Summed-area tables for texture mapping,” ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.</p> </dd> </dl> </dd>
</dl>   <h2 id="integrate">integrate</h2> <dl class="function"> <dt id="skimage.transform.integrate">
<code>skimage.transform.integrate(ii, start, end)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/integral.py#L36-L128"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Use an integral image to integrate over a given window.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>iindarray</code> </dt>
<dd>
<p>Integral image.</p> </dd> <dt>
<code>startList of tuples, each tuple of length equal to dimension of ii</code> </dt>
<dd>
<p>Coordinates of top left corner of window(s). Each tuple in the list contains the starting row, col, … index i.e <code>[(row_win1, col_win1, …), (row_win2, col_win2,…), …]</code>.</p> </dd> <dt>
<code>endList of tuples, each tuple of length equal to dimension of ii</code> </dt>
<dd>
<p>Coordinates of bottom right corner of window(s). Each tuple in the list containing the end row, col, … index i.e <code>[(row_win1, col_win1, …), (row_win2, col_win2, …), …]</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>Sscalar or ndarray</code> </dt>
<dd>
<p>Integral (sum) over the given window(s).</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; arr = np.ones((5, 6), dtype=float)
&gt;&gt;&gt; ii = integral_image(arr)
&gt;&gt;&gt; integrate(ii, (1, 0), (1, 2))  # sum from (1, 0) to (1, 2)
array([3.])
&gt;&gt;&gt; integrate(ii, [(3, 3)], [(4, 5)])  # sum from (3, 3) to (4, 5)
array([6.])
&gt;&gt;&gt; # sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)
&gt;&gt;&gt; integrate(ii, [(1, 0), (3, 3)], [(1, 2), (4, 5)])
array([3., 6.])
</pre> </dd>
</dl>   <h2 id="iradon">iradon</h2> <dl class="function"> <dt id="skimage.transform.iradon">
<code>skimage.transform.iradon(radon_image, theta=None, output_size=None, filter_name='ramp', interpolation='linear', circle=True, preserve_range=True)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/radon_transform.py#L184-L314"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Inverse radon transform.</p> <p>Reconstruct an image from the radon transform, using the filtered back projection algorithm.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>radon_imagearray</code> </dt>
<dd>
<p>Image containing radon transform (sinogram). Each column of the image corresponds to a projection along a different angle. The tomography rotation axis should lie at the pixel index <code>radon_image.shape[0] // 2</code> along the 0th dimension of <code>radon_image</code>.</p> </dd> <dt>
<code>thetaarray_like, optional</code> </dt>
<dd>
<p>Reconstruction angles (in degrees). Default: m angles evenly spaced between 0 and 180 (if the shape of <code>radon_image</code> is (N, M)).</p> </dd> <dt>
<code>output_sizeint, optional</code> </dt>
<dd>
<p>Number of rows and columns in the reconstruction.</p> </dd> <dt>
<code>filter_namestr, optional</code> </dt>
<dd>
<p>Filter used in frequency domain filtering. Ramp filter used by default. Filters available: ramp, shepp-logan, cosine, hamming, hann. Assign None to use no filter.</p> </dd> <dt>
<code>interpolationstr, optional</code> </dt>
<dd>
<p>Interpolation method used in reconstruction. Methods available: ‘linear’, ‘nearest’, and ‘cubic’ (‘cubic’ is slow).</p> </dd> <dt>
<code>circleboolean, optional</code> </dt>
<dd>
<p>Assume the reconstructed image is zero outside the inscribed circle. Also changes the default output_size to match the behaviour of <code>radon</code> called with <code>circle=True</code>.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>reconstructedndarray</code> </dt>
<dd>
<p>Reconstructed image. The rotation axis will be located in the pixel with indices <code>(reconstructed.shape[0] // 2, reconstructed.shape[1] // 2)</code>.</p> </dd> </dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.19: </span>In <code>iradon</code>, <code>filter</code> argument is deprecated in favor of <code>filter_name</code>.</p> </div> </dd> </dl> <h4 class="rubric">Notes</h4> <p>It applies the Fourier slice theorem to reconstruct an image by multiplying the frequency domain of the filter with the FFT of the projection data. This algorithm is called filtered back projection.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r19c92af887b5-1">
<code>1</code> </dt> <dd>
<p>AC Kak, M Slaney, “Principles of Computerized Tomographic Imaging”, IEEE Press 1988.</p> </dd> <dt class="label" id="r19c92af887b5-2">
<code>2</code> </dt> <dd>
<p>B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing the Discrete Radon Transform With Some Applications”, Proceedings of the Fourth IEEE Region 10 International Conference, TENCON ‘89, 1989</p> </dd> </dl> </dd>
</dl>   <h2 id="iradon-sart">iradon_sart</h2> <dl class="function"> <dt id="skimage.transform.iradon_sart">
<code>skimage.transform.iradon_sart(radon_image, theta=None, image=None, projection_shifts=None, clip=None, relaxation=0.15, dtype=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/radon_transform.py#L376-L515"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Inverse radon transform.</p> <p>Reconstruct an image from the radon transform, using a single iteration of the Simultaneous Algebraic Reconstruction Technique (SART) algorithm.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>radon_image2D array</code> </dt>
<dd>
<p>Image containing radon transform (sinogram). Each column of the image corresponds to a projection along a different angle. The tomography rotation axis should lie at the pixel index <code>radon_image.shape[0] // 2</code> along the 0th dimension of <code>radon_image</code>.</p> </dd> <dt>
<code>theta1D array, optional</code> </dt>
<dd>
<p>Reconstruction angles (in degrees). Default: m angles evenly spaced between 0 and 180 (if the shape of <code>radon_image</code> is (N, M)).</p> </dd> <dt>
<code>image2D array, optional</code> </dt>
<dd>
<p>Image containing an initial reconstruction estimate. Shape of this array should be <code>(radon_image.shape[0], radon_image.shape[0])</code>. The default is an array of zeros.</p> </dd> <dt>
<code>projection_shifts1D array, optional</code> </dt>
<dd>
<p>Shift the projections contained in <code>radon_image</code> (the sinogram) by this many pixels before reconstructing the image. The i’th value defines the shift of the i’th column of <code>radon_image</code>.</p> </dd> <dt>
<code>cliplength-2 sequence of floats, optional</code> </dt>
<dd>
<p>Force all values in the reconstructed tomogram to lie in the range <code>[clip[0], clip[1]]</code></p> </dd> <dt>
<code>relaxationfloat, optional</code> </dt>
<dd>
<p>Relaxation parameter for the update step. A higher value can improve the convergence rate, but one runs the risk of instabilities. Values close to or higher than 1 are not recommended.</p> </dd> <dt>
<code>dtypedtype, optional</code> </dt>
<dd>
<p>Output data type, must be floating point. By default, if input data type is not float, input is cast to double, otherwise dtype is set to input data type.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>reconstructedndarray</code> </dt>
<dd>
<p>Reconstructed image. The rotation axis will be located in the pixel with indices <code>(reconstructed.shape[0] // 2, reconstructed.shape[1] // 2)</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Algebraic Reconstruction Techniques are based on formulating the tomography reconstruction problem as a set of linear equations. Along each ray, the projected value is the sum of all the values of the cross section along the ray. A typical feature of SART (and a few other variants of algebraic techniques) is that it samples the cross section at equidistant points along the ray, using linear interpolation between the pixel values of the cross section. The resulting set of linear equations are then solved using a slightly modified Kaczmarz method.</p> <p>When using SART, a single iteration is usually sufficient to obtain a good reconstruction. Further iterations will tend to enhance high-frequency information, but will also often increase the noise.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r5a4015ea6a92-1">
<code>1</code> </dt> <dd>
<p>AC Kak, M Slaney, “Principles of Computerized Tomographic Imaging”, IEEE Press 1988.</p> </dd> <dt class="label" id="r5a4015ea6a92-2">
<code>2</code> </dt> <dd>
<p>AH Andersen, AC Kak, “Simultaneous algebraic reconstruction technique (SART): a superior implementation of the ART algorithm”, Ultrasonic Imaging 6 pp 81–94 (1984)</p> </dd> <dt class="label" id="r5a4015ea6a92-3">
<code>3</code> </dt> <dd>
<p>S Kaczmarz, “Angenäherte auflösung von systemen linearer gleichungen”, Bulletin International de l’Academie Polonaise des Sciences et des Lettres 35 pp 355–357 (1937)</p> </dd> <dt class="label" id="r5a4015ea6a92-4">
<code>4</code> </dt> <dd>
<p>Kohler, T. “A projection access scheme for iterative reconstruction based on the golden section.” Nuclear Science Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</p> </dd> <dt class="label" id="r5a4015ea6a92-5">
<code>5</code> </dt> <dd>
<p>Kaczmarz’ method, Wikipedia, <a class="reference external" href="https://en.wikipedia.org/wiki/Kaczmarz_method">https://en.wikipedia.org/wiki/Kaczmarz_method</a></p> </dd> </dl> </dd>
</dl>   <h2 id="matrix-transform">matrix_transform</h2> <dl class="function"> <dt id="skimage.transform.matrix_transform">
<code>skimage.transform.matrix_transform(coords, matrix)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1416-L1432"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply 2D matrix transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>coords(N, 2) array</code> </dt>
<dd>
<p>x, y coordinates to transform</p> </dd> <dt>
<code>matrix(3, 3) array</code> </dt>
<dd>
<p>Homogeneous transformation matrix.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>coords(N, 2) array</code> </dt>
<dd>
<p>Transformed coordinates.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="order-angles-golden-ratio">order_angles_golden_ratio</h2> <dl class="function"> <dt id="skimage.transform.order_angles_golden_ratio">
<code>skimage.transform.order_angles_golden_ratio(theta)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/radon_transform.py#L317-L373"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Order angles to reduce the amount of correlated information in subsequent projections.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>theta1D array of floats</code> </dt>
<dd>
<p>Projection angles in degrees. Duplicate angles are not allowed.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>indices_generatorgenerator yielding unsigned integers</code> </dt>
<dd>
<p>The returned generator yields indices into <code>theta</code> such that <code>theta[indices]</code> gives the approximate golden ratio ordering of the projections. In total, <code>len(theta)</code> indices are yielded. All non-negative integers &lt; <code>len(theta)</code> are yielded exactly once.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The method used here is that of the golden ratio introduced by T. Kohler.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r88d6c0557044-1">
<code>1</code> </dt> <dd>
<p>Kohler, T. “A projection access scheme for iterative reconstruction based on the golden section.” Nuclear Science Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</p> </dd> <dt class="label" id="r88d6c0557044-2">
<code>2</code> </dt> <dd>
<p>Winkelmann, Stefanie, et al. “An optimal radial profile order based on the Golden Ratio for time-resolved MRI.” Medical Imaging, IEEE Transactions on 26.1 (2007): 68-76.</p> </dd> </dl> </dd>
</dl>   <h2 id="probabilistic-hough-line">probabilistic_hough_line</h2> <dl class="function"> <dt id="skimage.transform.probabilistic_hough_line">
<code>skimage.transform.probabilistic_hough_line(image, threshold=10, line_length=50, line_gap=10, theta=None, seed=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L226-L268"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return lines from a progressive probabilistic line Hough transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M, N) ndarray</code> </dt>
<dd>
<p>Input image with nonzero values representing edges.</p> </dd> <dt>
<code>thresholdint, optional</code> </dt>
<dd>
<p>Threshold</p> </dd> <dt>
<code>line_lengthint, optional</code> </dt>
<dd>
<p>Minimum accepted length of detected lines. Increase the parameter to extract longer lines.</p> </dd> <dt>
<code>line_gapint, optional</code> </dt>
<dd>
<p>Maximum gap between pixels to still form a line. Increase the parameter to merge broken lines more aggressively.</p> </dd> <dt>
<code>theta1D ndarray, dtype=double, optional</code> </dt>
<dd>
<p>Angles at which to compute the transform, in radians. If None, use a range from -pi/2 to pi/2.</p> </dd> <dt>
<code>seedint, optional</code> </dt>
<dd>
<p>Seed to initialize the random number generator.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>lineslist</code> </dt>
<dd>
<p>List of lines identified, lines in format ((x0, y0), (x1, y1)), indicating line start and end.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rd9a46cdb16bc-1">
<code>1</code> </dt> <dd>
<p>C. Galamhos, J. Matas and J. Kittler, “Progressive probabilistic Hough transform for line detection”, in IEEE Computer Society Conference on Computer Vision and Pattern Recognition, 1999.</p> </dd> </dl> </dd>
</dl>   <h2 id="pyramid-expand">pyramid_expand</h2> <dl class="function"> <dt id="skimage.transform.pyramid_expand">
<code>skimage.transform.pyramid_expand(image, upscale=2, sigma=None, order=1, mode='reflect', cval=0, multichannel=False, preserve_range=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/pyramids.py#L85-L142"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Upsample and then smooth image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>upscalefloat, optional</code> </dt>
<dd>
<p>Upscale factor.</p> </dd> <dt>
<code>sigmafloat, optional</code> </dt>
<dd>
<p>Sigma for Gaussian filter. Default is <code>2 * upscale / 6.0</code> which corresponds to a filter mask twice the size of the scale factor that covers more than 99% of the Gaussian distribution.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>Order of splines used in interpolation of upsampling. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a> for detail.</p> </dd> <dt>
<code>mode{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</code> </dt>
<dd>
<p>The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Value to fill past edges of input if mode is ‘constant’.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Whether the last axis of the image is to be interpreted as multiple channels or another spatial dimension.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outarray</code> </dt>
<dd>
<p>Upsampled and smoothed float image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r53df52222c6d-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p> </dd> </dl> </dd>
</dl>   <h2 id="pyramid-gaussian">pyramid_gaussian</h2> <dl class="function"> <dt id="skimage.transform.pyramid_gaussian">
<code>skimage.transform.pyramid_gaussian(image, max_layer=-1, downscale=2, sigma=None, order=1, mode='reflect', cval=0, multichannel=False, preserve_range=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/pyramids.py#L145-L224"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Yield images of the Gaussian pyramid formed by the input image.</p> <p>Recursively applies the <a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><code>pyramid_reduce</code></a> function to the image, and yields the downscaled images.</p> <p>Note that the first image of the pyramid will be the original, unscaled image. The total number of images is <code>max_layer + 1</code>. In case all layers are computed, the last image is either a one-pixel image or the image where the reduction does not change its shape.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>max_layerint, optional</code> </dt>
<dd>
<p>Number of layers for the pyramid. 0th layer is the original image. Default is -1 which builds all possible layers.</p> </dd> <dt>
<code>downscalefloat, optional</code> </dt>
<dd>
<p>Downscale factor.</p> </dd> <dt>
<code>sigmafloat, optional</code> </dt>
<dd>
<p>Sigma for Gaussian filter. Default is <code>2 * downscale / 6.0</code> which corresponds to a filter mask twice the size of the scale factor that covers more than 99% of the Gaussian distribution.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>Order of splines used in interpolation of downsampling. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a> for detail.</p> </dd> <dt>
<code>mode{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</code> </dt>
<dd>
<p>The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Value to fill past edges of input if mode is ‘constant’.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Whether the last axis of the image is to be interpreted as multiple channels or another spatial dimension.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>pyramidgenerator</code> </dt>
<dd>
<p>Generator yielding pyramid layers as float images.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r4f1da659b730-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p> </dd> </dl> </dd>
</dl>   <h2 id="pyramid-laplacian">pyramid_laplacian</h2> <dl class="function"> <dt id="skimage.transform.pyramid_laplacian">
<code>skimage.transform.pyramid_laplacian(image, max_layer=-1, downscale=2, sigma=None, order=1, mode='reflect', cval=0, multichannel=False, preserve_range=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/pyramids.py#L227-L317"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Yield images of the laplacian pyramid formed by the input image.</p> <p>Each layer contains the difference between the downsampled and the downsampled, smoothed image:</p> <pre data-language="python">layer = resize(prev_layer) - smooth(resize(prev_layer))
</pre> <p>Note that the first image of the pyramid will be the difference between the original, unscaled image and its smoothed version. The total number of images is <code>max_layer + 1</code>. In case all layers are computed, the last image is either a one-pixel image or the image where the reduction does not change its shape.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>max_layerint, optional</code> </dt>
<dd>
<p>Number of layers for the pyramid. 0th layer is the original image. Default is -1 which builds all possible layers.</p> </dd> <dt>
<code>downscalefloat, optional</code> </dt>
<dd>
<p>Downscale factor.</p> </dd> <dt>
<code>sigmafloat, optional</code> </dt>
<dd>
<p>Sigma for Gaussian filter. Default is <code>2 * downscale / 6.0</code> which corresponds to a filter mask twice the size of the scale factor that covers more than 99% of the Gaussian distribution.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>Order of splines used in interpolation of downsampling. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a> for detail.</p> </dd> <dt>
<code>mode{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</code> </dt>
<dd>
<p>The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Value to fill past edges of input if mode is ‘constant’.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Whether the last axis of the image is to be interpreted as multiple channels or another spatial dimension.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>pyramidgenerator</code> </dt>
<dd>
<p>Generator yielding pyramid layers as float images.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r64565393f7ed-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p> </dd> <dt class="label" id="r64565393f7ed-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html">http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html</a></p> </dd> </dl> </dd>
</dl>   <h2 id="pyramid-reduce">pyramid_reduce</h2> <dl class="function"> <dt id="skimage.transform.pyramid_reduce">
<code>skimage.transform.pyramid_reduce(image, downscale=2, sigma=None, order=1, mode='reflect', cval=0, multichannel=False, preserve_range=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/pyramids.py#L25-L82"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Smooth and then downsample image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>downscalefloat, optional</code> </dt>
<dd>
<p>Downscale factor.</p> </dd> <dt>
<code>sigmafloat, optional</code> </dt>
<dd>
<p>Sigma for Gaussian filter. Default is <code>2 * downscale / 6.0</code> which corresponds to a filter mask twice the size of the scale factor that covers more than 99% of the Gaussian distribution.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>Order of splines used in interpolation of downsampling. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a> for detail.</p> </dd> <dt>
<code>mode{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</code> </dt>
<dd>
<p>The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Value to fill past edges of input if mode is ‘constant’.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Whether the last axis of the image is to be interpreted as multiple channels or another spatial dimension.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outarray</code> </dt>
<dd>
<p>Smoothed and downsampled float image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r4f51c9e42c4a-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p> </dd> </dl> </dd>
</dl>   <h2 id="radon">radon</h2> <dl class="function"> <dt id="skimage.transform.radon">
<code>skimage.transform.radon(image, theta=None, circle=True, *, preserve_range=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/radon_transform.py#L24-L115"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculates the radon transform of an image given specified projection angles.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagearray_like</code> </dt>
<dd>
<p>Input image. The rotation axis will be located in the pixel with indices <code>(image.shape[0] // 2, image.shape[1] // 2)</code>.</p> </dd> <dt>
<code>thetaarray_like, optional</code> </dt>
<dd>
<p>Projection angles (in degrees). If <code>None</code>, the value is set to np.arange(180).</p> </dd> <dt>
<code>circleboolean, optional</code> </dt>
<dd>
<p>Assume image is zero outside the inscribed circle, making the width of each projection (the first dimension of the sinogram) equal to <code>min(image.shape)</code>.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>radon_imagendarray</code> </dt>
<dd>
<p>Radon transform (sinogram). The tomography rotation axis will lie at the pixel index <code>radon_image.shape[0] // 2</code> along the 0th dimension of <code>radon_image</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Based on code of Justin K. Romberg (<a class="reference external" href="https://www.clear.rice.edu/elec431/projects96/DSP/bpanalysis.html">https://www.clear.rice.edu/elec431/projects96/DSP/bpanalysis.html</a>)</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r0eb755fc1fae-1">
<code>1</code> </dt> <dd>
<p>AC Kak, M Slaney, “Principles of Computerized Tomographic Imaging”, IEEE Press 1988.</p> </dd> <dt class="label" id="r0eb755fc1fae-2">
<code>2</code> </dt> <dd>
<p>B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing the Discrete Radon Transform With Some Applications”, Proceedings of the Fourth IEEE Region 10 International Conference, TENCON ‘89, 1989</p> </dd> </dl> </dd>
</dl>   <h2 id="rescale">rescale</h2> <dl class="function"> <dt id="skimage.transform.rescale">
<code>skimage.transform.rescale(image, scale, order=None, mode='reflect', cval=0, clip=True, preserve_range=False, multichannel=False, anti_aliasing=None, anti_aliasing_sigma=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L201-L293"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Scale image by a certain factor.</p> <p>Performs interpolation to up-scale or down-scale N-dimensional images. Note that anti-aliasing should be enabled when down-sizing images to avoid aliasing artifacts. For down-sampling with an integer factor also see <a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code>skimage.transform.downscale_local_mean</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>scale{float, tuple of floats}</code> </dt>
<dd>
<p>Scale factors. Separate scale factors can be defined as <code>(rows, cols[, …][, dim])</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>scaledndarray</code> </dt>
<dd>
<p>Scaled version of the input.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>The order of the spline interpolation, default is 0 if image.dtype is bool and 1 otherwise. The order has to be in the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a> for detail.</p> </dd> <dt>
<code>mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</code> </dt>
<dd>
<p>Points outside the boundaries of the input are filled according to the given mode. Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.19)"><code>numpy.pad</code></a>.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p> </dd> <dt>
<code>clipbool, optional</code> </dt>
<dd>
<p>Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Whether the last axis of the image is to be interpreted as multiple channels or another spatial dimension.</p> </dd> <dt>
<code>anti_aliasingbool, optional</code> </dt>
<dd>
<p>Whether to apply a Gaussian filter to smooth the image prior to down-scaling. It is crucial to filter when down-sampling the image to avoid aliasing artifacts. If input image data type is bool, no anti-aliasing is applied.</p> </dd> <dt>
<code>anti_aliasing_sigma{float, tuple of floats}, optional</code> </dt>
<dd>
<p>Standard deviation for Gaussian filtering to avoid aliasing artifacts. By default, this value is chosen as (s - 1) / 2 where s is the down-scaling factor.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge pixels are duplicated during the reflection. As an example, if an array has values [0, 1, 2] and was padded to the right by four values using symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it would be [0, 1, 2, 1, 0, 1, 2].</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.transform import rescale
&gt;&gt;&gt; image = data.camera()
&gt;&gt;&gt; rescale(image, 0.1).shape
(51, 51)
&gt;&gt;&gt; rescale(image, 0.5).shape
(256, 256)
</pre> </dd>
</dl>   <h2 id="resize">resize</h2> <dl class="function"> <dt id="skimage.transform.resize">
<code>skimage.transform.resize(image, output_shape, order=None, mode='reflect', cval=0, clip=True, preserve_range=False, anti_aliasing=None, anti_aliasing_sigma=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L19-L198"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Resize image to match a certain size.</p> <p>Performs interpolation to up-size or down-size N-dimensional images. Note that anti-aliasing should be enabled when down-sizing images to avoid aliasing artifacts. For down-sampling with an integer factor also see <a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code>skimage.transform.downscale_local_mean</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>output_shapetuple or ndarray</code> </dt>
<dd>
<p>Size of the generated output image <code>(rows, cols[, …][, dim])</code>. If <code>dim</code> is not provided, the number of channels is preserved. In case the number of input channels does not equal the number of output channels a n-dimensional interpolation is applied.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>resizedndarray</code> </dt>
<dd>
<p>Resized version of the input.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>The order of the spline interpolation, default is 0 if image.dtype is bool and 1 otherwise. The order has to be in the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a> for detail.</p> </dd> <dt>
<code>mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</code> </dt>
<dd>
<p>Points outside the boundaries of the input are filled according to the given mode. Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.19)"><code>numpy.pad</code></a>.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p> </dd> <dt>
<code>clipbool, optional</code> </dt>
<dd>
<p>Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> <dt>
<code>anti_aliasingbool, optional</code> </dt>
<dd>
<p>Whether to apply a Gaussian filter to smooth the image prior to down-scaling. It is crucial to filter when down-sampling the image to avoid aliasing artifacts. If input image data type is bool, no anti-aliasing is applied.</p> </dd> <dt>
<code>anti_aliasing_sigma{float, tuple of floats}, optional</code> </dt>
<dd>
<p>Standard deviation for Gaussian filtering to avoid aliasing artifacts. By default, this value is chosen as (s - 1) / 2 where s is the down-scaling factor, where s &gt; 1. For the up-size case, s &lt; 1, no anti-aliasing is performed prior to rescaling.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge pixels are duplicated during the reflection. As an example, if an array has values [0, 1, 2] and was padded to the right by four values using symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it would be [0, 1, 2, 1, 0, 1, 2].</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.transform import resize
&gt;&gt;&gt; image = data.camera()
&gt;&gt;&gt; resize(image, (100, 100)).shape
(100, 100)
</pre> </dd>
</dl>   <h2 id="rotate">rotate</h2> <dl class="function"> <dt id="skimage.transform.rotate">
<code>skimage.transform.rotate(image, angle, resize=False, center=None, order=None, mode='constant', cval=0, clip=True, preserve_range=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L296-L404"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Rotate image by a certain angle around its center.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>anglefloat</code> </dt>
<dd>
<p>Rotation angle in degrees in counter-clockwise direction.</p> </dd> <dt>
<code>resizebool, optional</code> </dt>
<dd>
<p>Determine whether the shape of the output image will be automatically calculated, so the complete rotated image exactly fits. Default is False.</p> </dd> <dt>
<code>centeriterable of length 2</code> </dt>
<dd>
<p>The rotation center. If <code>center=None</code>, the image is rotated around its center, i.e. <code>center=(cols / 2 - 0.5, rows / 2 - 0.5)</code>. Please note that this parameter is (cols, rows), contrary to normal skimage ordering.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rotatedndarray</code> </dt>
<dd>
<p>Rotated version of the input.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>The order of the spline interpolation, default is 0 if image.dtype is bool and 1 otherwise. The order has to be in the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a> for detail.</p> </dd> <dt>
<code>mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</code> </dt>
<dd>
<p>Points outside the boundaries of the input are filled according to the given mode. Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.19)"><code>numpy.pad</code></a>.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p> </dd> <dt>
<code>clipbool, optional</code> </dt>
<dd>
<p>Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge pixels are duplicated during the reflection. As an example, if an array has values [0, 1, 2] and was padded to the right by four values using symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it would be [0, 1, 2, 1, 0, 1, 2].</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.transform import rotate
&gt;&gt;&gt; image = data.camera()
&gt;&gt;&gt; rotate(image, 2).shape
(512, 512)
&gt;&gt;&gt; rotate(image, 2, resize=True).shape
(530, 530)
&gt;&gt;&gt; rotate(image, 90, resize=True).shape
(512, 512)
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-transform-rotate">Examples using <code>skimage.transform.rotate</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="In this example we show the uncertainty on calculating perimeters, comparing classic and Crofto...">
<div class="figure align-default" id="id25"> <img alt="Different perimeters" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_perimeters.html#sphx-glr-auto-examples-segmentation-plot-perimeters-py"><span class="std std-ref">Different perimeters</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima...">
<div class="figure align-default" id="id26"> <img alt="Measure region properties" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span></p> </div> </div>   <h2 id="swirl">swirl</h2> <dl class="function"> <dt id="skimage.transform.swirl">
<code>skimage.transform.swirl(image, center=None, strength=1, radius=100, rotation=0, output_shape=None, order=None, mode='reflect', cval=0, clip=True, preserve_range=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L473-L534"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform a swirl transformation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>center(column, row) tuple or (2,) ndarray, optional</code> </dt>
<dd>
<p>Center coordinate of transformation.</p> </dd> <dt>
<code>strengthfloat, optional</code> </dt>
<dd>
<p>The amount of swirling applied.</p> </dd> <dt>
<code>radiusfloat, optional</code> </dt>
<dd>
<p>The extent of the swirl in pixels. The effect dies out rapidly beyond <code>radius</code>.</p> </dd> <dt>
<code>rotationfloat, optional</code> </dt>
<dd>
<p>Additional rotation applied to the image.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>swirledndarray</code> </dt>
<dd>
<p>Swirled version of the input.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>output_shapetuple (rows, cols), optional</code> </dt>
<dd>
<p>Shape of the output image generated. By default the shape of the input image is preserved.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>The order of the spline interpolation, default is 0 if image.dtype is bool and 1 otherwise. The order has to be in the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a> for detail.</p> </dd> <dt>
<code>mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</code> </dt>
<dd>
<p>Points outside the boundaries of the input are filled according to the given mode, with ‘constant’ used as the default. Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.19)"><code>numpy.pad</code></a>.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p> </dd> <dt>
<code>clipbool, optional</code> </dt>
<dd>
<p>Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="warp">warp</h2> <dl class="function"> <dt id="skimage.transform.warp">
<code>skimage.transform.warp(image, inverse_map, map_args={}, output_shape=None, order=None, mode='constant', cval=0.0, clip=True, preserve_range=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L684-L932"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Warp an image according to a given coordinate transformation.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>inverse_maptransformation object, callable cr = f(cr, **kwargs), or ndarray</code> </dt>
<dd>
<p>Inverse coordinate map, which transforms coordinates in the output images into their corresponding coordinates in the input image.</p> <p>There are a number of different options to define this map, depending on the dimensionality of the input image. A 2-D image can have 2 dimensions for gray-scale images, or 3 dimensions with color information.</p>  <ul class="simple"> <li>For 2-D images, you can directly pass a transformation object, e.g. <a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code>skimage.transform.SimilarityTransform</code></a>, or its inverse.</li> <li>For 2-D images, you can pass a <code>(3, 3)</code> homogeneous transformation matrix, e.g. <code>skimage.transform.SimilarityTransform.params</code>.</li> <li>For 2-D images, a function that transforms a <code>(M, 2)</code> array of <code>(col, row)</code> coordinates in the output image to their corresponding coordinates in the input image. Extra parameters to the function can be specified through <code>map_args</code>.</li> <li>For N-D images, you can directly pass an array of coordinates. The first dimension specifies the coordinates in the input image, while the subsequent dimensions determine the position in the output image. E.g. in case of 2-D images, you need to pass an array of shape <code>(2, rows, cols)</code>, where <code>rows</code> and <code>cols</code> determine the shape of the output image, and the first dimension contains the <code>(row, col)</code> coordinate in the input image. See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates" title="(in SciPy v1.5.4)"><code>scipy.ndimage.map_coordinates</code></a> for further documentation.</li> </ul>  <p>Note, that a <code>(3, 3)</code> matrix is interpreted as a homogeneous transformation matrix, so you cannot interpolate values from a 3-D input, if the output is of shape <code>(3,)</code>.</p> <p>See example section for usage.</p> </dd> <dt>
<code>map_argsdict, optional</code> </dt>
<dd>
<p>Keyword arguments passed to <code>inverse_map</code>.</p> </dd> <dt>
<code>output_shapetuple (rows, cols), optional</code> </dt>
<dd>
<p>Shape of the output image generated. By default the shape of the input image is preserved. Note that, even for multi-band images, only rows and columns need to be specified.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<dl> <dt>The order of interpolation. The order has to be in the range 0-5:</dt>
<dd>
<ul class="simple"> <li>0: Nearest-neighbor</li> <li>1: Bi-linear (default)</li> <li>2: Bi-quadratic</li> <li>3: Bi-cubic</li> <li>4: Bi-quartic</li> <li>5: Bi-quintic</li> </ul> <p>Default is 0 if image.dtype is bool and 1 otherwise.</p> </dd> </dl> </dd> <dt>
<code>mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</code> </dt>
<dd>
<p>Points outside the boundaries of the input are filled according to the given mode. Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.19)"><code>numpy.pad</code></a>.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p> </dd> <dt>
<code>clipbool, optional</code> </dt>
<dd>
<p>Whether to clip the output to the range of values of the input image. This is enabled by default, since higher order interpolation may produce values outside the given input range.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>warpeddouble ndarray</code> </dt>
<dd>
<p>The warped input image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <ul class="simple"> <li>The input image is converted to a <code>double</code> image.</li> <li>In case of a <a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code>SimilarityTransform</code></a>, <a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code>AffineTransform</code></a> and <a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code>ProjectiveTransform</code></a> and <code>order</code> in [0, 3] this function uses the underlying transformation matrix to warp the image with a much faster routine.</li> </ul> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import warp
&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; image = data.camera()
</pre> <p>The following image warps are all equal but differ substantially in execution time. The image is shifted to the bottom.</p> <p>Use a geometric transform to warp an image (fast):</p> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import SimilarityTransform
&gt;&gt;&gt; tform = SimilarityTransform(translation=(0, -10))
&gt;&gt;&gt; warped = warp(image, tform)
</pre> <p>Use a callable (slow):</p> <pre data-language="python">&gt;&gt;&gt; def shift_down(xy):
...     xy[:, 1] -= 10
...     return xy
&gt;&gt;&gt; warped = warp(image, shift_down)
</pre> <p>Use a transformation matrix to warp an image (fast):</p> <pre data-language="python">&gt;&gt;&gt; matrix = np.array([[1, 0, 0], [0, 1, -10], [0, 0, 1]])
&gt;&gt;&gt; warped = warp(image, matrix)
&gt;&gt;&gt; from skimage.transform import ProjectiveTransform
&gt;&gt;&gt; warped = warp(image, ProjectiveTransform(matrix=matrix))
</pre> <p>You can also use the inverse of a geometric transformation (fast):</p> <pre data-language="python">&gt;&gt;&gt; warped = warp(image, tform.inverse)
</pre> <p>For N-D images you can pass a coordinate array, that specifies the coordinates in the input image for every element in the output image. E.g. if you want to rescale a 3-D cube, you can do:</p> <pre data-language="python">&gt;&gt;&gt; cube_shape = np.array([30, 30, 30])
&gt;&gt;&gt; cube = np.random.rand(*cube_shape)
</pre> <p>Setup the coordinate array, that defines the scaling:</p> <pre data-language="python">&gt;&gt;&gt; scale = 0.1
&gt;&gt;&gt; output_shape = (scale * cube_shape).astype(int)
&gt;&gt;&gt; coords0, coords1, coords2 = np.mgrid[:output_shape[0],
...                    :output_shape[1], :output_shape[2]]
&gt;&gt;&gt; coords = np.array([coords0, coords1, coords2])
</pre> <p>Assume that the cube contains spatial data, where the first array element center is at coordinate (0.5, 0.5, 0.5) in real space, i.e. we have to account for this extra offset when scaling the image:</p> <pre data-language="python">&gt;&gt;&gt; coords = (coords + 0.5) / scale - 0.5
&gt;&gt;&gt; warped = warp(cube, coords)
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-transform-warp">Examples using <code>skimage.transform.warp</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="Demonstration of image registration using optical flow.">
<div class="figure align-default" id="id27"> <img alt="Registration using optical flow" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/registration/plot_opticalflow.html#sphx-glr-auto-examples-registration-plot-opticalflow-py"><span class="std std-ref">Registration using optical flow</span></a></span></p> </div> </div>   <h2 id="warp-coords">warp_coords</h2> <dl class="function"> <dt id="skimage.transform.warp_coords">
<code>skimage.transform.warp_coords(coord_map, shape, dtype=&lt;class 'numpy.float64'&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L560-L635"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Build the source coordinates for the output of a 2-D image warp.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>coord_mapcallable like GeometricTransform.inverse</code> </dt>
<dd>
<p>Return input coordinates for given output coordinates. Coordinates are in the shape (P, 2), where P is the number of coordinates and each element is a <code>(row, col)</code> pair.</p> </dd> <dt>
<code>shapetuple</code> </dt>
<dd>
<p>Shape of output image <code>(rows, cols[, bands])</code>.</p> </dd> <dt>
<code>dtypenp.dtype or string</code> </dt>
<dd>
<p>dtype for return value (sane choices: float32 or float64).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>coords(ndim, rows, cols[, bands]) array of dtype dtype</code> </dt>
<dd>
<p>Coordinates for <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates" title="(in SciPy v1.5.4)"><code>scipy.ndimage.map_coordinates</code></a>, that will yield an image of shape (orows, ocols, bands) by drawing from source points according to the <code>coord_transform_fn</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This is a lower-level routine that produces the source coordinates for 2-D images used by <code>warp()</code>.</p> <p>It is provided separately from <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>warp</code></a> to give additional flexibility to users who would like, for example, to re-use a particular coordinate mapping, to use specific dtypes at various points along the the image-warping process, or to implement different post-processing logic than <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code>warp</code></a> performs after the call to <code>ndi.map_coordinates</code>.</p> <h4 class="rubric">Examples</h4> <p>Produce a coordinate map that shifts an image up and to the right:</p> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from scipy.ndimage import map_coordinates
&gt;&gt;&gt;
&gt;&gt;&gt; def shift_up10_left20(xy):
...     return xy - np.array([-20, 10])[None, :]
&gt;&gt;&gt;
&gt;&gt;&gt; image = data.astronaut().astype(np.float32)
&gt;&gt;&gt; coords = warp_coords(shift_up10_left20, image.shape)
&gt;&gt;&gt; warped_image = map_coordinates(image, coords)
</pre> </dd>
</dl>   <h2 id="warp-polar">warp_polar</h2> <dl class="function"> <dt id="skimage.transform.warp_polar">
<code>skimage.transform.warp_polar(image, center=None, *, radius=None, output_shape=None, scaling='linear', multichannel=False, **kwargs)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L997-L1095"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Remap image to polar or log-polar coordinates space.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image. Only 2-D arrays are accepted by default. If <code>multichannel=True</code>, 3-D arrays are accepted and the last axis is interpreted as multiple channels.</p> </dd> <dt>
<code>centertuple (row, col), optional</code> </dt>
<dd>
<p>Point in image that represents the center of the transformation (i.e., the origin in cartesian space). Values can be of type <code>float</code>. If no value is given, the center is assumed to be the center point of the image.</p> </dd> <dt>
<code>radiusfloat, optional</code> </dt>
<dd>
<p>Radius of the circle that bounds the area to be transformed.</p> </dd> <dt>
<code>output_shapetuple (row, col), optional</code> </dt>
 <dt>
<code>scaling{‘linear’, ‘log’}, optional</code> </dt>
<dd>
<p>Specify whether the image warp is polar or log-polar. Defaults to ‘linear’.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Whether the image is a 3-D array in which the third axis is to be interpreted as multiple channels. If set to <code>False</code> (default), only 2-D arrays are accepted.</p> </dd> <dt>
<code>**kwargskeyword arguments</code> </dt>
<dd>
<p>Passed to <code>transform.warp</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>warpedndarray</code> </dt>
<dd>
<p>The polar or log-polar warped image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <p>Perform a basic polar warp on a grayscale image:</p> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.transform import warp_polar
&gt;&gt;&gt; image = data.checkerboard()
&gt;&gt;&gt; warped = warp_polar(image)
</pre> <p>Perform a log-polar warp on a grayscale image:</p> <pre data-language="python">&gt;&gt;&gt; warped = warp_polar(image, scaling='log')
</pre> <p>Perform a log-polar warp on a grayscale image while specifying center, radius, and output shape:</p> <pre data-language="python">&gt;&gt;&gt; warped = warp_polar(image, (100,100), radius=100,
...                     output_shape=image.shape, scaling='log')
</pre> <p>Perform a log-polar warp on a color image:</p> <pre data-language="python">&gt;&gt;&gt; image = data.astronaut()
&gt;&gt;&gt; warped = warp_polar(image, scaling='log', multichannel=True)
</pre> </dd>
</dl>   <h2 id="affinetransform">AffineTransform</h2> <dl class="class"> <dt id="skimage.transform.AffineTransform">
<code>class skimage.transform.AffineTransform(matrix=None, scale=None, rotation=None, shear=None, translation=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L746-L844"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.ProjectiveTransform</code></p> <p>2D affine transformation.</p> <p>Has the following form:</p> <pre data-language="python">X = a0*x + a1*y + a2 =
  = sx*x*cos(rotation) - sy*y*sin(rotation + shear) + a2

Y = b0*x + b1*y + b2 =
  = sx*x*sin(rotation) + sy*y*cos(rotation + shear) + b2
</pre> <p>where <code>sx</code> and <code>sy</code> are scale factors in the x and y directions, and the homogeneous transformation matrix is:</p> <pre data-language="python">[[a0  a1  a2]
 [b0  b1  b2]
 [0   0    1]]
</pre> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>matrix(3, 3) array, optional</code> </dt>
<dd>
<p>Homogeneous transformation matrix.</p> </dd> <dt>
<code>scale{s as float or (sx, sy) as array, list or tuple}, optional</code> </dt>
<dd>
<p>Scale factor(s). If a single value, it will be assigned to both sx and sy.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.17: </span>Added support for supplying a single scalar value.</p> </div> </dd> <dt>
<code>rotationfloat, optional</code> </dt>
<dd>
<p>Rotation angle in counter-clockwise direction as radians.</p> </dd> <dt>
<code>shearfloat, optional</code> </dt>
<dd>
<p>Shear angle in counter-clockwise direction as radians.</p> </dd> <dt>
<code>translation(tx, ty) as array, list or tuple, optional</code> </dt>
<dd>
<p>Translation parameters.</p> </dd> </dl> </dd> <dt class="field-even">Attributes</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>params(3, 3) array</code> </dt>
<dd>
<p>Homogeneous transformation matrix.</p> </dd> </dl> </dd> </dl> <dl class="method"> <dt id="skimage.transform.AffineTransform.__init__">
<code>__init__(matrix=None, scale=None, rotation=None, shear=None, translation=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L790-L825"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize self. See help(type(self)) for accurate signature.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.AffineTransform.rotation">
<code>property rotation</code> </dt> 
</dl> <dl class="method"> <dt id="skimage.transform.AffineTransform.scale">
<code>property scale</code> </dt> 
</dl> <dl class="method"> <dt id="skimage.transform.AffineTransform.shear">
<code>property shear</code> </dt> 
</dl> <dl class="method"> <dt id="skimage.transform.AffineTransform.translation">
<code>property translation</code> </dt> 
</dl> </dd>
</dl>   <h2 id="essentialmatrixtransform">EssentialMatrixTransform</h2> <dl class="class"> <dt id="skimage.transform.EssentialMatrixTransform">
<code>class skimage.transform.EssentialMatrixTransform(rotation=None, translation=None, matrix=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L399-L494"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.FundamentalMatrixTransform</code></p> <p>Essential matrix transformation.</p> <p>The essential matrix relates corresponding points between a pair of calibrated images. The matrix transforms normalized, homogeneous image points in one image to epipolar lines in the other image.</p> <p>The essential matrix is only defined for a pair of moving images capturing a non-planar scene. In the case of pure rotation or planar scenes, the homography describes the geometric relation between two images (<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code>ProjectiveTransform</code></a>). If the intrinsic calibration of the images is unknown, the fundamental matrix describes the projective relation between the two images (<a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code>FundamentalMatrixTransform</code></a>).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>rotation(3, 3) array, optional</code> </dt>
<dd>
<p>Rotation matrix of the relative camera motion.</p> </dd> <dt>
<code>translation(3, 1) array, optional</code> </dt>
<dd>
<p>Translation vector of the relative camera motion. The vector must have unit length.</p> </dd> <dt>
<code>matrix(3, 3) array, optional</code> </dt>
<dd>
<p>Essential matrix.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r2fbde33858f1-1">
<code>1</code> </dt> <dd>
<p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in computer vision. Cambridge university press, 2003.</p> </dd> </dl> <dl class="field-list simple"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>params(3, 3) array</code> </dt>
<dd>
<p>Essential matrix.</p> </dd> </dl> </dd> </dl> <dl class="method"> <dt id="skimage.transform.EssentialMatrixTransform.__init__">
<code>__init__(rotation=None, translation=None, matrix=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L435-L458"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize self. See help(type(self)) for accurate signature.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.EssentialMatrixTransform.estimate">
<code>estimate(src, dst)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L460-L494"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate essential matrix using 8-point algorithm.</p> <p>The 8-point algorithm requires at least 8 corresponding point pairs for a well-conditioned solution, otherwise the over-determined solution is estimated.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>src(N, 2) array</code> </dt>
<dd>
<p>Source coordinates.</p> </dd> <dt>
<code>dst(N, 2) array</code> </dt>
<dd>
<p>Destination coordinates.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>successbool</code> </dt>
<dd>
<p>True, if model estimation succeeds.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="euclideantransform">EuclideanTransform</h2> <dl class="class"> <dt id="skimage.transform.EuclideanTransform">
<code>class skimage.transform.EuclideanTransform(matrix=None, rotation=None, translation=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L981-L1077"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.ProjectiveTransform</code></p> <p>2D Euclidean transformation.</p> <p>Has the following form:</p> <pre data-language="python">X = a0 * x - b0 * y + a1 =
  = x * cos(rotation) - y * sin(rotation) + a1

Y = b0 * x + a0 * y + b1 =
  = x * sin(rotation) + y * cos(rotation) + b1
</pre> <p>where the homogeneous transformation matrix is:</p> <pre data-language="python">[[a0  b0  a1]
 [b0  a0  b1]
 [0   0    1]]
</pre> <p>The Euclidean transformation is a rigid transformation with rotation and translation parameters. The similarity transformation extends the Euclidean transformation with a single scaling factor.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>matrix(3, 3) array, optional</code> </dt>
<dd>
<p>Homogeneous transformation matrix.</p> </dd> <dt>
<code>rotationfloat, optional</code> </dt>
<dd>
<p>Rotation angle in counter-clockwise direction as radians.</p> </dd> <dt>
<code>translation(tx, ty) as array, list or tuple, optional</code> </dt>
<dd>
<p>x, y translation parameters.</p> </dd> </dl> </dd> <dt class="field-even">Attributes</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>params(3, 3) array</code> </dt>
<dd>
<p>Homogeneous transformation matrix.</p> </dd> </dl> </dd> </dl> <dl class="method"> <dt id="skimage.transform.EuclideanTransform.__init__">
<code>__init__(matrix=None, rotation=None, translation=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1018-L1043"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize self. See help(type(self)) for accurate signature.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.EuclideanTransform.estimate">
<code>estimate(src, dst)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1045-L1069"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate the transformation from a set of corresponding points.</p> <p>You can determine the over-, well- and under-determined parameters with the total least-squares method.</p> <p>Number of source and destination coordinates must match.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>src(N, 2) array</code> </dt>
<dd>
<p>Source coordinates.</p> </dd> <dt>
<code>dst(N, 2) array</code> </dt>
<dd>
<p>Destination coordinates.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>successbool</code> </dt>
<dd>
<p>True, if model estimation succeeds.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.EuclideanTransform.rotation">
<code>property rotation</code> </dt> 
</dl> <dl class="method"> <dt id="skimage.transform.EuclideanTransform.translation">
<code>property translation</code> </dt> 
</dl> </dd>
</dl>   <h2 id="fundamentalmatrixtransform">FundamentalMatrixTransform</h2> <dl class="class"> <dt id="skimage.transform.FundamentalMatrixTransform">
<code>class skimage.transform.FundamentalMatrixTransform(matrix=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L211-L396"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.GeometricTransform</code></p> <p>Fundamental matrix transformation.</p> <p>The fundamental matrix relates corresponding points between a pair of uncalibrated images. The matrix transforms homogeneous image points in one image to epipolar lines in the other image.</p> <p>The fundamental matrix is only defined for a pair of moving images. In the case of pure rotation or planar scenes, the homography describes the geometric relation between two images (<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code>ProjectiveTransform</code></a>). If the intrinsic calibration of the images is known, the essential matrix describes the metric relation between the two images (<a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code>EssentialMatrixTransform</code></a>).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>matrix(3, 3) array, optional</code> </dt>
<dd>
<p>Fundamental matrix.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r725e3a484348-1">
<code>1</code> </dt> <dd>
<p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in computer vision. Cambridge university press, 2003.</p> </dd> </dl> <dl class="field-list simple"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>params(3, 3) array</code> </dt>
<dd>
<p>Fundamental matrix.</p> </dd> </dl> </dd> </dl> <dl class="method"> <dt id="skimage.transform.FundamentalMatrixTransform.__init__">
<code>__init__(matrix=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L241-L247"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize self. See help(type(self)) for accurate signature.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.FundamentalMatrixTransform.estimate">
<code>estimate(src, dst)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L335-L367"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate fundamental matrix using 8-point algorithm.</p> <p>The 8-point algorithm requires at least 8 corresponding point pairs for a well-conditioned solution, otherwise the over-determined solution is estimated.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>src(N, 2) array</code> </dt>
<dd>
<p>Source coordinates.</p> </dd> <dt>
<code>dst(N, 2) array</code> </dt>
<dd>
<p>Destination coordinates.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>successbool</code> </dt>
<dd>
<p>True, if model estimation succeeds.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.FundamentalMatrixTransform.inverse">
<code>inverse(coords)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L266-L281"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply inverse transformation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>coords(N, 2) array</code> </dt>
<dd>
<p>Destination coordinates.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>coords(N, 3) array</code> </dt>
<dd>
<p>Epipolar lines in the source image.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.FundamentalMatrixTransform.residuals">
<code>residuals(src, dst)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L369-L396"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the Sampson distance.</p> <p>The Sampson distance is the first approximation to the geometric error.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>src(N, 2) array</code> </dt>
<dd>
<p>Source coordinates.</p> </dd> <dt>
<code>dst(N, 2) array</code> </dt>
<dd>
<p>Destination coordinates.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>residuals(N, ) array</code> </dt>
<dd>
<p>Sampson distance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="piecewiseaffinetransform">PiecewiseAffineTransform</h2> <dl class="class"> <dt id="skimage.transform.PiecewiseAffineTransform">
<code>class skimage.transform.PiecewiseAffineTransform</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L847-L978"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.GeometricTransform</code></p> <p>2D piecewise affine transformation.</p> <p>Control points are used to define the mapping. The transform is based on a Delaunay triangulation of the points to form a mesh. Each triangle is used to find a local affine transform.</p> <dl class="field-list simple"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>affineslist of AffineTransform objects</code> </dt>
<dd>
<p>Affine transformations for each triangle in the mesh.</p> </dd> <dt>
<code>inverse_affineslist of AffineTransform objects</code> </dt>
<dd>
<p>Inverse affine transformations for each triangle in the mesh.</p> </dd> </dl> </dd> </dl> <dl class="method"> <dt id="skimage.transform.PiecewiseAffineTransform.__init__">
<code>__init__()</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L863-L867"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize self. See help(type(self)) for accurate signature.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.PiecewiseAffineTransform.estimate">
<code>estimate(src, dst)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L869-L908"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate the transformation from a set of corresponding points.</p> <p>Number of source and destination coordinates must match.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>src(N, 2) array</code> </dt>
<dd>
<p>Source coordinates.</p> </dd> <dt>
<code>dst(N, 2) array</code> </dt>
<dd>
<p>Destination coordinates.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>successbool</code> </dt>
<dd>
<p>True, if model estimation succeeds.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.PiecewiseAffineTransform.inverse">
<code>inverse(coords)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L945-L978"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply inverse transformation.</p> <p>Coordinates outside of the mesh will be set to <code>- 1</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>coords(N, 2) array</code> </dt>
<dd>
<p>Source coordinates.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>coords(N, 2) array</code> </dt>
<dd>
<p>Transformed coordinates.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="polynomialtransform">PolynomialTransform</h2> <dl class="class"> <dt id="skimage.transform.PolynomialTransform">
<code>class skimage.transform.PolynomialTransform(params=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1182-L1327"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.GeometricTransform</code></p> <p>2D polynomial transformation.</p> <p>Has the following form:</p> <pre data-language="python">X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i ))
Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i ))
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>params(2, N) array, optional</code> </dt>
<dd>
<p>Polynomial coefficients where <code>N * 2 = (order + 1) * (order + 2)</code>. So, a_ji is defined in <code>params[0, :]</code> and b_ji in <code>params[1, :]</code>.</p> </dd> </dl> </dd> <dt class="field-even">Attributes</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>params(2, N) array</code> </dt>
<dd>
<p>Polynomial coefficients where <code>N * 2 = (order + 1) * (order + 2)</code>. So, a_ji is defined in <code>params[0, :]</code> and b_ji in <code>params[1, :]</code>.</p> </dd> </dl> </dd> </dl> <dl class="method"> <dt id="skimage.transform.PolynomialTransform.__init__">
<code>__init__(params=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1204-L1210"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize self. See help(type(self)) for accurate signature.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.PolynomialTransform.estimate">
<code>estimate(src, dst, order=2)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1212-L1290"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate the transformation from a set of corresponding points.</p> <p>You can determine the over-, well- and under-determined parameters with the total least-squares method.</p> <p>Number of source and destination coordinates must match.</p> <p>The transformation is defined as:</p> <pre data-language="python">X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i ))
Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i ))
</pre> <p>These equations can be transformed to the following form:</p> <pre data-language="python">0 = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i )) - X
0 = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i )) - Y
</pre> <p>which exist for each set of corresponding points, so we have a set of N * 2 equations. The coefficients appear linearly so we can write A x = 0, where:</p> <pre data-language="python">A   = [[1 x y x**2 x*y y**2 ... 0 ...             0 -X]
       [0 ...                 0 1 x y x**2 x*y y**2 -Y]
        ...
        ...
      ]
x.T = [a00 a10 a11 a20 a21 a22 ... ann
       b00 b10 b11 b20 b21 b22 ... bnn c3]
</pre> <p>In case of total least-squares the solution of this homogeneous system of equations is the right singular vector of A which corresponds to the smallest singular value normed by the coefficient c3.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>src(N, 2) array</code> </dt>
<dd>
<p>Source coordinates.</p> </dd> <dt>
<code>dst(N, 2) array</code> </dt>
<dd>
<p>Destination coordinates.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>Polynomial order (number of coefficients is order + 1).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>successbool</code> </dt>
<dd>
<p>True, if model estimation succeeds.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.PolynomialTransform.inverse">
<code>inverse(coords)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1322-L1327"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply inverse transformation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>coords(N, 2) array</code> </dt>
<dd>
<p>Destination coordinates.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>coords(N, 2) array</code> </dt>
<dd>
<p>Source coordinates.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="projectivetransform">ProjectiveTransform</h2> <dl class="class"> <dt id="skimage.transform.ProjectiveTransform">
<code>class skimage.transform.ProjectiveTransform(matrix=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L497-L743"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.GeometricTransform</code></p> <p>Projective transformation.</p> <p>Apply a projective transformation (homography) on coordinates.</p> <p>For each homogeneous coordinate <span class="math notranslate nohighlight">\(\mathbf{x} = [x, y, 1]^T\)</span>, its target position is calculated by multiplying with the given matrix, <span class="math notranslate nohighlight">\(H\)</span>, to give <span class="math notranslate nohighlight">\(H \mathbf{x}\)</span>:</p> <pre data-language="python">[[a0 a1 a2]
 [b0 b1 b2]
 [c0 c1 1 ]].
</pre> <p>E.g., to rotate by theta degrees clockwise, the matrix should be:</p> <pre data-language="python">[[cos(theta) -sin(theta) 0]
 [sin(theta)  cos(theta) 0]
 [0            0         1]]
</pre> <p>or, to translate x by 10 and y by 20:</p> <pre data-language="python">[[1 0 10]
 [0 1 20]
 [0 0 1 ]].
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>matrix(3, 3) array, optional</code> </dt>
<dd>
<p>Homogeneous transformation matrix.</p> </dd> </dl> </dd> <dt class="field-even">Attributes</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>params(3, 3) array</code> </dt>
<dd>
<p>Homogeneous transformation matrix.</p> </dd> </dl> </dd> </dl> <dl class="method"> <dt id="skimage.transform.ProjectiveTransform.__init__">
<code>__init__(matrix=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L536-L542"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize self. See help(type(self)) for accurate signature.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.ProjectiveTransform.estimate">
<code>estimate(src, dst)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L596-L703"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate the transformation from a set of corresponding points.</p> <p>You can determine the over-, well- and under-determined parameters with the total least-squares method.</p> <p>Number of source and destination coordinates must match.</p> <p>The transformation is defined as:</p> <pre data-language="python">X = (a0*x + a1*y + a2) / (c0*x + c1*y + 1)
Y = (b0*x + b1*y + b2) / (c0*x + c1*y + 1)
</pre> <p>These equations can be transformed to the following form:</p> <pre data-language="python">0 = a0*x + a1*y + a2 - c0*x*X - c1*y*X - X
0 = b0*x + b1*y + b2 - c0*x*Y - c1*y*Y - Y
</pre> <p>which exist for each set of corresponding points, so we have a set of N * 2 equations. The coefficients appear linearly so we can write A x = 0, where:</p> <pre data-language="python">A   = [[x y 1 0 0 0 -x*X -y*X -X]
       [0 0 0 x y 1 -x*Y -y*Y -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c0 c1 c3]
</pre> <p>In case of total least-squares the solution of this homogeneous system of equations is the right singular vector of A which corresponds to the smallest singular value normed by the coefficient c3.</p> <p>In case of the affine transformation the coefficients c0 and c1 are 0. Thus the system of equations is:</p> <pre data-language="python">A   = [[x y 1 0 0 0 -X]
       [0 0 0 x y 1 -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c3]
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>src(N, 2) array</code> </dt>
<dd>
<p>Source coordinates.</p> </dd> <dt>
<code>dst(N, 2) array</code> </dt>
<dd>
<p>Destination coordinates.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>successbool</code> </dt>
<dd>
<p>True, if model estimation succeeds.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.ProjectiveTransform.inverse">
<code>inverse(coords)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L580-L594"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply inverse transformation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>coords(N, 2) array</code> </dt>
<dd>
<p>Destination coordinates.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>coords(N, 2) array</code> </dt>
<dd>
<p>Source coordinates.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="similaritytransform">SimilarityTransform</h2> <dl class="class"> <dt id="skimage.transform.SimilarityTransform">
<code>class skimage.transform.SimilarityTransform(matrix=None, scale=None, rotation=None, translation=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1080-L1179"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.transform._geometric.EuclideanTransform</code></p> <p>2D similarity transformation.</p> <p>Has the following form:</p> <pre data-language="python">X = a0 * x - b0 * y + a1 =
  = s * x * cos(rotation) - s * y * sin(rotation) + a1

Y = b0 * x + a0 * y + b1 =
  = s * x * sin(rotation) + s * y * cos(rotation) + b1
</pre> <p>where <code>s</code> is a scale factor and the homogeneous transformation matrix is:</p> <pre data-language="python">[[a0  b0  a1]
 [b0  a0  b1]
 [0   0    1]]
</pre> <p>The similarity transformation extends the Euclidean transformation with a single scaling factor in addition to the rotation and translation parameters.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>matrix(3, 3) array, optional</code> </dt>
<dd>
<p>Homogeneous transformation matrix.</p> </dd> <dt>
<code>scalefloat, optional</code> </dt>
<dd>
<p>Scale factor.</p> </dd> <dt>
<code>rotationfloat, optional</code> </dt>
<dd>
<p>Rotation angle in counter-clockwise direction as radians.</p> </dd> <dt>
<code>translation(tx, ty) as array, list or tuple, optional</code> </dt>
<dd>
<p>x, y translation parameters.</p> </dd> </dl> </dd> <dt class="field-even">Attributes</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>params(3, 3) array</code> </dt>
<dd>
<p>Homogeneous transformation matrix.</p> </dd> </dl> </dd> </dl> <dl class="method"> <dt id="skimage.transform.SimilarityTransform.__init__">
<code>__init__(matrix=None, scale=None, rotation=None, translation=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1119-L1148"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize self. See help(type(self)) for accurate signature.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.SimilarityTransform.estimate">
<code>estimate(src, dst)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1150-L1174"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate the transformation from a set of corresponding points.</p> <p>You can determine the over-, well- and under-determined parameters with the total least-squares method.</p> <p>Number of source and destination coordinates must match.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>src(N, 2) array</code> </dt>
<dd>
<p>Source coordinates.</p> </dd> <dt>
<code>dst(N, 2) array</code> </dt>
<dd>
<p>Destination coordinates.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>successbool</code> </dt>
<dd>
<p>True, if model estimation succeeds.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.transform.SimilarityTransform.scale">
<code>property scale</code> </dt> 
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://scikit-image.org/docs/0.18.x/api/skimage.transform.html" class="_attribution-link">https://scikit-image.org/docs/0.18.x/api/skimage.transform.html</a>
  </p>
</div>
