<section id="image-adjustment-transforming-image-content"> <h1>9. Image adjustment: transforming image content</h1> <section id="color-manipulation"> <h2>
<span class="section-number">9.1. </span>Color manipulation</h2> <p>Most functions for manipulating color channels are found in the submodule <a class="reference internal" href="../api/skimage.color.html#module-skimage.color" title="skimage.color"><code>skimage.color</code></a>.</p> <section id="conversion-between-color-models"> <h3>
<span class="section-number">9.1.1. </span>Conversion between color models</h3> <p>Color images can be represented using different <a class="reference external" href="https://en.wikipedia.org/wiki/Color_space">color spaces</a>. One of the most common color spaces is the <a class="reference external" href="https://en.wikipedia.org/wiki/RGB_color_model">RGB space</a>, where an image has red, green and blue channels. However, other color models are widely used, such as the <a class="reference external" href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSV color model</a>, where hue, saturation and value are independent channels, or the <a class="reference external" href="https://en.wikipedia.org/wiki/CMYK_color_model">CMYK model</a> used for printing.</p> <p><a class="reference internal" href="../api/skimage.color.html#module-skimage.color" title="skimage.color"><code>skimage.color</code></a> provides utility functions to convert images to and from different color spaces. Integer-type arrays can be transformed to floating-point type by the conversion operation:</p> <pre data-language="python">&gt;&gt;&gt; # bright saturated red
&gt;&gt;&gt; red_pixel_rgb = np.array([[[255, 0, 0]]], dtype=np.uint8)
&gt;&gt;&gt; color.rgb2hsv(red_pixel_rgb)
array([[[ 0.,  1.,  1.]]])
&gt;&gt;&gt; #Â darker saturated blue
&gt;&gt;&gt; dark_blue_pixel_rgb = np.array([[[0, 0, 100]]], dtype=np.uint8)
&gt;&gt;&gt; color.rgb2hsv(dark_blue_pixel_rgb)
array([[[ 0.66666667,  1.        ,  0.39215686]]])
&gt;&gt;&gt; # less saturated pink
&gt;&gt;&gt; pink_pixel_rgb = np.array([[[255, 100, 255]]], dtype=np.uint8)
&gt;&gt;&gt; color.rgb2hsv(pink_pixel_rgb)
array([[[ 0.83333333,  0.60784314,  1.        ]]])
</pre> </section> <section id="conversion-from-rgba-to-rgb-removing-alpha-channel-through-alpha-blending"> <h3>
<span class="section-number">9.1.2. </span>Conversion from RGBA to RGB - Removing alpha channel through alpha blending</h3> <p>Converting an RGBA image to an RGB image by alpha blending it with a background is realized with <a class="reference internal" href="../api/skimage.color.html#skimage.color.rgba2rgb" title="skimage.color.rgba2rgb"><code>rgba2rgb()</code></a></p> <pre data-language="python">&gt;&gt;&gt; import skimage as ski
&gt;&gt;&gt; img_rgba = ski.data.logo()
&gt;&gt;&gt; img_rgb = ski.color.rgba2rgb(img_rgba)
</pre> </section> <section id="conversion-between-color-and-gray-values"> <h3>
<span class="section-number">9.1.3. </span>Conversion between color and gray values</h3> <p>Converting an RGB image to a grayscale image is realized with <a class="reference internal" href="../api/skimage.color.html#skimage.color.rgb2gray" title="skimage.color.rgb2gray"><code>rgb2gray()</code></a></p> <pre data-language="python">&gt;&gt;&gt; img = ski.data.astronaut()
&gt;&gt;&gt; img_gray = ski.color.rgb2gray(img)
</pre> <p><a class="reference internal" href="../api/skimage.color.html#skimage.color.rgb2gray" title="skimage.color.rgb2gray"><code>rgb2gray()</code></a> uses a non-uniform weighting of color channels, because of the different sensitivity of the human eye to different colors. Therefore, such a weighting ensures <a class="reference external" href="https://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale">luminance preservation</a> from RGB to grayscale:</p> <pre data-language="python">&gt;&gt;&gt; red_pixel = np.array([[[255, 0, 0]]], dtype=np.uint8)
&gt;&gt;&gt; ski.color.rgb2gray(red_pixel)
array([[ 0.2125]])
&gt;&gt;&gt; green_pixel = np.array([[[0, 255, 0]]], dtype=np.uint8)
&gt;&gt;&gt; ski.color.rgb2gray(green_pixel)
array([[ 0.7154]])
</pre> <p>Converting a grayscale image to RGB with <a class="reference internal" href="../api/skimage.color.html#skimage.color.gray2rgb" title="skimage.color.gray2rgb"><code>gray2rgb()</code></a> simply duplicates the gray values over the three color channels.</p> </section> <section id="image-inversion"> <h3>
<span class="section-number">9.1.4. </span>Image inversion</h3> <p>An inverted image is also called complementary image. For binary images, True values become False and conversely. For grayscale images, pixel values are replaced by the difference of the maximum value of the data type and the actual value. For RGB images, the same operation is done for each channel. This operation can be achieved with <a class="reference internal" href="../api/skimage.util.html#skimage.util.invert" title="skimage.util.invert"><code>skimage.util.invert()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; import skimage as ski
&gt;&gt;&gt; img = ski.data.camera()
&gt;&gt;&gt; inverted_img = ski.util.invert(img)
</pre> </section> <section id="painting-images-with-labels"> <h3>
<span class="section-number">9.1.5. </span>Painting images with labels</h3> <p><a class="reference internal" href="../api/skimage.color.html#skimage.color.label2rgb" title="skimage.color.label2rgb"><code>label2rgb()</code></a> can be used to superimpose colors on a grayscale image using an array of labels to encode the regions to be represented with the same color.</p> <a class="reference external image-reference" href="https://scikit-image.org/docs/0.25.x/auto_examples/segmentation/plot_join_segmentations.html"><img alt="../_images/sphx_glr_plot_join_segmentations_001.png" class="align-center" src="https://scikit-image.org/docs/0.25.x/_images/sphx_glr_plot_join_segmentations_001.png" style="width: 80%;"> </a> <aside class="topic"> <p class="topic-title">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="https://scikit-image.org/docs/0.25.x/auto_examples/color_exposure/plot_tinting_grayscale_images.html#sphx-glr-auto-examples-color-exposure-plot-tinting-grayscale-images-py"><span class="std std-ref">Tinting gray-scale images</span></a></li> <li><a class="reference internal" href="https://scikit-image.org/docs/0.25.x/auto_examples/segmentation/plot_join_segmentations.html#sphx-glr-auto-examples-segmentation-plot-join-segmentations-py"><span class="std std-ref">Find the intersection of two segmentations</span></a></li> <li><a class="reference internal" href="https://scikit-image.org/docs/0.25.x/auto_examples/segmentation/plot_rag_mean_color.html#sphx-glr-auto-examples-segmentation-plot-rag-mean-color-py"><span class="std std-ref">Region adjacency graph (RAG) Thresholding</span></a></li> </ul> </aside> </section> </section> <section id="contrast-and-exposure"> <h2 id="exposure">
<span class="section-number">9.2. </span>Contrast and exposure</h2> <p>Image pixels can take values determined by the <code>dtype</code> of the image (see <a class="reference internal" href="data_types.html#data-types"><span class="std std-ref">Image data types and what they mean</span></a>), such as 0 to 255 for <code>uint8</code> images or <code>[0,
1]</code> for floating-point images. However, most images either have a narrower range of values (because of poor contrast), or have most pixel values concentrated in a subrange of the accessible values. <a class="reference internal" href="../api/skimage.exposure.html#module-skimage.exposure" title="skimage.exposure"><code>skimage.exposure</code></a> provides functions that spread the intensity values over a larger range.</p> <p>A first class of methods compute a nonlinear function of the intensity, that is independent of the pixel values of a specific image. Such methods are often used for correcting a known non-linearity of sensors, or receptors such as the human eye. A well-known example is <a class="reference external" href="https://en.wikipedia.org/wiki/Gamma_correction">Gamma correction</a>, implemented in <a class="reference internal" href="../api/skimage.exposure.html#skimage.exposure.adjust_gamma" title="skimage.exposure.adjust_gamma"><code>adjust_gamma()</code></a>.</p> <p>Other methods re-distribute pixel values according to the <em>histogram</em> of the image. The histogram of pixel values is computed with <a class="reference internal" href="../api/skimage.exposure.html#skimage.exposure.histogram" title="skimage.exposure.histogram"><code>skimage.exposure.histogram()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import skimage as ski
&gt;&gt;&gt; image = np.array([[1, 3], [1, 1]])
&gt;&gt;&gt; ski.exposure.histogram(image)
(array([3, 0, 1]), array([1, 2, 3]))
</pre> <p><a class="reference internal" href="../api/skimage.exposure.html#skimage.exposure.histogram" title="skimage.exposure.histogram"><code>histogram()</code></a> returns the number of pixels for each value bin, and the centers of the bins. The behavior of <a class="reference internal" href="../api/skimage.exposure.html#skimage.exposure.histogram" title="skimage.exposure.histogram"><code>histogram()</code></a> is therefore slightly different from the one of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.histogram.html#numpy.histogram" title="(in NumPy v2.1)"><code>numpy.histogram()</code></a>, which returns the boundaries of the bins.</p> <p>The simplest contrast enhancement <a class="reference internal" href="../api/skimage.exposure.html#skimage.exposure.rescale_intensity" title="skimage.exposure.rescale_intensity"><code>rescale_intensity()</code></a> consists in stretching pixel values to the whole allowed range, using a linear transformation:</p> <pre data-language="python">&gt;&gt;&gt; import skimage as ski
&gt;&gt;&gt; text = ski.data.text()
&gt;&gt;&gt; text.min(), text.max()
(10, 197)
&gt;&gt;&gt; better_contrast = ski.exposure.rescale_intensity(text)
&gt;&gt;&gt; better_contrast.min(), better_contrast.max()
(0, 255)
</pre> <p>Even if an image uses the whole value range, sometimes there is very little weight at the ends of the value range. In such a case, clipping pixel values using percentiles of the image improves the contrast (at the expense of some loss of information, because some pixels are saturated by this operation):</p> <pre data-language="python">&gt;&gt;&gt; moon = ski.data.moon()
&gt;&gt;&gt; v_min, v_max = np.percentile(moon, (0.2, 99.8))
&gt;&gt;&gt; v_min, v_max
(10.0, 186.0)
&gt;&gt;&gt; better_contrast = ski.exposure.rescale_intensity(moon, in_range=(v_min, v_max))
</pre> <p>The function <a class="reference internal" href="../api/skimage.exposure.html#skimage.exposure.equalize_hist" title="skimage.exposure.equalize_hist"><code>equalize_hist()</code></a> maps the cumulative distribution function (cdf) of pixel values onto a linear cdf, ensuring that all parts of the value range are equally represented in the image. As a result, details are enhanced in large regions with poor contrast. As a further refinement, histogram equalization can be performed in subregions of the image with <a class="reference internal" href="../api/skimage.exposure.html#skimage.exposure.equalize_adapthist" title="skimage.exposure.equalize_adapthist"><code>equalize_adapthist()</code></a>, in order to correct for exposure gradients across the image. See the example <a class="reference internal" href="https://scikit-image.org/docs/0.25.x/auto_examples/color_exposure/plot_equalize.html#sphx-glr-auto-examples-color-exposure-plot-equalize-py"><span class="std std-ref">Histogram Equalization</span></a>.</p> <a class="reference external image-reference" href="https://scikit-image.org/docs/0.25.x/auto_examples/color_exposure/plot_equalize.html"><img alt="../_images/sphx_glr_plot_equalize_001.png" class="align-center" src="https://scikit-image.org/docs/0.25.x/_images/sphx_glr_plot_equalize_001.png" style="width: 90%;"> </a> <aside class="topic"> <p class="topic-title">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="https://scikit-image.org/docs/0.25.x/auto_examples/color_exposure/plot_equalize.html#sphx-glr-auto-examples-color-exposure-plot-equalize-py"><span class="std std-ref">Histogram Equalization</span></a></li> </ul> </aside> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://scikit-image.org/docs/0.25.x/user_guide/transforming_image_data.html" class="_attribution-link">https://scikit-image.org/docs/0.25.x/user_guide/transforming_image_data.html</a>
  </p>
</div>
