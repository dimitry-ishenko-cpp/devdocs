<div class="innertube"> <h1 id="Match Specifications in Erlang">4 Match Specifications in Erlang</h1> <p>A "match specification" (<code>match_spec</code>) is an Erlang term describing a small "program" that tries to match something. It can be used to either control tracing with <code><a href="erlang.html#trace_pattern-3">erlang:trace_pattern/3</a></code> or to search for objects in an ETS table with for example <code>ets:select/2</code>. The match specification in many ways works like a small function in Erlang, but is interpreted/compiled by the Erlang runtime system to something much more efficient than calling an Erlang function. The match specification is also very limited compared to the expressiveness of real Erlang functions.</p> <p>The most notable difference between a match specification and an Erlang fun is the syntax. Match specifications are Erlang terms, not Erlang code. Also, a match specification has a strange concept of exceptions:</p> <ul> <li> <p>An exception (such as <code>badarg</code>) in the <code>MatchCondition</code> part, which resembles an Erlang guard, generates immediate failure.</p> </li> <li> <p>An exception in the <code>MatchBody</code> part, which resembles the body of an Erlang function, is implicitly caught and results in the single atom <code>'EXIT'</code>.</p> </li> </ul> <h2 id="grammar" class="title-link"> <div class="title-name">4.1 Grammar</div>  </h2> <p>A match specification used in tracing can be described in the following <strong>informal</strong> grammar:</p> <ul> <li>MatchExpression ::= [ MatchFunction, ... ] </li> <li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li> <li>MatchHead ::= MatchVariable | <code>'_'</code> | [ MatchHeadPart, ... ] </li> <li>MatchHeadPart ::= term() | MatchVariable | <code>'_'</code> </li> <li>MatchVariable ::= '$&lt;number&gt;' </li> <li>MatchConditions ::= [ MatchCondition, ...] | <code>[]</code> </li> <li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li> <li>BoolFunction ::= <code>is_atom</code> | <code>is_float</code> | <code>is_integer</code> | <code>is_list</code> | <code>is_number</code> | <code>is_pid</code> | <code>is_port</code> | <code>is_reference</code> | <code>is_tuple</code> | <code>is_map</code> | <code>is_map_key</code> | <code>is_binary</code> | <code>is_bitstring</code> | <code>is_boolean</code> | <code>is_function</code> | <code>is_record</code> | <code>is_seq_trace</code> | <code>'and'</code> | <code>'or'</code> | <code>'not'</code> | <code>'xor'</code> | <code>'andalso'</code> | <code>'orelse'</code> </li> <li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li> <li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <code>'$_'</code> | <code>'$$'</code> </li> <li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <code>[]</code> | [ConditionExpression, ...] | <code>#{}</code> | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant </li> <li>NonCompositeTerm ::= term() (not list or tuple or map) </li> <li>Constant ::= {<code>const</code>, term()} </li> <li>GuardFunction ::= BoolFunction | <code>abs</code> | <code>element</code> | <code>hd</code> | <code>length</code> | <code>map_get</code> | <code>map_size</code> | <code>max</code> | <code>min</code> | <code>node</code> | <code>float</code> | <code>round</code> | <code>floor</code> | <code>ceil</code> | <code>size</code> | <code>bit_size</code> | <code>byte_size</code> | <code>tuple_size</code> | <code>tl</code> | <code>trunc</code> | <code>binary_part</code> | <code>'+'</code> | <code>'-'</code> | <code>'*'</code> | <code>'div'</code> | <code>'rem'</code> | <code>'band'</code> | <code>'bor'</code> | <code>'bxor'</code> | <code>'bnot'</code> | <code>'bsl'</code> | <code>'bsr'</code> | <code>'&gt;'</code> | <code>'&gt;='</code> | <code>'&lt;'</code> | <code>'=&lt;'</code> | <code>'=:='</code> | <code>'=='</code> | <code>'=/='</code> | <code>'/='</code> | <code>self</code> | <code>get_tcw</code> </li> <li>MatchBody ::= [ ActionTerm ] </li> <li>ActionTerm ::= ConditionExpression | ActionCall </li> <li>ActionCall ::= {ActionFunction} | {ActionFunction, ActionTerm, ...} </li> <li>ActionFunction ::= <code>set_seq_token</code> | <code>get_seq_token</code> | <code>message</code> | <code>return_trace</code> | <code>exception_trace</code> | <code>process_dump</code> | <code>enable_trace</code> | <code>disable_trace</code> | <code>trace</code> | <code>display</code> | <code>caller</code> | <code>caller_line</code> | <code>current_stacktrace</code> | <code>set_tcw</code> | <code>silent</code> </li> </ul> <p>A match specification used in <code>ets(3)</code> can be described in the following <strong>informal</strong> grammar:</p> <ul> <li>MatchExpression ::= [ MatchFunction, ... ] </li> <li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li> <li>MatchHead ::= MatchVariable | <code>'_'</code> | { MatchHeadPart, ... } </li> <li>MatchHeadPart ::= term() | MatchVariable | <code>'_'</code> </li> <li>MatchVariable ::= '$&lt;number&gt;' </li> <li>MatchConditions ::= [ MatchCondition, ...] | <code>[]</code> </li> <li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li> <li>BoolFunction ::= <code>is_atom</code> | <code>is_float</code> | <code>is_integer</code> | <code>is_list</code> | <code>is_number</code> | <code>is_pid</code> | <code>is_port</code> | <code>is_reference</code> | <code>is_tuple</code> | <code>is_map</code> | <code>is_map_key</code> | <code>is_binary</code> | <code>is_bitstring</code> | <code>is_boolean</code> | <code>is_function</code> | <code>is_record</code> | <code>'and'</code> | <code>'or'</code> | <code>'not'</code> | <code>'xor'</code> | <code>'andalso'</code> | <code>'orelse'</code> </li> <li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li> <li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <code>'$_'</code> | <code>'$$'</code> </li> <li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <code>[]</code> | [ConditionExpression, ...] | #{} | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant </li> <li>NonCompositeTerm ::= term() (not list or tuple or map) </li> <li>Constant ::= {<code>const</code>, term()} </li> <li>GuardFunction ::= BoolFunction | <code>abs</code> | <code>element</code> | <code>hd</code> | <code>length</code> | <code>map_get</code> | <code>map_size</code> | <code>max</code> | <code>min</code> | <code>node</code> | <code>float</code> | <code>round</code> | <code>floor</code> | <code>ceil</code> | <code>size</code> | <code>bit_size</code> | <code>byte_size</code> | <code>tuple_size</code> | <code>tl</code> | <code>trunc</code> | <code>binary_part</code> | <code>'+'</code> | <code>'-'</code> | <code>'*'</code> | <code>'div'</code> | <code>'rem'</code> | <code>'band'</code> | <code>'bor'</code> | <code>'bxor'</code> | <code>'bnot'</code> | <code>'bsl'</code> | <code>'bsr'</code> | <code>'&gt;'</code> | <code>'&gt;='</code> | <code>'&lt;'</code> | <code>'=&lt;'</code> | <code>'=:='</code> | <code>'=='</code> | <code>'=/='</code> | <code>'/='</code> | <code>self</code> </li> <li>MatchBody ::= [ ConditionExpression, ... ] </li> </ul> <h2 id="function-descriptions" class="title-link"> <div class="title-name">4.2 Function Descriptions</div>  </h2> <h3 id="functions-allowed-in-all-types-of-match-specifications" class="title-link"> <div class="title-name">Functions Allowed in All Types of Match Specifications</div>  </h3> <p>The functions allowed in <code>match_spec</code> work as follows:</p> <dl> <dt class="title-link"><strong><code>is_atom</code>, <code>is_boolean</code>, <code>is_float</code>, <code>is_integer</code>, <code>is_list</code>, <code>is_number</code>, <code>is_pid</code>, <code>is_port</code>, <code>is_reference</code>, <code>is_tuple</code>, <code>is_map</code>, <code>is_binary</code>, <code>is_bitstring</code>, <code>is_function</code> </strong></dt> <dd> <p>Same as the corresponding guard tests in Erlang, return <code>true</code> or <code>false</code>.</p> </dd> <dt class="title-link"><strong><code>is_record</code></strong></dt> <dd> <p>Takes an additional parameter, which <strong>must</strong> be the result of <code>record_info(size, &lt;record_type&gt;)</code>, like in <code>{is_record, '$1', rectype, record_info(size, rectype)}</code>.</p> </dd> <dt class="title-link"><strong><code>'not'</code></strong></dt> <dd> <p>Negates its single argument (anything other than <code>false</code> gives <code>false</code>).</p> </dd> <dt class="title-link"><strong><code>'and'</code></strong></dt> <dd> <p>Returns <code>true</code> if all its arguments (variable length argument list) evaluate to <code>true</code>, otherwise <code>false</code>. Evaluation order is undefined.</p> </dd> <dt class="title-link"><strong><code>'or'</code></strong></dt> <dd> <p>Returns <code>true</code> if any of its arguments evaluates to <code>true</code>. Variable length argument list. Evaluation order is undefined.</p> </dd> <dt class="title-link"><strong><code>'andalso'</code></strong></dt> <dd> <p>Works as <code>'and'</code>, but quits evaluating its arguments when one argument evaluates to something else than <code>true</code>. Arguments are evaluated left to right.</p> </dd> <dt class="title-link"><strong><code>'orelse'</code></strong></dt> <dd> <p>Works as <code>'or'</code>, but quits evaluating as soon as one of its arguments evaluates to <code>true</code>. Arguments are evaluated left to right.</p> </dd> <dt class="title-link"><strong><code>'xor'</code></strong></dt> <dd> <p>Only two arguments, of which one must be <code>true</code> and the other <code>false</code> to return <code>true</code>; otherwise <code>'xor'</code> returns false.</p> </dd> <dt class="title-link"><strong><code>abs</code>, <code>element</code>, <code>hd</code>, <code>length</code>, <code>map_get</code>, <code>map_size</code>, <code>max</code>, <code>min</code>, <code>node</code>, <code>round</code>, <code>ceil</code>, <code>floor</code>, <code>float</code>, <code>size</code>, <code>bit_size</code>, <code>byte_size</code>, <code>tuple_size</code>, <code>tl</code>, <code>trunc</code>, <code>binary_part</code>, <code>'+'</code>, <code>'-'</code>, <code>'*'</code>, <code>'div'</code>, <code>'rem'</code>, <code>'band'</code>, <code>'bor'</code>, <code>'bxor'</code>, <code>'bnot'</code>, <code>'bsl'</code>, <code>'bsr'</code>, <code>'&gt;'</code>, <code>'&gt;='</code>, <code>'&lt;'</code>, <code>'=&lt;'</code>, <code>'=:='</code>, <code>'=='</code>, <code>'=/='</code>, <code>'/='</code>, <code>self</code></strong></dt> <dd> <p>Same as the corresponding Erlang BIFs (or operators). In case of bad arguments, the result depends on the context. In the <code>MatchConditions</code> part of the expression, the test fails immediately (like in an Erlang guard). In the <code>MatchBody</code> part, exceptions are implicitly caught and the call results in the atom <code>'EXIT'</code>.</p> </dd> </dl> <h3 id="functions-allowed-only-for-tracing" class="title-link"> <div class="title-name">Functions Allowed Only for Tracing</div>  </h3> <p>The functions allowed only for tracing work as follows:</p> <dl> <dt class="title-link"><strong><code>is_seq_trace</code></strong></dt> <dd> <p>Returns <code>true</code> if a sequential trace token is set for the current process, otherwise <code>false</code>.</p> </dd> <dt class="title-link"><strong><code>set_seq_token</code></strong></dt> <dd> <p>Works as <code>seq_trace:set_token/2</code>, but returns <code>true</code> on success, and <code>'EXIT'</code> on error or bad argument. Only allowed in the <code>MatchBody</code> part and only allowed when tracing.</p> </dd> <dt class="title-link"><strong><code>get_seq_token</code></strong></dt> <dd> <p>Same as <code>seq_trace:get_token/0</code> and only allowed in the <code>MatchBody</code> part when tracing.</p> </dd> <dt class="title-link"><strong><code>message</code></strong></dt> <dd> <p>Sets an additional message appended to the trace message sent. One can only set one additional message in the body. Later calls replace the appended message.</p> <p>As a special case, <code>{message, false}</code> disables sending of trace messages ('call' and 'return_to') for this function call, just like if the match specification had not matched. This can be useful if only the side effects of the <code>MatchBody</code> part are desired.</p> <p>Another special case is <code>{message, true}</code>, which sets the default behavior, as if the function had no match specification; trace message is sent with no extra information (if no other calls to <code>message</code> are placed before <code>{message, true}</code>, it is in fact a "noop").</p> <p>Takes one argument: the message. Returns <code>true</code> and can only be used in the <code>MatchBody</code> part and when tracing.</p> </dd> <dt class="title-link"><strong><code>return_trace</code></strong></dt> <dd> <p>Causes a <code>return_from</code> trace message to be sent upon return from the current function. Takes no arguments, returns <code>true</code> and can only be used in the <code>MatchBody</code> part when tracing. If the process trace flag <code>silent</code> is active, the <code>return_from</code> trace message is inhibited.</p> <p><strong>Warning:</strong> If the traced function is tail-recursive, this match specification function destroys that property. Hence, if a match specification executing this function is used on a perpetual server process, it can only be active for a limited period of time, or the emulator will eventually use all memory in the host machine and crash. If this match specification function is inhibited using process trace flag <code>silent</code>, tail-recursiveness still remains.</p> </dd> <dt class="title-link"><strong><code>exception_trace</code></strong></dt> <dd> <p>Works as <code>return_trace</code> plus; if the traced function exits because of an exception, an <code>exception_from</code> trace message is generated, regardless of the exception is caught or not.</p> </dd> <dt class="title-link"><strong><code>process_dump</code></strong></dt> <dd> <p>Returns some textual information about the current process as a binary. Takes no arguments and is only allowed in the <code>MatchBody</code> part when tracing.</p> </dd> <dt class="title-link"><strong><code>enable_trace</code></strong></dt> <dd> <p>With one parameter this function turns on tracing like the Erlang call <code>erlang:trace(self(), true, [P2])</code>, where <code>P2</code> is the parameter to <code>enable_trace</code>.</p> <p>With two parameters, the first parameter is to be either a process identifier or the registered name of a process. In this case tracing is turned on for the designated process in the same way as in the Erlang call <code>erlang:trace(P1, true, [P2])</code>, where <code>P1</code> is the first and <code>P2</code> is the second argument. The process <code>P1</code> gets its trace messages sent to the same tracer as the process executing the statement uses. <code>P1</code> <strong>cannot</strong> be one of the atoms <code>all</code>, <code>new</code> or <code>existing</code> (unless they are registered names). <code>P2</code> <strong>cannot</strong> be <code>cpu_timestamp</code> or <code>tracer</code>.</p> <p>Returns <code>true</code> and can only be used in the <code>MatchBody</code> part when tracing.</p> </dd> <dt class="title-link"><strong><code>disable_trace</code></strong></dt> <dd> <p>With one parameter this function disables tracing like the Erlang call <code>erlang:trace(self(), false, [P2])</code>, where <code>P2</code> is the parameter to <code>disable_trace</code>.</p> <p>With two parameters this function works as the Erlang call <code>erlang:trace(P1, false, [P2])</code>, where <code>P1</code> can be either a process identifier or a registered name and is specified as the first argument to the match specification function. <code>P2</code> <strong>cannot</strong> be <code>cpu_timestamp</code> or <code>tracer</code>.</p> <p>Returns <code>true</code> and can only be used in the <code>MatchBody</code> part when tracing.</p> </dd> <dt class="title-link"><strong><code>trace</code></strong></dt> <dd> <p>With two parameters this function takes a list of trace flags to disable as first parameter and a list of trace flags to enable as second parameter. Logically, the disable list is applied first, but effectively all changes are applied atomically. The trace flags are the same as for <code>erlang:trace/3</code>, not including <code>cpu_timestamp</code>, but including <code>tracer</code>.</p> <p>If a tracer is specified in both lists, the tracer in the enable list takes precedence. If no tracer is specified, the same tracer as the process executing the match specification is used (not the meta tracer). If that process doesn't have tracer either, then trace flags are ignored.</p> <p>When using a <code><a href="erl_tracer.html">tracer module</a></code>, the module must be loaded before the match specification is executed. If it is not loaded, the match fails.</p> <p>With three parameters to this function, the first is either a process identifier or the registered name of a process to set trace flags on, the second is the disable list, and the third is the enable list.</p> <p>Returns <code>true</code> if any trace property was changed for the trace target process, otherwise <code>false</code>. Can only be used in the <code>MatchBody</code> part when tracing.</p> </dd> <dt class="title-link"><strong><code>caller</code></strong></dt> <dd> <p>Returns the calling function as a tuple <code>{Module, Function, Arity}</code> or the atom <code>undefined</code> if the calling function cannot be determined. Can only be used in the <code>MatchBody</code> part when tracing.</p> <p>Notice that if a "technically built in function" (that is, a function not written in Erlang) is traced, the <code>caller</code> function sometimes returns the atom <code>undefined</code>. The calling Erlang function is not available during such calls.</p> </dd> <dt class="title-link"><strong><code>caller_line</code></strong></dt> <dd> <p>Similar to <code>caller</code> but returns additional information about the source code location of the function call-site within the caller function. Returns the calling function as a tuple <code>{Module, Function, Arity, {File, Line}}</code>. <code>File</code> is the <code>string</code> file name while <code>Line</code> is source line number. If the <code>File</code> and <code>Line</code> cannot be determined, <code>{Module, Function, Arity, undefined}</code> is returned. If the calling function cannot be determined, the atom <code>undefined</code> is returned. Can only be used in the <code>MatchBody</code> part when tracing.</p> <p>Notice that if a "technically built in function" (that is, a function not written in Erlang) is traced, the <code>caller_line</code> function sometimes returns the atom <code>undefined</code>. The calling Erlang function is not available during such calls.</p> </dd> <dt class="title-link"><strong><code>current_stacktrace</code></strong></dt> <dd> <p>Returns the current call stack back-trace (<code>stacktrace</code>) of the calling function. The stack has the same format as in the <code>catch</code> part of a <code>try</code>. See <code>The call-stack back trace (stacktrace)</code>. The depth of the stacktrace is truncated according to the <code>backtrace_depth</code> system flag setting.</p> <p>Accepts a depth parameter. The depth value will be <code>backtrace_depth</code> if the argument is greater.</p> </dd> <dt class="title-link"><strong><code>display</code></strong></dt> <dd> <p>For debugging purposes only. Displays the single argument as an Erlang term on <code>stdout</code>, which is seldom what is wanted. Returns <code>true</code> and can only be used in the <code>MatchBody</code> part when tracing.</p> </dd> <dt class="title-link"><strong><code id="get_tcw">get_tcw</code></strong></dt> <dd> <p>Takes no argument and returns the value of the node's trace control word. The same is done by <code>erlang:system_info(trace_control_word)</code>.</p> <p>The trace control word is a 32-bit unsigned integer intended for generic trace control. The trace control word can be tested and set both from within trace match specifications and with BIFs. This call is only allowed when tracing.</p> </dd> <dt class="title-link"><strong><code id="set_tcw">set_tcw</code></strong></dt> <dd> <p>Takes one unsigned integer argument, sets the value of the node's trace control word to the value of the argument, and returns the previous value. The same is done by <code>erlang:system_flag(trace_control_word, Value)</code>. It is only allowed to use <code>set_tcw</code> in the <code>MatchBody</code> part when tracing.</p> </dd> <dt class="title-link"><strong><code>silent</code></strong></dt> <dd> <p>Takes one argument. If the argument is <code>true</code>, the call trace message mode for the current process is set to silent for this call and all later calls, that is, call trace messages are inhibited even if <code>{message, true}</code> is called in the <code>MatchBody</code> part for a traced function.</p> <p>This mode can also be activated with flag <code>silent</code> to <code>erlang:trace/3</code>.</p> <p>If the argument is <code>false</code>, the call trace message mode for the current process is set to normal (non-silent) for this call and all later calls.</p> <p>If the argument is not <code>true</code> or <code>false</code>, the call trace message mode is unaffected.</p> </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>All "function calls" must be tuples, even if they take no arguments. The value of <code>self</code> is the atom() <code>self</code>, but the value of <code>{self}</code> is the pid() of the current process.</p> </div> </div> <h2 id="match-target" class="title-link"> <div class="title-name">4.3 Match target</div>  </h2> <p>Each execution of a match specification is done against a match target term. The format and content of the target term depends on the context in which the match is done. The match target for ETS is always a full table tuple. The match target for call trace is always a list of all function arguments. The match target for event trace depends on the event type, see table below.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>Context</td> <td>Type</td> <td>Match target</td> <td>Description</td> </tr> <tr> <td>ETS</td> <td></td> <td>{Key, Value1, Value2, ...}</td> <td>A table object</td> </tr> <tr> <td>Trace</td> <td>call</td> <td>[Arg1, Arg2, ...]</td> <td>Function arguments</td> </tr> <tr> <td>Trace</td> <td>send</td> <td>[Receiver, Message]</td> <td>Receiving process/port and message term</td> </tr> <tr> <td>Trace</td> <td>'receive'</td> <td>[Node, Sender, Message]</td> <td>Sending node, process/port and message term</td> </tr> </table> <p class="doc-table-caption">Table 4.1: Match target depending on context</p> </div> <h2 id="variables-and-literals" class="title-link"> <div class="title-name">4.4 Variables and Literals</div>  </h2> <p>Variables take the form <code>'$&lt;number&gt;'</code>, where <code>&lt;number&gt;</code> is an integer between 0 and 100,000,000 (1e+8). The behavior if the number is outside these limits is <strong>undefined</strong>. In the <code>MatchHead</code> part, the special variable <code>'_'</code> matches anything, and never gets bound (like <code>_</code> in Erlang).</p> <ul> <li> <p>In the <code>MatchCondition/MatchBody</code> parts, no unbound variables are allowed, so <code>'_'</code> is interpreted as itself (an atom). Variables can only be bound in the <code>MatchHead</code> part.</p> </li> <li> <p>In the <code>MatchBody</code> and <code>MatchCondition</code> parts, only variables bound previously can be used.</p> </li> <li> <p>As a special case, the following apply in the <code>MatchCondition/MatchBody</code> parts:</p> <ul> <li> <p>The variable <code>'$_'</code> expands to the whole <code><a href="#match_target">match target</a></code> term. </p> </li> <li> <p>The variable <code>'$$'</code> expands to a list of the values of all bound variables in order (that is, <code>['$1','$2', ...]</code>).</p> </li> </ul> </li> </ul> <p>In the <code>MatchHead</code> part, all literals (except the variables above) are interpreted "as is".</p> <p>In the <code>MatchCondition/MatchBody</code> parts, the interpretation is in some ways different. Literals in these parts can either be written "as is", which works for all literals except tuples, or by using the special form <code>{const, T}</code>, where <code>T</code> is any Erlang term.</p> <p>For tuple literals in the match specification, double tuple parentheses can also be used, that is, construct them as a tuple of arity one containing a single tuple, which is the one to be constructed. The "double tuple parenthesis" syntax is useful to construct tuples from already bound variables, like in <code>{{'$1', [a,b,'$2']}}</code>. Examples:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Expression</strong></td> <td><strong>Variable Bindings</strong></td> <td><strong>Result</strong></td> </tr> <tr> <td>{{'$1','$2'}}</td> <td>'$1' = a, '$2' = b</td> <td>{a,b}</td> </tr> <tr> <td>{const, {'$1', '$2'}}</td> <td>Irrelevant</td> <td>{'$1', '$2'}</td> </tr> <tr> <td>a</td> <td>Irrelevant</td> <td>a</td> </tr> <tr> <td>'$1'</td> <td>'$1' = []</td> <td>[]</td> </tr> <tr> <td>['$1']</td> <td>'$1' = []</td> <td>[[]]</td> </tr> <tr> <td>[{{a}}]</td> <td>Irrelevant</td> <td>[{a}]</td> </tr> <tr> <td>42</td> <td>Irrelevant</td> <td>42</td> </tr> <tr> <td>"hello"</td> <td>Irrelevant</td> <td>"hello"</td> </tr> <tr> <td>$1</td> <td>Irrelevant</td> <td>49 (the ASCII value for character '1')</td> </tr> </table> <p class="doc-table-caption">Table 4.2: Literals in MatchCondition/MatchBody Parts of a Match Specification</p> </div> <h2 id="execution-of-the-match" class="title-link"> <div class="title-name">4.5 Execution of the Match</div>  </h2> <p>The execution of the match expression, when the runtime system decides whether a trace message is to be sent, is as follows:</p> <p>For each tuple in the <code>MatchExpression</code> list and while no match has succeeded:</p> <ol> <li> <p>Match the <code>MatchHead</code> part against the match target term, binding the <code>'$&lt;number&gt;'</code> variables (much like in <code>ets:match/2</code>). If the <code>MatchHead</code> part cannot match the arguments, the match fails.</p> </li> <li> <p>Evaluate each <code>MatchCondition</code> (where only <code>'$&lt;number&gt;'</code> variables previously bound in the <code>MatchHead</code> part can occur) and expect it to return the atom <code>true</code>. When a condition does not evaluate to <code>true</code>, the match fails. If any BIF call generates an exception, the match also fails.</p> </li> <li> <p>Two cases can occur:</p> <ul> <li> <p>If the match specification is executing when tracing:</p> <p>Evaluate each <code>ActionTerm</code> in the same way as the <code>MatchConditions</code>, but ignore the return values. Regardless of what happens in this part, the match has succeeded.</p> </li> <li> <p>If the match specification is executed when selecting objects from an ETS table:</p> <p>Evaluate the expressions in order and return the value of the last expression (typically there is only one expression in this context).</p> </li> </ul> </li> </ol> <h2 id="differences-between-match-specifications-in-ets-and-tracing" class="title-link"> <div class="title-name">4.6 Differences between Match Specifications in ETS and Tracing</div>  </h2> <p>ETS match specifications produce a return value. Usually the <code>MatchBody</code> contains one single <code>ConditionExpression</code> that defines the return value without any side effects. Calls with side effects are not allowed in the ETS context.</p> <p>When tracing there is no return value to produce, the match specification either matches or does not. The effect when the expression matches is a trace message rather than a returned term. The <code>ActionTerm</code>s are executed as in an imperative language, that is, for their side effects. Functions with side effects are also allowed when tracing.</p> <h2 id="tracing-examples" class="title-link"> <div class="title-name">4.7 Tracing Examples</div>  </h2> <p>Match an argument list of three, where the first and third arguments are equal:</p> <pre data-language="erlang">[{['$1', '_', '$1'],
  [],
  []}]</pre> <p>Match an argument list of three, where the second argument is a number &gt; 3:</p> <pre data-language="erlang">[{['_', '$1', '_'],
  [{ '&gt;', '$1', 3}],
  []}]</pre> <p>Match an argument list of three, where the third argument is either a tuple containing argument one and two, <strong>or</strong> a list beginning with argument one and two (that is, <code>[a,b,[a,b,c]]</code> or <code>[a,b,{a,b}]</code>):</p> <pre data-language="erlang">[{['$1', '$2', '$3'],
  [{'orelse', 
      {'=:=', '$3', {{'$1','$2'}}},
      {'and', 
        {'=:=', '$1', {hd, '$3'}},
        {'=:=', '$2', {hd, {tl, '$3'}}}}}],
  []}]</pre> <p>The above problem can also be solved as follows:</p> <pre data-language="erlang">[{['$1', '$2', {'$1', '$2}], [], []},
 {['$1', '$2', ['$1', '$2' | '_']], [], []}]</pre> <p>Match two arguments, where the first is a tuple beginning with a list that in turn begins with the second argument times two (that is, <code>[{[4,x],y},2]</code> or <code>[{[8], y, z},4])</code>:</p> <pre data-language="erlang">[{['$1', '$2'],[{'=:=', {'*', 2, '$2'}, {hd, {element, 1, '$1'}}}],
  []}]</pre> <p>Match three arguments. When all three are equal and are numbers, append the process dump to the trace message, otherwise let the trace message be "as is", but set the sequential trace token label to 4711:</p> <pre data-language="erlang">[{['$1', '$1', '$1'],
  [{is_number, '$1'}],
  [{message, {process_dump}}]},
 {'_', [], [{set_seq_token, label, 4711}]}]</pre> <p>As can be noted above, the parameter list can be matched against a single <code>MatchVariable</code> or an <code>'_'</code>. To replace the whole parameter list with a single variable is a special case. In all other cases the <code>MatchHead</code> must be a <strong>proper</strong> list.</p> <p>Generate a trace message only if the trace control word is set to 1:</p> <pre data-language="erlang">[{'_',
  [{'==',{get_tcw},{const, 1}}],
  []}]</pre> <p>Generate a trace message only if there is a <code>seq_trace</code> token:</p> <pre data-language="erlang">[{'_',
  [{'==',{is_seq_trace},{const, 1}}],
  []}]</pre> <p>Remove the <code>'silent'</code> trace flag when the first argument is <code>'verbose'</code>, and add it when it is <code>'silent':</code></p> <pre data-language="erlang">[{'$1',
  [{'==',{hd, '$1'},verbose}],
  [{trace, [silent],[]}]},
 {'$1',
  [{'==',{hd, '$1'},silent}],
  [{trace, [],[silent]}]}]</pre> <p>Add a <code>return_trace</code> message if the function is of arity 3:</p> <pre data-language="erlang">[{'$1',
  [{'==',{length, '$1'},3}],
  [{return_trace}]},
 {'_',[],[]}]</pre> <p>Generate a trace message only if the function is of arity 3 and the first argument is <code>'trace'</code>:</p> <pre data-language="erlang">[{['trace','$2','$3'],
  [],
  []},
 {'_',[],[]}]</pre> <h2 id="ets-examples" class="title-link"> <div class="title-name">4.8 ETS Examples</div>  </h2> <p>Match all objects in an ETS table, where the first element is the atom <code>'strider'</code> and the tuple arity is 3, and return the whole object:</p> <pre data-language="erlang">[{{strider,'_','_'},
  [],
  ['$_']}]</pre> <p>Match all objects in an ETS table with arity &gt; 1 and the first element is 'gandalf', and return element 2:</p> <pre data-language="erlang">[{'$1',
  [{'==', gandalf, {element, 1, '$1'}},{'&gt;=',{size, '$1'},2}],
  [{element,2,'$1'}]}]</pre> <p>In this example, if the first element had been the key, it is much more efficient to match that key in the <code>MatchHead</code> part than in the <code>MatchConditions</code> part. The search space of the tables is restricted with regards to the <code>MatchHead</code> so that only objects with the matching key are searched.</p> <p>Match tuples of three elements, where the second element is either <code>'merry'</code> or <code>'pippin'</code>, and return the whole objects:</p> <pre data-language="erlang">[{{'_',merry,'_'},
  [],
  ['$_']},
 {{'_',pippin,'_'},
  [],
  ['$_']}]</pre> <p>Function <code>ets:test_ms/2</code> can be useful for testing complicated ETS matches.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
