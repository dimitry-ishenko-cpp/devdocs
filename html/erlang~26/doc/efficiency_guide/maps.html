<div class="innertube"> <h1 id="Maps">5 Maps</h1> <p>This guide to using maps efficiently starts with a brief section on the choice between records or maps, followed by three sections giving concrete (but brief) advice on using maps as an alternative to records, as dictionaries, and as sets. The remaining sections dig deeper, looking at how maps are implemented, the map syntax, and finally the functions in the <code>maps</code> module.</p>  <p id="terminology">Terminology used in this chapter:</p> <ul> <li>A map with at most 32 elements will informally be called a <strong>small map</strong>.</li> <li>A map with more than 32 elements will informally be called a <strong>large map</strong>.</li> </ul> <h2 id="maps-or-records-" class="title-link"> <div class="title-name">5.1 Maps or Records?</div>  </h2> <p>If the advice in this chapter is followed, the performance of records compared to using small maps instead of records is expected to be similar. Therefore, the choice between records and maps should be based on the desired properties of the data structure and not performance.</p> <p>The advantages of records compared to maps are:</p> <ul> <li>If the name of a record field is misspelled, there will be a compilation error. If a map key is misspelled, the compiler will give no warning and program will fail in some way when it is run.</li> <li>Records will use slightly less memory than maps, and performance is expected to be <strong>slightly</strong> better than maps in most circumstances.</li> </ul> <p>The disadvantage of records compared to maps is that if a new field is added to a record, all code that uses that record must be recompiled. Because of that, it is recommended to only use records within a unit of code that can easily be recompiled all at once, for example within a single application or single module.</p> <h2 id="using-maps-as-an-alternative-to-records" class="title-link"> <div class="title-name">5.2 Using Maps as an Alternative to Records</div>  </h2> <ul> <li><p>Use the map syntax instead of the functions in the <code>maps</code> module.</p></li> <li><p>Avoid having more than 32 elements in the map. As soon as there are more than 32 elements in the map, it will require more memory and keys can no longer be shared with other instances of the map.</p></li> <li><p>When creating a new map, always create it with all keys that will ever be used. To maximize sharing of keys (thus minimizing memory use), create a single function that constructs the map using the map syntax and always use it.</p></li> <li><p>Always update the map using the <code>:=</code> operator (that is, requiring that an element with that key already exists). The <code>:=</code> operator is slightly more efficient, and it helps catching mispellings of keys.</p></li> <li><p>Whenever possible, match multiple map elements at once.</p></li> <li><p>Whenever possible, update multiple map elements at once.</p></li> <li><p>Avoid default values and the <code>maps:get/3</code> function. If there are default values, sharing of keys between different instances of the map will be less effective, and it is not possible to match multiple elements having default values in one go.</p></li> <li> <p>To avoid having to deal with a map that may lack some keys, <code>maps:merge/2</code> can efficiently add multiple default values. For example:</p> <pre data-language="erlang">DefaultMap = #{shoe_size =&gt; 42, editor =&gt; emacs},
MapWithDefaultsApplied = maps:merge(DefaultMap, OtherMap)</pre> </li> </ul> <h2 id="using-maps-as-dictionaries" class="title-link"> <div class="title-name">5.3 Using Maps as Dictionaries</div>  </h2> <p>Using a map as a dictionary implies the following usage pattern:</p> <ul> <li><p>Keys are usually variables not known at compile-time.</p></li> <li><p>There can be any number of elements in the map.</p></li> <li><p>Usually, no more than one element is looked up or updated at once.</p></li> </ul> <p>Given that usage pattern, the difference in performance between using the map syntax and the maps module is usually small. Therefore, which one to use is mostly a matter of taste.</p> <p>Maps are usually the most efficient dictionary data structure, with a few exceptions:</p> <ul> <li><p>If it is necessary to frequently convert a dictionary to a sorted list, or from a sorted list to a dictionary, using <code>gb_trees</code> can be a better choice.</p></li> <li><p>If all keys are non-negative integers, the <code>array</code> module can be a better choice.</p></li> </ul> <h2 id="using-maps-as-sets" class="title-link"> <div class="title-name">5.4 Using Maps as Sets</div>  </h2> <p>Starting in OTP 24, the <code>sets</code> module has an option to represent sets as maps. Examples:</p> <pre data-language="erlang">1&gt; sets:new([{version,2}]).
#{}
2&gt; sets:from_list([x,y,z], [{version,2}]).
#{x =&gt; [],y =&gt; [],z =&gt; []}</pre> <p><code>sets</code> backed by maps is generally the most efficient set representation, with a few possible exceptions:</p> <ul> <li><p><code>ordsets:intersection/2</code> can be more efficient than <code>sets:intersection/2</code>. If the intersection operation is frequently used and operations that operate on a single element in a set (such as <code>is_element/2</code>) are avoided, <code>ordsets</code> can be a better choice than <code>sets</code>.</p></li> <li><p>If the intersection operation is frequently used and operations that operate on a single element in a set (such as <code>is_element/2</code>) must also be efficient, <code>gb_sets</code> can potentially be a better choice than <code>sets</code>.</p></li> <li><p>If the elements of the set are integers in a fairly compact range, the set can be represented as an integer where each bit represents an element in the set. The union operation is performed by <code>bor</code> and the intersection operation by <code>band</code>.</p></li> </ul> <h2 id="how-maps-are-implemented" class="title-link"> <div class="title-name">5.5 How Maps are Implemented</div>  </h2> <p>Internally, maps have two distinct representations depending on the number of elements in the map. The representation changes when a map grows beyond 32 elements, or when it shrinks to 32 elements or less.</p> <ul> <li>A map with at most 32 elements has a compact representation, making it suitable as an alternative to records.</li> <li>A map with more than 32 elements is represented as a tree that can be efficiently searched and updated regardless of how many elements there are.</li> </ul> <h3 id="how-small-maps-are-implemented" class="title-link"> <div class="title-name">How Small Maps are Implemented</div>  </h3> <p>A small map looks like this inside the runtime system:</p> <div class="doc-table-wrapper"> <table class="doc-table"><tr> <td><code>FLATMAP</code></td> <td><strong>N</strong></td> <td><strong>Keys</strong></td> <td><strong>Value1</strong></td> <td><strong>. . .</strong></td> <td><strong>ValueN</strong></td> </tr></table> <p class="doc-table-caption">Table 5.1: The representation of a small map</p> </div> <dl> <dt class="title-link"><strong><code>FLATMAP</code></strong></dt> <dd>The tag for a small map (called <strong>flat map</strong> in the source code for the runtime system).</dd> <dt class="title-link"><strong>N</strong></dt> <dd>The number of elements in the map.</dd> <dt class="title-link"><strong>Keys</strong></dt> <dd>A tuple with keys of the map: <code>{Key1,...,KeyN}</code>. The keys are sorted.</dd> <dt class="title-link"><strong>Value1</strong></dt> <dd>The value corresponding to the first key in the key tuple.</dd> <dt class="title-link"><strong>ValueN</strong></dt> <dd>The value corresponding to the last key in the key tuple.</dd> </dl> <p>As an example, let us look at how the map <code>#{a =&gt; foo, z =&gt; bar}</code> is represented:</p> <div class="doc-table-wrapper"> <table class="doc-table"><tr> <td><code>FLATMAP</code></td> <td><strong>2</strong></td> <td><strong>{a,z}</strong></td> <td><strong>foo</strong></td> <td><strong>bar</strong></td> </tr></table> <p class="doc-table-caption">Table 5.2: #{a =&gt; foo, z =&gt; bar}</p> </div> <p>Let us update the map: <code>M#{q =&gt; baz}</code>. The map now looks like this:</p> <div class="doc-table-wrapper"> <table class="doc-table"><tr> <td><code>FLATMAP</code></td> <td><strong>3</strong></td> <td><strong>{a,q,z}</strong></td> <td><strong>foo</strong></td> <td><strong>baz</strong></td> <td><strong>bar</strong></td> </tr></table> <p class="doc-table-caption">Table 5.3: #{a =&gt; foo, q =&gt; baz, z =&gt; bar}</p> </div> <p>Finally, change the value of one element: <code>M#{z := bird}</code>. The map now looks like this:</p> <div class="doc-table-wrapper"> <table class="doc-table"><tr> <td><code>FLATMAP</code></td> <td><strong>3</strong></td> <td><strong>{a,q,z}</strong></td> <td><strong>foo</strong></td> <td><strong>baz</strong></td> <td><strong>bird</strong></td> </tr></table> <p class="doc-table-caption">Table 5.4: #{a =&gt; foo, q =&gt; baz, z =&gt; bird}</p> </div> <p>When the value for an existing key is updated, the key tuple is not updated, allowing the key tuple to be shared with other instances of the map that have the same keys. In fact, the key tuple can be shared between all maps with the same keys with some care. To arrange that, define a function that returns a map. For example:</p> <pre data-language="erlang">new() -&gt;
    #{a =&gt; default, b =&gt; default, c =&gt; default}.</pre> <p>Defined like this, the key tuple <code>{a,b,c}</code> will be a global literal. To ensure that the key tuple is shared when creating an instance of the map, always call <code>new()</code> and modify the returned map:</p> <pre data-language="erlang">(SOME_MODULE:new())#{a := 42}.</pre> <p>Using the map syntax with small maps is particularly efficient. As long as the keys are known at compile-time, the map is updated in one go, making the time to update a map essentially constant regardless of the number of keys updated. The same goes for matching. (When the keys are variables, one or more of the keys could be identical, so the operations need to be performed sequentially from left to right.)</p> <p>The memory size for a small map is the size of all keys and values plus 5 words. See <code><a href="advanced.html#memory">Advanced</a></code> for more information about memory sizes.</p> <h3 id="how-large-maps-are-implemented" class="title-link"> <div class="title-name">How Large Maps are Implemented</div>  </h3> <p>A map with more than 32 elements is implemented as a <code><a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">Hash array mapped trie (HAMT)</a></code>. A large map can be efficiently searched and updated regardless of the number of elements in the map.</p> <p>There is less performance to be gained by matching or updating multiple elements using the map syntax on a large map compared to a small map. The execution time is roughly proportional to the number of elements matched or updated.</p> <p>The storage overhead for a large map is higher than for a small map. For a large map, the extra number of words besides the keys and values is roughly proportional to the number of elements. For a map with 33 elements the overhead is at least 53 heap words according to the formula in <code><a href="advanced.html#memory">Advanced</a></code> (compared to 5 extra words for a small map regardless of the number of elements).</p> <p>When a large map is updated, the updated map and the original map will share common parts of the HAMT, but sharing will never be as effective as the best possible sharing of the key tuple for small maps.</p> <p>Therefore, if maps are used instead of records and it is expected that many instances of the map will be created, it is more efficient from a memory standpoint to avoid using large maps (for example, by grouping related map elements into sub maps to reduce the number of elements).</p> <h2 id="using-the-map-syntax" class="title-link"> <div class="title-name">5.6 Using the Map Syntax</div>  </h2> <p>Using the map syntax is usually slightly more efficient than using the corresponding function in the <code>maps</code> module.</p> <p>The gain in efficiency for the map syntax is more noticeable for the following operations that can only be achieved using the map syntax:</p> <ul> <li><p>Matching multiple literal keys</p></li> <li><p>Updating multiple literal keys</p></li> <li><p>Adding multiple literal keys to a map</p></li> </ul> <p>For example:</p> <p><strong>DO</strong></p> <pre data-language="erlang">Map = Map1#{x := X, y := Y, z := Z}</pre> <p><strong>DO NOT</strong></p> <pre data-language="erlang">Map2 = maps:update(x, X, Map1),
Map3 = maps:update(y, Y, Map2),
Map = maps:update(z, Z, Map3)</pre> <p>If the map is a small map, the first example runs roughly three times as fast.</p> <p>Note that for variable keys, the elements are updated sequentially from left to right. For example, given the following update with variable keys:</p> <pre data-language="erlang">Map = Map1#{Key1 := X, Key2 := Y, Key3 := Z}</pre> <p>the compiler rewrites it like this to ensure that the updates are applied from left to right:</p> <pre data-language="erlang">Map2 = Map1#{Key1 := X},
Map3 = Map2#{Key2 := Y},
Map = Map3#{Key3 := Z}</pre> <p>If a key is known to exist in a map, using the <code>:=</code> operator is slightly more efficient than using the <code>=&gt;</code> operator for a small map.</p> <h2 id="using-the-functions-in-the-maps-module" class="title-link"> <div class="title-name">5.7 Using the Functions in the maps Module</div>  </h2> <p>Here follows some notes about most of the functions in the <code>maps</code> module. For each function, the implementation language (C or Erlang) is stated. The reason we mention the language is that it gives an hint about how efficient the function is:</p> <ul> <li><p>If a function is implemented in C, it is pretty much impossible to implement the same functionality more efficiently in Erlang.</p></li> <li> <p>However, it might be possible to beat the <code>maps</code> modules functions implemented in Erlang, because they are generally implemented in a way that attempts to make the performance reasonable for all possible inputs.</p> <p>For example, <code>maps:map/2</code> iterates over all elements of the map, calling the mapping fun, collects the updated map elements in a list, and finally converts the list back to a map using <code>maps:from_list/1</code>. If it is known that at most one percent of the values in the map will change, it can be more efficient to update only the changed values.</p> </li> </ul> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The implementation details given in this section can change in the future.</p>
</div> </div> <h3 id="maps-filter-2" class="title-link"> <div class="title-name">maps:filter/2</div>  </h3> <p><code>maps:filter/2</code> is implemented in Erlang. It creates a new map using <code>maps:from_list/1</code>. If it is known that only a minority of the values will be removed, it can be more efficient to avoid <code>maps:filter/2</code> and write a function that will use <code>maps:remove/3</code> to remove the unwanted values.</p> <h3 id="maps-filtermap-2" class="title-link"> <div class="title-name">maps:filtermap/2</div>  </h3> <p><code>maps:filtermap/2</code> is implemented in Erlang. It creates a new map using <code>maps:from_list/1</code>. See the notes for <code>maps:map/2</code> and <code>maps:filter/2</code> for hints on how to implement a more efficient version.</p> <h3 id="maps-find-2" class="title-link"> <div class="title-name">maps:find/2</div>  </h3> <p><code>maps:find/2</code> is implemented in C.</p> <p>Using the map matching syntax instead of <code>maps:find/2</code> will be slightly more efficient since building an <code>{ok,Value}</code> tuple will be avoided.</p> <h3 id="maps-get-2" class="title-link"> <div class="title-name">maps:get/2</div>  </h3> <p>As an optimization, the compiler will rewrite a call to <code>maps:get/2</code> to a call to the guard BIF <code>map_get/2</code>. A call to a guard BIF is more efficient than calls to other BIFs, making the performance similar to using the map matching syntax.</p> <p>If the map is small and the keys are constants known at compile-time, using the map matching syntax will be more efficient than multiple calls to <code>maps:get/2</code>.</p> <h3 id="maps-get-3" class="title-link"> <div class="title-name">maps:get/3</div>  </h3> <p>As an optimization, the compiler will rewrite a call to <code>maps:get/3</code> to Erlang code similar to the following:</p> <pre data-language="erlang">Result = case Map of
             #{Key := Value} -&gt; Value;
             #{} -&gt; Default
         end</pre> <p>This is reasonably efficient, but if a small map is used as an alternative to using a record it is often better not to rely on default values as it prevents sharing of keys, which may in the end use more memory than what you save from not storing default values in the map.</p> <p>If default values are nevertheless required, instead of calling <code>maps:get/3</code> multiple times, consider putting the default values in a map and merging that map with the other map:</p> <pre data-language="erlang">DefaultMap = #{Key1 =&gt; Value2, Key2 =&gt; Value2, ..., KeyN =&gt; ValueN},
MapWithDefaultsApplied = maps:merge(DefaultMap, OtherMap)</pre> <p>This helps share keys between the default map and the one you applied defaults to, as long as the default map contains <strong>all</strong> the keys that will ever be used and not just the ones with default values. Whether this is faster than calling <code>maps:get/3</code> multiple times depends on the size of the map and the number of default values.</p> <div class="change"> <div class="label">Change</div> <div class="content">

<p> Before OTP 26.0 <code>maps:get/3</code> was implemented by calling the function instead of rewriting it as an Erlang expression. It is now slightly faster but can no longer be traced. </p> </div> </div> <h3 id="maps-intersect-2,-maps-intersect_with-3" class="title-link"> <div class="title-name">maps:intersect/2, maps:intersect_with/3</div>  </h3> <p><code>maps:intersect/2</code> and <code>maps:intersect_with/3</code> are implemented in Erlang. They both create new maps using <code>maps:from_list/1</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>A map is usually the most efficient way to implement a set, but an exception is the intersection operation, where <code>ordsets:intersection/2</code> used on <code>ordsets</code> can be more efficient than <code>maps:intersect/2</code> on sets implemented as maps.</p>
</div> </div> <h3 id="maps-from_list-1" class="title-link"> <div class="title-name">maps:from_list/1</div>  </h3> <p><code>maps:from_list/1</code> is implemented in C.</p> <h3 id="maps-from_keys-2" class="title-link"> <div class="title-name">maps:from_keys/2</div>  </h3> <p><code>maps:from_keys/2</code> is implemented in C.</p> <h3 id="maps-is_key-2" class="title-link"> <div class="title-name">maps:is_key/2</div>  </h3> <p>As an optimization, the compiler rewrites calls to <code>maps:is_key/2</code> to calls to the guard BIF <code>is_map_key/2</code>. A call to a guard BIF is more efficient than calls to other BIFs, making the performance similar to using the map matching syntax.</p> <h3 id="maps-iterator-1" class="title-link"> <div class="title-name">maps:iterator/1</div>  </h3> <p><code>maps:iterator/1</code> is efficiently implemented in C and Erlang.</p> <h3 id="maps-keys-1" class="title-link"> <div class="title-name">maps:keys/1</div>  </h3> <p><code>maps:keys/1</code> is implemented in C. If the resulting list needs to be ordered, use <code>lists:sort/1</code> to sort the result.</p> <h3 id="maps-map-2" class="title-link"> <div class="title-name">maps:map/2</div>  </h3> <p><code>maps:map/2</code> is implemented in Erlang. It creates a new map using <code>maps:from_list/1</code>. If it is known that only a minority of the values will be updated, it can be more efficient to avoid <code>maps:map/2</code> and write a function that will call <code>maps:update/3</code> to update only the values that have changed.</p> <h3 id="maps-merge-2" class="title-link"> <div class="title-name">maps:merge/2</div>  </h3> <p><code>maps:merge/2</code> is implemented in C. For <code><a href="#terminology">small maps</a></code>, the key tuple may be shared with any of the argument maps if that argument map contains all the keys. Literal key tuples are prefered if possible.</p> <div class="change"> <div class="label">Change</div> <div class="content">

<p> The sharing of key tuples by <code>maps:merge/2</code> was introduced in OTP 26.0. Older versions always contructed a new key tuple on the callers heap. </p> </div> </div> <h3 id="maps-merge_with-3" class="title-link"> <div class="title-name">maps:merge_with/3</div>  </h3> <p><code>maps:merge_with/3</code> is implemented in Erlang. It updates and returns the larger of the two maps.</p> <h3 id="maps-new-0" class="title-link"> <div class="title-name">maps:new/0</div>  </h3> <p>The compiler rewrites a call to <code>maps:new/0</code> to using the syntax <code>#{}</code> for constructing an empty map.</p> <h3 id="maps-next-1" class="title-link"> <div class="title-name">maps:next/1</div>  </h3> <p><code>maps:next/1</code> is efficiently implemented in C and Erlang.</p> <h3 id="maps-put-3" class="title-link"> <div class="title-name">maps:put/3</div>  </h3> <p><code>maps:put/3</code> is implemented in C.</p> <p>If the key is known to already exist in the map, <code>maps:update/3</code> is slightly more efficient than <code>maps:put/3</code>.</p> <p>If the keys are constants known at compile-time, using the map update syntax with the <code>=&gt;</code> operator is more efficient than multiple calls to <code>maps:put/3</code>, especially for small maps.</p> <h3 id="maps-remove-2" class="title-link"> <div class="title-name">maps:remove/2</div>  </h3> <p><code>maps:remove/2</code> is implemented in C.</p> <h3 id="maps-size-1" class="title-link"> <div class="title-name">maps:size/1</div>  </h3> <p>As an optimization, the compiler rewrites calls to <code>maps:size/1</code> to calls to the guard BIF <code>map_size/1</code>. Calls to guard BIFs are more efficient than calls to other BIFs.</p> <h3 id="maps-take-2" class="title-link"> <div class="title-name">maps:take/2</div>  </h3> <p><code>maps:take/2</code> is implemented in C.</p> <h3 id="maps-to_list-1" class="title-link"> <div class="title-name">maps:to_list/1</div>  </h3> <p><code>maps:to_list/1</code> is efficiently implemented in C and Erlang. If the resulting list needs to be ordered, use <code>lists:sort/1</code> to sort the result.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Maps are usually more performant than <code>gb_trees</code>, but if it is necessary to frequently convert to and from sorted lists, <code>gb_trees</code> can be a better choice.</p>
</div> </div> <h3 id="maps-update-3" class="title-link"> <div class="title-name">maps:update/3</div>  </h3> <p><code>maps:update/3</code> is implemented in C.</p> <p>If the keys are constants known at compile-time, using the map update syntax with the <code>:=</code> operator is more efficient than multiple calls to <code>maps:update/3</code>, especially for <code><a href="#terminology">small maps</a></code>.</p> <h3 id="maps-values-1" class="title-link"> <div class="title-name">maps:values/1</div>  </h3> <p><code>maps:values/1</code> is implemented in C.</p> <h3 id="maps-with-2" class="title-link"> <div class="title-name">maps:with/2</div>  </h3> <p><code>maps:with/2</code> is implemented in Erlang. It creates a new map using <code>maps:from_list/1</code>.</p> <h3 id="maps-without-2" class="title-link"> <div class="title-name">maps:without/2</div>  </h3> <p><code>maps:without/2</code> is implemented in Erlang. It returns a modified copy of the input map.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
