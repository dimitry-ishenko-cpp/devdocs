<div class="innertube"> <h1 id="Distributed Erlang">15 Distributed Erlang</h1> <h2 id="distributed-erlang-system" class="title-link"> <div class="title-name">15.1 Distributed Erlang System</div>  </h2> <p>A <strong>distributed Erlang system</strong> consists of a number of Erlang runtime systems communicating with each other. Each such runtime system is called a <strong>node</strong>. Message passing between processes at different nodes, as well as links and monitors, are transparent when pids are used. Registered names, however, are local to each node. This means that the node must be specified as well when sending messages, and so on, using registered names.</p> <p>The distribution mechanism is implemented using TCP/IP sockets. How to implement an alternative carrier is described in the <code>ERTS User's Guide</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> Starting a distributed node without also specifying <code>-proto_dist inet_tls</code> will expose the node to attacks that may give the attacker complete access to the node and in extension the cluster. When using un-secure distributed nodes, make sure that the network is configured to keep potential attackers out. See the <code> Using SSL for Erlang Distribution</code> User's Guide for details on how to setup a secure distributed node. </p> </div> </div> <h2 id="nodes" class="title-link"> <div class="title-name">15.2 Nodes</div>  </h2> <p> A <strong>node</strong> is an executing Erlang runtime system that has been given a name, using the command-line flag <code>-name</code> (long names) or <code>-sname</code> (short names). </p> <p>The format of the node name is an atom <code>name@host</code>. <code>name</code> is the name given by the user. <code>host</code> is the full host name if long names are used, or the first part of the host name if short names are used. Function <code>node()</code> returns the name of the node.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
% <code>erl -name dilbert</code>
(dilbert@uab.ericsson.se)1&gt; <code>node().</code>
'dilbert@uab.ericsson.se'

% <code>erl -sname dilbert</code>
(dilbert@uab)1&gt; <code>node().</code>
dilbert@uab</pre> <p> The node name can also be given in runtime by calling <code>net_kernel:start/1</code>. </p> <p><strong>Example:</strong></p> <pre data-language="erlang">
% <code>erl</code>
1&gt; <code>node().</code>
nonode@nohost
2&gt; <code>net_kernel:start([dilbert,shortnames]).</code>
{ok,&lt;0.102.0&gt;}
(dilbert@uab)3&gt; <code>node().</code>
dilbert@uab</pre> <div class="note"> <div class="label">Note</div> <div class="content">

<p>A node with a long node name cannot communicate with a node with a short node name.</p> </div> </div> <h2 id="node-connections" class="title-link"> <div class="title-name">15.3 Node Connections</div>  </h2> <p>The nodes in a distributed Erlang system are loosely connected. The first time the name of another node is used, for example, if <code>spawn(Node,M,F,A)</code> or <code>net_adm:ping(Node)</code> is called, a connection attempt to that node is made.</p> <p>Connections are by default transitive. If a node A connects to node B, and node B has a connection to node C, then node A also tries to connect to node C. This feature can be turned off by using the command-line flag <code>-connect_all false</code>, see the <code>erl(1)</code> manual page in ERTS.</p> <p>If a node goes down, all connections to that node are removed. Calling <code>erlang:disconnect_node(Node)</code> forces disconnection of a node.</p> <p>The list of (visible) nodes currently connected to is returned by <code>nodes()</code>.</p> <h2 id="epmd" class="title-link"> <div class="title-name">15.4 epmd</div>  </h2> <p>The Erlang Port Mapper Daemon <strong>epmd</strong> is automatically started at every host where an Erlang node is started. It is responsible for mapping the symbolic node names to machine addresses. See the <code>epmd(1)</code> manual page in ERTS.</p> <h2 id="hidden-nodes" class="title-link"> <div class="title-name">15.5 Hidden Nodes</div>  </h2> <p>In a distributed Erlang system, it is sometimes useful to connect to a node without also connecting to all other nodes. An example is some kind of O&amp;M functionality used to inspect the status of a system, without disturbing it. For this purpose, a <strong>hidden node</strong> can be used.</p> <p>A hidden node is a node started with the command-line flag <code>-hidden</code>. Connections between hidden nodes and other nodes are not transitive, they must be set up explicitly. Also, hidden nodes does not show up in the list of nodes returned by <code>nodes()</code>. Instead, <code>nodes(hidden)</code> or <code>nodes(connected)</code> must be used. This means, for example, that the hidden node is not added to the set of nodes that <code>global</code> is keeping track of.</p> <h2 id="dynamic-node-name" class="title-link"> <div class="title-name">15.6 Dynamic Node Name</div>  </h2> <p> If the node name is set to <strong><code>undefined</code></strong> the node will be started in a special mode to be the temporary client of another node. The node will then request a dynamic node name from the first node it connects to. In addition these distribution settings will be set: </p> <pre data-language="erlang"><code>-dist_listen false</code> <code>-hidden</code> <code>-kernel dist_auto_connect never</code></pre> <p> As <code>-dist_auto_connect</code> is set to <code>never</code>, <code>net_kernel:connect_node/1</code> must be called in order to setup connections. If the first established connection is closed (which gave the node its dynamic name), then any other connections will also be closed and the node will lose its dynamic node name. A new call to <code>net_kernel:connect_node/1</code> can be made to get a new dynamic node name. The node name may change if the distribution is dropped and then set up again. </p> <div class="change"> <div class="label">Change</div> <div class="content">

<p> The <strong>dynamic node name</strong> feature is supported from Erlang/OTP 23. Both the temporary client node and the first connected peer node (supplying the dynamic node name) must be at least Erlang/OTP 23 for it to work. </p> </div> </div> <h2 id="c-nodes" class="title-link"> <div class="title-name">15.7 C Nodes</div>  </h2> <p>A <strong>C node</strong> is a C program written to act as a hidden node in a distributed Erlang system. The library <strong>Erl_Interface</strong> contains functions for this purpose. For more information about C nodes, see the <code> Erl_Interface</code> application and <code> Interoperability Tutorial.</code>.</p> <h2 id="security" class="title-link"> <div class="title-name">15.8 Security</div>  </h2> <div class="note"> <div class="label">Note</div> <div class="content">

<p> "Security" here does <strong>not</strong> mean cryptographically secure, but rather security against accidental misuse, such as preventing a node from connecting to a cluster with which it is not intended to communicate. </p> <p> Furthermore, the communication between nodes is per default in clear text. If you need strong security, please see <code> Using TLS for Erlang Distribution </code> in the SSL application's User's Guide. </p> <p> Also, the default random cookie mentioned in the following text is not very unpredictable. A better one can be generated using primitives in the <code>crypto</code> module, though this still does not make the initial handshake cryptographically secure. And inter-node communication is still in clear text. </p> </div> </div> <p>Authentication determines which nodes are allowed to communicate with each other. In a network of different Erlang nodes, it is built into the system at the lowest possible level. All nodes use a <strong>magic cookie</strong>, which is an Erlang atom, when connecting another node.</p> <p>During the connection setup, after node names have been exchanged, the magic cookies the nodes present to each other are compared. If they do not match, the connection is rejected. The cookies themselves are never transferred, instead they are compared using hashed challenges, although not in a cryptographically secure manner.</p> <p>At start-up, a node has a random atom assigned as its default magic cookie and the cookie of other nodes is assumed to be <code>nocookie</code>. The first action of the Erlang network authentication server (<code>auth</code>) is then to search for a file named <code>.erlang.cookie</code> in the <code> user's home directory</code> and then in <code> filename:basedir(user_config, "erlang")</code>. If none of the files exist, a <code>.erlang.cooke</code> file is created in the user's home directory. The UNIX permissions mode of the file is set to octal 400 (read-only by user) and its content is a random string. An atom <code>Cookie</code> is created from the contents of the file and the cookie of the local node is set to this using <code>erlang:set_cookie(Cookie)</code>. This sets the default cookie that the local node will use for all other nodes.</p> <p>Thus, groups of users with identical cookie files get Erlang nodes that can communicate freely since they use the same magic cookie. Users who want to run nodes where the cookie files are on different file systems must make certain that their cookie files are identical.</p> <p>For a node <code>Node1</code> using magic cookie <code>Cookie</code> to be able to connect to, and to accept a connection from, another node <code>Node2</code> that uses a different cookie <code>DiffCookie</code>, the function <code>erlang:set_cookie(Node2, DiffCookie)</code> must first be called at <code>Node1</code>. Distributed systems with multiple home directories (differing cookie files) can be handled in this way.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>With this setup <code>Node1</code> and <code>Node2</code> agree on which cookie to use: <code>Node1</code> uses its explicitly configured <code>DiffCookie</code> for <code>Node2</code>, and <code>Node2</code> uses its default cookie <code>DiffCookie</code>.</p> <p>You can also use a <code>DiffCookie</code> that neither <code>Node1</code> nor <code>Node2</code> has as its default cookie, if you also call <code>erlang:set_cookie(Node1, DiffCookie)</code> in <code>Node2</code> before establishing connection</p> <p>Because node names are exchanged during connection setup before cookies are selected, connection setup works regardless of which node that initiates it.</p> <p>Note that to configure <code>Node1</code> to use <code>Node2</code>'s default cookie when communicating with <code>Node2</code>, <strong>and vice versa</strong> results in a broken configuration (if the cookies are different) because then both nodes use the other node's (differing) cookie.</p> </div> </div> <p>The default when a connection is established between two nodes, is to immediately connect all other visible nodes as well. This way, there is always a fully connected network. If there are nodes with different cookies, this method can be inappropriate (since it may not be feasible to configure different cookies for all possible nodes) and the command-line flag <code>-connect_all false</code> must be set, see the <code>erl(1)</code> manual page in ERTS.</p> <p>The magic cookie of the local node can be retrieved by calling <code>erlang:get_cookie()</code>.</p> <h2 id="distribution-bifs" class="title-link"> <div class="title-name">15.9 Distribution BIFs</div>  </h2> <p>Some useful BIFs for distributed programming (for more information, see the <code> erlang(3)</code> manual page in ERTS:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>BIF</strong></td> <td><strong>Description</strong></td> </tr> <tr> <td><code>erlang:disconnect_node(Node)</code></td> <td>Forces the disconnection of a node.</td> </tr> <tr> <td><code>erlang:get_cookie()</code></td> <td>Returns the magic cookie of the current node.</td> </tr> <tr> <td><code>erlang:get_cookie(Node)</code></td> <td>Returns the magic cookie for node <code>Node</code>.</td> </tr> <tr> <td><code>is_alive()</code></td> <td>Returns <code>true</code> if the runtime system is a node and can connect to other nodes, <code>false</code> otherwise.</td> </tr> <tr> <td><code>monitor_node(Node, true|false)</code></td> <td>Monitors the status of <code>Node</code>. A message<code>{nodedown, Node}</code> is received if the connection to it is lost.</td> </tr> <tr> <td><code>node()</code></td> <td>Returns the name of the current node. Allowed in guards.</td> </tr> <tr> <td><code>node(Arg)</code></td> <td>Returns the node where <code>Arg</code>, a pid, reference, or port, is located.</td> </tr> <tr> <td><code>nodes()</code></td> <td>Returns a list of all visible nodes this node is connected to.</td> </tr> <tr> <td><code>nodes(Arg)</code></td> <td>Depending on <code>Arg</code>, this function can return a list not only of visible nodes, but also hidden nodes and previously known nodes, and so on.</td> </tr> <tr> <td><code>erlang:set_cookie(Cookie)</code></td> <td>Sets the magic cookie, <code>Cookie</code> to use when connecting all nodes that have no explicit cookie set with <code>erlang:set_cookie/2</code>.</td> </tr> <tr> <td><code>erlang:set_cookie(Node, Cookie)</code></td> <td>Sets the magic cookie used when connecting <code>Node</code>. If <code>Node</code> is the current node, <code>Cookie</code> is used when connecting all nodes that have no explicit cookie set with this function.</td> </tr> <tr> <td><code>spawn[_link|_opt](Node, Fun)</code></td> <td>Creates a process at a remote node.</td> </tr> <tr> <td><code>spawn[_link|opt](Node, Module, FunctionName, Args)</code></td> <td>Creates a process at a remote node.</td> </tr> </table> <p class="doc-table-caption">Table 15.1: Distribution BIFs</p> </div> <h2 id="distribution-command-line-flags" class="title-link"> <div class="title-name">15.10 Distribution Command-Line Flags</div>  </h2> <p>Examples of command-line flags used for distributed programming (for more information, see the <code>erl(1) </code> manual page in ERTS:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Command-Line Flag</strong></td> <td><strong>Description</strong></td> </tr> <tr> <td><code>-connect_all false</code></td> <td>Only explicit connection set-ups are used.</td> </tr> <tr> <td><code>-hidden</code></td> <td>Makes a node into a hidden node.</td> </tr> <tr> <td><code>-name Name</code></td> <td>Makes a runtime system into a node, using long node names.</td> </tr> <tr> <td><code>-setcookie Cookie</code></td> <td>Same as calling <code>erlang:set_cookie(Cookie)</code>.</td> </tr> <tr> <td><code>-setcookie Node Cookie</code></td> <td>Same as calling <code>erlang:set_cookie(Node, Cookie)</code>.</td> </tr> <tr> <td><code>-sname Name</code></td> <td>Makes a runtime system into a node, using short node names.</td> </tr> </table> <p class="doc-table-caption">Table 15.2: Distribution Command-Line Flags</p> </div> <h2 id="distribution-modules" class="title-link"> <div class="title-name">15.11 Distribution Modules</div>  </h2> <p>Examples of modules useful for distributed programming:</p> <p>In the Kernel application:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Module</strong></td> <td><strong>Description</strong></td> </tr> <tr> <td><code>global</code></td> <td>A global name registration facility.</td> </tr> <tr> <td><code>global_group</code></td> <td>Grouping nodes to global name registration groups.</td> </tr> <tr> <td><code>net_adm</code></td> <td>Various Erlang net administration routines.</td> </tr> <tr> <td><code>net_kernel</code></td> <td>Erlang networking kernel.</td> </tr> </table> <p class="doc-table-caption">Table 15.3: Kernel Modules Useful For Distribution.</p> </div> <p>In the STDLIB application:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Module</strong></td> <td><strong>Description</strong></td> </tr> <tr> <td><code>slave</code></td> <td>Start and control of slave nodes.</td> </tr> </table> <p class="doc-table-caption">Table 15.4: STDLIB Modules Useful For Distribution.</p> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
