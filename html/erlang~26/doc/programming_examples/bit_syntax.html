<div class="innertube"> <h1 id="Bit Syntax">4 Bit Syntax</h1> <h2 id="introduction" class="title-link"> <div class="title-name">4.1 Introduction</div>  </h2> <p>The complete specification for the bit syntax appears in the <code>Reference Manual</code>.</p> <p>In Erlang, a Bin is used for constructing binaries and matching binary patterns. A Bin is written with the following syntax:</p> <pre data-language="erlang">&lt;&lt;E1, E2, ... En&gt;&gt;</pre> <p>A Bin is a low-level sequence of bits or bytes. The purpose of a Bin is to enable construction of binaries:</p> <pre data-language="erlang">Bin = &lt;&lt;E1, E2, ... En&gt;&gt;</pre> <p>All elements must be bound. Or match a binary:</p> <pre data-language="erlang">&lt;&lt;E1, E2, ... En&gt;&gt; = Bin </pre> <p>Here, <code>Bin</code> is bound and the elements are bound or unbound, as in any match.</p> <p>A Bin does not need to consist of a whole number of bytes.</p> <p>A <strong>bitstring</strong> is a sequence of zero or more bits, where the number of bits does not need to be divisible by 8. If the number of bits is divisible by 8, the bitstring is also a binary.</p> <p>Each element specifies a certain <strong>segment</strong> of the bitstring. A segment is a set of contiguous bits of the binary (not necessarily on a byte boundary). The first element specifies the initial segment, the second element specifies the following segment, and so on.</p> <p>The following examples illustrate how binaries are constructed, or matched, and how elements and tails are specified.</p> <h3 id="examples" class="title-link"> <div class="title-name">Examples</div>  </h3> <p><strong>Example 1:</strong> A binary can be constructed from a set of constants or a string literal:</p> <pre data-language="erlang">Bin11 = &lt;&lt;1, 17, 42&gt;&gt;,
Bin12 = &lt;&lt;"abc"&gt;&gt;</pre> <p>This gives two binaries of size 3, with the following evaluations:</p> <ul> <li> <code>binary_to_list(Bin11)</code> evaluates to <code>[1, 17, 42]</code>.</li> <li> <code>binary_to_list(Bin12)</code> evaluates to <code>[97, 98, 99]</code>.</li> </ul> <p><strong>Example 2:</strong>Similarly, a binary can be constructed from a set of bound variables:</p> <pre data-language="erlang">A = 1, B = 17, C = 42,
Bin2 = &lt;&lt;A, B, C:16&gt;&gt;</pre> <p>This gives a binary of size 4. Here, a <strong>size expression</strong> is used for the variable <code>C</code> to specify a 16-bits segment of <code>Bin2</code>.</p> <p><code>binary_to_list(Bin2)</code> evaluates to <code>[1, 17, 00, 42]</code>.</p> <p><strong>Example 3:</strong> A Bin can also be used for matching. <code>D</code>, <code>E</code>, and <code>F</code> are unbound variables, and <code>Bin2</code> is bound, as in Example 2:</p> <pre data-language="erlang">&lt;&lt;D:16, E, F/binary&gt;&gt; = Bin2</pre> <p>This gives <code>D = 273</code>, <code>E = 00</code>, and F binds to a binary of size 1: <code>binary_to_list(F) = [42]</code>.</p> <p><strong>Example 4:</strong> The following is a more elaborate example of matching. Here, <code>Dgram</code> is bound to the consecutive bytes of an IP datagram of IP protocol version 4. The ambition is to extract the header and the data of the datagram:</p> <pre data-language="erlang">-define(IP_VERSION, 4).
-define(IP_MIN_HDR_LEN, 5).

DgramSize = byte_size(Dgram),
case Dgram of 
    &lt;&lt;?IP_VERSION:4, HLen:4, SrvcType:8, TotLen:16, 
      ID:16, Flgs:3, FragOff:13,
      TTL:8, Proto:8, HdrChkSum:16,
      SrcIP:32,
      DestIP:32, RestDgram/binary&gt;&gt; when HLen&gt;=5, 4*HLen=&lt;DgramSize -&gt;
        OptsLen = 4*(HLen - ?IP_MIN_HDR_LEN),
        &lt;&lt;Opts:OptsLen/binary,Data/binary&gt;&gt; = RestDgram,
    ...
end.</pre> <p>Here, the segment corresponding to the <code>Opts</code> variable has a <strong>type modifier</strong>, specifying that <code>Opts</code> is to bind to a binary. All other variables have the default type equal to unsigned integer.</p> <p>An IP datagram header is of variable length. This length is measured in the number of 32-bit words and is given in the segment corresponding to <code>HLen</code>. The minimum value of <code>HLen</code> is 5. It is the segment corresponding to <code>Opts</code> that is variable, so if <code>HLen</code> is equal to 5, <code>Opts</code> becomes an empty binary.</p> <p>The tail variables <code>RestDgram</code> and <code>Data</code> bind to binaries, as all tail variables do. Both can bind to empty binaries.</p> <p>The match of <code>Dgram</code> fails if one of the following occurs:</p> <ul> <li>The first 4-bits segment of <code>Dgram</code> is not equal to 4.</li> <li> <code>HLen</code> is less than 5.</li> <li>The size of <code>Dgram</code> is less than <code>4*HLen</code>.</li> </ul> <h2 id="lexical-note" class="title-link"> <div class="title-name">4.2 Lexical Note</div>  </h2> <p>Notice that "<code>B=&lt;&lt;1&gt;&gt;</code>" will be interpreted as "<code>B =&lt; &lt;1&gt;&gt;</code>", which is a syntax error. The correct way to write the expression is: <code>B = &lt;&lt;1&gt;&gt;</code>.</p> <h2 id="segments" class="title-link"> <div class="title-name">4.3 Segments</div>  </h2> <p>Each segment has the following general syntax:</p> <p><code>Value:Size/TypeSpecifierList</code></p> <p>The <code>Size</code> or the <code>TypeSpecifier</code>, or both, can be omitted. Thus, the following variants are allowed:</p> <ul> <li><code>Value</code></li> <li><code>Value:Size</code></li> <li><code>Value/TypeSpecifierList</code></li> </ul> <p>Default values are used when specifications are missing. The default values are described in <code><a href="#Defaults">Defaults</a></code>.</p> <p>The <code>Value</code> part is any expression, when used in binary construction. Used in binary matching, the <code>Value</code> part must be a literal or a variable. For more information about the <code>Value</code> part, see <code><a href="#Constructing%20Binaries%20and%20Bitstrings">Constructing Binaries and Bitstrings</a></code> and <code><a href="#Matching%20Binaries">Matching Binaries</a></code>.</p> <p>The <code>Size</code> part of the segment multiplied by the unit in <code>TypeSpecifierList</code> (described later) gives the number of bits for the segment. In construction, <code>Size</code> is any expression that evaluates to an integer. In matching, <code>Size</code> must be a constant expression or a variable.</p> <p>The <code>TypeSpecifierList</code> is a list of type specifiers separated by hyphens.</p> <dl> <dt class="title-link"><strong>Type</strong></dt> <dd>The most commonly used types are <code>integer</code>, <code>float</code>, and <code>binary</code>. See <code>Bit Syntax Expressions in the Reference Manual</code> for a complete description. </dd> <dt class="title-link"><strong>Signedness</strong></dt> <dd>The signedness specification can be either <code>signed</code> or <code>unsigned</code>. Notice that signedness only matters for matching.</dd> <dt class="title-link"><strong>Endianness</strong></dt> <dd>The endianness specification can be either <code>big</code>, <code>little</code>, or <code>native</code>. Native-endian means that the endian is resolved at load time, to be either big-endian or little-endian, depending on what is "native" for the CPU that the Erlang machine is run on.</dd> <dt class="title-link"><strong>Unit</strong></dt> <dd>The unit size is given as <code>unit:IntegerLiteral</code>. The allowed range is 1-256. It is multiplied by the <code>Size</code> specifier to give the effective size of the segment. The unit size specifies the alignment for binary segments without size.</dd> </dl> <p><strong>Example:</strong></p> <pre data-language="erlang">X:4/little-signed-integer-unit:8</pre> <p>This element has a total size of 4*8 = 32 bits, and it contains a signed integer in little-endian order.</p> <h2 id="defaults" class="title-link"> <div class="title-name">4.4 Defaults</div>  </h2> <h3 id="Defaults">
The default type for a segment is integer. The default type does not depend on the value, even if the value is a literal. For example, the default type in <code id="Defaults">&lt;&lt;3.14&gt;&gt;</code> is integer, not float.</h3> <p>The default <code>Size</code> depends on the type. For integer it is 8. For float it is 64. For binary it is all of the binary. In matching, this default value is only valid for the last element. All other binary elements in matching must have a size specification.</p> <p>The default unit depends on the type. For <code>integer</code>, <code>float</code>, and <code>bitstring</code> it is 1. For binary it is 8.</p> <p>The default signedness is <code>unsigned</code>.</p> <p>The default endianness is <code>big</code>.</p> <h2 id="constructing-binaries-and-bitstrings" class="title-link"> <div class="title-name">4.5 Constructing Binaries and Bitstrings</div>  </h2>  <p id="Constructing%20Binaries%20and%20Bitstrings">This section describes the rules for constructing binaries using the bit syntax. Unlike when constructing lists or tuples, the construction of a binary can fail with a <code>badarg</code> exception.</p> <p>There can be zero or more segments in a binary to be constructed. The expression <code>&lt;&lt;&gt;&gt;</code> constructs a zero length binary.</p> <p>Each segment in a binary can consist of zero or more bits. There are no alignment rules for individual segments of type <code>integer</code> and <code>float</code>. For binaries and bitstrings without size, the unit specifies the alignment. Since the default alignment for the <code>binary</code> type is 8, the size of a binary segment must be a multiple of 8 bits, that is, only whole bytes.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">&lt;&lt;Bin/binary,Bitstring/bitstring&gt;&gt;</pre> <p>The variable <code>Bin</code> must contain a whole number of bytes, because the <code>binary</code> type defaults to <code>unit:8</code>. A <code>badarg</code> exception is generated if <code>Bin</code> consist of, for example, 17 bits.</p> <p>The <code>Bitstring</code> variable can consist of any number of bits, for example, 0, 1, 8, 11, 17, 42, and so on. This is because the default <code>unit</code> for bitstrings is 1.</p> <p>For clarity, it is recommended not to change the unit size for binaries. Instead, use <code>binary</code> when you need byte alignment and <code>bitstring</code> when you need bit alignment.</p> <p>The following example successfully constructs a bitstring of 7 bits, provided that all of X and Y are integers:</p> <pre data-language="erlang">&lt;&lt;X:1,Y:6&gt;&gt;</pre> <p>As mentioned earlier, segments have the following general syntax:</p> <p><code>Value:Size/TypeSpecifierList</code></p> <p>When constructing binaries, <code>Value</code> and <code>Size</code> can be any Erlang expression. However, for syntactical reasons, both <code>Value</code> and <code>Size</code> must be enclosed in parenthesis if the expression consists of anything more than a single literal or a variable. The following gives a compiler syntax error:</p> <pre data-language="erlang">&lt;&lt;X+1:8&gt;&gt;</pre> <p>This expression must be rewritten into the following, to be accepted by the compiler:</p> <pre data-language="erlang">&lt;&lt;(X+1):8&gt;&gt;</pre> <h3 id="including-literal-strings" class="title-link"> <div class="title-name">Including Literal Strings</div>  </h3> <p>A literal string can be written instead of an element:</p> <pre data-language="erlang">&lt;&lt;"hello"&gt;&gt;</pre> <p>This is syntactic sugar for the following:</p> <pre data-language="erlang">&lt;&lt;$h,$e,$l,$l,$o&gt;&gt;</pre> <h2 id="matching-binaries" class="title-link"> <div class="title-name">4.6 Matching Binaries</div>  </h2>  <p id="Matching%20Binaries">This section describes the rules for matching binaries, using the bit syntax.</p> <p>There can be zero or more segments in a binary pattern. A binary pattern can occur wherever patterns are allowed, including inside other patterns. Binary patterns cannot be nested. The pattern <code>&lt;&lt;&gt;&gt;</code> matches a zero length binary.</p> <p>Each segment in a binary can consist of zero or more bits. A segment of type <code>binary</code> must have a size evenly divisible by 8 (or divisible by the unit size, if the unit size has been changed). A segment of type <code>bitstring</code> has no restrictions on the size. A segment of type <code>float</code> must have size 64 or 32.</p> <p>As mentioned earlier, segments have the following general syntax:</p> <p><code>Value:Size/TypeSpecifierList</code></p> <p>When matching <code>Value</code>, value must be either a variable or an integer, or a floating point literal. Expressions are not allowed.</p> <p><code>Size</code> must be a <code>guard expression</code>, which can use literals and previously bound variables. The following is not allowed:</p> <pre data-language="erlang">foo(N, &lt;&lt;X:N,T/binary&gt;&gt;) -&gt;
   {X,T}.</pre> <p>The two occurrences of <code>N</code> are not related. The compiler will complain that the <code>N</code> in the size field is unbound.</p> <p>The correct way to write this example is as follows:</p> <pre data-language="erlang">foo(N, Bin) -&gt;
   &lt;&lt;X:N,T/binary&gt;&gt; = Bin,
   {X,T}.</pre> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Before OTP 23, <code>Size</code> was restricted to be an integer or a variable bound to an integer.</p>
</div> </div> <h3 id="binding-and-using-a-size-variable" class="title-link"> <div class="title-name">Binding and Using a Size Variable</div>  </h3> <p>There is one exception to the rule that a variable that is used as size must be previously bound. It is possible to match and bind a variable, and use it as a size within the same binary pattern. For example:</p> <pre data-language="erlang">bar(&lt;&lt;Sz:8,Payload:Sz/binary-unit:8,Rest/binary&gt;&gt;) -&gt;
   {Payload,Rest}.</pre> <p>Here <code>Sz</code> is bound to the value in the first byte of the binary. <code>Sz</code> is then used at the number of bytes to match out as a binary.</p> <p>Starting in OTP 23, the size can be a guard expression:</p> <pre data-language="erlang">bar(&lt;&lt;Sz:8,Payload:((Sz-1)*8)/binary,Rest/binary&gt;&gt;) -&gt;
   {Payload,Rest}.</pre> <p>Here <code>Sz</code> is the combined size of the header and the payload, so we will need to subtract one byte to get the size of the payload.</p> <h3 id="getting-the-rest-of-the-binary-or-bitstring" class="title-link"> <div class="title-name">Getting the Rest of the Binary or Bitstring</div>  </h3> <p>To match out the rest of a binary, specify a binary field without size:</p> <pre data-language="erlang">foo(&lt;&lt;A:8,Rest/binary&gt;&gt;) -&gt;</pre> <p>The size of the tail must be evenly divisible by 8.</p> <p>To match out the rest of a bitstring, specify a field without size:</p> <pre data-language="erlang">foo(&lt;&lt;A:8,Rest/bitstring&gt;&gt;) -&gt;</pre> <p>There are no restrictions on the number of bits in the tail.</p> <h2 id="appending-to-a-binary" class="title-link"> <div class="title-name">4.7 Appending to a Binary</div>  </h2> <p>Appending to a binary in an efficient way can be done as follows:</p> <pre data-language="erlang">triples_to_bin(T) -&gt;
    triples_to_bin(T, &lt;&lt;&gt;&gt;).

triples_to_bin([{X,Y,Z} | T], Acc) -&gt;
    triples_to_bin(T, &lt;&lt;Acc/binary,X:32,Y:32,Z:32&gt;&gt;);
triples_to_bin([], Acc) -&gt; 
    Acc.</pre> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
