  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">cerl_clauses</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Utility functions for Core Erlang case/receive clauses.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>Utility functions for Core Erlang case/receive clauses.</p> <p>Syntax trees are defined in the module <code><a href="cerl.html">cerl</a></code>.</p> </div> </div></section> <section class="innertube"><h2 id="data-types" class="title-link"> data types  </h2> <div class="REFBODY rb-3">  <dl id="types"> <dt class="title-link"><strong>bindings() = [{<code id="type-bindings">cerl:cerl()</code>, <code>cerl:cerl()</code>}]</strong></dt>  <dt class="title-link"><strong>cerl() = <code id="type-cerl">cerl:cerl()</code></strong></dt>  <dt class="title-link"><strong>expr() = any | <code id="type-expr">cerl:cerl()</code></strong></dt>  <dt class="title-link"><strong>match_ret() = none | {true, <code id="type-match_ret"><a href="#type-bindings">bindings()</a></code>} | {false, <code><a href="#type-bindings">bindings()</a></code>}</strong></dt>  </dl> </div></section> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><div class="bold_code func-head"><h3 id="any_catchall-1" class="title-link">  <div class="title-name">any_catchall(Cs::[<code>cerl:cerl()</code>]) -&gt; boolean()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="any_catchall-1">Returns <code>true</code> if any of the abstract clauses in the list is a catch-all, otherwise <code>false</code>. See <code>is_catchall/1</code> for details.</p> <p>Note: each node in <code>Clauses</code> must have type <code>clause</code>.</p> <p><strong>See also:</strong> <code><a href="#is_catchall-1">is_catchall/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="eval_guard-1" class="title-link">  <div class="title-name">eval_guard(E::<code>cerl:cerl()</code>) -&gt; none | {value, term()}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="eval_guard-1">Tries to reduce a guard expression to a single constant value, if possible. The returned value is <code>{value, Term}</code> if the guard expression <code>Expr</code> always yields the constant value <code>Term</code>, and is otherwise <code>none</code>.</p> <p>Note that although guard expressions should only yield boolean values, this function does not guarantee that <code>Term</code> is either <code>true</code> or <code>false</code>. Also note that only simple constructs like let-expressions are examined recursively; general constant folding is not performed.</p> <p><strong>See also:</strong> <code><a href="#is_catchall-1">is_catchall/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="is_catchall-1" class="title-link">  <div class="title-name">is_catchall(C::<code>cerl:c_clause()</code>) -&gt; boolean()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="is_catchall-1">Returns <code>true</code> if an abstract clause is a catch-all, otherwise <code>false</code>. A clause is a catch-all if all its patterns are variables, and its guard expression always evaluates to <code>true</code>; cf. <code>eval_guard/1</code>.</p> <p>Note: <code>Clause</code> must have type <code>clause</code>.</p> <p><strong>See also:</strong> <code><a href="#any_catchall-1">any_catchall/1</a></code>, <code><a href="#eval_guard-1">eval_guard/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="match-2" class="title-link">  <div class="title-name">match(P::<code>cerl:cerl()</code>, E::<code><a href="#type-expr">expr()</a></code>) -&gt; <code><a href="#type-match_ret">match_ret()</a></code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="match-2">Matches a pattern against an expression. The returned value is <code>none</code> if a match is impossible, <code>{true, Bindings}</code> if <code>Pattern</code> definitely matches <code>Expr</code>, and <code>{false, Bindings}</code> if a match is not definite, but cannot be excluded. <code>Bindings</code> is then a list of pairs <code>{Var, SubExpr}</code>, associating each variable in the pattern with either the corresponding subexpression of <code>Expr</code>, or with the atom <code>any</code> if no matching subexpression exists. (Recall that variables may not be repeated in a Core Erlang pattern.) The list of bindings is given in innermost-first order; this should only be of interest if <code>Pattern</code> contains one or more alias patterns. If the returned value is <code>{true, []}</code>, it implies that the pattern and the expression are syntactically identical.</p> <p>Instead of a syntax tree, the atom <code>any</code> can be passed for <code>Expr</code> (or, more generally, be used for any subtree of <code>Expr</code>, in as much the abstract syntax tree implementation allows it); this means that it cannot be decided whether the pattern will match or not, and the corresponding variable bindings will all map to <code>any</code>. The typical use is for producing bindings for <code>receive</code> clauses.</p> <p>Note: Binary-syntax patterns are never structurally matched against binary-syntax expressions by this function.</p> <p>Examples: </p> <ul> <li><p>Matching a pattern "<code>{X, Y}</code>" against the expression "<code>{foo, f(Z)}</code>" yields <code>{true, Bindings}</code> where <code>Bindings</code> associates "<code>X</code>" with the subtree "<code>foo</code>" and "<code>Y</code>" with the subtree "<code>f(Z)</code>".</p></li> <li><p>Matching pattern "<code>{X, {bar, Y}}</code>" against expression "<code>{foo, f(Z)}</code>" yields <code>{false, Bindings}</code> where <code>Bindings</code> associates "<code>X</code>" with the subtree "<code>foo</code>" and "<code>Y</code>" with <code>any</code> (because it is not known if "<code>{foo, Y}</code>" might match the run-time value of "<code>f(Z)</code>" or not).</p></li> <li><p>Matching pattern "<code>{foo, bar}</code>" against expression "<code>{foo, f()}</code>" yields <code>{false, []}</code>, telling us that there might be a match, but we cannot deduce any bindings.</p></li> <li><p>Matching <code>{foo, X = {bar, Y}}</code> against expression "<code>{foo, {bar, baz}}</code>" yields <code>{true, Bindings}</code> where <code>Bindings</code> associates "<code>Y</code>" with "<code>baz</code>", and "<code>X</code>" with "<code>{bar, baz}</code>".</p></li> <li><p>Matching a pattern "<code>{X, Y}</code>" against <code>any</code> yields <code>{false, Bindings}</code> where <code>Bindings</code> associates both "<code>X</code>" and "<code>Y</code>" with <code>any</code>.</p></li> </ul> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="match_list-2" class="title-link">  <div class="title-name">match_list(Ps::[<code>cerl:cerl()</code>], Es::[<code><a href="#type-expr">expr()</a></code>]) -&gt; <code><a href="#type-match_ret">match_ret()</a></code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="match_list-2">Like <code>match/2</code>, but matching a sequence of patterns against a sequence of expressions. Passing an empty list for <code>Exprs</code> is equivalent to passing a list of <code>any</code> atoms of the same length as <code>Patterns</code>. </p> <p><strong>See also:</strong> <code><a href="#match-2">match/2</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="reduce-1" class="title-link">  <div class="title-name">reduce(Cs::[<code>cerl:c_clause()</code>]) -&gt; {true, {<code>cerl:c_clause()</code>, <code><a href="#type-bindings">bindings()</a></code>}} | {false, [<code>cerl:c_clause()</code>]}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="reduce-1">Equivalent to <code><a href="#reduce-2">reduce(Cs, [])</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="reduce-2" class="title-link">  <div class="title-name">reduce(Cs::[<code>cerl:c_clause()</code>], Es::[<code><a href="#type-expr">expr()</a></code>]) -&gt; {true, {<code>cerl:c_clause()</code>, <code><a href="#type-bindings">bindings()</a></code>}} | {false, [<code>cerl:c_clause()</code>]}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="reduce-2">Selects a single clause, if possible, or otherwise reduces the list of selectable clauses. The input is a list <code>Clauses</code> of abstract clauses (i.e., syntax trees of type <code>clause</code>), and a list of switch expressions <code>Exprs</code>. The function tries to uniquely select a single clause or discard unselectable clauses, with respect to the switch expressions. All abstract clauses in the list must have the same number of patterns. If <code>Exprs</code> is not the empty list, it must have the same length as the number of patterns in each clause; see <code>match_list/2</code> for details.</p> <p>A clause can only be selected if its guard expression always yields the atom <code>true</code>, and a clause whose guard expression always yields the atom <code>false</code> can never be selected. Other guard expressions are considered to have unknown value; cf. <code>eval_guard/1</code>.</p> <p>If a particular clause can be selected, the function returns <code>{true, {Clause, Bindings}}</code>, where <code>Clause</code> is the selected clause and <code>Bindings</code> is a list of pairs <code>{Var, SubExpr}</code> associating the variables occurring in the patterns of <code>Clause</code> with the corresponding subexpressions in <code>Exprs</code>. The list of bindings is given in innermost-first order; see the <code>match/2</code> function for details.</p> <p>If no clause could be definitely selected, the function returns <code>{false, NewClauses}</code>, where <code>NewClauses</code> is the list of entries in <code>Clauses</code> that remain after eliminating unselectable clauses, preserving the relative order.</p> <p><strong>See also:</strong> <code><a href="#eval_guard-1">eval_guard/1</a></code>, <code><a href="#match-2">match/2</a></code>, <code><a href="#match_list-2">match_list/2</a></code>.</p> </div></div></article> </div> Richard Carlsson carlsson.richard@gmail.com<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
