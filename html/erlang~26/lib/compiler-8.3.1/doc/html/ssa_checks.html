<div class="innertube"> <h1 id="BEAM SSA Checks">2 BEAM SSA Checks</h1> <p> While developing optimizations operating on the BEAM SSA it is often hard to check that various transforms have the intended effect. For example, unless a transform produces crashing code, it is hard to detect that the transform is broken. Likewise missing an optimization opportunity is also hard to detect. </p> <p> To simplify the creation of tests on BEAM SSA the compiler has an internal mode in which it parses and checks assertions on the structure and content of the produced BEAM SSA code. This is a short introduction to the syntax and semantics of the SSA checker functionality. </p> <h2 id="syntax" class="title-link"> <div class="title-name">2.1 Syntax</div>  </h2> <p> SSA checks are embedded in the source code as comments starting with with one of <code>%ssa%</code>, <code>%%ssa%</code> or <code>%%%ssa%</code>. This is a short introduction the syntax, for the full syntax please refer to the <code>ssa_check_when_clause</code> production in <code>erl_parse.yrl</code>. </p> <p> SSA checks can be placed inside any Erlang function, for example: </p> <pre data-language="erlang">t0() -&gt;
%ssa% () when post_ssa_opt -&gt;
%ssa%   ret(#{}).
  #{}.</pre> <p> will check that <code>t0/0</code> returns the literal <code>#{}</code>. If we want to check that a function returns its first formal parameter, we can write: </p> <pre data-language="erlang">t1(A, _B) -&gt;
%ssa% (X, _) when post_ssa_opt -&gt;
%ssa%   ret(X).
  A.</pre> <p> Note how we match the first formal parameter using <code>X</code>. The reason for having our own formal parameters for the SSA check, is that we don't want to introduce new identifiers at the Erlang level to support SSA-level checks. Consider if <code>t1/2</code> had been defined as <code>t1([A|As], B)</code> we would have had to introduce a new identifier for the aggregate value <code>[A|As]</code>. </p> <p> The full syntax for a SSA check clause is: </p> <pre data-language="erlang">&lt;expected-result&gt;? (&lt;formals&gt;) when &lt;pipeline-location&gt; -&gt; &lt;checks&gt; '.'</pre> <p> where <code>&lt;expected-result&gt;</code> can be one of <code>pass</code> (the check must succeed), <code>fail</code> and <code>xfail</code> (the check must fail). Omitting <code>&lt;expected-result&gt;</code> is parsed as an implicit <code>pass</code>. </p> <p> <code>&lt;formals&gt;</code> is a comma-separated list of variables. </p> <p> <code>&lt;pipeline-location&gt;</code> specifies when in the compiler pipeline to run the checks. For now the only supported value for <code>&lt;pipeline-location&gt;</code> is <code>post_ssa_opt</code> which runs the checks after the <code>ssa_opt</code> pass. </p> <p> <code>&lt;checks&gt;</code> is a comma-separated list of matches against the BEAM SSA code. For non-flow-control operations the syntax is: </p> <pre data-language="erlang">&lt;variable&gt; = &lt;operation&gt; ( &lt;arguments&gt; ) &lt;annotation&gt;?</pre> <p> where <code>&lt;operation&gt;</code> is the <code>#b_set.op</code> field from the internal SSA representation. BIFs are written as <code>bif:&lt;atom&gt;</code>. </p> <p> <code>&lt;arguments&gt;</code> is a comma-separated list of variables or literals. </p> <p> For flow control operations and labels, the syntax is as follows: </p> <pre data-language="erlang">br(&lt;bool&gt;, &lt;true-label&gt;, &lt;false-label&gt;)

switch(&lt;value&gt;, &lt;fail-label&gt;, [{&lt;label&gt;,&lt;value&gt;},...])

ret(&lt;value&gt;)

label &lt;value&gt;</pre> <p> where <code>&lt;value&gt;</code> is a literal or a variable. </p> <p> A check can also include an assertion on operation annotations. The assertion is written as a map-like pattern following the argument list, for example: </p> <pre data-language="erlang">t0() -&gt;
%ssa% () when post_ssa_opt -&gt;
%ssa% _ = call(fun return_int/0) { result_type =&gt; {t_integer,{17,17}},
%ssa%                              location =&gt; {_,32} },
%ssa% _ = call(fun return_tuple/0) {
%ssa%    result_type =&gt; {t_tuple,2,true,#{1 =&gt; {t_integer,{1,1}},
%ssa%                                     2 =&gt; {t_integer,{2,2}}}}
%ssa% }.
    X = return_int(),
    Y = return_tuple(),
    {X, Y}.</pre> <h2 id="semantics" class="title-link"> <div class="title-name">2.2 Semantics</div>  </h2> <p> When an SSA assertion is matched against the BEAM SSA for a function, patterns are applied sequentially. If the current pattern doesn't match, the checker tries with the next instruction. If the checker reaches the end of the SSA representation without having matched all patterns, the check is considered failed otherwise the assertion is considered successful. When a pattern is matched against an SSA operation, the values of variables already bound are considered and if the patterns matches, free variables introduced in the successfully matched pattern are bound to the values they have in the matched operation. </p> <h2 id="compiler-integration" class="title-link"> <div class="title-name">2.3 Compiler integration</div>  </h2> <p> The BEAM SSA checker is enabled by the compiler option <code>{check_ssa,post_ssa_opt}</code>. When enabled, a failed SSA assertion will be reported using the same mechanisms as an ordinary compilation error. </p> <h2 id="limitations" class="title-link"> <div class="title-name">2.4 Limitations</div>  </h2> <ul><li> Unbound variables are not allowed in the key-part of map literals nor in annotation assertions. </li></ul> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
