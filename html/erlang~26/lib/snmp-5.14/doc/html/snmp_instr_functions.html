<div class="innertube"> <h1 id="Instrumentation Functions">10 Instrumentation Functions</h1> <p>A user-defined instrumentation function for each object attaches the managed objects to real resources. This function is called by the agent on a <code>get</code> or <code>set</code> operation. The function could read some hardware register, perform a calculation, or whatever is necessary to implement the semantics associated with the conceptual variable. These functions must be written both for scalar variables and for tables. They are specified in the association file, which is a text file. In this file, the <code>OBJECT IDENTIFIER</code>, or symbolic name for each managed object, is associated with an Erlang tuple <code>{Module,</code><code>Function</code>, <code>ListOfExtraArguments}</code>. </p> <p>When a managed object is referenced in an SNMP operation, the associated <code>{Module, Function, ListOfExtraArguments}</code> is called. The function is applied to some standard arguments (for example, the operation type) and the extra arguments supplied by the user. </p> <p>Instrumentation functions must be written for <code>get</code> and <code>set</code> for scalar variables and tables, and for <code>get-next</code> for tables only. The <code>get-bulk</code> operation is translated into a series of calls to <code>get-next</code>. </p> <h2 id="instrumentation-functions" class="title-link"> <div class="title-name">10.1 Instrumentation Functions</div>  </h2> <p>The following sections describe how the instrumentation functions should be defined in Erlang for the different operations. In the following, <code>RowIndex</code> is a list of key values for the table, and <code>Column</code> is a column number. </p> <p>These functions are described in detail in <code><a href="snmp_def_instr_functions.html">Definition of Instrumentation Functions</a></code>. </p> <h3 id="new---delete-operations" class="title-link"> <div class="title-name">New / Delete Operations</div>  </h3> <p>For scalar variables: </p> <pre data-language="erlang">variable_access(new [, ExtraArg1, ...])
variable_access(delete [, ExtraArg1, ...])</pre> <p>For tables: </p> <pre data-language="erlang">table_access(new [, ExtraArg1, ...])
table_access(delete [, ExtraArg1, ...])</pre> <p>These functions are called for each object in an MIB when the MIB is unloaded or loaded, respectively.</p> <h3 id="get-operation" class="title-link"> <div class="title-name">Get Operation</div>  </h3> <p>For scalar variables: </p> <pre data-language="erlang">variable_access(get [, ExtraArg1, ...])</pre> <p>For tables: </p> <pre data-language="erlang">table_access(get,RowIndex,Cols [,ExtraArg1, ...])</pre> <p><code>Cols</code> is a list of <code>Column</code>. The agent will sort incoming variables so that all operations on one row (same index) will be supplied at the same time. The reason for this is that a database normally retrieves information row by row. </p> <p>These functions must return the current values of the associated variables.</p> <h3 id="set-operation" class="title-link"> <div class="title-name">Set Operation</div>  </h3> <p>For scalar variables: </p> <pre data-language="erlang">variable_access(set, NewValue [, ExtraArg1, ...])</pre> <p>For tables: </p> <pre data-language="erlang">table_access(set, RowIndex, Cols [, ExtraArg1,..])</pre> <p><code>Cols</code> is a list of tuples <code>{Column, NewValue}</code>. </p> <p>These functions returns <code>noError</code> if the assignment was successful, otherwise an error code.</p> <h3 id="is-set-ok-operation" class="title-link"> <div class="title-name">Is-set-ok Operation</div>  </h3> <p>As a complement to the <code>set</code> operation, it is possible to specify a test function. This function has the same syntax as the set operation above, except that the first argument is <code>is_set_ok</code> instead of <code>set</code>. This function is called before the variable is set. Its purpose is to ensure that it is permissible to set the variable to the new value.</p> <pre data-language="erlang">variable_access(is_set_ok, NewValue [, ExtraArg1, ...])</pre> <p>For tables: </p> <pre data-language="erlang">table_access(set, RowIndex, Cols [, ExtraArg1,..])</pre> <p><code>Cols</code> is a list of tuples <code>{Column, NewValue}</code>. </p> <h3 id="undo-operation" class="title-link"> <div class="title-name">Undo Operation</div>  </h3> <p>A function which has been called with <code>is_set_ok</code> will be called again, either with <code>set</code> if there was no error, or with <code>undo</code>, if an error occurred. In this way, resources can be reserved in the <code>is_set_ok</code> operation, released in the <code>undo</code> operation, or made permanent in the <code>set</code> operation.</p> <pre data-language="erlang">variable_access(undo, NewValue [, ExtraArg1, ...])</pre> <p>For tables: </p> <pre data-language="erlang">table_access(set, RowIndex, Cols [, ExtraArg1,..])</pre> <p><code>Cols</code> is a list of tuples <code>{Column, NewValue}</code>. </p> <h3 id="getnext-operation" class="title-link"> <div class="title-name">GetNext Operation</div>  </h3> <p>The GetNext Operation operation should only be defined for tables since the agent can find the next instance of plain variables in the MIB and call the instrumentation with the <code>get</code> operation. </p> <pre data-language="erlang">table_access(get_next, RowIndex, Cols [, ExtraArg1, ...])</pre> <p><code>Cols</code> is a list of integers, all greater than or equal to zero. This indicates that the instrumentation should find the next accessible instance. This function returns the tuple <code>{NextOid, NextValue}</code>, or <code>endOfTable</code>. <code>NextOid</code> should be the lexicographically next accessible instance of a managed object in the table. It should be a list of integers, where the first integer is the column, and the rest of the list is the indices for the next row. If <code>endOfTable</code> is returned, the agent continues to search for the next instance among the other variables and tables. </p> <p><code>RowIndex</code> may be an empty list, an incompletely specified row index, or the index for an unspecified row. </p> <p>This operation is best described with an example. </p> <h4>GetNext Example</h4> <p>A table called <code>myTable</code> has five columns. The first two are keys (not accessible), and the table has three rows. The instrumentation function for this table is called <code>my_table</code>.</p>  <div class="doc-image-wrapper" id="getnext1">  <p class="doc-image-caption">Figure 10.1: Contents of my_table</p> </div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>N/A means not accessible.</p> </div> </div> <p>The manager issues the following <code>getNext</code> request: </p> <pre data-language="erlang">getNext{ myTable.myTableEntry.3.1.1,
         myTable.myTableEntry.5.1.1 } </pre> <p>Since both operations involve the 1.1 index, this is transformed into one call to <code>my_table</code>: </p> <pre data-language="erlang">my_table(get_next, [1, 1], [3, 5])</pre> <p>In this call, <code>[1, 1]</code> is the <code>RowIndex</code>, where key 1 has value 1, and key 2 has value 1, and <code>[3, 5]</code> is the list of requested columns. The function should now return the lexicographically next elements: </p> <pre data-language="erlang">[{[3, 1, 2], d}, {[5, 1, 2], f}]</pre> <p>This is illustrated in the following table: </p>   <div class="doc-image-wrapper" id="getnext2">  <p class="doc-image-caption">Figure 10.2: GetNext from [3,1,1] and [5,1,1].</p> </div> <p>The manager now issues the following <code>getNext</code> request: </p> <pre data-language="erlang">getNext{ myTable.myTableEntry.3.2.1,
         myTable.myTableEntry.5.2.1 } </pre> <p>This is transformed into one call to <code>my_table</code>: </p> <pre data-language="erlang">my_table(get_next, [2, 1], [3, 5])</pre> <p>The function should now return: </p> <pre data-language="erlang">[{[4, 1, 1], b}, endOfTable]</pre> <p>This is illustrated in the following table: </p>   <div class="doc-image-wrapper" id="getnext3">  <p class="doc-image-caption">Figure 10.3: GetNext from [3,2,1] and [5,2,1].</p> </div> <p>The manager now issues the following <code>getNext</code> request: </p> <pre data-language="erlang">getNext{ myTable.myTableEntry.3.1.2,
         myTable.myTableEntry.4.1.2 } </pre> <p>This will be transform into one call to <code>my_table</code>: </p> <pre data-language="erlang">my_table(get_next, [1, 2], [3, 4])</pre> <p>The function should now return: </p> <pre data-language="erlang">[{[3, 2, 1], g}, {[5, 1, 1], c}]</pre> <p>This is illustrated in the following table: </p>   <div class="doc-image-wrapper" id="getnext4">  <p class="doc-image-caption">Figure 10.4: GetNext from [3,1,2] and [4,1,2].</p> </div> <p>The manager now issues the following <code>getNext</code> request: </p> <pre data-language="erlang">getNext{ myTable.myTableEntry,
         myTable.myTableEntry.1.3.2 } </pre> <p>This will be transform into two calls to <code>my_table</code>: </p> <pre data-language="erlang">my_table(get_next, [], [0]) and
my_table(get_next, [3, 2], [1])</pre> <p>The function should now return: </p> <pre data-language="erlang">[{[3, 1, 1], a}] and
[{[3, 1, 1], a}]</pre> <p>In both cases, the first accessible element in the table should be returned. As the key columns are not accessible, this means that the third column is the first row.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Normally, the functions described above behave exactly as shown, but they are free to perform other actions. For example, a get-request may have side effects such as setting some other variable, perhaps a global <code>lastAccessed</code> variable.</p> </div> </div> <h2 id="using-the-extraargument" class="title-link"> <div class="title-name">10.2 Using the ExtraArgument</div>  </h2> <p>The <code>ListOfExtraArguments</code> can be used to write generic functions. This list is appended to the standard arguments for each function. Consider two read-only variables for a device, <code>ipAdr</code> and <code>name</code> with object identifiers 1.1.23.4 and 1.1.7 respectively. To access these variables, one could implement the two Erlang functions <code>ip_access</code> and <code>name_access</code>, which will be in the MIB. The functions could be specified in a text file as follows: </p>  <pre data-language="erlang">{ipAdr, {my_module, ip_access, []}}.
% Or using the oid syntax for 'name'
{[1,1,7], {my_module, name_access, []}}.</pre> <p>The <code>ExtraArgument</code> parameter is the empty list. For example, when the agent receives a get-request for the <code>ipAdr</code> variable, a call will be made to <code>ip_access(get)</code>. The value returned by this function is the answer to the get-request. </p> <p>If <code>ip_access</code> and <code>name_access</code> are implemented similarly, we could write a <code>generic_access</code> function using the <code>ListOfExtraArguments</code>: </p> <pre data-language="erlang">{ipAdr, {my_module, generic_access, ['IPADR']}}.
% The mnemonic 'name' is more convenient than 1.1.7
{name, {my_module, generic_access, ['NAME']}}.</pre> <p>When the agent receives the same get-request as above, a call will be made to <code>generic_access(get,</code>'<code>IPADR')</code>. </p> <p>Yet another possibility, closer to the hardware, could be: </p> <pre data-language="erlang">{ipAdr, {my_module, generic_access, [16#2543]}}.
{name, {my_module, generic_access, [16#A2B3]}}.</pre> <h2 id="default-instrumentation" class="title-link"> <div class="title-name">10.3 Default Instrumentation</div>  </h2>  <p id="snmp_3">When the MIB definition work is finished, there are two major issues left. </p> <ul> <li>Implementing the MIB </li> <li>Implementing a Manager Application.</li> </ul> <p>Implementing an MIB can be a tedious task. Most probably, there is a need to test the agent before all tables and variables are implemented. In this case, the default instrumentation functions are useful. The toolkit can generate default instrumentation functions for variables as well as for tables. Consequently, a running prototype agent, which can handle <code>set</code>, <code>get</code>, <code>get-next</code> and table operations, is generated without any programming. </p> <p>The agent stores the values in an internal volatile database, which is based on the standard module <code>ets</code>. However, it is possible to let the MIB compiler generate functions which use an internal, persistent database, or the Mnesia DBMS. Refer to the Mnesia User Guide and the Reference Manual, section SNMP, module <code>snmp_generic</code> for more information. </p> <p>When parts of the MIB are implemented, you recompile it and continue on by using default functions. With this approach, the SNMP agent can be developed incrementally. </p> <p>The default instrumentation allows the application on the manager side to be developed and tested simultaneously with the agent. As soon as the ASN.1 file is completed, let the MIB compiler generate a default implementation and develop the management application from this. </p> <h3 id="table-operations" class="title-link"> <div class="title-name">Table Operations</div>  </h3> <p>The generation of default functions for tables works for tables which use the <code>RowStatus</code> textual convention from SNMPv2, defined in STANDARD-MIB and SNMPv2-TC. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>We strongly encourage the use of the <code>RowStatus</code> convention for every table that can be modified from the manager, even for newly designed SNMPv1 MIBs. In SNMPv1, everybody has invented their own scheme for emulating table operations, which has led to numerous inconsistencies. The convention in SNMPv2 is flexible and powerful and has been tested successfully. If the table is read only, no RowStatus column should be used. </p> </div> </div> <h2 id="atomic-set" class="title-link"> <div class="title-name">10.4 Atomic Set</div>  </h2> <p>In SNMP, the <code>set</code> operation is atomic. Either all variables which are specified in a <code>set</code> operation are changed, or none are changed. Therefore, the <code>set</code> operation is divided into two phases. In the first phase, the new value of each variable is checked against the definition of the variable in the MIB. The following definitions are checked: </p> <ul> <li>the type</li> <li>the length</li> <li>the range</li> <li>the variable is writable and within the MIB view. </li> </ul> <p>At the end of phase one, the user defined <code>is_set_ok</code> functions are called for each scalar variable, and for each group of table operations. </p> <p>If no error occurs, the second phase is performed. This phase calls the user defined <code>set</code> function for all variables. </p> <p>If an error occurs, either in the <code>is_set_ok</code> phase, or in the <code>set</code> phase, all functions which were called with <code>is_set_ok</code> but not <code>set</code>, are called with <code>undo</code>. </p> <p>There are limitations with this transaction mechanism. If complex dependencies exist between variables, for example between <code>month</code> and <code>day</code>, another mechanism is needed. Setting the date to 'Feb 31' can be avoided by a somewhat more generic transaction mechanism. You can continue and find more and more complex situations and construct an N-phase set-mechanism. This toolkit only contains a trivial mechanism. </p> <p>The most common application of transaction mechanisms is to keep row operations together. Since our agent sorts row operations, the mechanism implemented in combination with the RowStatus (particularly 'createAndWait' value) solve most problems elegantly. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
