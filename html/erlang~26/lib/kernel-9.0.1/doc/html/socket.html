  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">socket</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Socket interface.</div> <h2 id="since" class="title-link"> <div class="title-name">Since</div>  </h2> <div class="REFBODY module-since"> Module socket was introduced in OTP 22.0. </div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module provides an API for network socket. Functions are provided to create, delete and manipulate the sockets as well as sending and receiving data on them. </p> <p>The intent is that it shall be as "close as possible" to the OS level socket interface. The only significant addition is that some of the functions, e.g. <code><a href="#recv-3">recv/3</a></code>, have a time-out argument. </p>  <div class="note" id="asynchronous-call"> <div class="label">Note</div> <div class="content">

<p> Some functions allow for an <i>asynchronous</i> call. This is achieved by setting the <code>Timeout</code> argument to <code>nowait</code> or to a (<code><a href="socket.html#type-select_handle">select</a></code> or <code><a href="socket.html#type-completion_handle">completion</a></code>) <i>handle</i>. </p> <p> For instance, if calling the <code><a href="#recv-nowait">recv/3</a></code> function with Timeout set to <code>nowait</code> (<code>recv(Sock, 0, nowait)</code>) when there is actually nothing to read, it will return with either one of: </p> <dl>  <dd> <code>{completion,</code> <code><a href="#type-completion_info">CompletionInfo</a></code><code>}</code> </dd>  <dd> <code>{select,</code> <code><a href="#type-select_info">SelectInfo</a></code><code>}</code> </dd> </dl> <p> <code>CompletionInfo</code> contains the <code><a href="socket.html#type-completion_handle">CompletionHandle</a></code> and <code>SelectInfo</code> contains the <code><a href="socket.html#type-select_handle">SelectHandle</a></code>. </p> <p> We have two different implementations. One on <i>Unix</i> (<code>select</code>, based directly on the synchronous standard socket interface) and one on <i>Windows</i> (<code>completion</code>, based on the asynchronous I/O Completion Ports). </p> <p> These two implementations have a slightly different behaviour and message interface. </p> <p> The difference will only manifest for the user, if calls are made with the timeout argument set to 'nowait' (see above). </p> <p> When an completion message is received (<strong>with</strong> the result of the operation), that means that the operation (connect, send, recv, ...) has been <strong>completed</strong> (successfully or otherwise). When a select message is received, that only means that the operation <strong>can now be completed</strong>, via a call to, for instance, <code><a href="#connect-1">connect/1</a></code>. </p> <p>The completion message has the format:</p> <dl>  <dd><code>{'$socket', socket(), completion, {CompletionHandle, CompletionStatus}}</code></dd> </dl> <p>The select message has the format: </p> <dl>  <dd><code>{'$socket', socket(), select, SelectHandle}</code></dd> </dl> <p> Note that, on select "system", all other users are <strong>locked out</strong> until the 'current user' has called the function (<code>recv</code> for instance) and its return value shows that the operation has completed. Such an operation can also be cancelled with <code><a href="#cancel-2">cancel/2</a></code>. </p> <p> Instead of <code>Timeout = nowait</code> it is equivalent to create a <code><a href="socket.html#type-select_handle">SelectHandle</a></code> or <code><a href="socket.html#type-completion_handle">CompletionHandle</a></code> with <code>make_ref()</code> and give as <code>Timeout</code>. This will then be the <code>Handle</code> in the 'completion' or 'select' message, which enables a compiler optimization for receiving a message containing a newly created <code>reference()</code> (ignore the part of the message queue that had arrived before the the <code>reference()</code> was created). </p> <p>Another message the user must be prepared for (when making asynchronous calls) is the <code>abort</code> message:</p> <dl>  <dd><code>{'$socket', socket(), abort, Info}</code></dd> </dl> <p>This message indicates that the (asynchronous) operation has been aborted. If, for instance, the socket has been closed (by another process), <code>Info</code> will be <code>{SelectHandle, closed}</code>. </p> </div> </div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The Windows support has currently <strong>pre-release</strong> status. </p> <p>Support for IPv6 has been implemented but not <strong>fully</strong> tested. </p> <p>SCTP has only been partly implemented (and not tested). </p> </div> </div> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-invalid" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-invalid">invalid()</a> = {invalid, What :: term()}</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-domain" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-domain">domain()</a> = inet | inet6 | local | unspec</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> A lowercase <code>atom()</code> representing a protocol <strong>domain</strong> on the platform named <code>AF_*</code> (or <code>PF_*</code>). </p> <p> The calls <code><a href="#supports-0">supports()</a></code>, <code><a href="#is_supported-1"> is_supported(ipv6) </a></code> and <code><a href="#is_supported-1"> is_supported(local) </a></code> tells if the IPv6 protocol for the <code>inet6</code> protocol domain / address family, and if the <code>local</code> protocol domain / address family is supported by the platform's header files. </p> </div></div></article> <article class="data-types-body"><h3 id="type-type" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-type">type()</a> = stream | dgram | raw | rdm | seqpacket</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> A lowercase <code>atom()</code> representing a protocol <strong>type</strong> on the platform named <code>SOCK_*</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-protocol" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-protocol">protocol()</a> = atom()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> An <code>atom()</code> means any <strong>protocol</strong> as enumerated by the <code>C</code> library call <code>getprotoent()</code> on the platform, or at least the supported ones of <code>ip | ipv6 | tcp | udp | sctp</code>. </p> <p>See <code><a href="#open-3">open/2,3,4</a></code></p> <p> The call <code><a href="#supports-1">supports(protocols)</a></code> returns which protocols are supported, and <code><a href="#is_supported-2"> is_supported(protocols, Protocol) </a></code> tells if <code>Protocol</code> is among the enumerated. </p> </div></div></article> <article class="data-types-body"><h3 id="type-socket" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-socket">socket()</a> = {'$socket', <a href="#type-socket_handle">socket_handle()</a>}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>As returned by <code><a href="#open-1">open/1,2,3,4</a></code> and <code><a href="#accept-1">accept/1,2</a></code>.</p> </div></div></article> <article class="data-types-body"><h3 id="type-socket_handle" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-socket_handle">socket_handle()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>An opaque socket handle unique for the socket.</p></div></div></article> <article class="data-types-body"><h3 id="type-select_tag" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-select_tag">select_tag()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> A tag that describes the (select) operation, contained in the returned <code><a href="#type-select_info">select_info()</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-select_handle" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-select_handle">select_handle()</a> = reference()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> A <code>reference()</code> that uniquely identifies the (select) operation, contained in the returned <code><a href="#type-select_info">select_info()</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-select_info" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-select_info">select_info()</a> = 
 {select_info,
 SelectTag :: <a href="#type-select_tag">select_tag()</a>,
 SelectHandle :: <a href="#type-select_handle">select_handle()</a>}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Returned by an operation that requires the caller to wait for a <code><a href="#asynchronous-call">select message</a></code> containing the <code><a href="#type-select_handle">SelectHandle</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-completion_tag" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-completion_tag">completion_tag()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> A tag that describes the ongoing (completion) operation, contained in the returned <code><a href="#type-completion_info">completion_info()</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-completion_handle" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-completion_handle">completion_handle()</a> = reference()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> A <code>reference()</code> that uniquely identifies the (completion) operation, contained in the returned <code><a href="#type-completion_info">completion_info()</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-completion_info" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-completion_info">completion_info()</a> = 
 {completion_info,
 CompletionTag :: <a href="#type-completion_tag">completion_tag()</a>,
 CompletionHandle :: <a href="#type-completion_handle">completion_handle()</a>}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Returned by an operation that requires the caller to wait for a <code><a href="#asynchronous-call">completion message</a></code> containing the <code><a href="#type-completion_handle">CompletionHandle</a></code> <strong>and</strong> the result of the operation; the <code>CompletionStatus</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-info" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-info">info()</a> = 
 #{counters := #{atom() := integer() &gt;= 0},
 iov_max := integer() &gt;= 0,
 use_registry := boolean(),
 io_backend := #{name := atom()}}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> The smallest allowed <code>iov_max</code> value according to POSIX is <code>16</code>, but check your platform documentation to be sure. </p> </div></div></article> <article class="data-types-body"><h3 id="type-socket_counters" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-socket_counters">socket_counters()</a> = 
 #{read_byte := integer() &gt;= 0,
 read_fails := integer() &gt;= 0,
 read_pkg := integer() &gt;= 0,
 read_pkg_max := integer() &gt;= 0,
 read_tries := integer() &gt;= 0,
 read_waits := integer() &gt;= 0,
 write_byte := integer() &gt;= 0,
 write_fails := integer() &gt;= 0,
 write_pkg := integer() &gt;= 0,
 write_pkg_max := integer() &gt;= 0,
 write_tries := integer() &gt;= 0,
 write_waits := integer() &gt;= 0,
 sendfile =&gt; integer() &gt;= 0,
 sendfile_byte =&gt; integer() &gt;= 0,
 sendfile_fails =&gt; integer() &gt;= 0,
 sendfile_max =&gt; integer() &gt;= 0,
 sendfile_pkg =&gt; integer() &gt;= 0,
 sendfile_pkg_max =&gt; integer() &gt;= 0,
 sendfile_tries =&gt; integer() &gt;= 0,
 sendfile_waits =&gt; integer() &gt;= 0,
 acc_success := integer() &gt;= 0,
 acc_fails := integer() &gt;= 0,
 acc_tries := integer() &gt;= 0,
 acc_waits := integer() &gt;= 0}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-info_keys" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-info_keys">info_keys()</a> = 
 [domain | type | protocol | fd | owner | local_address |
 remote_address | recv | sent | state]</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Defines the information elements of the table(s) printed by the <code><a href="#i-0">i/0</a></code>, <code><a href="#i-1">i/1</a></code> and <code><a href="#i-2">i/2</a></code> functions. </p> </div></div></article> <article class="data-types-body"><h3 id="type-socket_info" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-socket_info">socket_info()</a> = 
 #{domain := <a href="#type-domain">domain()</a> | integer(),
 type := <a href="#type-type">type()</a> | integer(),
 protocol := <a href="#type-protocol">protocol()</a> | integer(),
 owner := pid(),
 ctype := normal | fromfd | {fromfd, integer()},
 counters := <a href="#type-socket_counters">socket_counters()</a>,
 num_readers := integer() &gt;= 0,
 num_writers := integer() &gt;= 0,
 num_acceptors := integer() &gt;= 0,
 writable := boolean(),
 readable := boolean(),
 rstates := [atom()],
 wstates := [atom()]}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-in_addr" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-in_addr">in_addr()</a> = {0..255, 0..255, 0..255, 0..255}</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-in6_addr" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-in6_addr">in6_addr()</a> = 
 {0..65535,
 0..65535,
 0..65535,
 0..65535,
 0..65535,
 0..65535,
 0..65535,
 0..65535}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-sockaddr" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-sockaddr">sockaddr()</a> = 
 <a href="#type-sockaddr_in">sockaddr_in()</a> |
 <a href="#type-sockaddr_in6">sockaddr_in6()</a> |
 <a href="#type-sockaddr_un">sockaddr_un()</a> |
 <a href="#type-sockaddr_ll">sockaddr_ll()</a> |
 <a href="#type-sockaddr_dl">sockaddr_dl()</a> |
 <a href="#type-sockaddr_unspec">sockaddr_unspec()</a> |
 <a href="#type-sockaddr_native">sockaddr_native()</a></code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-sockaddr_recv" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-sockaddr_recv">sockaddr_recv()</a> = <a href="#type-sockaddr">sockaddr()</a> | binary()</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-sockaddr_in" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-sockaddr_in">sockaddr_in()</a> = 
 #{family := inet,
 port := <a href="#type-port_number">port_number()</a>,
 addr := any | broadcast | loopback | <a href="#type-in_addr">in_addr()</a>}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-sockaddr_in6" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-sockaddr_in6">sockaddr_in6()</a> = 
 #{family := inet6,
 port := <a href="#type-port_number">port_number()</a>,
 addr := any | loopback | <a href="#type-in6_addr">in6_addr()</a>,
 flowinfo := <a href="#type-in6_flow_info">in6_flow_info()</a>,
 scope_id := <a href="#type-in6_scope_id">in6_scope_id()</a>}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-sockaddr_un" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-sockaddr_un">sockaddr_un()</a> = #{family := local, path := binary() | string()}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> The <code>path</code> element will always be a <code>binary</code> when returned from this module. When supplied to an API function in this module it may be a <code>string()</code>, which will be encoded into a binary according to the <code><a href="file.html#native_name_encoding-0"> native file name encoding </a></code> on the platform. </p> <p> A terminating zero character will be appended before the address path is given to the OS, and the terminating zero will be stripped before giving the address path to the caller. </p> <p> Linux's non-portable abstract socket address extension is handled by not doing any terminating zero processing in either direction, if the first byte of the address is zero. </p> </div></div></article> <article class="data-types-body"><h3 id="type-sockaddr_ll" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-sockaddr_ll">sockaddr_ll()</a> = 
 #{family := packet,
 protocol := integer() &gt;= 0,
 ifindex := integer(),
 pkttype := <a href="#type-packet_type">packet_type()</a>,
 hatype := <a href="#type-hatype">hatype()</a>,
 addr := binary()}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-sockaddr_dl" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-sockaddr_dl">sockaddr_dl()</a> = 
 #{family := link,
 index := integer() &gt;= 0,
 type := integer() &gt;= 0,
 nlen := integer() &gt;= 0,
 alen := integer() &gt;= 0,
 slen := integer() &gt;= 0,
 data := binary()}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-sockaddr_unspec" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-sockaddr_unspec">sockaddr_unspec()</a> = #{family := unspec, addr := binary()}</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-sockaddr_native" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-sockaddr_native">sockaddr_native()</a> = #{family := integer(), addr := binary()}</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-packet_type" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-packet_type">packet_type()</a> = 
 host | broadcast | multicast | otherhost | outgoing |
 loopback | user | kernel | fastroute |
 integer() &gt;= 0</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-hatype" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-hatype">hatype()</a> = 
 netrom | eether | ether | ax25 | pronet | chaos | ieee802 |
 arcnet | appletlk | dlci | atm | metricom | ieee1394 | eui64 |
 infiniband | tunnel | tunnel6 | loopback | localtlk | none |
 void |
 integer() &gt;= 0</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-port_number" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-port_number">port_number()</a> = 0..65535</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-in6_flow_info" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-in6_flow_info">in6_flow_info()</a> = 0..1048575</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-in6_scope_id" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-in6_scope_id">in6_scope_id()</a> = 0..4294967295</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-msg_flag" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-msg_flag">msg_flag()</a> = 
 cmsg_cloexec | confirm | ctrunc | dontroute | eor | errqueue |
 more | oob | peek | trunc</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Flags corresponding to the message flag constants on the platform. The flags are lowercase and the constants are uppercase with the prefix <code>MSG_</code>. </p> <p> Some flags are only used for sending, some only for receiving, some in received control messages, and some for several of these. Not all flags are supported on all platforms. See the platform's documentation, <code><a href="#supports-1">supports(msg_flags)</a></code>, and <code><a href="#is_supported-2">is_supported(msg_flags, MsgFlag)</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-level" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-level">level()</a> = socket | <a href="#type-protocol">protocol()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> The OS protocol levels for, for example, socket options and control messages, with the following names in the OS header files: </p> <dl> <dt class="title-link"><strong><code>socket</code></strong></dt> <dd> <code>SOL_SOCKET</code> with options named <code>SO_</code>*. </dd> <dt class="title-link"><strong><code>ip</code></strong></dt> <dd> <code>IPPROTO_IP</code> a.k.a <code>SOL_IP</code> with options named <code>IP_</code>*. </dd> <dt class="title-link"><strong><code>ipv6</code></strong></dt> <dd> <code>IPPROTO_IPV6</code> a.k.a <code>SOL_IPV6</code> with options named <code>IPV6_</code>*. </dd> <dt class="title-link"><strong><code>tcp</code></strong></dt> <dd> <code>IPPROTO_TCP</code> with options named <code>TCP_</code>*. </dd> <dt class="title-link"><strong><code>udp</code></strong></dt> <dd> <code>IPPROTO_UDP</code> with options named <code>UDP_</code>*. </dd> <dt class="title-link"><strong><code>sctp</code></strong></dt> <dd> <code>IPPROTO_SCTP</code> with options named <code>SCTP_</code>*. </dd> </dl> <p> There are many other possible protocols, but the ones above are those for which this socket library implements socket options and/or control messages. </p> <p> All protocols known to the OS are enumerated when the Erlang VM is started. See the OS man page for protocols(5). The protocol level 'socket' is always implemented as <code>SOL_SOCKET</code> and all the others mentioned in the list above are valid, if supported by the platform, enumerated or not. </p> <p> The calls <code><a href="#supports-0">supports()</a></code> and <code><a href="#is_supported-2"> is_supported(protocols, Protocol) </a></code> can be used to find out if protocols <code>ipv6</code> and/or <code>sctp</code> are supported according to the platform's header files. </p> </div></div></article> <article class="data-types-body"><h3 id="type-otp_socket_option" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-otp_socket_option">otp_socket_option()</a> = 
 debug | iow | controlling_process | rcvbuf | rcvctrlbuf |
 sndctrlbuf | meta | use_registry | fd | domain</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> These are socket options for the <code>otp</code> protocol level, that is <code>{otp, Name}</code> options, above all OS protocol levels. They affect Erlang/OTP's socket implementation. </p> <dl> <dt class="title-link"><strong><code>debug</code></strong></dt> <dd> <code>boolean()</code> - Activate debug printout.</dd> <dt class="title-link"><strong><code>iow</code></strong></dt> <dd> <code>boolean()</code> - Inform On Wrap of statistics counters. </dd> <dt class="title-link"><strong><code>controlling_process</code></strong></dt> <dd> <code>pid()</code> - The socket "owner". Only the current controlling process can set this option. </dd> <dt class="title-link"><strong><code>rcvbuf</code></strong></dt> <dd> <code>BufSize :: (default | integer()&gt;0) | {N :: integer()&gt;0, BufSize :: (default | integer()&gt;0)}</code> - Receive buffer size. The value <code>default</code> is only valid to <strong>set</strong>. <code>N</code> specifies the number of read attempts to do in a tight loop before assuming no more data is pending. </dd> <dt class="title-link"><strong><code>rcvctrlbuf</code></strong></dt> <dd> <code>BufSize :: (default | integer()&gt;0)</code> - Buffer size for received ancillary messages. The value <code>default</code> is only valid to <strong>set</strong>. </dd> <dt class="title-link"><strong><code>sndctrlbuf</code></strong></dt> <dd> <code>BufSize :: (default | integer()&gt;0)</code> - Buffer size for sent ancillary messages. The value <code>default</code> is only valid to <strong>set</strong>. </dd> <dt class="title-link"><strong><code>fd</code></strong></dt> <dd> <code>integer()</code> - Only valid to <strong>get</strong>. The OS protocol levels' socket descriptor. Functions <code><a href="#open-1">open/1,2</a></code> can be used to create a socket according to this module from an existing OS socket descriptor. </dd> <dt class="title-link"><strong><code>use_registry</code></strong></dt> <dd> <code>boolean()</code> - Only valid to <strong>get</strong>. The value is set when the socket is created with <code><a href="#open-2">open/2</a></code> or <code><a href="#open-4">open/4</a></code>. </dd> </dl> <p> Options not described here are intentionally undocumented and for Erlang/OTP internal use only. </p> </div></div></article> <article class="data-types-body"><h3 id="type-socket_option" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-socket_option">socket_option()</a> = 
 {Level :: socket,
 Opt ::
 acceptconn | acceptfilter | bindtodevice | broadcast |
 busy_poll | debug | domain | dontroute | error |
 keepalive | linger | mark | oobinline | passcred |
 peek_off | peercred | priority | protocol | rcvbuf |
 rcvbufforce | rcvlowat | rcvtimeo | reuseaddr |
 reuseport | rxq_ovfl | setfib | sndbuf | sndbufforce |
 sndlowat | sndtimeo | timestamp | type} |
 {Level :: ip,
 Opt ::
 add_membership | add_source_membership | block_source |
 dontfrag | drop_membership | drop_source_membership |
 freebind | hdrincl | minttl | msfilter | mtu |
 mtu_discover | multicast_all | multicast_if |
 multicast_loop | multicast_ttl | nodefrag | options |
 pktinfo | recvdstaddr | recverr | recvif | recvopts |
 recvorigdstaddr | recvtos | recvttl | retopts |
 router_alert | sndsrcaddr | tos | transparent | ttl |
 unblock_source} |
 {Level :: ipv6,
 Opt ::
 addrform | add_membership | authhdr | auth_level |
 checksum | drop_membership | dstopts | esp_trans_level |
 esp_network_level | faith | flowinfo | hopopts |
 ipcomp_level | join_group | leave_group | mtu |
 mtu_discover | multicast_hops | multicast_if |
 multicast_loop | portrange | pktoptions | recverr |
 recvhoplimit | hoplimit | recvpktinfo | pktinfo |
 recvtclass | router_alert | rthdr | tclass |
 unicast_hops | use_min_mtu | v6only} |
 {Level :: tcp,
 Opt ::
 congestion | cork | info | keepcnt | keepidle |
 keepintvl | maxseg | md5sig | nodelay | noopt | nopush |
 syncnt | user_timeout} |
 {Level :: udp, Opt :: cork} |
 {Level :: sctp,
 Opt ::
 adaption_layer | associnfo | auth_active_key |
 auth_asconf | auth_chunk | auth_key | auth_delete_key |
 autoclose | context | default_send_params |
 delayed_ack_time | disable_fragments | hmac_ident |
 events | explicit_eor | fragment_interleave |
 get_peer_addr_info | initmsg | i_want_mapped_v4_addr |
 local_auth_chunks | maxseg | maxburst | nodelay |
 partial_delivery_point | peer_addr_params |
 peer_auth_chunks | primary_addr | reset_streams |
 rtoinfo | set_peer_primary_addr | status |
 use_ext_recvinfo}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Socket option on the form <code>{Level, Opt}</code> where the OS protocol <code>Level</code> = <code><a href="#type-level">level()</a></code> and <code>Opt</code> is a socket option on that protocol level. </p> <p> The OS name for an options is, except where otherwise noted, the <code>Opt</code> atom, in capitals, with prefix according to <code><a href="#type-level">level()</a></code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The <code>IPv6</code> option <code>pktoptions</code> is a special (barf) case. It is intended for backward compatibility usage only. </p> <p>Do <strong>not</strong> use this option.</p> </div> </div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>See the OS documentation for every socket option.</p> </div> </div> <p> An option below that has the value type <code>boolean()</code> will translate the value <code>false</code> to a C <code>int</code> with value <code>0</code>, and the value <code>true</code> to <code>!!0</code> (not (not false)). </p> <p> An option with value type <code>integer()</code> will be translated to a C <code>int</code> that may have a restricted range, for example byte: <code>0..255</code>. See the OS documentation. </p> <p> The calls <code><a href="#supports-1">supports(options)</a></code>, <code><a href="#supports-1">supports(options, Level)</a></code> and <code><a href="#is_supported-2"> is_supported(options, {Level, Opt}) </a></code> can be used to find out which socket options that are supported by the platform. </p> <p> <strong>Options for protocol level</strong> <code><a href="#type-level"><strong>socket</strong>:</a></code> </p> <dl> <dt class="title-link"><strong><code>{socket, acceptconn}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{socket, bindtodevice}</code></strong></dt> <dd><p><code>Value = string()</code></p></dd> <dt class="title-link"><strong><code>{socket, broadcast}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{socket, debug}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{socket, domain}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-domain">domain()</a></code> </p> <p>Only valid to <strong>get</strong>.</p> <p> The socket's protocol domain. Does <strong>not</strong> work on for instance FreeBSD. </p> </dd> <dt class="title-link"><strong><code>{socket, dontroute}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{socket, keepalive}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{socket, linger}</code></strong></dt> <dd> <p> <code>Value = abort |</code> <code><a href="#type-linger">linger()</a></code> </p> <p> The value <code>abort</code> is shorthand for <code>#{onoff =&gt; true, linger =&gt; 0}</code>, and only valid to <strong>set</strong>. </p> </dd> <dt class="title-link"><strong><code>{socket, oobinline}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{socket, passcred}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{socket, peek_off}</code></strong></dt> <dd> <p><code>Value = integer()</code></p> <p> Currently disabled due to a possible infinite loop when calling <code><a href="#recv-1">recv/1-4</a></code> with <code><a href="#type-msg_flag">peek</a></code> in <code>Flags</code>. </p> </dd> <dt class="title-link"><strong><code>{socket, priority}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{socket, protocol}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-protocol">protocol()</a></code> </p> <p>Only valid to <strong>get</strong>.</p> <p> The socket's protocol. Does <strong>not</strong> work on for instance Darwin. </p> </dd> <dt class="title-link"><strong><code>{socket, rcvbuf}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{socket, rcvlowat}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{socket, rcvtimeo}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-timeval">timeval()</a></code> </p> <p> This option is unsupported per default; OTP has to be explicitly built with the <code>--enable-esock-rcvsndtimeo</code> configure option for this to be available. </p> <p> Since our implementation uses nonblocking sockets, it is unknown if and how this option works, or even if it may cause malfunction. Therefore, we do not recommend setting this option. </p> <p> Instead, use the <code>Timeout</code> argument to, for instance, the <code><a href="#recv-3">recv/3</a></code> function. </p> </dd> <dt class="title-link"><strong><code>{socket, reuseaddr}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{socket, reuseport}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{socket, sndbuf}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{socket, sndlowat}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{socket, sndtimeo}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-timeval">timeval()</a></code> </p> <p> This option is unsupported per default; OTP has to be explicitly built with the <code>--enable-esock-rcvsndtimeo</code> configure option for this to be available. </p> <p> Since our implementation uses nonblocking sockets, it is unknown if and how this option works, or even if it may cause malfunction. Therefore, we do not recommend setting this option. </p> <p> Instead, use the <code>Timeout</code> argument to, for instance, the <code><a href="#send-3">send/3</a></code> function. </p> </dd> <dt class="title-link"><strong><code>{socket, timestamp}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{socket, type}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-type">type()</a></code> </p> <p>Only valid to <strong>get</strong>.</p> <p>The socket's type.</p> </dd> </dl>  <p> <strong>Options for protocol level</strong> <code><a href="#type-level"><strong>ip</strong>:</a></code> </p> <dl> <dt class="title-link"><strong><code>{ip, add_membership}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ip_mreq">ip_mreq()</a></code> </p> <p>Only valid to <strong>set</strong>.</p> </dd> <dt class="title-link"><strong><code>{ip, add_source_membership}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ip_mreq_source"> ip_mreq_source() </a></code> </p> <p>Only valid to <strong>set</strong>.</p> </dd> <dt class="title-link"><strong><code>{ip, block_source}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ip_mreq_source"> ip_mreq_source() </a></code> </p> <p>Only valid to <strong>set</strong>.</p> </dd> <dt class="title-link"><strong><code>{ip, drop_membership}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ip_mreq">ip_mreq()</a></code> </p> <p>Only valid to <strong>set</strong>.</p> </dd> <dt class="title-link"><strong><code>{ip, drop_source_membership}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ip_mreq_source"> ip_mreq_source() </a></code> </p> <p>Only valid to <strong>set</strong>.</p> </dd> <dt class="title-link"><strong><code>{ip, freebind}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, hdrincl}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, minttl}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{ip, msfilter}</code></strong></dt> <dd> <p> <code>Value =</code> <code>null |</code> <code><a href="#type-ip_msfilter"> ip_msfilter() </a></code> </p> <p>Only valid to <strong>set</strong>.</p> <p> The value <code>null</code> passes a <code>NULL</code> pointer and size <code>0</code> to the C library call. </p> </dd> <dt class="title-link"><strong><code>{ip, mtu}</code></strong></dt> <dd> <p><code>Value = integer()</code></p> <p>Only valid to <strong>get</strong>.</p> </dd> <dt class="title-link"><strong><code>{ip, mtu_discover}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ip_pmtudisc"> ip_pmtudisc() </a></code> <code>| integer()</code> </p> <p> An <code>integer()</code> value is according to the platform's header files. </p> </dd> <dt class="title-link"><strong><code>{ip, multicast_all}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, multicast_if}</code></strong></dt> <dd> <p> <code>Value =</code> <code>any |</code> <code><a href="#type-in_addr"> in_addr() </a></code> </p> </dd> <dt class="title-link"><strong><code>{ip, multicast_loop}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, multicast_ttl}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{ip, nodefrag}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, pktinfo}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, recvdstaddr}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, recverr}</code></strong></dt> <dd> <p><code>Value = boolean()</code></p> <p> <strong>Warning!</strong> When this option is enabled, error messages may arrive on the socket's error queue, which should be read using the message flag <code><a href="#type-msg_flag">errqueue</a></code>, and using <code><a href="#recvmsg-1">recvmsg/1,2,3,4,5</a></code> to get all error information in the <code><a href="#type-msg_recv">message's</a></code> <code>ctrl</code> field as a <code><a href="#type-cmsg_recv">control message</a></code> <code>#{level := ip, type := recverr}</code>. </p> <p> A working strategy should be to first poll the error queue using <code><a href="#recvmsg-timeout"> recvmsg/2,3,4 </a></code> with <code>Timeout =:= 0</code> and <code>Flags</code> containing <code>errqueue</code> (ignore the return value <code>{error, timeout}</code>) before reading the actual data to ensure that the error queue gets cleared. And read the data using one of the <code>nowait |</code> <code><a href="#type-select_handle"> select_handle() </a></code> recv functions: <code><a href="#recv-nowait">recv/3,4</a></code>, <code><a href="#recvfrom-nowait">recvfrom/3,4</a></code> or <code><a href="#recvmsg-nowait">recvmsg/3,4,5</a></code>. Otherwise you might accidentally cause a busy loop in and out of 'select' for the socket. </p> </dd> <dt class="title-link"><strong><code>{ip, recvif}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, recvopts}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, recvorigdstaddr}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, recvtos}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, recvttl}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, retopts}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, router_alert}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{ip, sendsrcaddr}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, tos}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ip_tos"> ip_tos() </a></code> <code>| integer()</code> </p> <p> An <code>integer()</code> value is according to the platform's header files. </p> </dd> <dt class="title-link"><strong><code>{ip, transparent}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ip, ttl}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{ip, unblock_source}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ip_mreq_source"> ip_mreq_source() </a></code> </p> <p>Only valid to <strong>set</strong>.</p> </dd> </dl>  <p> <strong>Options for protocol level</strong> <code><a href="#type-level"><strong>ipv6</strong>:</a></code> </p> <dl> <dt class="title-link"><strong><code>{ipv6, addrform}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-domain"> domain() </a></code> </p> <p> As far as we know the only valid value is <code>inet</code> and it is only allowed for an IPv6 socket that is connected and bound to an IPv4-mapped IPv6 address. </p> </dd> <dt class="title-link"><strong><code>{ipv6, add_membership}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ipv6_mreq">ipv6_mreq()</a></code> </p> <p>Only valid to <strong>set</strong>.</p> </dd> <dt class="title-link"><strong><code>{ipv6, authhdr}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, drop_membership}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ipv6_mreq">ipv6_mreq()</a></code> </p> <p>Only valid to <strong>set</strong>.</p> </dd> <dt class="title-link"><strong><code>{ipv6, dstopts}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, flowinfo}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, hoplimit}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, hopopts}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, mtu}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, mtu_discover}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ipv6_pmtudisc"> ipv6_pmtudisc() </a></code> <code>| integer()</code> </p> <p> An <code>integer()</code> value is according to the platform's header files. </p> </dd> <dt class="title-link"><strong><code>{ipv6, multicast_hops}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ipv6_hops">ipv6_hops()</a></code> </p> </dd> <dt class="title-link"><strong><code>{ipv6, multicast_if}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, multicast_loop}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, recverr}</code></strong></dt> <dd> <p><code>Value = boolean()</code></p> <p> <strong>Warning!</strong> See the socket option <code>{ip, recverr}</code> regarding the socket's error queue. The same warning applies for this option. </p> </dd> <dt class="title-link"><strong><code>{ipv6, recvhoplimit}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, recvpktinfo}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, recvtclass}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, router_alert}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, rthdr}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, tclass}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{ipv6, unicast_hops}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-ipv6_hops">ipv6_hops()</a></code> </p> </dd> <dt class="title-link"><strong><code>{ipv6, v6only}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> </dl>  <p> <strong>Options for protocol level</strong> <code><a href="#type-level"><strong>sctp</strong></a></code>. See also RFC 6458. </p> <dl> <dt class="title-link"><strong><code>{sctp, associnfo}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-sctp_assocparams"> sctp_assocparams() </a></code> </p> </dd> <dt class="title-link"><strong><code>{sctp, autoclose}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{sctp, disable_fragments}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{sctp, events}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-sctp_event_subscribe"> sctp_event_subscribe() </a></code> </p> <p>Only valid to <strong>set</strong>.</p> </dd> <dt class="title-link"><strong><code>{sctp, initmsg}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-sctp_initmsg"> sctp_initmsg() </a></code> </p> </dd> <dt class="title-link"><strong><code>{sctp, maxseg}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{sctp, nodelay}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{sctp, rtoinfo}</code></strong></dt> <dd> <p> <code>Value =</code> <code><a href="#type-sctp_rtoinfo"> sctp_rtoinfo() </a></code> </p> </dd> </dl>  <p> <strong>Options for protocol level</strong> <code><a href="#type-level"><strong>tcp:</strong></a></code> </p> <dl> <dt class="title-link"><strong><code>{tcp, congestion}</code></strong></dt> <dd><p><code>Value = string()</code></p></dd> <dt class="title-link"><strong><code>{tcp, cork}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> <dt class="title-link"><strong><code>{tcp, maxseg}</code></strong></dt> <dd><p><code>Value = integer()</code></p></dd> <dt class="title-link"><strong><code>{tcp, nodelay}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> </dl>  <p> <strong>Options for protocol level</strong> <code><a href="#type-level"><strong>udp:</strong></a></code> </p> <dl> <dt class="title-link"><strong><code>{udp, cork}</code></strong></dt> <dd><p><code>Value = boolean()</code></p></dd> </dl> </div></div></article> <article class="data-types-body"><h3 id="type-linger" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-linger">linger()</a> = #{onoff := boolean(), linger := integer() &gt;= 0}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Corresponds to the C <code>struct linger</code> for managing the <code><a href="#type-socket_option">socket option</a></code> <code>{socket, linger}</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-timeval" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-timeval">timeval()</a> = #{sec := integer(), usec := integer()}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Corresponds to the C <code>struct timeval</code>. The field <code>sec</code> holds seconds, and <code>usec</code> microseconds. </p> </div></div></article> <article class="data-types-body"><h3 id="type-ip_mreq" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-ip_mreq">ip_mreq()</a> = #{multiaddr := <a href="#type-in_addr">in_addr()</a>, interface := <a href="#type-in_addr">in_addr()</a>}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Corresponds to the C <code>struct ip_mreq</code> for managing multicast groups. </p> </div></div></article> <article class="data-types-body"><h3 id="type-ip_mreq_source" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-ip_mreq_source">ip_mreq_source()</a> = 
 #{multiaddr := <a href="#type-in_addr">in_addr()</a>,
 interface := <a href="#type-in_addr">in_addr()</a>,
 sourceaddr := <a href="#type-in_addr">in_addr()</a>}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Corresponds to the C <code>struct ip_mreq_source</code> for managing multicast groups. </p> </div></div></article> <article class="data-types-body"><h3 id="type-ip_msfilter" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-ip_msfilter">ip_msfilter()</a> = 
 #{multiaddr := <a href="#type-in_addr">in_addr()</a>,
 interface := <a href="#type-in_addr">in_addr()</a>,
 mode := include | exclude,
 slist := [<a href="#type-in_addr">in_addr()</a>]}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Corresponds to the C <code>struct ip_msfilter</code> for managing multicast source filtering (RFC 3376). </p> </div></div></article> <article class="data-types-body"><h3 id="type-ip_pmtudisc" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-ip_pmtudisc">ip_pmtudisc()</a> = want | dont | do | probe</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Lowercase <code>atom()</code> values corresponding to the C library constants <code>IP_PMTUDISC_*</code>. Some constant(s) may be unsupported by the platform. </p> </div></div></article> <article class="data-types-body"><h3 id="type-ip_tos" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-ip_tos">ip_tos()</a> = lowdelay | throughput | reliability | mincost</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Lowercase <code>atom()</code> values corresponding to the C library constants <code>IPTOS_*</code>. Some constant(s) may be unsupported by the platform. </p> </div></div></article> <article class="data-types-body"><h3 id="type-ip_pktinfo" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-ip_pktinfo">ip_pktinfo()</a> = 
 #{ifindex := integer() &gt;= 0,
 spec_dst := <a href="#type-in_addr">in_addr()</a>,
 addr := <a href="#type-in_addr">in_addr()</a>}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-ipv6_mreq" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-ipv6_mreq">ipv6_mreq()</a> = 
 #{multiaddr := <a href="#type-in6_addr">in6_addr()</a>, interface := integer() &gt;= 0}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Corresponds to the C <code>struct ipv6_mreq</code> for managing multicast groups. See also RFC 2553. </p> </div></div></article> <article class="data-types-body"><h3 id="type-ipv6_hops" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-ipv6_hops">ipv6_hops()</a> = default | 0..255</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> The value <code>default</code> is only valid to <strong>set</strong> and is translated to the C value <code>-1</code>, meaning the route default. </p> </div></div></article> <article class="data-types-body"><h3 id="type-ipv6_pmtudisc" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-ipv6_pmtudisc">ipv6_pmtudisc()</a> = want | dont | do | probe</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Lowercase <code>atom()</code> values corresponding to the C library constants <code>IPV6_PMTUDISC_*</code>. Some constant(s) may be unsupported by the platform. </p> </div></div></article> <article class="data-types-body"><h3 id="type-ipv6_pktinfo" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-ipv6_pktinfo">ipv6_pktinfo()</a> = #{addr := <a href="#type-in6_addr">in6_addr()</a>, ifindex := integer()}</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-sctp_assocparams" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-sctp_assocparams">sctp_assocparams()</a> = 
 #{assoc_id := integer(),
 asocmaxrxt := 0..65535,
 numbe_peer_destinations := 0..65535,
 peer_rwnd := 0..4294967295,
 local_rwnd := 0..4294967295,
 cookie_life := 0..4294967295}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Corresponds to the C <code>struct sctp_assocparams</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-sctp_event_subscribe" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-sctp_event_subscribe">sctp_event_subscribe()</a> = 
 #{data_io := boolean(),
 association := boolean(),
 address := boolean(),
 send_failure := boolean(),
 peer_error := boolean(),
 shutdown := boolean(),
 partial_delivery := boolean(),
 adaptation_layer =&gt; boolean(),
 sender_dry =&gt; boolean()}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Corresponds to the C <code>struct sctp_event_subscribe</code>. </p> <p> Not all fields are implemented on all platforms; unimplemented fields are ignored, but implemented fields are mandatory. Note that the '_event' suffixes have been stripped from the C struct field names, for convenience. </p> </div></div></article> <article class="data-types-body"><h3 id="type-sctp_initmsg" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-sctp_initmsg">sctp_initmsg()</a> = 
 #{num_ostreams := 0..65535,
 max_instreams := 0..65535,
 max_attempts := 0..65535,
 max_init_timeo := 0..65535}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Corresponds to the C <code>struct sctp_initmsg</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-sctp_rtoinfo" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-sctp_rtoinfo">sctp_rtoinfo()</a> = 
 #{assoc_id := integer(),
 initial := 0..4294967295,
 max := 0..4294967295,
 min := 0..4294967295}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Corresponds to the C <code>struct sctp_rtoinfo</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-msg" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-msg">msg()</a> = <a href="#type-msg_send">msg_send()</a> | <a href="#type-msg_recv">msg_recv()</a></code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-msg_send" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-msg_send">msg_send()</a> = 
 #{addr =&gt; <a href="#type-sockaddr">sockaddr()</a>,
 iov := erlang:iovec(),
 ctrl =&gt;
 [<a href="#type-cmsg_send">cmsg_send()</a> |
 #{level := <a href="#type-level">level()</a> | integer(),
 type := integer(),
 data := binary()}]}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Message sent by <code><a href="#sendmsg-2">sendmsg/2,3,4</a></code>. </p> <p> Corresponds to a C <code>struct msghdr</code>, see your platform documentation for <code>sendmsg(2)</code>. </p> <dl> <dt class="title-link"><strong><code>addr</code></strong></dt> <dd> Optional peer address, used on unconnected sockets. Corresponds to <code>msg_name</code> and <code>msg_namelen</code> fields of a <code>struct msghdr</code>. If not used they are set to <code>NULL</code>, <code>0</code>. </dd> <dt class="title-link"><strong><code>iov</code></strong></dt> <dd> Mandatory data as a list of binaries. The <code>msg_iov</code> and <code>msg_iovlen</code> fields of a <code>struct msghdr</code>. </dd> <dt class="title-link"><strong><code>ctrl</code></strong></dt> <dd> Optional list of control messages (CMSG). Corresponds to the <code>msg_control</code> and <code>msg_controllen</code> fields of a <code>struct msghdr</code>. If not used they are set to <code>NULL</code>, <code>0</code>. </dd> </dl> <p> The <code>msg_flags</code> field of the <code>struct msghdr</code> is set to <code>0</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-msg_recv" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-msg_recv">msg_recv()</a> = 
 #{addr =&gt; <a href="#type-sockaddr_recv">sockaddr_recv()</a>,
 iov := erlang:iovec(),
 ctrl :=
 [<a href="#type-cmsg_recv">cmsg_recv()</a> |
 #{level := <a href="#type-level">level()</a> | integer(),
 type := integer(),
 data := binary()}],
 flags := [<a href="#type-msg_flag">msg_flag()</a> | integer()]}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Message returned by <code><a href="#recvmsg-1">recvmsg/1,2,3,5</a></code>. </p> <p> Corresponds to a C <code>struct msghdr</code>, see your platform documentation for <code>recvmsg(2)</code>. </p> <dl> <dt class="title-link"><strong><code>addr</code></strong></dt> <dd> Optional peer address, used on unconnected sockets. Corresponds to <code>msg_name</code> and <code>msg_namelen</code> fields of a <code>struct msghdr</code>. If <code>NULL</code> the map key is not present. </dd> <dt class="title-link"><strong><code>iov</code></strong></dt> <dd> Data as a list of binaries. The <code>msg_iov</code> and <code>msg_iovlen</code> fields of a <code>struct msghdr</code>. </dd> <dt class="title-link"><strong><code>ctrl</code></strong></dt> <dd> A possibly empty list of control messages (CMSG). Corresponds to the <code>msg_control</code> and <code>msg_controllen</code> fields of a <code>struct msghdr</code>. </dd> <dt class="title-link"><strong><code>flags</code></strong></dt> <dd> Message flags. Corresponds to the <code>msg_flags</code> field of a <code>struct msghdr</code>. Unknown flags, if any, are returned in one <code>integer()</code>, last in the containing list. </dd> </dl> </div></div></article> <article class="data-types-body"><h3 id="type-native_value" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-native_value">native_value()</a> = integer() | boolean() | binary()</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-cmsg_send" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-cmsg_send">cmsg_send()</a> = 
 #{level := socket,
 type := timestamp,
 data =&gt; <a href="#type-native_value">native_value()</a>,
 value =&gt; <a href="#type-timeval">timeval()</a>} |
 #{level := socket, type := rights, data := <a href="#type-native_value">native_value()</a>} |
 #{level := socket,
 type := credentials,
 data := <a href="#type-native_value">native_value()</a>} |
 #{level := ip,
 type := tos,
 data =&gt; <a href="#type-native_value">native_value()</a>,
 value =&gt; <a href="#type-ip_tos">ip_tos()</a> | integer()} |
 #{level := ip,
 type := ttl,
 data =&gt; <a href="#type-native_value">native_value()</a>,
 value =&gt; integer()} |
 #{level := ip,
 type := hoplimit,
 data =&gt; <a href="#type-native_value">native_value()</a>,
 value =&gt; integer()} |
 #{level := ipv6,
 type := tclass,
 data =&gt; <a href="#type-native_value">native_value()</a>,
 value =&gt; integer()}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Control messages (ancillary messages) accepted by <code><a href="#sendmsg-2">sendmsg/2,3,4</a></code>. </p> <p> A control message may for some message types have a <code>value</code> field with a symbolic value, or a <code>data</code> field with a native value, that has to be binary compatible what is defined in the platform's header files. </p> </div></div></article> <article class="data-types-body"><h3 id="type-cmsg_recv" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-cmsg_recv">cmsg_recv()</a> = 
 #{level := socket,
 type := timestamp,
 data := binary(),
 value =&gt; <a href="#type-timeval">timeval()</a>} |
 #{level := socket, type := rights, data := binary()} |
 #{level := socket, type := credentials, data := binary()} |
 #{level := ip,
 type := tos,
 data := binary(),
 value =&gt; <a href="#type-ip_tos">ip_tos()</a> | integer()} |
 #{level := ip,
 type := recvtos,
 data := binary(),
 value := <a href="#type-ip_tos">ip_tos()</a> | integer()} |
 #{level := ip,
 type := ttl,
 data := binary(),
 value =&gt; integer()} |
 #{level := ip,
 type := recvttl,
 data := binary(),
 value := integer()} |
 #{level := ip,
 type := pktinfo,
 data := binary(),
 value =&gt; <a href="#type-ip_pktinfo">ip_pktinfo()</a>} |
 #{level := ip,
 type := origdstaddr,
 data := binary(),
 value =&gt; <a href="#type-sockaddr_recv">sockaddr_recv()</a>} |
 #{level := ip,
 type := recverr,
 data := binary(),
 value =&gt; <a href="#type-extended_err">extended_err()</a>} |
 #{level := ipv6,
 type := hoplimit,
 data := binary(),
 value =&gt; integer()} |
 #{level := ipv6,
 type := pktinfo,
 data := binary(),
 value =&gt; <a href="#type-ipv6_pktinfo">ipv6_pktinfo()</a>} |
 #{level := ipv6,
 type := recverr,
 data := binary(),
 value =&gt; <a href="#type-extended_err">extended_err()</a>} |
 #{level := ipv6,
 type := tclass,
 data := binary(),
 value =&gt; integer()}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Control messages (ancillary messages) returned by <code><a href="#recvmsg-1">recvmsg/1,2,3,5</a></code>. </p> <p> A control message has got a <code>data</code> field with a native (<code>binary</code>) value for the message data, and may also have a decoded <code>value</code> field if this socket library successfully decoded the data. </p> </div></div></article> <article class="data-types-body"><h3 id="type-icmp_dest_unreach" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-icmp_dest_unreach">icmp_dest_unreach()</a> = 
 net_unreach | host_unreach | port_unreach | frag_needed |
 net_unknown | host_unknown</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-icmpv6_dest_unreach" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-icmpv6_dest_unreach">icmpv6_dest_unreach()</a> = 
 noroute | adm_prohibited | not_neighbour | addr_unreach |
 port_unreach | policy_fail | reject_route</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-ee_origin" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-ee_origin">ee_origin()</a> = none | local | icmp | icmp6</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-extended_err" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-extended_err">extended_err()</a> = 
 #{error := <a href="#type-posix">posix()</a>,
 origin := icmp,
 type := dest_unreach,
 code := <a href="#type-icmp_dest_unreach">icmp_dest_unreach()</a> | 0..255,
 info := 0..4294967295,
 data := 0..4294967295,
 offender := <a href="#type-sockaddr_recv">sockaddr_recv()</a>} |
 #{error := <a href="#type-posix">posix()</a>,
 origin := icmp,
 type := time_exceeded | 0..255,
 code := 0..255,
 info := 0..4294967295,
 data := 0..4294967295,
 offender := <a href="#type-sockaddr_recv">sockaddr_recv()</a>} |
 #{error := <a href="#type-posix">posix()</a>,
 origin := icmp6,
 type := dest_unreach,
 code := <a href="#type-icmpv6_dest_unreach">icmpv6_dest_unreach()</a> | 0..255,
 info := 0..4294967295,
 data := 0..4294967295,
 offender := <a href="#type-sockaddr_recv">sockaddr_recv()</a>} |
 #{error := <a href="#type-posix">posix()</a>,
 origin := icmp6,
 type := pkt_toobig | time_exceeded | 0..255,
 code := 0..255,
 info := 0..4294967295,
 data := 0..4294967295,
 offender := <a href="#type-sockaddr_recv">sockaddr_recv()</a>} |
 #{error := <a href="#type-posix">posix()</a>,
 origin := <a href="#type-ee_origin">ee_origin()</a> | 0..255,
 type := 0..255,
 code := 0..255,
 info := 0..4294967295,
 data := 0..4294967295,
 offender := <a href="#type-sockaddr_recv">sockaddr_recv()</a>}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-posix" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-posix">posix()</a> = <a href="inet.html#type-posix">inet:posix()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> The POSIX error codes originates from the OS level socket interface. </p> </div></div></article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="accept-1" class="bold_code title-link func-head">  <code>accept(ListenSocket) -&gt; {ok, Socket} | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="accept-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>accept(ListenSocket, Timeout :: infinity) -&gt;
 {ok, Socket} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ListenSocket = Socket = <a href="#type-socket">socket()</a></code></div>  <div class="REFTYPES rt-1"><pre><code>Reason = 
 <a href="#type-posix">posix()</a> |
 closed |
 <a href="#type-invalid">invalid()</a> |
 {create_accept_socket, <a href="#type-posix">posix()</a>} |
 {add_socket, <a href="#type-posix">posix()</a>} |
 {update_accept_context, <a href="#type-posix">posix()</a>}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Accept a connection on a socket.</p> <p> This call is used with connection oriented socket types (<code>stream</code> or <code>seqpacket</code>). It returns the first pending incoming connection for a listen socket, or waits for one to arrive, and returns the (newly) connected socket. </p> </div></div></article><article class="func"><h3 id="accept-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>accept(ListenSocket, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, Socket} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ListenSocket = Socket = <a href="#type-socket">socket()</a></code></div>  <div class="REFTYPES rt-1"><pre><code>Reason = 
 <a href="#type-posix">posix()</a> |
 closed |
 <a href="#type-invalid">invalid()</a> |
 timeout |
 {create_accept_socket, <a href="#type-posix">posix()</a>} |
 {add_socket, <a href="#type-posix">posix()</a>} |
 {update_accept_context, <a href="#type-posix">posix()</a>}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> The same as <code><a href="#accept-1">accept/1</a></code> but returns <code>{error, timeout}</code> if no connection has been accepted after <code>Timeout</code> milliseconds. </p> </div></div></article><article class="func"><h3 id="accept-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>accept(ListenSocket, Timeout :: nowait) -&gt;
 {ok, Socket} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="accept-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>accept(ListenSocket,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 {ok, Socket} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ListenSocket = Socket = <a href="#type-socket">socket()</a></code></div>  <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>CompletionInfo = <a href="#type-completion_info">completion_info()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Reason = 
 <a href="#type-posix">posix()</a> |
 closed |
 <a href="#type-invalid">invalid()</a> |
 {create_accept_socket, <a href="#type-posix">posix()</a>} |
 {add_socket, <a href="#type-posix">posix()</a>} |
 {update_accept_context, <a href="#type-posix">posix()</a>}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> The same as <code><a href="#accept-1">accept/1</a></code> but returns promptly. </p> <p> When there is no pending connection to return, the function will return (on <i>Unix</i>) <code><a href="#type-select_info">{select, SelectInfo}</a></code> or (on <i>Windows</i>) <code><a href="#type-completion_info">{completion, CompletionInfo}</a></code>, and the caller will later receive either one of these messages (depending on the platform) when the client connects: </p> <dl> <dt class="title-link"><strong><code>select</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, select, SelectHandle}</code> (with the <code><a href="socket.html#type-select_handle">SelectHandle</a></code> contained in the <code><a href="#type-select_info">SelectInfo</a></code>). </p> <p> A subsequent call to <code>accept/1,2</code> will then return the socket. </p> </dd> <dt class="title-link"><strong><code>completion</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, completion, {CompletionHandle, CompletionStatus}}</code> (with the <code><a href="socket.html#type-completion_handle">CompletionHandle</a></code> contained in the <code><a href="#type-completion_info">CompletionInfo</a></code>). </p> <p> The <strong>result</strong> of the accept will be in the <code>CompletionStatus</code>. </p> </dd> </dl> <p> If the time-out argument is a <code>Handle</code>, that term will be contained in a returned <code>SelectInfo</code> or <code>CompletionInfo</code> and the corresponding select or completion message. The <code>Handle</code> is presumed to be unique to this call. </p> <p> If the time-out argument is <code>nowait</code>:</p> <dl> <dt class="title-link"><strong>On <i>Unix</i></strong></dt> <dd> <p> And a <code>SelectInfo</code> is returned, it will contain a <code><a href="socket.html#type-select_handle">select_handle()</a></code> generated by the call. </p> </dd> <dt class="title-link"><strong>On <i>Windows</i></strong></dt> <dd> <p> And a <code>CompletionInfo</code> is returned, it will contain a <code><a href="socket.html#type-completion_handle">completion_handle()</a></code> generated by the call. </p> </dd> </dl> <p> If the caller doesn't want to wait for a connection, it must immediately call <code><a href="#cancel-2">cancel/2</a></code> to cancel the operation. </p> </div></div></article><article class="func"><h3 id="bind-2" class="bold_code title-link func-head">  <code>bind(Socket, Addr) -&gt; ok | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Addr = <a href="#type-sockaddr">sockaddr()</a> | any | broadcast | loopback</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Bind a name to a socket.</p> <p> When a socket is created (with <code><a href="#open-2">open</a></code>), it has no address assigned to it. <code>bind</code> assigns the address specified by the <code>Addr</code> argument. </p> <p> The rules used for name binding vary between domains. </p> <p> If you bind a socket to an address in for example the 'inet' or 'inet6' address families, with an ephemeral port number (0), and want to know which port that was chosen, you can find out using something like: <code>{ok, #{port := Port}} =</code> <code><a href="#sockname-1"> socket:sockname(Socket) </a></code> </p> </div></div></article><article class="func"><h3 id="cancel-2" class="bold_code title-link func-head">  <code>cancel(Socket, SelectInfo) -&gt; ok | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Cancel an asynchronous (select) request.</p> <p> Call this function in order to cancel a previous asynchronous call to, e.g. <code><a href="#recv-3">recv/3</a></code>. </p> <p> An ongoing asynchronous operation blocks the socket until the operation has been finished in good order, or until it has been cancelled by this function. </p> <p> Any other process that tries an operation of the same basic type (accept / send / recv) will be enqueued and notified with the regular <code>select</code> mechanism for asynchronous operations when the current operation and all enqueued before it has been completed. </p> <p> If <code>SelectInfo</code> does not match an operation in progress for the calling process, this function returns <code>{error, {invalid, SelectInfo}}</code>. </p> </div></div></article><article class="func"><h3 id="cancel-2" class="bold_code title-link func-head">  <code>cancel(Socket, CompletionInfo) -&gt; ok | {error, Reason}</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>CompletionInfo = <a href="#type-completion_info">completion_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Cancel an asynchronous (completion) request.</p> <p> Call this function in order to cancel a previous asynchronous call to, e.g. <code><a href="#recv-3">recv/3</a></code>. </p> <p> An ongoing asynchronous operation blocks the socket until the operation has been finished in good order, or until it has been cancelled by this function. </p> <p> Any other process that tries an operation of the same basic type (accept / send / recv) will be enqueued and notified with the regular <code>select</code> mechanism for asynchronous operations when the current operation and all enqueued before it has been completed. </p> <p> If <code>CompletionInfo</code> does not match an operation in progress for the calling process, this function returns <code>{error, {invalid, CompletionInfo}}</code>. </p> </div></div></article><article class="func"><h3 id="close-1" class="bold_code title-link func-head">  <code>close(Socket) -&gt; ok | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | timeout</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Closes the socket.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Note that for e.g. <code>protocol</code> = <code>tcp</code>, most implementations doing a close does not guarantee that any data sent is delivered to the recipient before the close is detected at the remote side. </p> <p>One way to handle this is to use the <code><a href="#shutdown-2">shutdown</a></code> function (<code>socket:shutdown(Socket, write)</code>) to signal that no more data is to be sent and then wait for the read side of the socket to be closed.</p> </div> </div> </div></div></article><article class="func"><h3 id="connect-2" class="bold_code title-link func-head">  <code>connect(Socket, SockAddr) -&gt; ok | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="connect-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>connect(Socket, SockAddr, Timeout :: infinity) -&gt;
 ok | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>SockAddr = <a href="#type-sockaddr">sockaddr()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Reason = 
 <a href="#type-posix">posix()</a> |
 closed |
 <a href="#type-invalid">invalid()</a> |
 already | not_bound |
 {add_socket, <a href="#type-posix">posix()</a>} |
 {update_connect_context, <a href="#type-posix">posix()</a>}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> This function connects the socket to the address specified by the <code>SockAddr</code> argument, and returns when the connection has been established or failed. </p> <p> If a connection attempt is already in progress (by another process), <code>{error, already}</code> is returned. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> On <i>Windows</i> the socket has to be <strong>bound</strong>. </p> </div> </div> </div></div></article><article class="func"><h3 id="connect-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>connect(Socket, SockAddr, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 ok | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>SockAddr = <a href="#type-sockaddr">sockaddr()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Reason = 
 <a href="#type-posix">posix()</a> |
 closed |
 <a href="#type-invalid">invalid()</a> |
 already | not_bound | timeout |
 {add_socket, <a href="#type-posix">posix()</a>} |
 {update_connect_context, <a href="#type-posix">posix()</a>}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> The same as <code><a href="#connect-2">connect/2</a></code> but returns <code>{error, timeout}</code> if no connection has been established after <code>Timeout</code> milliseconds. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> On <i>Windows</i> the socket has to be <strong>bound</strong>. </p> <p> Note that when this call has returned <code>{error, timeout}</code> the connection state of the socket is uncertain since the platform's network stack may complete the connection at any time, up to some platform specific time-out. </p> <p> Repeating a connection attempt towards the same address would be ok, but towards a different address could end up with a connection to either address. </p> <p> The safe play would be to close the socket and start over. </p> <p> Also note that all this applies to cancelling a connect call with a no-wait time-out described below. </p> </div> </div> </div></div></article><article class="func"><h3 id="connect-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>connect(Socket, SockAddr, Timeout :: nowait) -&gt;
 ok |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="connect-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>connect(Socket, SockAddr,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 ok |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>SockAddr = <a href="#type-sockaddr">sockaddr()</a></code></div> <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>CompletionInfo = <a href="#type-completion_info">completion_info()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Reason = 
 <a href="#type-posix">posix()</a> |
 closed |
 <a href="#type-invalid">invalid()</a> |
 already | not_bound |
 {add_socket, <a href="#type-posix">posix()</a>} |
 {update_connect_context, <a href="#type-posix">posix()</a>}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> The same as <code><a href="#connect-2">connect/2</a></code> but returns promptly. </p> <p> If it is not possible to immediately establish a connection, the function will return <code><a href="#type-select_info">{select, SelectInfo}</a></code>, and the caller will later receive a select message, <code>{'$socket', Socket, select, SelectHandle}</code> ( with the <code><a href="socket.html#type-select_handle">SelectHandle</a></code> contained in the <code><a href="#type-select_info">SelectInfo</a></code> ) when the connection has been completed or failed. A subsequent call to <code><a href="#connect-1">connect/1</a></code> will then finalize the connection and return the result. </p> <p> If the time-out argument is <code>SelectHandle</code>, that term will be contained in a returned <code>SelectInfo</code> and the corresponding select message. The <code>SelectHandle</code> is presumed to be unique to this call. </p> <p> If the time-out argument is <code>nowait</code>, and a <code>SelectInfo</code> is returned, it will contain a <code><a href="socket.html#type-select_handle"> select_handle() </a></code> generated by the call. </p> <p> If the caller doesn't want to wait for the connection to complete, it must immediately call <code><a href="#cancel-2">cancel/2</a></code> to cancel the operation. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>On <i>Windows</i> the socket has to be <strong>bound</strong>.</p> </div> </div> </div></div></article><article class="func"><h3 id="connect-1" class="bold_code title-link func-head">  <code>connect(Socket) -&gt; ok | {error, Reason}</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> This function finalizes a connection setup on a socket, after calling <code><a href="#connect-3"> connect(_, _, nowait | select_handle()) </a></code> that returned <code><a href="#type-select_info">{select, SelectInfo}</a></code>, and receiving the select message <code>{'$socket', Socket, select, SelectHandle}</code>, and returns whether the connection setup was successful or not. </p> <p> Instead of calling this function, for backwards compatibility, it is allowed to call <code><a href="#connect-2">connect/2,3</a></code>, but that incurs more overhead since the connect address and time-out are processed in vain. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> <strong>Not</strong> used on <i>Windows</i>. </p> </div> </div> </div></div></article><article class="func"><h3 id="cancel_monitor-1" class="bold_code title-link func-head">  <code>cancel_monitor(MRef) -&gt; <code>boolean()</code></code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>MRef = reference()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>If <code>MRef</code> is a reference that the calling process obtained by calling <code><a href="#monitor-1">monitor/1</a></code>, this monitor is turned off. If the monitoring is already turned off, nothing happens.</p> <p>The returned value is one of the following:</p> <dl> <dt class="title-link"><strong><code>true</code></strong></dt> <dd> <p>The monitor was found and removed. In this case, no <code>'DOWN'</code> message corresponding to this monitor has been delivered and will not be delivered. </p> </dd> <dt class="title-link"><strong><code>false</code></strong></dt> <dd> <p>The monitor was not found and could not be removed. This probably because a <code>'DOWN'</code> message corresponding to this monitor has already been placed in the caller message queue.</p> </dd> </dl> <p>Failure: It is an error if <code>MRef</code> refers to a monitor started by another process. </p> </div></div></article><article class="func"><h3 id="getopt-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>getopt(X1 :: <code><a href="#type-socket">socket()</a></code>,
 SocketOption :: {Level :: otp, Opt :: <code><a href="#type-otp_socket_option">otp_socket_option()</a></code>}) -&gt;
 {ok, Value :: <code>term()</code>} | {error, <code><a href="#type-invalid">invalid()</a></code> | closed}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Gets a socket option from the protocol level <code>otp</code>, which is this implementation's level above the OS protocol layers. </p> <p> See the type <code><a href="#type-otp_socket_option"> otp_socket_option() </a></code> for a description of the options on this level. </p> </div></div></article><article class="func"><h3 id="getopt-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>getopt(X1 :: <code><a href="#type-socket">socket()</a></code>, SocketOption :: <code><a href="#type-socket_option">socket_option()</a></code>) -&gt;
 {ok, Value :: <code>term()</code>} |
 {error, <code><a href="#type-posix">posix()</a></code> | <code><a href="#type-invalid">invalid()</a></code> | closed}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Gets a socket option from one of the OS's protocol levels. See the type <code><a href="#type-socket_option">socket_option()</a></code> for which options that this implementation knows about, how they are related to option names in the OS, and if there are known peculiarities with any of them. </p> <p> What options are valid depends on what kind of socket it is (<code><a href="#type-domain">domain()</a></code>, <code><a href="#type-type">type()</a></code> and <code><a href="#type-protocol">protocol()</a></code>). </p> <p> See the <code><a href="socket_usage.html#socket_options"> socket options </a></code> chapter of the users guide for more info. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Not all options are valid, nor possible to get, on all platforms. That is, even if "we" support an option; it does not mean that the underlying OS does. </p> </div> </div> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="getopt-3" class="title-link">  <div class="title-name">getopt(Socket, Level, Opt) -&gt; ok | {error, Reason}</div> <div class="title-since"><span class="since">OTP 22.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Socket = <a href="#type-socket">socket()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Reason = <a href="inet.html#type-posix">inet:posix()</a> | <a href="#type-invalid">invalid()</a> | closed</code><br> </div> </div> <div class="REFBODY rb-7"> <p>Backwards compatibility function.</p> <p> The same as <code><a href="#getopt-2"> getopt(Socket, {Level, Opt}) </a></code> </p> </div> </div></article><article class="func"><h3 id="getopt_native-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>getopt_native(X1 :: <code><a href="#type-socket">socket()</a></code>,
 SocketOption ::
 <code><a href="#type-socket_option">socket_option()</a></code> |
 {Level :: <code><a href="#type-level">level()</a></code> | (NativeLevel :: <code>integer()</code>),
 NativeOpt :: <code>integer()</code>},
 ValueType :: integer) -&gt;
 {ok, Value :: <code>integer()</code>} |
 {error, <code><a href="#type-posix">posix()</a></code> | <code><a href="#type-invalid">invalid()</a></code> | closed}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="getopt_native-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>getopt_native(X1 :: <code><a href="#type-socket">socket()</a></code>,
 SocketOption ::
 <code><a href="#type-socket_option">socket_option()</a></code> |
 {Level :: <code><a href="#type-level">level()</a></code> | (NativeLevel :: <code>integer()</code>),
 NativeOpt :: <code>integer()</code>},
 ValueType :: boolean) -&gt;
 {ok, Value :: <code>boolean()</code>} |
 {error, <code><a href="#type-posix">posix()</a></code> | <code><a href="#type-invalid">invalid()</a></code> | closed}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="getopt_native-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>getopt_native(X1 :: <code><a href="#type-socket">socket()</a></code>,
 SocketOption ::
 <code><a href="#type-socket_option">socket_option()</a></code> |
 {Level :: <code><a href="#type-level">level()</a></code> | (NativeLevel :: <code>integer()</code>),
 NativeOpt :: <code>integer()</code>},
 ValueSize :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, Value :: <code>binary()</code>} |
 {error, <code><a href="#type-posix">posix()</a></code> | <code><a href="#type-invalid">invalid()</a></code> | closed}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="getopt_native-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>getopt_native(X1 :: <code><a href="#type-socket">socket()</a></code>,
 SocketOption ::
 <code><a href="#type-socket_option">socket_option()</a></code> |
 {Level :: <code><a href="#type-level">level()</a></code> | (NativeLevel :: <code>integer()</code>),
 NativeOpt :: <code>integer()</code>},
 ValueSpec :: <code>binary()</code>) -&gt;
 {ok, Value :: <code>binary()</code>} |
 {error, <code><a href="#type-posix">posix()</a></code> | <code><a href="#type-invalid">invalid()</a></code> | closed}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Gets a socket option that may be unknown to our implementation, or that has a type not compatible with our implementation, that is; in "native mode". </p> <p> The socket option may be specified with an ordinary <code><a href="#type-socket_option"> socket_option() </a></code> tuple, with a known <code><a href="#type-level"> Level = level() </a></code> and an integer <code>NativeOpt</code>, or with both an integer <code>NativeLevel</code> and <code>NativeOpt</code>. </p> <p> How to decode the option value has to be specified either with <code>ValueType</code>, by specifying the <code>ValueSize</code> for a <code>binary()</code> that will contain the fetched option value, or by specifying a <code>binary()</code> <code>ValueSpec</code> that will be copied to a buffer for the <code>getsockopt()</code> call to write the value in which will be returned as a new <code>binary()</code>. </p> <p> If <code>ValueType</code> is <code>integer</code> a <code>C</code> type <code>(int)</code> will be fetched, if it is <code>boolean</code> a <code>C</code> type <code>(int)</code> will be fetched and converted into a <code>boolean()</code> according to the <code>C</code> implementation. </p> <p> What options are valid depends on what kind of socket it is (<code><a href="#type-domain">domain()</a></code>, <code><a href="#type-type">type()</a></code> and <code><a href="#type-protocol">protocol()</a></code>). </p> <p> The integer values for <code>NativeLevel</code> and <code>NativeOpt</code> as well as the <code>Value</code> encoding has to be deduced from the header files for the running system. </p> </div></div></article><article class="func"><h3 id="i-0" class="bold_code title-link func-head">  <code>i() -&gt; ok</code><div class="title-since"><span class="since">OTP 24.1</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Print all sockets in table format in the erlang shell. </p> </div></div></article><article class="func"><h3 id="i-1" class="bold_code title-link func-head">  <code>i(InfoKeys) -&gt; ok</code><div class="title-since"><span class="since">OTP 24.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>InfoKeys = <a href="#type-info_keys">info_keys()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Print all sockets in table format in the erlang shell. What information is included is defined by <code>InfoKeys</code>. </p> </div></div></article><article class="func"><h3 id="i-1" class="bold_code title-link func-head">  <code>i(Domain) -&gt; ok</code><div class="title-since"><span class="since">OTP 24.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Domain = inet | inet6 | local</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Print a selection, based on domain, of the sockets in table format in the erlang shell. </p> </div></div></article><article class="func"><h3 id="i-1" class="bold_code title-link func-head">  <code>i(Proto) -&gt; ok</code><div class="title-since"><span class="since">OTP 24.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Proto = sctp | tcp | udp</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Print a selection, based on protocol, of the sockets in table format in the erlang shell. </p> </div></div></article><article class="func"><h3 id="i-1" class="bold_code title-link func-head">  <code>i(Type) -&gt; ok</code><div class="title-since"><span class="since">OTP 24.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = dgram | seqpacket | stream</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Print a selection, based on type, of the sockets in table format in the erlang shell. </p> </div></div></article><article class="func"><h3 id="i-2" class="bold_code title-link func-head">  <code>i(Domain, InfoKeys) -&gt; ok</code><div class="title-since"><span class="since">OTP 24.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Domain = inet | inet6 | local</code></div> <div class="REFTYPES rt-1"><code>InfoKeys = <a href="#type-info_keys">info_keys()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Print a selection, based on domain, of the sockets in table format in the erlang shell. What information is included is defined by <code>InfoKeys</code>. </p> </div></div></article><article class="func"><h3 id="i-2" class="bold_code title-link func-head">  <code>i(Proto, InfoKeys) -&gt; ok</code><div class="title-since"><span class="since">OTP 24.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Proto = sctp | tcp | udp</code></div> <div class="REFTYPES rt-1"><code>InfoKeys = <a href="#type-info_keys">info_keys()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Print a selection, based on domain, of the sockets in table format in the erlang shell. What information is included is defined by <code>InfoKeys</code>. </p> </div></div></article><article class="func"><h3 id="i-2" class="bold_code title-link func-head">  <code>i(Type, InfoKeys) -&gt; ok</code><div class="title-since"><span class="since">OTP 24.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = dgram | seqpacket | stream</code></div> <div class="REFTYPES rt-1"><code>InfoKeys = <a href="#type-info_keys">info_keys()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Print a selection, based on type, of the sockets in table format in the erlang shell. What information is included is defined by <code>InfoKeys</code>. </p> </div></div></article><article class="func"><h3 id="info-0" class="bold_code title-link func-head">  <code>info() -&gt; <code><a href="#type-info">info()</a></code></code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Get miscellaneous info about the socket library.</p> <p> The function returns a map with each info item as a key-value binding. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> In order to ensure data integrity, mutex'es are taken when needed. So, do not call this function often. </p> </div> </div> </div></div></article><article class="func"><h3 id="info-1" class="bold_code title-link func-head">  <code>info(Socket) -&gt; <code><a href="#type-socket_info">socket_info()</a></code></code><div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Get miscellaneous info about the socket.</p> <p>The function returns a map with each info item as a key-value binding. It reflects the "current" state of the socket. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>In order to ensure data integrity, mutex'es are taken when needed. So, do not call this function often. </p> </div> </div> </div></div></article><article class="func"><h3 id="ioctl-2" class="bold_code title-link func-head">  <code>ioctl(Socket, GetRequest) -&gt; {ok, IFConf} | {error, Reason}</code><div class="title-since"><span class="since">OTP 24.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>GetRequest = gifconf</code></div> <div class="REFTYPES rt-1"><code>IFConf = [#{name := string, addr := <a href="#type-sockaddr">sockaddr()</a>}]</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Retrieve socket (device) parameters.</p> </div></div></article><article class="func"><h3 id="ioctl-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>ioctl(Socket, GetRequest, NameOrIndex) -&gt;
 {ok, Result} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><pre><code>GetRequest = 
 gifname | gifindex | gifaddr | gifdstaddr | gifbrdaddr |
 gifnetmask | gifhwaddr | gifmtu | giftxqlen | gifflags</code></pre></div> <div class="REFTYPES rt-1"><code>NameOrIndex = string() | integer()</code></div> <div class="REFTYPES rt-1"><code>Result = term()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Retrieve socket (device) parameters. This function retrieves a specific parameter, according to <code>GetRequest</code> argument. The third argument is the (lookup) "key", identifying the interface (usually the name of the interface).</p> <dl> <dt class="title-link"><strong><code>gifname</code></strong></dt> <dd> <p>Get the name of the interface with the specified index (integer()). </p> <p>Result, name of the interface, is a <code>string()</code>. </p> </dd> <dt class="title-link"><strong><code>gifindex</code></strong></dt> <dd> <p>Get the index of the interface with the specified name. </p> <p>Result, interface index, is a <code>integer()</code>. </p> </dd> <dt class="title-link"><strong><code>gifaddr</code></strong></dt> <dd> <p>Get the address of the interface with the specified name. Result, address of the interface, is a <code>socket:sockaddr()</code>. </p> </dd> <dt class="title-link"><strong><code>gifdstaddr</code></strong></dt> <dd> <p>Get the destination address of the point-to-point interface with the specified name. </p> <p>Result, destination address of the interface, is a <code>socket:sockaddr()</code>. </p> </dd> <dt class="title-link"><strong><code>gifbrdaddr</code></strong></dt> <dd> <p>Get the droadcast address for the interface with the specified name. </p> <p>Result, broadcast address of the interface, is a <code>socket:sockaddr()</code>. </p> </dd> <dt class="title-link"><strong><code>gifnetmask</code></strong></dt> <dd> <p>Get the network mask for the interface with the specified name. </p> <p>Result, network mask of the interface, is a <code>socket:sockaddr()</code>. </p> </dd> <dt class="title-link"><strong><code>gifhwaddr</code></strong></dt> <dd> <p>Get the hardware address for the interface with the specified name. </p> <p>Result, hardware address of the interface, is a <code>socket:sockaddr()</code>. The family field contains the 'ARPHRD' device type (or an integer). </p> </dd> <dt class="title-link"><strong><code>gifmtu</code></strong></dt> <dd> <p>Get the MTU (Maximum Transfer Unit) for the interface with the specified name. </p> <p>Result, MTU of the interface, is an <code>integer()</code>. </p> </dd> <dt class="title-link"><strong><code>giftxqlen</code></strong></dt> <dd> <p>Get the transmit queue length of the interface with the specified name. </p> <p>Result, transmit queue length of the interface, is an <code>integer()</code>. </p> </dd> <dt class="title-link"><strong><code>gifflags</code></strong></dt> <dd> <p>Get the active flag word of the interface with the specified name. </p> <p>Result, the active flag word of the interface, is an list of <code>socket:ioctl_device_flag() | integer()</code>. </p> </dd> </dl> </div></div></article><article class="func"><h3 id="ioctl-4" class="bold_code title-link func-head">  <code>ioctl(Socket, SetRequest, Name, Value) -&gt; ok | {error, Reason}</code><div class="title-since"><span class="since">OTP 24.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><pre><code>SetRequest = 
 sifflags | sifaddr | sifdstaddr | sifbrdaddr | sifnetmask |
 sifhwaddr | gifmtu | siftxqlen</code></pre></div> <div class="REFTYPES rt-1"><code>Name = string()</code></div> <div class="REFTYPES rt-1"><code>Value = term()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Set socket (device) parameters. This function sets a specific parameter, according to <code>SetRequest</code> argument. The third argument is the "key", identifying the interface (usually the name of the interface), and the fourth is the "new" value.</p> <p>These are privileged operation's. </p> <dl> <dt class="title-link"><strong><code>sifflags</code></strong></dt> <dd> <p>Set the the active flag word, <code>#{Flag =&gt; boolean()}</code>, of the interface with the specified name. </p> <p>Each flag to be changed, should be added to the value map, with the value <code>'true'</code> if the flag (<code>Flag</code>) should be set and <code>'false'</code> if the flag should be reset. </p> </dd> <dt class="title-link"><strong><code>sifaddr</code></strong></dt> <dd> <p>Set the address, <code>sockaddr()</code>, of the interface with the specified name. </p> </dd> <dt class="title-link"><strong><code>sifdstaddr</code></strong></dt> <dd> <p>Set the destination address, <code>sockaddr()</code>, of a point-to-point interface with the specified name. </p> </dd> <dt class="title-link"><strong><code>sifbrdaddr</code></strong></dt> <dd> <p>Set the broadcast address, <code>sockaddr()</code>, of the interface with the specified name. </p> </dd> <dt class="title-link"><strong><code>sifnetmask</code></strong></dt> <dd> <p>Set the network mask, <code>sockaddr()</code>, of the interface with the specified name. </p> </dd> <dt class="title-link"><strong><code>sifmtu</code></strong></dt> <dd> <p>Set the MTU (Maximum Transfer Unit), <code>integer()</code>, for the interface with the specified name. </p> </dd> <dt class="title-link"><strong><code>siftxqlen</code></strong></dt> <dd> <p>Set the transmit queue length, <code>integer()</code>, of the interface with the specified name. </p> </dd> </dl> </div></div></article><article class="func"><h3 id="is_supported-1" class="bold_code title-link func-head">  <code>is_supported(Key1 :: <code>term()</code>) -&gt; <code>boolean()</code></code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <h3 id="is_supported-2" class="bold_code title-link func-head">  <code>is_supported(Key1 :: <code>term()</code>, Key2 :: <code>term()</code>) -&gt; <code>boolean()</code></code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> This function retrieves information about what the platform supports, such as if SCTP is supported, or if a socket options are supported. </p> <p> For keys other than the known <code>false</code> is returned. Note that in a future version or on a different platform there might be more supported items. </p> <p> This functions returns a <code>boolean</code> corresponding to what <code><a href="#supports-0">supports/0-2</a></code> reports for the same <code>Key1</code> (and <code>Key2</code>). </p> </div></div></article><article class="func"><h3 id="listen-1" class="bold_code title-link func-head">  <code>listen(Socket) -&gt; ok | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="listen-2" class="bold_code title-link func-head">  <code>listen(Socket, Backlog) -&gt; ok | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Backlog = integer()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Listen for connections on a socket.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>On <i>Windows</i> the socket has to be <strong>bound</strong>.</p> </div> </div> </div></div></article><article class="func"><h3 id="monitor-1" class="bold_code title-link func-head">  <code>monitor(Socket) -&gt; <code>reference()</code></code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Start monitor the socket <code>Socket</code>. </p> <p>If the monitored socket does not exist or when the monitor is triggered, a <code>'DOWN'</code> message is sent that has the following pattern:</p> <pre data-language="erlang">{'DOWN', MonitorRef, socket, Object, Info}</pre> <p>In the monitor message <code>MonitorRef</code> and <code>Type</code> are the same as described earlier, and:</p> <dl> <dt class="title-link"><strong><code>Object</code></strong></dt> <dd> <p>The monitored entity, socket, which triggered the event. </p> </dd> <dt class="title-link"><strong><code>Info</code></strong></dt> <dd> <p>Either the termination reason of the socket or <code>nosock</code> (socket <code>Socket</code> did not exist at the time of monitor creation). </p> </dd> </dl> <p>Making several calls to <code>socket:monitor/1</code> for the same <code>Socket</code> is not an error; it results in as many independent monitoring instances. </p> </div></div></article><article class="func"><h3 id="number_of-0" class="bold_code title-link func-head">  <code>number_of() -&gt; <code>integer() &gt;= 0</code></code><div class="title-since"><span class="since">OTP 22.3</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the number of active sockets.</p> </div></div></article><article class="func"><h3 id="open-1" class="bold_code title-link func-head">  <code>open(FD) -&gt; {ok, Socket} | {error, Reason}</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <h3 id="open-2" class="bold_code title-link func-head">  <code>open(FD, Opts) -&gt; {ok, Socket} | {error, Reason}</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>FD = integer()</code></div> <div class="REFTYPES rt-1"><pre><code>Opts = 
 #{domain =&gt; <a href="#type-domain">domain()</a> | integer(),
 type =&gt; <a href="#type-type">type()</a> | integer(),
 protocol =&gt; default | <a href="#type-protocol">protocol()</a> | integer(),
 dup =&gt; boolean(),
 debug =&gt; boolean(),
 use_registry =&gt; boolean()}</code></pre></div> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | domain | type | protocol</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Creates an endpoint (socket) for communication based on an already existing file descriptor. The function attempts to retrieve <code>domain</code>, <code>type</code> and <code>protocol</code> from the system. This is however not possible on all platforms, and they should then be specified in <code>Opts</code>. </p> <p>The <code>Opts</code> argument is intended for providing extra information for the open call:</p> <dl> <dt class="title-link"><strong> <code>domain</code> </strong></dt> <dd> <p> Which protocol domain is the descriptor of. See also <code><a href="#open-3">open/2,3,4</a></code>. </p> </dd> <dt class="title-link"><strong> <code>type</code> </strong></dt> <dd> <p>Which protocol type type is the descriptor of.</p> <p> See also <code><a href="#open-3">open/2,3,4</a></code>. </p> </dd> <dt class="title-link"><strong> <code>protocol</code> </strong></dt> <dd> <p> Which protocol is the descriptor of. The atom <code>default</code> is equivalent to the integer protocol number <code>0</code> which means the default protocol for a given domain and type. </p> <p> If the protocol can not be retrieved from the platform for the socket, and <code>protocol</code> is not specified, the default protocol is used, which may or may not be correct. </p> <p> See also <code><a href="#open-3">open/2,3,4</a></code>. </p> </dd> <dt class="title-link"><strong><code>dup</code></strong></dt> <dd> <p>Shall the provided descriptor be duplicated (dup) or not. <br>Defaults to <code>true</code>. </p> </dd> <dt class="title-link"><strong><code>debug</code></strong></dt> <dd> <p>Enable or disable debug during the open call. <br>Defaults to <code>false</code>. </p> </dd> <dt class="title-link"><strong><code>use_registry&gt;</code></strong></dt> <dd> <p>Enable or disable use of the socket registry for this socket. This overrides the global value. <br>Defaults to the global value, see <code><a href="#use_registry-1">use_registry/1</a></code>. </p> </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function should be used with care! </p> <p> On some platforms it is <strong>necessary</strong> to provide <code>domain</code>, <code>type</code> and <code>protocol</code> since they cannot be retrieved from the platform. </p> </div> </div> </div></div></article><article class="func"><h3 id="open-2" class="bold_code title-link func-head">  <code>open(Domain, Type) -&gt; {ok, Socket} | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="open-3" class="bold_code title-link func-head">  <code>open(Domain, Type, Opts) -&gt; {ok, Socket} | {error, Reason}</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Domain = <a href="#type-domain">domain()</a> | integer()</code></div> <div class="REFTYPES rt-1"><code>Type = <a href="#type-type">type()</a> | integer()</code></div> <div class="REFTYPES rt-1"><code>Opts = map()</code></div> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | protocol</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Creates an endpoint (socket) for communication.</p> <p> The same as <code>open(Domain, Type, default)</code> and <code>open(Domain, Type, default, Opts)</code> respectively. </p> </div></div></article><article class="func"><h3 id="open-3" class="bold_code title-link func-head">  <code>open(Domain, Type, Protocol) -&gt; {ok, Socket} | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="open-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>open(Domain, Type, Protocol, Opts) -&gt;
 {ok, Socket} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Domain = <a href="#type-domain">domain()</a> | integer()</code></div> <div class="REFTYPES rt-1"><code>Type = <a href="#type-type">type()</a> | integer()</code></div> <div class="REFTYPES rt-1"><code>Protocol = default | <a href="#type-protocol">protocol()</a> | integer()</code></div> <div class="REFTYPES rt-1"><pre><code>Opts = 
 #{netns =&gt; string(),
 debug =&gt; boolean(),
 use_registry =&gt; boolean()}</code></pre></div> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | protocol</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Creates an endpoint (socket) for communication.</p> <p> <code>Domain</code> and <code>Type</code> may be <code>integer()</code>s, as defined in the platform's header files. The same goes for <code>Protocol</code> as defined in the platform's <code>services(5)</code> database. See also the OS man page for the library call <code>socket(2)</code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> For some combinations of <code>Domain</code> and <code>Type</code> the platform has got a default protocol that can be selected with <code>Protocol = default</code>, and the platform may allow or require selecting the default protocol, a specific protocol, or either. </p> <p>Examples:</p> <dl> <dt class="title-link"><strong><code>socket:open(inet, stream, tcp)</code></strong></dt> <dd> <p> It is common that for protocol domain and type <code>inet,stream</code> it is allowed to select the <code>tcp</code> protocol although that mostly is the default. </p> </dd> <dt class="title-link"><strong><code>socket:open(local, dgram)</code></strong></dt> <dd> <p> It is common that for the protocol domain <code>local</code> it is mandatory to not select a protocol, that is; to select the default protocol. </p> </dd> </dl> </div> </div> <p>The <code>Opts</code> argument is intended for "other" options. The supported option(s) are described below:</p> <dl> <dt class="title-link"><strong><code>netns: string()</code></strong></dt> <dd> <p>Used to set the network namespace during the open call. Only supported on the Linux platform. </p> </dd> <dt class="title-link"><strong><code>debug: boolean()</code></strong></dt> <dd> <p>Enable or disable debug during the open call. <br>Defaults to <code>false</code>. </p> </dd> <dt class="title-link"><strong><code>use_registry: boolean()</code></strong></dt> <dd> <p>Enable or disable use of the socket registry for this socket. This overrides the global value. <br>Defaults to the global value, see <code><a href="#use_registry-1">use_registry/1</a></code>. </p> </dd> </dl> </div></div></article><article class="func"><h3 id="peername-1" class="bold_code title-link func-head">  <code>peername(Socket) -&gt; {ok, SockAddr} | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>SockAddr = <a href="#type-sockaddr_recv">sockaddr_recv()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the address of the peer connected to the socket.</p> </div></div></article><article class="func"><h3 id="recv-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket) -&gt;
 {ok, Data} | {error, Reason} | {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recv-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Flags) -&gt;
 {ok, Data} | {error, Reason} | {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recv-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Length) -&gt;
 {ok, Data} | {error, Reason} | {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recv-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Flags, Timeout :: infinity) -&gt;
 {ok, Data} | {error, Reason} | {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recv-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Length, Flags) -&gt;
 {ok, Data} | {error, Reason} | {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recv-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Length, Timeout :: infinity) -&gt;
 {ok, Data} | {error, Reason} | {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recv-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Length, Flags, Timeout :: infinity) -&gt;
 {ok, Data} | {error, Reason} | {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Length = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>Data = binary()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Receives data from a socket, waiting for it to arrive. </p> <p> The argument <code>Length</code> specifies how many bytes to receive, with the special case <code>0</code> meaning "all available". </p> <p> For a socket of <code><a href="#type-type">type stream</a></code> this call will not return until all requested data can be delivered, or if "all available" data was requested when the first data chunk arrives. </p> <p> The message <code>Flags</code> may be symbolic <code><a href="#type-msg_flag">msg_flag()</a></code>s and/or <code>integer()</code>s, as in the platform's appropriate header files. The values of all symbolic flags and integers are or:ed together. </p> <p> When there is a socket error this function returns <code>{error, Reason}</code>, or if some data arrived before the error; <code>{error, {Reason, Data}}</code>. </p> </div></div></article><article class="func"><h3 id="recv-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Flags, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, Data} | {error, Reason} | {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recv-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Length, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, Data} | {error, Reason} | {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recv-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Length, Flags, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, Data} | {error, Reason} | {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Length = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>Data = binary()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a> | timeout</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Receives data from a socket, waiting at most <code>Timeout</code> milliseconds for it to arrive. </p> <p> The same as <code><a href="#recv-infinity"> infinite time-out recv/1,2,3,4 </a></code> but returns <code>{error, timeout}</code> or <code>{error, {timeout, Data}}</code> after <code>Timeout</code> milliseconds, if the requested data has not been delivered. </p> </div></div></article><article class="func"><h3 id="recv-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Flags, Handle :: nowait) -&gt;
 {ok, Data} |
 {select, SelectInfo} |
 {select, {SelectInfo, Data}} |
 {completion, CompletionInfo} |
 {error, Reason} |
 {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recv-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Flags,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 {ok, Data} |
 {select, SelectInfo} |
 {select, {SelectInfo, Data}} |
 {completion, CompletionInfo} |
 {error, Reason} |
 {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recv-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Length, Handle :: nowait) -&gt;
 {ok, Data} |
 {select, SelectInfo} |
 {select, {SelectInfo, Data}} |
 {completion, CompletionInfo} |
 {error, Reason} |
 {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="recv-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Length,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 {ok, Data} |
 {select, SelectInfo} |
 {select, {SelectInfo, Data}} |
 {completion, CompletionInfo} |
 {error, Reason} |
 {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recv-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Length, Flags, Handle :: nowait) -&gt;
 {ok, Data} |
 {select, SelectInfo} |
 {select, {SelectInfo, Data}} |
 {completion, CompletionInfo} |
 {error, Reason} |
 {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="recv-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Socket, Length, Flags,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 {ok, Data} |
 {select, SelectInfo} |
 {select, {SelectInfo, Data}} |
 {completion, CompletionInfo} |
 {error, Reason} |
 {error, {Reason, Data}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Length = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>Data = binary()</code></div> <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>CompletionInfo = <a href="#type-completion_info">completion_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Receives data from a socket, but returns a <code>select</code> or <code>completion</code> continuation if the data could not be returned immediately. </p> <p> The same as <code><a href="#recv-infinity"> infinite time-out recv/1,2,3,4 </a></code> but if the data can be delivered immediately, the function returns (on <i>Unix</i>) <code><a href="#type-select_info">{select, SelectInfo}</a></code> or (on <i>Windows</i>) <code><a href="#type-completion_info">{completion, CompletionInfo}</a></code>, and the caller will then receive one of these messages: </p> <dl> <dt class="title-link"><strong><code>select</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, select, SelectHandle}</code> (with the <code><a href="socket.html#type-select_handle">SelectHandle</a></code> that was contained in the <code><a href="#type-select_info">SelectInfo</a></code>) when data has arrived. </p> <p> A subsequent call to <code>recv/1,2,3,4</code> will then return the data. </p> </dd> <dt class="title-link"><strong><code>completion</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, completion, {CompletionHandle, CompletionStatus}}</code> (with the <code><a href="socket.html#type-completion_handle">CompletionHandle</a></code> contained in the <code><a href="#type-completion_info">CompletionInfo</a></code>). </p> <p> The <strong>result</strong> of the receive will be in the <code>CompletionStatus</code>. </p> </dd> </dl> <p> If <code>Handle</code> is a <code><a href="#type-select_handle">select_handle()</a></code> or <code><a href="#type-completion_handle">completion_handle()</a></code>, that term will be contained in a returned <code>SelectInfo</code> or <code>CompletionInfo</code> and the corresponding (select or completion) message. The <code>Handle</code> is presumed to be unique to this call. </p> <p> If the time-out argument is <code>nowait</code>, and a <code>SelectInfo</code> or <code>CompletionInfo</code> is returned, it will contain a <code><a href="socket.html#type-select_handle">select_handle()</a></code> or <code><a href="socket.html#type-completion_handle">completion_handle()</a></code> generated by the call. </p> <p> Note that for a socket of type <code>stream</code> (on <i>Unix</i>), if <code>Length &gt; 0</code> and only part of that amount of data is available, the function will return <code><a href="#type-select_info"> {ok, {Data, SelectInfo}} </a></code> with partial data. If the caller doesn't want to wait for more data, it must immediately call <code><a href="#cancel-2">cancel/2</a></code> to cancel the operation. </p> </div></div></article><article class="func"><h3 id="recvfrom-1" class="bold_code title-link func-head">  <code>recvfrom(Socket) -&gt; {ok, {Source, Data}} | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvfrom-2" class="bold_code title-link func-head">  <code>recvfrom(Socket, Flags) -&gt; {ok, {Source, Data}} | {error, Reason}</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recvfrom-2" class="bold_code title-link func-head">  <code>recvfrom(Socket, BufSz) -&gt; {ok, {Source, Data}} | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvfrom-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, Flags, Timeout :: infinity) -&gt;
 {ok, {Source, Data}} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvfrom-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, BufSz, Flags) -&gt;
 {ok, {Source, Data}} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvfrom-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, BufSz, Timeout :: infinity) -&gt;
 {ok, {Source, Data}} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvfrom-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, BufSz, Flags, Timeout :: infinity) -&gt;
 {ok, {Source, Data}} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>BufSz = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>Source = <a href="#type-sockaddr_recv">sockaddr_recv()</a></code></div> <div class="REFTYPES rt-1"><code>Data = binary()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Receive a message from a socket, waiting for it to arrive. </p> <p> The function returns when a message is received, or when there is a socket error. Argument <code>BufSz</code> specifies the number of bytes for the receive buffer. If the buffer size is too small, the message will be truncated. </p> <p> If <code>BufSz</code> is not specified or <code>0</code>, a default buffer size is used, which can be set by <code><a href="#setopt-3"> socket:setopt(Socket, {otp,recvbuf}, BufSz). </a></code> </p> <p> If it is impossible to know the appropriate buffer size, it may be possible to use the receive <code><a href="#type-msg_flag">message flag</a></code> <code>peek</code>. When this flag is used, the message is <strong>not</strong> "consumed" from the underlying buffers, so another <code>recvfrom/1,2,3,4</code> call is needed, possibly with an adjusted buffer size. </p> <p> The message <code>Flags</code> may be symbolic <code><a href="#type-msg_flag">msg_flag()</a></code>s and/or <code>integer()</code>s, as in the platform's appropriate header files. The values of all symbolic flags and integers are or:ed together. </p> </div></div></article><article class="func"><h3 id="recvfrom-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, Flags, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, {Source, Data}} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvfrom-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, BufSz, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, {Source, Data}} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvfrom-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, BufSz, Flags, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, {Source, Data}} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>BufSz = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>Source = <a href="#type-sockaddr_recv">sockaddr_recv()</a></code></div> <div class="REFTYPES rt-1"><code>Data = binary()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a> | timeout</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Receives a message from a socket, waiting at most <code>Timeout</code> milliseconds for it to arrive. </p> <p> The same as <code><a href="#recvfrom-infinity"> infinite time-out recvfrom/1,2,3,4 </a></code> but returns <code>{error, timeout}</code> after <code>Timeout</code> milliseconds, if no message has been delivered. </p> </div></div></article><article class="func"><h3 id="recvfrom-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, Flags, Handle :: nowait) -&gt;
 {ok, {Source, Data}} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="recvfrom-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, Flags,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 {ok, {Source, Data}} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recvfrom-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, BufSz, Handle :: nowait) -&gt;
 {ok, {Source, Data}} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="recvfrom-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, BufSz,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 {ok, {Source, Data}} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recvfrom-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, BufSz, Flags, Handle :: nowait) -&gt;
 {ok, {Source, Data}} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="recvfrom-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvfrom(Socket, BufSz, Flags,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 {ok, {Source, Data}} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>BufSz = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>Source = <a href="#type-sockaddr_recv">sockaddr_recv()</a></code></div> <div class="REFTYPES rt-1"><code>Data = binary()</code></div> <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>CompletionInfo = <a href="#type-completion_info">completion_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Receives a message from a socket, but returns a select continuation or a completion term if no message could be returned immediately. </p> <p> The same as <code><a href="#recvfrom-infinity"> infinite time-out recvfrom/1,2,3,4 </a></code> but if no message can be delivered immediately, the function returns (on <i>/Unix</i>) <code><a href="#type-select_info">{select, SelectInfo}</a></code> or (on <i>Windows</i>) <code><a href="#type-completion_info">{completion, CompletionInfo}</a></code>, and the caller will then receive one of these messages: </p> <dl> <dt class="title-link"><strong><code>select</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, select, SelectHandle}</code> (with the <code><a href="socket.html#type-select_handle">SelectHandle</a></code> that was contained in the <code><a href="#type-select_info">SelectInfo</a></code>) when data has arrived. </p> <p> A subsequent call to <code>recvfrom/1,2,3,4</code> will then return the message. </p> </dd> <dt class="title-link"><strong><code>completion</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, completion, {CompletionHandle, CompletionStatus}}</code> (with the <code><a href="socket.html#type-completion_handle">CompletionHandle</a></code> contained in the <code><a href="#type-completion_info">CompletionInfo</a></code>). </p> <p> The <strong>result</strong> of the receive will be in the <code>CompletionStatus</code>. </p> </dd> </dl> <p> If the <code>Handle</code> is a <code><a href="#type-select_handle">select_handle()</a></code> or <code><a href="#type-completion_handle">completion_handle()</a></code>, that term will be contained in a returned <code>SelectInfo</code> or <code>CompletionInfo</code> and the corresponding (select or completion) message. The <code>Handle</code> is presumed to be unique to this call. </p> <p> If the time-out argument is <code>nowait</code>, and a <code>SelectInfo</code> or <code>CompletionInfo</code> is returned, it will contain a <code><a href="socket.html#type-select_handle">select_handle()</a></code> or <code><a href="socket.html#type-completion_handle">completion_handle()</a></code> generated by the call. </p> <p> If the caller doesn't want to wait for the data, it must immediately call <code><a href="#cancel-2">cancel/2</a></code> to cancel the operation. </p> </div></div></article><article class="func"><h3 id="recvmsg-1" class="bold_code title-link func-head">  <code>recvmsg(Socket) -&gt; {ok, Msg} | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvmsg-2" class="bold_code title-link func-head">  <code>recvmsg(Socket, Flags) -&gt; {ok, Msg} | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvmsg-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, Timeout :: infinity) -&gt;
 {ok, Msg} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvmsg-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, Flags, Timeout :: infinity) -&gt;
 {ok, Msg} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvmsg-3" class="bold_code title-link func-head">  <code>recvmsg(Socket, BufSz, CtrlSz) -&gt; {ok, Msg} | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, BufSz, CtrlSz, Timeout :: infinity) -&gt;
 {ok, Msg} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recvmsg-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, BufSz, CtrlSz, Flags, Timeout :: infinity) -&gt;
 {ok, Msg} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>BufSz = CtrlSz = integer() &gt;= 0</code></div>  <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>Msg = <a href="#type-msg_recv">msg_recv()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Receive a message from a socket, waiting for it to arrive. </p> <p> The function returns when a message is received, or when there is a socket error. Arguments <code>BufSz</code> and <code>CtrlSz</code> specifies the number of bytes for the receive buffer and the control message buffer. If the buffer size(s) is(are) too small, the message and/or control message list will be truncated. </p> <p> If <code>BufSz</code> is not specified or <code>0</code>, a default buffer size is used, which can be set by <code><a href="#setopt-3"> socket:setopt(Socket, {otp,recvbuf}, BufSz). </a></code> The same applies to <code>CtrlSz</code> and <code><a href="#setopt-3"> socket:setopt(Socket, {otp,recvctrlbuf}, CtrlSz). </a></code> </p> <p> If it is impossible to know the appropriate buffer size, it may be possible to use the receive <code><a href="#type-msg_flag">message flag</a></code> <code>peek</code>. When this flag is used, the message is <strong>not</strong> "consumed" from the underlying buffers, so another <code>recvfrom/1,2,3,4,5</code> call is needed, possibly with an adjusted buffer size. </p> <p> The message <code>Flags</code> may be symbolic <code><a href="#type-msg_flag">msg_flag()</a></code>s and/or <code>integer()</code>s, as in the platform's appropriate header files. The values of all symbolic flags and integers are or:ed together. </p> </div></div></article><article class="func"><h3 id="recvmsg-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, Msg} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvmsg-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, Flags, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, Msg} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="recvmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, BufSz, CtrlSz, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, Msg} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recvmsg-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, BufSz, CtrlSz, Flags,
 Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, Msg} | {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>BufSz = CtrlSz = integer() &gt;= 0</code></div>  <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>Msg = <a href="#type-msg_recv">msg_recv()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a> | timeout</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Receives a message from a socket, waiting at most <code>Timeout</code> milliseconds for it to arrive. </p> <p> The same as <code><a href="#recvmsg-infinity">recvmsg/1,2,3,4,5</a></code> but returns <code>{error, timeout}</code> after <code>Timeout</code> milliseconds, if no message has been delivered. </p> </div></div></article><article class="func"><h3 id="recvmsg-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, Timeout :: nowait) -&gt;
 {ok, Msg} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="recvmsg-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 {ok, Msg} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recvmsg-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, Flags, Timeout :: nowait) -&gt;
 {ok, Msg} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="recvmsg-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, Flags,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 {ok, Msg} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recvmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, BufSz, CtrlSz, Timeout :: nowait) -&gt;
 {ok, Msg} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recvmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, BufSz, CtrlSz,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 {ok, Msg} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="recvmsg-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, BufSz, CtrlSz, Flags, Timeout :: nowait) -&gt;
 {ok, Msg} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="recvmsg-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recvmsg(Socket, BufSz, CtrlSz, Flags,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 {ok, Msg} |
 {select, SelectInfo} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>BufSz = CtrlSz = integer() &gt;= 0</code></div>  <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>Msg = <a href="#type-msg_recv">msg_recv()</a></code></div> <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>CompletionInfo = <a href="#type-completion_info">completion_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Receives a message from a socket, but returns a select continuation or a completion term if no message could be returned immediately. </p> <p> The same as <code><a href="#recvmsg-infinity"> infinite time-out recvmsg/1,2,3,4 </a></code> but if no message can delivered immediately, the function returns (on <i>Unix</i>) <code><a href="#type-select_info">{select, SelectInfo}</a></code> or (on <i>Windows</i>) <code><a href="#type-completion_info">{completion, CompletionInfo}</a></code>, and the caller will then receive one of these messages: </p> <dl> <dt class="title-link"><strong><code>select</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, select, SelectHandle}</code> (with the <code><a href="socket.html#type-select_handle">SelectHandle</a></code> that was contained in the <code><a href="#type-select_info">SelectInfo</a></code>) when data has arrived. </p> <p> A subsequent call to <code>recvmsg/1,2,3,4,5</code> will then return the data. </p> </dd> <dt class="title-link"><strong><code>completion</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, completion, {CompletionHandle, CompletionStatus}}</code> (with the <code><a href="socket.html#type-completion_handle">CompletionHandle</a></code> contained in the <code><a href="#type-completion_info">CompletionInfo</a></code>). </p> <p> The <strong>result</strong> of the receive will be in the <code>CompletionStatus</code>. </p> </dd> </dl> <p> If the <code>Handle</code> is a <code><a href="#type-select_handle">select_handle()</a></code> or <code><a href="#type-completion_handle">completion_handle()</a></code>, that term will be contained in a returned <code>SelectInfo</code> or <code>CompletionInfo</code> and the corresponding (select or completion) message. The <code>Handle</code> is presumed to be unique to this call. </p> <p> If the time-out argument is <code>nowait</code>, and a <code>SelectInfo</code> or <code>CompletionInfo</code> is returned, it will contain a <code><a href="socket.html#type-select_handle">select_handle()</a></code> or <code><a href="socket.html#type-completion_handle">completion_handle()</a></code> generated by the call. </p> <p> If the caller doesn't want to wait for the data, it must immediately call <code><a href="#cancel-2">cancel/2</a></code> to cancel the operation. </p> </div></div></article><article class="func"><h3 id="send-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="send-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Flags) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="send-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Timeout :: infinity) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="send-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Flags, Timeout :: infinity) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>RestData = binary()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends data on a connected socket, waiting for it to be sent. </p> <p> This call will not return until the <code>Data</code> has been accepted by the platform's network layer, or it reports an error. </p> <p> The message <code>Flags</code> may be symbolic <code><a href="#type-msg_flag">msg_flag()</a></code>s and/or <code>integer()</code>s, matching the platform's appropriate header files. The values of all symbolic flags and integers are or:ed together. </p> <p> The <code>Data</code>, if it is not a <code>binary()</code>, is copied into one before calling the platform network API, because a single buffer is required. A returned <code>RestData</code> is a sub binary of this data binary. </p> <p> The return value indicates the result from the platform's network layer: </p> <dl> <dt class="title-link"><strong><code>ok</code></strong></dt> <dd> <p> All data has been accepted. </p> </dd> <dt class="title-link"><strong><code>{ok, RestData}</code></strong></dt> <dd> <p> Not all data has been accepted, but no error has been reported. <code>RestData</code> is the tail of <code>Data</code> that has not been accepted. </p> <p> This cannot happen for a socket of <code><a href="#type-type">type stream</a></code> where a partially successful send is retried until the data is either accepted or there is an error. </p> <p> For a socket of <code><a href="#type-type">type dgram</a></code> this should probably also not happen since a message that cannot be passed atomically should render an error. </p> <p> It is nevertheless possible for the platform's network layer to return this. </p> </dd> <dt class="title-link"><strong><code>{error, Reason}</code></strong></dt> <dd> <p> An error has been reported and no data has been accepted. The <code><a href="#type-posix">posix()</a></code> <code>Reasons</code> are from the platform's network layer. <code>closed</code> means that this socket library knows that the socket is closed, and <code><a href="#type-invalid">invalid()</a></code> means that something about an argument is invalid. </p> </dd> <dt class="title-link"><strong> <code>{error, {Reason, RestData}}</code> </strong></dt> <dd> <p> An error has been reported but before that some data was accepted. <code>RestData</code> is the tail of <code>Data</code> that has not been accepted. See <code>{error, Reason}</code> above. </p> <p> This can only happen for a socket of <code><a href="#type-type">type stream</a></code> when a partially successful send is retried until there is an error. </p> </dd> </dl> </div></div></article><article class="func"><h3 id="send-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason | timeout} |
 {error, {Reason | timeout, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="send-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Flags, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason | timeout} |
 {error, {Reason | timeout, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>RestData = binary()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends data on a connected socket, waiting at most <code>Timeout</code> milliseconds for it to be sent. </p> <p> The same as <code><a href="#send-infinity"> infinite time-out send/2,3,4 </a></code> but returns <code>{error, timeout}</code> or <code>{error, {timeout, RestData}}</code> after <code>Timeout</code> milliseconds, if no <code>Data</code> or only some of it was accepted by the platform's network layer. </p> </div></div></article><article class="func"><h3 id="send-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Handle :: nowait) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="send-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="send-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Flags, Handle :: nowait) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="send-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Flags,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>RestData = binary()</code></div> <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>CompletionInfo = <a href="#type-completion_info">completion_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends data on a connected socket, but returns completion <strong>or</strong> a select continuation if the data could not be sent immediately. </p> <p> The same as <code><a href="#send-infinity"> infinite time-out send/2,3 </a></code> but if the data is not immediately accepted by the platform network layer, the function returns (on <i>Unix</i>) <code><a href="#type-select_info">{select, SelectInfo}</a></code> or (on <i>Windows</i>) <code><a href="#type-completion_info">{completion, CompletionInfo}</a></code>, and the caller will then receive one of these messages: </p> <dl> <dt class="title-link"><strong><code>select</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, select, SelectHandle}</code> ( with the <code><a href="socket.html#type-select_handle">SelectHandle</a></code> that was contained in the <code><a href="#type-select_info"> SelectInfo </a></code> ) when there is room for more data. </p> <p>A subsequent call to <code>send/2-4</code> will then send the data. </p> </dd> <dt class="title-link"><strong><code>completion</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, completion, {CompletionHandle, CompletionStatus}}</code> (with the <code><a href="socket.html#type-completion_handle">CompletionHandle</a></code> contained in the <code><a href="#type-completion_info">CompletionInfo</a></code>). </p> <p> The <strong>result</strong> of the send will be in the <code>CompletionStatus</code>. </p> </dd> </dl> <p> If <code>Handle</code> is a <code><a href="#type-select_handle">select_handle()</a></code> or <code><a href="#type-completion_handle">completion_handle()</a></code>, that term will be contained in a returned <code>SelectInfo</code> or <code>CompletionInfo</code> and the corresponding select or completion message. The <code>Handle</code> is presumed to be unique to this call. </p> <p> If <code>Handle</code> is <code>nowait</code>, and a <code>SelectInfo</code> or <code>CompletionInfo</code> is returned, it will contain a <code><a href="socket.html#type-select_handle">select_handle()</a></code> or <code><a href="socket.html#type-completion_handle">completion_handle()</a></code> generated by the call. </p> <p> If some of the data was sent, the function will return <code><a href="#type-select_info"> {select, {RestData, SelectInfo}, </a></code> which can only happen (on <i>Unix</i>) for a socket of <code><a href="#type-type">type stream</a></code>. If the caller does not want to wait to send the rest of the data, it should immediately cancel the operation with <code><a href="#cancel-2">cancel/2</a></code>. </p> </div></div></article><article class="func"><h3 id="send-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Cont) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="send-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Cont, Timeout :: infinity) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="send-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Cont, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason | timeout} |
 {error, {Reason | timeout, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="send-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Cont, SelectHandle :: nowait) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="send-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Socket, Data, Cont, SelectHandle :: <code><a href="#type-select_handle">select_handle()</a></code>) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>Cont = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>RestData = binary()</code></div> <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Continues sending data on a connected socket, where the send operation was initiated by <code><a href="#send-nowait">send/3,4</a></code> that returned a <code>SelectInfo</code> continuation. Otherwise like <code><a href="#send-infinity"> infinite time-out send/2,3,4 </a></code> , <code><a href="#send-timeout"> limited time-out send/3,4 </a></code> or <code><a href="#send-nowait"> nowait send/3,4 </a></code> respectively. </p> <p> <code>Cont</code> is the <code>SelectInfo</code> that was returned from the previous <code>send()</code> call. </p> <p> If <code>Data</code> is not a <code>binary()</code>, it will be copied into one, again. </p> <p> The return value indicates the result from the platform's network layer. See <code><a href="#send-infinity">send/2,3,4</a></code> and <code><a href="#send-nowait">nowait send/3,4</a></code>. </p> </div></div></article><article class="func"><h3 id="sendmsg-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Msg) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="sendmsg-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Msg, Flags) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="sendmsg-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Msg, Timeout :: infinity) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="sendmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Msg, Flags, Timeout :: infinity) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Msg = <a href="#type-msg_send">msg_send()</a></code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>RestData = erlang:iovec()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends a message on a socket, waiting for it to be sent. </p> <p> The destination, if needed, that is: if the socket is <strong>not</strong> connected, is provided in <code>Msg</code>, which also contains the data to send as a <code>list of binaries</code>. <code>Msg</code> may also contain an list of optional <code><a href="#type-cmsg_send">control messages</a></code> (depending on what the protocol and platform supports). </p> <p> For a connected socket no address field should be present in <code>Msg</code>, the platform may return an error or ignore one. </p> <p> The message data is given to to the platform's network layer in the form of an I/O vector without copying the content. If the number of elements in the I/O vector is larger than allowed on the platform (reported in the <code><a href="#type-info">iov_max</a></code> field from <code><a href="#info-0">info/0</a></code>), on a socket of <code><a href="#type-type">type stream</a></code> the send is iterated over all elements, but for other socket types the call fails. </p> <p> This call will not return until the data has been handed over to the platform's network layer, or when it reports an error. </p> <p> The message <code>Flags</code> may be symbolic <code><a href="#type-msg_flag">msg_flag()</a></code>s and/or <code>integer()</code>s, matching the platform's appropriate header files. The values of all symbolic flags and integers are or:ed together. </p> <p> The return value indicates the result from the platform's network layer. See <code><a href="#send-infinity">send/2,3,4</a></code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> On Windows, this function can only be used with datagram and raw sockets. </p> </div> </div> </div></div></article><article class="func"><h3 id="sendmsg-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Msg, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason | timeout} |
 {error, {Reason | timeout, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="sendmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Msg, Flags, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason | timeout} |
 {error, {Reason | timeout, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Msg = <a href="#type-msg_send">msg_send()</a></code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>RestData = erlang:iovec()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends a message on a socket, waiting at most <code>Timeout</code> milliseconds for it to be sent. </p> <p> The same as <code><a href="#sendmsg-infinity"> infinite time-out sendmsg/2,3,4 </a></code> but returns <code>{error, timeout}</code> or <code>{error, {timeout, RestData}}</code> after <code>Timeout</code> milliseconds, if no data or only some of it was accepted by the platform's network layer. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> On Windows, this function can only be used with datagram and raw sockets. </p> </div> </div> </div></div></article><article class="func"><h3 id="sendmsg-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Msg, Timeout :: nowait) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="sendmsg-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Msg,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Msg, Flags, Timeout :: nowait) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="sendmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Msg, Flags,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Msg = <a href="#type-msg_send">msg_send()</a></code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>RestData = erlang:iovec()</code></div> <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>CompletionInfo = <a href="#type-completion_info">completion_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends a message on a socket, but returns completion <strong>or</strong> a select continuation if the data could not be sent immediately. </p> <p> The same as <code><a href="#sendmsg-infinity"> infinity time-out sendmsg/2,3 </a></code> but if the data is not immediately accepted by the platform network layer, the function returns (on <i>Unix</i>) <code><a href="#type-select_info">{select, SelectInfo}</a></code> or (on <i>Windows</i>) <code><a href="#type-completion_info">{completion, CompletionInfo}</a></code>, and the caller will then receive one of these messages: </p> <dl> <dt class="title-link"><strong><code>select</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, select, SelectHandle}</code> ( with the <code><a href="socket.html#type-select_handle">SelectHandle</a></code> that was contained in the <code><a href="#type-select_info"> SelectInfo </a></code> ) when there is room for more data. A subsequent call to <code>sendmsg/2-4</code> will then send the data. </p> </dd> <dt class="title-link"><strong><code>completion</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, completion, {CompletionHandle, CompletionStatus}}</code> (with the <code><a href="socket.html#type-completion_handle">CompletionHandle</a></code> contained in the <code><a href="#type-completion_info">CompletionInfo</a></code>). </p> <p> The <strong>result</strong> of the send will be in the <code>CompletionStatus</code>. </p> </dd> </dl> <p> If <code>Handle</code>, is a <code><a href="#type-select_handle">select_handle()</a></code> or <code><a href="#type-completion_handle">completion_handle()</a></code>, that term will be contained in a returned <code>SelectInfo</code> or <code>CompletionInfo</code> and the corresponding select or completion message. The <code>Handle</code> is presumed to be unique to this call. </p> <p> If <code>Timeout</code> is <code>nowait</code>, and a <code>SelectInfo</code> or <code>CompletionInfo</code> is returned, it will contain a <code><a href="socket.html#type-select_handle">select_handle()</a></code> or <code><a href="socket.html#type-completion_handle">completion_handle()</a></code> generated by the call. </p> <p> If some of the data was sent, the function will return <code><a href="#type-select_info"> {select, {RestData, SelectInfo}, </a></code> which can only happen for a socket of <code><a href="#type-type">type stream</a></code>. If the caller does not want to wait to send the rest of the data, it should immediately cancel the operation with <code><a href="#cancel-2">cancel/2</a></code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> On Windows, this function can only be used with datagram and raw sockets. </p> </div> </div> </div></div></article><article class="func"><h3 id="sendmsg-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Data, Cont) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Data, Cont, Timeout :: infinity) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Data, Cont, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason | timeout} |
 {error, {Reason | timeout, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Data, Cont, Timeout :: nowait) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendmsg-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendmsg(Socket, Data, Cont, SelectHandle :: <code><a href="#type-select_handle">select_handle()</a></code>) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Data = <a href="#type-msg_send">msg_send()</a> | erlang:iovec()</code></div> <div class="REFTYPES rt-1"><code>Cont = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>RestData = erlang:iovec()</code></div> <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Continues sending a message data on a socket, where the send operation was initiated by <code><a href="#sendmsg-nowait">sendmsg/3,4</a></code> that returned a <code>SelectInfo</code> continuation. Otherwise like <code><a href="#sendmsg-infinity"> infinite time-out sendmsg/2,3,4 </a></code> , <code><a href="#sendmsg-timeout"> limited time-out sendmsg/3,4 </a></code> or <code><a href="#sendmsg-nowait"> nowait sendmsg/3,4 </a></code> respectively. </p> <p> <code>Cont</code> is the <code>SelectInfo</code> that was returned from the previous <code>sendmsg()</code> call. </p> <p> The return value indicates the result from the platform's network layer. See <code><a href="#send-infinity">send/2,3,4</a></code> and <code><a href="#sendmsg-nowait">nowait sendmsg/3,4</a></code>. </p> </div></div></article><article class="func"><h3 id="sendto-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Dest) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="sendto-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Dest, Flags) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="sendto-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Dest, Timeout :: infinity) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="sendto-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Dest, Flags, Timeout :: infinity) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>Dest = <a href="#type-sockaddr">sockaddr()</a></code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>RestData = binary()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends data on a socket, to the specified destination, waiting for it to be sent. </p> <p> This call will not return until the data has been accepted by the platform's network layer, or it reports an error. </p> <p> If this call is used on a connection mode socket or on a connected socket, the platforms's network layer may return an error or ignore the destination address. </p> <p> The message <code>Flags</code> may be symbolic <code><a href="#type-msg_flag">msg_flag()</a></code>s and/or <code>integer()</code>s, matching the platform's appropriate header files. The values of all symbolic flags and integers are or:ed together. </p> <p> The return value indicates the result from the platform's network layer. See <code><a href="#send-infinity">send/2,3,4</a></code>. </p> </div></div></article><article class="func"><h3 id="sendto-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Dest, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason | timeout} |
 {error, {Reason | timeout, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="sendto-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Dest, Flags, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason | timeout} |
 {error, {Reason | timeout, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>Dest = <a href="#type-sockaddr">sockaddr()</a></code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>RestData = binary()</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends data on a socket, waiting at most <code>Timeout</code> milliseconds for it to be sent. </p> <p> The same as <code><a href="#sendto-infinity"> infinite time-out sendto/3,4,5 </a></code> but returns <code>{error, timeout}</code> or <code>{error, {timeout, RestData}}</code> after <code>Timeout</code> milliseconds, if no <code>Data</code> or only some of it was accepted by the platform's network layer. </p> </div></div></article><article class="func"><h3 id="sendto-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Dest, Handle :: nowait) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="sendto-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Dest,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendto-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Dest, Flags, Handle :: nowait) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <h3 id="sendto-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Dest, Flags,
 Handle :: <code><a href="#type-select_handle">select_handle()</a></code> | <code><a href="#type-completion_handle">completion_handle()</a></code>) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {completion, CompletionInfo} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>Dest = <a href="#type-sockaddr">sockaddr()</a></code></div> <div class="REFTYPES rt-1"><code>Flags = [<a href="#type-msg_flag">msg_flag()</a> | integer()]</code></div> <div class="REFTYPES rt-1"><code>RestData = binary()</code></div> <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>CompletionInfo = <a href="#type-completion_info">completion_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends data on a socket, but returns completion <strong>or</strong> a select continuation if the data could not be sent immediately. </p> <p> The same as <code><a href="#sendto-infinity"> infinity time-out sendto/3,4 </a></code> but if the data is not immediately accepted by the platform network layer, the function returns (on <i>Unix</i>) <code><a href="#type-select_info">{select, SelectInfo}</a></code> or (on <i>Windows</i>) <code><a href="#type-completion_info">{completion, CompletionInfo}</a></code>, and the caller will then receive one of these messages: </p> <dl> <dt class="title-link"><strong><code>select</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, select, SelectHandle}</code> ( with the <code><a href="socket.html#type-select_handle">SelectHandle</a></code> that was contained in the <code><a href="#type-select_info"> SelectInfo </a></code> ) when there is room for more data. </p> <p>A subsequent call to <code>send/2-4</code> will then send the data. </p> </dd> <dt class="title-link"><strong><code>completion</code> message</strong></dt> <dd> <p> <code>{'$socket', Socket, completion, {CompletionHandle, CompletionStatus}}</code> (with the <code><a href="socket.html#type-completion_handle">CompletionHandle</a></code> contained in the <code><a href="#type-completion_info">CompletionInfo</a></code>). </p> <p> The <strong>result</strong> of the send will be in the <code>CompletionStatus</code>. </p> </dd> </dl> <p> If <code>Handle</code> is a <code><a href="#type-select_handle">select_handle()</a></code> or <code><a href="#type-completion_handle">completion_handle()</a></code>, that term will be contained in a returned <code>SelectInfo</code> or <code>CompletionInfo</code> and the corresponding select or completion message. The <code>Handle</code> is presumed to be unique to this call. </p> <p> If <code>Handle</code> is <code>nowait</code>, and a <code>SelectInfo</code> or <code>CompletionInfo</code> is returned, it will contain a <code><a href="socket.html#type-select_handle">select_handle()</a></code> or <code><a href="socket.html#type-completion_handle">completion_handle()</a></code> generated by the call. </p> <p> If some of the data was sent, the function will return <code><a href="#type-select_info"> {select, {RestData, SelectInfo}, </a></code> which can only happen (on <i>Unix</i>) for a socket of <code><a href="#type-type">type stream</a></code>. If the caller does not want to wait to send the rest of the data, it should immediately cancel the operation with <code><a href="#cancel-2">cancel/2</a></code>. </p> </div></div></article><article class="func"><h3 id="sendto-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Cont) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendto-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Cont, Timeout :: infinity) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason} |
 {error, {Reason, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendto-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Cont, Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 ok |
 {ok, RestData} |
 {error, Reason | timeout} |
 {error, {Reason | timeout, RestData}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendto-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Cont, SelectHandle :: nowait) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendto-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendto(Socket, Data, Cont, SelectHandle :: <code><a href="#type-select_handle">select_handle()</a></code>) -&gt;
 ok |
 {ok, RestData} |
 {select, SelectInfo} |
 {select, {SelectInfo, RestData}} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>Cont = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>RestData = binary()</code></div> <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Continues sending data on a socket, where the send operation was initiated by <code><a href="#sendto-nowait">sendto/4,5</a></code> that returned a <code>SelectInfo</code> continuation. Otherwise like <code><a href="#sendto-infinity"> infinite time-out sendto/3,4,5 </a></code> , <code><a href="#sendto-timeout"> limited time-out sendto/4,5 </a></code> or <code><a href="#sendto-nowait"> nowait sendto/4,5 </a></code> respectively. </p> <p> <code>Cont</code> is the <code>SelectInfo</code> that was returned from the previous <code>sendto()</code> call. </p> <p> If <code>Data</code> is not a <code>binary()</code>, it will be copied into one, again. </p> <p> The return value indicates the result from the platform's network layer. See <code><a href="#send-infinity">send/2,3,4</a></code> and <code><a href="#sendto-nowait">nowait sendto/4,5</a></code>. </p> </div></div></article><article class="func"><h3 id="sendfile-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendfile(Socket, FileHandle, Offset, Count, Timeout :: infinity) -&gt;
 {ok, BytesSent} |
 {error, Reason} |
 {error, {Reason, BytesSent}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>FileHandle = <a href="file.html#type-fd">file:fd()</a></code></div> <div class="REFTYPES rt-1"><code>Offset = integer()</code></div> <div class="REFTYPES rt-1"><code>Count = BytesSent = integer() &gt;= 0</code></div>  <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends file data on a socket, to the specified destination, waiting for it to be sent (<strong>"infinite" time-out</strong>). </p> <p> The <code>FileHandle</code> must refer to an open raw file as described in <code><a href="file.html#open-2">file:open/2</a></code>. </p> <p> This call will not return until the data has been accepted by the platform's network layer, or it reports an error. </p> <p> The <code>Offset</code> argument is the file offset to start reading from. The default value is <code>0</code>. </p> <p> The <code>Count</code> argument is the number of bytes to transfer from <code>FileHandle</code> to <code>Socket</code>. If <code>Count =:= 0</code> (the default) the transfer stops at the end of file. </p> <p> The return value indicates the result from the platform's network layer: </p> <dl> <dt class="title-link"><strong><code>{ok, BytesSent}</code></strong></dt> <dd> <p> The transfer completed successfully after <code>BytesSent</code> bytes of data. </p> </dd> <dt class="title-link"><strong><code>{error, Reason}</code></strong></dt> <dd> <p> An error has been reported and no data has been transferred. The <code><a href="#type-posix">posix()</a></code> <code>Reasons</code> are from the platform's network layer. <code>closed</code> means that this socket library knows that the socket is closed, and <code><a href="#type-invalid">invalid()</a></code> means that something about an argument is invalid. </p> </dd> <dt class="title-link"><strong> <code>{error, {Reason, BytesSent}}</code> </strong></dt> <dd> <p> An error has been reported but before that some data was transferred. See <code>{error, Reason}</code> and <code>{ok, BytesSent}</code> above. </p> </dd> </dl> </div></div></article><article class="func"><h3 id="sendfile-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendfile(Socket, FileHandle, Offset, Count,
 Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, BytesSent} |
 {error, Reason | timeout} |
 {error, {Reason | timeout, BytesSent}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>FileHandle = <a href="file.html#type-fd">file:fd()</a></code></div> <div class="REFTYPES rt-1"><code>Offset = integer()</code></div> <div class="REFTYPES rt-1"><code>Count = BytesSent = integer() &gt;= 0</code></div>  <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends file data on a socket, waiting at most <code>Timeout</code> milliseconds for it to be sent (<strong>limited time-out</strong>). </p> <p> The same as <code><a href="#sendfile-infinity"> "infinite" time-out sendfile/5 </a></code> but returns <code>{error, timeout}</code> or <code>{error, {timeout, BytesSent}}</code> after <code>Timeout</code> milliseconds, if not all file data was transferred by the platform's network layer. </p> </div></div></article><article class="func"><h3 id="sendfile-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendfile(Socket, FileHandle, Offset, Count,
 SelectHandle :: nowait) -&gt;
 {ok, BytesSent} |
 {select, SelectInfo} |
 {select, {SelectInfo, BytesSent}} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendfile-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendfile(Socket, FileHandle, Offset, Count,
 SelectHandle :: <code><a href="#type-select_handle">select_handle()</a></code>) -&gt;
 {ok, BytesSent} |
 {select, SelectInfo} |
 {select, {SelectInfo, BytesSent}} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>FileHandle = <a href="file.html#type-fd">file:fd()</a></code></div> <div class="REFTYPES rt-1"><code>Offset = integer()</code></div> <div class="REFTYPES rt-1"><code>Count = BytesSent = integer() &gt;= 0</code></div>  <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends file data on a socket, but returns a select continuation if the data could not be sent immediately (<strong>nowait</strong>). </p> <p> The same as <code><a href="#sendfile-infinity"> "infinite" time-out sendfile/5 </a></code> but if the data is not immediately accepted by the platform network layer, the function returns <code><a href="#type-select_info">{select, SelectInfo}</a></code>, and the caller will then receive a select message, <code>{'$socket', Socket, select, SelectHandle}</code> ( with the <code><a href="socket.html#type-select_handle">SelectHandle</a></code> that was contained in the <code><a href="#type-select_info"> SelectInfo </a></code> ) when there is room for more data. Then a call to <code><a href="#sendfile-cont">sendfile/3</a></code> with <code>SelectInfo</code> as the second argument will continue the data transfer. </p> <p> If <code>SelectHandle</code> is a <code><a href="#type-select_handle">select_handle()</a></code>, that term will be contained in a returned <code>SelectInfo</code> and the corresponding select message. The <code>SelectHandle</code> is presumed to be unique to this call. </p> <p> If <code>SelectHandle</code> is <code>nowait</code>, and a <code>SelectInfo</code> is returned, it will contain a <code><a href="socket.html#type-select_handle"> select_handle() </a></code> generated by the call. </p> <p> If some file data was sent, the function will return <code><a href="#type-select_info"> {ok, {BytesSent, SelectInfo}. </a></code> If the caller does not want to wait to send the rest of the data, it should immediately cancel the operation with <code><a href="#cancel-2">cancel/2</a></code>. </p> </div></div></article><article class="func"><h3 id="sendfile-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendfile(Socket, Cont, Offset, Count, Timeout :: infinity) -&gt;
 {ok, BytesSent} |
 {error, Reason} |
 {error, {Reason, BytesSent}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendfile-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendfile(Socket, Cont, Offset, Count,
 Timeout :: <code>integer() &gt;= 0</code>) -&gt;
 {ok, BytesSent} |
 {error, Reason | timeout} |
 {error, {Reason | timeout, BytesSent}}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendfile-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendfile(Socket, Cont, Offset, Count, SelectHandle :: nowait) -&gt;
 {ok, BytesSent} |
 {select, SelectInfo} |
 {select, {SelectInfo, BytesSent}} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <h3 id="sendfile-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sendfile(Socket, Cont, Offset, Count,
 SelectHandle :: <code><a href="#type-select_handle">select_handle()</a></code>) -&gt;
 {ok, BytesSent} |
 {select, SelectInfo} |
 {select, {SelectInfo, BytesSent}} |
 {error, Reason}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>Cont = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>Offset = integer()</code></div> <div class="REFTYPES rt-1"><code>Count = BytesSent = integer() &gt;= 0</code></div>  <div class="REFTYPES rt-1"><code>SelectInfo = <a href="#type-select_info">select_info()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed | <a href="#type-invalid">invalid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Continues sending file data on a socket, where the send operation was initiated by <code><a href="#sendfile-nowait">sendfile/3,5</a></code> that returned a <code>SelectInfo</code> continuation. Otherwise like <code><a href="#sendfile-infinity"> "infinite" time-out sendfile/5 </a></code> , <code><a href="#sendfile-timeout"> limited time-out sendfile/5 </a></code> or <code><a href="#sendfile-nowait"> nowait sendfile/5 </a></code> respectively. </p> <p> <code>Cont</code> is the <code>SelectInfo</code> that was returned from the previous <code>sendfile()</code> call. </p> <p> The return value indicates the result from the platform's network layer. See <code><a href="#sendfile-infinity"> "infinite" time-out sendfile/5. </a></code> </p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="sendfile-4" class="title-link">  <div class="title-name">sendfile(Socket, FileHandle, Offset, Count) -&gt; Result</div> <div class="title-since"><span class="since">OTP 24.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Socket = <a href="#type-socket">socket()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>FileHandle = <a href="file.html#type-fd">file:fd()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Offset = integer()</code><br> </div> <div class="REFTYPES rt-4"> <code>Count = integer() &gt;= 0</code><br> </div> </div> <div class="REFBODY rb-7"> <p> The same as <code><a href="#sendfile-infinity"> sendfile(Socket, FileHandle, Offset, Count, infinity), </a></code> that is: send the file data at <code>Offset</code> and <code>Count</code> to the socket, without time-out other than from the platform's network stack. </p> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="sendfile-3" class="title-link">  <div class="title-name">sendfile(Socket, FileHandle, Timeout) -&gt; Result</div> <div class="title-since"><span class="since">OTP 24.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Socket = <a href="#type-socket">socket()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>FileHandle = <a href="file.html#type-fd">file:fd()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Timeout = timeout() | 'nowait' | <a href="#type-select_handle">select_handle()</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p> Depending on the <code>Timeout</code> argument; the same as <code><a href="#sendfile-infinity"> sendfile(Socket, FileHandle, 0, 0, infinity), </a></code> <code><a href="#sendfile-timeout"> sendfile(Socket, FileHandle, 0, 0, Timeout), </a></code> or <code><a href="#sendfile-nowait"> sendfile(Socket, FileHandle, 0, 0, SelectHandle), </a></code> that is: send all data in the file to the socket, with the given <code>Timeout</code>. </p> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="sendfile-2" class="title-link">  <div class="title-name">sendfile(Socket, FileHandle) -&gt; Result</div> <div class="title-since"><span class="since">OTP 24.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Socket = <a href="#type-socket">socket()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>FileHandle = <a href="file.html#type-fd">file:fd()</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p> The same as <code><a href="#sendfile-infinity"> sendfile(Socket, FileHandle, 0, 0, infinity), </a></code> that is: send all data in the file to the socket, without time-out other than from the platform's network stack. </p> </div> </div></article><article class="func"><h3 id="setopt-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>setopt(Socket :: <code><a href="#type-socket">socket()</a></code>,
 SocketOption :: {Level :: otp, Opt :: <code><a href="#type-otp_socket_option">otp_socket_option()</a></code>},
 Value :: <code>term()</code>) -&gt;
 ok | {error, <code><a href="#type-invalid">invalid()</a></code> | closed}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sets a socket option in the protocol level <code>otp</code>, which is this implementation's level above the OS protocol layers. </p> <p> See the type <code><a href="#type-otp_socket_option"> otp_socket_option() </a></code> for a description of the options on this level. </p> </div></div></article><article class="func"><h3 id="setopt-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>setopt(Socket :: <code><a href="#type-socket">socket()</a></code>,
 SocketOption :: <code><a href="#type-socket_option">socket_option()</a></code>,
 Value :: <code>term()</code>) -&gt;
 ok | {error, <code><a href="#type-posix">posix()</a></code> | <code><a href="#type-invalid">invalid()</a></code> | closed}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Set a socket option in one of the OS's protocol levels. See the type <code><a href="#type-socket_option">socket_option()</a></code> for which options that this implementation knows about, how they are related to option names in the OS, and if there are known peculiarities with any of them. </p> <p> What options are valid depends on what kind of socket it is (<code><a href="#type-domain">domain()</a></code>, <code><a href="#type-type">type()</a></code> and <code><a href="#type-protocol">protocol()</a></code>). </p> <p> See the <code><a href="socket_usage.html#socket_options"> socket options </a></code> chapter of the users guide for more info. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Not all options are valid, nor possible to set, on all platforms. That is, even if "we" support an option; it does not mean that the underlying OS does. </p> </div> </div> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="setopt-4" class="title-link">  <div class="title-name">setopt(Socket, Level, Opt, Value) -&gt; ok | {error, Reason}</div> <div class="title-since"><span class="since">OTP 22.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Socket = <a href="#type-socket">socket()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Value = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>Reason = <a href="inet.html#type-posix">inet:posix()</a> | <a href="#type-invalid">invalid()</a> | closed</code><br> </div> </div> <div class="REFBODY rb-7"> <p>Backwards compatibility function.</p> <p> The same as <code><a href="#setopt-3"> setopt(Socket, {Level, Opt}, Value) </a></code> </p> </div> </div></article><article class="func"><h3 id="setopt_native-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>setopt_native(Socket :: <code><a href="#type-socket">socket()</a></code>,
 SocketOption ::
 <code><a href="#type-socket_option">socket_option()</a></code> |
 {Level :: <code><a href="#type-level">level()</a></code> | (NativeLevel :: <code>integer()</code>),
 NativeOpt :: <code>integer()</code>},
 Value :: <code><a href="#type-native_value">native_value()</a></code>) -&gt;
 ok | {error, <code><a href="#type-posix">posix()</a></code> | <code><a href="#type-invalid">invalid()</a></code> | closed}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sets a socket option that may be unknown to our implementation, or that has a type not compatible with our implementation, that is; in "native mode". </p> <p> If <code>Value</code> is an <code>integer()</code> it will be used as a <code>C</code> type <code>(int)</code>, if it is a <code>boolean()</code> it will be used as a <code>C</code> type <code>(int)</code> with the <code>C</code> implementations values for <code>false</code> or <code>true</code>, and if it is a <code>binary()</code> its content and size will be used as the option value. </p> <p> The socket option may be specified with an ordinary <code><a href="#type-socket_option"> socket_option() </a></code> tuple, with a known <code><a href="#type-level"> Level = level() </a></code> and an integer <code>NativeOpt</code>, or with both an integer <code>NativeLevel</code> and <code>NativeOpt</code>. </p> <p> What options are valid depends on what kind of socket it is (<code><a href="#type-domain">domain()</a></code>, <code><a href="#type-type">type()</a></code> and <code><a href="#type-protocol">protocol()</a></code>). </p> <p> The integer values for <code>NativeLevel</code> and <code>NativeOpt</code> as well as the encoding of <code>Value</code> has to be deduced from the header files for the running system. </p> </div></div></article><article class="func"><h3 id="shutdown-2" class="bold_code title-link func-head">  <code>shutdown(Socket, How) -&gt; ok | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>How = read | write | read_write</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Shut down all or part of a full-duplex connection.</p> </div></div></article><article class="func"><h3 id="sockname-1" class="bold_code title-link func-head">  <code>sockname(Socket) -&gt; {ok, SockAddr} | {error, Reason}</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Socket = <a href="#type-socket">socket()</a></code></div> <div class="REFTYPES rt-1"><code>SockAddr = <a href="#type-sockaddr_recv">sockaddr_recv()</a></code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="#type-posix">posix()</a> | closed</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the current address to which the socket is bound.</p> </div></div></article><article class="func"><h3 id="supports-0" class="bold_code title-link func-head">  <pre data-language="erlang"><code>supports() -&gt;
 [{Key1 :: <code>term()</code>,
 <code>boolean()</code> |
 [{Key2 :: <code>term()</code>,
 <code>boolean()</code> | [{Key3 :: <code>term()</code>, <code>boolean()</code>}]}]}]</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="supports-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>supports(Key1 :: <code>term()</code>) -&gt;
 [{Key2 :: <code>term()</code>,
 <code>boolean()</code> | [{Key3 :: <code>term()</code>, <code>boolean()</code>}]}]</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="supports-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>supports(Key1 :: <code>term()</code>, Key2 :: <code>term()</code>) -&gt;
 [{Key3 :: <code>term()</code>, <code>boolean()</code>}]</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> These functions function retrieves information about what the platform supports, such which platform features or which socket options, are supported. </p> <p> For keys other than the known the empty list is returned, Note that in a future version or on a different platform there might be more supported items. </p> <dl> <dt class="title-link"><strong><code>supports()</code></strong></dt> <dd> <p> Returns a list of <code>{Key1, supports(Key1)}</code> tuples for every <code>Key1</code> described in <code><a href="#supports-1">supports/1</a></code> and <code>{Key1, boolean()}</code> tuples for each of the following keys: </p> <dl> <dt class="title-link"><strong><code>sctp</code></strong></dt> <dd>SCTP support</dd> <dt class="title-link"><strong><code>ipv6</code></strong></dt> <dd>IPv6 support</dd> <dt class="title-link"><strong><code>local</code></strong></dt> <dd> Unix Domain sockets support (<code>AF_UNIX | AF_LOCAL</code>) </dd> <dt class="title-link"><strong><code>netns</code></strong></dt> <dd> Network Namespaces support (Linux, <code>setns(2)</code>) </dd> <dt class="title-link"><strong><code>sendfile</code></strong></dt> <dd> Sendfile support (<code>sendfile(2)</code>) </dd> </dl>  </dd> <dt class="title-link"><strong><code>supports(msg_flags = Key1)</code></strong></dt> <dd> <p> Returns a list of <code>{Flag, boolean()}</code> tuples for every <code>Flag</code> in <code><a href="#type-msg_flag"> msg_flag() </a></code> with the <code>boolean()</code> indicating if the flag is supported on this platform. </p> </dd> <dt class="title-link"><strong><code>supports(protocols = Key1)</code></strong></dt> <dd> <p> Returns a list of <code>{Name :: atom(), boolean()}</code> tuples for every <code>Name</code> in <code><a href="#type-protocol"> protocol() </a></code> with the <code>boolean()</code> indicating if the protocol is supported on this platform. </p> </dd> <dt class="title-link"><strong><code>supports(options = Key1)</code></strong></dt> <dd> <p> Returns a list of <code>{SocketOption, boolean()}</code> tuples for every <code>SocketOption</code> in <code><a href="#type-socket_option"> socket_option() </a></code> with the <code>boolean()</code> indicating if the socket option is supported on this platform. </p> </dd> <dt class="title-link"><strong> <code>supports(options = Key1, Key2)</code> </strong></dt> <dd> <p> For a <code>Key2</code> in <code><a href="#type-level"> level() </a></code> returns a list of <code>{Opt, boolean()}</code> tuples for all known <code><a href="#type-socket_option"> socket options Opt on that Level =:= Key2, </a></code> and the <code>boolean()</code> indicating if the socket option is supported on this platform. See <code><a href="#setopt-3">setopt/3</a></code> and <code><a href="#getopt-2">getopt/2</a></code>. </p> </dd> </dl> </div></div></article><article class="func"><h3 id="use_registry-1" class="bold_code title-link func-head">  <code>use_registry(D :: <code>boolean()</code>) -&gt; ok</code><div class="title-since"><span class="since">OTP 23.1</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Globally change if the socket registry is to be used or not. Note that its still possible to override this explicitly when creating an individual sockets, see <code><a href="socket.html#open-2">open/2</a></code> or <code><a href="socket.html#open-4">open/4</a></code> for more info (use the Extra argument). </p> </div></div></article><article class="func"><h3 id="which_sockets-0" class="bold_code title-link func-head">  <code>which_sockets() -&gt; [<code><a href="#type-socket">socket()</a></code>]</code><div class="title-since"><span class="since">OTP 22.3</span></div> </h3> <h3 id="which_sockets-1" class="bold_code title-link func-head">  <code>which_sockets(FilterRule) -&gt; [<code><a href="#type-socket">socket()</a></code>]</code><div class="title-since"><span class="since">OTP 22.3</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><pre><code>FilterRule = 
 inet | inet6 | local | stream | dgram | seqpacket | sctp |
 tcp | udp |
 pid() |
 fun((<a href="#type-socket_info">socket_info()</a>) -&gt; boolean())</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list of all sockets, according to the filter rule.</p> <p>There are several pre-made filter rule(s) and one general: </p> <dl> <dt class="title-link"><strong><code>inet | inet6</code></strong></dt> <dd> <p>Selection based on the domain of the socket. <br>Only a subset is valid. </p> </dd> <dt class="title-link"><strong><code>stream | dgram | seqpacket</code></strong></dt> <dd> <p>Selection based on the type of the socket. <br>Only a subset is valid. </p> </dd> <dt class="title-link"><strong><code>sctp | tcp | udp</code></strong></dt> <dd> <p>Selection based on the protocol of the socket. <br>Only a subset is valid. </p> </dd> <dt class="title-link"><strong><code>pid()</code></strong></dt> <dd> <p>Selection base on which sockets has this pid as Controlling Process. </p> </dd> <dt class="title-link"><strong><code>fun((socket_info()) -&gt; boolean())</code></strong></dt> <dd> <p>The general filter rule. <br>A fun that takes the socket info and returns a <code>boolean()</code> (<code>true</code> if the socket could be included and <code>false</code> if should not). </p> </dd> </dl> </div></div></article> </div> <section class="innertube"><h2 id="examples" class="title-link"> <div class="title-name">Examples</div>  </h2> <div class="REFBODY rb-3">  <pre id="examples" data-language="erlang">client(SAddr, SPort) -&gt;
   {ok, Sock} = socket:open(inet, stream, tcp),
   ok = socket:connect(Sock, #{family =&gt; inet,
                               addr   =&gt; SAddr,
                               port   =&gt; SPort}),
   Msg = &lt;&lt;"hello"&gt;&gt;,
   ok = socket:send(Sock, Msg),
   ok = socket:shutdown(Sock, write),
   {ok, Msg} = socket:recv(Sock),
   ok = socket:close(Sock).

server(Addr, Port) -&gt;  
   {ok, LSock} = socket:open(inet, stream, tcp),
   ok = socket:bind(LSock, #{family =&gt; inet,
                             port   =&gt; Port,
                             addr   =&gt; Addr}),
   ok = socket:listen(LSock),
   {ok, Sock} = socket:accept(LSock),
   {ok, Msg} = socket:recv(Sock),
   ok = socket:send(Sock, Msg),
   ok = socket:close(Sock),
   ok = socket:close(LSock).</pre> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
