<div class="innertube"> <h1 id="Socket Usage">2 Socket Usage</h1> <h2 id="introduction" class="title-link"> <div class="title-name">2.1 Introduction</div>  </h2> <p>The socket interface (module) is basically a "thin" layer on top of the OS socket interface. It is assumed that, unless you have special needs, gen_[tcp|udp|sctp] should be sufficient (when they become available). </p> <p>Note that just because we have a documented and described option, it does <strong>not</strong> mean that the OS supports it. So its recommended that the user reads the platform specific documentation for the option used. </p> <h3 id="asynchronous-calls" class="title-link"> <div class="title-name">Asynchronous calls</div>  </h3> <p> Some functions allow for an <i>asynchronous</i> call (<code><a href="socket.html#accept-nowait">accept/2</a></code>, <code><a href="socket.html#connect-nowait">connect/3</a></code>, <code><a href="socket.html#recv-nowait">recv/3,4</a></code>, <code><a href="socket.html#recvfrom-nowait">recvfrom/3,4</a></code>, <code><a href="socket.html#recvmsg-nowait">recvmsg/2,3,5</a></code>, <code><a href="socket.html#send-nowait">send/3,4</a></code>, <code><a href="socket.html#sendmsg-nowait">sendmsg/3,4</a></code> and <code><a href="socket.html#sendto-nowait">sendto/4,5</a></code>). This is achieved by setting the <code>Timeout</code> argument to <code>nowait</code>. For instance, if calling the <code><a href="socket.html#recv-nowait">recv/3</a></code> function with Timeout set to <code>nowait</code> (i.e. <code>recv(Sock, 0, nowait)</code>) when there is actually nothing to read, it will return with: </p> <dl> <dt class="title-link"><strong>On Unix</strong></dt> <dd> <p> <code>{select,</code> <code><a href="socket.html#type-select_info">SelectInfo</a></code><code>}</code> </p> <p> <code>SelectInfo</code> contains the <code><a href="socket.html#type-select_handle">SelectHandle</a></code>. </p> </dd> <dt class="title-link"><strong>On Windows</strong></dt> <dd> <p> <code>{completion,</code> <code><a href="socket.html#type-completion_info">CompletionInfo</a></code><code>}</code> </p> <p> <code>CompletionInfo</code> contains the <code><a href="socket.html#type-completion_handle">CompletionHandle</a></code>. </p> </dd> </dl> <p>When data eventually arrives a 'select' or 'completion' message will be sent to the caller:</p> <dl> <dt class="title-link"><strong>On Unix</strong></dt> <dd> <p> <code>{'$socket', socket(), select, SelectHandle}</code> </p> <p> The caller can then make another call to the recv function and now expect data. </p> <p> Note that all other users are <strong>locked out</strong> until the 'current user' has called the function (recv in this case). So either immediately call the function or <code><a href="socket.html#cancel-2">cancel</a></code>. </p> </dd> <dt class="title-link"><strong>On Windows</strong></dt> <dd> <p> <code>{'$socket', socket(), completion, {CompletionHandle, CompletionStatus}}</code> </p> <p> The <code>CompletionStatus</code> contains the result of the operation (read). </p> </dd> </dl> <p>The user must also be prepared to receive an abort message: </p> <dl>  <dd><code>{'$socket', socket(), abort, Info}</code></dd> </dl> <p>If the operation is aborted for whatever reason (e.g. if the socket is closed "by someone else"). The <code>Info</code> part contains the abort reason (in this case that the socket has been closed <code>Info = {SelectHandle, closed}</code>). </p> <p>The general form of the 'socket' message is: </p> <dl>  <dd><code>{'$socket', Sock :: socket(), Tag :: atom(), Info :: term()}</code></dd> </dl> <p>Where the format of <code>Info</code> is a function of <code>Tag</code>:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Tag</strong></td> <td><strong>Info value type</strong></td> </tr> <tr> <td>select</td> <td>select_handle()</td> </tr> <tr> <td>completion</td> <td>{completion_handle(), CompletionStatus}</td> </tr> <tr> <td>abort</td> <td>{select_handle(), Reason :: term()}</td> </tr> </table> <p class="doc-table-caption">Table 2.1: socket message info value type</p> </div> <p>The <code>select_handle()</code> is the same as was returned in the <code><a href="socket.html#type-select_info">SelectInfo</a></code>. </p> <p>The <code>completion_handle()</code> is the same as was returned in the <code><a href="socket.html#type-completion_info">CompletionInfo</a></code>. </p> <h2 id="socket-registry" class="title-link"> <div class="title-name">2.2 Socket Registry</div>  </h2> <p>The <strong>socket registry</strong> is how we keep track of sockets. There are two functions that can be used for interaction: <code><a href="socket.html#number_of-0">socket:number_of/0</a></code> and <code><a href="socket.html#which_sockets-1">socket:which_sockets/1</a></code>. </p> <p>In systems which create and delete <strong>many</strong> sockets dynamically, it (the socket registry) could become a bottleneck. For such systems, there are a couple of ways to control the use of the socket registry. </p> <p>Firstly, its possible to effect the global default value when building OTP from source with the two configure options:</p> <pre data-language="erlang">--enable-esock-socket-registry (default) | --disable-esock-socket-registry</pre> <p>Second, its possible to effect the global default value by setting the environment variable <code>ESOCK_USE_SOCKET_REGISTRY</code> (boolean) before starting the erlang. </p> <p>Third, its possible to alter the global default value in runtime by calling the function <code><a href="socket.html#use_registry-1">use_registry/1</a></code>.</p> <p>And finally, its possible to override the global default when creating a socket (with <code><a href="socket.html#open-2">open/2</a></code> and <code><a href="socket.html#open-4">open/4</a></code>) by providing the attribute <code>use_registry</code> (boolean) in the their <code>Opts</code> argument (which effects <strong>that</strong> specific socket).</p> <h2 id="socket-options" class="title-link"> <div class="title-name">2.3 Socket Options</div>  </h2> <p>Options for level <code>otp</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>assoc_id</td> <td>integer()</td> <td>no</td> <td>yes</td> <td>type = seqpacket, protocol = sctp, is an association</td> </tr> <tr> <td>debug</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>iow</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>controlling_process</td> <td>pid()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>rcvbuf</td> <td>default | pos_integer() | {pos_integer(), pos_ineteger()}</td> <td>yes</td> <td>yes</td> <td> The tuple format is <strong>not</strong> allowed on Windows. 'default' only valid for set. The tuple form is only valid for type 'stream' and protocol 'tcp'. </td> </tr> <tr> <td>rcvctrlbuf</td> <td>default | pos_integer()</td> <td>yes</td> <td>yes</td> <td>default only valid for set</td> </tr> <tr> <td>sndctrlbuf</td> <td>default | pos_integer()</td> <td>yes</td> <td>yes</td> <td>default only valid for set</td> </tr> <tr> <td>fd</td> <td>integer()</td> <td>no</td> <td>yes</td> <td>none</td> </tr> <tr> <td>use_registry</td> <td>boolean()</td> <td>no</td> <td>yes</td> <td>the value is set when the socket is created, by a call to <code><a href="socket.html#open-2">open/2</a></code> or <code><a href="socket.html#open-4">open/4</a></code>.</td> </tr> </table> <p class="doc-table-caption">Table 2.2: option levels</p> </div> <p>Options for level <code>socket</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>acceptconn</td> <td>boolean()</td> <td>no</td> <td>yes</td> <td>none</td> </tr> <tr> <td>bindtodevice</td> <td>string()</td> <td>yes</td> <td>yes</td> <td>Before Linux 3.8, this socket option could be set, but not get. Only works for some socket types (e.g. <code>inet</code>). If empty value is set, the binding is removed.</td> </tr> <tr> <td>broadcast</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram</td> </tr> <tr> <td>debug</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>may require admin capability</td> </tr> <tr> <td>domain</td> <td>domain()</td> <td>no</td> <td>yes</td> <td> <strong>Not</strong> on FreeBSD (for instance)</td> </tr> <tr> <td>dontroute</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>keepalive</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>linger</td> <td>abort | linger()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>oobinline</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>peek_off</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>domain = local (unix). Currently disabled due to a possible infinite loop when calling recv([peek]) the second time. </td> </tr> <tr> <td>priority</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>protocol</td> <td>protocol()</td> <td>no</td> <td>yes</td> <td> <strong>Not</strong> on (some) Darwin (for instance)</td> </tr> <tr> <td>rcvbuf</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>rcvlowat</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>rcvtimeo</td> <td>timeval()</td> <td>yes</td> <td>yes</td> <td> This option is not normally supported (see why below). OTP has to be explicitly built with the <code>--enable-esock-rcvsndtime</code> configure option for this to be available. Since our implementation is <strong>nonblocking</strong>, its unknown if and how this option works, or even if it may cause malfunctions. Therefore, we do not recommend setting this option. Instead, use the <code>Timeout</code> argument to, for instance, the <code><a href="socket.html#recv-3">recv/3</a></code> function. </td> </tr> <tr> <td>reuseaddr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>reuseport</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>domain = inet | inet6</td> </tr> <tr> <td>sndbuf</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>sndlowat</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>not changeable on Linux</td> </tr> <tr> <td>sndtimeo</td> <td>timeval()</td> <td>yes</td> <td>yes</td> <td> This option is not normally supported (see why below). OTP has to be explicitly built with the <code>--enable-esock-rcvsndtime</code> configure option for this to be available. Since our implementation is <strong>nonblocking</strong>, its unknown if and how this option works, or even if it may cause malfunctions. Therefore, we do not recommend setting this option. Instead, use the <code>Timeout</code> argument to, for instance, the <code><a href="socket.html#send-3">send/3</a></code> function. </td> </tr> <tr> <td>timestamp</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>type</td> <td>type()</td> <td>no</td> <td>yes</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.3: socket options</p> </div> <p>Options for level <code>ip</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>add_membership</td> <td>ip_mreq()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>add_source_membership</td> <td>ip_mreq_source()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>block_source</td> <td>ip_mreq_source()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>drop_membership</td> <td>ip_mreq()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>drop_source_membership</td> <td>ip_mreq_source()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>freebind</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>hdrincl</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>minttl</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>msfilter</td> <td>null | ip_msfilter()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>mtu</td> <td>integer()</td> <td>no</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>mtu_discover</td> <td>ip_pmtudisc()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_all</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_if</td> <td>any | ip4_address()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_loop</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_ttl</td> <td>uint8()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>nodefrag</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>pktinfo</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram</td> </tr> <tr> <td>recvdstaddr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram</td> </tr> <tr> <td>recverr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>recvif</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw</td> </tr> <tr> <td>recvopts</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type =/= stream</td> </tr> <tr> <td>recvorigdstaddr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>recvttl</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type =/= stream</td> </tr> <tr> <td>retopts</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type =/= stream</td> </tr> <tr> <td>router_alert</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>sendsrcaddr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>tos</td> <td>ip_tos()</td> <td>yes</td> <td>yes</td> <td>some high-priority levels may require superuser capability</td> </tr> <tr> <td>transparent</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>requires admin capability</td> </tr> <tr> <td>ttl</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>unblock_source</td> <td>ip_mreq_source()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.4: ip options</p> </div> <p>Options for level <code>ipv6</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>addrform</td> <td>inet</td> <td>yes</td> <td>no</td> <td>allowed only for IPv6 sockets that are connected and bound to a v4-mapped-on-v6 address</td> </tr> <tr> <td>add_membership</td> <td>ipv6_mreq()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>authhdr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw, obsolete?</td> </tr> <tr> <td>drop_membership</td> <td>ipv6_mreq()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>dstopts</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw, requires superuser privileges to update</td> </tr> <tr> <td>flowinfo</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw, requires superuser privileges to update</td> </tr> <tr> <td>hoplimit</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw. On some platforms (e.g. FreeBSD) is used to set in order to get <code>hoplimit</code> as a control message heeader. On others (e.g. Linux), <code>recvhoplimit</code> is set in order to get <code>hoplimit</code>. </td> </tr> <tr> <td>hopopts</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw, requires superuser privileges to update</td> </tr> <tr> <td>mtu</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>Get: Only after the socket has been connected</td> </tr> <tr> <td>mtu_discover</td> <td>ipv6_pmtudisc()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_hops</td> <td>default | uint8()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_if</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw</td> </tr> <tr> <td>multicast_loop</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>recverr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>recvhoplimit</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw. On some platforms (e.g. Linux), <code>recvhoplimit</code> is set in order to get <code>hoplimit</code> </td> </tr> <tr> <td>recvpktinfo | pktinfo</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw. On some platforms (e.g. FreeBSD) is used to set in order to get <code>hoplimit</code> as a control message heeader. On others (e.g. Linux), <code>recvhoplimit</code> is set in order to get <code>hoplimit</code>. </td> </tr> <tr> <td>recvtclass</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw. On some platforms is used to set (=true) in order to get the <code>tclass</code> control message heeader. On others, <code>tclass</code> is set in order to get <code>tclass</code> control message heeader. </td> </tr> <tr> <td>router_alert</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>rthdr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw, requires superuser privileges to update</td> </tr> <tr> <td>tclass</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>Set the traffic class associated with outgoing packets. RFC3542. </td> </tr> <tr> <td>unicast_hops</td> <td>default | uint8()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>v6only</td> <td>boolean()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.5: ipv6 options</p> </div> <p>Options for level <code>tcp</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>congestion</td> <td>string()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>maxseg</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>Set not allowed on all platforms.</td> </tr> <tr> <td>nodelay</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.6: tcp options</p> </div> <p>Options for level <code>udp</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>cork</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.7: udp options</p> </div> <p>Options for level <code>sctp</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>associnfo</td> <td>sctp_assocparams()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>autoclose</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>disable_fragments</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>events</td> <td>sctp_event_subscribe()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>initmsg</td> <td>sctp_initmsg()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>maxseg</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>nodelay</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>rtoinfo</td> <td>sctp_rtoinfo()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.8: sctp options</p> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
