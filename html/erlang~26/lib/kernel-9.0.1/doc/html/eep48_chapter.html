<div class="innertube"> <h1 id="EEP-48: Documentation storage and format">5 EEP-48: Documentation storage and format</h1> <p>This User's Guide describes the documentation storage format initially described in <code><a href="https://www.erlang.org/erlang-enhancement-proposals/eep-0048.html">EEP-48</a></code>. By standardizing how API documentation is stored, it will be possible to write tools that work across languages.</p> <p>To fetch the EEP-48 documentation for a module you can use <code><a href="code.html#get_doc-1">code:get_doc/1</a></code>.</p> <p>To render the EEP-48 documentation for an Erlang module you can use <code>shell_docs:render/2</code>.</p> <h2 id="the--docs--storage" class="title-link"> <div class="title-name">5.1 the "Docs" storage</div>  </h2> <p>To look for documentation for a module name example, a tool should:</p> <p>Look for <code>example.beam</code> in the code path, parse the BEAM file and retrieve the <code>Docs</code> chunk. If the chunk is not available, it should look for "example.beam" in the code path and find the <code>doc/chunks/example.chunk</code> file in the application that defines the <code>example</code> module. If a .chunk file is not available, then documentation is not available.</p> <p>The choice of using a chunk or the filesystem is completely up to the language or library. In both cases, the documentation can be added or removed at any moment by stripping the <code>Docs</code> chunk or by removing the doc/chunks directory.</p> <p>For example, languages like Elixir and LFE attach the <code>Docs</code> chunk at compilation time, which can be controlled via a compiler flag. On the other hand, projects like OTP itself will likely generate the doc/chunks entries on a separate command, completely unrelated from code compilation.</p> <h2 id="the--docs--format" class="title-link"> <div class="title-name">5.2 the "Docs" format</div>  </h2> <p>In both storages, the documentation is written in the exactly same format: an Erlang term serialized to binary via <code> term_to_binary/1</code>. The term may be optionally compressed when serialized. It must follow the type specification below:</p> <pre data-language="erlang">{docs_v1,
 Anno :: erl_anno:anno(),
 BeamLanguage :: atom(),
 Format :: binary(),
 ModuleDoc :: #{DocLanguage := DocValue} | none | hidden,
 Metadata :: map(),
 Docs ::
   [{{Kind, Name, Arity},
     Anno :: erl_anno:anno(),
     Signature :: [binary()],
     Doc :: #{DocLanguage := DocValue} | none | hidden,
     Metadata :: map()
    }]} when DocLanguage :: binary(),
             DocValue :: binary() | term()</pre> <p>where in the root tuple we have:</p> <dl> <dt class="title-link"><strong>Anno</strong></dt> <dd>annotation (line, column, file) of the definition itself (see <code>erl_anno(3)</code>)</dd> <dt class="title-link"><strong>BeamLanguage</strong></dt> <dd>an atom representing the language, for example: erlang, elixir, lfe, alpaca, etc</dd> <dt class="title-link"><strong>Format</strong></dt> <dd>the mime type of the documentation, such as &lt;&lt;"text/markdown"&gt;&gt; or &lt;&lt;"application/erlang+html"&gt;&gt;. For details of the format used by Erlang see the <code>EEP-48 Chapter</code> in Erl_Docgen's User's Guide.</dd> <dt class="title-link"><strong>ModuleDoc</strong></dt> <dd>a map with the documentation language as key, such as <code>&lt;&lt;"en"&gt;&gt;</code> or <code>&lt;&lt;"pt_BR"&gt;&gt;</code>, and the documentation as a binary value. It may be the atom <code>none</code> in case there is no documentation or the atom <code>hidden</code> if documentation has been explicitly disabled for this entry.</dd> <dt class="title-link"><strong>Metadata</strong></dt> <dd>a map of atom keys with any term as value. This can be used to add annotations like the <code>authors</code> of a module, <code>deprecated</code>, or anything else a language or documentation tool may find relevant.</dd> <dt class="title-link"><strong>Docs</strong></dt> <dd>a list of documentation for other entities (such as functions and types) in the module.</dd> </dl> <p>For each entry in Docs, we have:</p> <dl> <dt class="title-link"><strong>{Kind, Name, Arity}</strong></dt> <dd>the kind, name and arity identifying the function, callback, type, etc. The official entities are: <code>function</code>, <code>type</code> and <code>callback</code>. Other languages will add their own. For instance, Elixir and LFE may add macro.</dd> <dt class="title-link"><strong>Anno</strong></dt> <dd>annotation (line, column, file) of the module documentation or of the definition itself (see <code>erl_anno(3)</code>).</dd> <dt class="title-link"><strong>Signature</strong></dt> <dd>the signature of the entity. It is is a list of binaries. Each entry represents a binary in the signature that can be joined with a whitespace or a newline. For example, <code>[&lt;&lt;"binary_to_atom(Binary, Encoding)"&gt;&gt;, &lt;&lt;"when is_binary(Binary)"&gt;&gt;]</code> may be rendered as a single line or two lines. It exists exclusively for exhibition purposes.</dd> <dt class="title-link"><strong>Doc</strong></dt> <dd>a map with the documentation language as key, such as &lt;&lt;"en"&gt;&gt; or &lt;&lt;"pt_BR"&gt;&gt;, and the documentation as a value. The documentation may either be a binary or any Erlang term, both described by <code>Format</code>. If it is an Erlang term, then the Format must be &lt;&lt;"application/erlang+SUFFIX",&gt;&gt; such as &lt;&lt;"application/erlang+html"&gt;&gt; when the documentation is an Erlang representation of an HTML document. The Doc may also be atom <code>none</code> in case there is no documentation or the atom <code>hidden</code> if documentation has been explicitly disabled for this entry.</dd> <dt class="title-link"><strong>Metadata</strong></dt> <dd>a map of atom keys with any term as value.</dd> </dl> <p>This shared format is the heart of the EEP as it is what effectively allows cross-language collaboration.</p> <p>The Metadata field exists to allow languages, tools and libraries to add custom information to each entry. This EEP documents the following metadata keys:</p> <dl> <dt class="title-link"><strong>authors := [binary()]</strong></dt> <dd>a list of authors as binaries.</dd> <dt class="title-link"><strong>cross_references := [module() | {module(), {Kind, Name, Arity}}]</strong></dt> <dd>a list of modules or module entries that can be used as cross references when generating documentation.</dd> <dt class="title-link"><strong>deprecated := binary()</strong></dt> <dd>when present, it means the current entry is deprecated with a binary that represents the reason for deprecation and a recommendation to replace the deprecated code.</dd> <dt class="title-link"><strong>since := binary()</strong></dt> <dd>a binary representing the version such entry was added, such as &lt;&lt;"1.3.0"&gt;&gt; or &lt;&lt;"20.0"&gt;&gt;.</dd> <dt class="title-link"><strong>edit_url := binary()</strong></dt> <dd>a binary representing a URL to change the documentation itself.</dd> </dl> <p>Any key may be added to Metadata at any time. Keys that are frequently used by the community can be standardized in future versions.</p> <h2 id="see-also" class="title-link"> <div class="title-name">5.3 See Also</div>  </h2> <p> <code>erl_anno(3)</code>, <code>shell_docs(3)</code>, <code>EEP-48 Chapter in Erl_Docgen's User's Guide</code>, <code><a href="code.html#get_doc-1">code:get_doc/1</a></code> </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
