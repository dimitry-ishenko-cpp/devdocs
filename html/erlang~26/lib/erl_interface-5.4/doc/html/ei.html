  <div class="innertube"> <h2 id="c-library" class="title-link"> <div class="title-name">C Library</div>  </h2> <div class="REFBODY c-library-body">ei</div> </div> <div class="innertube"> <h2 id="library-summary" class="title-link"> <div class="title-name">Library Summary</div>  </h2> <div class="REFBODY library-summary-body">Routines for handling the Erlang binary term format.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>The library <code>ei</code> contains macros and functions to encode and decode the Erlang binary term format.</p> <p><code>ei</code> allows you to convert atoms, lists, numbers, and binaries to and from the binary format. This is useful when writing port programs and drivers. <code>ei</code> uses a given buffer, no dynamic memory (except <code>ei_decode_fun()</code>) and is often quite fast.</p> <p><code>ei</code> also handles C-nodes, C-programs that talks Erlang distribution with Erlang nodes (or other C-nodes) using the Erlang distribution format.The <code>ei</code> library is thread safe, and using threads, one process can handle multiple C-nodes.</p> <p>The decode and encode functions use a buffer and an index into the buffer, which points at the point where to encode and decode. The index is updated to point right after the term encoded/decoded. No checking is done whether the term fits in the buffer or not. If encoding goes outside the buffer, the program can crash.</p> <p>All functions take two parameters:</p> <ul> <li> <p><code>buf</code> is a pointer to the buffer where the binary data is or will be.</p> </li> <li> <p><code>index</code> is a pointer to an index into the buffer. This parameter is incremented with the size of the term decoded/encoded.</p> </li> </ul> <p>The data is thus at <code>buf[*index]</code> when an <code>ei</code> function is called.</p> <p>All encode functions assume that the <code>buf</code> and <code>index</code> parameters point to a buffer large enough for the data. To get the size of an encoded term, without encoding it, pass <code>NULL</code> instead of a buffer pointer. Parameter <code>index</code> is incremented, but nothing will be encoded. This is the way in <code>ei</code> to "preflight" term encoding.</p> <p>There are also encode functions that use a dynamic buffer. It is often more convenient to use these to encode data. All encode functions comes in two versions; those starting with <code>ei_x_</code> use a dynamic buffer of type <code><a href="#ei_x_buff">ei_x_buff</a></code>. </p> <p>All functions return <code>0</code> if successful, otherwise <code>-1</code> (for example, if a term is not of the expected type, or the data to decode is an invalid Erlang term).</p> <p>Some of the decode functions need a pre-allocated buffer. This buffer must be allocated large enough, and for non-compound types the <code><a href="#ei_get_type">ei_get_type()</a></code> function returns the size required (notice that for strings an extra byte is needed for the <code>NULL</code>-terminator).</p> </div> </div></section> <section class="innertube"><h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <div class="REFBODY rb-3"> <dl> <dt class="title-link"><strong><code id="ei_term">ei_term</code></strong></dt> <dd> <pre data-language="erlang">typedef struct {
    char ei_type;
    int arity;
    int size;
    union {
	long i_val;
	double d_val;
	char atom_name[MAXATOMLEN_UTF8];
	erlang_pid pid;
	erlang_port port;
	erlang_ref ref;
    } value;
} ei_term;</pre> <p>Structure written by <code><a href="#ei_decode_ei_term">ei_decode_ei_term()</a></code>. The <code>ei_type</code> field is the type of the term which equals to what <code><a href="#ei_get_type">ei_get_type()</a></code> sets <code>*type</code> to. </p> </dd> <dt class="title-link"><strong><code id="ei_x_buff">ei_x_buff</code></strong></dt> <dd> <p>A dynamically resized buffer. It is a <code>struct</code> with two fields of interest for the user: </p> <dl> <dt class="title-link"><strong><code>char *buff</code></strong></dt> <dd> <p>Pointer to the dynamically allocated buffer.</p> </dd> <dt class="title-link"><strong><code>int index</code></strong></dt> <dd> <p>Offset to the next byte to write which also equals the amount of bytes currently written.</p> </dd> </dl> <p> An <code>ei_x_buff</code> is initialized by calling either <code><a href="#ei_x_new">ei_x_new()</a></code> or <code><a href="#ei_x_new_with_version">ei_x_new_with_version()</a></code>. The memory used by an initialized <code>ei_x_buff</code> is released by calling <code><a href="#ei_x_free">ei_x_free()</a></code>. </p> </dd> <dt class="title-link"><strong><code id="erlang_char_encoding">erlang_char_encoding</code></strong></dt> <dd> <pre data-language="erlang">typedef enum {
    ERLANG_ASCII = 1,
    ERLANG_LATIN1 = 2,
    ERLANG_UTF8 = 4
} erlang_char_encoding;</pre> <p>The character encodings used for atoms. <code>ERLANG_ASCII</code> represents 7-bit ASCII. Latin-1 and UTF-8 are different extensions of 7-bit ASCII. All 7-bit ASCII characters are valid Latin-1 and UTF-8 characters. ASCII and Latin-1 both represent each character by one byte. An UTF-8 character can consist of 1-4 bytes. Notice that these constants are bit-flags and can be combined with bitwise OR.</p> </dd> <dt class="title-link"><strong><code id="erlang_fun">erlang_fun</code></strong></dt> <dd> <p>Opaque data type representing an Erlang fun.</p> </dd> <dt class="title-link"><strong><code id="erlang_pid">erlang_pid</code></strong></dt> <dd> <p>Opaque data type representing an Erlang process identifier.</p> </dd> <dt class="title-link"><strong><code id="erlang_port">erlang_port</code></strong></dt> <dd> <p>Opaque data type representing an Erlang port identifier.</p> </dd> <dt class="title-link"><strong><code id="erlang_ref">erlang_ref</code></strong></dt> <dd> <p>Opaque data type representing an Erlang reference.</p> </dd> <dt class="title-link"><strong><code id="erlang_trace">erlang_trace</code></strong></dt> <dd> <p>Opaque data type representing an Erlang sequential trace token.</p> </dd> </dl> </div></section> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_cmp_pids" class="title-link">  <div class="title-name">int ei_cmp_pids(<br>erlang_pid *a,<br>erlang_pid *b)</div> <div class="title-since"><span class="since">OTP 23.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#erlang_pid">erlang_pid</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p> Compare two process identifiers. The comparison is done the same way as Erlang does. </p> <p> Returns <code>0</code> if <code>a</code> and <code>b</code> are equal. Returns a value less than <code>0</code> if <code>a</code> compares as less than <code>b</code>. Returns a value larger than <code>0</code> if <code>a</code> compares as larger than <code>b</code>. </p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_cmp_ports" class="title-link">  <div class="title-name">int ei_cmp_ports(<br>erlang_port *a,<br>erlang_port *b)</div> <div class="title-since"><span class="since">OTP 23.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#erlang_port">erlang_port</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p> Compare two port identifiers. The comparison is done the same way as Erlang does. </p> <p> Returns <code>0</code> if <code>a</code> and <code>b</code> are equal. Returns a value less than <code>0</code> if <code>a</code> compares as less than <code>b</code>. Returns a value larger than <code>0</code> if <code>a</code> compares as larger than <code>b</code>. </p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_cmp_refs" class="title-link">  <div class="title-name">int ei_cmp_refs(<br>erlang_ref *a,<br>erlang_ref *b)</div> <div class="title-since"><span class="since">OTP 23.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#erlang_ref">erlang_ref</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p> Compare two references. The comparison is done the same way as Erlang does. </p> <p> Returns <code>0</code> if <code>a</code> and <code>b</code> are equal. Returns a value less than <code>0</code> if <code>a</code> compares as less than <code>b</code>. Returns a value larger than <code>0</code> if <code>a</code> compares as larger than <code>b</code>. </p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_atom" class="title-link">  <div class="title-name">int ei_decode_atom(<br>const char *buf,<br>int *index,<br>char *p)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes an atom from the binary format. The <code>NULL</code>-terminated name of the atom is placed at <code>p</code>. At most <code>MAXATOMLEN</code> bytes can be placed in the buffer.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_atom_as" class="title-link">  <div class="title-name">int ei_decode_atom_as(<br>const char *buf,<br>int *index,<br>char *p,<br>int plen,<br>erlang_char_encoding want,<br>erlang_char_encoding* was,<br>erlang_char_encoding* result)</div> <div class="title-since"><span class="since">OTP R16B</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#erlang_char_encoding">erlang_char_encoding</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Decodes an atom from the binary format. The <code>NULL</code>-terminated name of the atom is placed in buffer at <code>p</code> of length <code>plen</code> bytes.</p> <p>The wanted string encoding is specified by <code><a href="#erlang_char_encoding">want</a></code>. The original encoding used in the binary format (Latin-1 or UTF-8) can be obtained from <code>*was</code>. The encoding of the resulting string (7-bit ASCII, Latin-1, or UTF-8) can be obtained from <code>*result</code>. Both <code>was</code> and <code>result</code> can be <code>NULL</code>. <code>*result</code> can differ from <code>want</code> if <code>want</code> is a bitwise OR'd combination like <code>ERLANG_LATIN1|ERLANG_UTF8</code> or if <code>*result</code> turns out to be pure 7-bit ASCII (compatible with both Latin-1 and UTF-8).</p> <p>This function fails if the atom is too long for the buffer or if it cannot be represented with encoding <code>want</code>.</p> <p>This function was introduced in Erlang/OTP R16 as part of a first step to support UTF-8 atoms.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_bignum" class="title-link">  <div class="title-name">int ei_decode_bignum(<br>const char *buf,<br>int *index,<br>mpz_t obj)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes an integer in the binary format to a GMP <code>mpz_t</code> integer. To use this function, the <code>ei</code> library must be configured and compiled to use the GMP library.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_binary" class="title-link">  <div class="title-name">int ei_decode_binary(<br>const char *buf,<br>int *index,<br>void *p,<br>long *len)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a binary from the binary format. Parameter <code>len</code> is set to the actual size of the binary. Notice that <code>ei_decode_binary()</code> assumes that there is enough room for the binary. The size required can be fetched by <code><a href="#ei_get_type">ei_get_type()</a></code>.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_bitstring" class="title-link">  <div class="title-name">int ei_decode_bitstring(<br>const char *buf,<br>int *index,<br>const char **pp,<br>unsigned int *bitoffsp,<br>size_t *nbitsp)</div> <div class="title-since"><span class="since">OTP 22.0</span></div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a bit string from the binary format.</p> <dl> <dt class="title-link"><strong><code>pp</code></strong></dt> <dd> <p>Either <code>NULL</code> or <code>*pp</code> returns a pointer to the first byte of the bit string. The returned bit string is readable as long as the buffer pointed to by <code>buf</code> is readable and not written to.</p> </dd> <dt class="title-link"><strong><code>bitoffsp</code></strong></dt> <dd> <p>Either <code>NULL</code> or <code>*bitoffsp</code> returns the number of unused bits in the first byte pointed to by <code>*pp</code>. The value of <code>*bitoffsp</code> is between 0 and 7. Unused bits in the first byte are the most significant bits.</p> </dd> <dt class="title-link"><strong><code>nbitsp</code></strong></dt> <dd> <p>Either <code>NULL</code> or <code>*nbitsp</code> returns the length of the bit string in <strong>bits</strong>.</p> </dd> </dl> <p>Returns <code>0</code> if it was a bit string term.</p> <p>The number of <strong>bytes</strong> pointed to by <code>*pp</code>, which are part of the bit string, is <code>(*bitoffsp + *nbitsp + 7)/8</code>. If <code>(*bitoffsp + *bitsp)%8 &gt; 0</code> then only <code>(*bitoffsp + *bitsp)%8</code> bits of the last byte are used. Unused bits in the last byte are the least significant bits.</p> <p>The values of unused bits in the first and last byte are undefined and cannot be relied on.</p> <p>Number of bits may be divisible by 8, which means a binary decodable by <code>ei_decode_binary</code> is also decodable by <code>ei_decode_bitstring</code>.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_boolean" class="title-link">  <div class="title-name">int ei_decode_boolean(<br>const char *buf,<br>int *index,<br>int *p)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a boolean value from the binary format. A boolean is actually an atom, <code>true</code> decodes 1 and <code>false</code> decodes 0.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_char" class="title-link">  <div class="title-name">int ei_decode_char(<br>const char *buf,<br>int *index,<br>char *p)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a char (8-bit) integer between 0-255 from the binary format. For historical reasons the returned integer is of type <code>char</code>. Your C code is to consider the returned value to be of type <code>unsigned char</code> even if the C compilers and system can define <code>char</code> to be signed.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_double" class="title-link">  <div class="title-name">int ei_decode_double(<br>const char *buf,<br>int *index,<br>double *p)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a double-precision (64-bit) floating point number from the binary format.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_ei_term" class="title-link">  <div class="title-name">int ei_decode_ei_term(<br>const char* buf,<br>int* index,<br>ei_term* term)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_term">ei_term</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Decodes any term, or at least tries to. If the term pointed at by <code>*index</code> in <code>buf</code> fits in the <code>term</code> union, it is decoded, and the appropriate field in <code>term-&gt;value</code> is set, and <code>*index</code> is incremented by the term size.</p> <p>The function returns <code>1</code> on successful decoding, <code>-1</code> on error, and <code>0</code> if the term seems alright, but does not fit in the <code>term</code> structure. If <code>1</code> is returned, the <code>index</code> is incremented, and <code>term</code> contains the decoded term.</p> <p>The <code>term</code> structure contains the arity for a tuple or list, size for a binary, string, or atom. It contains a term if it is any of the following: integer, float, atom, pid, port, or ref.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_fun" class="title-link">  <div class="title-name">int ei_decode_fun(<br>const char *buf,<br>int *index,<br>erlang_fun *p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="free_fun" class="title-link">  <div class="title-name">void free_fun(<br>erlang_fun* f)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#erlang_fun">erlang_fun</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Decodes a fun from the binary format. Parameter <code>p</code> is to be <code>NULL</code> or point to an <code>erlang_fun</code> structure. This is the only decode function that allocates memory. When the <code>erlang_fun</code> is no longer needed, it is to be freed with <code>free_fun</code>. (This has to do with the arbitrary size of the environment for a fun.)</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_iodata" class="title-link">  <div class="title-name">int ei_decode_iodata(<br>const char *buf,<br>int *index,<br>int *size,<br>char *outbuf)</div> <div class="title-since"><span class="since">OTP 23.0</span></div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a term of the type <code>iodata()</code>. The <code>iodata()</code> term will be flattened an written into the buffer pointed to by the <code>outbuf</code> argument. The byte size of the <code>iodata</code> is written into the integer variable pointed to by the <code>size</code> argument. Both <code>size</code> and <code>outbuf</code> can be set to <code>NULL</code>. The integer pointed to by the <code>index</code> argument is updated to refer to the term following after the <code>iodata()</code> term regardless of the the state of the <code>size</code> and the <code>outbuf</code> arguments. </p> <p>Note that the buffer pointed to by the <code>outbuf</code> argument must be large enough if a non <code>NULL</code> value is passed as <code>outbuf</code>. You typically want to call <code>ei_decode_iodata()</code> twice. First with a non <code>NULL</code> <code>size</code> argument and a <code>NULL</code> <code>outbuf</code> argument in order to determine the size of the buffer needed, and then once again in order to do the actual decoding. Note that the integer pointed to by <code>index</code> will be updated by the call determining the size as well, so you need to reset it before the second call doing the actual decoding. </p> <p>Returns <code>0</code> on success and <code>-1</code> on failure. Failure might be either due to invalid encoding of the term or due to the term not being of the type <code>iodata()</code>. On failure, the integer pointed to by the <code>index</code> argument will be updated to refer to the sub term where the failure was detected.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_list_header" class="title-link">  <div class="title-name">int ei_decode_list_header(<br>const char *buf,<br>int *index,<br>int *arity)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a list header from the binary format. The number of elements is returned in <code>arity</code>. The <code>arity+1</code> elements follow (the last one is the tail of the list, normally an empty list). If <code>arity</code> is <code>0</code>, it is an empty list.</p> <p>Notice that lists are encoded as strings if they consist entirely of integers in the range 0..255. This function do not decode such strings, use <code>ei_decode_string()</code> instead.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_long" class="title-link">  <div class="title-name">int ei_decode_long(<br>const char *buf,<br>int *index,<br>long *p)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a long integer from the binary format. If the code is 64 bits, the function <code>ei_decode_long()</code> is the same as <code>ei_decode_longlong()</code>.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_longlong" class="title-link">  <div class="title-name">int ei_decode_longlong(<br>const char *buf,<br>int *index,<br>long long *p)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a GCC <code>long long</code> or Visual C++ <code>__int64</code> (64-bit) integer from the binary format.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_map_header" class="title-link">  <div class="title-name">int ei_decode_map_header(<br>const char *buf,<br>int *index,<br>int *arity)</div> <div class="title-since"><span class="since">OTP 17.0</span></div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a map header from the binary format. The number of key-value pairs is returned in <code>*arity</code>. Keys and values follow in this order: <code>K1, V1, K2, V2, ..., Kn, Vn</code>. This makes a total of <code>arity*2</code> terms. If <code>arity</code> is zero, it is an empty map. A correctly encoded map does not have duplicate keys.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_pid" class="title-link">  <div class="title-name">int ei_decode_pid(<br>const char *buf,<br>int *index,<br>erlang_pid *p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#erlang_pid">erlang_pid</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Decodes a process identifier (pid) from the binary format.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_port" class="title-link">  <div class="title-name">int ei_decode_port(<br>const char *buf,<br>int *index,<br>erlang_port *p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#erlang_port">erlang_port</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Decodes a port identifier from the binary format.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_ref" class="title-link">  <div class="title-name">int ei_decode_ref(<br>const char *buf,<br>int *index,<br>erlang_ref *p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#erlang_ref">erlang_ref</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Decodes a reference from the binary format.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_string" class="title-link">  <div class="title-name">int ei_decode_string(<br>const char *buf,<br>int *index,<br>char *p)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a string from the binary format. A string in Erlang is a list of integers between 0 and 255. Notice that as the string is just a list, sometimes lists are encoded as strings by <code>term_to_binary/1</code>, even if it was not intended.</p> <p>The string is copied to <code>p</code>, and enough space must be allocated. The returned string is <code>NULL</code>-terminated, so you must add an extra byte to the memory requirement.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_trace" class="title-link">  <div class="title-name">int ei_decode_trace(<br>const char *buf,<br>int *index,<br>erlang_trace *p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#erlang_trace">erlang_trace</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Decodes an Erlang trace token from the binary format.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_tuple_header" class="title-link">  <div class="title-name">int ei_decode_tuple_header(<br>const char *buf,<br>int *index,<br>int *arity)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a tuple header, the number of elements is returned in <code>arity</code>. The tuple elements follow in order in the buffer.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_ulong" class="title-link">  <div class="title-name">int ei_decode_ulong(<br>const char *buf,<br>int *index,<br>unsigned long *p)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes an unsigned long integer from the binary format. If the code is 64 bits, the function <code>ei_decode_ulong()</code> is the same as <code>ei_decode_ulonglong()</code>.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_ulonglong" class="title-link">  <div class="title-name">int ei_decode_ulonglong(<br>const char *buf,<br>int *index,<br>unsigned long long *p)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes a GCC <code>unsigned long long</code> or Visual C++ <code>unsigned __int64</code> (64-bit) integer from the binary format.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_decode_version" class="title-link">  <div class="title-name">int ei_decode_version(<br>const char *buf,<br>int *index,<br>int *version)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decodes the version magic number for the Erlang binary term format. It must be the first token in a binary term.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_atom" class="title-link">  <div class="title-name">int ei_encode_atom(<br>char *buf,<br>int *index,<br>const char *p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_encode_atom_len" class="title-link">  <div class="title-name">int ei_encode_atom_len(<br>char *buf,<br>int *index,<br>const char *p,<br>int len)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_atom" class="title-link">  <div class="title-name">int ei_x_encode_atom(<br>ei_x_buff* x,<br>const char *p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_atom_len" class="title-link">  <div class="title-name">int ei_x_encode_atom_len(<br>ei_x_buff* x,<br>const char *p,<br>int len)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes an atom in the binary format. Parameter <code>p</code> is the name of the atom in Latin-1 encoding. Only up to <code>MAXATOMLEN-1</code> bytes are encoded. The name is to be <code>NULL</code>-terminated, except for the <code>ei_x_encode_atom_len()</code> function.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_atom_as" class="title-link">  <div class="title-name">int ei_encode_atom_as(<br>char *buf,<br>int *index,<br>const char *p,<br>erlang_char_encoding from_enc,<br>erlang_char_encoding to_enc)</div> <div class="title-since"><span class="since">OTP R16B</span></div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_encode_atom_len_as" class="title-link">  <div class="title-name">int ei_encode_atom_len_as(<br>char *buf,<br>int *index,<br>const char *p,<br>int len,<br>erlang_char_encoding from_enc,<br>erlang_char_encoding to_enc)</div> <div class="title-since"><span class="since">OTP R16B</span></div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_atom_as" class="title-link">  <div class="title-name">int ei_x_encode_atom_as(<br>ei_x_buff* x,<br>const char *p,<br>erlang_char_encoding from_enc,<br>erlang_char_encoding to_enc)</div> <div class="title-since"><span class="since">OTP R16B</span></div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_atom_len_as" class="title-link">  <div class="title-name">int ei_x_encode_atom_len_as(<br>ei_x_buff* x,<br>const char *p,<br>int len,<br>erlang_char_encoding from_enc,<br>erlang_char_encoding to_enc)</div> <div class="title-since"><span class="since">OTP R16B</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> <div class="REFTYPES rt-4"> <code><a href="#erlang_char_encoding">erlang_char_encoding</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes an atom in the binary format. Parameter <code>p</code> is the name of the atom with character encoding <code><a href="#erlang_char_encoding">from_enc</a></code> (ASCII, Latin-1, or UTF-8). The name must either be <code>NULL</code>-terminated or a function variant with a <code>len</code> parameter must be used.</p> <p>The encoding fails if <code>p</code> is not a valid string in encoding <code>from_enc</code>.</p> <p>Argument <code>to_enc</code> is ignored. As from Erlang/OTP 20 the encoding is always done in UTF-8 which is readable by nodes as old as Erlang/OTP R16.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_bignum" class="title-link">  <div class="title-name">int ei_encode_bignum(<br>char *buf,<br>int *index,<br>mpz_t obj)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_bignum" class="title-link">  <div class="title-name">int ei_x_encode_bignum(<br>ei_x_buff *x,<br>mpz_t obj)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a GMP <code>mpz_t</code> integer to binary format. To use this function, the <code>ei</code> library must be configured and compiled to use the GMP library.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_binary" class="title-link">  <div class="title-name">int ei_encode_binary(<br>char *buf,<br>int *index,<br>const void *p,<br>long len)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_binary" class="title-link">  <div class="title-name">int ei_x_encode_binary(<br>ei_x_buff* x,<br>const void *p,<br>long len)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a binary in the binary format. The data is at <code>p</code>, of <code>len</code> bytes length.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_bitstring" class="title-link">  <div class="title-name">int ei_encode_bitstring(<br>char *buf,<br>int *index,<br>const char *p,<br>size_t bitoffs,<br>size_t nbits)</div> <div class="title-since"><span class="since">OTP 22.0</span></div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_bitstring" class="title-link">  <div class="title-name">int ei_x_encode_bitstring(<br>ei_x_buff* x,<br>const char *p,<br>size_t bitoffs,<br>size_t nbits)</div> <div class="title-since"><span class="since">OTP 22.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a bit string in the binary format.</p> <p>The data is at <code>p</code>. The length of the bit string is <code>nbits</code> bits. The first <code>bitoffs</code> bits of the data at <code>p</code> are unused. The first byte which is part of the bit string is <code>p[bitoffs/8]</code>. The <code>bitoffs%8</code> most significant bits of the first byte <code>p[bitoffs/8]</code> are unused.</p> <p>The number of bytes which is part of the bit string is <code>(bitoffs + nbits + 7)/8</code>. If <code>(bitoffs + nbits)%8 &gt; 0</code> then only <code>(bitoffs + nbits)%8</code> bits of the last byte are used. Unused bits in the last byte are the least significant bits.</p> <p>The values of unused bits are disregarded and does not need to be cleared.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_boolean" class="title-link">  <div class="title-name">int ei_encode_boolean(<br>char *buf,<br>int *index,<br>int p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_boolean" class="title-link">  <div class="title-name">int ei_x_encode_boolean(<br>ei_x_buff* x,<br>int p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a boolean value as the atom <code>true</code> if <code>p</code> is not zero, or <code>false</code> if <code>p</code> is zero.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_char" class="title-link">  <div class="title-name">int ei_encode_char(<br>char *buf,<br>int *index,<br>char p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_char" class="title-link">  <div class="title-name">int ei_x_encode_char(<br>ei_x_buff* x,<br>char p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a char (8-bit) as an integer between 0-255 in the binary format. For historical reasons the integer argument is of type <code>char</code>. Your C code is to consider the specified argument to be of type <code>unsigned char</code> even if the C compilers and system may define <code>char</code> to be signed.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_double" class="title-link">  <div class="title-name">int ei_encode_double(<br>char *buf,<br>int *index,<br>double p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_double" class="title-link">  <div class="title-name">int ei_x_encode_double(<br>ei_x_buff* x,<br>double p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a double-precision (64-bit) floating point number in the binary format.</p> <p>Returns <code>-1</code> if the floating point number is not finite.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_empty_list" class="title-link">  <div class="title-name">int ei_encode_empty_list(<br>char* buf,<br>int* index)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_empty_list" class="title-link">  <div class="title-name">int ei_x_encode_empty_list(<br>ei_x_buff* x)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes an empty list. It is often used at the tail of a list.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_fun" class="title-link">  <div class="title-name">int ei_encode_fun(<br>char *buf,<br>int *index,<br>const erlang_fun *p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_fun" class="title-link">  <div class="title-name">int ei_x_encode_fun(<br>ei_x_buff* x,<br>const erlang_fun* fun)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> <div class="REFTYPES rt-4"> <code><a href="#erlang_fun">erlang_fun</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a fun in the binary format. Parameter <code>p</code> points to an <code>erlang_fun</code> structure. The <code>erlang_fun</code> is not freed automatically, the <code>free_fun</code> is to be called if the fun is not needed after encoding.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_list_header" class="title-link">  <div class="title-name">int ei_encode_list_header(<br>char *buf,<br>int *index,<br>int arity)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_list_header" class="title-link">  <div class="title-name">int ei_x_encode_list_header(<br>ei_x_buff* x,<br>int arity)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a list header, with a specified arity. The next <code>arity+1</code> terms are the elements (actually its <code>arity</code> cons cells) and the tail of the list. Lists and tuples are encoded recursively, so that a list can contain another list or tuple.</p> <p>For example, to encode the list <code>[c, d, [e | f]]</code>:</p> <pre data-language="erlang">
ei_encode_list_header(buf, &amp;i, 3);
ei_encode_atom(buf, &amp;i, "c");
ei_encode_atom(buf, &amp;i, "d");
ei_encode_list_header(buf, &amp;i, 1);
ei_encode_atom(buf, &amp;i, "e");
ei_encode_atom(buf, &amp;i, "f");
ei_encode_empty_list(buf, &amp;i);</pre> <div class="note"> <div class="label">Note</div> <div class="content">

<p>It may seem that there is no way to create a list without knowing the number of elements in advance. But indeed there is a way. Notice that the list <code>[a, b, c]</code> can be written as <code>[a | [b | [c]]]</code>. Using this, a list can be written as conses.</p> </div> </div> <p>To encode a list, without knowing the arity in advance:</p> <pre data-language="erlang">
while (something()) {
    ei_x_encode_list_header(&amp;x, 1);
    ei_x_encode_ulong(&amp;x, i); /* just an example */
}
ei_x_encode_empty_list(&amp;x);</pre> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_long" class="title-link">  <div class="title-name">int ei_encode_long(<br>char *buf,<br>int *index,<br>long p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_long" class="title-link">  <div class="title-name">int ei_x_encode_long(<br>ei_x_buff* x,<br>long p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a long integer in the binary format. If the code is 64 bits, the function <code>ei_encode_long()</code> is the same as <code>ei_encode_longlong()</code>.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_longlong" class="title-link">  <div class="title-name">int ei_encode_longlong(<br>char *buf,<br>int *index,<br>long long p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_longlong" class="title-link">  <div class="title-name">int ei_x_encode_longlong(<br>ei_x_buff* x,<br>long long p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a GCC <code>long long</code> or Visual C++ <code>__int64</code> (64-bit) integer in the binary format.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_map_header" class="title-link">  <div class="title-name">int ei_encode_map_header(<br>char *buf,<br>int *index,<br>int arity)</div> <div class="title-since"><span class="since">OTP 17.0</span></div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_map_header" class="title-link">  <div class="title-name">int ei_x_encode_map_header(<br>ei_x_buff* x,<br>int arity)</div> <div class="title-since"><span class="since">OTP 17.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a map header, with a specified arity. The next <code>arity*2</code> terms encoded will be the keys and values of the map encoded in the following order: <code>K1, V1, K2, V2, ..., Kn, Vn</code>. </p> <p>For example, to encode the map <code>#{a =&gt; "Apple", b =&gt; "Banana"}</code>:</p> <pre data-language="erlang">
ei_x_encode_map_header(&amp;x, 2);
ei_x_encode_atom(&amp;x, "a");
ei_x_encode_string(&amp;x, "Apple");
ei_x_encode_atom(&amp;x, "b");
ei_x_encode_string(&amp;x, "Banana");</pre> <p>A correctly encoded map cannot have duplicate keys.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_pid" class="title-link">  <div class="title-name">int ei_encode_pid(<br>char *buf,<br>int *index,<br>const erlang_pid *p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_pid" class="title-link">  <div class="title-name">int ei_x_encode_pid(<br>ei_x_buff* x,<br>const erlang_pid *p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> <div class="REFTYPES rt-4"> <code><a href="#erlang_pid">erlang_pid</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes an Erlang process identifier (pid) in the binary format. Parameter <code>p</code> points to an <code>erlang_pid</code> structure which should either have been obtained earlier with <code><a href="#ei_decode_pid">ei_decode_pid()</a></code>, <code><a href="ei_connect.html#ei_self">ei_self()</a></code> or created by <code><a href="ei_connect.html#ei_make_pid">ei_make_pid()</a></code>. </p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_port" class="title-link">  <div class="title-name">int ei_encode_port(<br>char *buf,<br>int *index,<br>const erlang_port *p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_port" class="title-link">  <div class="title-name">int ei_x_encode_port(<br>ei_x_buff* x,<br>const erlang_port *p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> <div class="REFTYPES rt-4"> <code><a href="#erlang_port">erlang_port</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes an Erlang port in the binary format. Parameter <code>p</code> points to an <code>erlang_port</code> structure which should have been obtained earlier with <code><a href="#ei_decode_port">ei_decode_port()</a></code>, </p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_ref" class="title-link">  <div class="title-name">int ei_encode_ref(<br>char *buf,<br>int *index,<br>const erlang_ref *p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_ref" class="title-link">  <div class="title-name">int ei_x_encode_ref(<br>ei_x_buff* x,<br>const erlang_ref *p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> <div class="REFTYPES rt-4"> <code><a href="#erlang_ref">erlang_ref</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes an Erlang reference in the binary format. Parameter <code>p</code> points to an <code>erlang_ref</code> structure which either should have been obtained earlier with <code><a href="#ei_decode_ref">ei_decode_ref()</a></code>, or created by <code><a href="ei_connect.html#ei_make_ref">ei_make_ref()</a></code>.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_string" class="title-link">  <div class="title-name">int ei_encode_string(<br>char *buf,<br>int *index,<br>const char *p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_encode_string_len" class="title-link">  <div class="title-name">int ei_encode_string_len(<br>char *buf,<br>int *index,<br>const char *p,<br>int len)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_string" class="title-link">  <div class="title-name">int ei_x_encode_string(<br>ei_x_buff* x,<br>const char *p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_string_len" class="title-link">  <div class="title-name">int ei_x_encode_string_len(<br>ei_x_buff* x,<br>const char* s,<br>int len)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a string in the binary format. (A string in Erlang is a list, but is encoded as a character array in the binary format.) The string is to be <code>NULL</code>-terminated, except for the <code>ei_x_encode_string_len()</code> function.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_trace" class="title-link">  <div class="title-name">int ei_encode_trace(<br>char *buf,<br>int *index,<br>const erlang_trace *p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_trace" class="title-link">  <div class="title-name">int ei_x_encode_trace(<br>ei_x_buff* x,<br>const erlang_trace *p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> <div class="REFTYPES rt-4"> <code><a href="#erlang_trace">erlang_trace</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes an Erlang trace token in the binary format. Parameter <code>p</code> points to a <code>erlang_trace</code> structure which should have been obtained earlier with <code><a href="#ei_decode_trace">ei_decode_trace()</a></code>.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_tuple_header" class="title-link">  <div class="title-name">int ei_encode_tuple_header(<br>char *buf,<br>int *index,<br>int arity)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_tuple_header" class="title-link">  <div class="title-name">int ei_x_encode_tuple_header(<br>ei_x_buff* x,<br>int arity)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a tuple header, with a specified arity. The next <code>arity</code> terms encoded will be the elements of the tuple. Tuples and lists are encoded recursively, so that a tuple can contain another tuple or list.</p> <p>For example, to encode the tuple <code>{a, {b, {}}}</code>:</p> <pre data-language="erlang">
ei_encode_tuple_header(buf, &amp;i, 2);
ei_encode_atom(buf, &amp;i, "a");
ei_encode_tuple_header(buf, &amp;i, 2);
ei_encode_atom(buf, &amp;i, "b");
ei_encode_tuple_header(buf, &amp;i, 0);</pre> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_ulong" class="title-link">  <div class="title-name">int ei_encode_ulong(<br>char *buf,<br>int *index,<br>unsigned long p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_ulong" class="title-link">  <div class="title-name">int ei_x_encode_ulong(<br>ei_x_buff* x,<br>unsigned long p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes an unsigned long integer in the binary format. If the code is 64 bits, the function <code>ei_encode_ulong()</code> is the same as <code>ei_encode_ulonglong()</code>.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_ulonglong" class="title-link">  <div class="title-name">int ei_encode_ulonglong(<br>char *buf,<br>int *index,<br>unsigned long long p)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_ulonglong" class="title-link">  <div class="title-name">int ei_x_encode_ulonglong(<br>ei_x_buff* x,<br>unsigned long long p)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a GCC <code>unsigned long long</code> or Visual C++ <code>unsigned __int64</code> (64-bit) integer in the binary format.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_encode_version" class="title-link">  <div class="title-name">int ei_encode_version(<br>char *buf,<br>int *index)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_encode_version" class="title-link">  <div class="title-name">int ei_x_encode_version(<br>ei_x_buff* x)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Encodes a version magic number for the binary format. Must be the first token in a binary term.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_get_type" class="title-link">  <div class="title-name">int ei_get_type(<br>const char *buf,<br>const int *index,<br>int *type,<br>int *size)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the type in <code>*type</code> and size in <code>*size</code> of the encoded term. For strings and atoms, size is the number of characters <strong>not</strong> including the terminating <code>NULL</code>. For binaries and bitstrings, <code>*size</code> is the number of bytes. For lists, tuples and maps, <code>*size</code> is the arity of the object. For bignum integers, <code>*size</code> is the number of bytes for the absolute value of the bignum. For other types, <code>*size</code> is 0. In all cases, <code>index</code> is left unchanged.</p> <p>Currently <code>*type</code> is one of:</p> <dl> <dt class="title-link"><strong>ERL_ATOM_EXT</strong></dt> <dd><p> Decode using either <code><a href="#ei_decode_atom">ei_decode_atom()</a></code>, <code><a href="#ei_decode_atom_as">ei_decode_atom_as()</a></code>, or <code><a href="#ei_decode_boolean">ei_decode_boolean()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_BINARY_EXT</strong></dt> <dd><p> Decode using either <code><a href="#ei_decode_binary">ei_decode_binary()</a></code>, <code><a href="#ei_decode_bitstring">ei_decode_bitstring()</a></code>, or <code><a href="#ei_decode_iodata">ei_decode_iodata()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_BIT_BINARY_EXT</strong></dt> <dd><p> Decode using <code><a href="#ei_decode_bitstring">ei_decode_bitstring()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_FLOAT_EXT</strong></dt> <dd><p> Decode using <code><a href="#ei_decode_double">ei_decode_double()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_NEW_FUN_EXT<br>ERL_FUN_EXT<br>ERL_EXPORT_EXT</strong></dt> <dd><p> Decode using <code><a href="#ei_decode_fun">ei_decode_fun()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_SMALL_INTEGER_EXT<br>ERL_INTEGER_EXT<br>ERL_SMALL_BIG_EXT<br>ERL_LARGE_BIG_EXT</strong></dt> <dd><p> Decode using either <code><a href="#ei_decode_char">ei_decode_char()</a></code>, <code><a href="#ei_decode_long">ei_decode_long()</a></code>, <code><a href="#ei_decode_longlong">ei_decode_longlong()</a></code>, <code><a href="#ei_decode_ulong">ei_decode_ulong()</a></code>, <code><a href="#ei_decode_ulonglong">ei_decode_ulonglong()</a></code>, or <code><a href="#ei_decode_bignum">ei_decode_bignum()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_LIST_EXT<br>ERL_NIL_EXT</strong></dt> <dd><p> Decode using either <code><a href="#ei_decode_list_header">ei_decode_list_header()</a></code>, or <code><a href="#ei_decode_iodata">ei_decode_iodata()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_STRING_EXT</strong></dt> <dd><p> Decode using either <code><a href="#ei_decode_string">ei_decode_string()</a></code>, or <code><a href="#ei_decode_iodata">ei_decode_iodata()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_MAP_EXT</strong></dt> <dd><p> Decode using <code><a href="#ei_decode_map_header">ei_decode_map_header()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_PID_EXT</strong></dt> <dd><p> Decode using <code><a href="#ei_decode_pid">ei_decode_pid()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_PORT_EXT</strong></dt> <dd><p> Decode using <code><a href="#ei_decode_port">ei_decode_port()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_NEW_REFERENCE_EXT</strong></dt> <dd><p> Decode using <code><a href="#ei_decode_ref">ei_decode_ref()</a></code>. </p></dd> <dt class="title-link"><strong>ERL_SMALL_TUPLE_EXT<br>ERL_LARGE_TUPLE_EXT</strong></dt> <dd><p> Decode using <code><a href="#ei_decode_tuple_header">ei_decode_tuple_header()</a></code>. </p></dd> </dl> <p>Instead of decoding a term you can also skipped past it if you are not interested in the data by usage of <code><a href="#ei_skip_term">ei_skip_term()</a></code>.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_init" class="title-link">  <div class="title-name">int ei_init(void)</div> <div class="title-since"><span class="since">OTP 21.3</span></div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Initialize the <code>ei</code> library. This function should be called once (and only once) before calling any other functionality in the <code>ei</code> library.</p> <p>On success zero is returned. On failure a posix error code is returned.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_print_term" class="title-link">  <div class="title-name">int ei_print_term(<br>FILE* fp,<br>const char* buf,<br>int* index)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_s_print_term" class="title-link">  <div class="title-name">int ei_s_print_term(<br>char** s,<br>const char* buf,<br>int* index)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Prints a term, in clear text, to the file specified by <code>fp</code>, or the buffer pointed to by <code>s</code>. It tries to resemble the term printing in the Erlang shell.</p> <p>In <code>ei_s_print_term()</code>, parameter <code>s</code> is to point to a dynamically (malloc) allocated string of <code>BUFSIZ</code> bytes or a <code>NULL</code> pointer. The string can be reallocated (and <code>*s</code> can be updated) by this function if the result is more than <code>BUFSIZ</code> characters. The string returned is <code>NULL</code>-terminated.</p> <p>The return value is the number of characters written to the file or string, or <code>-1</code> if <code>buf[index]</code> does not contain a valid term. Unfortunately, I/O errors on <code>fp</code> is not checked.</p> <p>Argument <code>index</code> is updated, that is, this function can be viewed as a decode function that decodes a term into a human-readable format.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_set_compat_rel" class="title-link">  <div class="title-name">void ei_set_compat_rel(<br>unsigned release_number)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="ei_set_compat_rel">In general, the <code>ei</code> library is guaranteed to be compatible with other Erlang/OTP components that are 2 major releases older or newer than the <code>ei</code> library itself.</p> <p>Sometimes an exception to the above rule has to be made to make new features (or even bug fixes) possible. A call to <code>ei_set_compat_rel(release_number)</code> sets the <code>ei</code> library in compatibility mode of OTP release <code>release_number</code>.</p> <p>The only useful value for <code>release_number</code> is currently <code>21</code>. This will only be useful and have an effect if <strong>bit strings</strong> or <strong>export funs</strong> are received from a connected node. Before OTP 22, bit strings and export funs were not supported by <code>ei</code>. They were instead encoded using an undocumented fallback tuple format when sent from the emulator to <code>ei</code>:</p> <dl> <dt class="title-link"><strong><code>Bit string</code></strong></dt> <dd> <p>The term <code>&lt;&lt;42, 1:1&gt;&gt;</code> was encoded as <code>{&lt;&lt;42, 128&gt;&gt;, 1}</code>. The first element of the tuple is a binary and the second element denotes how many bits of the last bytes are part of the bit string. In this example only the most significant bit of the last byte (128) is part of the bit string.</p> </dd> <dt class="title-link"><strong><code>Export fun</code></strong></dt> <dd> <p>The term <code>fun lists:map/2</code> was encoded as <code>{lists,map}</code>. A tuple with the module, function and a missing arity.</p> </dd> </dl> <p>If <code>ei_set_compat_rel(21)</code> is <strong>not</strong> called then a connected emulator will send bit strings and export funs correctly encoded. The functions <code><a href="#ei_decode_bitstring">ei_decode_bitstring</a></code> and <code><a href="#ei_decode_fun">ei_decode_fun</a></code> has to be used to decode such terms. Calling <code>ei_set_compat_rel(21)</code> should only be done as a workaround to keep an old implementation alive, which expects to receive the undocumented tuple formats for bit strings and/or export funs. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If this function is called, it can only be called once and must be called before any other functions in the <code>ei</code> library are called.</p> </div> </div> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_skip_term" class="title-link">  <div class="title-name">int ei_skip_term(<br>const char* buf,<br>int* index)</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Skips a term in the specified buffer; recursively skips elements of lists and tuples, so that a full term is skipped. This is a way to get the size of an Erlang term.</p> <p><code>buf</code> is the buffer.</p> <p><code>index</code> is updated to point right after the term in the buffer.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This can be useful when you want to hold arbitrary terms: skip them and copy the binary term data to some buffer.</p> </div> </div> <p>Returns <code>0</code> on success, otherwise <code>-1</code>.</p> </div></div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_x_append" class="title-link">  <div class="title-name">int ei_x_append(<br>ei_x_buff* x,<br>const ei_x_buff* x2)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_append_buf" class="title-link">  <div class="title-name">int ei_x_append_buf(<br>ei_x_buff* x,<br>const char* buf,<br>int len)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Appends data at the end of buffer <code>x</code>.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_x_format" class="title-link">  <div class="title-name">int ei_x_format(<br>ei_x_buff* x,<br>const char* fmt,<br>...)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_format_wo_ver" class="title-link">  <div class="title-name">int ei_x_format_wo_ver(<br>ei_x_buff* x,<br>const char *fmt,<br>... )</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> <div class="REFTYPES rt-4"> <code><a href="#erlang_pid">erlang_pid</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Formats a term, given as a string, to a buffer. Works like a sprintf for Erlang terms. <code>fmt</code> contains a format string, with arguments like <code>~d</code>, to insert terms from variables. The following formats are supported (with the C types given):</p> <pre data-language="erlang">
~a  An atom, char*
~c  A character, char
~s  A string, char*
~i  An integer, int
~l  A long integer, long int
~u  A unsigned long integer, unsigned long int
~f  A float, float
~d  A double float, double float
~p  An Erlang pid, erlang_pid*</pre> <p>For example, to encode a tuple with some stuff:</p> <pre data-language="erlang">
ei_x_format("{~a,~i,~d}", "numbers", 12, 3.14159)
encodes the tuple {numbers,12,3.14159}</pre> <p><code>ei_x_format_wo_ver()</code> formats into a buffer, without the initial version byte.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_x_free" class="title-link">  <div class="title-name">int ei_x_free(<br>ei_x_buff* x)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Deallocates the dynamically allocated content of the buffer referred by <code>x</code>. After deallocation, the <code>buff</code> field is set to <code>NULL</code>.</p> </div> </div></article><article class="func"><div class="cref-head bold_code bc-7"><h3 id="ei_x_new" class="title-link">  <div class="title-name">int ei_x_new(<br>ei_x_buff* x)</div> </h3></div> <div class="cref-head bold_code bc-7"><h3 id="ei_x_new_with_version" class="title-link">  <div class="title-name">int ei_x_new_with_version(<br>ei_x_buff* x)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code><a href="#ei_x_buff">ei_x_buff</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p>Initialize the dynamically realizable buffer referred to by <code>x</code>. The fields of the structure pointed to by parameter <code>x</code> is filled in, and a default buffer is allocated. <code>ei_x_new_with_version()</code> also puts an initial version byte, which is used in the binary format (so that <code>ei_x_encode_version()</code> will not be needed.)</p> </div> </div></article> </div> <section class="innertube"><h2 id="debug-information" class="title-link"> <div class="title-name">Debug Information</div>  </h2> <div class="REFBODY rb-3"> <p>Some tips on what to check when the emulator does not seem to receive the terms that you send:</p> <ul> <li>Be careful with the version header, use <code>ei_x_new_with_version()</code> when appropriate.</li> <li>Turn on distribution tracing on the Erlang node.</li> <li>Check the result codes from <code>ei_decode_-calls</code>.</li> </ul> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
