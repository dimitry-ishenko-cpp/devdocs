<div class="innertube"> <h1 id="EUnit - a Lightweight Unit Testing Framework for Erlang
">1 EUnit - a Lightweight Unit Testing Framework for Erlang </h1> <p>EUnit is a unit testing framework for Erlang. It is very powerful and flexible, is easy to use, and has small syntactical overhead.</p> <ul> <li><p><code><a href="#Unit_testing">Unit testing</a></code></p></li> <li><p><code><a href="#Terminology">Terminology</a></code></p></li> <li><p><code><a href="#Getting_started">Getting started</a></code></p></li> <li><p><code><a href="#EUnit_macros">EUnit macros</a></code></p></li> <li><p><code><a href="#EUnit_test_representation">EUnit test representation</a></code></p></li> </ul> <p>EUnit builds on ideas from the family of unit testing frameworks for Object Oriented languages that originated with JUnit by Beck and Gamma (and Beck's previous framework SUnit for Smalltalk). However, EUnit uses techniques more adapted to functional and concurrent programming, and is typically less verbose than its relatives.</p> <p>Although EUnit uses many preprocessor macros, they have been designed to be as nonintrusive as possible, and should not cause conflicts with existing code. Adding EUnit tests to a module should thus not normally require changing existing code. Furthermore, tests that only exercise the exported functions of a module can always be placed in a completely separate module, avoiding any conflicts entirely.</p> <h2 id="unit-testing" class="title-link"> <div class="title-name">1.1 Unit testing</div>  </h2> <p>Unit Testing is testing of individual program "units" in relative isolation. There is no particular size requirement: a unit can be a function, a module, a process, or even a whole application, but the most typical testing units are individual functions or modules. In order to test a unit, you specify a set of individual tests, set up the smallest necessary environment for being able to run those tests (often, you don't need to do any setup at all), you run the tests and collect the results, and finally you do any necessary cleanup so that the test can be run again later. A Unit Testing Framework tries to help you in each stage of this process, so that it is easy to write tests, easy to run them, and easy to see which tests failed (so you can fix the bugs).</p> <h3 id="advantages-of-unit-testing" class="title-link"> <div class="title-name">Advantages of unit testing</div>  </h3> <dl> <dt class="title-link"><strong>Reduces the risks of changing the program</strong></dt> <dd><p>Most programs will be modified during their lifetime: bugs will be fixed, features will be added, optimizations may become necessary, or the code will need to be refactored or cleaned up in other ways to make it easier to work with. But every change to a working program is a risk of introducing new bugs - or reintroducing bugs that had previously been fixed. Having a set of unit tests that you can run with very little effort makes it easy to know that the code still works as it should (this use is called <strong>regression testing</strong>; see <code><a href="#Terminology">Terminology</a></code>). This goes a long way to reduce the resistance to changing and refactoring code.</p></dd> <dt class="title-link"><strong>Helps guide and speed up the development process</strong></dt> <dd><p>By focusing on getting the code to pass the tests, the programmer can become more productive, not overspecify or get lost in premature optimizations, and create code that is correct from the very beginning (so-called <strong>test-driven development</strong>; see <code><a href="#Terminology">Terminology</a></code>).</p></dd> <dt class="title-link"><strong>Helps separate interface from implementation</strong></dt> <dd><p>When writing tests, the programmer may discover dependencies (in order to get the tests to run) that ought not to be there, and which need to be abstracted away to get a cleaner design. This helps eliminate bad dependencies before they spread throughout the code.</p></dd> <dt class="title-link"><strong>Makes component integration easier</strong></dt> <dd><p>By testing in a bottom-up fashion, beginning with the smallest program units and creating a confidence in that they work as they should, it becomes easier to test that a higher-level component, consisting of several such units, also behaves according to specification (known as <strong>integration testing</strong>; see <code><a href="#Terminology">Terminology</a></code>).</p></dd> <dt class="title-link"><strong>Is self-documenting</strong></dt> <dd><p>The tests can be read as documentation, typically showing both examples of correct and incorrect usage, along with the expected consequences.</p></dd> </dl> <h2 id="terminology" class="title-link"> <div class="title-name">1.2 Terminology</div>  </h2> <dl> <dt class="title-link"><strong>Unit testing</strong></dt> <dd><p>Testing that a program unit behaves as it is supposed to do (in itself), according to its specifications. Unit tests have an important function as regression tests, when the program later is modified for some reason, since they check that the program still behaves according to specification.</p></dd> <dt class="title-link"><strong>Regression testing</strong></dt> <dd><p>Running a set of tests after making changes to a program, to check that the program behaves as it did before the changes (except, of course, for any intentional changes in behaviour). Unit tests are important as regression tests, but regression testing can involve more than just unit testing, and may also test behaviour that might not be part of the normal specification (such as bug-for-bug-compatibility). </p></dd> <dt class="title-link"><strong>Integration testing</strong></dt> <dd><p>Testing that a number of individually developed program units (assumed to already have been separately unit tested) work together as expected. Depending on the system being developed, integration testing may be as simple as "just another level of unit testing", but might also involve other kinds of tests (compare <strong>system testing</strong>). </p></dd> <dt class="title-link"><strong>System testing</strong></dt> <dd><p>Testing that a complete system behaves according to its specification. Specifically, system testing should not require knowing any details about the implementation. It typically involves testing many different aspects of the system behaviour apart from the basic functionality, such as performance, usability, and reliability.</p></dd> <dt class="title-link"><strong>Test-driven development</strong></dt> <dd><p>A program development technique where you continuously write tests <strong>before</strong> you implement the code that is supposed to pass those tests. This can help you focus on solving the right problems, and not make a more complicated implementation than necessary, by letting the unit tests determine when a program is "done": if it fulfils its specifications, there is no need to keep adding functionality.</p></dd> <dt class="title-link"><strong>Mock object</strong></dt> <dd><p>Sometimes, testing some unit <code>A</code> (e.g., a function) requires that it collaborates somehow with some other unit <code>B</code> (perhaps being passed as an argument, or by reference) - but <code>B</code> has not been implemented yet. A "mock object" - an object which, for the purposes of testing <code>A</code>, looks and behaves like a real <code>B</code> - might then be used instead. (This is of course only useful if it would be significantly more work to implement a real <code>B</code> than to create a mock object.)</p></dd> <dt class="title-link"><strong>Test case</strong></dt> <dd><p>A single, well-defined test, that somehow can be uniquely identified. When executed, the test case either <strong>passes</strong> or <strong>fails</strong>; the test report should identify exactly which test cases failed.</p></dd> <dt class="title-link"><strong>Test suite</strong></dt> <dd><p>A collection of test cases, generally with a specific, common target for testing, such as a single function, module, or subsystem. A test suite may also be recursively composed by smaller test suites.</p></dd> </dl> <h2 id="getting-started" class="title-link"> <div class="title-name">1.3 Getting started</div>  </h2> <ul> <li><p><code><a href="#Including_the_EUnit_header_file">Including the EUnit header file</a></code></p></li> <li><p><code><a href="#Writing_simple_test_functions">Writing simple test functions</a></code></p></li> <li><p><code><a href="#Running_EUnit">Running EUnit</a></code></p></li> <li><p><code><a href="#Writing_test_generating_functions">Writing test generating functions</a></code></p></li> <li><p><code><a href="#An_example">An example</a></code></p></li> <li><p><code><a href="#Disabling_testing">Disabling testing</a></code></p></li> <li><p><code><a href="#Avoiding_compile-time_dependency_on_EUnit">Avoiding compile-time dependency on EUnit</a></code></p></li> </ul> <h3 id="including-the-eunit-header-file" class="title-link"> <div class="title-name">Including the EUnit header file</div>  </h3> <p> The simplest way to use EUnit in an Erlang module is to add the following line at the beginning of the module (after the <code>-module</code> declaration, but before any function definitions): </p> <pre data-language="erlang">-include_lib("eunit/include/eunit.hrl").</pre> <p> This will have the following effect: </p> <ul> <li><p>Creates an exported function <code>test()</code> (unless testing is turned off, and the module does not already contain a test() function), that can be used to run all the unit tests defined in the module</p></li> <li><p>Causes all functions whose names match <code>..._test()</code> or <code>..._test_()</code> to be automatically exported from the module (unless testing is turned off, or the <code>EUNIT_NOAUTO</code> macro is defined)</p></li> <li><p>Makes all the preprocessor macros of EUnit available, to help writing tests</p></li> </ul> <p> <strong>Note:</strong> For <code>-include_lib(...)</code> to work, the Erlang module search path <strong>must</strong> contain a directory whose name ends in <code>eunit/ebin</code> (pointing to the <code>ebin</code> subdirectory of the EUnit installation directory). If EUnit is installed as <code>lib/eunit</code> under your Erlang/OTP system directory, its <code>ebin</code> subdirectory will be automatically added to the search path when Erlang starts. Otherwise, you need to add the directory explicitly, by passing a <code>-pa</code> flag to the <code>erl</code> or <code>erlc</code> command. For example, a Makefile could contain the following action for compiling <code>.erl</code> files: </p> <pre data-language="erlang">erlc -pa "path/to/eunit/ebin" $(ERL_COMPILE_FLAGS) -o$(EBIN) $&lt;</pre> <p> or if you want Eunit to always be available when you run Erlang interactively, you can add a line like the following to your <code>$HOME/.erlang</code> file: </p> <pre data-language="erlang">code:add_path("/path/to/eunit/ebin").</pre> <h3 id="writing-simple-test-functions" class="title-link"> <div class="title-name">Writing simple test functions</div>  </h3> <p>The EUnit framework makes it extremely easy to write unit tests in Erlang. There are a few different ways of writing them, though, so we start with the simplest:</p> <p>A function with a name ending in <code>..._test()</code> is recognized by EUnit as a simple test function - it takes no arguments, and its execution either succeeds (returning some arbitrary value that EUnit will throw away), or fails by throwing an exception of some kind (or by not terminating, in which case it will be aborted after a while).</p> <p>An example of a simple test function could be the following: </p> <pre data-language="erlang">reverse_test() -&gt; lists:reverse([1,2,3]).</pre> <p> This just tests that the function <code>lists:reverse(List)</code> does not crash when <code>List</code> is <code>[1,2,3]</code>. It is not a great test, but many people write simple functions like this one to test the basic functionality of their code, and those tests can be used directly by EUnit, without changes, as long as their function names match.</p> <h3 id="Use_exceptions_to_signal_failure">
<strong id="Use_exceptions_to_signal_failure">Use exceptions to signal failure</strong> To write more interesting tests, we need to make them crash (throw an exception) when they don't get the result they expect. A simple way of doing this is to use pattern matching with <code>=</code>, as in the following examples: </h3> <pre data-language="erlang">reverse_nil_test() -&gt; [] = lists:reverse([]).
reverse_one_test() -&gt; [1] = lists:reverse([1]).
reverse_two_test() -&gt; [2,1] = lists:reverse([1,2]).</pre> <p> If there was some bug in <code>lists:reverse/1</code> that made it return something other than <code>[2,1]</code> when it got <code>[1,2]</code> as input, then the last test above would throw a <code>badmatch</code> error. The first two (we assume they do not get a <code>badmatch</code>) would simply return <code>[]</code> and <code>[1]</code>, respectively, so both succeed. (Note that EUnit is not psychic: if you write a test that returns a value, even if it is the wrong value, EUnit will consider it a success. You must make sure that the test is written so that it causes a crash if the result is not what it should be.)</p> <h3 id="Using_assert_macros">
<strong id="Using_assert_macros">Using assert macros</strong> If you want to use Boolean operators for your tests, the <code>assert</code> macro comes in handy (see <code><a href="#EUnit_macros">EUnit macros</a></code> for details): </h3> <pre data-language="erlang">length_test() -&gt; ?assert(length([1,2,3]) =:= 3).</pre> <p> The <code>?assert(Expression)</code> macro will evaluate <code>Expression</code>, and if that does not evaluate to <code>true</code>, it will throw an exception; otherwise it just returns <code>ok</code>. In the above example, the test will thus fail if the call to <code>length</code> does not return 3.</p> <h3 id="running-eunit" class="title-link"> <div class="title-name">Running EUnit</div>  </h3> <p>If you have added the declaration <code>-include_lib("eunit/include/eunit.hrl")</code> to your module, as described above, you only need to compile the module, and run the automatically exported function <code>test()</code>. For example, if your module was named <code>m</code>, then calling <code>m:test()</code> will run EUnit on all the tests defined in the module. You do not need to write <code>-export</code> declarations for the test functions. This is all done by magic.</p> <p>You can also use the function <code><a href="eunit.html#test-1">eunit:test/1</a></code> to run arbitrary tests, for example to try out some more advanced test descriptors (see <code><a href="#EUnit_test_representation">EUnit test representation</a></code>). For example, running <code>eunit:test(m)</code> does the same thing as the auto-generated function <code>m:test()</code>, while <code>eunit:test({inparallel, m})</code> runs the same test cases but executes them all in parallel.</p> <h3 id="Putting_tests_in_separate_modules">
<strong id="Putting_tests_in_separate_modules">Putting tests in separate modules</strong> </h3> <p>If you want to separate your test code from your normal code (at least for testing the exported functions), you can simply write the test functions in a module named <code>m_tests</code> (note: not <code>m_test</code>), if your module is named <code>m</code>. Then, whenever you ask EUnit to test the module <code>m</code>, it will also look for the module <code>m_tests</code> and run those tests as well. See <code>ModuleName</code> in the section <code><a href="#Primitives">Primitives</a></code> for details.</p> <h3 id="EUnit_captures_standard_output">
<strong id="EUnit_captures_standard_output">EUnit captures standard output</strong> </h3> <p>If your test code writes to the standard output, you may be surprised to see that the text does not appear on the console when the tests are running. This is because EUnit captures all standard output from test functions (this also includes setup and cleanup functions, but not generator functions), so that it can be included in the test report if errors occur. To bypass EUnit and print text directly to the console while testing, you can write to the <code>user</code> output stream, as in <code>io:format(user, "~w", [Term])</code>. The recommended way of doing this is to use the EUnit <code><a href="#Debugging_macros">Debugging macros</a></code>, which make it much simpler.</p> <p>For checking the output produced by the unit under test, see <code><a href="#Macros_for_checking_output">Macros for checking output</a></code>.</p> <h3 id="writing-test-generating-functions" class="title-link"> <div class="title-name">Writing test generating functions</div>  </h3> <p>A drawback of simple test functions is that you must write a separate function (with a separate name) for each test case. A more compact way of writing tests (and much more flexible, as we shall see), is to write functions that <strong>return</strong> tests, instead of <strong>being</strong> tests.</p> <p>A function with a name ending in <code>..._test_()</code> (note the final underscore) is recognized by EUnit as a <strong>test generator</strong> function. Test generators return a <strong>representation</strong> of a <strong>set of tests</strong> to be executed by EUnit.</p> <h3 id="Representing_a_test_as_data">
<strong id="Representing_a_test_as_data">Representing a test as data</strong> The most basic representation of a test is a single fun-expression that takes no arguments. For example, the following test generator: </h3> <pre data-language="erlang">basic_test_() -&gt;
    fun () -&gt; ?assert(1 + 1 =:= 2) end.</pre> <p> will have the same effect as the following simple test: </p> <pre data-language="erlang">simple_test() -&gt;
    ?assert(1 + 1 =:= 2).</pre> <p> (in fact, EUnit will handle all simple tests just like it handles fun-expressions: it will put them in a list, and run them one by one).</p> <h3 id="Using_macros_to_write_tests">
<strong id="Using_macros_to_write_tests">Using macros to write tests</strong> To make tests more compact and readable, as well as automatically add information about the line number in the source code where a test occurred (and reduce the number of characters you have to type), you can use the <code>_test</code> macro (note the initial underscore character), like this: </h3> <pre data-language="erlang">basic_test_() -&gt;
    ?_test(?assert(1 + 1 =:= 2)).</pre> <p> The <code>_test</code> macro takes any expression (the "body") as argument, and places it within a fun-expression (along with some extra information). The body can be any kind of test expression, just like the body of a simple test function.</p> <h3 id="Underscore-prefixed_macros_create_test_objects">
<strong id="Underscore-prefixed_macros_create_test_objects">Underscore-prefixed macros create test objects</strong> But this example can be made even shorter! Most test macros, such as the family of <code>assert</code> macros, have a corresponding form with an initial underscore character, which automatically adds a <code>?_test(...)</code> wrapper. The above example can then simply be written: </h3> <pre data-language="erlang">basic_test_() -&gt;
    ?_assert(1 + 1 =:= 2).</pre> <p> which has exactly the same meaning (note the <code>_assert</code> instead of <code>assert</code>). You can think of the initial underscore as signalling <strong>test object</strong>.</p> <h3 id="an-example" class="title-link"> <div class="title-name">An example</div>  </h3> <p> Sometimes, an example says more than a thousand words. The following small Erlang module shows how EUnit can be used in practice. </p> <pre data-language="erlang">   -module(fib).
   -export([fib/1]).
   -include_lib("eunit/include/eunit.hrl").

   fib(0) -&gt; 1;
   fib(1) -&gt; 1;
   fib(N) when N &gt; 1 -&gt; fib(N-1) + fib(N-2).

   fib_test_() -&gt;
       [?_assert(fib(0) =:= 1),
?_assert(fib(1) =:= 1),
?_assert(fib(2) =:= 2),
?_assert(fib(3) =:= 3),
?_assert(fib(4) =:= 5),
?_assert(fib(5) =:= 8),
?_assertException(error, function_clause, fib(-1)),
?_assert(fib(31) =:= 2178309)
       ].</pre> <p>(Author's note: When I first wrote this example, I happened to write a <code>*</code> instead of <code>+</code> in the <code>fib</code> function. Of course, this showed up immediately when I ran the tests.)</p> <p>See <code><a href="#EUnit_test_representation">EUnit test representation</a></code> for a full list of all the ways you can specify test sets in EUnit.</p> <h3 id="disabling-testing" class="title-link"> <div class="title-name">Disabling testing</div>  </h3> <p> Testing can be turned off by defining the <code>NOTEST</code> macro when compiling, for example as an option to <code>erlc</code>, as in: </p> <pre data-language="erlang">erlc -DNOTEST my_module.erl</pre> <p> or by adding a macro definition to the code, <strong>before the EUnit header file is included</strong>: </p> <pre data-language="erlang">-define(NOTEST, 1).</pre> <p> (the value is not important, but should typically be 1 or <code>true</code>). Note that unless the <code>EUNIT_NOAUTO</code> macro is defined, disabling testing will also automatically strip all test functions from the code, except for any that are explicitly declared as exported.</p> <p>For instance, to use EUnit in your application, but with testing turned off by default, put the following lines in a header file: </p> <pre data-language="erlang">-define(NOTEST, true).
-include_lib("eunit/include/eunit.hrl").</pre> <p> and then make sure that every module of your application includes that header file. This means that you have a single place to modify in order to change the default setting for testing. To override the <code>NOTEST</code> setting without modifying the code, you can define <code>TEST</code> in a compiler option, like this: </p> <pre data-language="erlang">erlc -DTEST my_module.erl</pre> <p>See <code><a href="#Compilation_control_macros">Compilation control macros</a></code> for details about these macros.</p> <h3 id="avoiding-compile-time-dependency-on-eunit" class="title-link"> <div class="title-name">Avoiding compile-time dependency on EUnit</div>  </h3> <p> If you are distributing the source code for your application for other people to compile and run, you probably want to ensure that the code compiles even if EUnit is not available. Like the example in the previous section, you can put the following lines in a common header file: </p> <pre data-language="erlang">-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-endif.</pre> <p> and, of course, also make sure that you place all test code that uses EUnit macros within <code>-ifdef(TEST)</code> or <code>-ifdef(EUNIT)</code> sections.</p> <h2 id="eunit-macros" class="title-link"> <div class="title-name">1.4 EUnit macros</div>  </h2> <p>Although all the functionality of EUnit is available even without the use of preprocessor macros, the EUnit header file defines a number of such macros in order to make it as easy as possible to write unit tests as compactly as possible and without getting too many details in the way.</p> <p>Except where explicitly stated, using EUnit macros will never introduce run-time dependencies on the EUnit library code, regardless of whether your code is compiled with testing enabled or disabled.</p> <ul> <li><p><code><a href="#Basic_macros">Basic macros</a></code></p></li> <li><p><code><a href="#Compilation_control_macros">Compilation control macros</a></code></p></li> <li><p><code><a href="#Utility_macros">Utility macros</a></code></p></li> <li><p><code><a href="#Assert_macros">Assert macros</a></code></p></li> <li><p><code><a href="#Macros_for_checking_output">Macros for checking output</a></code></p></li> <li><p><code><a href="#Macros_for_running_external_commands">Macros for running external commands</a></code></p></li> <li><p><code><a href="#Debugging_macros">Debugging macros</a></code></p></li> </ul> <h3 id="basic-macros" class="title-link"> <div class="title-name">Basic macros</div>  </h3> <dl> <dt class="title-link"><strong><code>_test(Expr)</code></strong></dt> <dd><p>Turns <code>Expr</code> into a "test object", by wrapping it in a fun-expression and a source line number. Technically, this is the same as <code>{?LINE, fun () -&gt; (Expr) end}</code>. </p></dd> </dl> <h3 id="compilation-control-macros" class="title-link"> <div class="title-name">Compilation control macros</div>  </h3> <dl> <dt class="title-link"><strong><code>EUNIT</code></strong></dt> <dd> <p>This macro is always defined to <code>true</code> whenever EUnit is enabled at compile time. This is typically used to place testing code within conditional compilation, as in: </p> <pre data-language="erlang">-ifdef(EUNIT).
    % test code here
    ...
-endif.</pre> <p> e.g., to ensure that the code can be compiled without including the EUnit header file, when testing is disabled. See also the macros <code>TEST</code> and <code>NOTEST</code>. </p> </dd> <dt class="title-link"><strong><code>EUNIT_NOAUTO</code></strong></dt> <dd><p>If this macro is defined, the automatic exporting or stripping of test functions will be disabled. </p></dd> <dt class="title-link"><strong><code>TEST</code></strong></dt> <dd> <p>This macro is always defined (to <code>true</code>, unless previously defined by the user to have another value) whenever EUnit is enabled at compile time. This can be used to place testing code within conditional compilation; see also the macros <code>NOTEST</code> and <code>EUNIT</code>.</p> <p>For testing code that is strictly dependent on EUnit, it may be preferable to use the <code>EUNIT</code> macro for this purpose, while for code that uses more generic testing conventions, using the <code>TEST</code> macro may be preferred.</p> <p>The <code>TEST</code> macro can also be used to override the <code>NOTEST</code> macro. If <code>TEST</code> is defined <strong>before</strong> the EUnit header file is included (even if <code>NOTEST</code> is also defined), then the code will be compiled with EUnit enabled. </p> </dd> <dt class="title-link"><strong><code>NOTEST</code></strong></dt> <dd> <p>This macro is always defined (to <code>true</code>, unless previously defined by the user to have another value) whenever EUnit is <strong>disabled</strong> at compile time. (Compare the <code>TEST</code> macro.)</p> <p>This macro can also be used for conditional compilation, but is more typically used to disable testing: If <code>NOTEST</code> is defined <strong>before</strong> the EUnit header file is included, and <code>TEST</code> is <strong>not</strong> defined, then the code will be compiled with EUnit disabled. See also <code><a href="#Disabling_testing">Disabling testing</a></code>. </p> </dd> <dt class="title-link"><strong><code>NOASSERT</code></strong></dt> <dd><p>If this macro is defined, the assert macros will have no effect, when testing is also disabled. See <code><a href="#Assert_macros">Assert macros</a></code>. When testing is enabled, the assert macros are always enabled automatically and cannot be disabled. </p></dd> <dt class="title-link"><strong><code>ASSERT</code></strong></dt> <dd><p>If this macro is defined, it overrides the NOASSERT macro, forcing the assert macros to always be enabled regardless of other settings. </p></dd> <dt class="title-link"><strong><code>NODEBUG</code></strong></dt> <dd><p>If this macro is defined, the debugging macros will have no effect. See <code><a href="#Debugging_macros">Debugging macros</a></code>. <code>NODEBUG</code> also implies <code>NOASSERT</code>, unless testing is enabled. </p></dd> <dt class="title-link"><strong><code>DEBUG</code></strong></dt> <dd><p>If this macro is defined, it overrides the NODEBUG macro, forcing the debugging macros to be enabled. </p></dd> </dl> <h3 id="utility-macros" class="title-link"> <div class="title-name">Utility macros</div>  </h3> <p>The following macros can make tests more compact and readable:</p> <dl> <dt class="title-link"><strong><code>LET(Var,Arg,Expr)</code></strong></dt> <dd><p>Creates a local binding <code>Var = Arg</code> in <code>Expr</code>. (This is the same as <code>(fun(Var)-&gt;(Expr)end)(Arg)</code>.) Note that the binding is not exported outside of <code>Expr</code>, and that within <code>Expr</code>, this binding of <code>Var</code> will shadow any binding of <code>Var</code> in the surrounding scope. </p></dd> <dt class="title-link"><strong><code>IF(Cond,TrueCase,FalseCase)</code></strong></dt> <dd><p>Evaluates <code>TrueCase</code> if <code>Cond</code> evaluates to <code>true</code>, or otherwise evaluates <code>FalseCase</code> if <code>Cond</code> evaluates to <code>false</code>. (This is the same as <code>(case (Cond) of true-&gt;(TrueCase); false-&gt;(FalseCase) end)</code>.) Note that it is an error if <code>Cond</code> does not yield a boolean value. </p></dd> </dl> <h3 id="assert-macros" class="title-link"> <div class="title-name">Assert macros</div>  </h3> <p>(Note that these macros also have corresponding forms which start with an "<code>_</code>" (underscore) character, as in <code>?_assert(BoolExpr)</code>, that create a "test object" instead of performing the test immediately. This is equivalent to writing <code>?_test(assert(BoolExpr))</code>, etc.)</p> <p>If the macro <code>NOASSERT</code> is defined before the EUnit header file is included, these macros have no effect when testing is also disabled; see <code><a href="#Compilation_control_macros">Compilation control macros</a></code> for details.</p> <dl> <dt class="title-link"><strong><code>assert(BoolExpr)</code></strong></dt> <dd> <p>Evaluates the expression <code>BoolExpr</code>, if testing is enabled. Unless the result is <code>true</code>, an informative exception will be generated. If there is no exception, the result of the macro expression is the atom <code>ok</code>, and the value of <code>BoolExpr</code> is discarded. If testing is disabled, the macro will not generate any code except the atom <code>ok</code>, and <code>BoolExpr</code> will not be evaluated.</p> <p>Typical usage: </p> <pre data-language="erlang">?assert(f(X, Y) =:= [])</pre> <p> The <code>assert</code> macro can be used anywhere in a program, not just in unit tests, to check pre/postconditions and invariants. For example: </p> <pre data-language="erlang">some_recursive_function(X, Y, Z) -&gt;
    ?assert(X + Y &gt; Z),
    ...</pre>  </dd> <dt class="title-link"><strong><code>assertNot(BoolExpr)</code></strong></dt> <dd><p>Equivalent to <code>assert(not (BoolExpr))</code>. </p></dd> <dt class="title-link"><strong><code>assertMatch(GuardedPattern, Expr)</code></strong></dt> <dd> <p>Evaluates <code>Expr</code> and matches the result against <code>GuardedPattern</code>, if testing is enabled. If the match fails, an informative exception will be generated; see the <code>assert</code> macro for further details. <code>GuardedPattern</code> can be anything that you can write on the left hand side of the <code>-&gt;</code> symbol in a case-clause, except that it cannot contain comma-separated guard tests.</p> <p>The main reason for using <code>assertMatch</code> also for simple matches, instead of matching with <code>=</code>, is that it produces more detailed error messages.</p> <p>Examples: </p> <pre data-language="erlang">?assertMatch({found, {fred, _}}, lookup(bloggs, Table))</pre> <pre data-language="erlang">?assertMatch([X|_] when X &gt; 0, binary_to_list(B))</pre>  </dd> <dt class="title-link"><strong><code>assertNotMatch(GuardedPattern, Expr)</code></strong></dt> <dd><p>The inverse case of assertMatch, for convenience. </p></dd> <dt class="title-link"><strong><code>assertEqual(Expect, Expr)</code></strong></dt> <dd> <p>Evaluates the expressions <code>Expect</code> and <code>Expr</code> and compares the results for equality, if testing is enabled. If the values are not equal, an informative exception will be generated; see the <code>assert</code> macro for further details.</p> <p><code>assertEqual</code> is more suitable than <code>assertMatch</code> when the left-hand side is a computed value rather than a simple pattern, and gives more details than <code>?assert(Expect =:= Expr)</code>.</p> <p>Examples: </p> <pre data-language="erlang">?assertEqual("b" ++ "a", lists:reverse("ab"))</pre> <pre data-language="erlang">?assertEqual(foo(X), bar(Y))</pre>  </dd> <dt class="title-link"><strong><code>assertNotEqual(Unexpected, Expr)</code></strong></dt> <dd><p>The inverse case of assertEqual, for convenience. </p></dd> <dt class="title-link"><strong><code>assertException(ClassPattern, TermPattern, Expr)</code></strong></dt>  <dt class="title-link"><strong><code>assertError(TermPattern, Expr)</code></strong></dt>  <dt class="title-link"><strong><code>assertExit(TermPattern, Expr)</code></strong></dt>  <dt class="title-link"><strong><code>assertThrow(TermPattern, Expr)</code></strong></dt> <dd> <p>Evaluates <code>Expr</code>, catching any exception and testing that it matches the expected <code>ClassPattern:TermPattern</code>. If the match fails, or if no exception is thrown by <code>Expr</code>, an informative exception will be generated; see the <code>assert</code> macro for further details. The <code>assertError</code>, <code>assertExit</code>, and <code>assertThrow</code> macros, are equivalent to using <code>assertException</code> with a <code>ClassPattern</code> of <code>error</code>, <code>exit</code>, or <code>throw</code>, respectively.</p> <p>Examples: </p> <pre data-language="erlang">?assertError(badarith, X/0)</pre> <pre data-language="erlang">?assertExit(normal, exit(normal))</pre> <pre data-language="erlang">?assertException(throw, {not_found,_}, throw({not_found,42}))</pre>  </dd> </dl> <h3 id="macros-for-checking-output" class="title-link"> <div class="title-name">Macros for checking output</div>  </h3> <p>The following macro can be used within a test case to retrieve the output written to standard output.</p> <dl> <dt class="title-link"><strong><code>capturedOutput</code></strong></dt> <dd> <p>The output captured by EUnit in the current test case, as a string.</p> <p>Examples:</p> <pre data-language="erlang">io:format("Hello~n"),
?assertEqual("Hello\n", ?capturedOutput)</pre>  </dd> </dl> <h3 id="macros-for-running-external-commands" class="title-link"> <div class="title-name">Macros for running external commands</div>  </h3> <p>Keep in mind that external commands are highly dependent on the operating system. You can use the standard library function <code>os:type()</code> in test generator functions, to produce different sets of tests depending on the current operating system.</p> <p>Note: these macros introduce a run-time dependency on the EUnit library code, if compiled with testing enabled.</p> <dl> <dt class="title-link"><strong><code>assertCmd(CommandString)</code></strong></dt> <dd> <p>Runs <code>CommandString</code> as an external command, if testing is enabled. Unless the returned status value is 0, an informative exception will be generated. If there is no exception, the result of the macro expression is the atom <code>ok</code>. If testing is disabled, the macro will not generate any code except the atom <code>ok</code>, and the command will not be executed.</p> <p>Typical usage: </p> <pre data-language="erlang">?assertCmd("mkdir foo")</pre>  </dd> <dt class="title-link"><strong><code>assertCmdStatus(N, CommandString)</code></strong></dt> <dd><p>Like the <code>assertCmd(CommandString)</code> macro, but generates an exception unless the returned status value is <code>N</code>. </p></dd> <dt class="title-link"><strong><code>assertCmdOutput(Text, CommandString)</code></strong></dt> <dd><p>Runs <code>CommandString</code> as an external command, if testing is enabled. Unless the output produced by the command exactly matches the specified string <code>Text</code>, an informative exception will be generated. (Note that the output is normalized to use a single LF character as line break on all platforms.) If there is no exception, the result of the macro expression is the atom <code>ok</code>. If testing is disabled, the macro will not generate any code except the atom <code>ok</code>, and the command will not be executed. </p></dd> <dt class="title-link"><strong><code>cmd(CommandString)</code></strong></dt> <dd> <p>Runs <code>CommandString</code> as an external command. Unless the returned status value is 0 (indicating success), an informative exception will be generated; otherwise, the result of the macro expression is the output produced by the command, as a flat string. The output is normalized to use a single LF character as line break on all platforms.</p> <p>This macro is useful in the setup and cleanup sections of fixtures, e.g., for creating and deleting files or perform similar operating system specific tasks, to make sure that the test system is informed of any failures.</p> <p>A Unix-specific example: </p> <pre data-language="erlang">{setup,
 fun () -&gt; ?cmd("mktemp") end,
 fun (FileName) -&gt; ?cmd("rm " ++ FileName) end,
 ...}</pre>  </dd> </dl> <h3 id="debugging-macros" class="title-link"> <div class="title-name">Debugging macros</div>  </h3> <p>To help with debugging, EUnit defines several useful macros for printing messages directly to the console (rather than to the standard output). Furthermore, these macros all use the same basic format, which includes the file and line number where they occur, making it possible in some development environments (e.g., when running Erlang in an Emacs buffer) to simply click on the message and jump directly to the corresponding line in the code.</p> <p>If the macro <code>NODEBUG</code> is defined before the EUnit header file is included, these macros have no effect; see <code><a href="#Compilation_control_macros">Compilation control macros</a></code> for details.</p> <dl> <dt class="title-link"><strong><code>debugHere</code></strong></dt> <dd><p>Just prints a marker showing the current file and line number. Note that this is an argument-less macro. The result is always <code>ok</code>.</p></dd> <dt class="title-link"><strong><code>debugMsg(Text)</code></strong></dt> <dd><p>Outputs the message <code>Text</code> (which can be a plain string, an IO-list, or just an atom). The result is always <code>ok</code>.</p></dd> <dt class="title-link"><strong><code>debugFmt(FmtString, Args)</code></strong></dt> <dd><p>This formats the text like <code>io:format(FmtString, Args)</code> and outputs it like <code>debugMsg</code>. The result is always <code>ok</code>.</p></dd> <dt class="title-link"><strong><code>debugVal(Expr)</code></strong></dt> <dd><p>Prints both the source code for <code>Expr</code> and its current value. E.g., <code>?debugVal(f(X))</code> might be displayed as "<code>f(X) = 42</code>". (Large terms are truncated to the depth given by the macro <code>EUNIT_DEBUG_VAL_DEPTH</code>, which defaults to 15 but can be overridden by the user.) The result is always the value of <code>Expr</code>, so this macro can be wrapped around any expression to display its value when the code is compiled with debugging enabled.</p></dd> <dt class="title-link"><strong><code>debugVal(Expr, Depth)</code></strong></dt> <dd><p>Like <code>debugVal(Expr)</code>, but prints terms truncated to the given depth.</p></dd> <dt class="title-link"><strong><code>debugTime(Text,Expr)</code></strong></dt> <dd><p>Prints <code>Text</code> and the wall clock time for evaluation of <code>Expr</code>. The result is always the value of <code>Expr</code>, so this macro can be wrapped around any expression to show its run time when the code is compiled with debugging enabled. For example, <code>List1 = ?debugTime("sorting", lists:sort(List))</code> might show as "<code>sorting: 0.015 s</code>".</p></dd> </dl>  <h2 id="eunit-test-representation" class="title-link"> <div class="title-name">1.5 EUnit test representation</div>  </h2> <p>The way EUnit represents tests and test sets as data is flexible, powerful, and concise. This section describes the representation in detail.</p> <ul> <li><p><code><a href="#Simple_test_objects">Simple test objects</a></code></p></li> <li><p><code><a href="#Test_sets_and_deep_lists">Test sets and deep lists</a></code></p></li> <li><p><code><a href="#Titles">Titles</a></code></p></li> <li><p><code><a href="#Primitives">Primitives</a></code></p></li> <li><p><code><a href="#Control">Control</a></code></p></li> <li><p><code><a href="#Fixtures">Fixtures</a></code></p></li> <li><p><code><a href="#Lazy_generators">Lazy generators</a></code></p></li> </ul> <h3 id="simple-test-objects" class="title-link"> <div class="title-name">Simple test objects</div>  </h3> <p> A <strong>simple test object</strong> is one of the following: </p> <ul> <li> <p>A nullary functional value (i.e., a fun that takes zero arguments). Examples: </p> <pre data-language="erlang">fun () -&gt; ... end</pre> <pre data-language="erlang">fun some_function/0</pre> <pre data-language="erlang">fun some_module:some_function/0</pre>  </li> <li><p>A tuple <code>{test, ModuleName, FunctionName}</code>, where <code>ModuleName</code> and <code>FunctionName</code> are atoms, referring to the function <code>ModuleName:FunctionName/0</code></p></li> <li><p>(Obsolete) A pair of atoms <code>{ModuleName, FunctionName}</code>, equivalent to <code>{test, ModuleName, FunctionName}</code> if nothing else matches first. This might be removed in a future version.</p></li> <li><p>A pair <code>{LineNumber, SimpleTest}</code>, where <code>LineNumber</code> is a nonnegative integer and <code>SimpleTest</code> is another simple test object. <code>LineNumber</code> should indicate the source line of the test. Pairs like this are usually only created via <code>?_test(...)</code> macros; see <code><a href="#Basic_macros">Basic macros</a></code>.</p></li> </ul> <p> In brief, a simple test object consists of a single function that takes no arguments (possibly annotated with some additional metadata, i.e., a line number). Evaluation of the function either <strong>succeeds</strong>, by returning some value (which is ignored), or <strong>fails</strong>, by throwing an exception.</p> <h3 id="test-sets-and-deep-lists" class="title-link"> <div class="title-name">Test sets and deep lists</div>  </h3> <p>A test set can be easily created by placing a sequence of test objects in a list. If <code>T_1</code>, ..., <code>T_N</code> are individual test objects, then <code>[T_1, ..., T_N]</code> is a test set consisting of those objects (in that order).</p> <p>Test sets can be joined in the same way: if <code>S_1</code>, ..., <code>S_K</code> are test sets, then <code>[S_1, ..., S_K]</code> is also a test set, where the tests of <code>S_i</code> are ordered before those of <code>S_(i+1)</code>, for each subset <code>S_i</code>.</p> <p>Thus, the main representation of test sets is <strong>deep lists</strong>, and a simple test object can be viewed as a test set containing only a single test; there is no difference between <code>T</code> and <code>[T]</code>.</p> <p>A module can also be used to represent a test set; see <code>ModuleName</code> under <code><a href="#Primitives">Primitives</a></code> below.</p> <h3 id="titles" class="title-link"> <div class="title-name">Titles</div>  </h3> <p>Any test or test set <code>T</code> can be annotated with a title, by wrapping it in a pair <code>{Title, T}</code>, where <code>Title</code> is a string. For convenience, any test which is normally represented using a tuple can simply be given a title string as the first element, i.e., writing <code>{"The Title", ...}</code> instead of adding an extra tuple wrapper as in <code>{"The Title", {...}}</code>.</p> <h3 id="primitives" class="title-link"> <div class="title-name">Primitives</div>  </h3> <p> The following are primitives, which do not contain other test sets as arguments: </p> <dl> <dt class="title-link"><strong><code>ModuleName::atom()</code> </strong></dt> <dd><p>A single atom represents a module name, and is equivalent to <code>{module, ModuleName}</code>. This is often used as in the call <code>eunit:test(some_module)</code>. </p></dd> <dt class="title-link"><strong><code>{module, ModuleName::atom()}</code> </strong></dt> <dd> <p>This composes a test set from the exported test functions of the named module, i.e., those functions with arity zero whose names end with <code>_test</code> or <code>_test_</code>. Basically, the <code>..._test()</code> functions become simple tests, while the <code>..._test_()</code> functions become generators.</p> <p>In addition, EUnit will also look for another module whose name is <code>ModuleName</code> plus the suffix <code>_tests</code>, and if it exists, all the tests from that module will also be added. (If <code>ModuleName</code> already contains the suffix <code>_tests</code>, this is not done.) E.g., the specification <code>{module, mymodule}</code> will run all tests in the modules <code>mymodule</code> and <code>mymodule_tests</code>. Typically, the <code>_tests</code> module should only contain test cases that use the public interface of the main module (and no other code). </p> </dd> <dt class="title-link"><strong><code>{application, AppName::atom(), Info::list()}</code> </strong></dt> <dd><p>This is a normal Erlang/OTP application descriptor, as found in an <code>.app</code> file. The resulting test set consists of the modules listed in the <code>modules</code> entry in <code>Info</code>. </p></dd> <dt class="title-link"><strong><code>{application, AppName::atom()}</code> </strong></dt> <dd><p>This creates a test set from all the modules belonging to the specified application, by consulting the application's <code>.app</code> file (see <code>{file, FileName}</code>), or if no such file exists, by testing all object files in the application's <code>ebin</code>-directory (see <code>{dir, Path}</code>); if that does not exist, the <code>code:lib_dir(AppName)</code> directory is used. </p></dd> <dt class="title-link"><strong><code>Path::string()</code> </strong></dt> <dd><p>A single string represents the path of a file or directory, and is equivalent to <code>{file, Path}</code>, or <code>{dir, Path}</code>, respectively, depending on what <code>Path</code> refers to in the file system. </p></dd> <dt class="title-link"><strong><code>{file, FileName::string()}</code> </strong></dt> <dd> <p>If <code>FileName</code> has a suffix that indicates an object file (<code>.beam</code>), EUnit will try to reload the module from the specified file and test it. Otherwise, the file is assumed to be a text file containing test specifications, which will be read using the standard library function <code>file:path_consult/2</code>.</p> <p>Unless the file name is absolute, the file is first searched for relative to the current directory, and then using the normal search path (<code>code:get_path()</code>). This means that the names of typical "app" files can be used directly, without a path, e.g., <code>"mnesia.app"</code>. </p> </dd> <dt class="title-link"><strong><code>{dir, Path::string()}</code> </strong></dt> <dd><p>This tests all object files in the specified directory, as if they had been individually specified using <code>{file, FileName}</code>. </p></dd> <dt class="title-link"><strong><code>{generator, GenFun::(() -&gt; Tests)}</code> </strong></dt> <dd><p>The generator function <code>GenFun</code> is called to produce a test set. </p></dd> <dt class="title-link"><strong><code>{generator, ModuleName::atom(), FunctionName::atom()}</code> </strong></dt> <dd><p>The function <code>ModuleName:FunctionName()</code> is called to produce a test set. </p></dd> <dt class="title-link"><strong><code>{with, X::any(), [AbstractTestFun::((any()) -&gt; any())]}</code> </strong></dt> <dd><p>Distributes the value <code>X</code> over the unary functions in the list, turning them into nullary test functions. An <code>AbstractTestFun</code> is like an ordinary test fun, but takes one argument instead of zero - it's basically missing some information before it can be a proper test. In practice, <code>{with, X, [F_1, ..., F_N]}</code> is equivalent to <code>[fun () -&gt; F_1(X) end, ..., fun () -&gt; F_N(X) end]</code>. This is particularly useful if your abstract test functions are already implemented as proper functions: <code>{with, FD, [fun filetest_a/1, fun filetest_b/1, fun filetest_c/1]}</code> is equivalent to <code>[fun () -&gt; filetest_a(FD) end, fun () -&gt; filetest_b(FD) end, fun () -&gt; filetest_c(FD) end]</code>, but much more compact. See also <code><a href="#Fixtures">Fixtures</a></code>, below. </p></dd> </dl> <h3 id="control" class="title-link"> <div class="title-name">Control</div>  </h3> <p> The following representations control how and where tests are executed: </p> <dl> <dt class="title-link"><strong><code>{spawn, Tests}</code></strong></dt> <dd><p>Runs the specified tests in a separate subprocess, while the current test process waits for it to finish. This is useful for tests that need a fresh, isolated process state. (Note that EUnit always starts at least one such a subprocess automatically; tests are never executed by the caller's own process.)</p></dd> <dt class="title-link"><strong><code>{spawn, Node::atom(), Tests}</code></strong></dt> <dd><p>Like <code>{spawn, Tests}</code>, but runs the specified tests on the given Erlang node.</p></dd> <dt class="title-link"><strong><code>{timeout, Time::number(), Tests}</code></strong></dt> <dd><p>Runs the specified tests under the given timeout. Time is in seconds; e.g., 60 means one minute and 0.1 means 1/10th of a second. If the timeout is exceeded, the unfinished tests will be forced to terminate. Note that if a timeout is set around a fixture, it includes the time for setup and cleanup, and if the timeout is triggered, the entire fixture is abruptly terminated (without running the cleanup). The default timeout for an individual test is 5 seconds.</p></dd> <dt class="title-link"><strong><code>{inorder, Tests}</code></strong></dt> <dd><p>Runs the specified tests in strict order. Also see <code>{inparallel, Tests}</code>. By default, tests are neither marked as <code>inorder</code> or <code>inparallel</code>, but may be executed as the test framework chooses.</p></dd> <dt class="title-link"><strong><code>{inparallel, Tests}</code></strong></dt> <dd><p>Runs the specified tests in parallel (if possible). Also see <code>{inorder, Tests}</code>.</p></dd> <dt class="title-link"><strong><code>{inparallel, N::integer(), Tests}</code></strong></dt> <dd><p>Like <code>{inparallel, Tests}</code>, but running no more than <code>N</code> subtests simultaneously.</p></dd> </dl> <h3 id="fixtures" class="title-link"> <div class="title-name">Fixtures</div>  </h3> <p>A "fixture" is some state that is necessary for a particular set of tests to run. EUnit's support for fixtures makes it easy to set up such state locally for a test set, and automatically tear it down again when the test set is finished, regardless of the outcome (success, failures, timeouts, etc.).</p> <p>To make the descriptions simpler, we first list some definitions: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><code>Setup</code></td> <td><code>() -&gt; (R::any())</code></td> </tr> <tr> <td><code>SetupX</code></td> <td><code>(X::any()) -&gt; (R::any())</code></td> </tr> <tr> <td><code>Cleanup</code></td> <td><code>(R::any()) -&gt; any()</code></td> </tr> <tr> <td><code>CleanupX</code></td> <td><code>(X::any(), R::any()) -&gt; any()</code></td> </tr> <tr> <td><code>Instantiator</code></td> <td><code>((R::any()) -&gt; Tests) | {with, [AbstractTestFun::((any()) -&gt; any())]}</code></td> </tr> <tr> <td><code>Where</code></td> <td><code>local | spawn | {spawn, Node::atom()}</code></td> </tr> </table> <p class="doc-table-caption">Table 1.1: </p> </div> <p> (these are explained in more detail further below.)</p> <p>The following representations specify fixture handling for test sets: </p> <dl> <dt class="title-link"><strong><code>{setup, Setup, Tests | Instantiator}</code></strong></dt>  <dt class="title-link"><strong><code>{setup, Setup, Cleanup, Tests | Instantiator}</code></strong></dt>  <dt class="title-link"><strong><code>{setup, Where, Setup, Tests | Instantiator}</code></strong></dt>  <dt class="title-link"><strong><code>{setup, Where, Setup, Cleanup, Tests | Instantiator}</code></strong></dt> <dd><p><code>setup</code> sets up a single fixture for running all of the specified tests, with optional teardown afterwards. The arguments are described in detail below. </p></dd> <dt class="title-link"><strong><code>{node, Node::atom(), Tests | Instantiator}</code></strong></dt>  <dt class="title-link"><strong><code>{node, Node::atom(), Args::string(), Tests | Instantiator}</code></strong></dt> <dd><p><code>node</code> is like <code>setup</code>, but with a built-in behaviour: it starts a slave node for the duration of the tests. The atom <code>Node</code> should have the format <code>nodename@full.machine.name</code>, and <code>Args</code> are the optional arguments to the new node; see <code>slave:start_link/3</code> for details. </p></dd> <dt class="title-link"><strong><code>{foreach, Where, Setup, Cleanup, [Tests | Instantiator]}</code></strong></dt>  <dt class="title-link"><strong><code>{foreach, Setup, Cleanup, [Tests | Instantiator]}</code></strong></dt>  <dt class="title-link"><strong><code>{foreach, Where, Setup, [Tests | Instantiator]}</code></strong></dt>  <dt class="title-link"><strong><code>{foreach, Setup, [Tests | Instantiator]}</code></strong></dt> <dd><p><code>foreach</code> is used to set up a fixture and optionally tear it down afterwards, repeated for each single one of the specified test sets. </p></dd> <dt class="title-link"><strong><code>{foreachx, Where, SetupX, CleanupX, Pairs::[{X::any(), ((X::any(), R::any()) -&gt; Tests)}]}</code></strong></dt>  <dt class="title-link"><strong><code>{foreachx, SetupX, CleanupX, Pairs}</code></strong></dt>  <dt class="title-link"><strong><code>{foreachx, Where, SetupX, Pairs}</code></strong></dt>  <dt class="title-link"><strong><code>{foreachx, SetupX, Pairs}</code></strong></dt> <dd><p><code>foreachx</code> is like <code>foreach</code>, but uses a list of pairs, each containing an extra argument <code>X</code> and an extended instantiator function. </p></dd> </dl> <p>A <code>Setup</code> function is executed just before any of the specified tests are run, and a <code>Cleanup</code> function is executed when no more of the specified tests will be run, regardless of the reason. A <code>Setup</code> function takes no argument, and returns some value which will be passed as it is to the <code>Cleanup</code> function. A <code>Cleanup</code> function should do whatever necessary and return some arbitrary value, such as the atom <code>ok</code>. (<code>SetupX</code> and <code>CleanupX</code> functions are similar, but receive one additional argument: some value <code>X</code>, which depends on the context.) When no <code>Cleanup</code> function is specified, a dummy function is used which has no effect.</p> <p>An <code>Instantiator</code> function receives the same value as the <code>Cleanup</code> function, i.e., the value returned by the <code>Setup</code> function. It should then behave much like a generator (see <code><a href="#Primitives">Primitives</a></code>), and return a test set whose tests have been <strong>instantiated</strong> with the given value. A special case is the syntax <code>{with, [AbstractTestFun]}</code> which represents an instantiator function that distributes the value over a list of unary functions; see <code><a href="#Primitives">Primitives</a></code>: <code>{with, X, [...]}</code> for more details.</p> <p>A <code>Where</code> term controls how the specified tests are executed. The default is <code>spawn</code>, which means that the current process handles the setup and teardown, while the tests are executed in a subprocess. <code>{spawn, Node}</code> is like <code>spawn</code>, but runs the subprocess on the specified node. <code>local</code> means that the current process will handle both setup/teardown and running the tests - the drawback is that if a test times out so that the process is killed, the <strong>cleanup will not be performed</strong>; hence, avoid this for persistent fixtures such as file operations. In general, <code>local</code> should only be used when: </p> <ul> <li><p>the setup/teardown needs to be executed by the process that will run the tests;</p></li> <li><p>no further teardown needs to be done if the process is killed (i.e., no state outside the process was affected by the setup)</p></li> </ul> <h3 id="lazy-generators" class="title-link"> <div class="title-name">Lazy generators</div>  </h3> <p>Sometimes, it can be convenient not to produce the whole set of test descriptions before the testing begins; for example, if you want to generate a huge amount of tests that would take up too much space to keep in memory all at once.</p> <p>It is fairly easy to write a generator which, each time it is called, either produces an empty list if it is done, or otherwise produces a list containing a single test case plus a new generator which will produce the rest of the tests. This demonstrates the basic pattern:</p> <pre data-language="erlang">lazy_test_() -&gt;
    lazy_gen(10000).

lazy_gen(N) -&gt;
    {generator,
     fun () -&gt;
         if N &gt; 0 -&gt;
                [?_test(...)
                 | lazy_gen(N-1)];
            true -&gt;
                []
         end
     end}.</pre> <p>When EUnit traverses the test representation in order to run the tests, the new generator will not be called to produce the next test until the previous test has been executed.</p> <p>Note that it is easiest to write this kind of recursive generator using a help function, like the <code>lazy_gen/1</code> function above. It can also be written using a recursive fun, if you prefer to not clutter your function namespace and are comfortable with writing that kind of code. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
