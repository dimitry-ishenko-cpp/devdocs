  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">mnesia</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">A distributed telecommunications DBMS</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>The following are some of the most important and attractive capabilities provided by Mnesia:</p> <ul> <li>A relational/object hybrid data model that is suitable for telecommunications applications. </li> <li>A DBMS query language, Query List Comprehension (QLC) as an add-on library. </li> <li>Persistence. Tables can be coherently kept on disc and in the main memory. </li> <li>Replication. Tables can be replicated at several nodes. </li> <li>Atomic transactions. A series of table manipulation operations can be grouped into a single atomic transaction. </li> <li>Location transparency. Programs can be written without knowledge of the actual data location. </li> <li>Extremely fast real-time data searches. </li> <li>Schema manipulation routines. The DBMS can be reconfigured at runtime without stopping the system. </li> </ul> <p>This Reference Manual describes the Mnesia API. This includes functions that define and manipulate Mnesia tables.</p> <p>All functions in this Reference Manual can be used in any combination with queries using the list comprehension notation. For information about the query notation, see the <code>qlc</code> manual page in STDLIB.</p> <p>Data in Mnesia is organized as a set of tables. Each table has a name that must be an atom. Each table is made up of Erlang records. The user is responsible for the record definitions. Each table also has a set of properties. The following are some of the properties that are associated with each table:</p> <ul> <li> <p><code>type</code>. Each table can have <code>set</code>, <code>ordered_set</code>, or <code>bag</code> semantics. Notice that currently <code>ordered_set</code> is not supported for <code>disc_only_copies</code>.</p> <p>If a table is of type <code>set</code>, each key leads to either one or zero records.</p> <p>If a new item is inserted with the same key as an existing record, the old record is overwritten. However, if a table is of type <code>bag</code>, each key can map to several records. All records in type <code>bag</code> tables are unique, only the keys can be duplicated.</p> </li> <li> <p><code>record_name</code>. All records stored in a table must have the same name. The records must be instances of the same record type.</p> </li> <li> <p><code>ram_copies</code>. A table can be replicated on a number of Erlang nodes. Property <code>ram_copies</code> specifies a list of Erlang nodes where RAM copies are kept. These copies can be dumped to disc at regular intervals. However, updates to these copies are not written to disc on a transaction basis.</p> </li> <li> <p><code>disc_copies</code>. This property specifies a list of Erlang nodes where the table is kept in RAM and on disc. All updates of the table are performed in the actual table and are also logged to disc. If a table is of type <code>disc_copies</code> at a certain node, the entire table is resident in RAM memory and on disc. Each transaction performed on the table is appended to a <code>LOG</code> file and written into the RAM table.</p> </li> <li> <p><code>disc_only_copies</code>. Some, or all, table replicas can be kept on disc only. These replicas are considerably slower than the RAM-based replicas.</p> </li> <li> <p><code>index</code>. This is a list of attribute names, or integers, which specify the tuple positions on which Mnesia is to build and maintain an extra index table.</p> </li> <li> <p><code>local_content</code>. When an application requires tables whose contents are local to each node, <code>local_content</code> tables can be used. The table name is known to all Mnesia nodes, but its content is unique on each node. This means that access to such a table must be done locally. Set field <code>local_content</code> to <code>true</code> to enable the <code>local_content</code> behavior. Default is <code>false</code>.</p> </li> <li> <p><code>majority</code>. This attribute is <code>true</code> or <code>false</code>; default is <code>false</code>. When <code>true</code>, a majority of the table replicas must be available for an update to succeed. Majority checking can be enabled on tables with mission-critical data, where it is vital to avoid inconsistencies because of network splits.</p> </li> <li> <p><code>snmp</code>. Each (set-based) Mnesia table can be automatically turned into a Simple Network Management Protocol (SNMP) ordered table as well. This property specifies the types of the SNMP keys.</p> </li> <li> <p><code>attributes</code>. The names of the attributes for the records that are inserted in the table.</p> </li> </ul> <p>For information about the complete set of table properties and their details, see <code>mnesia:create_table/2</code>.</p> <p>This Reference Manual uses a table of persons to illustrate various examples. The following record definition is assumed:</p> <pre data-language="erlang">-record(person, {name,
                 age = 0,
                 address = unknown,
                 salary = 0,
                 children = []}),</pre> <p>The first record attribute is the primary key, or key for short.</p> <p>The function descriptions are sorted in alphabetical order. It is recommended to start to read about <code>mnesia:create_table/2</code>, <code>mnesia:lock/2</code>, and <code>mnesia:activity/4</code> before you continue and learn about the rest.</p> <p>Writing or deleting in transaction-context creates a local copy of each modified record during the transaction. During iteration, that is, <code>mnesia:fold[lr]/4</code>, <code>mnesia:next/2</code>, <code>mnesia:prev/2</code>, and <code>mnesia:snmp_get_next_index/2</code>, Mnesia compensates for every written or deleted record, which can reduce the performance.</p> <p>If possible, avoid writing or deleting records in the same transaction before iterating over the table.</p> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-table" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-table">table()</a> = atom()</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-activity" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-activity">activity()</a> = 
 ets | async_dirty | sync_dirty | transaction |
 sync_transaction |
 {transaction, Retries :: integer() &gt;= 0} |
 {sync_transaction, Retries :: integer() &gt;= 0}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-create_option" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-create_option">create_option()</a> = 
 {access_mode, read_write | read_only} |
 {attributes, [atom()]} |
 {disc_copies, [node()]} |
 {disc_only_copies, [node()]} |
 {index, [<a href="#type-index_attr">index_attr()</a>]} |
 {load_order, integer() &gt;= 0} |
 {majority, boolean()} |
 {ram_copies, [node()]} |
 {record_name, atom()} |
 {snmp, SnmpStruct :: term()} |
 {storage_properties,
 [{Backend :: module(), [BackendProp :: term()]}]} |
 {type, set | ordered_set | bag} |
 {local_content, boolean()} |
 {user_properties, proplists:proplist()}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-storage_type" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-storage_type">storage_type()</a> = ram_copies | disc_copies | disc_only_copies</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-t_result" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-t_result">t_result(Res)</a> = {atomic, Res} | {aborted, Reason :: term()}</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-result" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-result">result()</a> = ok | {error, Reason :: term()}</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-index_attr" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-index_attr">index_attr()</a> = atom() | integer() &gt;= 0 | {atom()}</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-write_locks" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-write_locks">write_locks()</a> = write | sticky_write</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-read_locks" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-read_locks">read_locks()</a> = read</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-lock_kind" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-lock_kind">lock_kind()</a> = <a href="#type-write_locks">write_locks()</a> | <a href="#type-read_locks">read_locks()</a></code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-select_continuation" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-select_continuation">select_continuation()</a> = term()</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-snmp_struct" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-snmp_struct">snmp_struct()</a> = [{atom(), <a href="#type-snmp_type">snmp_type()</a> | <a href="#type-tuple_of">tuple_of</a>(<a href="#type-snmp_type">snmp_type()</a>)}]</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-snmp_type" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-snmp_type">snmp_type()</a> = fix_string | string | integer</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-tuple_of" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-tuple_of">tuple_of(_T)</a> = tuple()</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-config_key" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-config_key">config_key()</a> = extra_db_nodes | dc_dump_limit</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-config_value" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-config_value">config_value()</a> = [node()] | number()</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-config_result" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-config_result">config_result()</a> = {ok, <a href="#type-config_value">config_value()</a>} | {error, term()}</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-debug_level" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-debug_level">debug_level()</a> = none | verbose | debug | trace</code><br> </div> </h3> </article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="abort-1" class="bold_code title-link func-head">  <code>abort(Reason :: <code>term()</code>) -&gt; <code>no_return()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Makes the transaction silently return the tuple <code>{aborted, Reason}</code>. Termination of a Mnesia transaction means that an exception is thrown to an enclosing <code>catch</code>. Thus, the expression <code>catch mnesia:abort(x)</code> does not terminate the transaction.</p> </div></div></article><article class="func"><h3 id="activate_checkpoint-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>activate_checkpoint(Args :: [Arg]) -&gt;
 {ok, Name, [<code>node()</code>]} |
 {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><pre><code>Arg = 
 {name, Name} |
 {max, [<a href="#type-table">table()</a>]} |
 {min, [<a href="#type-table">table()</a>]} |
 {allow_remote, boolean()} |
 {ram_overrides_dump, boolean()}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="activate_checkpoint">A checkpoint is a consistent view of the system. A checkpoint can be activated on a set of tables. This checkpoint can then be traversed and presents a view of the system as it existed at the time when the checkpoint was activated, even if the tables are being or have been manipulated.</p> <p><code>Args</code> is a list of the following tuples:</p> <ul> <li> <p><code>{name,Name}</code>. <code>Name</code> is the checkpoint name. Each checkpoint must have a name that is unique to the associated nodes. The name can be reused only once the checkpoint has been deactivated. By default, a name that is probably unique is generated.</p> </li> <li> <p><code>{max,MaxTabs}</code>. <code>MaxTabs</code> is a list of tables that are to be included in the checkpoint. Default is <code>[]</code>. For these tables, the redundancy is maximized and checkpoint information is retained together with all replicas. The checkpoint becomes more fault tolerant if the tables have several replicas. When a new replica is added by the schema manipulation function <code>mnesia:add_table_copy/3</code>, a retainer is also attached automatically.</p> </li> <li> <p><code>{min,MinTabs}</code>. <code>MinTabs</code> is a list of tables that are to be included in the checkpoint. Default is []. For these tables, the redundancy is minimized and the checkpoint information is only retained with one replica, preferably on the local node.</p> </li> <li> <p><code>{allow_remote,Bool}</code>. <code>false</code> means that all retainers must be local. The checkpoint cannot be activated if a table does not reside locally. <code>true</code> allows retainers to be allocated on any node. Default is <code>true</code>.</p> </li> <li> <p><code>{ram_overrides_dump,Bool}</code>. Only applicable for <code>ram_copies</code>. <code>Bool</code> allows you to choose to back up the table state as it is in RAM, or as it is on disc. <code>true</code> means that the latest committed records in RAM are to be included in the checkpoint. These are the records that the application accesses. <code>false</code> means that the records dumped to <code>DAT</code> files are to be included in the checkpoint. These records are loaded at startup. Default is <code>false</code>.</p> </li> </ul> <p>Returns <code>{ok,Name,Nodes}</code> or <code>{error,Reason}</code>. <code>Name</code> is the (possibly generated) checkpoint name. <code>Nodes</code> are the nodes that are involved in the checkpoint. Only nodes that keep a checkpoint retainer know about the checkpoint.</p> </div></div></article><article class="func"><h3 id="activity-2" class="bold_code title-link func-head">  <code>activity(Kind, Fun) -&gt; <code><a href="#type-t_result">t_result</a></code>(Res) | Res</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Kind = <a href="#type-activity">activity()</a></code></div> <div class="REFTYPES rt-1"><code>Fun = fun(() -&gt; Res)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="activity_2_3">Calls <code>mnesia:activity(AccessContext, Fun, Args, AccessMod)</code>, where <code>AccessMod</code> is the default access callback module obtained by <code>mnesia:system_info(access_module)</code>. <code>Args</code> defaults to <code>[]</code> (empty list).</p> </div></div></article><article class="func"><h3 id="activity-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>activity(Kind, Fun, Args :: [Arg :: <code>term()</code>], Mod) -&gt;
 <code><a href="#type-t_result">t_result</a></code>(Res) | Res</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Kind = <a href="#type-activity">activity()</a></code></div> <div class="REFTYPES rt-1"><code>Fun = fun((...) -&gt; Res)</code></div> <div class="REFTYPES rt-1"><code>Mod = atom()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="activity_4">Executes the functional object <code>Fun</code> with argument <code>Args</code>.</p> <p>The code that executes inside the activity can consist of a series of table manipulation functions, which are performed in an <code>AccessContext</code>. Currently, the following access contexts are supported:</p> <dl> <dt class="title-link"><strong><code>transaction</code></strong></dt> <dd> <p>Short for <code>{transaction, infinity}</code></p> </dd> <dt class="title-link"><strong><code>{transaction, Retries}</code></strong></dt> <dd> <p>Calls <code>mnesia:transaction(Fun, Args, Retries)</code>. Notice that the result from <code>Fun</code> is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</p> </dd> <dt class="title-link"><strong><code>sync_transaction</code></strong></dt> <dd> <p>Short for <code>{sync_transaction, infinity}</code></p> </dd> <dt class="title-link"><strong><code>{sync_transaction, Retries}</code></strong></dt> <dd> <p>Calls <code>mnesia:sync_transaction(Fun, Args, Retries)</code>. Notice that the result from <code>Fun</code> is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</p> </dd> <dt class="title-link"><strong><code>async_dirty</code></strong></dt> <dd> <p>Calls <code>mnesia:async_dirty(Fun, Args)</code>.</p> </dd> <dt class="title-link"><strong><code>sync_dirty</code></strong></dt> <dd> <p>Calls <code>mnesia:sync_dirty(Fun, Args)</code>.</p> </dd> <dt class="title-link"><strong><code>ets</code></strong></dt> <dd> <p>Calls <code>mnesia:ets(Fun, Args)</code>.</p> </dd> </dl> <p>This function (<code>mnesia:activity/4</code>) differs in an important way from the functions <code>mnesia:transaction</code>, <code>mnesia:sync_transaction</code>, <code>mnesia:async_dirty</code>, <code>mnesia:sync_dirty</code>, and <code>mnesia:ets</code>. Argument <code>AccessMod</code> is the name of a callback module, which implements the <code>mnesia_access</code> behavior.</p> <p>Mnesia forwards calls to the following functions:</p> <ul> <li>mnesia:lock/2 (read_lock_table/1, write_lock_table/1) </li> <li>mnesia:write/3 (write/1, s_write/1) </li> <li>mnesia:delete/3 (delete/1, s_delete/1) </li> <li>mnesia:delete_object/3 (delete_object/1, s_delete_object/1) </li> <li>mnesia:read/3 (read/1, wread/1) </li> <li>mnesia:match_object/3 (match_object/1) </li> <li>mnesia:all_keys/1 </li> <li>mnesia:first/1 </li> <li>mnesia:last/1 </li> <li>mnesia:prev/2 </li> <li>mnesia:next/2 </li> <li>mnesia:index_match_object/4 (index_match_object/2) </li> <li>mnesia:index_read/3 </li> <li>mnesia:table_info/2 </li> </ul> <p>to the corresponding:</p> <ul> <li>AccessMod:lock(ActivityId, Opaque, LockItem, LockKind) </li> <li>AccessMod:write(ActivityId, Opaque, Tab, Rec, LockKind) </li> <li>AccessMod:delete(ActivityId, Opaque, Tab, Key, LockKind) </li> <li>AccessMod:delete_object(ActivityId, Opaque, Tab, RecXS, LockKind) </li> <li>AccessMod:read(ActivityId, Opaque, Tab, Key, LockKind) </li> <li>AccessMod:match_object(ActivityId, Opaque, Tab, Pattern, LockKind) </li> <li>AccessMod:all_keys(ActivityId, Opaque, Tab, LockKind) </li> <li>AccessMod:first(ActivityId, Opaque, Tab) </li> <li>AccessMod:last(ActivityId, Opaque, Tab) </li> <li>AccessMod:prev(ActivityId, Opaque, Tab, Key) </li> <li>AccessMod:next(ActivityId, Opaque, Tab, Key) </li> <li>AccessMod:index_match_object(ActivityId, Opaque, Tab, Pattern, Attr, LockKind) </li> <li>AccessMod:index_read(ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind) </li> <li>AccessMod:table_info(ActivityId, Opaque, Tab, InfoItem) </li> </ul> <p><code>ActivityId</code> is a record that represents the identity of the enclosing Mnesia activity. The first field (obtained with <code>element(1, ActivityId)</code>) contains an atom, which can be interpreted as the activity type: <code>ets</code>, <code>async_dirty</code>, <code>sync_dirty</code>, or <code>tid</code>. <code>tid</code> means that the activity is a transaction. The structure of the rest of the identity record is internal to Mnesia.</p> <p><code>Opaque</code> is an opaque data structure that is internal to Mnesia.</p> </div></div></article><article class="func"><h3 id="add_table_copy-3" class="bold_code title-link func-head">  <code>add_table_copy(Tab, N, ST) -&gt; <code><a href="#type-t_result">t_result</a></code>(ok)</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>N = node()</code></div> <div class="REFTYPES rt-1"><code>ST = <a href="#type-storage_type">storage_type()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="add_table_copy">Makes another copy of a table at the node <code>Node</code>. Argument <code>Type</code> must be either of the atoms <code>ram_copies</code>, <code>disc_copies</code>, or <code>disc_only_copies</code>. For example, the following call ensures that a disc replica of the <code>person</code> table also exists at node <code>Node</code>:</p> <pre data-language="erlang">mnesia:add_table_copy(person, Node, disc_copies)</pre> <p>This function can also be used to add a replica of the table named <code>schema</code>.</p> </div></div></article><article class="func"><h3 id="add_table_index-2" class="bold_code title-link func-head">  <code>add_table_index(Tab, I) -&gt; <code><a href="#type-t_result">t_result</a></code>(ok)</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>I = <a href="#type-index_attr">index_attr()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="add_table_index">Table indexes can be used whenever the user wants to use frequently some other field than the key field to look up records. If this other field has an associated index, these lookups can occur in constant time and space. For example, if your application wishes to use field <code>age</code> to find efficiently all persons with a specific age, it can be a good idea to have an index on field <code>age</code>. This can be done with the following call:</p> <pre data-language="erlang">mnesia:add_table_index(person, age)</pre> <p>Indexes do not come for free. They occupy space that is proportional to the table size, and they cause insertions into the table to execute slightly slower.</p> </div></div></article><article class="func"><h3 id="all_keys-1" class="bold_code title-link func-head">  <code>all_keys(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; [Key :: <code>term()</code>]</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="all_keys">Returns a list of all keys in the table named <code>Tab</code>. The semantics of this function is context-sensitive. For more information, see <code>mnesia:activity/4</code>. In transaction-context, it acquires a read lock on the entire table.</p> </div></div></article><article class="func"><h3 id="async_dirty-1" class="bold_code title-link func-head">  <code>async_dirty(Fun) -&gt; Res | <code>no_return()</code></code> </h3> <h3 id="async_dirty-2" class="bold_code title-link func-head">  <code>async_dirty(Fun, Args :: [Arg :: <code>term()</code>]) -&gt; Res | <code>no_return()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((...) -&gt; Res)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="async_dirty">Calls the <code>Fun</code> in a context that is not protected by a transaction. The Mnesia function calls performed in the <code>Fun</code> are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions, but there is no locking, local transaction storage, or commit protocols involved. Checkpoint retainers and indexes are updated, but they are updated dirty. As for normal <code>mnesia:dirty_*</code> operations, the operations are performed semi-asynchronously. For details, see <code>mnesia:activity/4</code> and the User's Guide.</p> <p>The Mnesia tables can be manipulated without using transactions. This has some serious disadvantages, but is considerably faster, as the transaction manager is not involved and no locks are set. A dirty operation does, however, guarantee a certain level of consistency, and the dirty operations cannot return garbled records. All dirty operations provide location transparency to the programmer, and a program does not have to be aware of the whereabouts of a certain table to function.</p> <p>Notice that it is more than ten times more efficient to read records dirty than within a transaction.</p> <p>Depending on the application, it can be a good idea to use the dirty functions for certain operations. Almost all Mnesia functions that can be called within transactions have a dirty equivalent, which is much more efficient.</p> <p>However, notice that there is a risk that the database can be left in an inconsistent state if dirty operations are used to update it. Dirty operations are only to be used for performance reasons when it is absolutely necessary.</p> <p>Notice that calling (nesting) <code>mnesia:[a]sync_dirty</code> inside a transaction-context inherits the transaction semantics.</p> </div></div></article><article class="func"><h3 id="backup-1" class="bold_code title-link func-head">  <code>backup(Dest :: <code>term()</code>) -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <h3 id="backup-2" class="bold_code title-link func-head">  <code>backup(Dest :: <code>term()</code>, Mod :: <code>module()</code>) -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="backup">Activates a new checkpoint covering all Mnesia tables, including the schema, with maximum degree of redundancy, and performs a backup using <code>backup_checkpoint/2/3</code>. The default value of the backup callback module <code>BackupMod</code> is obtained by <code>mnesia:system_info(backup_module)</code>.</p> </div></div></article><article class="func"><h3 id="backup_checkpoint-2" class="bold_code title-link func-head">  <code>backup_checkpoint(Name, Dest) -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <h3 id="backup_checkpoint-3" class="bold_code title-link func-head">  <code>backup_checkpoint(Name, Dest, Mod) -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = Dest = term()</code></div>  <div class="REFTYPES rt-1"><code>Mod = module()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="backup_checkpoint">The tables are backed up to external media using backup module <code>BackupMod</code>. Tables with the local contents property are backed up as they exist on the current node. <code>BackupMod</code> is the default backup callback module obtained by <code>mnesia:system_info(backup_module)</code>. For information about the exact callback interface (the <code>mnesia_backup behavior</code>), see the User's Guide.</p> </div></div></article><article class="func"><h3 id="change_config-2" class="bold_code title-link func-head">  <code>change_config(Config, Value) -&gt; <code><a href="#type-config_result">config_result()</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Config = <a href="#type-config_key">config_key()</a></code></div> <div class="REFTYPES rt-1"><code>Value = <a href="#type-config_value">config_value()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="change_config"><code>Config</code> is to be an atom of the following configuration parameters:</p> <dl> <dt class="title-link"><strong><code>extra_db_nodes</code></strong></dt> <dd> <p><code>Value</code> is a list of nodes that Mnesia is to try to connect to. <code>ReturnValue</code> is those nodes in <code>Value</code> that Mnesia is connected to.</p> <p>Notice that this function must only be used to connect to newly started RAM nodes (N.D.R.S.N.) with an empty schema. If, for example, this function is used after the network has been partitioned, it can lead to inconsistent tables.</p> <p>Notice that Mnesia can be connected to other nodes than those returned in <code>ReturnValue</code>.</p> </dd> <dt class="title-link"><strong><code>dc_dump_limit</code></strong></dt> <dd> <p><code>Value</code> is a number. See the description in <code><a href="#configuration_parameters">Section Configuration Parameters</a></code>. <code>ReturnValue</code> is the new value. Notice that this configuration parameter is not persistent. It is lost when Mnesia has stopped.</p> </dd> </dl> </div></div></article><article class="func"><h3 id="change_table_access_mode-2" class="bold_code title-link func-head">  <code>change_table_access_mode(Tab :: <code><a href="#type-table">table()</a></code>, Mode) -&gt; <code><a href="#type-t_result">t_result</a></code>(ok)</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Mode = read_only | read_write</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="change_table_access_mode"><code>AcccessMode</code> is by default the atom <code>read_write</code> but it can also be set to the atom <code>read_only</code>. If <code>AccessMode</code> is set to <code>read_only</code>, updates to the table cannot be performed. At startup, Mnesia always loads <code>read_only</code> tables locally regardless of when and if Mnesia is terminated on other nodes.</p> </div></div></article><article class="func"><h3 id="change_table_copy_type-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>change_table_copy_type(Tab :: <code><a href="#type-table">table()</a></code>,
 Node :: <code>node()</code>,
 To :: <code><a href="#type-storage_type">storage_type()</a></code>) -&gt;
 <code><a href="#type-t_result">t_result</a></code>(ok)</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="change_table_copy_type">For example:</p> <pre data-language="erlang">mnesia:change_table_copy_type(person, node(), disc_copies)</pre> <p>Transforms the <code>person</code> table from a RAM table into a disc-based table at <code>Node</code>.</p> <p>This function can also be used to change the storage type of the table named <code>schema</code>. The schema table can only have <code>ram_copies</code> or <code>disc_copies</code> as the storage type. If the storage type of the schema is <code>ram_copies</code>, no other table can be disc-resident on that node.</p> </div></div></article><article class="func"><h3 id="change_table_load_order-2" class="bold_code title-link func-head">  <code>change_table_load_order(Tab :: <code><a href="#type-table">table()</a></code>, Order) -&gt; <code><a href="#type-t_result">t_result</a></code>(ok)</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Order = integer() &gt;= 0</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="change_table_load_order">The <code>LoadOrder</code> priority is by default <code>0</code> (zero) but can be set to any integer. The tables with the highest <code>LoadOrder</code> priority are loaded first at startup.</p> </div></div></article><article class="func"><h3 id="change_table_majority-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>change_table_majority(Tab :: <code><a href="#type-table">table()</a></code>, M :: <code>boolean()</code>) -&gt;
 <code><a href="#type-t_result">t_result</a></code>(ok)</code></pre>
<div class="title-since"><span class="since">OTP R14B03</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p><code>Majority</code> must be a boolean. Default is <code>false</code>. When <code>true</code>, a majority of the table replicas must be available for an update to succeed. When used on fragmented tables, <code>Tab</code> must be the base table name. Directly changing the majority setting on individual fragments is not allowed.</p> </div></div></article><article class="func"><h3 id="clear_table-1" class="bold_code title-link func-head">  <code>clear_table(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; <code><a href="#type-t_result">t_result</a></code>(ok)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="clear_table">Deletes all entries in the table <code>Tab</code>.</p> </div></div></article><article class="func"><h3 id="create_schema-1" class="bold_code title-link func-head">  <code>create_schema(Ns :: [<code>node()</code>]) -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="create_schema">Creates a new database on disc. Various files are created in the local Mnesia directory of each node. Notice that the directory must be unique for each node. Two nodes must never share the same directory. If possible, use a local disc device to improve performance.</p> <p><code>mnesia:create_schema/1</code> fails if any of the Erlang nodes given as <code>DiscNodes</code> are not alive, if Mnesia is running on any of the nodes, or if any of the nodes already have a schema. Use <code>mnesia:delete_schema/1</code> to get rid of old faulty schemas.</p> <p>Notice that only nodes with disc are to be included in <code>DiscNodes</code>. Disc-less nodes, that is, nodes where all tables including the schema only resides in RAM, must not be included.</p> </div></div></article><article class="func"><h3 id="create_table-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>create_table(Name :: <code><a href="#type-table">table()</a></code>, Arg :: [<code><a href="#type-create_option">create_option()</a></code>]) -&gt;
 <code><a href="#type-t_result">t_result</a></code>(ok)</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="create_table">Creates a Mnesia table called <code>Name</code> according to argument <code>TabDef</code>. This list must be a list of <code>{Item, Value}</code> tuples, where the following values are allowed:</p> <ul> <li> <p><code>{access_mode, Atom}</code>. The access mode is by default the atom <code>read_write</code> but it can also be set to the atom <code>read_only</code>. If <code>AccessMode</code> is set to <code>read_only</code>, updates to the table cannot be performed.</p> <p>At startup, Mnesia always loads <code>read_only</code> table locally regardless of when and if Mnesia is terminated on other nodes. This argument returns the access mode of the table. The access mode can be <code>read_only</code> or <code>read_write</code>.</p> </li> <li> <p><code>{attributes, AtomList}</code> is a list of the attribute names for the records that are supposed to populate the table. Default is <code>[key, val]</code>. The table must at least have one extra attribute in addition to the key.</p> <p>When accessing single attributes in a record, it is not necessary, or even recommended, to hard code any attribute names as atoms. Use construct <code>record_info(fields, RecordName)</code> instead. It can be used for records of type <code>RecordName</code>.</p> </li> <li> <p><code>{disc_copies, Nodelist}</code>, where <code>Nodelist</code> is a list of the nodes where this table is supposed to have disc copies. If a table replica is of type <code>disc_copies</code>, all write operations on this particular replica of the table are written to disc and to the RAM copy of the table.</p> <p>It is possible to have a replicated table of type <code>disc_copies</code> on one node and another type on another node. Default is <code>[]</code>.</p> </li> <li> <p><code>{disc_only_copies, Nodelist}</code>, where <code>Nodelist</code> is a list of the nodes where this table is supposed to have <code>disc_only_copies</code>. A disc only table replica is kept on disc only and unlike the other replica types, the contents of the replica do not reside in RAM. These replicas are considerably slower than replicas held in RAM.</p> </li> <li> <p><code>{index, Intlist}</code>, where <code>Intlist</code> is a list of attribute names (atoms) or record fields for which Mnesia is to build and maintain an extra index table. The <code>qlc</code> query compiler <strong>may</strong> be able to optimize queries if there are indexes available.</p> </li> <li> <p><code>{load_order, Integer}</code>. The load order priority is by default <code>0</code> (zero) but can be set to any integer. The tables with the highest load order priority are loaded first at startup.</p> </li> <li> <p><code>{majority, Flag}</code>, where <code>Flag</code> must be a boolean. If <code>true</code>, any (non-dirty) update to the table is aborted, unless a majority of the table replicas are available for the commit. When used on a fragmented table, all fragments are given the same majority setting.</p> </li> <li> <p><code>{ram_copies, Nodelist}</code>, where <code>Nodelist</code> is a list of the nodes where this table is supposed to have RAM copies. A table replica of type <code>ram_copies</code> is not written to disc on a per transaction basis. <code>ram_copies</code> replicas can be dumped to disc with the function <code>mnesia:dump_tables(Tabs)</code>. Default value for this attribute is <code>[node()]</code>.</p> </li> <li> <p><code>{record_name, Name}</code>, where <code>Name</code> must be an atom. All records stored in the table must have this name as the first element. It defaults to the same name as the table name.</p> </li> <li> <p><code>{snmp, SnmpStruct}</code>. For a description of <code>SnmpStruct</code>, see <code>mnesia:snmp_open_table/2</code>. If this attribute is present in <code>ArgList</code> to <code>mnesia:create_table/2</code>, the table is immediately accessible by SNMP. Therefore applications that use SNMP to manipulate and control the system can be designed easily, since Mnesia provides a direct mapping between the logical tables that make up an SNMP control application and the physical data that makes up a Mnesia table.</p> </li> <li> <p><code>{storage_properties, [{Backend, Properties}]</code> forwards more properties to the back end storage. <code>Backend</code> can currently be <code>ets</code> or <code>dets</code>. <code>Properties</code> is a list of options sent to the back end storage during table creation. <code>Properties</code> cannot contain properties already used by Mnesia, such as <code>type</code> or <code>named_table</code>.</p> <p>For example:</p> <pre data-language="erlang">mnesia:create_table(table, [{ram_copies, [node()]}, {disc_only_copies, nodes()},
       {storage_properties,
        [{ets, [compressed]}, {dets, [{auto_save, 5000}]} ]}])</pre> </li> <li> <p><code>{type, Type}</code>, where <code>Type</code> must be either of the atoms <code>set</code>, <code>ordered_set</code>, or <code>bag</code>. Default is <code>set</code>. In a <code>set</code>, all records have unique keys. In a <code>bag</code>, several records can have the same key, but the record content is unique. If a non-unique record is stored, the old conflicting records are overwritten.</p> <p>Notice that currently <code>ordered_set</code> is not supported for <code>disc_only_copies</code>.</p> </li> <li> <p><code>{local_content, Bool}</code>, where <code>Bool</code> is <code>true</code> or <code>false</code>. Default is <code>false</code>.</p> </li> </ul> <p>For example, the following call creates the <code>person</code> table (defined earlier) and replicates it on two nodes:</p> <pre data-language="erlang">mnesia:create_table(person,
    [{ram_copies, [N1, N2]},
     {attributes, record_info(fields, person)}]).</pre> <p>If it is required that Mnesia must build and maintain an extra index table on attribute <code>address</code> of all the <code>person</code> records that are inserted in the table, the following code would be issued:</p> <pre data-language="erlang">mnesia:create_table(person,
    [{ram_copies, [N1, N2]},
     {index, [address]},
     {attributes, record_info(fields, person)}]).</pre> <p>The specification of <code>index</code> and <code>attributes</code> can be hard-coded as <code>{index, [2]}</code> and <code>{attributes, [name, age, address, salary, children]}</code>, respectively.</p> <p><code>mnesia:create_table/2</code> writes records into the table <code>schema</code>. This function, and all other schema manipulation functions, are implemented with the normal transaction management system. This guarantees that schema updates are performed on all nodes in an atomic manner.</p> </div></div></article><article class="func"><h3 id="deactivate_checkpoint-1" class="bold_code title-link func-head">  <code>deactivate_checkpoint(Name :: <code>term()</code>) -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="deactivate_checkpoint">The checkpoint is automatically deactivated when some of the tables involved have no retainer attached to them. This can occur when nodes go down or when a replica is deleted. Checkpoints are also deactivated with this function. <code>Name</code> is the name of an active checkpoint.</p> </div></div></article><article class="func"><h3 id="del_table_copy-2" class="bold_code title-link func-head">  <code>del_table_copy(Tab :: <code><a href="#type-table">table()</a></code>, N :: <code>node()</code>) -&gt; <code><a href="#type-t_result">t_result</a></code>(ok)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="del_table_copy">Deletes the replica of table <code>Tab</code> at node <code>Node</code>. When the last replica is deleted with this function, the table disappears entirely.</p> <p>This function can also be used to delete a replica of the table named <code>schema</code>. The Mnesia node is then removed. Notice that Mnesia must be stopped on the node first.</p> </div></div></article><article class="func"><h3 id="del_table_index-2" class="bold_code title-link func-head">  <code>del_table_index(Tab, I) -&gt; <code><a href="#type-t_result">t_result</a></code>(ok)</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>I = <a href="#type-index_attr">index_attr()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="del_table_index">Deletes the index on attribute with name <code>AttrName</code> in a table.</p> </div></div></article><article class="func"><h3 id="delete-1" class="bold_code title-link func-head">  <code>delete(Oid :: {Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>}) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="delete_1">Calls <code>mnesia:delete(Tab, Key, write)</code>.</p> </div></div></article><article class="func"><h3 id="delete-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>delete(Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>, LockKind :: <code><a href="#type-write_locks">write_locks()</a></code>) -&gt;
 ok</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="delete_3">Deletes all records in table <code>Tab</code> with the key <code>Key</code>.</p> <p>The semantics of this function is context-sensitive. For details, see <code>mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code>LockKind</code> in the record. Currently, the lock types <code>write</code> and <code>sticky_write</code> are supported.</p> </div></div></article><article class="func"><h3 id="delete_object-1" class="bold_code title-link func-head">  <code>delete_object(Rec :: <code>tuple()</code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="delete_object_1">Calls <code>mnesia:delete_object(Tab, Record, write)</code>, where <code>Tab</code> is <code>element(1, Record)</code>.</p> </div></div></article><article class="func"><h3 id="delete_object-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>delete_object(Tab :: <code><a href="#type-table">table()</a></code>,
 Rec :: <code>tuple()</code>,
 LockKind :: <code><a href="#type-write_locks">write_locks()</a></code>) -&gt;
 ok</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="delete_object_3">If a table is of type <code>bag</code>, it can sometimes be needed to delete only some of the records with a certain key. This can be done with the function <code>delete_object/3</code>. A complete record must be supplied to this function.</p> <p>The semantics of this function is context-sensitive. For details, see <code>mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code>LockKind</code> on the record. Currently, the lock types <code>write</code> and <code>sticky_write</code> are supported.</p> </div></div></article><article class="func"><h3 id="delete_schema-1" class="bold_code title-link func-head">  <code>delete_schema(Ns :: [<code>node()</code>]) -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="delete_schema">Deletes a database created with <code>mnesia:create_schema/1</code>. <code>mnesia:delete_schema/1</code> fails if any of the Erlang nodes given as <code>DiscNodes</code> are not alive, or if Mnesia is running on any of the nodes.</p> <p>After the database is deleted, it can still be possible to start Mnesia as a disc-less node. This depends on how configuration parameter <code>schema_location</code> is set.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Use this function with extreme caution, as it makes existing persistent data obsolete. Think twice before using it.</p> </div> </div> </div></div></article><article class="func"><h3 id="delete_table-1" class="bold_code title-link func-head">  <code>delete_table(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; <code><a href="#type-t_result">t_result</a></code>(ok)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="delete_table">Permanently deletes all replicas of table <code>Tab</code>.</p> </div></div></article><article class="func"><h3 id="dirty_all_keys-1" class="bold_code title-link func-head">  <code>dirty_all_keys(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; [Key :: <code>term()</code>]</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="delete_all_keys">Dirty equivalent of the function <code>mnesia:all_keys/1</code>.</p> </div></div></article><article class="func"><h3 id="dirty_delete-1" class="bold_code title-link func-head">  <code>dirty_delete(Oid :: {Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>}) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_delete">Calls <code>mnesia:dirty_delete(Tab, Key)</code>.</p> </div></div></article><article class="func"><h3 id="dirty_delete-2" class="bold_code title-link func-head">  <code>dirty_delete(Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Dirty equivalent of the function <code>mnesia:delete/3</code>.</p> </div></div></article><article class="func"><h3 id="dirty_delete_object-1" class="bold_code title-link func-head">  <code>dirty_delete_object(Record :: <code>tuple()</code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_delete_object_1">Calls <code>mnesia:dirty_delete_object(Tab, Record)</code>, where <code>Tab</code> is <code>element(1, Record)</code>.</p> </div></div></article><article class="func"><h3 id="dirty_delete_object-2" class="bold_code title-link func-head">  <code>dirty_delete_object(Tab :: <code><a href="#type-table">table()</a></code>, Record :: <code>tuple()</code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Dirty equivalent of the function <code>mnesia:delete_object/3</code>.</p> </div></div></article><article class="func"><h3 id="dirty_first-1" class="bold_code title-link func-head">  <code>dirty_first(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; Key :: <code>term()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_first">Records in <code>set</code> or <code>bag</code> tables are not ordered. However, there is an ordering of the records that is unknown to the user. Therefore, a table can be traversed by this function with the function <code>mnesia:dirty_next/2</code>. </p> <p>If there are no records in the table, this function returns the atom <code>'$end_of_table'</code>. It is therefore highly undesirable, but not disallowed, to use this atom as the key for any user records.</p> </div></div></article><article class="func"><h3 id="dirty_index_match_object-2" class="bold_code title-link func-head">  <code>dirty_index_match_object(Pattern, Attr) -&gt; [Record]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pattern = tuple()</code></div> <div class="REFTYPES rt-1"><code>Attr = <a href="#type-index_attr">index_attr()</a></code></div> <div class="REFTYPES rt-1"><code>Record = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_index_match_object_2">Starts <code>mnesia:dirty_index_match_object(Tab, Pattern, Pos)</code>, where <code>Tab</code> is <code>element(1, Pattern)</code>.</p> </div></div></article><article class="func"><h3 id="dirty_index_match_object-3" class="bold_code title-link func-head">  <code>dirty_index_match_object(Tab, Pattern, Attr) -&gt; [Record]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>Pattern = tuple()</code></div> <div class="REFTYPES rt-1"><code>Attr = <a href="#type-index_attr">index_attr()</a></code></div> <div class="REFTYPES rt-1"><code>Record = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Dirty equivalent of the function <code>mnesia:index_match_object/4</code>.</p> </div></div></article><article class="func"><h3 id="dirty_index_read-3" class="bold_code title-link func-head">  <code>dirty_index_read(Tab, Key, Attr) -&gt; [Record]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>Key = term()</code></div> <div class="REFTYPES rt-1"><code>Attr = <a href="#type-index_attr">index_attr()</a></code></div> <div class="REFTYPES rt-1"><code>Record = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_index_read">Dirty equivalent of the function <code>mnesia:index_read/3</code>.</p> </div></div></article><article class="func"><h3 id="dirty_last-1" class="bold_code title-link func-head">  <code>dirty_last(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; Key :: <code>term()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_last">Works exactly like <code>mnesia:dirty_first/1</code> but returns the last object in Erlang term order for the <code>ordered_set</code> table type. For all other table types, <code>mnesia:dirty_first/1</code> and <code>mnesia:dirty_last/1</code> are synonyms.</p> </div></div></article><article class="func"><h3 id="dirty_match_object-1" class="bold_code title-link func-head">  <code>dirty_match_object(Pattern :: <code>tuple()</code>) -&gt; [Record :: <code>tuple()</code>]</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_match_object_1">Calls <code>mnesia:dirty_match_object(Tab, Pattern)</code>, where <code>Tab</code> is <code>element(1, Pattern)</code>.</p> </div></div></article><article class="func"><h3 id="dirty_match_object-2" class="bold_code title-link func-head">  <code>dirty_match_object(Tab, Pattern) -&gt; [Record]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>Pattern = Record = tuple()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Dirty equivalent of the function <code>mnesia:match_object/3</code>.</p> </div></div></article><article class="func"><h3 id="dirty_next-2" class="bold_code title-link func-head">  <code>dirty_next(Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>) -&gt; NextKey :: <code>term()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_next">Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key <code>'$end_of_table'</code> is returned. Otherwise, the function returns a key that can be used to read the actual record. The behavior is undefined if another Erlang process performs write operations on the table while it is being traversed with the function <code>mnesia:dirty_next/2</code>.</p> </div></div></article><article class="func"><h3 id="dirty_prev-2" class="bold_code title-link func-head">  <code>dirty_prev(Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>) -&gt; PrevKey :: <code>term()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_prev">Works exactly like <code>mnesia:dirty_next/2</code> but returns the previous object in Erlang term order for the <code>ordered_set</code> table type. For all other table types, <code>mnesia:dirty_next/2</code> and <code>mnesia:dirty_prev/2</code> are synonyms.</p> </div></div></article><article class="func"><h3 id="dirty_read-1" class="bold_code title-link func-head">  <code>dirty_read(Oid :: {Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>}) -&gt; [<code>tuple()</code>]</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_read">Calls <code>mnesia:dirty_read(Tab, Key)</code>.</p> </div></div></article><article class="func"><h3 id="dirty_read-2" class="bold_code title-link func-head">  <code>dirty_read(Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>) -&gt; [<code>tuple()</code>]</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Dirty equivalent of the function <code>mnesia:read/3</code>.</p> </div></div></article><article class="func"><h3 id="dirty_select-2" class="bold_code title-link func-head">  <code>dirty_select(Tab, Spec) -&gt; [Match]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>Spec = ets:match_spec()</code></div> <div class="REFTYPES rt-1"><code>Match = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_select">Dirty equivalent of the function <code>mnesia:select/2</code>.</p> </div></div></article><article class="func"><h3 id="dirty_update_counter-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>dirty_update_counter(Counter :: {Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>},
 Incr :: <code>integer()</code>) -&gt;
 NewVal :: <code>integer()</code></code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_update_counter">Calls <code>mnesia:dirty_update_counter(Tab, Key, Incr)</code>.</p> </div></div></article><article class="func"><h3 id="dirty_update_counter-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>dirty_update_counter(Tab :: <code><a href="#type-table">table()</a></code>,
 Key :: <code>term()</code>,
 Incr :: <code>integer()</code>) -&gt;
 NewVal :: <code>integer()</code></code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Mnesia has no special counter records. However, records of the form <code>{Tab, Key, Integer}</code> can be used as (possibly disc-resident) counters when <code>Tab</code> is a <code>set</code>. This function updates a counter with a positive or negative number. However, counters can never become less than zero. There are two significant differences between this function and the action of first reading the record, performing the arithmetic, and then writing the record:</p> <ul> <li>It is much more efficient. </li> <li> <code>mnesia:dirty_update_counter/3</code> is performed as an atomic operation although it is not protected by a transaction. </li> </ul> <p>If two processes perform <code>mnesia:dirty_update_counter/3</code> simultaneously, both updates take effect without the risk of losing one of the updates. The new value <code>NewVal</code> of the counter is returned.</p> <p>If <code>Key</code> does not exist, a new record is created with value <code>Incr</code> if it is larger than 0, otherwise it is set to 0.</p> </div></div></article><article class="func"><h3 id="dirty_write-1" class="bold_code title-link func-head">  <code>dirty_write(Record :: <code>tuple()</code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dirty_write_1">Calls <code>mnesia:dirty_write(Tab, Record)</code>, where <code>Tab</code> is <code>element(1, Record)</code>.</p> </div></div></article><article class="func"><h3 id="dirty_write-2" class="bold_code title-link func-head">  <code>dirty_write(Tab :: <code><a href="#type-table">table()</a></code>, Record :: <code>tuple()</code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Dirty equivalent of the function <code>mnesia:write/3</code>.</p> </div></div></article><article class="func"><h3 id="dump_log-0" class="bold_code title-link func-head">  <code>dump_log() -&gt; dumped</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dump_log">Performs a user-initiated dump of the local log file. This is usually not necessary, as Mnesia by default manages this automatically. See configuration parameters <code><a href="#dump_log_time_threshold">dump_log_time_threshold</a></code> and <code><a href="#dump_log_write_threshold">dump_log_write_threshold</a></code>. </p> </div></div></article><article class="func"><h3 id="dump_tables-1" class="bold_code title-link func-head">  <code>dump_tables(Tabs :: [Tab :: <code><a href="#type-table">table()</a></code>]) -&gt; <code><a href="#type-t_result">t_result</a></code>(ok)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dump_tables">Dumps a set of <code>ram_copies</code> tables to disc. The next time the system is started, these tables are initiated with the data found in the files that are the result of this dump. None of the tables can have disc-resident replicas.</p> </div></div></article><article class="func"><h3 id="dump_to_textfile-1" class="bold_code title-link func-head">  <code>dump_to_textfile(File :: <code>file:filename()</code>) -&gt; <code><a href="#type-result">result()</a></code> | error</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="dump_to_textfile">Dumps all local tables of a Mnesia system into a text file, which can be edited (by a normal text editor) and then be reloaded with <code>mnesia:load_textfile/1</code>. Only use this function for educational purposes. Use other functions to deal with real backups.</p> </div></div></article><article class="func"><h3 id="error_description-1" class="bold_code title-link func-head">  <code>error_description(Error :: <code>term()</code>) -&gt; <code>string()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="error_description">All Mnesia transactions, including all the schema update functions, either return value <code>{atomic, Val}</code> or the tuple <code>{aborted, Reason}</code>. <code>Reason</code> can be either of the atoms in the following list. The function <code>error_description/1</code> returns a descriptive string that describes the error.</p> <ul> <li> <code>nested_transaction</code>. Nested transactions are not allowed in this context. </li> <li> <code>badarg</code>. Bad or invalid argument, possibly bad type. </li> <li> <code>no_transaction</code>. Operation not allowed outside transactions. </li> <li> <code>combine_error</code>. Table options illegally combined. </li> <li> <code>bad_index</code>. Index already exists, or was out of bounds. </li> <li> <code>already_exists</code>. Schema option to be activated is already on. </li> <li> <code>index_exists</code>. Some operations cannot be performed on tables with an index. </li> <li> <code>no_exists</code>. Tried to perform operation on non-existing (not-alive) item. </li> <li> <code>system_limit</code>. A system limit was exhausted. </li> <li> <code>mnesia_down</code>. A transaction involves records on a remote node, which became unavailable before the transaction was completed. Records are no longer available elsewhere in the network. </li> <li> <code>not_a_db_node</code>. A node was mentioned that does not exist in the schema. </li> <li> <code>bad_type</code>. Bad type specified in argument. </li> <li> <code>node_not_running</code>. Node is not running. </li> <li> <code>truncated_binary_file</code>. Truncated binary in file. </li> <li> <code>active</code>. Some delete operations require that all active records are removed. </li> <li> <code>illegal</code>. Operation not supported on this record. </li> </ul> <p><code>Error</code> can be <code>Reason</code>, <code>{error, Reason}</code>, or <code>{aborted, Reason}</code>. <code>Reason</code> can be an atom or a tuple with <code>Reason</code> as an atom in the first field.</p> <p>The following examples illustrate a function that returns an error, and the method to retrieve more detailed error information:</p> <ul> <li>The function <code><a href="#create_table-2">mnesia:create_table(bar, [{attributes, 3.14}])</a></code> returns the tuple <code>{aborted,Reason}</code>, where <code>Reason</code> is the tuple <code>{bad_type,bar,3.14000}</code>.</li> <li>The function <code><a href="#error_description-1">mnesia:error_description(Reason)</a></code> returns the term <code>{"Bad type on some provided arguments",bar,3.14000}</code>, which is an error description suitable for display.</li> </ul> </div></div></article><article class="func"><h3 id="ets-1" class="bold_code title-link func-head">  <code>ets(Fun) -&gt; Res | <code>no_return()</code></code> </h3> <h3 id="ets-2" class="bold_code title-link func-head">  <code>ets(Fun, Args :: [Arg :: <code>term()</code>]) -&gt; Res | <code>no_return()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((...) -&gt; Res)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="ets">Calls the <code>Fun</code> in a raw context that is not protected by a transaction. The Mnesia function call is performed in the <code>Fun</code> and performed directly on the local ETS tables on the assumption that the local storage type is <code>ram_copies</code> and the tables are not replicated to other nodes. Subscriptions are not triggered and checkpoints are not updated, but it is extremely fast. This function can also be applied to <code>disc_copies</code> tables if all operations are read only. For details, see <code>mnesia:activity/4</code> and the User's Guide.</p> <p>Notice that calling (nesting) a <code>mnesia:ets</code> inside a transaction-context inherits the transaction semantics.</p> </div></div></article><article class="func"><h3 id="first-1" class="bold_code title-link func-head">  <code>first(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; Key :: <code>term()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="first">Records in <code>set</code> or <code>bag</code> tables are not ordered. However, there is an ordering of the records that is unknown to the user. A table can therefore be traversed by this function with the function <code>mnesia:next/2</code>.</p> <p>If there are no records in the table, this function returns the atom <code>'$end_of_table'</code>. It is therefore highly undesirable, but not disallowed, to use this atom as the key for any user records.</p> </div></div></article><article class="func"><h3 id="foldl-3" class="bold_code title-link func-head">  <code>foldl(Fun, Acc0, Tab :: <code><a href="#type-table">table()</a></code>) -&gt; Acc</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((Record :: tuple(), Acc0) -&gt; Acc)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="foldl">Iterates over the table <code>Table</code> and calls <code>Function(Record, NewAcc)</code> for each <code>Record</code> in the table. The term returned from <code>Function</code> is used as the second argument in the next call to <code>Function</code>.</p> <p><code>foldl</code> returns the same term as the last call to <code>Function</code> returned.</p> </div></div></article><article class="func"><h3 id="foldr-3" class="bold_code title-link func-head">  <code>foldr(Fun, Acc0, Tab :: <code><a href="#type-table">table()</a></code>) -&gt; Acc</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((Record :: tuple(), Acc0) -&gt; Acc)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="foldr">Works exactly like <code>foldl/3</code> but iterates the table in the opposite order for the <code>ordered_set</code> table type. For all other table types, <code>foldr/3</code> and <code>foldl/3</code> are synonyms.</p> </div></div></article><article class="func"><h3 id="force_load_table-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>force_load_table(Tab :: <code><a href="#type-table">table()</a></code>) -&gt;
 yes | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="force_load_table">The Mnesia algorithm for table load can lead to a situation where a table cannot be loaded. This situation occurs when a node is started and Mnesia concludes, or suspects, that another copy of the table was active after this local copy became inactive because of a system crash.</p> <p>If this situation is not acceptable, this function can be used to override the strategy of the Mnesia table load algorithm. This can lead to a situation where some transaction effects are lost with an inconsistent database as result, but for some applications high availability is more important than consistent data.</p> </div></div></article><article class="func"><h3 id="index_match_object-2" class="bold_code title-link func-head">  <code>index_match_object(Pattern, Attr) -&gt; [Record]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pattern = tuple()</code></div> <div class="REFTYPES rt-1"><code>Attr = <a href="#type-index_attr">index_attr()</a></code></div> <div class="REFTYPES rt-1"><code>Record = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="index_match_object_2">Starts <code>mnesia:index_match_object(Tab, Pattern, Pos, read)</code>, where <code>Tab</code> is <code>element(1, Pattern)</code>.</p> </div></div></article><article class="func"><h3 id="index_match_object-4" class="bold_code title-link func-head">  <code>index_match_object(Tab, Pattern, Attr, LockKind) -&gt; [Record]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>Pattern = tuple()</code></div> <div class="REFTYPES rt-1"><code>Attr = <a href="#type-index_attr">index_attr()</a></code></div> <div class="REFTYPES rt-1"><code>LockKind = <a href="#type-lock_kind">lock_kind()</a></code></div> <div class="REFTYPES rt-1"><code>Record = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="index_match_object_4">In a manner similar to the function <code>mnesia:index_read/3</code>, any index information can be used when trying to match records. This function takes a pattern that obeys the same rules as the function <code>mnesia:match_object/3</code>, except that this function requires the following conditions:</p> <ul> <li> <p>The table <code>Tab</code> must have an index on position <code>Pos</code>.</p> </li> <li> <p>The element in position <code>Pos</code> in <code>Pattern</code> must be bound. <code>Pos</code> is an integer (<code>#record.Field</code>) or an attribute name.</p> </li> </ul> <p>The two index search functions described here are automatically started when searching tables with <code>qlc</code> list comprehensions and also when using the low-level <code>mnesia:[dirty_]match_object</code> functions.</p> <p>The semantics of this function is context-sensitive. For details, see <code>mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code>LockKind</code> on the entire table or on a single record. Currently, the lock type <code>read</code> is supported.</p> </div></div></article><article class="func"><h3 id="index_read-3" class="bold_code title-link func-head">  <code>index_read(Tab, Key, Attr) -&gt; [Record]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>Key = term()</code></div> <div class="REFTYPES rt-1"><code>Attr = <a href="#type-index_attr">index_attr()</a></code></div> <div class="REFTYPES rt-1"><code>Record = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="index_read">Assume that there is an index on position <code>Pos</code> for a certain record type. This function can be used to read the records without knowing the actual key for the record. For example, with an index in position 1 of table <code>person</code>, the call <code>mnesia:index_read(person, 36, #person.age)</code> returns a list of all persons with age 36. <code>Pos</code> can also be an attribute name (atom), but if the notation <code>mnesia:index_read(person, 36, age)</code> is used, the field position is searched for in runtime, for each call.</p> <p>The semantics of this function is context-sensitive. For details, see <code>mnesia:activity/4</code>. In transaction-context, it acquires a read lock on the entire table.</p> </div></div></article><article class="func"><h3 id="info-0" class="bold_code title-link func-head">  <code>info() -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="info">Prints system information on the terminal. This function can be used even if Mnesia is not started. However, more information is displayed if Mnesia is started.</p> </div></div></article><article class="func"><h3 id="install_fallback-1" class="bold_code title-link func-head">  <code>install_fallback(Src :: <code>term()</code>) -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="install_fallback_1">Calls <code>mnesia:install_fallback(Opaque, Args)</code>, where <code>Args</code> is <code>[{scope, global}]</code>.</p> </div></div></article><article class="func"><h3 id="install_fallback-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>install_fallback(Src :: <code>term()</code>, Mod :: <code>module()</code> | [Opt]) -&gt;
 <code><a href="#type-result">result()</a></code></code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Opt = Module | Scope | Dir</code></div> <div class="REFTYPES rt-1"><code>Module = {module, Mod :: module()}</code></div> <div class="REFTYPES rt-1"><code>Scope = {scope, global | local}</code></div> <div class="REFTYPES rt-1"><code>Dir = {mnesia_dir, Dir :: string()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Installs a backup as fallback. The fallback is used to restore the database at the next startup. Installation of fallbacks requires Erlang to be operational on all the involved nodes, but it does not matter if Mnesia is running or not. The installation of the fallback fails if the local node is not one of the disc-resident nodes in the backup.</p> <p><code>Args</code> is a list of the following tuples:</p> <ul> <li> <p><code>{module, BackupMod}</code>. All accesses of the backup media are performed through a callback module named <code>BackupMod</code>. Argument <code>Opaque</code> is forwarded to the callback module, which can interpret it as it wishes. The default callback module is called <code>mnesia_backup</code> and it interprets argument <code>Opaque</code> as a local filename. The default for this module is also configurable through configuration parameter <code>-mnesia mnesia_backup</code>.</p> </li> <li> <p><code>{scope, Scope}</code>. The <code>Scope</code> of a fallback is either <code>global</code> for the entire database or <code>local</code> for one node. By default, the installation of a fallback is a global operation, which either is performed on all nodes with a disc-resident schema or none. Which nodes that are disc-resident is determined from the schema information in the backup.</p> <p>If <code>Scope</code> of the operation is <code>local</code>, the fallback is only installed on the local node.</p> </li> <li> <p><code>{mnesia_dir, AlternateDir}</code>. This argument is only valid if the scope of the installation is <code>local</code>. Normally the installation of a fallback is targeted to the Mnesia directory, as configured with configuration parameter <code>-mnesia dir</code>. But by explicitly supplying an <code>AlternateDir</code>, the fallback is installed there regardless of the Mnesia directory configuration parameter setting. After installation of a fallback on an alternative Mnesia directory, that directory is fully prepared for use as an active Mnesia directory.</p> <p>This is a dangerous feature that must be used with care. By unintentional mixing of directories, you can easily end up with an inconsistent database, if the same backup is installed on more than one directory.</p> </li> </ul> </div></div></article><article class="func"><h3 id="is_transaction-0" class="bold_code title-link func-head">  <code>is_transaction() -&gt; <code>boolean()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="is_transaction">When this function is executed inside a transaction-context, it returns <code>true</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="last-1" class="bold_code title-link func-head">  <code>last(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; Key :: <code>term()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Works exactly like <code>mnesia:first/1</code>, but returns the last object in Erlang term order for the <code>ordered_set</code> table type. For all other table types, <code>mnesia:first/1</code> and <code>mnesia:last/1</code> are synonyms.</p> </div></div></article><article class="func"><h3 id="load_textfile-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>load_textfile(File :: <code>file:filename()</code>) -&gt;
 <code><a href="#type-t_result">t_result</a></code>(ok) | {error, <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="load_textfile">Loads a series of definitions and data found in the text file (generated with <code>mnesia:dump_to_textfile/1</code>) into Mnesia. This function also starts Mnesia and possibly creates a new schema. This function is intended for educational purposes only. It is recommended to use other functions to deal with real backups.</p> </div></div></article><article class="func"><h3 id="lock-2" class="bold_code title-link func-head">  <code>lock(LockItem, LockKind) -&gt; <code>list()</code> | <code>tuple()</code> | <code>no_return()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><pre><code>LockItem = 
 {record, <a href="#type-table">table()</a>, Key :: term()} |
 {table, <a href="#type-table">table()</a>} |
 {global, Key :: term(), MnesiaNodes :: [node()]}</code></pre></div> <div class="REFTYPES rt-1"><code>LockKind = <a href="#type-lock_kind">lock_kind()</a> | load</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="lock">Write locks are normally acquired on all nodes where a replica of the table resides (and is active). Read locks are acquired on one node (the local node if a local replica exists). Most of the context-sensitive access functions acquire an implicit lock if they are started in a transaction-context. The granularity of a lock can either be a single record or an entire table.</p> <p>The normal use is to call the function without checking the return value, as it exits if it fails and the transaction is restarted by the transaction manager. It returns all the locked nodes if a write lock is acquired and <code>ok</code> if it was a read lock.</p> <p>The function <code>mnesia:lock/2</code> is intended to support explicit locking on tables, but is also intended for situations when locks need to be acquired regardless of how tables are replicated. Currently, two kinds of <code>LockKind</code> are supported:</p> <dl> <dt class="title-link"><strong><code>write</code></strong></dt> <dd> <p>Write locks are exclusive. This means that if one transaction manages to acquire a write lock on an item, no other transaction can acquire any kind of lock on the same item.</p> </dd> <dt class="title-link"><strong><code>read</code></strong></dt> <dd> <p>Read locks can be shared. This means that if one transaction manages to acquire a read lock on an item, other transactions can also acquire a read lock on the same item. However, if someone has a read lock, no one can acquire a write lock at the same item. If someone has a write lock, no one can acquire either a read lock or a write lock at the same item.</p> </dd> </dl> <p>Conflicting lock requests are automatically queued if there is no risk of a deadlock. Otherwise the transaction must be terminated and executed again. Mnesia does this automatically as long as the upper limit of the maximum <code>retries</code> is not reached. For details, see <code>mnesia:transaction/3</code>.</p> <p>For the sake of completeness, sticky write locks are also described here even if a sticky write lock is not supported by this function:</p> <dl> <dt class="title-link"><strong><code>sticky_write</code></strong></dt> <dd> <p>Sticky write locks are a mechanism that can be used to optimize write lock acquisition. If your application uses replicated tables mainly for fault tolerance (as opposed to read access optimization purpose), sticky locks can be the best option available.</p> <p>When a sticky write lock is acquired, all nodes are informed which node is locked. Then, sticky lock requests from the same node are performed as a local operation without any communication with other nodes. The sticky lock lingers on the node even after the transaction ends. For details, see the User's Guide.</p> </dd> </dl> <p>Currently, this function supports two kinds of <code>LockItem</code>:</p> <dl> <dt class="title-link"><strong><code>{table, Tab}</code></strong></dt> <dd> <p>This acquires a lock of type <code>LockKind</code> on the entire table <code>Tab</code>.</p> </dd> <dt class="title-link"><strong><code>{global, GlobalKey, Nodes}</code></strong></dt> <dd> <p>This acquires a lock of type <code>LockKind</code> on the global resource <code>GlobalKey</code>. The lock is acquired on all active nodes in the <code>Nodes</code> list.</p> </dd> </dl> <p>Locks are released when the outermost transaction ends.</p> <p>The semantics of this function is context-sensitive. For details, see <code>mnesia:activity/4</code>. In transaction-context, it acquires locks, otherwise it ignores the request.</p> </div></div></article><article class="func"><h3 id="match_object-1" class="bold_code title-link func-head">  <code>match_object(Pattern :: <code>tuple()</code>) -&gt; [Record :: <code>tuple()</code>]</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="match_object_1">Calls <code>mnesia:match_object(Tab, Pattern, read)</code>, where <code>Tab</code> is <code>element(1, Pattern)</code>.</p> </div></div></article><article class="func"><h3 id="match_object-3" class="bold_code title-link func-head">  <code>match_object(Tab, Pattern, LockKind) -&gt; [Record]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>Pattern = tuple()</code></div> <div class="REFTYPES rt-1"><code>LockKind = <a href="#type-lock_kind">lock_kind()</a></code></div> <div class="REFTYPES rt-1"><code>Record = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="match_object_3">Takes a pattern with "don't care" variables denoted as a <code>'_'</code> parameter. This function returns a list of records that matched the pattern. Since the second element of a record in a table is considered to be the key for the record, the performance of this function depends on whether this key is bound or not.</p> <p>For example, the call <code>mnesia:match_object(person, {person, '_', 36, '_', '_'}, read)</code> returns a list of all person records with an <code>age</code> field of 36.</p> <p>The function <code>mnesia:match_object/3</code> automatically uses indexes if these exist. However, no heuristics are performed to select the best index.</p> <p>The semantics of this function is context-sensitive. For details, see <code>mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code>LockKind</code> on the entire table or a single record. Currently, the lock type <code>read</code> is supported.</p> </div></div></article><article class="func"><h3 id="move_table_copy-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>move_table_copy(Tab :: <code><a href="#type-table">table()</a></code>, From :: <code>node()</code>, To :: <code>node()</code>) -&gt;
 <code><a href="#type-t_result">t_result</a></code>(ok)</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="move_table_copy">Moves the copy of table <code>Tab</code> from node <code>From</code> to node <code>To</code>.</p> <p>The storage type is preserved. For example, a RAM table moved from one node remains a RAM on the new node. Other transactions can still read and write in the table while it is being moved.</p> <p>This function cannot be used on <code>local_content</code> tables.</p> </div></div></article><article class="func"><h3 id="next-2" class="bold_code title-link func-head">  <code>next(Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>) -&gt; NextKey :: <code>term()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="next">Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key <code>'$end_of_table'</code> is returned. Otherwise the function returns a key that can be used to read the actual record.</p> </div></div></article><article class="func"><h3 id="prev-2" class="bold_code title-link func-head">  <code>prev(Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>) -&gt; PrevKey :: <code>term()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Works exactly like <code>mnesia:next/2</code>, but returns the previous object in Erlang term order for the <code>ordered_set</code> table type. For all other table types, <code>mnesia:next/2</code> and <code>mnesia:prev/2</code> are synonyms.</p> </div></div></article><article class="func"><h3 id="read-1" class="bold_code title-link func-head">  <code>read(Oid :: {Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>}) -&gt; [<code>tuple()</code>]</code> </h3> <h3 id="read-2" class="bold_code title-link func-head">  <code>read(Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>) -&gt; [<code>tuple()</code>]</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="read_2">Calls function <code>mnesia:read(Tab, Key, read)</code>.</p> </div></div></article><article class="func"><h3 id="read-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>read(Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>, LockKind :: <code><a href="#type-lock_kind">lock_kind()</a></code>) -&gt;
 [<code>tuple()</code>]</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="read_3">Reads all records from table <code>Tab</code> with key <code>Key</code>. This function has the same semantics regardless of the location of <code>Tab</code>. If the table is of type <code>bag</code>, the function <code>mnesia:read(Tab, Key)</code> can return an arbitrarily long list. If the table is of type <code>set</code>, the list is either of length 1, or <code>[]</code>.</p> <p>The semantics of this function is context-sensitive. For details, see <code>mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code>LockKind</code>. Currently, the lock types <code>read</code>, <code>write</code>, and <code>sticky_write</code> are supported.</p> <p>If the user wants to update the record, it is more efficient to use <code>write/sticky_write</code> as the <code>LockKind</code>. If majority checking is active on the table, it is checked as soon as a write lock is attempted. This can be used to end quickly if the majority condition is not met.</p> </div></div></article><article class="func"><h3 id="read_lock_table-1" class="bold_code title-link func-head">  <code>read_lock_table(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="read_lock_table">Calls the function <code>mnesia:lock({table, Tab}, read)</code>.</p> </div></div></article><article class="func"><h3 id="report_event-1" class="bold_code title-link func-head">  <code>report_event(Event :: <code>term()</code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="report_event">When tracing a system of Mnesia applications it is useful to be able to interleave Mnesia own events with application-related events that give information about the application context.</p> <p>Whenever the application begins a new and demanding Mnesia task, or if it enters a new interesting phase in its execution, it can be a good idea to use <code>mnesia:report_event/1</code>. <code>Event</code> can be any term and generates a <code>{mnesia_user, Event}</code> event for any processes that subscribe to Mnesia system events.</p> </div></div></article><article class="func"><h3 id="restore-2" class="bold_code title-link func-head">  <code>restore(Src :: <code>term()</code>, Args :: [Arg]) -&gt; <code><a href="#type-t_result">t_result</a></code>([<code><a href="#type-table">table()</a></code>])</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Op = skip_tables | clear_tables | keep_tables | restore_tables</code></div> <div class="REFTYPES rt-1"><code>Arg = {module, module()} | {Op, [<a href="#type-table">table()</a>]} | {default_op, Op}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="restore">With this function, tables can be restored online from a backup without restarting Mnesia. <code>Opaque</code> is forwarded to the backup module. <code>Args</code> is a list of the following tuples:</p> <ul> <li> <code>{module,BackupMod}</code>. The backup module <code>BackupMod</code> is used to access the backup media. If omitted, the default backup module is used. </li> <li> <code>{skip_tables, TabList}</code>, where <code>TabList</code> is a list of tables that is not to be read from the backup. </li> <li> <code>{clear_tables, TabList}</code>, where <code>TabList</code> is a list of tables that is to be cleared before the records from the backup are inserted. That is, all records in the tables are deleted before the tables are restored. Schema information about the tables is not cleared or read from the backup. </li> <li> <code>{keep_tables, TabList}</code>, where <code>TabList</code> is a list of tables that is not to be cleared before the records from the backup are inserted. That is, the records in the backup are added to the records in the table. Schema information about the tables is not cleared or read from the backup. </li> <li> <code>{recreate_tables, TabList}</code>, where <code>TabList</code> is a list of tables that is to be recreated before the records from the backup are inserted. The tables are first deleted and then created with the schema information from the backup. All the nodes in the backup need to be operational. </li> <li> <code>{default_op, Operation}</code>, where <code>Operation</code> is either of the operations <code>skip_tables</code>, <code>clear_tables</code>, <code>keep_tables</code>, or <code>recreate_tables</code>. The default operation specifies which operation that is to be used on tables from the backup that is not specified in any of the mentioned lists. If omitted, operation <code>clear_tables</code> is used. </li> </ul> <p>The affected tables are write-locked during the restoration. However, regardless of the lock conflicts caused by this, the applications can continue to do their work while the restoration is being performed. The restoration is performed as one single transaction.</p> <p>If the database is huge, it it not always possible to restore it online. In such cases, restore the old database by installing a fallback and then restart.</p> </div></div></article><article class="func"><h3 id="s_delete-1" class="bold_code title-link func-head">  <code>s_delete(Oid :: {Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>}) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="s_delete">Calls the function <code>mnesia:delete(Tab, Key, sticky_write)</code></p> </div></div></article><article class="func"><h3 id="s_delete_object-1" class="bold_code title-link func-head">  <code>s_delete_object(Rec :: <code>tuple()</code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="s_delete_object">Calls the function <code>mnesia:delete_object(Tab, Record, sticky_write)</code>, where <code>Tab</code> is <code>element(1, Record)</code>.</p> </div></div></article><article class="func"><h3 id="s_write-1" class="bold_code title-link func-head">  <code>s_write(Record :: <code>tuple()</code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="s_write">Calls the function <code>mnesia:write(Tab, Record, sticky_write)</code>, where <code>Tab</code> is <code>element(1, Record)</code>.</p> </div></div></article><article class="func"><h3 id="schema-0" class="bold_code title-link func-head">  <code>schema() -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Prints information about all table definitions on the terminal.</p> </div></div></article><article class="func"><h3 id="schema-1" class="bold_code title-link func-head">  <code>schema(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Prints information about one table definition on the terminal.</p> </div></div></article><article class="func"><h3 id="select-2" class="bold_code title-link func-head">  <code>select(Tab, Spec) -&gt; [Match]</code> </h3> <h3 id="select-3" class="bold_code title-link func-head">  <code>select(Tab, Spec, LockKind) -&gt; [Match]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>Spec = ets:match_spec()</code></div> <div class="REFTYPES rt-1"><code>Match = term()</code></div> <div class="REFTYPES rt-1"><code>LockKind = <a href="#type-lock_kind">lock_kind()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="select_2_3">Matches the objects in table <code>Tab</code> using a <code>match_spec</code> as described in the <code>ets:select/3</code>. Optionally a lock <code>read</code> or <code>write</code> can be given as the third argument. Default is <code>read</code>. The return value depends on <code>MatchSpec</code>.</p> <p>Notice that for best performance, <code>select</code> is to be used before any modifying operations are done on that table in the same transaction. That is, do not use <code>write</code> or <code>delete</code> before a <code>select</code>.</p> <p>In its simplest forms, the <code>match_spec</code> look as follows:</p> <ul> <li><code>MatchSpec = [MatchFunction]</code></li> <li><code>MatchFunction = {MatchHead, [Guard], [Result]}</code></li> <li><code>MatchHead = tuple() | record()</code></li> <li><code>Guard = {"Guardtest name", ...}</code></li> <li><code>Result = "Term construct"</code></li> </ul> <p>For a complete description of <code>select</code>, see the <code>ERTS</code> User's Guide and the <code>ets</code> manual page in STDLIB.</p> <p>For example, to find the names of all male persons older than 30 in table <code>Tab</code>:</p> <pre data-language="erlang">MatchHead = #person{name='$1', sex=male, age='$2', _='_'},
Guard = {'&gt;', '$2', 30},
Result = '$1',
mnesia:select(Tab,[{MatchHead, [Guard], [Result]}]),</pre> </div></div></article><article class="func"><h3 id="select-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>select(Tab, Spec, N, LockKind) -&gt;
 {[Match], Cont} | '$end_of_table'</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tab = <a href="#type-table">table()</a></code></div> <div class="REFTYPES rt-1"><code>Spec = ets:match_spec()</code></div> <div class="REFTYPES rt-1"><code>Match = term()</code></div> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>LockKind = <a href="#type-lock_kind">lock_kind()</a></code></div> <div class="REFTYPES rt-1"><code>Cont = <a href="#type-select_continuation">select_continuation()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="select_4">Matches the objects in table <code>Tab</code> using a <code>match_spec</code> as described in the <code>ERTS</code> User's Guide, and returns a chunk of terms and a continuation. The wanted number of returned terms is specified by argument <code>NObjects</code>. The lock argument can be <code>read</code> or <code>write</code>. The continuation is to be used as argument to <code>mnesia:select/1</code>, if more or all answers are needed.</p> <p>Notice that for best performance, <code>select</code> is to be used before any modifying operations are done on that table in the same transaction. That is, do not use <code>mnesia:write</code> or <code>mnesia:delete</code> before a <code>mnesia:select</code>. For efficiency, <code>NObjects</code> is a recommendation only and the result can contain anything from an empty list to all available results.</p> </div></div></article><article class="func"><h3 id="select-1" class="bold_code title-link func-head">  <code>select(Cont) -&gt; {[Match], Cont} | '$end_of_table'</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Match = term()</code></div> <div class="REFTYPES rt-1"><code>Cont = <a href="#type-select_continuation">select_continuation()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Selects more objects with the match specification initiated by <code>mnesia:select/4</code>.</p> <p>Notice that any modifying operations, that is, <code>mnesia:write</code> or <code>mnesia:delete</code>, that are done between the <code>mnesia:select/4</code> and <code>mnesia:select/1</code> calls are not visible in the result.</p> </div></div></article><article class="func"><h3 id="set_debug_level-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>set_debug_level(Level :: <code><a href="#type-debug_level">debug_level()</a></code>) -&gt;
 OldLevel :: <code><a href="#type-debug_level">debug_level()</a></code></code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="set_debug_level">Changes the internal debug level of Mnesia. For details, see <code><a href="#configuration_parameters">Section Configuration Parameters</a></code>.</p> </div></div></article><article class="func"><h3 id="set_master_nodes-1" class="bold_code title-link func-head">  <code>set_master_nodes(Ns :: [<code>node()</code>]) -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="set_master_nodes_1">For each table Mnesia determines its replica nodes (<code>TabNodes</code>) and starts <code>mnesia:set_master_nodes(Tab, TabMasterNodes)</code>. where <code>TabMasterNodes</code> is the intersection of <code>MasterNodes</code> and <code>TabNodes</code>. For semantics, see <code>mnesia:set_master_nodes/2</code>.</p> </div></div></article><article class="func"><h3 id="set_master_nodes-2" class="bold_code title-link func-head">  <code>set_master_nodes(Tab :: <code><a href="#type-table">table()</a></code>, Ns :: [<code>node()</code>]) -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="set_master_nodes_2">If the application detects a communication failure (in a potentially partitioned network) that can have caused an inconsistent database, it can use the function <code>mnesia:set_master_nodes(Tab, MasterNodes)</code> to define from which nodes each table is to be loaded. At startup, the Mnesia normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of when and if Mnesia terminated on other nodes. <code>MasterNodes</code> can only contain nodes where the table has a replica. If the <code>MasterNodes</code> list is empty, the master node recovery mechanism for the particular table is reset, and the normal load mechanism is used at the next restart.</p> <p>The master node setting is always local. It can be changed regardless if Mnesia is started or not.</p> <p>The database can also become inconsistent if configuration parameter <code>max_wait_for_decision</code> is used or if <code>mnesia:force_load_table/1</code> is used.</p> </div></div></article><article class="func"><h3 id="snmp_close_table-1" class="bold_code title-link func-head">  <code>snmp_close_table(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Removes the possibility for SNMP to manipulate the table.</p> </div></div></article><article class="func"><h3 id="snmp_get_mnesia_key-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>snmp_get_mnesia_key(Tab :: <code><a href="#type-table">table()</a></code>, RowIndex :: [<code>integer()</code>]) -&gt;
 {ok, Key :: <code>term()</code>} | undefined</code></pre> </h3> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Tab ::= atom()</code><br> </div> <div class="REFTYPES rt-4"> <code>RowIndex ::= [integer()]</code><br> </div> <div class="REFTYPES rt-4"> <code>Key ::= key() | {key(), key(), ...}</code><br> </div> <div class="REFTYPES rt-4"> <code>key() ::= integer() | string() | [integer()]</code><br> </div> </div> <div class="REFBODY rb-7"> <p>Transforms an SNMP index to the corresponding Mnesia key. If the SNMP table has multiple keys, the key is a tuple of the key columns.</p> </div> </div></article><article class="func"><h3 id="snmp_get_next_index-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>snmp_get_next_index(Tab :: <code><a href="#type-table">table()</a></code>, RowIndex :: [<code>integer()</code>]) -&gt;
 {ok, [<code>integer()</code>]} | endOfTable</code></pre> </h3> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Tab ::= atom()</code><br> </div> <div class="REFTYPES rt-4"> <code>RowIndex ::= [integer()]</code><br> </div> <div class="REFTYPES rt-4"> <code>NextIndex ::= [integer()]</code><br> </div> </div> <div class="REFBODY rb-7"> <p><code>RowIndex</code> can specify a non-existing row. Specifically, it can be the empty list. Returns the index of the next lexicographical row. If <code>RowIndex</code> is the empty list, this function returns the index of the first row in the table.</p> </div> </div></article><article class="func"><h3 id="snmp_get_row-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>snmp_get_row(Tab :: <code><a href="#type-table">table()</a></code>, RowIndex :: [<code>integer()</code>]) -&gt;
 {ok, Row :: <code>tuple()</code>} | undefined</code></pre> </h3> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Tab ::= atom()</code><br> </div> <div class="REFTYPES rt-4"> <code>RowIndex ::= [integer()]</code><br> </div> <div class="REFTYPES rt-4"> <code>Row ::= record(Tab)</code><br> </div> </div> <div class="REFBODY rb-7"> <p>Reads a row by its SNMP index. This index is specified as an SNMP Object Identifier, a list of integers.</p> </div> </div></article><article class="func"><h3 id="snmp_open_table-2" class="bold_code title-link func-head">  <code>snmp_open_table(Tab :: <code><a href="#type-table">table()</a></code>, Snmp :: <code><a href="#type-snmp_struct">snmp_struct()</a></code>) -&gt; ok</code> </h3> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Tab ::= atom()</code><br> </div> <div class="REFTYPES rt-4"> <code>SnmpStruct ::= [{key, type()}]</code><br> </div> <div class="REFTYPES rt-4"> <code>type() ::= type_spec() | {type_spec(), type_spec(), ...}</code><br> </div> <div class="REFTYPES rt-4"> <code>type_spec() ::= fix_string | string | integer</code><br> </div> </div> <div class="REFBODY rb-7"> <p>A direct one-to-one mapping can be established between Mnesia tables and SNMP tables. Many telecommunication applications are controlled and monitored by the SNMP protocol. This connection between Mnesia and SNMP makes it simple and convenient to achieve this mapping.</p> <p>Argument <code>SnmpStruct</code> is a list of SNMP information. Currently, the only information needed is information about the key types in the table. Multiple keys cannot be handled in Mnesia, but many SNMP tables have multiple keys. Therefore, the following convention is used: if a table has multiple keys, these must always be stored as a tuple of the keys. Information about the key types is specified as a tuple of atoms describing the types. The only significant type is <code>fix_string</code>. This means that a string has a fixed size.</p> <p>For example, the following causes table <code>person</code> to be ordered as an SNMP table:</p> <pre data-language="erlang">mnesia:snmp_open_table(person, [{key, string}])</pre> <p>Consider the following schema for a table of company employees. Each employee is identified by department number and name. The other table column stores the telephone number:</p> <pre data-language="erlang">mnesia:create_table(employee,
    [{snmp, [{key, {integer, string}}]},
     {attributes, record_info(fields, employees)}]),</pre> <p>The corresponding SNMP table would have three columns: <code>department</code>, <code>name</code>, and <code>telno</code>.</p> <p>An option is to have table columns that are not visible through the SNMP protocol. These columns must be the last columns of the table. In the previous example, the SNMP table could have columns <code>department</code> and <code>name</code> only. The application could then use column <code>telno</code> internally, but it would not be visible to the SNMP managers.</p> <p>In a table monitored by SNMP, all elements must be integers, strings, or lists of integers.</p> <p>When a table is SNMP ordered, modifications are more expensive than usual, O(logN). Also, more memory is used.</p> <p>Notice that only the lexicographical SNMP ordering is implemented in Mnesia, not the actual SNMP monitoring.</p> </div> </div></article><article class="func"><h3 id="start-0" class="bold_code title-link func-head">  <code>start() -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="start">Mnesia startup is asynchronous. The function call <code>mnesia:start()</code> returns the atom <code>ok</code> and then starts to initialize the different tables. Depending on the size of the database, this can take some time, and the application programmer must wait for the tables that the application needs before they can be used. This is achieved by using the function <code>mnesia:wait_for_tables/2</code>.</p> <p>The startup procedure for a set of Mnesia nodes is a fairly complicated operation. A Mnesia system consists of a set of nodes, with Mnesia started locally on all participating nodes. Normally, each node has a directory where all the Mnesia files are written. This directory is referred to as the Mnesia directory. Mnesia can also be started on disc-less nodes. For more information about disc-less nodes, see <code>mnesia:create_schema/1</code> and the User's Guide.</p> <p>The set of nodes that makes up a Mnesia system is kept in a schema. Mnesia nodes can be added to or removed from the schema. The initial schema is normally created on disc with the function <code>mnesia:create_schema/1</code>. On disc-less nodes, a tiny default schema is generated each time Mnesia is started. During the startup procedure, Mnesia exchanges schema information between the nodes to verify that the table definitions are compatible.</p> <p>Each schema has a unique cookie, which can be regarded as a unique schema identifier. The cookie must be the same on all nodes where Mnesia is supposed to run. For details, see the User's Guide.</p> <p>The schema file and all other files that Mnesia needs are kept in the Mnesia directory. The command-line option <code>-mnesia dir Dir</code> can be used to specify the location of this directory to the Mnesia system. If no such command-line option is found, the name of the directory defaults to <code>Mnesia.Node</code>.</p> <p><code>application:start(mnesia)</code> can also be used.</p> </div></div></article><article class="func"><h3 id="stop-0" class="bold_code title-link func-head">  <code>stop() -&gt; stopped | {error, <code>term()</code>}</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="stop">Stops Mnesia locally on the current node.</p> <p><code>application:stop(mnesia)</code> can also be used.</p> </div></div></article><article class="func"><h3 id="subscribe-1" class="bold_code title-link func-head">  <code>subscribe(What) -&gt; {ok, <code>node()</code>} | {error, Reason :: <code>term()</code>}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>What = system | activity | {table, <a href="#type-table">table()</a>, simple | detailed}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="subscribe">Ensures that a copy of all events of type <code>EventCategory</code> is sent to the caller. The available event types are described in the <code><a href="mnesia_chap5.html#event_handling">User's Guide</a></code>.</p> </div></div></article><article class="func"><h3 id="sync_dirty-1" class="bold_code title-link func-head">  <code>sync_dirty(Fun) -&gt; Res | <code>no_return()</code></code> </h3> <h3 id="sync_dirty-2" class="bold_code title-link func-head">  <code>sync_dirty(Fun, Args :: [Arg :: <code>term()</code>]) -&gt; Res | <code>no_return()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((...) -&gt; Res)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="sync_dirty">Calls the <code>Fun</code> in a context that is not protected by a transaction. The Mnesia function calls performed in the <code>Fun</code> are mapped to the corresponding dirty functions. It is performed in almost the same context as <code>mnesia:async_dirty/1,2</code>. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas before the <code>Fun</code> returns. For details, see <code>mnesia:activity/4</code> and the User's Guide.</p> </div></div></article><article class="func"><h3 id="sync_log-0" class="bold_code title-link func-head">  <code>sync_log() -&gt; <code><a href="#type-result">result()</a></code></code><div class="title-since"><span class="since">OTP 17.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Ensures that the local transaction log file is synced to disk. On a single node system, data written to disk tables since the last dump can be lost if there is a power outage. See <code><a href="#dump_log-0">dump_log/0</a></code>.</p> </div></div></article><article class="func"><h3 id="sync_transaction-1" class="bold_code title-link func-head">  <code>sync_transaction(Fun) -&gt; <code><a href="#type-t_result">t_result</a></code>(Res)</code> </h3> <h3 id="sync_transaction-2" class="bold_code title-link func-head">  <code>sync_transaction(Fun, Retries) -&gt; <code><a href="#type-t_result">t_result</a></code>(Res)</code> </h3> <h3 id="sync_transaction-2" class="bold_code title-link func-head">  <code>sync_transaction(Fun, Args :: [Arg :: <code>term()</code>]) -&gt; <code><a href="#type-t_result">t_result</a></code>(Res)</code> </h3> <h3 id="sync_transaction-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>sync_transaction(Fun, Args :: [Arg :: <code>term()</code>], Retries) -&gt;
 <code><a href="#type-t_result">t_result</a></code>(Res)</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((...) -&gt; Res)</code></div> <div class="REFTYPES rt-1"><code>Retries = integer() &gt;= 0 | infinity</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="sync_transaction">Waits until data have been committed and logged to disk (if disk is used) on every involved node before it returns, otherwise it behaves as <code>mnesia:transaction/[1,2,3]</code>.</p> <p>This functionality can be used to avoid that one process overloads a database on another node.</p> </div></div></article><article class="func"><h3 id="system_info-1" class="bold_code title-link func-head">  <code>system_info(Iterm :: <code>term()</code>) -&gt; Info :: <code>term()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="system_info">Returns information about the Mnesia system, such as transaction statistics, <code>db_nodes</code>, and configuration parameters. The valid keys are as follows:</p> <ul> <li> <p><code>all</code>. Returns a list of all local system information. Each element is a <code>{InfoKey, InfoVal}</code> tuple.</p> <p>New <code>InfoKey</code>s can be added and old undocumented <code>InfoKey</code>s can be removed without notice.</p> </li> <li> <p><code>access_module</code>. Returns the name of module that is configured to be the activity access callback module.</p> </li> <li> <p><code>auto_repair</code>. Returns <code>true</code> or <code>false</code> to indicate if Mnesia is configured to start the auto-repair facility on corrupted disc files.</p> </li> <li> <p><code>backup_module</code>. Returns the name of the module that is configured to be the backup callback module.</p> </li> <li> <p><code>checkpoints</code>. Returns a list of the names of the checkpoints currently active on this node.</p> </li> <li> <p><code>event_module</code>. Returns the name of the module that is the event handler callback module.</p> </li> <li> <p><code>db_nodes</code>. Returns the nodes that make up the persistent database. Disc-less nodes are only included in the list of nodes if they explicitly have been added to the schema, for example, with <code>mnesia:add_table_copy/3</code>. The function can be started even if Mnesia is not yet running.</p> </li> <li> <p><code>debug</code>. Returns the current debug level of Mnesia.</p> </li> <li> <p><code>directory</code>. Returns the name of the Mnesia directory. It can be called even if Mnesia is not yet running.</p> </li> <li> <p><code>dump_log_load_regulation</code>. Returns a boolean that tells if Mnesia is configured to regulate the dumper process load.</p> <p>This feature is temporary and will be removed in future releases.</p> </li> <li> <p><code>dump_log_time_threshold</code>. Returns the time threshold for transaction log dumps in milliseconds.</p> </li> <li> <p><code>dump_log_update_in_place</code>. Returns a boolean that tells if Mnesia is configured to perform the updates in the Dets files directly, or if the updates are to be performed in a copy of the Dets files.</p> </li> <li> <p><code>dump_log_write_threshold</code>. Returns the write threshold for transaction log dumps as the number of writes to the transaction log.</p> </li> <li> <p><code>extra_db_nodes</code>. Returns a list of extra <code>db_nodes</code> to be contacted at startup.</p> </li> <li> <p><code>fallback_activated</code>. Returns <code>true</code> if a fallback is activated, otherwise <code>false</code>.</p> </li> <li> <p><code>held_locks</code>. Returns a list of all locks held by the local Mnesia lock manager.</p> </li> <li> <p><code>is_running</code>. Returns <code>yes</code> or <code>no</code> to indicate if Mnesia is running. It can also return <code>starting</code> or <code>stopping</code>. Can be called even if Mnesia is not yet running.</p> </li> <li> <p><code>local_tables</code>. Returns a list of all tables that are configured to reside locally.</p> </li> <li> <p><code>lock_queue</code>. Returns a list of all transactions that are queued for execution by the local lock manager.</p> </li> <li> <p><code>log_version</code>. Returns the version number of the Mnesia transaction log format.</p> </li> <li> <p><code>master_node_tables</code>. Returns a list of all tables with at least one master node.</p> </li> <li> <p><code>protocol_version</code>. Returns the version number of the Mnesia inter-process communication protocol.</p> </li> <li> <p><code>running_db_nodes</code>. Returns a list of nodes where Mnesia currently is running. This function can be called even if Mnesia is not yet running, but it then has slightly different semantics.</p> <p>If Mnesia is down on the local node, the function returns those other <code>db_nodes</code> and <code>extra_db_nodes</code> that for the moment are operational.</p> <p>If Mnesia is started, the function returns those nodes that Mnesia on the local node is fully connected to. Only those nodes that Mnesia has exchanged schema information with are included as <code>running_db_nodes</code>. After the merge of schemas, the local Mnesia system is fully operable and applications can perform access of remote replicas. Before the schema merge, Mnesia only operates locally. Sometimes there are more nodes included in the <code>running_db_nodes</code> list than all <code>db_nodes</code> and <code>extra_db_nodes</code> together.</p> </li> <li> <p><code>schema_location</code>. Returns the initial schema location.</p> </li> <li> <p><code>subscribers</code>. Returns a list of local processes currently subscribing to system events.</p> </li> <li> <p><code>tables</code>. Returns a list of all locally known tables.</p> </li> <li> <p><code>transactions</code>. Returns a list of all currently active local transactions.</p> </li> <li> <p><code>transaction_failures</code>. Returns a number that indicates how many transactions have failed since Mnesia was started.</p> </li> <li> <p><code>transaction_commits</code>. Returns a number that indicates how many transactions have terminated successfully since Mnesia was started.</p> </li> <li> <p><code>transaction_restarts</code>. Returns a number that indicates how many transactions have been restarted since Mnesia was started.</p> </li> <li> <p><code>transaction_log_writes</code>. Returns a number that indicates how many write operations that have been performed to the transaction log since startup.</p> </li> <li> <p><code>use_dir</code>. Returns a boolean that indicates if the Mnesia directory is used or not. Can be started even if Mnesia is not yet running.</p> </li> <li> <p><code>version</code>. Returns the current version number of Mnesia.</p> </li> </ul> </div></div></article><article class="func"><h3 id="table-1" class="bold_code title-link func-head">  <code>table(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; <code>qlc:query_handle()</code></code> </h3> <h3 id="table-2" class="bold_code title-link func-head">  <code>table(Tab :: <code><a href="#type-table">table()</a></code>, Options) -&gt; <code>qlc:query_handle()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Options = Option | [Option]</code></div> <div class="REFTYPES rt-1"><code>Option = MnesiaOpt | QlcOption</code></div> <div class="REFTYPES rt-1"><pre><code>MnesiaOpt = 
 {traverse, SelectOp} |
 {lock, <a href="#type-lock_kind">lock_kind()</a>} |
 {n_objects, integer() &gt;= 0}</code></pre></div> <div class="REFTYPES rt-1"><code>SelectOp = select | {select, ets:match_spec()}</code></div> <div class="REFTYPES rt-1"><code>QlcOption = {key_equality, '==' | '=:='}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="table">Returns a Query List Comprehension (QLC) query handle, see the <code>qlc(3)</code> manual page in STDLIB. The module <code>qlc</code> implements a query language that can use Mnesia tables as sources of data. Calling <code>mnesia:table/1,2</code> is the means to make the <code>mnesia</code> table <code>Tab</code> usable to QLC.</p> <p><code>Option</code> can contain Mnesia options or QLC options. Mnesia recognizes the following options (any other option is forwarded to QLC).</p> <ul> <li> <code>{lock, Lock}</code>, where <code>lock</code> can be <code>read</code> or <code>write</code>. Default is <code>read</code>. </li> <li> <code>{n_objects,Number}</code>, where <code>n_objects</code> specifies (roughly) the number of objects returned from Mnesia to QLC. Queries to remote tables can need a larger chunk to reduce network overhead. By default, <code>100</code> objects at a time are returned. </li> <li> <code>{traverse, SelectMethod}</code>, where <code>traverse</code> determines the method to traverse the whole table (if needed). The default method is <code>select</code>. </li> </ul> <p>There are two alternatives for <code>select</code>:</p> <ul> <li> <p><code>select</code>. The table is traversed by calling <code>mnesia:select/4</code> and <code>mnesia:select/1</code>. The match specification (the second argument of <code>select/3</code>) is assembled by QLC: simple filters are translated into equivalent match specifications. More complicated filters need to be applied to all objects returned by <code>select/3</code> given a match specification that matches all objects.</p> </li> <li> <p><code>{select, MatchSpec}</code>. As for <code>select</code>, the table is traversed by calling <code>mnesia:select/3</code> and <code>mnesia:select/1</code>. The difference is that the match specification is explicitly given. This is how to state match specifications that cannot easily be expressed within the syntax provided by QLC.</p> </li> </ul> </div></div></article><article class="func"><h3 id="table_info-2" class="bold_code title-link func-head">  <code>table_info(Tab :: <code><a href="#type-table">table()</a></code>, Item :: <code>term()</code>) -&gt; Info :: <code>term()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="table_info">The <code>table_info/2</code> function takes two arguments. The first is the name of a Mnesia table. The second is one of the following keys:</p> <ul> <li> <p><code>all</code>. Returns a list of all local table information. Each element is a <code>{InfoKey, ItemVal}</code> tuple.</p> <p>New <code>InfoItem</code>s can be added and old undocumented <code>InfoItem</code>s can be removed without notice.</p> </li> <li> <p><code>access_mode</code>. Returns the access mode of the table. The access mode can be <code>read_only</code> or <code>read_write</code>.</p> </li> <li> <p><code>arity</code>. Returns the arity of records in the table as specified in the schema.</p> </li> <li> <p><code>attributes</code>. Returns the table attribute names that are specified in the schema.</p> </li> <li> <p><code>checkpoints</code>. Returns the names of the currently active checkpoints, which involve this table on this node.</p> </li> <li> <p><code>cookie</code>. Returns a table cookie, which is a unique system-generated identifier for the table. The cookie is used internally to ensure that two different table definitions using the same table name cannot accidentally be intermixed. The cookie is generated when the table is created initially.</p> </li> <li> <p><code>disc_copies</code>. Returns the nodes where a <code>disc_copy</code> of the table resides according to the schema.</p> </li> <li> <p><code>disc_only_copies</code>. Returns the nodes where a <code>disc_only_copy</code> of the table resides according to the schema.</p> </li> <li> <p><code>index</code>. Returns the list of index position integers for the table.</p> </li> <li> <p><code>load_node</code>. Returns the name of the node that Mnesia loaded the table from. The structure of the returned value is unspecified, but can be useful for debugging purposes.</p> </li> <li> <p><code>load_order</code>. Returns the load order priority of the table. It is an integer and defaults to <code>0</code> (zero).</p> </li> <li> <p><code>load_reason</code>. Returns the reason of why Mnesia decided to load the table. The structure of the returned value is unspecified, but can be useful for debugging purposes.</p> </li> <li> <p><code>local_content</code>. Returns <code>true</code> or <code>false</code> to indicate if the table is configured to have locally unique content on each node.</p> </li> <li> <p><code>master_nodes</code>. Returns the master nodes of a table.</p> </li> <li> <p><code>memory</code>. Returns for <code>ram_copies</code> and <code>disc_copies</code> tables the number of words allocated in memory to the table on this node. For <code>disc_only_copies</code> tables the number of bytes stored on disc is returned. </p> </li> <li> <p><code>ram_copies</code>. Returns the nodes where a <code>ram_copy</code> of the table resides according to the schema.</p> </li> <li> <p><code>record_name</code>. Returns the record name, common for all records in the table.</p> </li> <li> <p><code>size</code>. Returns the number of records inserted in the table.</p> </li> <li> <p><code>snmp</code>. Returns the SNMP struct. <code>[]</code> means that the table currently has no SNMP properties.</p> </li> <li> <p><code>storage_type</code>. Returns the local storage type of the table. It can be <code>disc_copies</code>, <code>ram_copies</code>, <code>disc_only_copies</code>, or the atom <code>unknown</code>. <code>unknown</code> is returned for all tables that only reside remotely.</p> </li> <li> <p><code>subscribers</code>. Returns a list of local processes currently subscribing to local table events that involve this table on this node.</p> </li> <li> <p><code>type</code>. Returns the table type, which is <code>bag</code>, <code>set</code>, or <code>ordered_set</code>.</p> </li> <li> <p><code>user_properties</code>. Returns the user-associated table properties of the table. It is a list of the stored property records.</p> </li> <li> <p><code>version</code>. Returns the current version of the table definition. The table version is incremented when the table definition is changed. The table definition can be incremented directly when it has been changed in a schema transaction, or when a committed table definition is merged with table definitions from other nodes during startup.</p> </li> <li> <p><code>where_to_read</code>. Returns the node where the table can be read. If value <code>nowhere</code> is returned, either the table is not loaded or it resides at a remote node that is not running.</p> </li> <li> <p><code>where_to_write</code>. Returns a list of the nodes that currently hold an active replica of the table.</p> </li> <li> <p><code>wild_pattern</code>. Returns a structure that can be given to the various match functions for a certain table. A record tuple is where all record fields have value <code>'_'</code>.</p> </li> </ul> </div></div></article><article class="func"><h3 id="transaction-1" class="bold_code title-link func-head">  <code>transaction(Fun) -&gt; <code><a href="#type-t_result">t_result</a></code>(Res)</code> </h3> <h3 id="transaction-2" class="bold_code title-link func-head">  <code>transaction(Fun, Retries) -&gt; <code><a href="#type-t_result">t_result</a></code>(Res)</code> </h3> <h3 id="transaction-2" class="bold_code title-link func-head">  <code>transaction(Fun, Args :: [Arg :: <code>term()</code>]) -&gt; <code><a href="#type-t_result">t_result</a></code>(Res)</code> </h3> <h3 id="transaction-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>transaction(Fun, Args :: [Arg :: <code>term()</code>], Retries) -&gt;
 <code><a href="#type-t_result">t_result</a></code>(Res)</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((...) -&gt; Res)</code></div> <div class="REFTYPES rt-1"><code>Retries = integer() &gt;= 0 | infinity</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="transaction">Executes the functional object <code>Fun</code> with arguments <code>Args</code> as a transaction.</p> <p>The code that executes inside the transaction can consist of a series of table manipulation functions. If something goes wrong inside the transaction as a result of a user error or a certain table not being available, the entire transaction is terminated and the function <code>transaction/1</code> returns the tuple <code>{aborted, Reason}</code>.</p> <p>If all is going well, <code>{atomic, ResultOfFun}</code> is returned, where <code>ResultOfFun</code> is the value of the last expression in <code>Fun</code>.</p> <p>A function that adds a family to the database can be written as follows if there is a structure <code>{family, Father, Mother, ChildrenList}</code>:</p> <pre data-language="erlang">add_family({family, F, M, Children}) -&gt;
    ChildOids = lists:map(fun oid/1, Children),
    Trans = fun() -&gt;
        mnesia:write(F#person{children = ChildOids}),
        mnesia:write(M#person{children = ChildOids}),
        Write = fun(Child) -&gt; mnesia:write(Child) end,
        lists:foreach(Write, Children)
    end,
    mnesia:transaction(Trans).

oid(Rec) -&gt; {element(1, Rec), element(2, Rec)}.</pre> <p>This code adds a set of people to the database. Running this code within one transaction ensures that either the whole family is added to the database, or the whole transaction terminates. For example, if the last child is badly formatted, or the executing process terminates because of an <code>'EXIT'</code> signal while executing the family code, the transaction terminates. Thus, the situation where half a family is added can never occur.</p> <p>It is also useful to update the database within a transaction if several processes concurrently update the same records. For example, the function <code>raise(Name, Amount)</code>, which adds <code>Amount</code> to the salary field of a person, is to be implemented as follows:</p> <pre data-language="erlang">raise(Name, Amount) -&gt;
    mnesia:transaction(fun() -&gt;
        case mnesia:wread({person, Name}) of
            [P] -&gt;
                Salary = Amount + P#person.salary,
                P2 = P#person{salary = Salary},
                mnesia:write(P2);
            _ -&gt;
                mnesia:abort("No such person")
        end
    end).</pre> <p>When this function executes within a transaction, several processes running on different nodes can concurrently execute the function <code>raise/2</code> without interfering with each other.</p> <p> Since Mnesia detects deadlocks, a transaction can be restarted any number of times and therefore the <code>Fun</code> shall not have any side effects such as waiting for specific messages. This function attempts a restart as many times as specified in <code>Retries</code>. <code>Retries</code> must be an integer greater than 0 or the atom <code>infinity</code>, default is <code>infinity</code>. Mnesia uses <code>exit</code> exceptions to signal that a transaction needs to be restarted, thus a <code>Fun</code> must not catch <code>exit</code> exceptions with reason <code>{aborted, term()}</code>. </p> </div></div></article><article class="func"><h3 id="transform_table-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>transform_table(Tab :: <code><a href="#type-table">table()</a></code>, Fun, NewA :: [Attr], RecName) -&gt;
 <code><a href="#type-t_result">t_result</a></code>(ok)</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>RecName = Attr = atom()</code></div>  <div class="REFTYPES rt-1"><pre><code>Fun = 
 fun((Record :: tuple()) -&gt; Transformed :: tuple()) | ignore</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="transform_table_4">Applies argument <code>Fun</code> to all records in the table. <code>Fun</code> is a function that takes a record of the old type and returns a transformed record of the new type. Argument <code>Fun</code> can also be the atom <code>ignore</code>, which indicates that only the metadata about the table is updated. Use of <code>ignore</code> is not recommended, but included as a possibility for the user do to an own transformation.</p> <p><code>NewAttributeList</code> and <code>NewRecordName</code> specify the attributes and the new record type of the converted table. Table name always remains unchanged. If <code>record_name</code> is changed, only the Mnesia functions that use table identifiers work, for example, <code>mnesia:write/3</code> works, but not <code>mnesia:write/1</code>.</p> </div></div></article><article class="func"><h3 id="transform_table-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>transform_table(Tab :: <code><a href="#type-table">table()</a></code>, Fun, NewA :: [Attr]) -&gt;
 <code><a href="#type-t_result">t_result</a></code>(ok)</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Attr = atom()</code></div> <div class="REFTYPES rt-1"><pre><code>Fun = 
 fun((Record :: tuple()) -&gt; Transformed :: tuple()) | ignore</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Calls <code>mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)</code>, where <code>RecName</code> is <code>mnesia:table_info(Tab, record_name)</code>.</p> </div></div></article><article class="func"><h3 id="traverse_backup-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>traverse_backup(Src :: <code>term()</code>, Dest :: <code>term()</code>, Fun, Acc) -&gt;
 {ok, Acc} | {error, Reason :: <code>term()</code>}</code></pre> </h3> <h3 id="traverse_backup-6" class="bold_code title-link func-head">  <pre data-language="erlang"><code>traverse_backup(Src :: <code>term()</code>,
 SrcMod :: <code>module()</code>,
 Dest :: <code>term()</code>,
 DestMod :: <code>module()</code>,
 Fun, Acc) -&gt;
 {ok, Acc} | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((Items, Acc) -&gt; {Items, Acc})</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="traverse_backup">Iterates over a backup, either to transform it into a new backup, or read it. The arguments are explained briefly here. For details, see the User's Guide.</p> <ul> <li> <code>SourceMod</code> and <code>TargetMod</code> are the names of the modules that actually access the backup media. </li> <li> <code>Source</code> and <code>Target</code> are opaque data used exclusively by modules <code>SourceMod</code> and <code>TargetMod</code> to initialize the backup media. </li> <li> <code>Acc</code> is an initial accumulator value. </li> <li> <code>Fun(BackupItems, Acc)</code> is applied to each item in the backup. The <code>Fun</code> must return a tuple <code>{BackupItems,NewAcc}</code>, where <code>BackupItems</code> is a list of valid backup items, and <code>NewAcc</code> is a new accumulator value. The returned backup items are written in the target backup. </li> <li> <code>LastAcc</code> is the last accumulator value. This is the last <code>NewAcc</code> value that was returned by <code>Fun</code>. </li> </ul> </div></div></article><article class="func"><h3 id="uninstall_fallback-0" class="bold_code title-link func-head">  <code>uninstall_fallback() -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="uninstall_fallback_0">Calls the function <code>mnesia:uninstall_fallback([{scope, global}])</code>.</p> </div></div></article><article class="func"><h3 id="uninstall_fallback-1" class="bold_code title-link func-head">  <code>uninstall_fallback(Args) -&gt; <code><a href="#type-result">result()</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Args = [{mnesia_dir, Dir :: string()}]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Deinstalls a fallback before it has been used to restore the database. This is normally a distributed operation that is either performed on all nodes with disc resident schema, or none. Uninstallation of fallbacks requires Erlang to be operational on all involved nodes, but it does not matter if Mnesia is running or not. Which nodes that are considered as disc-resident nodes is determined from the schema information in the local fallback.</p> <p><code>Args</code> is a list of the following tuples:</p> <ul> <li> <code>{module, BackupMod}</code>. For semantics, see <code>mnesia:install_fallback/2</code>. </li> <li> <code>{scope, Scope}</code>. For semantics, see <code>mnesia:install_fallback/2</code>. </li> <li> <code>{mnesia_dir, AlternateDir}</code>. For semantics, see <code>mnesia:install_fallback/2</code>. </li> </ul> </div></div></article><article class="func"><h3 id="unsubscribe-1" class="bold_code title-link func-head">  <code>unsubscribe(What) -&gt; {ok, <code>node()</code>} | {error, Reason :: <code>term()</code>}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>What = system | activity | {table, <a href="#type-table">table()</a>, simple | detailed}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="unsubscribe">Stops sending events of type <code>EventCategory</code> to the caller.</p> <p><code>Node</code> is the local node.</p> </div></div></article><article class="func"><h3 id="wait_for_tables-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>wait_for_tables(Tabs :: [Tab :: <code><a href="#type-table">table()</a></code>], TMO :: <code>timeout()</code>) -&gt;
 <code><a href="#type-result">result()</a></code> | {timeout, [<code><a href="#type-table">table()</a></code>]}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="wait_for_tables">Some applications need to wait for certain tables to be accessible to do useful work. <code>mnesia:wait_for_tables/2</code> either hangs until all tables in <code>TabList</code> are accessible, or until <code>timeout</code> is reached.</p> </div></div></article><article class="func"><h3 id="wread-1" class="bold_code title-link func-head">  <code>wread(Oid :: {Tab :: <code><a href="#type-table">table()</a></code>, Key :: <code>term()</code>}) -&gt; [<code>tuple()</code>]</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="wread">Calls the function <code>mnesia:read(Tab, Key, write)</code>.</p> </div></div></article><article class="func"><h3 id="write-1" class="bold_code title-link func-head">  <code>write(Record :: <code>tuple()</code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="write_1">Calls the function <code>mnesia:write(Tab, Record, write)</code>, where <code>Tab</code> is <code>element(1, Record)</code>.</p> </div></div></article><article class="func"><h3 id="write-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>write(Tab :: <code><a href="#type-table">table()</a></code>,
 Record :: <code>tuple()</code>,
 LockKind :: <code><a href="#type-write_locks">write_locks()</a></code>) -&gt;
 ok</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="write_3">Writes record <code>Record</code> to table <code>Tab</code>.</p> <p>The function returns <code>ok</code>, or terminates if an error occurs. For example, the transaction terminates if no <code>person</code> table exists.</p> <p>The semantics of this function is context-sensitive. For details, see <code>mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code>LockKind</code>. The lock types <code>write</code> and <code>sticky_write</code> are supported.</p> </div></div></article><article class="func"><h3 id="write_lock_table-1" class="bold_code title-link func-head">  <code>write_lock_table(Tab :: <code><a href="#type-table">table()</a></code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="write_lock_table">Calls the function <code>mnesia:lock({table, Tab}, write)</code>.</p> </div></div></article> </div> <section class="innertube"><h2 id="configuration-parameters" class="title-link"> <div class="title-name">Configuration Parameters</div>  </h2> <div class="REFBODY rb-3">  <p id="configuration_parameters">Mnesia reads the following application configuration parameters:</p> <ul> <li> <p><code>-mnesia access_module Module</code>. The name of the Mnesia activity access callback module. Default is <code>mnesia</code>.</p> </li> <li> <p><code>-mnesia auto_repair true | false</code>. This flag controls if Mnesia automatically tries to repair files that have not been properly closed. Default is <code>true</code>.</p> </li> <li> <p><code>-mnesia backup_module Module</code>. The name of the Mnesia backup callback module. Default is <code>mnesia_backup</code>.</p> </li> <li> <p><code>-mnesia debug Level</code>. Controls the debug level of Mnesia. The possible values are as follows:</p> <dl> <dt class="title-link"><strong><code>none</code></strong></dt> <dd> <p>No trace outputs. This is the default.</p> </dd> <dt class="title-link"><strong><code>verbose</code></strong></dt> <dd> <p>Activates tracing of important debug events. These events generate <code>{mnesia_info, Format, Args}</code> system events. Processes can subscribe to these events with <code>mnesia:subscribe/1</code>. The events are always sent to the Mnesia event handler.</p> </dd> <dt class="title-link"><strong><code>debug</code></strong></dt> <dd> <p>Activates all events at the verbose level plus full trace of all debug events. These debug events generate <code>{mnesia_info, Format, Args}</code> system events. Processes can subscribe to these events with <code>mnesia:subscribe/1</code>. The events are always sent to the Mnesia event handler. On this debug level, the Mnesia event handler starts subscribing to updates in the schema table.</p> </dd> <dt class="title-link"><strong><code>trace</code></strong></dt> <dd> <p>Activates all events at the debug level. On this level, the Mnesia event handler starts subscribing to updates on all Mnesia tables. This level is intended only for debugging small toy systems, as many large events can be generated.</p> </dd> <dt class="title-link"><strong><code>false</code></strong></dt> <dd>An alias for none. </dd> <dt class="title-link"><strong><code>true</code></strong></dt> <dd>An alias for debug. </dd> </dl> </li> <li> <p><code>-mnesia core_dir Directory</code>. The name of the directory where Mnesia core files is stored, or false. Setting it implies that also RAM-only nodes generate a core file if a crash occurs.</p> </li> <li> <p><code>-mnesia dc_dump_limit Number</code>. Controls how often <code>disc_copies</code> tables are dumped from memory. Tables are dumped when <code>filesize(Log) &gt; (filesize(Tab)/Dc_dump_limit)</code>. Lower values reduce CPU overhead but increase disk space and startup times. Default is 4.</p> </li> <li> <p><code>-mnesia dir Directory</code>. The name of the directory where all Mnesia data is stored. The directory name must be unique for the current node. Two nodes must never share the the same Mnesia directory. The results are unpredictable.</p> </li> <li> <p><code>-mnesia dump_disc_copies_at_startup true | false</code>. If set to false, this disables the dumping of <code>disc_copies</code> tables during startup while tables are being loaded. The default is true.</p> </li> <li> <p><code>-mnesia dump_log_load_regulation true | false</code>. Controls if log dumps are to be performed as fast as possible, or if the dumper is to do its own load regulation. Default is <code>false</code>.</p> <p>This feature is temporary and will be removed in a future release</p> </li> <li> <p><code>-mnesia dump_log_update_in_place true | false</code>. Controls if log dumps are performed on a copy of the original data file, or if the log dump is performed on the original data file. Default is <code>true</code></p> </li> <li>  <p id="dump_log_write_threshold"><code>-mnesia dump_log_write_threshold Max</code>. <code>Max</code> is an integer that specifies the maximum number of writes allowed to the transaction log before a new dump of the log is performed. Default is <code>1000</code> log writes.</p> </li> <li>  <p id="dump_log_time_threshold"><code>-mnesia dump_log_time_threshold Max</code>. <code>Max</code> is an integer that specifies the dump log interval in milliseconds. Default is 3 minutes. If a dump has not been performed within <code>dump_log_time_threshold</code> milliseconds, a new dump is performed regardless of the number of writes performed.</p> </li> <li> <p><code>-mnesia event_module Module</code>. The name of the Mnesia event handler callback module. Default is <code>mnesia_event</code>.</p> </li> <li> <p><code>-mnesia extra_db_nodes Nodes</code> specifies a list of nodes, in addition to the ones found in the schema, with which Mnesia is also to establish contact. Default is <code>[]</code> (empty list).</p> </li> <li> <p><code>-mnesia fallback_error_function {UserModule, UserFunc}</code>. Specifies a user-supplied callback function, which is called if a fallback is installed and Mnesia goes down on another node. Mnesia calls the function with one argument, the name of the dying node, for example, <code>UserModule:UserFunc(DyingNode)</code>. Mnesia must be restarted, otherwise the database can be inconsistent. The default behavior is to terminate Mnesia.</p> </li> <li> <p><code>-mnesia max_wait_for_decision Timeout</code>. Specifies how long Mnesia waits for other nodes to share their knowledge about the outcome of an unclear transaction. By default, <code>Timeout</code> is set to the atom <code>infinity</code>. This implies that if Mnesia upon startup detects a "heavyweight transaction" whose outcome is unclear, the local Mnesia waits until Mnesia is started on some (in the worst case all) of the other nodes that were involved in the interrupted transaction. This is a rare situation, but if it occurs, Mnesia does not guess if the transaction on the other nodes was committed or terminated. Mnesia waits until it knows the outcome and then acts accordingly.</p> <p>If <code>Timeout</code> is set to an integer value in milliseconds, Mnesia forces "heavyweight transactions" to be finished, even if the outcome of the transaction for the moment is unclear. After <code>Timeout</code> milliseconds, Mnesia commits or terminates the transaction and continues with the startup. This can lead to a situation where the transaction is committed on some nodes and terminated on other nodes. If the transaction is a schema transaction, the inconsistency can be fatal.</p> </li> <li> <p><code>-mnesia no_table_loaders NUMBER</code>. Specifies the number of parallel table loaders during start. More loaders can be good if the network latency is high or if many tables contain few records. Default is <code>2</code>.</p> </li> <li> <p><code>-mnesia send_compressed Level</code>. Specifies the level of compression to be used when copying a table from the local node to another one. Default is <code>0</code>.</p> <p><code>Level</code> must be an integer in the interval <code>[0, 9]</code>, where <code>0</code> means no compression and <code>9</code> means maximum compression. Before setting it to a non-zero value, ensure that the remote nodes understand this configuration.</p> </li> <li> <p><code>-mnesia max_transfer_size Number</code>. Specifies the estimated size in bytes of a single packet of data to be used when copying a table from the local node to another one. Default is <code>64000</code>.</p> </li> <li> <p><code>-mnesia schema_location Loc</code>. Controls where Mnesia looks for its schema. Parameter <code>Loc</code> can be one of the following atoms:</p> <dl> <dt class="title-link"><strong><code>disc</code></strong></dt> <dd> <p>Mandatory disc. The schema is assumed to be located in the Mnesia directory. If the schema cannot be found, Mnesia refuses to start. This is the old behavior.</p> </dd> <dt class="title-link"><strong><code>ram</code></strong></dt> <dd> <p>Mandatory RAM. The schema resides in RAM only. At startup, a tiny new schema is generated. This default schema only contains the definition of the schema table and only resides on the local node. Since no other nodes are found in the default schema, configuration parameter <code>extra_db_nodes</code> must be used to let the node share its table definitions with other nodes.</p> <p>Parameter <code>extra_db_nodes</code> can also be used on disc based nodes.</p> </dd> <dt class="title-link"><strong><code>opt_disc</code></strong></dt> <dd> <p>Optional disc. The schema can reside on disc or in RAM. If the schema is found on disc, Mnesia starts as a disc-based node and the storage type of the schema table is <code>disc_copies</code>. If no schema is found on disc, Mnesia starts as a disc-less node and the storage type of the schema table is <code>ram_copies</code>. Default value for the application parameter is <code>opt_disc</code>.</p> </dd> </dl> </li> </ul> <p>First, the SASL application parameters are checked, then the command-line flags are checked, and finally, the default value is chosen.</p> </div></section> <section class="innertube"><h2 id="see-also" class="title-link"> <div class="title-name">See Also</div>  </h2> <div class="REFBODY rb-3"> <p><code>application(3)</code>, <code>dets(3)</code>, <code>disk_log(3)</code>, <code>ets(3)</code>, <code>mnesia_registry(3)</code>, <code>qlc(3)</code></p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
