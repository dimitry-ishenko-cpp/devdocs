  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">mnesia_frag_hash</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Defines mnesia_frag_hash callback behavior</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module defines a callback behavior for user-defined hash functions of fragmented tables.</p> <p>Which module that is selected to implement the <code>mnesia_frag_hash</code> behavior for a particular fragmented table is specified together with the other <code>frag_properties</code>. The <code>hash_module</code> defines the module name. The <code>hash_state</code> defines the initial hash state.</p> <p>This module implements dynamic hashing, which is a kind of hashing that grows nicely when new fragments are added. It is well suited for scalable hash tables.</p> </div> </div></section> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><div class="bold_code func-head"><h3 id="init_state-2" class="title-link">  <div class="title-name">init_state(Tab, State) -&gt; NewState | abort(Reason)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Tab = atom()</code><br> </div> <div class="REFTYPES rt-4"> <code>State = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>NewState = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>Reason = term()</code><br> </div> </div> <div class="REFBODY rb-7"> <p>Starts when a fragmented table is created with the function <code>mnesia:create_table/2</code> or when a normal (unfragmented) table is converted to be a fragmented table with <code>mnesia:change_table_frag/2</code>.</p> <p>Notice that the function <code>add_frag/2</code> is started one time for each of the other fragments (except number 1) as a part of the table creation procedure.</p> <p><code>State</code> is the initial value of the <code>hash_state</code> <code>frag_property</code>. <code>NewState</code> is stored as <code>hash_state</code> among the other <code>frag_properties</code>.</p> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="add_frag-1" class="title-link">  <div class="title-name">add_frag(State) -&gt; {NewState, IterFrags, AdditionalLockFrags} | abort(Reason)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>State = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>NewState = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>IterFrags = [integer()]</code><br> </div> <div class="REFTYPES rt-4"> <code>AdditionalLockFrags = [integer()]</code><br> </div> <div class="REFTYPES rt-4"> <code>Reason = term()</code><br> </div> </div> <div class="REFBODY rb-7"> <p>To scale well, it is a good idea to ensure that the records are evenly distributed over all fragments, including the new one.</p> <p><code>NewState</code> is stored as <code>hash_state</code> among the other <code>frag_properties</code>.</p> <p>As a part of the <code>add_frag</code> procedure, Mnesia iterates over all fragments corresponding to the <code>IterFrags</code> numbers and starts <code>key_to_frag_number(NewState,RecordKey)</code> for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</p> <p>As the <code>add_frag</code> procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to <code>IterFrags</code> and those corresponding to <code>AdditionalLockFrags</code>.</p> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="del_frag-1" class="title-link">  <div class="title-name">del_frag(State) -&gt; {NewState, IterFrags, AdditionalLockFrags} | abort(Reason)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>State = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>NewState = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>IterFrags = [integer()]</code><br> </div> <div class="REFTYPES rt-4"> <code>AdditionalLockFrags = [integer()]</code><br> </div> <div class="REFTYPES rt-4"> <code>Reason = term()</code><br> </div> </div> <div class="REFBODY rb-7"> <p><code>NewState</code> is stored as <code>hash_state</code> among the other <code>frag_properties</code>.</p> <p>As a part of the <code>del_frag</code> procedure, Mnesia iterates over all fragments corresponding to the <code>IterFrags</code> numbers and starts <code>key_to_frag_number(NewState,RecordKey)</code> for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</p> <p>Notice that all records in the last fragment must be moved to another fragment, as the entire fragment is deleted.</p> <p>As the <code>del_frag</code> procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to <code>IterFrags</code> and those corresponding to <code>AdditionalLockFrags</code>.</p> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="key_to_frag_number-2" class="title-link">  <div class="title-name">key_to_frag_number(State, Key) -&gt; FragNum | abort(Reason)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>FragNum = integer()</code><br> </div> <div class="REFTYPES rt-4"> <code>Reason = term()</code><br> </div> </div> <div class="REFBODY rb-7"> <p>Starts whenever Mnesia needs to determine which fragment a certain record belongs to. It is typically started at <code>read</code>, <code>write</code>, and <code>delete</code>.</p> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="match_spec_to_frag_numbers-2" class="title-link">  <div class="title-name">match_spec_to_frag_numbers(State, MatchSpec) -&gt; FragNums | abort(Reason)</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>MatcSpec = ets_select_match_spec()</code><br> </div> <div class="REFTYPES rt-4"> <code>FragNums = [FragNum]</code><br> </div> <div class="REFTYPES rt-4"> <code>FragNum = integer()</code><br> </div> <div class="REFTYPES rt-4"> <code>Reason = term()</code><br> </div> </div> <div class="REFBODY rb-7"> <p>This function is called whenever Mnesia needs to determine which fragments that need to be searched for a <code>MatchSpec</code>. It is typically called by <code>select</code> and <code>match_object</code>.</p> </div> </div></article> </div> <section class="innertube"><h2 id="see-also" class="title-link"> <div class="title-name">See Also</div>  </h2> <div class="REFBODY rb-3"> <p><code>mnesia(3)</code></p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
