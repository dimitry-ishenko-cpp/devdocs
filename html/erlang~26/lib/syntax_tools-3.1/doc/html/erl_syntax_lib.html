  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">erl_syntax_lib</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Support library for abstract Erlang syntax trees.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>Support library for abstract Erlang syntax trees.</p> <p>This module contains utility functions for working with the abstract data type defined in the module <code><a href="erl_syntax.html">erl_syntax</a></code>. </p>
</div> </div></section> <section class="innertube"><h2 id="data-types" class="title-link"> data types  </h2> <div class="REFBODY rb-3">  <dl id="types"> <dt class="title-link"><strong id="type-appFunName">appFunName() = {atom(), arity()} | {atom(), {atom(), arity()}}</strong></dt>  <dt class="title-link"><strong>field() = {atom(), {<code id="type-field"><a href="#type-field_default">field_default()</a></code>, <code><a href="#type-field_type">field_type()</a></code>}}</strong></dt>  <dt class="title-link"><strong>field_default() = none | <code id="type-field_default">erl_syntax:syntaxTree()</code></strong></dt>  <dt class="title-link"><strong>field_type() = none | <code id="type-field_type">erl_syntax:syntaxTree()</code></strong></dt>  <dt class="title-link"><strong>fields() = [<code id="type-fields"><a href="#type-field">field()</a></code>]</strong></dt>  <dt class="title-link"><strong id="type-functionN">functionN() = atom() | {atom(), arity()}</strong></dt>  <dt class="title-link"><strong>functionName() = <code id="type-functionName"><a href="#type-functionN">functionN()</a></code> | {atom(), <code><a href="#type-functionN">functionN()</a></code>}</strong></dt>  <dt class="title-link"><strong>info() = {atom(), [{atom(), <code id="type-info">erl_syntax:syntaxTree()</code>}]} | {atom(), atom()} | atom()</strong></dt>  <dt class="title-link"><strong>info_pair() = {<code id="type-info_pair"><a href="#type-key">key()</a></code>, term()}</strong></dt>  <dt class="title-link"><strong id="type-key">key() = attributes | errors | exports | functions | imports | module | records | warnings</strong></dt>  <dt class="title-link"><strong>name() = <code id="type-name"><a href="#type-shortname">shortname()</a></code> | {atom(), <code><a href="#type-shortname">shortname()</a></code>}</strong></dt>  <dt class="title-link"><strong>ordset(T) = <code id="type-ordset">ordsets:ordset(T)</code></strong></dt>  <dt class="title-link"><strong>set(T) = <code id="type-set">sets:set(T)</code></strong></dt>  <dt class="title-link"><strong id="type-shortname">shortname() = atom() | {atom(), arity()}</strong></dt>  <dt class="title-link"><strong>syntaxTree() = <code id="type-syntaxTree">erl_syntax:syntaxTree()</code></strong></dt> <dd>  <p>An abstract syntax tree. See the <code><a href="erl_syntax.html">erl_syntax</a></code> module for details.</p> </dd> <dt class="title-link"><strong id="type-typeName">typeName() = atom() | {module(), {atom(), arity()}} | {atom(), arity()}</strong></dt>  </dl> </div></section> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><div class="bold_code func-head"><h3 id="analyze_application-1" class="title-link">  <div class="title-name">analyze_application(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; <code><a href="#type-appFunName">appFunName()</a></code> | arity()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_application-1">Returns the name of a called function. The result is a representation of the name of the applied function <code>F/A</code>, if <code>Node</code> represents a function application "<code>F(X_1, ..., X_A)</code>". If the function is not explicitly named (i.e., <code>F</code> is given by some expression), only the arity <code>A</code> is returned.</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed application expression. </p> <p><strong>See also:</strong> <code><a href="#analyze_function_name-1">analyze_function_name/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_attribute-1" class="title-link">  <div class="title-name">analyze_attribute(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; preprocessor | {atom(), term()}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_attribute-1">Analyzes an attribute node. If <code>Node</code> represents a preprocessor directive, the atom <code>preprocessor</code> is returned. Otherwise, if <code>Node</code> represents a module attribute "<code>-Name...</code>", a tuple <code>{Name, Info}</code> is returned, where <code>Info</code> depends on <code>Name</code>, as follows: </p> <dl> <dt class="title-link"><strong><code>{module, Info}</code></strong></dt> <dd><p>where <code>Info = analyze_module_attribute(Node)</code>.</p></dd> <dt class="title-link"><strong><code>{export, Info}</code></strong></dt> <dd><p>where <code>Info = analyze_export_attribute(Node)</code>.</p></dd> <dt class="title-link"><strong><code>{import, Info}</code></strong></dt> <dd><p>where <code>Info = analyze_import_attribute(Node)</code>.</p></dd> <dt class="title-link"><strong><code>{file, Info}</code></strong></dt> <dd><p>where <code>Info = analyze_file_attribute(Node)</code>.</p></dd> <dt class="title-link"><strong><code>{record, Info}</code></strong></dt> <dd><p>where <code>Info = analyze_record_attribute(Node)</code>.</p></dd> <dt class="title-link"><strong><code>{Name, Info}</code></strong></dt> <dd><p>where <code>{Name, Info} = analyze_wild_attribute(Node)</code>.</p></dd> </dl> <p> The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed module attribute. </p> <p><strong>See also:</strong> <code><a href="#analyze_export_attribute-1">analyze_export_attribute/1</a></code>, <code><a href="#analyze_file_attribute-1">analyze_file_attribute/1</a></code>, <code><a href="#analyze_import_attribute-1">analyze_import_attribute/1</a></code>, <code><a href="#analyze_module_attribute-1">analyze_module_attribute/1</a></code>, <code><a href="#analyze_record_attribute-1">analyze_record_attribute/1</a></code>, <code><a href="#analyze_wild_attribute-1">analyze_wild_attribute/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_export_attribute-1" class="title-link">  <div class="title-name">analyze_export_attribute(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; [<code><a href="#type-functionName">functionName()</a></code>]</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_export_attribute-1">Returns the list of function names declared by an export attribute. We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed export attribute. </p> <p><strong>See also:</strong> <code><a href="#analyze_attribute-1">analyze_attribute/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_file_attribute-1" class="title-link">  <div class="title-name">analyze_file_attribute(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; {string(), integer()}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_file_attribute-1">Returns the file name and line number of a <code>file</code> attribute. The result is the pair <code>{File, Line}</code> if <code>Node</code> represents "<code>-file(File, Line).</code>".</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed <code>file</code> attribute. </p> <p><strong>See also:</strong> <code><a href="#analyze_attribute-1">analyze_attribute/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_form-1" class="title-link">  <div class="title-name">analyze_form(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; {atom(), term()} | atom()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_form-1">Analyzes a "source code form" node. If <code>Node</code> is a "form" type (cf. <code>erl_syntax:is_form/1</code>), the returned value is a tuple <code>{Type, Info}</code> where <code>Type</code> is the node type and <code>Info</code> depends on <code>Type</code>, as follows: </p> <dl> <dt class="title-link"><strong><code>{attribute, Info}</code></strong></dt> <dd><p>where <code>Info = analyze_attribute(Node)</code>.</p></dd> <dt class="title-link"><strong><code>{error_marker, Info}</code></strong></dt> <dd><p>where <code>Info = erl_syntax:error_marker_info(Node)</code>.</p></dd> <dt class="title-link"><strong><code>{function, Info}</code></strong></dt> <dd><p>where <code>Info = analyze_function(Node)</code>.</p></dd> <dt class="title-link"><strong><code>{warning_marker, Info}</code></strong></dt> <dd><p>where <code>Info = erl_syntax:warning_marker_info(Node)</code>.</p></dd> </dl> <p> For other types of forms, only the node type is returned.</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> is not well-formed. </p> <p><strong>See also:</strong> <code><a href="#analyze_attribute-1">analyze_attribute/1</a></code>, <code><a href="#analyze_function-1">analyze_function/1</a></code>, <code><a href="erl_syntax.html#error_marker_info-1">erl_syntax:error_marker_info/1</a></code>, <code><a href="erl_syntax.html#is_form-1">erl_syntax:is_form/1</a></code>, <code><a href="erl_syntax.html#warning_marker_info-1">erl_syntax:warning_marker_info/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_forms-1" class="title-link">  <div class="title-name">analyze_forms(Forms::<code>erl_syntax:forms()</code>) -&gt; [<code><a href="#type-info_pair">info_pair()</a></code>]</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_forms-1">Analyzes a sequence of "program forms". The given <code>Forms</code> may be a single syntax tree of type <code>form_list</code>, or a list of "program form" syntax trees. The returned value is a list of pairs <code>{Key, Info}</code>, where each value of <code>Key</code> occurs at most once in the list; the absence of a particular key indicates that there is no well-defined value for that key.</p> <p>Each entry in the resulting list contains the following corresponding information about the program forms: </p> <dl> <dt class="title-link"><strong><code>{attributes, Attributes}</code></strong></dt> <dd> <ul> <li><p><code>Attributes = [{atom(), term()}]</code></p></li> </ul> <p> <code>Attributes</code> is a list of pairs representing the names and corresponding values of all so-called "wild" attributes (as e.g. "<code>-compile(...)</code>") occurring in <code>Forms</code> (cf. <code>analyze_wild_attribute/1</code>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p> </dd> <dt class="title-link"><strong><code>{errors, Errors}</code></strong></dt> <dd> <ul> <li><p><code>Errors = [term()]</code></p></li> </ul> <p> <code>Errors</code> is the list of error descriptors of all <code>error_marker</code> nodes that occur in <code>Forms</code>. The order of listing is not defined.</p> </dd> <dt class="title-link"><strong><code>{exports, Exports}</code></strong></dt> <dd> <ul> <li><p><code>Exports = [FunctionName]</code></p></li> <li><p><code>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</code></p></li> <li><p><code>ModuleName = atom()</code></p></li> </ul> <p> <code>Exports</code> is a list of representations of those function names that are listed by export declaration attributes in <code>Forms</code> (cf. <code>analyze_export_attribute/1</code>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p> </dd> <dt class="title-link"><strong><code>{functions, Functions}</code></strong></dt> <dd> <ul> <li><p><code>Functions = [{atom(), integer()}]</code></p></li> </ul> <p> <code>Functions</code> is a list of the names of the functions that are defined in <code>Forms</code> (cf. <code>analyze_function/1</code>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p> </dd> <dt class="title-link"><strong><code>{imports, Imports}</code></strong></dt> <dd> <ul> <li><p><code>Imports = [{Module, Names}]</code></p></li> <li><p><code>Module = atom()</code></p></li> <li><p><code>Names = [FunctionName]</code></p></li> <li><p><code>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</code></p></li> <li><p><code>ModuleName = atom()</code></p></li> </ul> <p> <code>Imports</code> is a list of pairs representing those module names and corresponding function names that are listed by import declaration attributes in <code>Forms</code> (cf. <code>analyze_import_attribute/1</code>), where each <code>Module</code> occurs at most once in <code>Imports</code>. We do not guarantee that each name occurs at most once in the lists of function names. The order of listing is not defined.</p> </dd> <dt class="title-link"><strong><code>{module, ModuleName}</code></strong></dt> <dd> <ul> <li><p><code>ModuleName = atom()</code></p></li> </ul> <p> <code>ModuleName</code> is the name declared by a module attribute in <code>Forms</code>. If no module name is defined in <code>Forms</code>, the result will contain no entry for the <code>module</code> key. If multiple module name declarations should occur, all but the first will be ignored.</p> </dd> <dt class="title-link"><strong><code>{records, Records}</code></strong></dt> <dd> <ul> <li><p><code>Records = [{atom(), Fields}]</code></p></li> <li><p><code>Fields = [{atom(), {Default, Type}}]</code></p></li> <li><p><code>Default = none | syntaxTree()</code></p></li> <li><p><code>Type = none | syntaxTree()</code></p></li> </ul> <p> <code>Records</code> is a list of pairs representing the names and corresponding field declarations of all record declaration attributes occurring in <code>Forms</code>. For fields declared without a default value, the corresponding value for <code>Default</code> is the atom <code>none</code>. Similarly, for fields declared without a type, the corresponding value for <code>Type</code> is the atom <code>none</code> (cf. <code>analyze_record_attribute/1</code>). We do not guarantee that each record name occurs at most once in the list. The order of listing is not defined.</p> </dd> <dt class="title-link"><strong><code>{warnings, Warnings}</code></strong></dt> <dd> <ul> <li><p><code>Warnings = [term()]</code></p></li> </ul> <p> <code>Warnings</code> is the list of error descriptors of all <code>warning_marker</code> nodes that occur in <code>Forms</code>. The order of listing is not defined.</p> </dd> </dl> <p>The evaluation throws <code>syntax_error</code> if an ill-formed Erlang construct is encountered. </p> <p><strong>See also:</strong> <code><a href="#analyze_export_attribute-1">analyze_export_attribute/1</a></code>, <code><a href="#analyze_function-1">analyze_function/1</a></code>, <code><a href="#analyze_import_attribute-1">analyze_import_attribute/1</a></code>, <code><a href="#analyze_record_attribute-1">analyze_record_attribute/1</a></code>, <code><a href="#analyze_wild_attribute-1">analyze_wild_attribute/1</a></code>, <code><a href="erl_syntax.html#error_marker_info-1">erl_syntax:error_marker_info/1</a></code>, <code><a href="erl_syntax.html#warning_marker_info-1">erl_syntax:warning_marker_info/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_function-1" class="title-link">  <div class="title-name">analyze_function(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; {atom(), arity()}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_function-1">Returns the name and arity of a function definition. The result is a pair <code>{Name, A}</code> if <code>Node</code> represents a function definition "<code>Name(P_1, ..., P_A) -&gt; ...</code>".</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed function definition.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_function_name-1" class="title-link">  <div class="title-name">analyze_function_name(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; <code><a href="#type-functionName">functionName()</a></code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_function_name-1">Returns the function name represented by a syntax tree. If <code>Node</code> represents a function name, such as "<code>foo/1</code>" or "<code>bloggs:fred/2</code>", a uniform representation of that name is returned. Different nestings of arity and module name qualifiers in the syntax tree does not affect the result.</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed function name.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_implicit_fun-1" class="title-link">  <div class="title-name">analyze_implicit_fun(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; <code><a href="#type-functionName">functionName()</a></code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_implicit_fun-1">Returns the name of an implicit fun expression "<code>fun F</code>". The result is a representation of the function name <code>F</code>. (Cf. <code>analyze_function_name/1</code>.)</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed implicit fun. </p> <p><strong>See also:</strong> <code><a href="#analyze_function_name-1">analyze_function_name/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_import_attribute-1" class="title-link">  <div class="title-name">analyze_import_attribute(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; {atom(), [<code><a href="#type-functionName">functionName()</a></code>]} | atom()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_import_attribute-1">Returns the module name and (if present) list of function names declared by an import attribute. The returned value is an atom <code>Module</code> or a pair <code>{Module, Names}</code>, where <code>Names</code> is a list of function names declared as imported from the module named by <code>Module</code>. We do not guarantee that each name occurs at most once in <code>Names</code>. The order of listing is not defined.</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed import attribute. </p> <p><strong>See also:</strong> <code><a href="#analyze_attribute-1">analyze_attribute/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_module_attribute-1" class="title-link">  <div class="title-name">analyze_module_attribute(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; atom() | {atom(), [atom()]}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_module_attribute-1">Returns the module name and possible parameters declared by a module attribute. If the attribute is a plain module declaration such as <code>-module(name)</code>, the result is the module name. If the attribute is a parameterized module declaration, the result is a tuple containing the module name and a list of the parameter variable names.</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed module attribute. </p> <p><strong>See also:</strong> <code><a href="#analyze_attribute-1">analyze_attribute/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_record_attribute-1" class="title-link">  <div class="title-name">analyze_record_attribute(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; {atom(), <code><a href="#type-fields">fields()</a></code>}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_record_attribute-1">Returns the name and the list of fields of a record declaration attribute. The result is a pair <code>{Name, Fields}</code>, if <code>Node</code> represents "<code>-record(Name, {...}).</code>", where <code>Fields</code> is a list of pairs <code>{Label, {Default, Type}}</code> for each field "<code>Label</code>", "<code>Label = Default</code>", "<code>Label :: Type</code>", or "<code>Label = Default :: Type</code>" in the declaration, listed in left-to-right order. If the field has no default-value declaration, the value for <code>Default</code> will be the atom <code>none</code>. If the field has no type declaration, the value for <code>Type</code> will be the atom <code>none</code>. We do not guarantee that each label occurs at most once in the list.</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed record declaration attribute. </p> <p><strong>See also:</strong> <code><a href="#analyze_attribute-1">analyze_attribute/1</a></code>, <code><a href="#analyze_record_field-1">analyze_record_field/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_record_expr-1" class="title-link">  <div class="title-name">analyze_record_expr(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; {atom(), <code><a href="#type-info">info()</a></code>} | atom()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_record_expr-1">Returns the record name and field name/names of a record expression. If <code>Node</code> has type <code>record_expr</code>, <code>record_index_expr</code> or <code>record_access</code>, a pair <code>{Type, Info}</code> is returned, otherwise an atom <code>Type</code> is returned. <code>Type</code> is the node type of <code>Node</code>, and <code>Info</code> depends on <code>Type</code>, as follows: </p> <dl> <dt class="title-link"><strong><code>record_expr</code>:</strong></dt> <dd><p><code>{atom(), [{atom(), Value}]}</code></p></dd> <dt class="title-link"><strong><code>record_access</code>:</strong></dt> <dd><p><code>{atom(), atom()}</code></p></dd> <dt class="title-link"><strong><code>record_index_expr</code>:</strong></dt> <dd><p><code>{atom(), atom()}</code></p></dd> </dl>  <p>For a <code>record_expr</code> node, <code>Info</code> represents the record name and the list of descriptors for the involved fields, listed in the order they appear. A field descriptor is a pair <code>{Label, Value}</code>, if <code>Node</code> represents "<code>Label = Value</code>". For a <code>record_access</code> node, <code>Info</code> represents the record name and the field name. For a <code>record_index_expr</code> node, <code>Info</code> represents the record name and the name field name.</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> represents a record expression that is not well-formed. </p> <p><strong>See also:</strong> <code><a href="#analyze_record_attribute-1">analyze_record_attribute/1</a></code>, <code><a href="#analyze_record_field-1">analyze_record_field/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_record_field-1" class="title-link">  <div class="title-name">analyze_record_field(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; <code><a href="#type-field">field()</a></code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_record_field-1">Returns the label, value-expression, and type of a record field specifier. The result is a pair <code>{Label, {Default, Type}}</code>, if <code>Node</code> represents "<code>Label</code>", "<code>Label = Default</code>", "<code>Label :: Type</code>", or "<code>Label = Default :: Type</code>". If the field has no value-expression, the value for <code>Default</code> will be the atom <code>none</code>. If the field has no type, the value for <code>Type</code> will be the atom <code>none</code>.</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed record field specifier. </p> <p><strong>See also:</strong> <code><a href="#analyze_record_attribute-1">analyze_record_attribute/1</a></code>, <code><a href="#analyze_record_expr-1">analyze_record_expr/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_type_application-1" class="title-link">  <div class="title-name">analyze_type_application(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; <code><a href="#type-typeName">typeName()</a></code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_type_application-1">Returns the name of a used type. The result is a representation of the name of the used pre-defined or local type <code>N/A</code>, if <code>Node</code> represents a local (user) type application "<code>N(T_1, ..., T_A)</code>", or a representation of the name of the used remote type <code>M:N/A</code> if <code>Node</code> represents a remote user type application "<code>M:N(T_1, ..., T_A)</code>".</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed (user) type application expression. </p> <p><strong>See also:</strong> <code><a href="#analyze_type_name-1">analyze_type_name/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_type_name-1" class="title-link">  <div class="title-name">analyze_type_name(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; <code><a href="#type-typeName">typeName()</a></code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_type_name-1">Returns the type name represented by a syntax tree. If <code>Node</code> represents a type name, such as "<code>foo/1</code>" or "<code>bloggs:fred/2</code>", a uniform representation of that name is returned.</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed type name.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="analyze_wild_attribute-1" class="title-link">  <div class="title-name">analyze_wild_attribute(Node::<code>erl_syntax:syntaxTree()</code>) -&gt; {atom(), term()}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="analyze_wild_attribute-1">Returns the name and value of a "wild" attribute. The result is the pair <code>{Name, Value}</code>, if <code>Node</code> represents "<code>-Name(Value)</code>".</p> <p>Note that no checking is done whether <code>Name</code> is a reserved attribute name such as <code>module</code> or <code>export</code>: it is assumed that the attribute is "wild".</p> <p>The evaluation throws <code>syntax_error</code> if <code>Node</code> does not represent a well-formed wild attribute. </p> <p><strong>See also:</strong> <code><a href="#analyze_attribute-1">analyze_attribute/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="annotate_bindings-1" class="title-link">  <div class="title-name">annotate_bindings(Tree::<code>erl_syntax:syntaxTree()</code>) -&gt; <code>erl_syntax:syntaxTree()</code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="annotate_bindings-1">Adds or updates annotations on nodes in a syntax tree. Equivalent to <code>annotate_bindings(Tree, Bindings)</code> where the top-level environment <code>Bindings</code> is taken from the annotation <code>{env, Bindings}</code> on the root node of <code>Tree</code>. An exception is thrown if no such annotation should exist. </p> <p><strong>See also:</strong> <code><a href="#annotate_bindings-2">annotate_bindings/2</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="annotate_bindings-2" class="title-link">  <div class="title-name">annotate_bindings(Tree::<code>erl_syntax:syntaxTree()</code>, Env::<code>ordsets:ordset(atom())</code>) -&gt; <code>erl_syntax:syntaxTree()</code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="annotate_bindings-2">Adds or updates annotations on nodes in a syntax tree. <code>Bindings</code> specifies the set of bound variables in the environment of the top level node. The following annotations are affected: </p> <ul> <li><p><code>{env, Vars}</code>, representing the input environment of the subtree.</p></li> <li><p><code>{bound, Vars}</code>, representing the variables that are bound in the subtree.</p></li> <li><p><code>{free, Vars}</code>, representing the free variables in the subtree.</p></li> </ul> <p> <code>Bindings</code> and <code>Vars</code> are ordered-set lists (cf. module <code>ordsets</code>) of atoms representing variable names. </p> <p><strong>See also:</strong> <code>ordsets(3)</code>, <code><a href="#annotate_bindings-1">annotate_bindings/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="fold-2" class="title-link">  <div class="title-name">fold(F::(<code>erl_syntax:syntaxTree()</code>, term()) -&gt; term(), S::term(), Tree::<code>erl_syntax:syntaxTree()</code>) -&gt; term()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="fold-3">Folds a function over all nodes of a syntax tree. The result is the value of <code>Function(X1, Function(X2, ... Function(Xn, Start) ... ))</code>, where <code>[X1, X2, ..., Xn]</code> are the nodes of <code>Tree</code> in a post-order traversal. </p> <p><strong>See also:</strong> <code><a href="#fold_subtrees-3">fold_subtrees/3</a></code>, <code><a href="#foldl_listlist-3">foldl_listlist/3</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="fold_subtrees-2" class="title-link">  <div class="title-name">fold_subtrees(F::(<code>erl_syntax:syntaxTree()</code>, term()) -&gt; term(), S::term(), Tree::<code>erl_syntax:syntaxTree()</code>) -&gt; term()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="fold_subtrees-3">Folds a function over the immediate subtrees of a syntax tree. This is similar to <code>fold/3</code>, but only on the immediate subtrees of <code>Tree</code>, in left-to-right order; it does not include the root node of <code>Tree</code>. </p> <p><strong>See also:</strong> <code><a href="#fold-3">fold/3</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="foldl_listlist-2" class="title-link">  <div class="title-name">foldl_listlist(F::(term(), term()) -&gt; term(), S::term(), Ls::[[term()]]) -&gt; term()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="foldl_listlist-3">Like <code>lists:foldl/3</code>, but over a list of lists. </p> <p><strong>See also:</strong> <code>lists:foldl/3</code>, <code><a href="#fold-3">fold/3</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="function_name_expansions-1" class="title-link">  <div class="title-name">function_name_expansions(Fs::[<code><a href="#type-name">name()</a></code>]) -&gt; [{<code><a href="#type-shortname">shortname()</a></code>, <code><a href="#type-name">name()</a></code>}]</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="function_name_expansions-1">Creates a mapping from corresponding short names to full function names. Names are represented by nested tuples of atoms and integers (cf. <code>analyze_function_name/1</code>). The result is a list containing a pair <code>{ShortName, Name}</code> for each element <code>Name</code> in the given list, where the corresponding <code>ShortName</code> is the rightmost-innermost part of <code>Name</code>. The list thus represents a finite mapping from unqualified names to the corresponding qualified names.</p> <p>Note: the resulting list can contain more than one tuple <code>{ShortName, Name}</code> for the same <code>ShortName</code>, possibly with different values for <code>Name</code>, depending on the given list. </p> <p><strong>See also:</strong> <code><a href="#analyze_function_name-1">analyze_function_name/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="is_fail_expr-1" class="title-link">  <div class="title-name">is_fail_expr(E::<code>erl_syntax:syntaxTree()</code>) -&gt; boolean()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="is_fail_expr-1">Returns <code>true</code> if <code>Tree</code> represents an expression which never terminates normally. Note that the reverse does not apply. Currently, the detected cases are calls to <code>exit/1</code>, <code>throw/1</code>, <code>erlang:error/1</code> and <code>erlang:error/2</code>. </p> <p><strong>See also:</strong> <code>erlang:error/1</code>, <code>erlang:error/2</code>, <code>erlang:exit/1</code>, <code>erlang:throw/1</code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="limit-2" class="title-link">  <div class="title-name">limit(Tree::<code>erl_syntax:syntaxTree()</code>, Depth::integer()) -&gt; <code>erl_syntax:syntaxTree()</code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="limit-2">Equivalent to <code>limit(Tree, Depth, Text)</code> using the text <code>"..."</code> as default replacement. </p> <p><strong>See also:</strong> <code><a href="#limit-3">limit/3</a></code>, <code><a href="erl_syntax.html#text-1">erl_syntax:text/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="limit-3" class="title-link">  <div class="title-name">limit(Tree::<code>erl_syntax:syntaxTree()</code>, Depth::integer(), Node::<code>erl_syntax:syntaxTree()</code>) -&gt; <code>erl_syntax:syntaxTree()</code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="limit-3">Limits a syntax tree to a specified depth. Replaces all non-leaf subtrees in <code>Tree</code> at the given <code>Depth</code> by <code>Node</code>. If <code>Depth</code> is negative, the result is always <code>Node</code>, even if <code>Tree</code> has no subtrees.</p> <p>When a group of subtrees (as e.g., the argument list of an <code>application</code> node) is at the specified depth, and there are two or more subtrees in the group, these will be collectively replaced by <code>Node</code> even if they are leaf nodes. Groups of subtrees that are above the specified depth will be limited in size, as if each subsequent tree in the group were one level deeper than the previous. E.g., if <code>Tree</code> represents a list of integers "<code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>", the result of <code>limit(Tree, 5)</code> will represent <code>[1, 2, 3, 4, ...]</code>.</p> <p>The resulting syntax tree is typically only useful for pretty-printing or similar visual formatting. </p> <p><strong>See also:</strong> <code><a href="#limit-2">limit/2</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="map-1" class="title-link">  <div class="title-name">map(F::(<code>erl_syntax:syntaxTree()</code>) -&gt; <code>erl_syntax:syntaxTree()</code>, Tree::<code>erl_syntax:syntaxTree()</code>) -&gt; <code>erl_syntax:syntaxTree()</code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="map-2">Applies a function to each node of a syntax tree. The result of each application replaces the corresponding original node. The order of traversal is bottom-up. </p> <p><strong>See also:</strong> <code><a href="#map_subtrees-2">map_subtrees/2</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="map_subtrees-1" class="title-link">  <div class="title-name">map_subtrees(F::(<code>erl_syntax:syntaxTree()</code>) -&gt; <code>erl_syntax:syntaxTree()</code>, Tree::<code>erl_syntax:syntaxTree()</code>) -&gt; <code>erl_syntax:syntaxTree()</code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="map_subtrees-2">Applies a function to each immediate subtree of a syntax tree. The result of each application replaces the corresponding original node. </p> <p><strong>See also:</strong> <code><a href="#map-2">map/2</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="mapfold-2" class="title-link">  <div class="title-name">mapfold(F::(<code>erl_syntax:syntaxTree()</code>, term()) -&gt; {<code>erl_syntax:syntaxTree()</code>, term()}, S::term(), Tree::<code>erl_syntax:syntaxTree()</code>) -&gt; {<code>erl_syntax:syntaxTree()</code>, term()}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="mapfold-3">Combines map and fold in a single operation. This is similar to <code>map/2</code>, but also propagates an extra value from each application of the <code>Function</code> to the next, while doing a post-order traversal of the tree like <code>fold/3</code>. The value <code>Start</code> is passed to the first function application, and the final result is the result of the last application. </p> <p><strong>See also:</strong> <code><a href="#fold-3">fold/3</a></code>, <code><a href="#map-2">map/2</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="mapfold_subtrees-2" class="title-link">  <div class="title-name">mapfold_subtrees(F::(<code>erl_syntax:syntaxTree()</code>, term()) -&gt; {<code>erl_syntax:syntaxTree()</code>, term()}, S::term(), Tree::<code>erl_syntax:syntaxTree()</code>) -&gt; {<code>erl_syntax:syntaxTree()</code>, term()}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="mapfold_subtrees-3">Does a mapfold operation over the immediate subtrees of a syntax tree. This is similar to <code>mapfold/3</code>, but only on the immediate subtrees of <code>Tree</code>, in left-to-right order; it does not include the root node of <code>Tree</code>. </p> <p><strong>See also:</strong> <code><a href="#mapfold-3">mapfold/3</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="mapfoldl_listlist-2" class="title-link">  <div class="title-name">mapfoldl_listlist(F::(term(), term()) -&gt; {term(), term()}, S::term(), Ls::[[term()]]) -&gt; {[[term()]], term()}</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="mapfoldl_listlist-3">Like <code>lists:mapfoldl/3</code>, but over a list of lists. The list of lists in the result has the same structure as the given list of lists.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="new_variable_name-1" class="title-link">  <div class="title-name">new_variable_name(S::<code>sets:set(atom())</code>) -&gt; atom()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="new_variable_name-1">Returns an atom which is not already in the set <code>Used</code>. This is equivalent to <code>new_variable_name(Function, Used)</code>, where <code>Function</code> maps a given integer <code>N</code> to the atom whose name consists of "<code>V</code>" followed by the numeral for <code>N</code>. </p> <p><strong>See also:</strong> <code><a href="#new_variable_name-2">new_variable_name/2</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="new_variable_name-1" class="title-link">  <div class="title-name">new_variable_name(F::(integer()) -&gt; atom(), S::<code>sets:set(atom())</code>) -&gt; atom()</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="new_variable_name-2">Returns a user-named atom which is not already in the set <code>Used</code>. The atom is generated by applying the given <code>Function</code> to a generated integer. Integers are generated using an algorithm which tries to keep the names randomly distributed within a reasonably small range relative to the number of elements in the set.</p> <p>This function uses the module <code>rand</code> to generate new keys. The seed it uses may be initialized by calling <code>rand:seed/1</code> or <code>rand:seed/2</code> before this function is first called. </p> <p><strong>See also:</strong> <code>random(3)</code>, <code>sets(3)</code>, <code><a href="#new_variable_name-1">new_variable_name/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="new_variable_names-2" class="title-link">  <div class="title-name">new_variable_names(N::integer(), S::<code>sets:set(atom())</code>) -&gt; [atom()]</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="new_variable_names-2">Like <code>new_variable_name/1</code>, but generates a list of <code>N</code> new names. </p> <p><strong>See also:</strong> <code><a href="#new_variable_name-1">new_variable_name/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="new_variable_names-2" class="title-link">  <div class="title-name">new_variable_names(N::integer(), F::(integer()) -&gt; atom(), S::<code>sets:set(atom())</code>) -&gt; [atom()]</div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="new_variable_names-3">Like <code>new_variable_name/2</code>, but generates a list of <code>N</code> new names. </p> <p><strong>See also:</strong> <code><a href="#new_variable_name-2">new_variable_name/2</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="strip_comments-1" class="title-link">  <div class="title-name">strip_comments(Tree::<code>erl_syntax:syntaxTree()</code>) -&gt; <code>erl_syntax:syntaxTree()</code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="strip_comments-1">Removes all comments from all nodes of a syntax tree. All other attributes (such as position information) remain unchanged. Standalone comments in form lists are removed; any other standalone comments are changed into null-comments (no text, no indentation).</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="to_comment-1" class="title-link">  <div class="title-name">to_comment(Tree::<code>erl_syntax:syntaxTree()</code>) -&gt; <code>erl_syntax:syntaxTree()</code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="to_comment-1">Equivalent to <code><a href="#to_comment-2">to_comment(Tree, "% ")</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="to_comment-2" class="title-link">  <div class="title-name">to_comment(Tree::<code>erl_syntax:syntaxTree()</code>, Prefix::string()) -&gt; <code>erl_syntax:syntaxTree()</code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="to_comment-2">Equivalent to <code>to_comment(Tree, Prefix, F)</code> for a default formatting function <code>F</code>. The default <code>F</code> simply calls <code>erl_prettypr:format/1</code>. </p> <p><strong>See also:</strong> <code><a href="#to_comment-3">to_comment/3</a></code>, <code><a href="erl_prettypr.html#format-1">erl_prettypr:format/1</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="to_comment-3" class="title-link">  <div class="title-name">to_comment(Tree::<code>erl_syntax:syntaxTree()</code>, Prefix::string(), F::(<code>erl_syntax:syntaxTree()</code>) -&gt; string()) -&gt; <code>erl_syntax:syntaxTree()</code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="to_comment-3">Transforms a syntax tree into an abstract comment. The lines of the comment contain the text for <code>Node</code>, as produced by the given <code>Printer</code> function. Each line of the comment is prefixed by the string <code>Prefix</code> (this does not include the initial "<code>%</code>" character of the comment line).</p> <p>For example, the result of <code>to_comment(erl_syntax:abstract([a,b,c]))</code> represents </p> <pre data-language="erlang">
%% [a,b,c]</pre> <p> (cf. <code>to_comment/1</code>).</p> <p>Note: the text returned by the formatting function will be split automatically into separate comment lines at each line break. No extra work is needed. </p> <p><strong>See also:</strong> <code><a href="#to_comment-1">to_comment/1</a></code>, <code><a href="#to_comment-2">to_comment/2</a></code>.</p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="variables-1" class="title-link">  <div class="title-name">variables(Tree::<code>erl_syntax:syntaxTree()</code>) -&gt; <code>sets:set(atom())</code> </div> </h3></div> <div class="exports-tube"><div class="REFBODY rb-7">  <p id="variables-1">Returns the names of variables occurring in a syntax tree, The result is a set of variable names represented by atoms. Macro names are not included. </p> <p><strong>See also:</strong> <code>sets(3)</code>.</p> </div></div></article> </div> Richard Carlsson carlsson.richard@gmail.com<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
