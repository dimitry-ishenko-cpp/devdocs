  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">diameter_codec</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Decode and encode of Diameter messages.</div> <h2 id="since" class="title-link"> <div class="title-name">Since</div>  </h2> <div class="REFBODY module-since"> Module diameter_codec was introduced in OTP R15B03. </div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p> Incoming Diameter messages are decoded from binary() before being communicated to <code><span>diameter_app(3)</span></code> callbacks. Similarly, outgoing Diameter messages are encoded into binary() before being passed to the appropriate <code><a href="diameter_transport.html">diameter_transport(3)</a></code> module for transmission. The functions documented here implement the default encode/decode.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> The diameter user does not need to call functions here explicitly when sending and receiving messages using <code><a href="diameter.html#call-4">diameter:call/4</a></code> and the callback interface documented in <code><span>diameter_app(3)</span></code>: diameter itself provides encode/decode as a consequence of configuration passed to <code><a href="diameter.html#start_service-2">diameter:start_service/2</a></code>, and the results may differ from those returned by the functions documented here, depending on configuration.</p> </div> </div> <p> The <code><a href="#header">header()</a></code> and <code><a href="#packet">packet()</a></code> records below are defined in diameter.hrl, which can be included as follows.</p> <pre data-language="erlang">
-include_lib("diameter/include/diameter.hrl").
</pre> <p> Application-specific records are defined in the hrl files resulting from dictionary file compilation.</p> </div> </div></section> <section class="innertube"><h2 id="data-types" class="title-link"> data types  </h2> <div class="REFBODY rb-3">  <dl> <dt class="title-link"><strong> <code id="integers">uint8() = 0..255</code></strong></dt>  <dt class="title-link"><strong><code>uint24() = 0..16777215</code></strong></dt>  <dt class="title-link"><strong><code>uint32() = 0..4294967295</code></strong></dt> <dd> <p> 8-bit, 24-bit and 32-bit integers occurring in Diameter and AVP headers.</p> </dd> <dt class="title-link"><strong> <code id="avp">avp() = #diameter_avp{}</code></strong></dt> <dd> <p> The application-neutral representation of an AVP. Primarily intended for use by relay applications that need to handle arbitrary Diameter applications. A service implementing a specific Diameter application (for which it configures a dictionary) can manipulate values of type <code><a href="#message">message()</a></code> instead.</p> <p> Fields have the following types.</p> <dl> <dt class="title-link"><strong><code>code = uint32()</code></strong></dt>  <dt class="title-link"><strong><code>is_mandatory = boolean()</code></strong></dt>  <dt class="title-link"><strong><code>need_encryption = boolean()</code></strong></dt>  <dt class="title-link"><strong><code>vendor_id = uint32() | undefined</code></strong></dt> <dd> <p> Values in the AVP header, corresponding to AVP Code, the M flag, P flags and Vendor-ID respectively. A Vendor-ID other than <code>undefined</code> implies a set V flag.</p> </dd> <dt class="title-link"><strong><code>data = iolist()</code></strong></dt> <dd> <p> The data bytes of the AVP.</p> </dd> <dt class="title-link"><strong><code>name = atom()</code></strong></dt> <dd> <p> The name of the AVP as defined in the dictionary file in question, or <code>undefined</code> if the AVP is unknown to the dictionary file in question.</p> </dd> <dt class="title-link"><strong><code>value = term()</code></strong></dt> <dd> <p> The decoded value of an AVP. Will be <code>undefined</code> on decode if the data bytes could not be decoded, the AVP is unknown, or if the <code><a href="diameter.html#decode_format">decode format</a></code> is <code>none</code>. The type of a decoded value is as document in <code><a href="diameter_dict.html#DATA_TYPES">diameter_dict(4)</a></code>.</p> </dd> <dt class="title-link"><strong><code>type = atom()</code></strong></dt> <dd> <p> The type of the AVP as specified in the dictionary file in question (or one it inherits). Possible types are <code>undefined</code> and the Diameter types: <code>OctetString</code>, <code>Integer32</code>, <code>Integer64</code>, <code>Unsigned32</code>, <code>Unsigned64</code>, <code>Float32</code>, <code>Float64</code>, <code>Grouped</code>, <code>Enumerated</code>, <code>Address</code>, <code>Time</code>, <code>UTF8String</code>, <code>DiameterIdentity</code>, <code>DiameterURI</code>, <code>IPFilterRule</code> and <code>QoSFilterRule</code>.</p> </dd> </dl> </dd> <dt class="title-link"><strong> <code id="dictionary">dictionary() = module()</code></strong></dt> <dd> <p> The name of a generated dictionary module as generated by <code><a href="diameterc.html">diameterc(1)</a></code> or <code><a href="diameter_make.html#codec-2">diameter_make:codec/2</a></code>. The interface provided by a dictionary module is an implementation detail that may change.</p> </dd> <dt class="title-link"><strong> <code id="header">header() = #diameter_header{}</code></strong></dt> <dd> <p> The record representation of the Diameter header. Values in a <code><a href="#packet">packet()</a></code> returned by <code><a href="#decode-2">decode/2</a></code> are as extracted from the incoming message. Values set in an <code><a href="#packet">packet()</a></code> passed to <code><a href="#encode-2">encode/2</a></code> are preserved in the encoded binary(), with the exception of <code>length</code>, <code>cmd_code</code> and <code>application_id</code>, all of which are determined by the <code><a href="#dictionary">dictionary()</a></code> in question.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> It is not necessary to set header fields explicitly in outgoing messages as diameter itself will set appropriate values. Setting inappropriate values can be useful for test purposes.</p> </div> </div> <p> Fields have the following types.</p> <dl> <dt class="title-link"><strong><code>version = uint8()</code></strong></dt>  <dt class="title-link"><strong><code>length = uint24()</code></strong></dt>  <dt class="title-link"><strong><code>cmd_code = uint24()</code></strong></dt>  <dt class="title-link"><strong><code>application_id = uint32()</code></strong></dt>  <dt class="title-link"><strong><code>hop_by_hop_id = uint32()</code></strong></dt>  <dt class="title-link"><strong><code>end_to_end_id = uint32()</code></strong></dt> <dd> <p> Values of the Version, Message Length, Command-Code, Application-ID, Hop-by-Hop Identifier and End-to-End Identifier fields of the Diameter header.</p> </dd> <dt class="title-link"><strong><code>is_request = boolean()</code></strong></dt>  <dt class="title-link"><strong><code>is_proxiable = boolean()</code></strong></dt>  <dt class="title-link"><strong><code>is_error = boolean()</code></strong></dt>  <dt class="title-link"><strong><code>is_retransmitted = boolean()</code></strong></dt> <dd> <p> Values corresponding to the R(equest), P(roxiable), E(rror) and T(Potentially re-transmitted message) flags of the Diameter header.</p> </dd> </dl> </dd> <dt class="title-link"><strong> <code id="message">message() = record() | maybe_improper_list()</code></strong></dt> <dd> <p> The representation of a Diameter message as passed to <code><a href="diameter.html#call-4">diameter:call/4</a></code> or returned from a <code><span>handle_request/3</span></code> callback. The record representation is as outlined in <code><a href="diameter_dict.html#MESSAGE_RECORDS">diameter_dict(4)</a></code>: a message as defined in a dictionary file is encoded as a record with one field for each component AVP. Equivalently, a message can also be encoded as a list whose head is the atom-valued message name (as specified in the relevant dictionary file) and whose tail is either a list of AVP name/values pairs or a map with values keyed on AVP names. The format at decode is determined by <code><a href="diameter.html#service_opt">diameter:service_opt()</a></code> <code><a href="diameter.html#decode_format">decode_format</a></code>. Any of the formats is accepted at encode.</p> <p> Another list-valued representation allows a message to be specified as a list whose head is a <code><a href="#header">header()</a></code> and whose tail is an <code><a href="#avp">avp()</a></code> list. This representation is used by diameter itself when relaying requests as directed by the return value of a <code><span>handle_request/3</span></code> callback. It differs from the other two in that it bypasses the checks for messages that do not agree with their definitions in the dictionary in question: messages are sent exactly as specified.</p> </dd> <dt class="title-link"><strong> <code id="packet">packet() = #diameter_packet{}</code></strong></dt> <dd> <p> A container for incoming and outgoing Diameter messages. Fields have the following types.</p> <dl> <dt class="title-link"><strong><code>header = <code><a href="#header">header()</a></code> | undefined</code></strong></dt> <dd> <p> The Diameter header of the message. Can be (and typically should be) <code>undefined</code> for an outgoing message in a non-relay application, in which case diameter provides appropriate values.</p> </dd> <dt class="title-link"><strong><code>avps = [<code><a href="#avp">avp()</a></code>] | undefined</code></strong></dt> <dd> <p> The AVPs of the message. Ignored for an outgoing message if the <code>msg</code> field is set to a value other than <code>undefined</code>.</p> </dd> <dt class="title-link"><strong><code>msg = <code><a href="#message">message()</a></code> | undefined</code></strong></dt> <dd> <p> The incoming/outgoing message. For an incoming message, a term corresponding to the configured <code><a href="diameter.html#decode_format">decode format</a></code> if the message can be decoded in a non-relay application, <code>undefined</code> otherwise. For an outgoing message, setting a <code>[<code><a href="#header">header()</a></code> | <code><a href="#avp">avp()</a></code>]</code> list is equivalent to setting the <code>header</code> and <code>avps</code> fields to the corresponding values.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> A value in the <code>msg</code> field does <strong>not</strong> imply an absence of decode errors. The <code>errors</code> field should also be examined.</p> </div> </div> </dd> <dt class="title-link"><strong><code>bin = binary()</code></strong></dt> <dd> <p> The incoming message prior to encode or the outgoing message after encode.</p> </dd> <dt class="title-link"><strong><code>errors = [5000..5999 | {5000..5999, avp()}]</code></strong></dt> <dd> <p> Errors detected at decode of an incoming message, as identified by a corresponding 5xxx series Result-Code (Permanent Failures). For an incoming request, these should be used to formulate an appropriate answer as documented for the <code><span>handle_request/3</span></code> callback in <code><span>diameter_app(3)</span></code>. For an incoming answer, the <code><a href="diameter.html#application_opt">diameter:application_opt()</a></code> <code>answer_errors</code> determines the behaviour.</p> </dd> <dt class="title-link"><strong><code>transport_data = term()</code></strong></dt> <dd> <p> An arbitrary term of meaning only to the transport process in question, as documented in <code><a href="diameter_transport.html">diameter_transport(3)</a></code>.</p> </dd> </dl> </dd> </dl> </div></section> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><div class="bold_code func-head"><h3 id="decode-2" class="title-link">  <div class="title-name">decode(Mod, Bin) -&gt; Pkt</div> <div class="title-since"><span class="since">OTP R15B03</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Mod = <a href="#dictionary">dictionary()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Bin = binary()</code><br> </div> <div class="REFTYPES rt-4"> <code>Pkt = <a href="#packet">packet()</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p> Decode a Diameter message.</p> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="encode-2" class="title-link">  <div class="title-name">encode(Mod, Msg) -&gt; Pkt</div> <div class="title-since"><span class="since">OTP R15B03</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Mod = <a href="#dictionary">dictionary()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Msg = <a href="#message">message()</a> | <a href="#packet">packet()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Pkt = <a href="#packet">packet()</a></code><br> </div> </div> <div class="REFBODY rb-7"> <p> Encode a Diameter message. </p> </div> </div></article> </div> <section class="innertube"><h2 id="see-also" class="title-link"> see also  </h2> <div class="REFBODY rb-3"> <p> <code><a href="diameterc.html">diameterc(1)</a></code>, <code><span>diameter_app(3)</span></code>, <code><a href="diameter_dict.html">diameter_dict(4)</a></code>, <code><a href="diameter_make.html">diameter_make(3)</a></code></p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
