<div class="innertube"> <h1 id="FIPS mode">2 FIPS mode</h1> <h3 id="fips">  This chapter describes FIPS mode support in the crypto application. </h3> <h2 id="background" class="title-link"> <div class="title-name">2.1 Background</div>  </h2> <p>OpenSSL can be built to provide FIPS 140-2 validated cryptographic services. It is not the OpenSSL application that is validated, but a special software component called the OpenSSL FIPS Object Module. However applications do not use this Object Module directly, but through the regular API of the OpenSSL library.</p> <p>The crypto application supports using OpenSSL in FIPS mode. In this scenario only the validated algorithms provided by the Object Module are accessible, other algorithms usually available in OpenSSL (like md5) or implemented in the Erlang code (like SRP) are disabled.</p> <h2 id="enabling-fips-mode" class="title-link"> <div class="title-name">2.2 Enabling FIPS mode</div>  </h2> <ol> <li> <p>Build or install the FIPS Object Module and a FIPS enabled OpenSSL library.</p> <p>You should read and precisely follow the instructions of the <code><a href="http://csrc.nist.gov/groups/STM/cmvp/documents/140-1/140sp/140sp1747.pdf">Security Policy</a></code> and <code><a href="https://www.openssl.org/docs/fips/UserGuide-2.0.pdf">User Guide</a></code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>It is very easy to build a working OpenSSL FIPS Object Module and library from the source. However it <strong>does not</strong> qualify as FIPS 140-2 validated if the numerous restrictions in the Security Policy are not properly followed.</p>
</div> </div> </li> <li> <p>Configure and build Erlang/OTP with FIPS support:</p> <pre data-language="erlang">
$ <code>cd $ERL_TOP</code>
$ <code>./otp_build configure --enable-fips</code>
...
checking for FIPS_mode_set... yes
...
$ <code>make</code>
        </pre> <p>If <code>FIPS_mode_set</code> returns <code>no</code> the OpenSSL library is not FIPS enabled and crypto won't support FIPS mode either.</p> </li> <li> <p>Set the <code>fips_mode</code> configuration setting of the crypto application to <code>true</code> <strong>before loading the crypto module</strong>.</p> <p>The best place is in the <code>sys.config</code> system configuration file of the release.</p> </li> <li> Start and use the crypto application as usual. However take care to avoid the non-FIPS validated algorithms, they will all throw exception <code>not_supported</code>. </li> </ol> <p>Entering and leaving FIPS mode on a node already running crypto is not supported. The reason is that OpenSSL is designed to prevent an application requesting FIPS mode to end up accidentally running in non-FIPS mode. If entering FIPS mode fails (e.g. the Object Module is not found or is compromised) any subsequent use of the OpenSSL API would terminate the emulator.</p> <p>An on-the-fly FIPS mode change would thus have to be performed in a critical section protected from any concurrently running crypto operations. Furthermore in case of failure all crypto calls would have to be disabled from the Erlang or nif code. This would be too much effort put into this not too important feature.</p> <h2 id="incompatibilities-with-regular-builds" class="title-link"> <div class="title-name">2.3 Incompatibilities with regular builds</div>  </h2> <p>The Erlang API of the crypto application is identical regardless of building with or without FIPS support. However the nif code internally uses a different OpenSSL API.</p> <p>This means that the context (an opaque type) returned from streaming crypto functions (<code>hash_(init|update|final)</code>, <code>hmac_(init|update|final)</code> and <code>stream_(init|encrypt|decrypt)</code>) is different and incompatible with regular builds when compiling crypto with FIPS support.</p> <h2 id="common-caveats" class="title-link"> <div class="title-name">2.4 Common caveats</div>  </h2> <p>In FIPS mode non-validated algorithms are disabled. This may cause some unexpected problems in application relying on crypto.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Do not try to work around these problems by using alternative implementations of the missing algorithms! An application can only claim to be using a FIPS 140-2 validated cryptographic module if it uses it exclusively for every cryptographic operation.</p>
</div> </div> <h3 id="restrictions-on-key-sizes" class="title-link"> <div class="title-name">Restrictions on key sizes</div>  </h3> <p>Although public key algorithms are supported in FIPS mode they can only be used with secure key sizes. The Security Policy requires the following minimum values: </p> <dl> <dt class="title-link"><strong>RSA</strong></dt> <dd>1024 bit</dd> <dt class="title-link"><strong>DSS</strong></dt> <dd>1024 bit</dd> <dt class="title-link"><strong>EC algorithms</strong></dt> <dd>160 bit</dd> </dl> <h3 id="restrictions-on-elliptic-curves" class="title-link"> <div class="title-name">Restrictions on elliptic curves</div>  </h3> <p>The Erlang API allows using arbitrary curve parameters, but in FIPS mode only those allowed by the Security Policy shall be used.</p> <h3 id="avoid-md5-for-hashing" class="title-link"> <div class="title-name">Avoid md5 for hashing</div>  </h3> <p>Md5 is a popular choice as a hash function, but it is not secure enough to be validated. Try to use sha instead wherever possible.</p> <p>For exceptional, non-cryptographic use cases one may consider switching to <code>erlang:md5/1</code> as well.</p> <h3 id="certificates-and-encrypted-keys" class="title-link"> <div class="title-name">Certificates and encrypted keys</div>  </h3> <p>As md5 is not available in FIPS mode it is only possible to use certificates that were signed using sha hashing. When validating an entire certificate chain all certificates (including the root CA's) must comply with this rule.</p> <p>For similar dependency on the md5 and des algorithms most encrypted private keys in PEM format do not work either. However, the PBES2 encryption scheme allows the use of stronger FIPS verified algorithms which is a viable alternative.</p> <h3 id="snmp-v3-limitations" class="title-link"> <div class="title-name">SNMP v3 limitations</div>  </h3> <p>It is only possible to use <code>usmHMACSHAAuthProtocol</code> and <code>usmAesCfb128Protocol</code> for authentication and privacy respectively in FIPS mode. The snmp application however won't restrict selecting disabled protocols in any way, and using them would result in run time crashes.</p> <h3 id="tls-1.2-is-required" class="title-link"> <div class="title-name">TLS 1.2 is required</div>  </h3> <p>All SSL and TLS versions prior to TLS 1.2 use a combination of md5 and sha1 hashes in the handshake for various purposes:</p> <ul> <li>Authenticating the integrity of the handshake messages.</li> <li>In the exchange of DH parameters in cipher suites providing non-anonymous PFS (perfect forward secrecy).</li> <li>In the PRF (pseud-random function) to generate keying materials in cipher suites not using PFS.</li> </ul> <p>OpenSSL handles these corner cases in FIPS mode, however the Erlang crypto and ssl applications are not prepared for them and therefore you are limited to TLS 1.2 in FIPS mode.</p> <p>On the other hand it worth mentioning that at least all cipher suites that would rely on non-validated algorithms are automatically disabled in FIPS mode.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Certificates using weak (md5) digests may also cause problems in TLS. Although TLS 1.2 has an extension for specifying which type of signatures are accepted, and in FIPS mode the ssl application will use it properly, most TLS implementations ignore this extension and simply send whatever certificates they were configured with.</p>
</div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
