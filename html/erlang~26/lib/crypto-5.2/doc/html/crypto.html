  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">crypto</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Crypto Functions</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module provides a set of cryptographic functions. </p> <dl> <dt class="title-link"><strong>Hash functions</strong></dt> <dd>  <dl> <dt class="title-link"><strong>SHA1, SHA2</strong></dt> <dd> <code><a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf"> Secure Hash Standard [FIPS PUB 180-4] </a></code> </dd> <dt class="title-link"><strong>SHA3</strong></dt> <dd> <code><a href="https://www.nist.gov/publications/sha-3-standard-permutation-based-hash-and-extendable-output-functions?pub_id=919061"> SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions [FIPS PUB 202] </a></code> </dd> <dt class="title-link"><strong>BLAKE2</strong></dt> <dd> <code><a href="https://blake2.net/">BLAKE2 â€” fast secure hashing</a></code> </dd> <dt class="title-link"><strong>MD5</strong></dt> <dd> <code><a href="http://www.ietf.org/rfc/rfc1321.txt">The MD5 Message Digest Algorithm [RFC 1321]</a></code> </dd> <dt class="title-link"><strong>MD4</strong></dt> <dd> <code><a href="http://www.ietf.org/rfc/rfc1320.txt">The MD4 Message Digest Algorithm [RFC 1320]</a></code> </dd> </dl>  </dd> <dt class="title-link"><strong>MACs - Message Authentication Codes</strong></dt> <dd>  <dl> <dt class="title-link"><strong>Hmac functions</strong></dt> <dd> <code><a href="http://www.ietf.org/rfc/rfc2104.txt"> Keyed-Hashing for Message Authentication [RFC 2104] </a></code> </dd> <dt class="title-link"><strong>Cmac functions</strong></dt> <dd> <code><a href="http://www.ietf.org/rfc/rfc4493.txt"> The AES-CMAC Algorithm [RFC 4493] </a></code> </dd> <dt class="title-link"><strong>POLY1305</strong></dt> <dd> <code><a href="http://www.ietf.org/rfc/rfc7539.txt"> ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] </a></code> </dd> </dl>  </dd> <dt class="title-link"><strong>Symmetric Ciphers</strong></dt> <dd>  <dl> <dt class="title-link"><strong>DES, 3DES and AES</strong></dt> <dd> <code><a href="https://csrc.nist.gov/projects/block-cipher-techniques">Block Cipher Techniques [NIST]</a></code> </dd> <dt class="title-link"><strong>Blowfish</strong></dt> <dd> <code><a href="https://www.schneier.com/academic/archives/1994/09/description_of_a_new.html"> Fast Software Encryption, Cambridge Security Workshop Proceedings (December 1993), Springer-Verlag, 1994, pp. 191-204. </a></code> </dd> <dt class="title-link"><strong>Chacha20</strong></dt> <dd> <code><a href="http://www.ietf.org/rfc/rfc7539.txt"> ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] </a></code> </dd> <dt class="title-link"><strong>Chacha20_poly1305</strong></dt> <dd> <code><a href="http://www.ietf.org/rfc/rfc7539.txt"> ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] </a></code> </dd> </dl>  </dd> <dt class="title-link"><strong>Modes</strong></dt> <dd>  <dl> <dt class="title-link"><strong>ECB, CBC, CFB, OFB and CTR</strong></dt> <dd> <code><a href="https://csrc.nist.gov/publications/detail/sp/800-38a/final"> Recommendation for Block Cipher Modes of Operation: Methods and Techniques [NIST SP 800-38A] </a></code> </dd> <dt class="title-link"><strong>GCM</strong></dt> <dd> <code><a href="https://csrc.nist.gov/publications/detail/sp/800-38d/final"> Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC [NIST SP 800-38D] </a></code> </dd> <dt class="title-link"><strong>CCM</strong></dt> <dd> <code><a href="https://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-38c.pdf"> Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality [NIST SP 800-38C] </a></code> </dd> </dl>  </dd> <dt class="title-link"><strong>Asymmetric Ciphers - Public Key Techniques</strong></dt> <dd>  <dl> <dt class="title-link"><strong>RSA</strong></dt> <dd> <code><a href="http://www.ietf.org/rfc/rfc3447.txt"> PKCS #1: RSA Cryptography Specifications [RFC 3447] </a></code> </dd> <dt class="title-link"><strong>DSS</strong></dt> <dd> <code><a href="https://csrc.nist.gov/publications/detail/fips/186/4/final"> Digital Signature Standard (DSS) [FIPS 186-4] </a></code> </dd> <dt class="title-link"><strong>ECDSA</strong></dt> <dd> <code><a href="http://csrc.nist.gov/groups/STM/cavp/documents/dss2/ecdsa2vs.pdf"> Elliptic Curve Digital Signature Algorithm [ECDSA] </a></code> </dd> <dt class="title-link"><strong>SRP</strong></dt> <dd> <code><a href="http://www.ietf.org/rfc/rfc2945.txt"> The SRP Authentication and Key Exchange System [RFC 2945] </a></code> </dd> </dl>  </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The actual supported algorithms and features depends on their availability in the actual libcrypto used. See the <code>crypto (App)</code> about dependencies. </p> <p>Enabling FIPS mode will also disable algorithms and features. </p> </div> </div> <p>The <code><a href="users_guide.html">CRYPTO User's Guide</a></code> has more information on FIPS, Engines and Algorithm Details like key lengths. </p> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <h3 id="Ciphers" class="title-link"> <div class="title-name">Ciphers</div>  </h3> <article class="data-types-body"><h3 id="type-cipher" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-cipher">cipher()</a> = <a href="#type-cipher_no_iv">cipher_no_iv()</a> | <a href="#type-cipher_iv">cipher_iv()</a> | <a href="#type-cipher_aead">cipher_aead()</a></code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-cipher_no_iv" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-cipher_no_iv">cipher_no_iv()</a> = 
 aes_128_ecb | aes_192_ecb | aes_256_ecb | aes_ecb |
 blowfish_ecb | des_ecb | rc4</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-cipher_iv" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-cipher_iv">cipher_iv()</a> = 
 aes_128_cbc | aes_192_cbc | aes_256_cbc | aes_cbc |
 aes_128_ofb | aes_192_ofb | aes_256_ofb | aes_128_cfb128 |
 aes_192_cfb128 | aes_256_cfb128 | aes_cfb128 | aes_128_cfb8 |
 aes_192_cfb8 | aes_256_cfb8 | aes_cfb8 | aes_128_ctr |
 aes_192_ctr | aes_256_ctr | aes_ctr | blowfish_cbc |
 blowfish_cfb64 | blowfish_ofb64 | chacha20 | des_ede3_cbc |
 des_ede3_cfb | des_cbc | des_cfb | rc2_cbc</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-cipher_aead" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-cipher_aead">cipher_aead()</a> = 
 aes_128_ccm | aes_192_ccm | aes_256_ccm | aes_ccm |
 aes_128_gcm | aes_192_gcm | aes_256_gcm | aes_gcm |
 chacha20_poly1305</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Ciphers known by the CRYPTO application.</p> <p>Note that this list might be reduced if the underlying libcrypto does not support all of them.</p> </div></div></article> <article class="data-types-body"><h3 id="type-crypto_opts" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-crypto_opts">crypto_opts()</a> = boolean() | [<a href="#type-crypto_opt">crypto_opt()</a>]</code><br> <code><a name="type-crypto_opt">crypto_opt()</a> = {encrypt, boolean()} | {padding, <a href="#type-padding">padding()</a>}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Selects encryption (<code>{encrypt,true}</code>) or decryption (<code>{encrypt,false}</code>). </p> </div></div></article> <article class="data-types-body"><h3 id="type-padding" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-padding">padding()</a> = <a href="#type-cryptolib_padding">cryptolib_padding()</a> | <a href="#type-otp_padding">otp_padding()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>This option handles padding in the last block. If not set, no padding is done and any bytes in the last unfilled block is silently discarded. </p> </div></div></article> <article class="data-types-body"><h3 id="type-cryptolib_padding" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-cryptolib_padding">cryptolib_padding()</a> = none | pkcs_padding</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>The <code>cryptolib_padding</code> are paddings that may be present in the underlying cryptolib linked to the Erlang/OTP crypto app. </p> <p>For OpenSSL, see the <code><a href="http:www.openssl.org">OpenSSL documentation</a></code>. and find <code>EVP_CIPHER_CTX_set_padding()</code> in cryptolib for your linked version. </p> </div></div></article> <article class="data-types-body"><h3 id="type-otp_padding" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-otp_padding">otp_padding()</a> = zero | random</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Erlang/OTP adds a either padding of zeroes or padding with random bytes.</p> </div></div></article> <h3 id="Digests and hash" class="title-link"> <div class="title-name">Digests and hash</div>  </h3> <article class="data-types-body"><h3 id="type-hash_algorithm" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-hash_algorithm">hash_algorithm()</a> = 
 <a href="#type-sha1">sha1()</a> |
 <a href="#type-sha2">sha2()</a> |
 <a href="#type-sha3">sha3()</a> |
 <a href="#type-sha3_xof">sha3_xof()</a> |
 <a href="#type-blake2">blake2()</a> |
 ripemd160 |
 <a href="#type-compatibility_only_hash">compatibility_only_hash()</a></code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-hash_xof_algorithm" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-hash_xof_algorithm">hash_xof_algorithm()</a> = <a href="#type-sha3_xof">sha3_xof()</a></code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-hmac_hash_algorithm" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-hmac_hash_algorithm">hmac_hash_algorithm()</a> = 
 <a href="#type-sha1">sha1()</a> | <a href="#type-sha2">sha2()</a> | <a href="#type-sha3">sha3()</a> | <a href="#type-compatibility_only_hash">compatibility_only_hash()</a></code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-cmac_cipher_algorithm" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-cmac_cipher_algorithm">cmac_cipher_algorithm()</a> = 
 aes_128_cbc | aes_192_cbc | aes_256_cbc | aes_cbc |
 blowfish_cbc | des_cbc | des_ede3_cbc | rc2_cbc</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-rsa_digest_type" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-rsa_digest_type">rsa_digest_type()</a> = <a href="#type-sha1">sha1()</a> | <a href="#type-sha2">sha2()</a> | md5 | ripemd160</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-dss_digest_type" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-dss_digest_type">dss_digest_type()</a> = <a href="#type-sha1">sha1()</a> | <a href="#type-sha2">sha2()</a></code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-ecdsa_digest_type" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-ecdsa_digest_type">ecdsa_digest_type()</a> = <a href="#type-sha1">sha1()</a> | <a href="#type-sha2">sha2()</a></code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-sha1" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-sha1">sha1()</a> = sha</code><br> <code><a name="type-sha2">sha2()</a> = sha224 | sha256 | sha384 | sha512</code><br> <code><a name="type-sha3">sha3()</a> = sha3_224 | sha3_256 | sha3_384 | sha3_512</code><br> <code><a name="type-sha3_xof">sha3_xof()</a> = shake128 | shake256</code><br> <code><a name="type-blake2">blake2()</a> = blake2b | blake2s</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-compatibility_only_hash" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-compatibility_only_hash">compatibility_only_hash()</a> = md5 | md4</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>The <code>compatibility_only_hash()</code> algorithms are recommended only for compatibility with existing applications.</p> </div></div></article> <h3 id="Elliptic Curves" class="title-link"> <div class="title-name">Elliptic Curves</div>  </h3> <article class="data-types-body"><h3 id="type-ec_named_curve" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-ec_named_curve">ec_named_curve()</a> = 
 brainpoolP160r1 | brainpoolP160t1 | brainpoolP192r1 |
 brainpoolP192t1 | brainpoolP224r1 | brainpoolP224t1 |
 brainpoolP256r1 | brainpoolP256t1 | brainpoolP320r1 |
 brainpoolP320t1 | brainpoolP384r1 | brainpoolP384t1 |
 brainpoolP512r1 | brainpoolP512t1 | c2pnb163v1 | c2pnb163v2 |
 c2pnb163v3 | c2pnb176v1 | c2pnb208w1 | c2pnb272w1 |
 c2pnb304w1 | c2pnb368w1 | c2tnb191v1 | c2tnb191v2 |
 c2tnb191v3 | c2tnb239v1 | c2tnb239v2 | c2tnb239v3 |
 c2tnb359v1 | c2tnb431r1 | ipsec3 | ipsec4 | prime192v1 |
 prime192v2 | prime192v3 | prime239v1 | prime239v2 |
 prime239v3 | prime256v1 | secp112r1 | secp112r2 | secp128r1 |
 secp128r2 | secp160k1 | secp160r1 | secp160r2 | secp192k1 |
 secp192r1 | secp224k1 | secp224r1 | secp256k1 | secp256r1 |
 secp384r1 | secp521r1 | sect113r1 | sect113r2 | sect131r1 |
 sect131r2 | sect163k1 | sect163r1 | sect163r2 | sect193r1 |
 sect193r2 | sect233k1 | sect233r1 | sect239k1 | sect283k1 |
 sect283r1 | sect409k1 | sect409r1 | sect571k1 | sect571r1 |
 wtls1 | wtls10 | wtls11 | wtls12 | wtls3 | wtls4 | wtls5 |
 wtls6 | wtls7 | wtls8 | wtls9</code></pre>
<br> <code><a name="type-edwards_curve_dh">edwards_curve_dh()</a> = x25519 | x448</code><br> <code><a name="type-edwards_curve_ed">edwards_curve_ed()</a> = ed25519 | ed448</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Note that some curves are disabled if FIPS is enabled.</p> </div></div></article> <article class="data-types-body"><h3 id="type-ec_explicit_curve" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-ec_explicit_curve">ec_explicit_curve()</a> = 
 {Field :: <a href="#type-ec_field">ec_field()</a>,
 Curve :: <a href="#type-ec_curve">ec_curve()</a>,
 BasePoint :: binary(),
 Order :: binary(),
 CoFactor :: none | binary()}</code></pre>
<br> <code><a name="type-ec_field">ec_field()</a> = <a href="#type-ec_prime_field">ec_prime_field()</a> | <a href="#type-ec_characteristic_two_field">ec_characteristic_two_field()</a></code><br> <pre data-language="erlang"><code><a name="type-ec_curve">ec_curve()</a> = 
 {A :: binary(), B :: binary(), Seed :: none | binary()}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Parametric curve definition.</p> </div></div></article> <article class="data-types-body"><h3 id="type-ec_prime_field" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-ec_prime_field">ec_prime_field()</a> = {prime_field, Prime :: integer()}</code><br> <pre data-language="erlang"><code><a name="type-ec_characteristic_two_field">ec_characteristic_two_field()</a> = 
 {characteristic_two_field,
 M :: integer(),
 Basis :: <a href="#type-ec_basis">ec_basis()</a>}</code></pre>
<br> <pre data-language="erlang"><code><a name="type-ec_basis">ec_basis()</a> = 
 {tpbasis, K :: integer() &gt;= 0} |
 {ppbasis,
 K1 :: integer() &gt;= 0,
 K2 :: integer() &gt;= 0,
 K3 :: integer() &gt;= 0} |
 onbasis</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Curve definition details.</p> </div></div></article> <h3 id="Keys" class="title-link"> <div class="title-name">Keys</div>  </h3> <article class="data-types-body"><h3 id="type-key_integer" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-key_integer">key_integer()</a> = integer() | binary()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Always <code>binary()</code> when used as return value</p> </div></div></article> <h3 id="Public/Private Keys" class="title-link"> <div class="title-name">Public/Private Keys</div>  </h3> <article class="data-types-body"><h3 id="type-rsa_public" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-rsa_public">rsa_public()</a> = [<a href="#type-key_integer">key_integer()</a>]</code><br> <code><a name="type-rsa_private">rsa_private()</a> = [<a href="#type-key_integer">key_integer()</a>]</code><br> <pre data-language="erlang"><code><a name="type-rsa_params">rsa_params()</a> = 
 {ModulusSizeInBits :: integer(),
 PublicExponent :: <a href="#type-key_integer">key_integer()</a>}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <pre data-language="erlang">rsa_public() = [E, N]</pre> <pre data-language="erlang">rsa_private() = [E, N, D] | [E, N, D, P1, P2, E1, E2, C]</pre> <p>Where E is the public exponent, N is public modulus and D is the private exponent. The longer key format contains redundant information that will make the calculation faster. P1 and P2 are first and second prime factors. E1 and E2 are first and second exponents. C is the CRT coefficient. The terminology is taken from <code><a href="http://www.ietf.org/rfc/rfc3447.txt"> RFC 3447</a></code>.</p> </div></div></article> <article class="data-types-body"><h3 id="type-dss_public" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-dss_public">dss_public()</a> = [<a href="#type-key_integer">key_integer()</a>]</code><br> <code><a name="type-dss_private">dss_private()</a> = [<a href="#type-key_integer">key_integer()</a>]</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <pre data-language="erlang">dss_public() = [P, Q, G, Y] </pre> <p>Where P, Q and G are the dss parameters and Y is the public key.</p> <pre data-language="erlang">dss_private() = [P, Q, G, X] </pre> <p>Where P, Q and G are the dss parameters and X is the private key.</p> </div></div></article> <article class="data-types-body"><h3 id="type-ecdsa_public" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-ecdsa_public">ecdsa_public()</a> = <a href="#type-key_integer">key_integer()</a></code><br> <code><a name="type-ecdsa_private">ecdsa_private()</a> = <a href="#type-key_integer">key_integer()</a></code><br> <code><a name="type-ecdsa_params">ecdsa_params()</a> = <a href="#type-ec_named_curve">ec_named_curve()</a> | <a href="#type-ec_explicit_curve">ec_explicit_curve()</a></code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-eddsa_public" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-eddsa_public">eddsa_public()</a> = <a href="#type-key_integer">key_integer()</a></code><br> <code><a name="type-eddsa_private">eddsa_private()</a> = <a href="#type-key_integer">key_integer()</a></code><br> <code><a name="type-eddsa_params">eddsa_params()</a> = <a href="#type-edwards_curve_ed">edwards_curve_ed()</a></code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-srp_public" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-srp_public">srp_public()</a> = <a href="#type-key_integer">key_integer()</a></code><br> <code><a name="type-srp_private">srp_private()</a> = <a href="#type-key_integer">key_integer()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <pre data-language="erlang">srp_public() = key_integer() </pre> <p>Where is <code>A</code> or <code>B</code> from <code><a href="http://srp.stanford.edu/design.html">SRP design</a></code></p> <pre data-language="erlang">srp_private() = key_integer() </pre> <p>Where is <code>a</code> or <code>b</code> from <code><a href="http://srp.stanford.edu/design.html">SRP design</a></code></p> </div></div></article> <article class="data-types-body"><h3 id="type-srp_gen_params" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-srp_gen_params">srp_gen_params()</a> = 
 {user, <a href="#type-srp_user_gen_params">srp_user_gen_params()</a>} | {host, <a href="#type-srp_host_gen_params">srp_host_gen_params()</a>}</code></pre>
<br> <pre data-language="erlang"><code><a name="type-srp_comp_params">srp_comp_params()</a> = 
 {user, <a href="#type-srp_user_comp_params">srp_user_comp_params()</a>} |
 {host, <a href="#type-srp_host_comp_params">srp_host_comp_params()</a>}</code></pre>
<br><div class="bold_code bc-8"><h3 id="type-srp_user_gen_params" class="title-link">  <div class="title-name">srp_user_gen_params() = [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom()]</div> </h3></div> <div class="bold_code bc-8"><h3 id="type-srp_host_gen_params" class="title-link">  <div class="title-name">srp_host_gen_params() = [Verifier::binary(), Prime::binary(), Version::atom() ]</div> </h3></div> <div class="bold_code bc-8"><h3 id="type-srp_user_comp_params" class="title-link">  <div class="title-name">srp_user_comp_params() = [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom() | ScramblerArg::list()]</div> </h3></div> <div class="bold_code bc-8"><h3 id="type-srp_host_comp_params" class="title-link">  <div class="title-name">srp_host_comp_params() = [Verifier::binary(), Prime::binary(), Version::atom() | ScramblerArg::list()]</div> </h3></div> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Where Verifier is <code>v</code>, Generator is <code>g</code> and Prime is<code>N</code>, DerivedKey is <code>X</code>, and Scrambler is <code>u</code> (optional will be generated if not provided) from <code><a href="http://srp.stanford.edu/design.html">SRP design</a></code> Version = '3' | '6' | '6a' </p> </div></div></article> <h3 id="Public Key Ciphers" class="title-link"> <div class="title-name">Public Key Ciphers</div>  </h3> <article class="data-types-body"><h3 id="type-pk_encrypt_decrypt_algs" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-pk_encrypt_decrypt_algs">pk_encrypt_decrypt_algs()</a> = rsa</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Algorithms for public key encrypt/decrypt. Only RSA is supported.</p> </div></div></article> <article class="data-types-body"><h3 id="type-pk_encrypt_decrypt_opts" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-pk_encrypt_decrypt_opts">pk_encrypt_decrypt_opts()</a> = [<a href="#type-rsa_opt">rsa_opt()</a>] | <a href="#type-rsa_compat_opts">rsa_compat_opts()</a></code><br> <pre data-language="erlang"><code><a name="type-rsa_opt">rsa_opt()</a> = 
 {rsa_padding, <a href="#type-rsa_padding">rsa_padding()</a>} |
 {signature_md, atom()} |
 {rsa_mgf1_md, sha} |
 {rsa_oaep_label, binary()} |
 {rsa_oaep_md, sha}</code></pre>
<br> <pre data-language="erlang"><code><a name="type-rsa_padding">rsa_padding()</a> = 
 rsa_pkcs1_padding | rsa_pkcs1_oaep_padding |
 rsa_sslv23_padding | rsa_x931_padding | rsa_no_padding</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Options for public key encrypt/decrypt. Only RSA is supported.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>The RSA options are experimental. </p> <p>The exact set of options and there syntax <strong>may</strong> be changed without prior notice.</p> </div> </div> </div></div></article> <article class="data-types-body"><h3 id="type-rsa_compat_opts" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-rsa_compat_opts">rsa_compat_opts()</a> = [{rsa_pad, <a href="#type-rsa_padding">rsa_padding()</a>}] | <a href="#type-rsa_padding">rsa_padding()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Those option forms are kept only for compatibility and should not be used in new code.</p> </div></div></article> <h3 id="Public Key Sign and Verify" class="title-link"> <div class="title-name">Public Key Sign and Verify</div>  </h3> <article class="data-types-body"><h3 id="type-pk_sign_verify_algs" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-pk_sign_verify_algs">pk_sign_verify_algs()</a> = rsa | dss | ecdsa | eddsa</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Algorithms for sign and verify.</p> </div></div></article> <article class="data-types-body"><h3 id="type-pk_sign_verify_opts" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-pk_sign_verify_opts">pk_sign_verify_opts()</a> = [<a href="#type-rsa_sign_verify_opt">rsa_sign_verify_opt()</a>]</code><br> <pre data-language="erlang"><code><a name="type-rsa_sign_verify_opt">rsa_sign_verify_opt()</a> = 
 {rsa_padding, <a href="#type-rsa_sign_verify_padding">rsa_sign_verify_padding()</a>} |
 {rsa_pss_saltlen, integer()} |
 {rsa_mgf1_md, <a href="#type-sha2">sha2()</a>}</code></pre>
<br> <pre data-language="erlang"><code><a name="type-rsa_sign_verify_padding">rsa_sign_verify_padding()</a> = 
 rsa_pkcs1_padding | rsa_pkcs1_pss_padding | rsa_x931_padding |
 rsa_no_padding</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Options for sign and verify.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>The RSA options are experimental. </p> <p>The exact set of options and there syntax <strong>may</strong> be changed without prior notice.</p> </div> </div> </div></div></article> <h3 id="Diffie-Hellman Keys and parameters" class="title-link"> <div class="title-name">Diffie-Hellman Keys and parameters</div>  </h3> <article class="data-types-body"><h3 id="type-dh_public" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-dh_public">dh_public()</a> = <a href="#type-key_integer">key_integer()</a></code><br> <code><a name="type-dh_private">dh_private()</a> = <a href="#type-key_integer">key_integer()</a></code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-dh_params" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-dh_params">dh_params()</a> = [<a href="#type-key_integer">key_integer()</a>]</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <pre data-language="erlang">dh_params() = [P, G] | [P, G, PrivateKeyBitLength]</pre> </div></div></article> <article class="data-types-body"><h3 id="type-ecdh_public" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-ecdh_public">ecdh_public()</a> = <a href="#type-key_integer">key_integer()</a></code><br> <code><a name="type-ecdh_private">ecdh_private()</a> = <a href="#type-key_integer">key_integer()</a></code><br> <pre data-language="erlang"><code><a name="type-ecdh_params">ecdh_params()</a> = 
 <a href="#type-ec_named_curve">ec_named_curve()</a> | <a href="#type-edwards_curve_dh">edwards_curve_dh()</a> | <a href="#type-ec_explicit_curve">ec_explicit_curve()</a></code></pre>
<br> </div> </h3> </article> <h3 id="Types for Engines" class="title-link"> <div class="title-name">Types for Engines</div>  </h3> <article class="data-types-body"><h3 id="type-engine_key_ref" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-engine_key_ref">engine_key_ref()</a> = 
 #{engine := <a href="#type-engine_ref">engine_ref()</a>,
 key_id := <a href="#type-key_id">key_id()</a>,
 password =&gt; <a href="#type-password">password()</a>,
 term() =&gt; term()}</code></pre>
<br> <code><a name="type-engine_ref">engine_ref()</a> = term()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>The result of a call to <code><a href="#engine_load-3">engine_load/3</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-key_id" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-key_id">key_id()</a> = string() | binary()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Identifies the key to be used. The format depends on the loaded engine. It is passed to the <code>ENGINE_load_(private|public)_key</code> functions in libcrypto. </p> </div></div></article> <article class="data-types-body"><h3 id="type-password" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-password">password()</a> = string() | binary()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>The password of the key stored in an engine. </p> </div></div></article> <article class="data-types-body"><h3 id="type-engine_method_type" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-engine_method_type">engine_method_type()</a> = 
 engine_method_rsa | engine_method_dsa | engine_method_dh |
 engine_method_rand | engine_method_ecdh |
 engine_method_ecdsa | engine_method_ciphers |
 engine_method_digests | engine_method_store |
 engine_method_pkey_meths | engine_method_pkey_asn1_meths |
 engine_method_ec</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-engine_cmnd" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-engine_cmnd">engine_cmnd()</a> = {unicode:chardata(), unicode:chardata()}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Pre and Post commands for <code><a href="#engine_load-3">engine_load/3 and /4</a></code>. </p> </div></div></article> <h3 id="Internal data types" class="title-link"> <div class="title-name">Internal data types</div>  </h3> <article class="data-types-body"><h3 id="type-crypto_state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-crypto_state">crypto_state()</a></code><br> <code><a name="type-hash_state">hash_state()</a></code><br> <code><a name="type-mac_state">mac_state()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Contexts with an internal state that should not be manipulated but passed between function calls. </p> </div></div></article> </div> <section class="innertube"><h2 id="exceptions" class="title-link"> <div class="title-name">Exceptions</div>  </h2> <div class="REFBODY rb-3"> <section><h3 id="Atoms - the older style">Atoms - the older style</h3> <div class="REFBODY rb-4">  <p id="error_old">The exception <code>error:badarg</code> signifies that one or more arguments are of wrong data type, or are otherwise badly formed. </p> <p>The exception <code>error:notsup</code> signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that. </p> <p>For a list of supported algorithms, see <code><a href="#supports-1">supports(ciphers)</a></code>. </p> </div></section> <section><h3 id="3-tuples - the new style">3-tuples - the new style</h3> <div class="REFBODY rb-4">  <p id="error_3tup">The exception is:</p> <pre data-language="erlang">
error:{Tag, C_FileInfo, Description}

Tag = badarg | notsup | error
C_FileInfo = term()    % Usually only useful for the OTP maintainer
Description = string() % Clear text, sometimes only useful for the OTP maintainer
      </pre> <p>The exception tags are:</p> <dl> <dt class="title-link"><strong><code>badarg</code></strong></dt> <dd> <p>Signifies that one or more arguments are of wrong data type or are otherwise badly formed.</p> </dd> <dt class="title-link"><strong><code>notsup</code></strong></dt> <dd> <p>Signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that one.</p> </dd> <dt class="title-link"><strong><code>error</code></strong></dt> <dd> <p>An error condition that should not occur, for example a memory allocation failed or the underlying cryptolib returned an error code, for example <code>"Can't initialize context, step 1"</code>. Those text usually needs searching the C-code to be understood.</p> </dd> </dl> <p>Usually there are more information in the call stack about which argument caused the exception and what the values where.</p> <p>To catch the exception, use for example:</p> <pre data-language="erlang">try crypto:crypto_init(Ciph, Key, IV, true)
    catch
        error:{Tag, _C_FileInfo, Description} -&gt;
            do_something(......)
         .....
end</pre> </div></section> </div></section> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="crypto_init-3" class="bold_code title-link func-head">  <code>crypto_init(Cipher, Key, FlagOrOptions) -&gt; State</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Cipher = <a href="#type-cipher_no_iv">cipher_no_iv()</a></code></div> <div class="REFTYPES rt-1"><code>Key = iodata()</code></div> <div class="REFTYPES rt-1"><code>FlagOrOptions = <a href="#type-crypto_opts">crypto_opts()</a> | boolean()</code></div> <div class="REFTYPES rt-1"><code>State = <a href="#type-crypto_state">crypto_state()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Equivalent to the call <code><a href="#crypto_init-4">crypto_init(Cipher, Key, &lt;&lt;&gt;&gt;, FlagOrOptions)</a></code>. It is intended for ciphers without an IV (nounce). </p> </div></div></article><article class="func"><h3 id="crypto_init-4" class="bold_code title-link func-head">  <code>crypto_init(Cipher, Key, IV, FlagOrOptions) -&gt; State</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Cipher = <a href="#type-cipher_iv">cipher_iv()</a></code></div> <div class="REFTYPES rt-1"><code>Key = IV = iodata()</code></div>  <div class="REFTYPES rt-1"><code>FlagOrOptions = <a href="#type-crypto_opts">crypto_opts()</a></code></div> <div class="REFTYPES rt-1"><code>State = <a href="#type-crypto_state">crypto_state()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p> Initializes a series of encryptions or decryptions and creates an internal state with a reference that is returned. </p> <p>If <code>IV = &lt;&lt;&gt;&gt;</code>, no IV is used. This is intended for ciphers without an IV (nounce). See <code><a href="#crypto_init-3">crypto_init/3</a></code>. </p> <p> If <code>IV = undefined</code>, the IV must be added by calls to <code><a href="crypto.html#crypto_dyn_iv_update-3">crypto_dyn_iv_update/3</a></code>. This is intended for cases where the IV (nounce) need to be changed for each encryption and decryption. See <code><a href="#crypto_dyn_iv_init-3">crypto_dyn_iv_init/3</a></code>. </p> <p> The actual encryption or decryption is done by <code><a href="crypto.html#crypto_update-2">crypto_update/2</a></code> (or <code><a href="crypto.html#crypto_dyn_iv_update-3">crypto_dyn_iv_update/3</a></code> ). </p> <p>For encryption, set the <code>FlagOrOptions</code> to <code>true</code> or <code>[{encrypt,true}]</code>. For decryption, set it to <code>false</code> or <code>[{encrypt,false}]</code>. </p> <p>Padding could be enabled with the option <code><a href="#type-padding">{padding,Padding}</a></code>. The <code><a href="#type-cryptolib_padding">cryptolib_padding</a></code> enables <code>pkcs_padding</code> or no padding (<code>none</code>). The paddings <code>zero</code> or <code>random</code> fills the last part of the last block with zeroes or random bytes. If the last block is already full, nothing is added. </p> <p>In decryption, the <code><a href="#type-cryptolib_padding">cryptolib_padding</a></code> removes such padding, if present. The <code><a href="#type-otp_padding">otp_padding</a></code> is not removed - it has to be done elsewhere. </p> <p>If padding is <code>{padding,none}</code> or not specified and the total data from all subsequent <code><a href="crypto.html#crypto_update-2">crypto_updates</a></code> does not fill the last block fully, that last data is lost. In case of <code>{padding,none}</code> there will be an error in this case. If padding is not specified, the bytes of the unfilled block is silently discarded. </p> <p>The actual padding is performed by <code><a href="crypto.html#crypto_final-1">crypto_final/1</a></code>. </p> <p> For blocksizes call <code><a href="#cipher_info-1">cipher_info/1</a></code>. </p> <p>See <code> examples in the User's Guide.</code> </p> </div></div></article><article class="func"><h3 id="crypto_update-2" class="bold_code title-link func-head">  <code>crypto_update(State, Data) -&gt; Result</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>State = <a href="#type-crypto_state">crypto_state()</a></code></div> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>Result = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p> It does an actual crypto operation on a part of the full text. If the part is less than a number of full blocks, only the full blocks (possibly none) are encrypted or decrypted and the remaining bytes are saved to the next <code>crypto_update</code> operation. The <code>State</code> should be created with <code><a href="crypto.html#crypto_init-3">crypto_init/3</a></code> or <code><a href="crypto.html#crypto_init-4">crypto_init/4</a></code>. </p> <p>See <code> examples in the User's Guide.</code> </p> </div></div></article><article class="func"><h3 id="crypto_dyn_iv_init-3" class="bold_code title-link func-head">  <code>crypto_dyn_iv_init(Cipher, Key, FlagOrOptions) -&gt; State</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Cipher = <a href="#type-cipher_iv">cipher_iv()</a></code></div> <div class="REFTYPES rt-1"><code>Key = iodata()</code></div> <div class="REFTYPES rt-1"><code>FlagOrOptions = <a href="#type-crypto_opts">crypto_opts()</a> | boolean()</code></div> <div class="REFTYPES rt-1"><code>State = <a href="#type-crypto_state">crypto_state()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Initializes a series of encryptions or decryptions where the IV is provided later. The actual encryption or decryption is done by <code><a href="crypto.html#crypto_dyn_iv_update-3">crypto_dyn_iv_update/3</a></code>. </p> <p>The function is equivalent to <code><a href="#crypto_init-4">crypto_init(Cipher, Key, undefined, FlagOrOptions)</a></code>. </p> </div></div></article><article class="func"><h3 id="crypto_final-1" class="bold_code title-link func-head">  <code>crypto_final(State) -&gt; FinalResult</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>State = <a href="#type-crypto_state">crypto_state()</a></code></div> <div class="REFTYPES rt-1"><code>FinalResult = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p> Finalizes a series of encryptions or decryptions and delivers the final bytes of the final block. The data returned from this function may be empty if no padding was enabled in <code><a href="#crypto_init-3">crypto_init/3,4</a></code> or <code><a href="#crypto_dyn_iv_init-3">crypto_dyn_iv_init/3</a></code>. </p> </div></div></article><article class="func"><h3 id="crypto_get_data-1" class="bold_code title-link func-head">  <code>crypto_get_data(State) -&gt; Result</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>State = <a href="#type-crypto_state">crypto_state()</a></code></div> <div class="REFTYPES rt-1"><code>Result = map()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p> Returns information about the State in the argument. The information is the form of a map, which currently contains at least: </p> <dl> <dt class="title-link"><strong><code>size</code></strong></dt> <dd>The number of bytes encrypted or decrypted so far. </dd> <dt class="title-link"><strong><code>padding_size</code></strong></dt> <dd>After a call to <code><a href="#crypto_final-1">crypto_final/1</a></code> it contains the number of bytes padded. Otherwise 0. </dd> <dt class="title-link"><strong><code>padding_type</code></strong></dt> <dd>The type of the padding as provided in the call to <code><a href="#crypto_init-3">crypto_init/3,4</a></code>. </dd> <dt class="title-link"><strong><code>encrypt</code></strong></dt> <dd>Is <code>true</code> if encryption is performed. It is <code>false</code> otherwise. </dd> </dl> </div></div></article><article class="func"><h3 id="crypto_dyn_iv_update-3" class="bold_code title-link func-head">  <code>crypto_dyn_iv_update(State, Data, IV) -&gt; Result</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>State = <a href="#type-crypto_state">crypto_state()</a></code></div> <div class="REFTYPES rt-1"><code>Data = IV = iodata()</code></div>  <div class="REFTYPES rt-1"><code>Result = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p> Do an actual crypto operation on a part of the full text and the IV is supplied for each part. The <code>State</code> should be created with <code><a href="crypto.html#crypto_dyn_iv_init-3">crypto_dyn_iv_init/3</a></code>. </p> </div></div></article><article class="func"><h3 id="crypto_one_time-4" class="bold_code title-link func-head">  <code>crypto_one_time(Cipher, Key, Data, FlagOrOptions) -&gt; Result</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Cipher = <a href="#type-cipher_no_iv">cipher_no_iv()</a></code></div> <div class="REFTYPES rt-1"><code>Key = Data = iodata()</code></div>  <div class="REFTYPES rt-1"><code>FlagOrOptions = <a href="#type-crypto_opts">crypto_opts()</a> | boolean()</code></div> <div class="REFTYPES rt-1"><code>Result = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>As <code><a href="#crypto_one_time-5">crypto_one_time/5</a></code> but for ciphers without IVs.</p> </div></div></article><article class="func"><h3 id="crypto_one_time-5" class="bold_code title-link func-head">  <code>crypto_one_time(Cipher, Key, IV, Data, FlagOrOptions) -&gt; Result</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Cipher = <a href="#type-cipher_iv">cipher_iv()</a></code></div> <div class="REFTYPES rt-1"><code>Key = IV = Data = iodata()</code></div>   <div class="REFTYPES rt-1"><code>FlagOrOptions = <a href="#type-crypto_opts">crypto_opts()</a> | boolean()</code></div> <div class="REFTYPES rt-1"><code>Result = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p> Do a complete encrypt or decrypt of the full text in the argument <code>Data</code>. </p> <p>For encryption, set the <code>FlagOrOptions</code> to <code>true</code>. For decryption, set it to <code>false</code>. For setting other options, see <code><a href="crypto.html#crypto_init-4">crypto_init/4</a></code>. </p> <p>See <code>examples in the User's Guide.</code> </p> </div></div></article><article class="func"><h3 id="crypto_one_time_aead-6" class="bold_code title-link func-head">  <pre data-language="erlang"><code>crypto_one_time_aead(Cipher, Key, IV, InText, AAD,
 EncFlag :: true) -&gt;
 Result</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <h3 id="crypto_one_time_aead-7" class="bold_code title-link func-head">  <pre data-language="erlang"><code>crypto_one_time_aead(Cipher, Key, IV, InText, AAD, TagOrTagLength,
 EncFlag) -&gt;
 Result</code></pre>
<div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Cipher = <a href="#type-cipher_aead">cipher_aead()</a></code></div> <div class="REFTYPES rt-1"><code>Key = IV = InText = AAD = iodata()</code></div>    <div class="REFTYPES rt-1"><code>TagOrTagLength = EncryptTagLength | DecryptTag</code></div> <div class="REFTYPES rt-1"><code>EncryptTagLength = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>DecryptTag = iodata()</code></div> <div class="REFTYPES rt-1"><code>EncFlag = boolean()</code></div> <div class="REFTYPES rt-1"><code>Result = EncryptResult | DecryptResult</code></div> <div class="REFTYPES rt-1"><code>EncryptResult = {OutCryptoText, OutTag}</code></div> <div class="REFTYPES rt-1"><code>DecryptResult = OutPlainText | error</code></div> <div class="REFTYPES rt-1"><code>OutCryptoText = OutTag = OutPlainText = binary()</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p> Do a complete encrypt or decrypt with an AEAD cipher of the full text. </p> <p>For encryption, set the <code>EncryptFlag</code> to <code>true</code> and set the <code>TagOrTagLength</code> to the wanted size (in bytes) of the tag, that is, the tag length. If the default length is wanted, the <code>crypto_aead/6</code> form may be used. </p> <p>For decryption, set the <code>EncryptFlag</code> to <code>false</code> and put the tag to be checked in the argument <code>TagOrTagLength</code>. </p> <p>See <code>examples in the User's Guide.</code> </p> </div></div></article><article class="func"><h3 id="supports-1" class="bold_code title-link func-head">  <code>supports(Type) -&gt; Support</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = hashs | ciphers | public_keys | macs | curves | rsa_opts</code></div> <div class="REFTYPES rt-1"><code>Support = Hashs | Ciphers | PKs | Macs | Curves | RSAopts</code></div> <div class="REFTYPES rt-1"><pre><code>Hashs = 
 [<a href="#type-sha1">sha1()</a> |
 <a href="#type-sha2">sha2()</a> |
 <a href="#type-sha3">sha3()</a> |
 <a href="#type-sha3_xof">sha3_xof()</a> |
 <a href="#type-blake2">blake2()</a> |
 ripemd160 |
 <a href="#type-compatibility_only_hash">compatibility_only_hash()</a>]</code></pre></div> <div class="REFTYPES rt-1"><code>Ciphers = [<a href="#type-cipher">cipher()</a>]</code></div> <div class="REFTYPES rt-1"><code>PKs = [rsa | dss | ecdsa | dh | ecdh | eddh | ec_gf2m]</code></div> <div class="REFTYPES rt-1"><code>Macs = [hmac | cmac | poly1305]</code></div> <div class="REFTYPES rt-1"><pre><code>Curves = 
 [<a href="#type-ec_named_curve">ec_named_curve()</a> | <a href="#type-edwards_curve_dh">edwards_curve_dh()</a> | <a href="#type-edwards_curve_ed">edwards_curve_ed()</a>]</code></pre></div> <div class="REFTYPES rt-1"><code>RSAopts = [<a href="#type-rsa_sign_verify_opt">rsa_sign_verify_opt()</a> | <a href="#type-rsa_opt">rsa_opt()</a>]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Can be used to determine which crypto algorithms that are supported by the underlying libcrypto library</p> <p>See <code><a href="#hash_info-1">hash_info/1</a></code> and <code><a href="#cipher_info-1">cipher_info/1</a></code> for information about the hash and cipher algorithms. </p> </div></div></article><article class="func"><h3 id="mac-3" class="bold_code title-link func-head">  <code>mac(Type :: poly1305, Key, Data) -&gt; Mac</code><div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Key = Data = iodata()</code></div>  <div class="REFTYPES rt-1"><code>Mac = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Short for <code><a href="#mac-4">mac(Type, undefined, Key, Data)</a></code>. </p> </div></div></article><article class="func"><h3 id="mac-4" class="bold_code title-link func-head">  <code>mac(Type, SubType, Key, Data) -&gt; Mac</code><div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = hmac | cmac | poly1305</code></div> <div class="REFTYPES rt-1"><pre><code>SubType = 
 <a href="#type-hmac_hash_algorithm">hmac_hash_algorithm()</a> | <a href="#type-cmac_cipher_algorithm">cmac_cipher_algorithm()</a> | undefined</code></pre></div> <div class="REFTYPES rt-1"><code>Key = Data = iodata()</code></div>  <div class="REFTYPES rt-1"><code>Mac = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Computes a MAC (Message Authentication Code) of type <code>Type</code> from <code>Data</code>. </p> <p><code>SubType</code> depends on the MAC <code>Type</code>: </p> <ul> <li>For <code>hmac</code> it is a hash algorithm, see <code><a href="algorithm_details.html#hmac">Algorithm Details</a></code> in the User's Guide. </li> <li>For <code>cmac</code> it is a cipher suitable for cmac, see <code><a href="algorithm_details.html#cmac">Algorithm Details</a></code> in the User's Guide. </li> <li>For <code>poly1305</code> it should be set to <code>undefined</code> or the <code><a href="#mac_init-2">mac/2</a></code> function could be used instead, see <code><a href="algorithm_details.html#poly1305">Algorithm Details</a></code> in the User's Guide. </li> </ul> <p><code>Key</code> is the authentication key with a length according to the <code>Type</code> and <code>SubType</code>. The key length could be found with the <code><a href="#hash_info-1">hash_info/1</a></code> (<code>hmac</code>) for and <code><a href="#cipher_info-1">cipher_info/1</a></code> (<code>cmac</code>) functions. For <code>poly1305</code> the key length is 32 bytes. Note that the cryptographic quality of the key is not checked. </p> <p>The <code>Mac</code> result will have a default length depending on the <code>Type</code> and <code>SubType</code>. To set a shorter length, use <code><a href="#macN-4">macN/4</a></code> or <code><a href="#macN-5">macN/5</a></code> instead. The default length is documented in <code><a href="algorithm_details.html#message-authentication-codes--macs-">Algorithm Details</a></code> in the User's Guide. </p> </div></div></article><article class="func"><h3 id="macN-4" class="bold_code title-link func-head">  <code>macN(Type :: poly1305, Key, Data, MacLength) -&gt; Mac</code><div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Key = Data = iodata()</code></div>  <div class="REFTYPES rt-1"><code>Mac = binary()</code></div> <div class="REFTYPES rt-1"><code>MacLength = integer() &gt;= 1</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Short for <code><a href="#macN-5">macN(Type, undefined, Key, Data, MacLength)</a></code>. </p> </div></div></article><article class="func"><h3 id="macN-5" class="bold_code title-link func-head">  <code>macN(Type, SubType, Key, Data, MacLength) -&gt; Mac</code><div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = hmac | cmac | poly1305</code></div> <div class="REFTYPES rt-1"><pre><code>SubType = 
 <a href="#type-hmac_hash_algorithm">hmac_hash_algorithm()</a> | <a href="#type-cmac_cipher_algorithm">cmac_cipher_algorithm()</a> | undefined</code></pre></div> <div class="REFTYPES rt-1"><code>Key = Data = iodata()</code></div>  <div class="REFTYPES rt-1"><code>Mac = binary()</code></div> <div class="REFTYPES rt-1"><code>MacLength = integer() &gt;= 1</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Computes a MAC (Message Authentication Code) as <code><a href="#mac-3">mac/3</a></code> and <code><a href="#mac-4">mac/4</a></code> but <code>MacLength</code> will limit the size of the resultant <code>Mac</code> to at most <code>MacLength</code> bytes. Note that if <code>MacLength</code> is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead. </p> <p>The max <code>MacLength</code> is documented in <code><a href="algorithm_details.html#message-authentication-codes--macs-">Algorithm Details</a></code> in the User's Guide. </p> </div></div></article><article class="func"><h3 id="mac_init-2" class="bold_code title-link func-head">  <code>mac_init(Type :: poly1305, Key) -&gt; State</code><div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Key = iodata()</code></div> <div class="REFTYPES rt-1"><code>State = <a href="#type-mac_state">mac_state()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Short for <code><a href="#mac_init-3">mac_init(Type, undefined, Key)</a></code>. </p> </div></div></article><article class="func"><h3 id="mac_init-3" class="bold_code title-link func-head">  <code>mac_init(Type, SubType, Key) -&gt; State</code><div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = hmac | cmac | poly1305</code></div> <div class="REFTYPES rt-1"><pre><code>SubType = 
 <a href="#type-hmac_hash_algorithm">hmac_hash_algorithm()</a> | <a href="#type-cmac_cipher_algorithm">cmac_cipher_algorithm()</a> | undefined</code></pre></div> <div class="REFTYPES rt-1"><code>Key = iodata()</code></div> <div class="REFTYPES rt-1"><code>State = <a href="#type-mac_state">mac_state()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Initializes the context for streaming MAC operations. </p> <p><code>Type</code> determines which mac algorithm to use in the MAC operation. </p> <p><code>SubType</code> depends on the MAC <code>Type</code>: </p> <ul> <li>For <code>hmac</code> it is a hash algorithm, see <code><a href="algorithm_details.html#hmac">Algorithm Details</a></code> in the User's Guide. </li> <li>For <code>cmac</code> it is a cipher suitable for cmac, see <code><a href="algorithm_details.html#cmac">Algorithm Details</a></code> in the User's Guide. </li> <li>For <code>poly1305</code> it should be set to <code>undefined</code> or the <code><a href="#mac_init-2">mac/2</a></code> function could be used instead, see <code><a href="algorithm_details.html#poly1305">Algorithm Details</a></code> in the User's Guide. </li> </ul> <p><code>Key</code> is the authentication key with a length according to the <code>Type</code> and <code>SubType</code>. The key length could be found with the <code><a href="#hash_info-1">hash_info/1</a></code> (<code>hmac</code>) for and <code><a href="#cipher_info-1">cipher_info/1</a></code> (<code>cmac</code>) functions. For <code>poly1305</code> the key length is 32 bytes. Note that the cryptographic quality of the key is not checked. </p> <p>The returned <code>State</code> should be used in one or more subsequent calls to <code><a href="#mac_update-2">mac_update/2</a></code>. The MAC value is finally returned by calling <code><a href="#mac_final-1">mac_final/1</a></code> or <code><a href="#mac_finalN-2">mac_finalN/2</a></code>. </p> <p>See <code> examples in the User's Guide.</code> </p> </div></div></article><article class="func"><h3 id="mac_update-2" class="bold_code title-link func-head">  <code>mac_update(State0, Data) -&gt; State</code><div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>State0 = State = <a href="#type-mac_state">mac_state()</a></code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Updates the MAC represented by <code>State0</code> using the given <code>Data</code> which could be of any length. </p> <p>The <code>State0</code> is the State value originally from a MAC init function, that is <code><a href="#mac_init-2">mac_init/2</a></code>, <code><a href="#mac_init-3">mac_init/3</a></code> or a previous call of <code>mac_update/2</code>. The value <code>State0</code> is returned unchanged by the function as <code>State</code>. </p> </div></div></article><article class="func"><h3 id="mac_final-1" class="bold_code title-link func-head">  <code>mac_final(State) -&gt; Mac</code><div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>State = <a href="#type-mac_state">mac_state()</a></code></div> <div class="REFTYPES rt-1"><code>Mac = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Finalizes the MAC operation referenced by <code>State</code>. The <code>Mac</code> result will have a default length depending on the <code>Type</code> and <code>SubType</code> in the <code><a href="#mac_init-3">mac_init/2,3</a></code> call. To set a shorter length, use <code><a href="#mac_finalN-2">mac_finalN/2</a></code> instead. The default length is documented in <code><a href="algorithm_details.html#message-authentication-codes--macs-">Algorithm Details</a></code> in the User's Guide. </p> </div></div></article><article class="func"><h3 id="mac_finalN-2" class="bold_code title-link func-head">  <code>mac_finalN(State, MacLength) -&gt; Mac</code><div class="title-since"><span class="since">OTP 22.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>State = <a href="#type-mac_state">mac_state()</a></code></div> <div class="REFTYPES rt-1"><code>MacLength = integer() &gt;= 1</code></div> <div class="REFTYPES rt-1"><code>Mac = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Finalizes the MAC operation referenced by <code>State</code>. </p> <p><code>Mac</code> will be a binary with at most <code>MacLength</code> bytes. Note that if <code>MacLength</code> is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead. </p> <p>The max <code>MacLength</code> is documented in <code><a href="algorithm_details.html#message-authentication-codes--macs-">Algorithm Details</a></code> in the User's Guide. </p> </div></div></article><article class="func"><h3 id="bytes_to_integer-1" class="bold_code title-link func-head">  <code>bytes_to_integer(Bin :: <code>binary()</code>) -&gt; <code>integer()</code></code><div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Convert binary representation, of an integer, to an Erlang integer. </p> </div></div></article><article class="func"><h3 id="compute_key-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>compute_key(Type, OthersPublicKey, MyPrivateKey, Params) -&gt;
 SharedSecret</code></pre>
<div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = dh | ecdh | eddh | srp</code></div> <div class="REFTYPES rt-1"><code>SharedSecret = binary()</code></div> <div class="REFTYPES rt-1"><code>OthersPublicKey = <a href="#type-dh_public">dh_public()</a> | <a href="#type-ecdh_public">ecdh_public()</a> | <a href="#type-srp_public">srp_public()</a></code></div> <div class="REFTYPES rt-1"><pre><code>MyPrivateKey = 
 <a href="#type-dh_private">dh_private()</a> | <a href="#type-ecdh_private">ecdh_private()</a> | {<a href="#type-srp_public">srp_public()</a>, <a href="#type-srp_private">srp_private()</a>}</code></pre></div> <div class="REFTYPES rt-1"><code>Params = <a href="#type-dh_params">dh_params()</a> | <a href="#type-ecdh_params">ecdh_params()</a> | <a href="#type-srp_comp_params">srp_comp_params()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Computes the shared secret from the private key and the other party's public key. See also <code>public_key:compute_key/2</code> </p> </div></div></article><article class="func"><h3 id="exor-2" class="bold_code title-link func-head">  <code>exor(Bin1 :: <code>iodata()</code>, Bin2 :: <code>iodata()</code>) -&gt; <code>binary()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Performs bit-wise XOR (exclusive or) on the data supplied.</p> </div></div></article><article class="func"><h3 id="generate_key-2" class="bold_code title-link func-head">  <code>generate_key(Type, Params) -&gt; {PublicKey, PrivKeyOut}</code><div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <h3 id="generate_key-3" class="bold_code title-link func-head">  <code>generate_key(Type, Params, PrivKeyIn) -&gt; {PublicKey, PrivKeyOut}</code><div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = dh | ecdh | eddh | eddsa | rsa | srp</code></div> <div class="REFTYPES rt-1"><pre><code>PublicKey = 
 <a href="#type-dh_public">dh_public()</a> | <a href="#type-ecdh_public">ecdh_public()</a> | <a href="#type-rsa_public">rsa_public()</a> | <a href="#type-srp_public">srp_public()</a></code></pre></div> <div class="REFTYPES rt-1"><pre><code>PrivKeyIn = 
 undefined |
 <a href="#type-dh_private">dh_private()</a> |
 <a href="#type-ecdh_private">ecdh_private()</a> |
 <a href="#type-rsa_private">rsa_private()</a> |
 {<a href="#type-srp_public">srp_public()</a>, <a href="#type-srp_private">srp_private()</a>}</code></pre></div> <div class="REFTYPES rt-1"><pre><code>PrivKeyOut = 
 <a href="#type-dh_private">dh_private()</a> |
 <a href="#type-ecdh_private">ecdh_private()</a> |
 <a href="#type-rsa_private">rsa_private()</a> |
 {<a href="#type-srp_public">srp_public()</a>, <a href="#type-srp_private">srp_private()</a>}</code></pre></div> <div class="REFTYPES rt-1"><pre><code>Params = 
 <a href="#type-dh_params">dh_params()</a> |
 <a href="#type-ecdh_params">ecdh_params()</a> |
 <a href="#type-eddsa_params">eddsa_params()</a> |
 <a href="#type-rsa_params">rsa_params()</a> |
 <a href="#type-srp_comp_params">srp_comp_params()</a></code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Generates a public key of type <code>Type</code>. See also <code>public_key:generate_key/1</code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If the linked version of cryptolib is OpenSSL 3.0</p> <ul> <li> <p>and the <code>Type</code> is <code>dh</code> (diffie-hellman)</p> </li> <li> <p>and the parameter <code>P</code> (in <code><a href="#type-dh_params">dh_params()</a></code>) is one of the MODP groups (see <code><a href="https://tools.ietf.org/html/rfc3526">RFC 3526</a></code>)</p> </li> <li> <p>and the optional <code>PrivateKeyBitLength</code> parameter (in <code><a href="#type-dh_params">dh_params()</a></code>) is present,</p> </li> </ul> <p>then the optional key length parameter must be at least 224, 256, 302, 352 and 400 for group sizes of 2048, 3072, 4096, 6144 and 8192, respectively.</p> </div> </div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>RSA key generation is only available if the runtime was built with dirty scheduler support. Otherwise, attempting to generate an RSA key will raise the exception <code>error:notsup</code>.</p> </div> </div> </div></div></article><article class="func"><h3 id="hash-2" class="bold_code title-link func-head">  <code>hash(Type, Data) -&gt; Digest</code><div class="title-since"><span class="since">OTP R15B02</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = <a href="#type-hash_algorithm">hash_algorithm()</a></code></div> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>Digest = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Computes a message digest of type <code>Type</code> from <code>Data</code>.</p> </div></div></article><article class="func"><h3 id="hash_xof-3" class="bold_code title-link func-head">  <code>hash_xof(Type, Data, Length) -&gt; Digest</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = <a href="#type-hash_xof_algorithm">hash_xof_algorithm()</a></code></div> <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> <div class="REFTYPES rt-1"><code>Length = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>Digest = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Computes a message digest of type <code>Type</code> from <code>Data</code> of <code>Length</code> for the chosen <code>xof_algorithm</code>.</p> <p>May raise exception <code>error:notsup</code> in case the chosen <code>Type</code> is not supported by the underlying libcrypto implementation.</p> </div></div></article><article class="func"><h3 id="hash_init-1" class="bold_code title-link func-head">  <code>hash_init(Type) -&gt; State</code><div class="title-since"><span class="since">OTP R15B02</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = <a href="#type-hash_algorithm">hash_algorithm()</a></code></div> <div class="REFTYPES rt-1"><code>State = <a href="#type-hash_state">hash_state()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Initializes the context for streaming hash operations. <code>Type</code> determines which digest to use. The returned context should be used as argument to <code><a href="#hash_update-2">hash_update</a></code>.</p> </div></div></article><article class="func"><h3 id="hash_update-2" class="bold_code title-link func-head">  <code>hash_update(State, Data) -&gt; NewState</code><div class="title-since"><span class="since">OTP R15B02</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>State = NewState = <a href="#type-hash_state">hash_state()</a></code></div>  <div class="REFTYPES rt-1"><code>Data = iodata()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Updates the digest represented by <code>Context</code> using the given <code>Data</code>. <code>Context</code> must have been generated using <code><a href="#hash_init-1">hash_init</a></code> or a previous call to this function. <code>Data</code> can be any length. <code>NewContext</code> must be passed into the next call to <code>hash_update</code> or <code><a href="#hash_final-1">hash_final</a></code>.</p> </div></div></article><article class="func"><h3 id="hash_final-1" class="bold_code title-link func-head">  <code>hash_final(State) -&gt; Digest</code><div class="title-since"><span class="since">OTP R15B02</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>State = <a href="#type-hash_state">hash_state()</a></code></div> <div class="REFTYPES rt-1"><code>Digest = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Finalizes the hash operation referenced by <code>Context</code> returned from a previous call to <code><a href="#hash_update-2">hash_update</a></code>. The size of <code>Digest</code> is determined by the type of hash function used to generate it.</p> </div></div></article><article class="func"><h3 id="info_fips-0" class="bold_code title-link func-head">  <code>info_fips() -&gt; not_supported | not_enabled | enabled</code><div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Provides information about the FIPS operating status of crypto and the underlying libcrypto library. If crypto was built with FIPS support this can be either <code>enabled</code> (when running in FIPS mode) or <code>not_enabled</code>. For other builds this value is always <code>not_supported</code>. </p> <p>See <code><a href="#enable_fips_mode-1">enable_fips_mode/1</a></code> about how to enable FIPS mode. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>In FIPS mode all non-FIPS compliant algorithms are disabled and raise exception <code>error:notsup</code>. Check <code><a href="#supports-1">supports(ciphers)</a></code> that in FIPS mode returns the restricted list of available algorithms.</p> </div> </div> </div></div></article><article class="func"><h3 id="enable_fips_mode-1" class="bold_code title-link func-head">  <code>enable_fips_mode(Enable) -&gt; Result</code><div class="title-since"><span class="since">OTP 21.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Enable = Result = boolean()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Enables (<code>Enable = true</code>) or disables (<code>Enable = false</code>) FIPS mode. Returns <code>true</code> if the operation was successful or <code>false</code> otherwise. </p> <p>Note that to enable FIPS mode successfully, OTP must be built with the configure option <code>--enable-fips</code>, and the underlying libcrypto must also support FIPS. </p> <p>See also <code><a href="#info_fips-0">info_fips/0</a></code>. </p> </div></div></article><article class="func"><h3 id="info-0" class="bold_code title-link func-head">  <pre data-language="erlang"><code>info() -&gt;
 #{compile_type := normal | debug | valgrind | asan,
 cryptolib_version_compiled =&gt; <code>string()</code> | undefined,
 cryptolib_version_linked := <code>string()</code>,
 link_type := dynamic | static,
 otp_crypto_version := <code>string()</code>}</code></pre>
<div class="title-since"><span class="since">OTP 24.2</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Provides a map with information about the compilation and linking of crypto. </p> <p>Example:</p> <pre data-language="erlang">1&gt; crypto:info().
#{compile_type =&gt; normal,
  cryptolib_version_compiled =&gt; "OpenSSL 3.0.0 7 sep 2021",
  cryptolib_version_linked =&gt; "OpenSSL 3.0.0 7 sep 2021",
  link_type =&gt; dynamic,
  otp_crypto_version =&gt; "5.0.2"}
2&gt;</pre> <p>More association types than documented may be present in the map. </p> </div></div></article><article class="func"><h3 id="info_lib-0" class="bold_code title-link func-head">  <code>info_lib() -&gt; [{Name, VerNum, VerStr}]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = binary()</code></div> <div class="REFTYPES rt-1"><code>VerNum = integer()</code></div> <div class="REFTYPES rt-1"><code>VerStr = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Provides the name and version of the libraries used by crypto.</p> <p><code>Name</code> is the name of the library. <code>VerNum</code> is the numeric version according to the library's own versioning scheme. <code>VerStr</code> contains a text variant of the version.</p> <pre data-language="erlang">
&gt; <code>info_lib().</code>
[{&lt;&lt;"OpenSSL"&gt;&gt;,269484095,&lt;&lt;"OpenSSL 1.1.0c  10 Nov 2016""&gt;&gt;}]
        </pre> <div class="note"> <div class="label">Note</div> <div class="content">

<p> From OTP R16 the <strong>numeric version</strong> represents the version of the OpenSSL <strong>header files</strong> (<code>openssl/opensslv.h</code>) used when crypto was compiled. The text variant represents the libcrypto library used at runtime. In earlier OTP versions both numeric and text was taken from the library. </p>
</div> </div> </div></div></article><article class="func"><h3 id="hash_info-1" class="bold_code title-link func-head">  <code>hash_info(Type) -&gt; Result</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = <a href="#type-hash_algorithm">hash_algorithm()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Result = 
 #{size := integer(),
 block_size := integer(),
 type := integer()}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Provides a map with information about block_size, size and possibly other properties of the hash algorithm in question. </p> <p>For a list of supported hash algorithms, see <code><a href="#supports-1">supports(hashs)</a></code>. </p> </div></div></article><article class="func"><h3 id="cipher_info-1" class="bold_code title-link func-head">  <code>cipher_info(Type) -&gt; Result</code><div class="title-since"><span class="since">OTP 22.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = <a href="#type-cipher">cipher()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Result = 
 #{key_length := integer(),
 iv_length := integer(),
 block_size := integer(),
 mode := CipherModes,
 type := undefined | integer(),
 prop_aead := boolean()}</code></pre></div> <div class="REFTYPES rt-1"><pre><code>CipherModes = 
 undefined | cbc_mode | ccm_mode | cfb_mode | ctr_mode |
 ecb_mode | gcm_mode | ige_mode | ocb_mode | ofb_mode |
 wrap_mode | xts_mode</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Provides a map with information about block_size, key_length, iv_length, aead support and possibly other properties of the cipher algorithm in question. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The ciphers <code>aes_cbc</code>, <code>aes_cfb8</code>, <code>aes_cfb128</code>, <code>aes_ctr</code>, <code>aes_ecb</code>, <code>aes_gcm</code> and <code>aes_ccm</code> has no keylength in the <code>Type</code> as opposed to for example <code>aes_128_ctr</code>. They adapt to the length of the key provided in the encrypt and decrypt function. Therefore it is impossible to return a valid keylength in the map.</p> <p>Always use a <code>Type</code> with an explicit key length, </p> </div> </div> <p>For a list of supported cipher algorithms, see <code><a href="#supports-1">supports(ciphers)</a></code>. </p> </div></div></article><article class="func"><h3 id="mod_pow-3" class="bold_code title-link func-head">  <code>mod_pow(N, P, M) -&gt; Result</code><div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>N = P = M = binary() | integer()</code></div>   <div class="REFTYPES rt-1"><code>Result = binary() | error</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Computes the function <code>N^P mod M</code>.</p> </div></div></article><article class="func"><h3 id="private_decrypt-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>private_decrypt(Algorithm, CipherText, PrivateKey, Options) -&gt;
 PlainText</code></pre>
<div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Algorithm = <a href="#type-pk_encrypt_decrypt_algs">pk_encrypt_decrypt_algs()</a></code></div> <div class="REFTYPES rt-1"><code>CipherText = binary()</code></div> <div class="REFTYPES rt-1"><code>PrivateKey = <a href="#type-rsa_private">rsa_private()</a> | <a href="#type-engine_key_ref">engine_key_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-pk_encrypt_decrypt_opts">pk_encrypt_decrypt_opts()</a></code></div> <div class="REFTYPES rt-1"><code>PlainText = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Decrypts the <code>CipherText</code>, encrypted with <code><a href="#public_encrypt-4">public_encrypt/4</a></code> (or equivalent function) using the <code>PrivateKey</code>, and returns the plaintext (message digest). This is a low level signature verification operation used for instance by older versions of the SSL protocol. See also <code>public_key:decrypt_private/[2,3]</code> </p> </div></div></article><article class="func"><h3 id="private_encrypt-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>private_encrypt(Algorithm, PlainText, PrivateKey, Options) -&gt;
 CipherText</code></pre>
<div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Algorithm = <a href="#type-pk_encrypt_decrypt_algs">pk_encrypt_decrypt_algs()</a></code></div> <div class="REFTYPES rt-1"><code>PlainText = binary()</code></div> <div class="REFTYPES rt-1"><code>PrivateKey = <a href="#type-rsa_private">rsa_private()</a> | <a href="#type-engine_key_ref">engine_key_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-pk_encrypt_decrypt_opts">pk_encrypt_decrypt_opts()</a></code></div> <div class="REFTYPES rt-1"><code>CipherText = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Encrypts the <code>PlainText</code> using the <code>PrivateKey</code> and returns the ciphertext. This is a low level signature operation used for instance by older versions of the SSL protocol. See also <code>public_key:encrypt_private/[2,3]</code> </p> </div></div></article><article class="func"><h3 id="public_decrypt-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>public_decrypt(Algorithm, CipherText, PublicKey, Options) -&gt;
 PlainText</code></pre>
<div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Algorithm = <a href="#type-pk_encrypt_decrypt_algs">pk_encrypt_decrypt_algs()</a></code></div> <div class="REFTYPES rt-1"><code>CipherText = binary()</code></div> <div class="REFTYPES rt-1"><code>PublicKey = <a href="#type-rsa_public">rsa_public()</a> | <a href="#type-engine_key_ref">engine_key_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-pk_encrypt_decrypt_opts">pk_encrypt_decrypt_opts()</a></code></div> <div class="REFTYPES rt-1"><code>PlainText = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Decrypts the <code>CipherText</code>, encrypted with <code><a href="#private_encrypt-4">private_encrypt/4</a></code>(or equivalent function) using the <code>PrivateKey</code>, and returns the plaintext (message digest). This is a low level signature verification operation used for instance by older versions of the SSL protocol. See also <code>public_key:decrypt_public/[2,3]</code> </p> </div></div></article><article class="func"><h3 id="public_encrypt-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>public_encrypt(Algorithm, PlainText, PublicKey, Options) -&gt;
 CipherText</code></pre>
<div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Algorithm = <a href="#type-pk_encrypt_decrypt_algs">pk_encrypt_decrypt_algs()</a></code></div> <div class="REFTYPES rt-1"><code>PlainText = binary()</code></div> <div class="REFTYPES rt-1"><code>PublicKey = <a href="#type-rsa_public">rsa_public()</a> | <a href="#type-engine_key_ref">engine_key_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-pk_encrypt_decrypt_opts">pk_encrypt_decrypt_opts()</a></code></div> <div class="REFTYPES rt-1"><code>CipherText = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Encrypts the <code>PlainText</code> (message digest) using the <code>PublicKey</code> and returns the <code>CipherText</code>. This is a low level signature operation used for instance by older versions of the SSL protocol. See also <code>public_key:encrypt_public/[2,3]</code> </p> </div></div></article><article class="func"><h3 id="rand_seed-1" class="bold_code title-link func-head">  <code>rand_seed(Seed :: <code>binary()</code>) -&gt; ok</code><div class="title-since"><span class="since">OTP 17.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Set the seed for PRNG to the given binary. This calls the RAND_seed function from openssl. Only use this if the system you are running on does not have enough "randomness" built in. Normally this is when <code><a href="#strong_rand_bytes-1">strong_rand_bytes/1</a></code> raises <code>error:low_entropy</code></p> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="rand_uniform-2" class="title-link">  <div class="title-name">rand_uniform(Lo, Hi) -&gt; N</div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Lo, Hi, N = integer()</code><br> </div> </div> <div class="REFBODY rb-7"> <p>Generate a random number <code>N, Lo =&lt; N &lt; Hi.</code> Uses the <code>crypto</code> library pseudo-random number generator. <code>Hi</code> must be larger than <code>Lo</code>.</p> </div> </div></article><article class="func"><h3 id="start-0" class="bold_code title-link func-head">  <code>start() -&gt; ok | {error, Reason :: <code>term()</code>}</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Equivalent to application:start(crypto).</p> </div></div></article><article class="func"><h3 id="stop-0" class="bold_code title-link func-head">  <code>stop() -&gt; ok | {error, Reason :: <code>term()</code>}</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Equivalent to application:stop(crypto).</p> </div></div></article><article class="func"><h3 id="strong_rand_bytes-1" class="bold_code title-link func-head">  <code>strong_rand_bytes(N :: <code>integer() &gt;= 0</code>) -&gt; <code>binary()</code></code><div class="title-since"><span class="since">OTP R14B03</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Generates N bytes randomly uniform 0..255, and returns the result in a binary. Uses a cryptographically secure prng seeded and periodically mixed with operating system provided entropy. By default this is the <code>RAND_bytes</code> method from OpenSSL.</p> <p>May raise exception <code>error:low_entropy</code> in case the random generator failed due to lack of secure "randomness".</p> </div></div></article><article class="func"><h3 id="rand_seed-0" class="bold_code title-link func-head">  <code>rand_seed() -&gt; <code>rand:state()</code></code><div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Creates state object for <code>random number generation</code>, in order to generate cryptographically strong random numbers (based on OpenSSL's <code>BN_rand_range</code>), and saves it in the process dictionary before returning it as well. See also <code>rand:seed/1</code> and <code><a href="#rand_seed_s-0">rand_seed_s/0</a></code>. </p> <p> When using the state object from this function the <code>rand</code> functions using it may raise exception <code>error:low_entropy</code> in case the random generator failed due to lack of secure "randomness". </p> <p><strong>Example</strong></p> <pre data-language="erlang">
_ = crypto:rand_seed(),
_IntegerValue = rand:uniform(42), % [1; 42]
_FloatValue = rand:uniform().     % [0.0; 1.0[</pre> </div></div></article><article class="func"><h3 id="rand_seed_s-0" class="bold_code title-link func-head">  <code>rand_seed_s() -&gt; <code>rand:state()</code></code><div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Creates state object for <code>random number generation</code>, in order to generate cryptographically strongly random numbers (based on OpenSSL's <code>BN_rand_range</code>). See also <code>rand:seed_s/1</code>. </p> <p> When using the state object from this function the <code>rand</code> functions using it may raise exception <code>error:low_entropy</code> in case the random generator failed due to lack of secure "randomness". </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> The state returned from this function cannot be used to get a reproducible random sequence as from the other <code>rand</code> functions, since reproducibility does not match cryptographically safe. </p> <p> The only supported usage is to generate one distinct random sequence from this start state. </p> </div> </div> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="rand_seed_alg-1" class="title-link">  <div class="title-name">rand_seed_alg(Alg) -&gt; rand:state()</div> <div class="title-since"><span class="since">OTP 21.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Alg = crypto | crypto_cache</code><br> </div> </div> <div class="REFBODY rb-7">  <p id="rand_seed_alg-1"> Creates state object for <code>random number generation</code>, in order to generate cryptographically strong random numbers, and saves it in the process dictionary before returning it as well. See also <code>rand:seed/1</code> and <code><a href="#rand_seed_alg_s-1">rand_seed_alg_s/1</a></code>. </p> <p> When using the state object from this function the <code>rand</code> functions using it may raise exception <code>error:low_entropy</code> in case the random generator failed due to lack of secure "randomness". </p> <p><strong>Example</strong></p> <pre data-language="erlang">
_ = crypto:rand_seed_alg(crypto_cache),
_IntegerValue = rand:uniform(42), % [1; 42]
_FloatValue = rand:uniform().     % [0.0; 1.0[</pre> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="rand_seed_alg-2" class="title-link">  <div class="title-name">rand_seed_alg(Alg, Seed) -&gt; rand:state()</div> <div class="title-since"><span class="since">OTP-22.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Alg = crypto_aes</code><br> </div> </div> <div class="REFBODY rb-7">  <p id="rand_seed_alg-2"> Creates a state object for <code>random number generation</code>, in order to generate cryptographically unpredictable random numbers, and saves it in the process dictionary before returning it as well. See also <code><a href="#rand_seed_alg_s-2">rand_seed_alg_s/2</a></code>. </p> <p><strong>Example</strong></p> <pre data-language="erlang">
_ = crypto:rand_seed_alg(crypto_aes, "my seed"),
IntegerValue = rand:uniform(42), % [1; 42]
FloatValue = rand:uniform(),     % [0.0; 1.0[
_ = crypto:rand_seed_alg(crypto_aes, "my seed"),
IntegerValue = rand:uniform(42), % Same values
FloatValue = rand:uniform().     % again
	</pre> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="rand_seed_alg_s-1" class="title-link">  <div class="title-name">rand_seed_alg_s(Alg) -&gt; rand:state()</div> <div class="title-since"><span class="since">OTP 21.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Alg = crypto | crypto_cache</code><br> </div> </div> <div class="REFBODY rb-7">  <p id="rand_seed_alg_s-1"> Creates state object for <code>random number generation</code>, in order to generate cryptographically strongly random numbers. See also <code>rand:seed_s/1</code>. </p> <p> If <code>Alg</code> is <code>crypto</code> this function behaves exactly like <code><a href="#rand_seed_s-0">rand_seed_s/0</a></code>. </p> <p> If <code>Alg</code> is <code>crypto_cache</code> this function fetches random data with OpenSSL's <code>RAND_bytes</code> and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines. </p> <p> When using the state object from this function the <code>rand</code> functions using it may raise exception <code>error:low_entropy</code> in case the random generator failed due to lack of secure "randomness". </p> <p> The cache size can be changed from its default value using the <code><span> crypto app's </span></code> configuration parameter <code>rand_cache_size</code>. </p> <p> When using the state object from this function the <code>rand</code> functions using it may throw exception <code>low_entropy</code> in case the random generator failed due to lack of secure "randomness". </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> The state returned from this function cannot be used to get a reproducible random sequence as from the other <code>rand</code> functions, since reproducibility does not match cryptographically safe. </p> <p> In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable. </p> <p> The only supported usage is to generate one distinct random sequence from this start state. </p> </div> </div> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="rand_seed_alg_s-2" class="title-link">  <div class="title-name">rand_seed_alg_s(Alg, Seed) -&gt; rand:state()</div> <div class="title-since"><span class="since">OTP 22.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Alg = crypto_aes</code><br> </div> </div> <div class="REFBODY rb-7">  <p id="rand_seed_alg_s-2"> Creates a state object for <code>random number generation</code>, in order to generate cryptographically unpredictable random numbers. See also <code><a href="#rand_seed_alg-1">rand_seed_alg/1</a></code>. </p> <p> To get a long period the Xoroshiro928 generator from the <code>rand</code> module is used as a counter (with period 2^928 - 1) and the generator states are scrambled through AES to create 58-bit pseudo random values. </p> <p> The result should be statistically completely unpredictable random values, since the scrambling is cryptographically strong and the period is ridiculously long. But the generated numbers are not to be regarded as cryptographically strong since there is no re-keying schedule. </p> <ul> <li> <p> If you need cryptographically strong random numbers use <code><a href="#rand_seed_alg_s-1">rand_seed_alg_s/1</a></code> with <code>Alg =:= crypto</code> or <code>Alg =:= crypto_cache</code>. </p> </li> <li> <p> If you need to be able to repeat the sequence use this function. </p> </li> <li> <p> If you do not need the statistical quality of this function, there are faster algorithms in the <code>rand</code> module. </p> </li> </ul> <p> Thanks to the used generator the state object supports the <code>rand:jump/0,1</code> function with distance 2^512. </p> <p> Numbers are generated in batches and cached for speed reasons. The cache size can be changed from its default value using the <code><span> crypto app's </span></code> configuration parameter <code>rand_cache_size</code>. </p> </div> </div></article><article class="func"><h3 id="ec_curves-0" class="bold_code title-link func-head">  <code>ec_curves() -&gt; [EllipticCurve]</code><div class="title-since"><span class="since">OTP 17.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><pre><code>EllipticCurve = 
 <a href="#type-ec_named_curve">ec_named_curve()</a> | <a href="#type-edwards_curve_dh">edwards_curve_dh()</a> | <a href="#type-edwards_curve_ed">edwards_curve_ed()</a></code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Can be used to determine which named elliptic curves are supported.</p> </div></div></article><article class="func"><h3 id="ec_curve-1" class="bold_code title-link func-head">  <code>ec_curve(CurveName) -&gt; ExplicitCurve</code><div class="title-since"><span class="since">OTP 17.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>CurveName = <a href="#type-ec_named_curve">ec_named_curve()</a></code></div> <div class="REFTYPES rt-1"><code>ExplicitCurve = <a href="#type-ec_explicit_curve">ec_explicit_curve()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Return the defining parameters of a elliptic curve.</p> </div></div></article><article class="func"><h3 id="sign-4" class="bold_code title-link func-head">  <code>sign(Algorithm, DigestType, Msg, Key) -&gt; Signature</code><div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <h3 id="sign-5" class="bold_code title-link func-head">  <code>sign(Algorithm, DigestType, Msg, Key, Options) -&gt; Signature</code><div class="title-since"><span class="since">OTP 20.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Algorithm = <a href="#type-pk_sign_verify_algs">pk_sign_verify_algs()</a></code></div> <div class="REFTYPES rt-1"><pre><code>DigestType = 
 <a href="#type-rsa_digest_type">rsa_digest_type()</a> |
 <a href="#type-dss_digest_type">dss_digest_type()</a> |
 <a href="#type-ecdsa_digest_type">ecdsa_digest_type()</a> |
 none</code></pre></div> <div class="REFTYPES rt-1"><code>Msg = iodata() | {digest, iodata()}</code></div> <div class="REFTYPES rt-1"><pre><code>Key = 
 <a href="#type-rsa_private">rsa_private()</a> |
 <a href="#type-dss_private">dss_private()</a> |
 [<a href="#type-ecdsa_private">ecdsa_private()</a> | <a href="#type-ecdsa_params">ecdsa_params()</a>] |
 [<a href="#type-eddsa_private">eddsa_private()</a> | <a href="#type-eddsa_params">eddsa_params()</a>] |
 <a href="#type-engine_key_ref">engine_key_ref()</a></code></pre></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-pk_sign_verify_opts">pk_sign_verify_opts()</a></code></div> <div class="REFTYPES rt-1"><code>Signature = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Creates a digital signature.</p> <p>The msg is either the binary "cleartext" data to be signed or it is the hashed value of "cleartext" i.e. the digest (plaintext).</p> <p>Algorithm <code>dss</code> can only be used together with digest type <code>sha</code>.</p> <p>See also <code>public_key:sign/3</code>.</p> </div></div></article><article class="func"><h3 id="verify-5" class="bold_code title-link func-head">  <code>verify(Algorithm, DigestType, Msg, Signature, Key) -&gt; Result</code><div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <h3 id="verify-6" class="bold_code title-link func-head">  <pre data-language="erlang"><code>verify(Algorithm, DigestType, Msg, Signature, Key, Options) -&gt;
 Result</code></pre>
<div class="title-since"><span class="since">OTP 20.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Algorithm = <a href="#type-pk_sign_verify_algs">pk_sign_verify_algs()</a></code></div> <div class="REFTYPES rt-1"><pre><code>DigestType = 
 <a href="#type-rsa_digest_type">rsa_digest_type()</a> |
 <a href="#type-dss_digest_type">dss_digest_type()</a> |
 <a href="#type-ecdsa_digest_type">ecdsa_digest_type()</a> |
 none</code></pre></div> <div class="REFTYPES rt-1"><code>Msg = iodata() | {digest, iodata()}</code></div> <div class="REFTYPES rt-1"><code>Signature = binary()</code></div> <div class="REFTYPES rt-1"><pre><code>Key = 
 <a href="#type-rsa_public">rsa_public()</a> |
 <a href="#type-dss_public">dss_public()</a> |
 [<a href="#type-ecdsa_public">ecdsa_public()</a> | <a href="#type-ecdsa_params">ecdsa_params()</a>] |
 [<a href="#type-eddsa_public">eddsa_public()</a> | <a href="#type-eddsa_params">eddsa_params()</a>] |
 <a href="#type-engine_key_ref">engine_key_ref()</a></code></pre></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-pk_sign_verify_opts">pk_sign_verify_opts()</a></code></div> <div class="REFTYPES rt-1"><code>Result = boolean()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p>Verifies a digital signature</p> <p>The msg is either the binary "cleartext" data to be signed or it is the hashed value of "cleartext" i.e. the digest (plaintext).</p> <p>Algorithm <code>dss</code> can only be used together with digest type <code>sha</code>.</p> <p>See also <code>public_key:verify/4</code>.</p> </div></div></article> </div> <section class="innertube"><h2 id="engine-api" class="title-link"> <div class="title-name">Engine API</div>  </h2> </section><div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="privkey_to_pubkey-2" class="bold_code title-link func-head">  <code>privkey_to_pubkey(Type, EnginePrivateKeyRef) -&gt; PublicKey</code><div class="title-since"><span class="since">OTP 20.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Type = rsa | dss</code></div> <div class="REFTYPES rt-1"><code>EnginePrivateKeyRef = <a href="#type-engine_key_ref">engine_key_ref()</a></code></div> <div class="REFTYPES rt-1"><code>PublicKey = <a href="#type-rsa_public">rsa_public()</a> | <a href="#type-dss_public">dss_public()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Fetches the corresponding public key from a private key stored in an Engine. The key must be of the type indicated by the Type parameter. </p> </div></div></article><article class="func"><h3 id="engine_get_all_methods-0" class="bold_code title-link func-head">  <code>engine_get_all_methods() -&gt; Result</code><div class="title-since"><span class="since">OTP 20.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Result = [<a href="#type-engine_method_type">engine_method_type()</a>]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a list of all possible engine methods. </p> <p> May raise exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> <p> See also the chapter <code>Engine Load</code> in the User's Guide. </p> </div></div></article><article class="func"><h3 id="engine_load-3" class="bold_code title-link func-head">  <code>engine_load(EngineId, PreCmds, PostCmds) -&gt; Result</code><div class="title-since"><span class="since">OTP 20.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>EngineId = unicode:chardata()</code></div> <div class="REFTYPES rt-1"><code>PreCmds = PostCmds = [<a href="#type-engine_cmnd">engine_cmnd()</a>]</code></div>  <div class="REFTYPES rt-1"><pre><code>Result = 
 {ok, Engine :: <a href="#type-engine_ref">engine_ref()</a>} | {error, Reason :: term()}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Loads the OpenSSL engine given by <code>EngineId</code> if it is available and intialize it. Returns ok and an engine handle, if the engine can't be loaded an error tuple is returned. </p> <p> The function raises a <code>error:badarg</code> if the parameters are in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> <p> See also the chapter <code>Engine Load</code> in the User's Guide. </p> </div></div></article><article class="func"><h3 id="engine_unload-1" class="bold_code title-link func-head">  <code>engine_unload(Engine) -&gt; Result</code><div class="title-since"><span class="since">OTP 20.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Engine = <a href="#type-engine_ref">engine_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Result = ok | {error, Reason :: term()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Unloads the OpenSSL engine given by <code>Engine</code>. An error tuple is returned if the engine can't be unloaded. </p> <p> The function raises a <code>error:badarg</code> if the parameter is in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> <p> See also the chapter <code>Engine Load</code> in the User's Guide. </p> </div></div></article><article class="func"><h3 id="engine_by_id-1" class="bold_code title-link func-head">  <code>engine_by_id(EngineId) -&gt; Result</code><div class="title-since"><span class="since">OTP 21.0.6</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>EngineId = unicode:chardata()</code></div> <div class="REFTYPES rt-1"><pre><code>Result = 
 {ok, Engine :: <a href="#type-engine_ref">engine_ref()</a>} | {error, Reason :: term()}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Get a reference to an already loaded engine with <code>EngineId</code>. An error tuple is returned if the engine can't be unloaded. </p> <p> The function raises a <code>error:badarg</code> if the parameter is in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> <p> See also the chapter <code>Engine Load</code> in the User's Guide. </p> </div></div></article><article class="func"><h3 id="engine_ctrl_cmd_string-3" class="bold_code title-link func-head">  <code>engine_ctrl_cmd_string(Engine, CmdName, CmdArg) -&gt; Result</code><div class="title-since"><span class="since">OTP 20.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Engine = term()</code></div> <div class="REFTYPES rt-1"><code>CmdName = CmdArg = unicode:chardata()</code></div>  <div class="REFTYPES rt-1"><code>Result = ok | {error, Reason :: term()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends ctrl commands to the OpenSSL engine given by <code>Engine</code>. This function is the same as calling <code>engine_ctrl_cmd_string/4</code> with <code>Optional</code> set to <code>false</code>. </p> <p> The function raises a <code>error:badarg</code> if the parameters are in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> </div></div></article><article class="func"><h3 id="engine_ctrl_cmd_string-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>engine_ctrl_cmd_string(Engine, CmdName, CmdArg, Optional) -&gt;
 Result</code></pre>
<div class="title-since"><span class="since">OTP 20.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Engine = term()</code></div> <div class="REFTYPES rt-1"><code>CmdName = CmdArg = unicode:chardata()</code></div>  <div class="REFTYPES rt-1"><code>Optional = boolean()</code></div> <div class="REFTYPES rt-1"><code>Result = ok | {error, Reason :: term()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends ctrl commands to the OpenSSL engine given by <code>Engine</code>. <code>Optional</code> is a boolean argument that can relax the semantics of the function. If set to <code>true</code> it will only return failure if the ENGINE supported the given command name but failed while executing it, if the ENGINE doesn't support the command name it will simply return success without doing anything. In this case we assume the user is only supplying commands specific to the given ENGINE so we set this to <code>false</code>. </p> <p> The function raises a <code>error:badarg</code> if the parameters are in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> </div></div></article><article class="func"><h3 id="engine_add-1" class="bold_code title-link func-head">  <code>engine_add(Engine) -&gt; Result</code><div class="title-since"><span class="since">OTP 21.0.6</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Engine = <a href="#type-engine_ref">engine_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Result = ok | {error, Reason :: term()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Add the engine to OpenSSL's internal list.</p> <p> The function raises a <code>error:badarg</code> if the parameters are in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> </div></div></article><article class="func"><h3 id="engine_remove-1" class="bold_code title-link func-head">  <code>engine_remove(Engine) -&gt; Result</code><div class="title-since"><span class="since">OTP 21.0.6</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Engine = <a href="#type-engine_ref">engine_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Result = ok | {error, Reason :: term()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Remove the engine from OpenSSL's internal list.</p> <p> The function raises a <code>error:badarg</code> if the parameters are in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> </div></div></article><article class="func"><h3 id="engine_register-2" class="bold_code title-link func-head">  <code>engine_register(Engine, EngineMethods) -&gt; Result</code><div class="title-since"><span class="since">OTP 25.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Engine = <a href="#type-engine_ref">engine_ref()</a></code></div> <div class="REFTYPES rt-1"><code>EngineMethods = [<a href="#type-engine_method_type">engine_method_type()</a>]</code></div> <div class="REFTYPES rt-1"><code>Result = ok | {error, Reason :: term()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Register engine to handle some type of methods, for example engine_method_digests.</p> <p> The function raises a <code>error:badarg</code> if the parameters are in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> </div></div></article><article class="func"><h3 id="engine_unregister-2" class="bold_code title-link func-head">  <code>engine_unregister(Engine, EngineMethods) -&gt; Result</code><div class="title-since"><span class="since">OTP 25.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Engine = <a href="#type-engine_ref">engine_ref()</a></code></div> <div class="REFTYPES rt-1"><code>EngineMethods = [<a href="#type-engine_method_type">engine_method_type()</a>]</code></div> <div class="REFTYPES rt-1"><code>Result = ok | {error, Reason :: term()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Unregister engine so it don't handle some type of methods.</p> <p> The function raises a <code>error:badarg</code> if the parameters are in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> </div></div></article><article class="func"><h3 id="engine_get_id-1" class="bold_code title-link func-head">  <code>engine_get_id(Engine) -&gt; EngineId</code><div class="title-since"><span class="since">OTP 21.0.6</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Engine = <a href="#type-engine_ref">engine_ref()</a></code></div> <div class="REFTYPES rt-1"><code>EngineId = unicode:chardata()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Return the ID for the engine, or an empty binary if there is no id set.</p> <p> The function raises a <code>error:badarg</code> if the parameters are in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> </div></div></article><article class="func"><h3 id="engine_get_name-1" class="bold_code title-link func-head">  <code>engine_get_name(Engine) -&gt; EngineName</code><div class="title-since"><span class="since">OTP 21.0.6</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Engine = <a href="#type-engine_ref">engine_ref()</a></code></div> <div class="REFTYPES rt-1"><code>EngineName = unicode:chardata()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Return the name (eg a description) for the engine, or an empty binary if there is no name set.</p> <p> The function raises a <code>error:badarg</code> if the parameters are in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> </div></div></article><article class="func"><h3 id="engine_list-0" class="bold_code title-link func-head">  <code>engine_list() -&gt; Result</code><div class="title-since"><span class="since">OTP 20.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Result = [EngineId :: unicode:chardata()]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>List the id's of all engines in OpenSSL's internal list.</p> <p> It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> <p> See also the chapter <code>Engine Load</code> in the User's Guide. </p> <p> May raise exception <code>error:notsup</code> in case engine functionality is not supported by the underlying OpenSSL implementation. </p> </div></div></article><article class="func"><h3 id="ensure_engine_loaded-2" class="bold_code title-link func-head">  <code>ensure_engine_loaded(EngineId, LibPath) -&gt; Result</code><div class="title-since"><span class="since">OTP 21.0.6</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>EngineId = LibPath = unicode:chardata()</code></div>  <div class="REFTYPES rt-1"><pre><code>Result = 
 {ok, Engine :: <a href="#type-engine_ref">engine_ref()</a>} | {error, Reason :: term()}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Loads an engine given by <code>EngineId</code> and the path to the dynamic library implementing the engine. An error tuple is returned if the engine can't be loaded. </p> <p> This function differs from the normal engine_load in the sense that it also add the engine id to OpenSSL's internal engine list. The difference between the first call and the following is that the first loads the engine with the dynamical engine and the following calls fetch it from the OpenSSL's engine list. All references that is returned are equal. </p> <p> Use <code>engine_unload/1</code> function to remove the references. But remember that <code>engine_unload/1</code> just removes the references to the engine and not the tag in OpenSSL's engine list. That has to be done with the <code>engine_remove/1</code> function when needed (just called once, from any of the references you got). </p> <p> The function raises a <code>error:badarg</code> if the parameters are in wrong format. It may also raise the exception <code>error:notsup</code> in case there is no engine support in the underlying OpenSSL implementation. </p> <p> See also the chapter <code>Engine Load</code> in the User's Guide. </p> </div></div></article><article class="func"><h3 id="hash_equals-2" class="bold_code title-link func-head">  <code>hash_equals(BinA, BinB) -&gt; Result</code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>BinA = BinB = binary()</code></div>  <div class="REFTYPES rt-1"><code>Result = boolean()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Constant time memory comparison for fixed length binaries, such as results of HMAC computations. </p> <p> Returns true if the binaries are identical, false if they are of the same length but not identical. The function raises an <code>error:badarg</code> exception if the binaries are of different size. </p> </div></div></article><article class="func"><h3 id="pbkdf2_hmac-5" class="bold_code title-link func-head">  <code>pbkdf2_hmac(Digest, Pass, Salt, Iter, KeyLen) -&gt; Result</code><div class="title-since"><span class="since">OTP 24.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Digest = sha | sha224 | sha256 | sha384 | sha512</code></div> <div class="REFTYPES rt-1"><code>Pass = Salt = binary()</code></div>  <div class="REFTYPES rt-1"><code>Iter = KeyLen = integer() &gt;= 1</code></div>  <div class="REFTYPES rt-1"><code>Result = binary()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses the <code><a href="#error_3tup">3-tuple style</a></code> for error handling.</p> <p> PKCS #5 PBKDF2 (Password-Based Key Derivation Function 2) in combination with HMAC. </p> </div></div></article> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
