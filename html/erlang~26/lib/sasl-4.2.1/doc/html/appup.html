  <div class="innertube"> <h2 id="file" class="title-link"> <div class="title-name">File</div>  </h2> <div class="REFBODY file-body">appup</div> </div> <div class="innertube"> <h2 id="file-summary" class="title-link"> <div class="title-name">File Summary</div>  </h2> <div class="REFBODY file-summary-body">Application upgrade file</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>The <strong>application upgrade file</strong> defines how an application is upgraded or downgraded in a running system.</p> <p>This file is used by the functions in <code><a href="systools.html">systools</a></code> when generating a release upgrade file <code>relup</code>.</p> </div> </div></section> <section class="innertube"><h2 id="file-syntax" class="title-link"> <div class="title-name">File Syntax</div>  </h2> <div class="REFBODY rb-3"> <p>The application upgrade file is to be called <code>Application.appup</code>, where <code>Application</code> is the application name. The file is to be located in the <code>ebin</code> directory for the application.</p> <p>The <code>.appup</code> file contains one single Erlang term, which defines the instructions used to upgrade or downgrade the application. The file has the following syntax:</p> <pre data-language="erlang">{Vsn,
  [{UpFromVsn, Instructions}, ...],
  [{DownToVsn, Instructions}, ...]}.</pre> <dl> <dt class="title-link"><strong><code>Vsn = string()</code></strong></dt> <dd><p>Current application version.</p></dd> <dt class="title-link"><strong><code>UpFromVsn = string() | binary()</code></strong></dt> <dd><p>An earlier application version to upgrade from. If it is a string, it is interpreted as a specific version number. If it is a binary, it is interpreted as a regular expression that can match multiple version numbers.</p></dd> <dt class="title-link"><strong><code>DownToVsn = string() | binary()</code></strong></dt> <dd><p>An earlier application version to downgrade to. If it is a string, it is interpreted as a specific version number. If it is a binary, it is interpreted as a regular expression that can match multiple version numbers.</p></dd> <dt class="title-link"><strong><code>Instructions</code></strong></dt> <dd><p>A list of <strong>release upgrade instructions</strong>, see <code><a href="#Release%20Upgrade%20Instructions">Release Upgrade Instructions</a></code>. It is recommended to use high-level instructions only. These are automatically translated to low-level instructions by <code>systools</code> when creating the <code>relup</code> file.</p></dd> </dl> <p>To avoid duplication of upgrade instructions, it is allowed to use regular expressions to specify <code>UpFromVsn</code> and <code>DownToVsn</code>. To be considered a regular expression, the version identifier must be specified as a binary. For example, the following match all versions <code>2.1.x</code>, where <code>x</code> is any number:</p> <pre data-language="erlang">&lt;&lt;"2\\.1\\.[0-9]+"&gt;&gt;</pre> <p>Notice that the regular expression must match the complete version string, so this example works for, for example, <code>2.1.1</code>, but not for <code>2.1.1.1</code>.</p> </div></section> <section class="innertube"><h2 id="release-upgrade-instructions" class="title-link"> <div class="title-name">Release Upgrade Instructions</div>  </h2> <div class="REFBODY rb-3"> <p>Release upgrade instructions are interpreted by the release handler when an upgrade or downgrade is made. For more information about release handling, see <code>OTP Design Principles</code> in <strong>System Documentation</strong>.</p> <p>A process is said to <strong>use</strong> a module <code>Mod</code> if <code>Mod</code> is listed in the <code>Modules</code> part of the child specification used to start the process, see <code>supervisor(3)</code>. In the case of <code>gen_event</code>, an event manager process is said to use <code>Mod</code> if <code>Mod</code> is an installed event handler.</p> <section><h3 id="High-Level Instructions">High-Level Instructions</h3> <div class="REFBODY rb-4"> <pre data-language="erlang">
{update, Mod}
{update, Mod, supervisor}
{update, Mod, Change}
{update, Mod, DepMods}
{update, Mod, Change, DepMods}
{update, Mod, Change, PrePurge, PostPurge, DepMods}
{update, Mod, Timeout, Change, PrePurge, PostPurge, DepMods}
{update, Mod, ModType, Timeout, Change, PrePurge, PostPurge, DepMods}
  Mod = atom()
  ModType = static | dynamic
  Timeout = int()&gt;0 | default | infinity
  Change = soft | {advanced,Extra}
    Extra = term()
  PrePurge = PostPurge = soft_purge | brutal_purge
  DepMods = [Mod]</pre> <p>Synchronized code replacement of processes using module <code>Mod</code>.</p> <p>All those processes are suspended using <code>sys:suspend</code>, the new module version is loaded, and then the processes are resumed using <code>sys:resume</code>.</p> <dl> <dt class="title-link"><strong><code>Change</code></strong></dt> <dd><p>Defaults to <code>soft</code> and defines the type of code change. If it is set to <code>{advanced,Extra}</code>, implemented processes using <code>gen_server</code>, <code>gen_fsm</code>, <code>gen_statem</code>, or <code>gen_event</code> transform their internal state by calling the callback function <code>code_change</code>. Special processes call the callback function <code>system_code_change/4</code>. In both cases, the term <code>Extra</code> is passed as an argument to the callback function.</p></dd> <dt class="title-link"><strong><code>PrePurge</code></strong></dt> <dd><p>Defaults to <code>brutal_purge</code>. It controls what action to take with processes executing old code before loading the new module version. If the value is <code>brutal_purge</code>, the processes are killed. If the value is <code>soft_purge</code>, <code><a href="release_handler.html#install_release-1">release_handler:install_release/1</a></code> returns <code>{error,{old_processes,Mod}}</code>.</p></dd> <dt class="title-link"><strong><code>PostPurge</code></strong></dt> <dd><p>Defaults to <code>brutal_purge</code>. It controls what action to take with processes that are executing old code when the new module version has been loaded. If the value is <code>brutal_purge</code>, the code is purged when the release is made permanent and the processes are killed. If the value is <code>soft_purge</code>, the release handler purges the old code when no remaining processes execute the code.</p></dd> <dt class="title-link"><strong><code>DepMods</code></strong></dt> <dd><p>Defaults to <code>[]</code> and defines other modules that <code>Mod</code> is dependent on. In the <code>relup</code> file, instructions for suspending processes using <code>Mod</code> come before instructions for suspending processes using modules in <code>DepMods</code> when upgrading, and conversely when downgrading. In case of circular dependencies, the order of the instructions in the <code>appup</code> file is kept.</p></dd> <dt class="title-link"><strong><code>Timeout</code></strong></dt> <dd><p>Defines the time-out when suspending processes. If no value or <code>default</code> is specified, the default value for <code>sys:suspend</code> is used.</p></dd> <dt class="title-link"><strong><code>ModType</code></strong></dt> <dd><p>Defaults to <code>dynamic</code>. It specifies if the code is "dynamic", that is, if a process using the module spontaneously switches to new code, or if it is "static". When doing an advanced update and upgrade, the new version of a dynamic module is loaded before the process is asked to change code. When downgrading, the process is asked to change code before loading the new version. For static modules, the new version is loaded before the process is asked to change code, both in the case of upgrading and downgrading. Callback modules are dynamic.</p></dd> </dl> <p><code>update</code> with argument <code>supervisor</code> is used when changing the start specification of a supervisor.</p> <pre data-language="erlang">
{load_module, Mod}
{load_module, Mod, DepMods}
{load_module, Mod, PrePurge, PostPurge, DepMods}
  Mod = atom()
  PrePurge = PostPurge = soft_purge | brutal_purge
  DepMods = [Mod]</pre> <p>Simple code replacement of the module <code>Mod</code>.</p> <p>For a description of <code>PrePurge</code> and <code>PostPurge</code>, see <code>update</code> above.</p> <p><code>DepMods</code> defaults to <code>[]</code> and defines which other modules <code>Mod</code> is dependent on. In the <code>relup</code> file, instructions for loading these modules come before the instruction for loading <code>Mod</code> when upgrading, and conversely when downgrading.</p> <pre data-language="erlang">
{add_module, Mod}
{add_module, Mod, DepMods}
  Mod = atom()
  DepMods = [Mod]</pre> <p>Loads a new module <code>Mod</code>.</p> <p><code>DepMods</code> defaults to <code>[]</code> and defines which other modules <code>Mod</code> is dependent on. In the <code>relup</code> file, instructions related to these modules come before the instruction for loading <code>Mod</code> when upgrading, and conversely when downgrading.</p> <pre data-language="erlang">
{delete_module, Mod}
{delete_module, Mod, DepMods}
  Mod = atom()</pre> <p>Deletes a module <code>Mod</code> using the low-level instructions <code>remove</code> and <code>purge</code>.</p> <p><code>DepMods</code> defaults to <code>[]</code> and defines which other modules <code>Mod</code> is dependent on. In the <code>relup</code> file, instructions related to these modules come before the instruction for removing <code>Mod</code> when upgrading, and conversely when downgrading.</p> <pre data-language="erlang">
{add_application, Application}
{add_application, Application, Type}
  Application = atom()
  Type = permanent | transient | temporary | load | none</pre> <p>Adding an application means that the modules defined by the <code>modules</code> key in the <code>.app</code> file are loaded using <code>add_module</code>.</p> <p><code>Type</code> defaults to <code>permanent</code> and specifies the start type of the application. If <code>Type = permanent | transient | temporary</code>, the application is loaded and started in the corresponding way, see <code>application(3)</code>. If <code>Type = load</code>, the application is only loaded. If <code>Type = none</code>, the application is not loaded and not started, although the code for its modules is loaded.</p> <pre data-language="erlang">
{remove_application, Application}
  Application = atom()</pre> <p>Removing an application means that the application is stopped, the modules are unloaded using <code>delete_module</code>, and then the application specification is unloaded from the application controller.</p> <pre data-language="erlang">
{restart_application, Application}
  Application = atom()</pre> <p>Restarting an application means that the application is stopped and then started again, similar to using the instructions <code>remove_application</code> and <code>add_application</code> in sequence. Note that, even if the application has been started before the release upgrade is performed, <code>restart_application</code> may only <code>load</code> it rather than <code>start</code> it, depending on the application's <code>start type</code>: If <code>Type = load</code>, the application is only loaded. If <code>Type = none</code>, the application is not loaded and not started, although the code for its modules is loaded. </p> </div></section> <section><h3 id="Low-Level Instructions">Low-Level Instructions</h3> <div class="REFBODY rb-4"> <pre data-language="erlang">
{load_object_code, {App, Vsn, [Mod]}}
  App = Mod = atom()
  Vsn = string()</pre> <p>Reads each <code>Mod</code> from directory <code>App-Vsn/ebin</code> as a binary. It does not load the modules. The instruction is to be placed first in the script to read all new code from the file to make the suspend-load-resume cycle less time-consuming.</p> <pre data-language="erlang">
point_of_no_return</pre> <p>If a crash occurs after this instruction, the system cannot recover and is restarted from the old release version. The instruction must only occur once in a script. It is to be placed after all <code>load_object_code</code> instructions.</p> <pre data-language="erlang">
{load, {Mod, PrePurge, PostPurge}}
  Mod = atom()
  PrePurge = PostPurge = soft_purge | brutal_purge</pre> <p>Before this instruction occurs, <code>Mod</code> must have been loaded using <code>load_object_code</code>. This instruction loads the module. <code>PrePurge</code> is ignored. For a description of <code>PostPurge</code>, see the high-level instruction <code>update</code> earlier.</p> <pre data-language="erlang">
{remove, {Mod, PrePurge, PostPurge}}
  Mod = atom()
  PrePurge = PostPurge = soft_purge | brutal_purge</pre> <p>Makes the current version of <code>Mod</code> old. <code>PrePurge</code> is ignored. For a description of <code>PostPurge</code>, see the high-level instruction <code>update</code> earlier.</p> <pre data-language="erlang">
{purge, [Mod]}
  Mod = atom()</pre> <p>Purges each module <code>Mod</code>, that is, removes the old code. Notice that any process executing purged code is killed.</p> <pre data-language="erlang">
{suspend, [Mod | {Mod, Timeout}]}
  Mod = atom()
  Timeout = int()&gt;0 | default | infinity</pre> <p>Tries to suspend all processes using a module <code>Mod</code>. If a process does not respond, it is ignored. This can cause the process to die, either because it crashes when it spontaneously switches to new code, or as a result of a purge operation. If no <code>Timeout</code> is specified or <code>default</code> is specified, the default value for <code>sys:suspend</code> is used.</p> <pre data-language="erlang">
{resume, [Mod]}
  Mod = atom()</pre> <p>Resumes all suspended processes using a module <code>Mod</code>.</p> <pre data-language="erlang">
{code_change, [{Mod, Extra}]}
{code_change, Mode, [{Mod, Extra}]}
  Mod = atom()
  Mode = up | down
  Extra = term()</pre> <p><code>Mode</code> defaults to <code>up</code> and specifies if it is an upgrade or downgrade. This instruction sends a <code>code_change</code> system message to all processes using a module <code>Mod</code> by calling function <code>sys:change_code</code>, passing term <code>Extra</code> as argument.</p> <pre data-language="erlang">
{stop, [Mod]}
  Mod = atom()</pre> <p>Stops all processes using a module <code>Mod</code> by calling <code>supervisor:terminate_child/2</code>. This instruction is useful when the simplest way to change code is to stop and restart the processes that run the code.</p> <pre data-language="erlang">
{start, [Mod]}
  Mod = atom()</pre> <p>Starts all stopped processes using a module <code>Mod</code> by calling <code>supervisor:restart_child/2</code>.</p> <pre data-language="erlang">
{sync_nodes, Id, [Node]}
{sync_nodes, Id, {M, F, A}}
  Id = term()
  Node = node()
  M = F = atom()
  A = [term()]</pre> <p><code>apply(M, F, A)</code> must return a list of nodes.</p> <p>This instruction synchronizes the release installation with other nodes. Each <code>Node</code> must evaluate this command with the same <code>Id</code>. The local node waits for all other nodes to evaluate the instruction before execution continues. If a node goes down, it is considered to be an unrecoverable error, and the local node is restarted from the old release. There is no time-out for this instruction, which means that it can hang forever.</p> <pre data-language="erlang">
{apply, {M, F, A}}
  M = F = atom()
  A = [term()]</pre> <p>Evaluates <code>apply(M, F, A)</code>.</p> <p>If the instruction appears before instruction <code>point_of_no_return</code>, a failure is caught. <code><a href="release_handler.html#install_release-1">release_handler:install_release/1</a></code> then returns <code>{error,{'EXIT',Reason}}</code>, unless <code>{error,Error}</code> is thrown or returned. Then it returns <code>{error,Error}</code>.</p> <p>If the instruction appears after instruction <code>point_of_no_return</code> and the function call fails, the system is restarted.</p> <pre data-language="erlang">
restart_new_emulator</pre> <p>This instruction is used when the application ERTS, Kernel, STDLIB, or SASL is upgraded. It shuts down the current emulator and starts a new one. All processes are terminated gracefully, and the new version of ERTS, Kernel, STDLIB, and SASL are used when the emulator restarts. Only one <code>restart_new_emulator</code> instruction is allowed in the <code>relup</code> file, and it must be placed first. <code><a href="systools.html#make_relup-3">systools:make_relup/3,4</a></code> ensures this when the <code>relup</code> file is generated. The rest of the instructions in the <code>relup</code> file is executed after the restart as a part of the boot script.</p> <p>An info report is written when the upgrade is completed. To programmatically determine if the upgrade is complete, call <code><a href="release_handler.html#which_releases-0"> release_handler:which_releases/0,1</a></code> and check if the expected release has status <code>current</code>.</p> <p>The new release must still be made permanent after the upgrade is completed, otherwise the old emulator is started if there is an emulator restart.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>As stated earlier, instruction <code>restart_new_emulator</code> causes the emulator to be restarted with new versions of ERTS&gt;, Kernel, STDLIB, and SASL. However, all other applications do at startup run their old versions in this new emulator. This is usually no problem, but every now and then incompatible changes occur to the core applications, which can cause trouble in this setting. Such incompatible changes (when functions are removed) are normally preceded by a deprecation over two major releases. To ensure that your application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</p> </div> </div> <pre data-language="erlang">
restart_emulator</pre> <p>This instruction is similar to <code>restart_new_emulator</code>, except it must be placed at the end of the <code>relup</code> file. It is not related to an upgrade of the emulator or the core applications, but can be used by any application when a complete reboot of the system is required.</p> <p>When generating the <code>relup</code> file, <code><a href="systools.html#make_relup-3">systools:make_relup/3,4</a></code> ensures that there is only one <code>restart_emulator</code> instruction and that it is the last instruction in the <code>relup</code> file.</p> </div></section> </div></section> <section class="innertube"><h2 id="see-also" class="title-link"> <div class="title-name">See Also</div>  </h2> <div class="REFBODY rb-3"> <p><code><a href="release_handler.html">release_handler(3)</a></code>, <code><a href="relup.html">relup(4)</a></code>, <code>supervisor(3)</code>, <code><a href="systools.html">systools(3)</a></code></p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
