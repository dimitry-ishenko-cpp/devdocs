  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">ftp</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">A File Transfer Protocol client.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body" id="service_start">

<p>This module implements a client for file transfer according to a subset of the File Transfer Protocol (FTP), see <code><a href="http://www.ietf.org/rfc/rfc959.txt">RFC 959</a></code>.</p> <p>The FTP client always tries to use passive FTP mode and only resort to active FTP mode if this fails. This default behavior can be changed by start option <code><a href="#mode">mode</a></code>.</p> <p>For a simple example of an FTP session, see <code><a href="ftp_client.html">FTP User's Guide</a></code>.</p> <p>In addition to the ordinary functions for receiving and sending files (see <code>recv/2</code>, <code>recv/3</code>, <code>send/2</code>, and <code>send/3</code>) there are functions for receiving remote files as binaries (see <code>recv_bin/2</code>) and for sending binaries to be stored as remote files (see <code>send_bin/3</code>).</p> <p>A set of functions is provided for sending and receiving contiguous parts of a file to be stored in a remote file. For send, see <code>send_chunk_start/2</code>, <code>send_chunk/2</code>, and <code>send_chunk_end/1</code>. For receive, see <code>recv_chunk_start/2</code> and <code>recv_chunk/</code>).</p> <p>The return values of the following functions depend much on the implementation of the FTP server at the remote host. In particular, the results from <code>ls</code> and <code>nlist</code> varies. Often real errors are not reported as errors by <code>ls</code>, even if, for example, a file or directory does not exist. <code>nlist</code> is usually more strict, but some implementations have the peculiar behaviour of responding with an error if the request is a listing of the contents of a directory that exists but is empty.</p>  </div> </div></section> <section class="innertube"><h2 id="ftp-client-start-stop" class="title-link"> ftp client start/stop  </h2> <div class="REFBODY rb-3"> <p>The FTP client can be started and stopped dynamically in runtime by calling the <code>ftp</code> application API <code>ftp:open(Host, Options)</code> and <code>ftp:close(Client)</code>. </p> </div></section> <section class="innertube"><h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <div class="REFBODY rb-3" id="account"> <p>The following type definitions are used by more than one function in the FTP client API:</p> <p><code>pid()</code> = identifier of an FTP connection</p> <p><code>string()</code> = list of ASCII characters</p>  </div></section> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="account-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>account(Pid :: <code>pid()</code>, Acc :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="append3"> <p>Sets the account for an operation, if needed.</p>    </div></div></article><article class="func"><h3 id="append-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>append(Pid :: <code>pid()</code>, LocalFileName :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <h3 id="append-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>append(Pid :: <code>pid()</code>,
 LocalFileName :: <code>string()</code>,
 RemoteFileName :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="append_bin"> <p>Transfers the file <code>LocalFile</code> to the remote server. If <code>RemoteFile</code> is specified, the name of the remote file that the file is appended to is set to <code>RemoteFile</code>, otherwise to <code>LocalFile</code>. If the file does not exists, it is created.</p>  </div></div></article><article class="func"><h3 id="append_bin-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>append_bin(Pid :: <code>pid()</code>, Bin :: <code>binary()</code>, RemoteFile :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="append_chunk"> <p>Transfers the binary <code>Bin</code> to the remote server and appends it to the file <code>RemoteFile</code>. If the file does not exist, it is created.</p>  </div></div></article><article class="func"><h3 id="append_chunk-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>append_chunk(Pid :: <code>pid()</code>, Bin :: <code>binary()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="append_chunk_start"> <p>Transfers the chunk <code>Bin</code> to the remote server, which appends it to the file specified in the call to <code>append_chunk_start/2</code>.</p> <p>For some errors, for example, file system full, it is necessary to call <code>append_chunk_end</code> to get the proper reason.</p>  </div></div></article><article class="func"><h3 id="append_chunk_start-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>append_chunk_start(Pid :: <code>pid()</code>, RemoteFile :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="append_chunk_end"> <p>Starts the transfer of chunks for appending to the file <code>RemoteFile</code> at the remote server. If the file does not exist, it is created.</p>  </div></div></article><article class="func"><h3 id="append_chunk_end-1" class="bold_code title-link func-head">  <code>append_chunk_end(Pid :: <code>pid()</code>) -&gt; ok | {error, Reason :: <code>term()</code>}</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="cd"> <p>Stops transfer of chunks for appending to the remote server. The file at the remote server, specified in the call to <code>append_chunk_start/2</code>, is closed by the server.</p>  </div></div></article><article class="func"><h3 id="cd-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>cd(Pid :: <code>pid()</code>, Dir :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="close"> <p>Changes the working directory at the remote server to <code>Dir</code>.</p>  </div></div></article><article class="func"><h3 id="close-1" class="bold_code title-link func-head">  <code>close(Pid :: <code>pid()</code>) -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="delete"> <p>Ends an FTP session, created using function <code><a href="#open">open</a></code>.</p>  </div></div></article><article class="func"><h3 id="delete-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>delete(Pid :: <code>pid()</code>, File :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="append"> <p>Deletes the file <code>File</code> at the remote server.</p>  </div></div></article><article class="func"><h3 id="formaterror-1" class="bold_code title-link func-head">  <code>formaterror(Tag :: <code>atom()</code> | {error, <code>atom()</code>}) -&gt; <code>string()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="lcd"> <p>Given an error return value <code>{error, AtomReason}</code>, this function returns a readable string describing the error.</p>  </div></div></article><article class="func"><h3 id="lcd-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>lcd(Pid :: <code>pid()</code>, Dir :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="lpwd"> <p>Changes the working directory to <code>Dir</code> for the local client.</p>  </div></div></article><article class="func"><h3 id="lpwd-1" class="bold_code title-link func-head">  <code>lpwd(Pid :: <code>pid()</code>) -&gt; {ok, Dir :: <code>string()</code>}</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="ls2"> <p>Returns the current working directory at the local client.</p>    </div></div></article><article class="func"><h3 id="ls-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>ls(Pid :: <code>pid()</code>) -&gt;
 {ok, Listing :: <code>string()</code>} | {error, Reason :: <code>term()</code>}</code></pre> </h3> <h3 id="ls-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>ls(Pid :: <code>pid()</code>, Dir :: <code>string()</code>) -&gt;
 {ok, Listing :: <code>string()</code>} | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="mkdir"> <p>Returns a list of files in long format.</p> <p><code>Dir</code> can be a directory or a file. The <code>Dir</code> string can contain wildcards.</p> <p><code>ls/1</code> implies the current remote directory of the user.</p> <p>The format of <code>Listing</code> depends on the operating system. On UNIX, it is typically produced from the output of the <code>ls -l</code> shell command.</p>  </div></div></article><article class="func"><h3 id="mkdir-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>mkdir(Pid :: <code>pid()</code>, Dir :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="nlist2"> <p>Creates the directory <code>Dir</code> at the remote server.</p>    </div></div></article><article class="func"><h3 id="nlist-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>nlist(Pid :: <code>pid()</code>) -&gt;
 {ok, Listing :: <code>string()</code>} | {error, Reason :: <code>term()</code>}</code></pre> </h3> <h3 id="nlist-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>nlist(Pid :: <code>pid()</code>, Pathname :: <code>string()</code>) -&gt;
 {ok, Listing :: <code>string()</code>} | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="open"> <p>Returns a list of files in short format.</p> <p><code>Pathname</code> can be a directory or a file. The <code>Pathname</code> string can contain wildcards.</p> <p><code>nlist/1</code> implies the current remote directory of the user.</p> <p>The format of <code>Listing</code> is a stream of filenames where each filename is separated by &lt;CRLF&gt; or &lt;NL&gt;. Contrary to function <code>ls</code>, the purpose of <code>nlist</code> is to enable a program to process filename information automatically.</p>  </div></div></article><article class="func"><h3 id="open-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>open(Host :: <code>string()</code> | <code>inet:ip_address()</code>) -&gt;
 {ok, Pid :: <code>pid()</code>} | {error, Reason :: <code>term()</code>}</code></pre> </h3> <h3 id="open-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>open(Host :: <code>string()</code> | <code>inet:ip_address()</code>, Opts) -&gt;
 {ok, Pid :: <code>pid()</code>} | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Opts = [Opt]</code></div> <div class="REFTYPES rt-1"><code>Opt = StartOption | OpenOption</code></div> <div class="REFTYPES rt-1"><code>StartOption = {verbose, Verbose} | {debug, Debug}</code></div> <div class="REFTYPES rt-1"><code>Verbose = boolean()</code></div> <div class="REFTYPES rt-1"><code>Debug = disable | debug | trace</code></div> <div class="REFTYPES rt-1"><pre><code>OpenOption = 
 {ipfamily, IpFamily} |
 {port, Port :: port()} |
 {mode, Mode} |
 {tls, TLSOptions :: [ssl:tls_option()]} |
 {tls_sec_method, TLSSecMethod :: ftps | ftpes} |
 {tls_ctrl_session_reuse, TLSSessionReuse :: boolean()} |
 {timeout, Timeout :: timeout()} |
 {dtimeout, DTimeout :: timeout()} |
 {progress, Progress} |
 {sock_ctrl, SocketCtrls} |
 {sock_data_act, [SocketControl]} |
 {sock_data_pass, [SocketControl]}</code></pre></div> <div class="REFTYPES rt-1"><code>SocketCtrls = [SocketControl]</code></div> <div class="REFTYPES rt-1"><code>IpFamily = inet | inet6 | inet6fb4</code></div> <div class="REFTYPES rt-1"><code>Mode = active | passive</code></div> <div class="REFTYPES rt-1"><code>Module = Function = atom()</code></div>  <div class="REFTYPES rt-1"><code>InitialData = term()</code></div> <div class="REFTYPES rt-1"><code>Progress = ignore | {Module, Function, InitialData}</code></div> <div class="REFTYPES rt-1"><code>SocketControl = gen_tcp:option()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7" id="pwd"> <p>Starts a FTP client process and opens a session with the FTP server at <code>Host</code>. </p> <p>A session opened in this way is closed using function <code><a href="#close">close</a></code>.</p> <p>The available configuration options are as follows:</p> <dl> <dt class="title-link"><strong>{host, Host}</strong></dt> <dd>  <p id="host">Host = <code>string() | ip_address()</code></p> </dd> <dt class="title-link"><strong>{port, Port}</strong></dt> <dd>  <p id="port">Default is <code>0</code> which aliases to <code>21</code> or <code>990</code> when used with <code><a href="#open">{tls_sec_method,ftps}</a></code>).</p> </dd> <dt class="title-link"><strong>{mode, Mode}</strong></dt> <dd>  <p id="mode">Default is <code>passive</code>.</p> </dd> <dt class="title-link"><strong>{verbose, Verbose}</strong></dt> <dd>  <p id="verbose">Determines if the FTP communication is to be verbose or not.</p> <p>Default is <code>false</code>.</p> </dd> <dt class="title-link"><strong>{debug, Debug}</strong></dt> <dd>  <p id="debug">Debugging using the dbg toolkit. </p> <p>Default is <code>disable</code>.</p> </dd> <dt class="title-link"><strong>{ipfamily, IpFamily}</strong></dt> <dd>  <p id="ipfamily">With <code>inet6fb4</code> the client behaves as before, that is, tries to use IPv6, and only if that does not work it uses IPv4).</p> <p>Default is <code>inet</code> (IPv4).</p> </dd> <dt class="title-link"><strong>{timeout, Timeout}</strong></dt> <dd>  <p id="timeout">Connection time-out.</p> <p>Default is <code>60000</code> (milliseconds).</p> </dd> <dt class="title-link"><strong>{dtimeout, DTimeout}</strong></dt> <dd>  <p id="dtimeout">Data connect time-out. The time the client waits for the server to connect to the data socket.</p> <p>Default is <code>infinity</code>. </p> </dd> <dt class="title-link"><strong>{tls, TLSOptions}</strong></dt> <dd>  <p id="tls_options">The FTP session is transported over <code>tls</code> (<code>ftps</code>, see <code><a href="http://www.ietf.org/rfc/rfc4217.txt">RFC 4217</a></code>). The list <code>TLSOptions</code> can be empty. The function <code>ssl:connect/3</code> is used for securing both the control connection and the data sessions. </p> </dd> <dt class="title-link"><strong>{tls_sec_method, TLSSecMethod}</strong></dt> <dd>  <p id="tls_sec_method">When set to <code>ftps</code> will connect immediately with SSL instead of upgrading with STARTTLS. This suboption is ignored unless the suboption <code>tls</code> is also set.</p> <p>Default is <code>ftpes</code></p> </dd> <dt class="title-link"><strong>{tls_ctrl_session_reuse, boolean()}</strong></dt> <dd>  <p id="tls_ctrl_session_reuse">When set to <code>true</code> the client will re-use the TLS session from the control channel on the data channel as enforced by many FTP servers as (<code><a href="https://scarybeastsecurity.blogspot.com/2009/02/vsftpd-210-released.html">proposed and implemented first by vsftpd</a></code>). </p> <p>Default is <code>false</code>.</p> </dd> <dt class="title-link"><strong>{sock_ctrl, SocketCtrls :: [SocketControl :: gen_tcp:option()]}</strong></dt> <dd> <p>Passes options from <code>SocketCtrls</code> down to the underlying transport layer (tcp).</p> <p><code>gen_tcp:option()</code> except for <code>ipv6_v6only</code>, <code>active</code>, <code>packet</code>, <code>mode</code>, <code>packet_size</code> and <code>header</code>.</p> <p>Default value is <code>SocketCtrls = []</code>.</p> </dd> <dt class="title-link"><strong>{sock_data_act, [SocketControl]}</strong></dt> <dd> <p>Passes options from <code>[SocketControl]</code> down to the underlying transport layer (tcp).</p> <p><code>sock_data_act</code> uses the value of <code>sock_ctrl</code> as default value.</p> </dd> <dt class="title-link"><strong>{sock_data_pass, [SocketControl]}</strong></dt> <dd> <p>Passes options from <code>[SocketControl]</code> down to the underlying transport layer (tcp). </p> <p><code>sock_data_pass</code> uses the value of <code>sock_ctrl</code> as default value.</p> </dd> <dt class="title-link"><strong>{progress, Progress}</strong></dt> <dd>  <p id="progress">Progress = <code>ignore | {Module, Function, InitialData}</code></p> <p><code>Module = atom()</code>, <code>Function = atom()</code></p> <p><code>InitialData = term()</code></p> <p>Default is <code>ignore</code>.</p> <p>Option <code>progress</code> is intended to be used by applications that want to create some type of progress report, such as a progress bar in a GUI. Default for the progress option is <code>ignore</code>, that is, the option is not used. When the progress option is specified, the following happens when <code>ftp:send/[3,4]</code> or <code>ftp:recv/[3,4]</code> are called:</p> <ul> <li> <p>Before a file is transferred, the following call is made to indicate the start of the file transfer and how large the file is. The return value of the callback function is to be a new value for the <code>UserProgressTerm</code> that will be used as input the next time the callback function is called.</p> <p><code>Module:Function(InitialData, File, {file_size, FileSize})</code></p> </li> <li> <p>Every time a chunk of bytes is transferred the following call is made:</p> <p><code>Module:Function(UserProgressTerm, File, {transfer_size, TransferSize})</code></p> </li> <li> <p>At the end of the file the following call is made to indicate the end of the transfer:</p> <p><code>Module:Function(UserProgressTerm, File, {transfer_size, 0})</code></p> </li> </ul> <p>The callback function is to be defined as follows:</p> <p><code>Module:Function(UserProgressTerm, File, Size) -&gt; UserProgressTerm</code></p> <p><code>UserProgressTerm = term()</code></p> <p><code>File = string()</code></p> <p><code>Size = {transfer_size, integer()} | {file_size, integer()} | {file_size, unknown}</code></p> <p>For remote files, <code>ftp</code> cannot determine the file size in a platform independent way. In this case the size becomes <code>unknown</code> and it is left to the application to determine the size.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The callback is made by a middleman process, hence the file transfer is not affected by the code in the progress callback function. If the callback crashes, this is detected by the FTP connection process, which then prints an info-report and goes on as if the progress option was set to <code>ignore</code>.</p> </div> </div> <p>The file transfer type is set to the default of the FTP server when the session is opened. This is usually ASCII mode. </p> <p>The current local working directory (compare <code>lpwd/1</code>) is set to the value reported by <code>file:get_cwd/1</code>, the wanted local directory. </p> <p>The return value <code>Pid</code> is used as a reference to the newly created FTP client in all other functions, and they are to be called by the process that created the connection. The FTP client process monitors the process that created it and terminates if that process terminates.</p> </dd> </dl>  </div></div></article><article class="func"><h3 id="pwd-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>pwd(Pid :: <code>pid()</code>) -&gt;
 {ok, Dir :: <code>string()</code>} | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="recv3"> <p>Returns the current working directory at the remote server.</p>    </div></div></article><article class="func"><h3 id="recv-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Pid :: <code>pid()</code>, RemoteFileName :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <h3 id="recv-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv(Pid :: <code>pid()</code>,
 RemoteFileName :: <code>string()</code>,
 LocalFileName :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="recv_bin"> <p>Transfers the file <code>RemoteFileName</code> from the remote server to the file system of the local client. If <code>LocalFileName</code> is specified, the local file will be <code>LocalFileName</code>, otherwise <code>RemoteFileName</code>.</p> <p>If the file write fails, the command is aborted and <code>{error, term()}</code> is returned. However, the file is <strong>not</strong> removed.</p>  </div></div></article><article class="func"><h3 id="recv_bin-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv_bin(Pid :: <code>pid()</code>, RemoteFile :: <code>string()</code>) -&gt;
 {ok, Bin :: <code>binary()</code>} | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="recv_chunk_start"> <p>Transfers the file <code>RemoteFile</code> from the remote server and receives it as a binary.</p>  </div></div></article><article class="func"><h3 id="recv_chunk_start-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv_chunk_start(Pid :: <code>pid()</code>, RemoteFile :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="recv_chunk"> <p>Starts transfer of the file <code>RemoteFile</code> from the remote server.</p>  </div></div></article><article class="func"><h3 id="recv_chunk-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>recv_chunk(Pid :: <code>pid()</code>) -&gt;
 ok |
 {ok, Bin :: <code>binary()</code>} |
 {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="rename"> <p>Receives a chunk of the remote file (<code>RemoteFile</code> of <code>recv_chunk_start</code>). The return values have the following meaning:</p> <ul> <li> <code>ok</code> = the transfer is complete.</li> <li> <code>{ok, Bin}</code> = just another chunk of the file.</li> <li> <code>{error, Reason}</code> = transfer failed.</li> </ul>  </div></div></article><article class="func"><h3 id="rename-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>rename(Pid :: <code>pid()</code>, Old :: <code>string()</code>, New :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="rmdir"> <p>Renames <code>Old</code> to <code>New</code> at the remote server.</p>  </div></div></article><article class="func"><h3 id="rmdir-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>rmdir(Pid :: <code>pid()</code>, Dir :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="send3"> <p>Removes directory <code>Dir</code> at the remote server.</p>    </div></div></article><article class="func"><h3 id="send-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Pid :: <code>pid()</code>, LocalFileName :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <h3 id="send-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send(Pid :: <code>pid()</code>,
 LocalFileName :: <code>string()</code>,
 RemoteFileName :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="send_bin"> <p>Transfers the file <code>LocalFileName</code> to the remote server. If <code>RemoteFileName</code> is specified, the name of the remote file is set to <code>RemoteFileName</code>, otherwise to <code>LocalFileName</code>.</p>  </div></div></article><article class="func"><h3 id="send_bin-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send_bin(Pid :: <code>pid()</code>, Bin :: <code>binary()</code>, RemoteFile :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="send_chunk"> <p>Transfers the binary <code>Bin</code> into the file <code>RemoteFile</code> at the remote server.</p>  </div></div></article><article class="func"><h3 id="send_chunk-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send_chunk(Pid :: <code>pid()</code>, Bin :: <code>binary()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="send_chunk_start"> <p>Transfers the chunk <code>Bin</code> to the remote server, which writes it into the file specified in the call to <code>send_chunk_start/2</code>.</p> <p>For some errors, for example, file system full, it is necessary to to call <code>send_chunk_end</code> to get the proper reason.</p>  </div></div></article><article class="func"><h3 id="send_chunk_start-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send_chunk_start(Pid :: <code>pid()</code>, RemoteFile :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="send_chunk_end"> <p>Starts transfer of chunks into the file <code>RemoteFile</code> at the remote server.</p>  </div></div></article><article class="func"><h3 id="send_chunk_end-1" class="bold_code title-link func-head">  <code>send_chunk_end(Pid :: <code>pid()</code>) -&gt; ok | {error, Reason :: <code>term()</code>}</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="type"> <p>Stops transfer of chunks to the remote server. The file at the remote server, specified in the call to <code>send_chunk_start/2</code> is closed by the server.</p>  </div></div></article><article class="func"><h3 id="type-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>type(Pid :: <code>pid()</code>, Type :: ascii | binary) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="user3"> <p>Sets the file transfer type to <code>ascii</code> or <code>binary</code>. When an FTP session is opened, the default transfer type of the server is used, most often <code>ascii</code>, which is default according to <code><a href="http://www.ietf.org/rfc/rfc959.txt">RFC 959</a></code>.</p>  </div></div></article><article class="func"><h3 id="user-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>user(Pid :: <code>pid()</code>, User :: <code>string()</code>, Pass :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="user4"> <p>Performs login of <code>User</code> with <code>Pass</code>.</p>  </div></div></article><article class="func"><h3 id="user-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>user(Pid :: <code>pid()</code>,
 User :: <code>string()</code>,
 Pass :: <code>string()</code>,
 Account :: <code>string()</code>) -&gt;
 ok | {error, Reason :: <code>term()</code>}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7" id="quote"> <p>Performs login of <code>User</code> with <code>Pass</code> to the account specified by <code>Account</code>.</p>  </div></div></article><article class="func"><h3 id="quote-2" class="bold_code title-link func-head">  <code>quote(Pid :: <code>pid()</code>, Cmd :: <code>string()</code>) -&gt; [FTPLine :: <code>string()</code>]</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The telnet end of line characters, from the FTP protocol definition, CRLF, for example, "\\r\\n" has been removed.</p>
</div> </div> <p>Sends an arbitrary FTP command and returns verbatim a list of the lines sent back by the FTP server. This function is intended to give application accesses to FTP commands that are server-specific or that cannot be provided by this FTP client.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>FTP commands requiring a data connection cannot be successfully issued with this function.</p> </div> </div> </div></div></article> </div> <section class="innertube"><h2 id="errors" class="title-link"> errors  </h2> <div class="REFBODY rb-3"> <p>The possible error reasons and the corresponding diagnostic strings returned by <code>formaterror/1</code> are as follows: </p> <dl> <dt class="title-link"><strong><code>echunk</code></strong></dt> <dd> <p>Synchronization error during chunk sending according to one of the following: </p> <ul> <li>A call is made to <code>send_chunk/2</code> or <code>send_chunk_end/1</code> before a call to <code>send_chunk_start/2</code>.</li> <li>A call has been made to another transfer function during chunk sending, that is, before a call to <code>send_chunk_end/1</code>.</li> </ul> </dd> <dt class="title-link"><strong><code>eclosed</code></strong></dt> <dd> <p>The session is closed.</p> </dd> <dt class="title-link"><strong><code>econn</code></strong></dt> <dd> <p>Connection to the remote server is prematurely closed.</p> </dd> <dt class="title-link"><strong><code>ehost</code></strong></dt> <dd> <p>Host is not found, FTP server is not found, or connection is rejected by FTP server.</p> </dd> <dt class="title-link"><strong><code>elogin</code></strong></dt> <dd> <p>User is not logged in.</p> </dd> <dt class="title-link"><strong><code>enotbinary</code></strong></dt> <dd> <p>Term is not a binary.</p> </dd> <dt class="title-link"><strong><code>epath</code></strong></dt> <dd> <p>No such file or directory, or directory already exists, or permission denied.</p> </dd> <dt class="title-link"><strong><code>etype</code></strong></dt> <dd> <p>No such type.</p> </dd> <dt class="title-link"><strong><code>euser</code></strong></dt> <dd> <p>Invalid username or password.</p> </dd> <dt class="title-link"><strong><code>etnospc</code></strong></dt> <dd> <p>Insufficient storage space in system [452].</p> </dd> <dt class="title-link"><strong><code>epnospc</code></strong></dt> <dd> <p>Exceeded storage allocation (for current directory or dataset) [552].</p> </dd> <dt class="title-link"><strong><code>efnamena</code></strong></dt> <dd> <p>Filename not allowed [553].</p> </dd> </dl> </div></section> <section class="innertube"><h2 id="see-also" class="title-link"> see also  </h2> <div class="REFBODY rb-3"> <p><code>file(3)</code> <code>filename(3)</code> and J. Postel and J. Reynolds: File Transfer Protocol (<code><a href="http://www.ietf.org/rfc/rfc959.txt">RFC 959</a></code>). </p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
