  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">erl_pp</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">The Erlang pretty printer.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>The functions in this module are used to generate aesthetically attractive representations of abstract forms, which are suitable for printing. All functions return (possibly deep) lists of characters and generate an error if the form is wrong.</p> <p>All functions can have an optional argument, which specifies a hook that is called if an attempt is made to print an unknown form.</p> <p>Note that if the functions in this module are used to convert abstract code back to Erlang source code, the enclosing function should first be processed by <code><a href="#legalize_vars-1">legalize_vars/1</a></code> in order to ensure that the output is semantically equivalent to the abstract code.</p> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-hook_function" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-hook_function">hook_function()</a> = 
 none |
 fun((Expr :: <a href="erl_parse.html#type-abstract_expr">erl_parse:abstract_expr()</a>,
 CurrentIndentation :: integer(),
 CurrentPrecedence :: integer() &gt;= 0,
 Options :: <a href="#type-options">options()</a>) -&gt;
 <a href="io_lib.html#type-chars">io_lib:chars()</a>)</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <h3 id="hook_function">Optional argument <code id="hook_function">HookFunction</code>, shown in the functions described in this module, defines a function that is called when an unknown form occurs where there is to be a valid expression. If <code>HookFunction</code> is equal to <code>none</code>, there is no hook function.</h3> <p>The called hook function is to return a (possibly deep) list of characters. Function <code><a href="#expr-4">expr/4</a></code> is useful in a hook.</p> <p>If <code>CurrentIndentation</code> is negative, there are no line breaks and only a space is used as a separator.</p> </div></div></article> <article class="data-types-body"><h3 id="type-option" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-option">option()</a> = 
 {hook, <a href="#type-hook_function">hook_function()</a>} |
 {encoding, latin1 | unicode | utf8} |
 {quote_singleton_atom_types, boolean()} |
 {linewidth, integer() &gt;= 1} |
 {indent, integer() &gt;= 1}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>The option <code>quote_singleton_atom_types</code> is used to add quotes to all singleton atom types.</p> <p>The option <code>linewidth</code> controls the maximum line width for formatted lines (defaults to 72 characters).</p> <p>The option <code>indent</code> controls the indention for formatted lines (defaults to 4 spaces).</p> </div></div></article> <article class="data-types-body"><h3 id="type-options" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-options">options()</a> = <a href="#type-hook_function">hook_function()</a> | [<a href="#type-option">option()</a>]</code><br> </div> </h3> </article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="attribute-1" class="bold_code title-link func-head">  <code>attribute(Attribute) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <h3 id="attribute-2" class="bold_code title-link func-head">  <code>attribute(Attribute, Options) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Attribute = <a href="erl_parse.html#type-abstract_form">erl_parse:abstract_form()</a></code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-options">options()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Same as <code><a href="#form-1">form/1,2</a></code>, but only for attribute <code>Attribute</code>.</p> </div></div></article><article class="func"><h3 id="expr-1" class="bold_code title-link func-head">  <code>expr(Expression) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <h3 id="expr-2" class="bold_code title-link func-head">  <code>expr(Expression, Options) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <h3 id="expr-3" class="bold_code title-link func-head">  <code>expr(Expression, Indent, Options) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <h3 id="expr-4" class="bold_code title-link func-head">  <code>expr(Expression, Indent, Precedence, Options) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Expression = <a href="erl_parse.html#type-abstract_expr">erl_parse:abstract_expr()</a></code></div> <div class="REFTYPES rt-1"><code>Indent = integer()</code></div> <div class="REFTYPES rt-1"><code>Precedence = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-options">options()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Prints one expression. It is useful for implementing hooks (see section <code><a href="#knownlimitations">Known Limitations</a></code>).</p> </div></div></article><article class="func"><h3 id="exprs-1" class="bold_code title-link func-head">  <code>exprs(Expressions) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <h3 id="exprs-2" class="bold_code title-link func-head">  <code>exprs(Expressions, Options) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <h3 id="exprs-3" class="bold_code title-link func-head">  <code>exprs(Expressions, Indent, Options) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Expressions = [<a href="erl_parse.html#type-abstract_expr">erl_parse:abstract_expr()</a>]</code></div> <div class="REFTYPES rt-1"><code>Indent = integer()</code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-options">options()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Same as <code><a href="#form-1">form/1,2</a></code>, but only for the sequence of expressions in <code>Expressions</code>.</p> </div></div></article><article class="func"><h3 id="form-1" class="bold_code title-link func-head">  <code>form(Form) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <h3 id="form-2" class="bold_code title-link func-head">  <code>form(Form, Options) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Form = <a href="erl_parse.html#type-abstract_form">erl_parse:abstract_form()</a> | <a href="erl_parse.html#type-form_info">erl_parse:form_info()</a></code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-options">options()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Pretty prints a <code>Form</code>, which is an abstract form of a type that is returned by <code><a href="erl_parse.html#parse_form-1"> erl_parse:parse_form/1</a></code>.</p> </div></div></article><article class="func"><h3 id="function-1" class="bold_code title-link func-head">  <code>function(Function) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <h3 id="function-2" class="bold_code title-link func-head">  <code>function(Function, Options) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Function = <a href="erl_parse.html#type-abstract_form">erl_parse:abstract_form()</a></code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-options">options()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Same as <code><a href="#form-1">form/1,2</a></code>, but only for function <code>Function</code>.</p> </div></div></article><article class="func"><h3 id="guard-1" class="bold_code title-link func-head">  <code>guard(Guard) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <h3 id="guard-2" class="bold_code title-link func-head">  <code>guard(Guard, Options) -&gt; <code><a href="io_lib.html#type-chars">io_lib:chars()</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Guard = [<a href="erl_parse.html#type-abstract_expr">erl_parse:abstract_expr()</a>]</code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-options">options()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Same as <code><a href="#form-1">form/1,2</a></code>, but only for the guard test <code>Guard</code>.</p> </div></div></article><article class="func"><h3 id="legalize_vars-1" class="bold_code title-link func-head">  <code>legalize_vars(Function) -&gt; <code><a href="erl_parse.html#type-abstract_form">erl_parse:abstract_form()</a></code></code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Function = <a href="erl_parse.html#type-abstract_form">erl_parse:abstract_form()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>The Erlang compiler will, when expanding records to tuples, introduce new variables in the abstract representation. As the expansion is done on the abstract representation, the compiler can safely name the new variables with names that are not syntactically valid in Erlang source code (the name starts with a lowercase letter), thus ensuring the uniqueness of the new names.</p> <p>The above strategy leads to problems if a user wants to convert the abstract representation, using the functions of this module back to Erlang source code. Typically, pattern variables are output as atoms thus changing the sematics of the program. To solve this problem <code>legalize_vars/1</code>, when run on the abstract representation of a function, will return an equivalent function where all variables will have syntactically valid names.</p> </div></div></article> </div> <section class="innertube"><h2 id="known-limitations" class="title-link"> <div class="title-name">Known Limitations</div>  </h2> <div class="REFBODY rb-3"> <p>It is not possible to have hook functions for unknown forms at other places than expressions.</p> </div></section> <section class="innertube"><h2 id="see-also" class="title-link"> <div class="title-name">See Also</div>  </h2> <div class="REFBODY rb-3"> <p><code><a href="erl_eval.html">erl_eval(3)</a></code>, <code><a href="erl_parse.html">erl_parse(3)</a></code>, <code><a href="io.html">io(3)</a></code></p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
