  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">gen_statem</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Generic state machine behavior.</div> <h2 id="since" class="title-link"> <div class="title-name">Since</div>  </h2> <div class="REFBODY module-since"> Module gen_statem was introduced in OTP 19.0. </div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p> <code>gen_statem</code> provides a generic state machine behaviour that for new code replaces its predecessor <code><a href="gen_fsm.html">gen_fsm</a></code> since Erlang/OTP 20.0. The <code>gen_fsm</code> behaviour remains in OTP "as is". </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> If you are new to <code>gen_statem</code> and want an overview of concepts and operation the section <code> gen_statem Behaviour </code> located in the User's Guide <code> OTP Design Principles </code> is recommended to read before this reference manual, possibly after the Description section you are reading here. </p> </div> </div> <p> This reference manual contains type descriptions generated from types in the <code>gen_statem</code> source code, so they are correct. However, the generated descriptions also reflect the type hierarchy, which sometimes makes it hard to get a good overview. If so, see the section <code> gen_statem Behaviour </code> in the <code> OTP Design Principles </code> User's Guide. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<ul> <li>This behavior appeared in Erlang/OTP 19.0.</li> <li> In OTP 19.1 a backwards incompatible change of the return tuple from <code><a href="#Module:init-1">Module:init/1</a></code> was made and the mandatory callback function <code><a href="#Module:callback_mode-0"> Module:callback_mode/0 </a></code> was introduced. </li> <li> In OTP 20.0 <code><a href="#type-generic_timeout"> generic time-outs </a></code> were added. </li> <li> In OTP 22.1 time-out content <code><a href="#type-timeout_update_action"> update </a></code> and explicit time-out <code><a href="#type-timeout_cancel_action"> cancel </a></code> were added. </li> <li> In OTP 22.3 the possibility to change the callback module with actions <code><a href="#type-action">change_callback_module</a></code>, <code><a href="#type-action">push_callback_module</a></code> and <code><a href="#type-action">pop_callback_module</a></code>, was added. </li> </ul> </div> </div> <p> <code>gen_statem</code> has got the same features that <code><a href="gen_fsm.html">gen_fsm</a></code> had and adds some really useful: </p> <ul> <li>Co-located state code</li> <li>Arbitrary term state</li> <li>Event postponing</li> <li>Self-generated events</li> <li>State time-out</li> <li>Multiple generic named time-outs</li> <li>Absolute time-out time</li> <li>Automatic state enter calls</li> <li> Reply from other state than the request, <code>sys</code> traceable </li> <li>Multiple <code>sys</code> traceable replies</li> <li>Changing the callback module</li> </ul> <p> Two <code><a href="#type-callback_mode"><strong>callback modes</strong></a></code> are supported: </p> <ul> <li> <p> One for finite-state machines (<code><a href="gen_fsm.html">gen_fsm</a></code> like), which requires the state to be an atom and uses that state as the name of the current callback function. </p> </li> <li> <p> One that allows the state to be any term and that uses one callback function for all states. </p> </li> </ul> <p> The callback model(s) for <code>gen_statem</code> differs from the one for <code><a href="gen_fsm.html">gen_fsm</a></code>, but it is still fairly easy to <code><a href="gen_fsm.html#Migration%20to%20gen_statem"> rewrite from </a></code> <code>gen_fsm</code> to <code>gen_statem</code>. </p> <p> A generic state machine server process (<code>gen_statem</code>) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see <code>OTP Design Principles</code>. </p> <p> A <code>gen_statem</code> assumes all specific parts to be located in a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows:</p> <pre data-language="erlang">
gen_statem module            Callback module
-----------------            ---------------
gen_statem:start
gen_statem:start_monitor
gen_statem:start_link -----&gt; Module:init/1

Server start or code change
                      -----&gt; Module:callback_mode/0

gen_statem:stop       -----&gt; Module:terminate/3

gen_statem:call
gen_statem:cast
gen_statem:send_request
erlang:send
erlang:'!'            -----&gt; Module:StateName/3
                             Module:handle_event/4

-                     -----&gt; Module:terminate/3

-                     -----&gt; Module:code_change/4</pre> <p> Events are of different <code><a href="#type-event_type">types</a></code>, so the callback functions can know the origin of an event and how to respond. </p> <p> If a callback function fails or returns a bad value, the <code>gen_statem</code> terminates, unless otherwise stated. However, an exception of class <code>throw</code> is not regarded as an error but as a valid return from all callback functions. </p>  <p id="state%20callback"> The <strong>state callback</strong> for a specific <code><a href="#type-state">state</a></code> in a <code>gen_statem</code> is the callback function that is called for all events in this state. It is selected depending on which <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> that the callback module defines with the callback function <code><a href="#Module:callback_mode-0">Module:callback_mode/0</a></code>. </p> <p> When the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code>state_functions</code>, the state must be an atom and is used as the <strong>state callback</strong> name; see <code><a href="#Module:StateName-3">Module:StateName/3</a></code>. This co-locates all code for a specific state in one function as the <code>gen_statem</code> engine branches depending on state name. Note the fact that the callback function <code><a href="#Module:terminate-3">Module:terminate/3</a></code> makes the state name <code>terminate</code> unusable in this mode. </p> <p> When the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code>handle_event_function</code>, the state can be any term and the <strong>state callback</strong> name is <code><a href="#Module:handle_event-4">Module:handle_event/4</a></code>. This makes it easy to branch depending on state or event as you desire. Be careful about which events you handle in which states so that you do not accidentally postpone an event forever creating an infinite busy loop. </p> <p> When <code>gen_statem</code> receives a process message it is converted into an event and the <code><a href="#state%20callback"><strong>state callback</strong></a></code> is called with the event as two arguments: type and content. When the <code><a href="#state%20callback"><strong>state callback</strong></a></code> has processed the event it returns to <code>gen_statem</code> which does a <strong>state transition</strong>. If this <strong>state transition</strong> is to a different state, that is: <code>NextState =/= State</code>, it is a <strong>state change</strong>. </p> <p> The <code><a href="#state%20callback"><strong>state callback</strong></a></code> may return <code><a href="#type-action"><strong>transition actions</strong></a></code> for <code>gen_statem</code> to execute during the <strong>state transition</strong>, for example to reply to a <code><a href="#call-2">gen_statem:call/2,3</a></code>. </p> <p> One of the possible <strong>transition actions</strong> is to postpone the current event. Then it is not retried in the current state. The <code>gen_statem</code> engine keeps a queue of events divided into the postponed events and the events still to process. After a <strong>state change</strong> the queue restarts with the postponed events. </p> <p> The <code>gen_statem</code> event queue model is sufficient to emulate the normal process message queue with selective receive. Postponing an event corresponds to not matching it in a receive statement, and changing states corresponds to entering a new receive statement. </p> <p> The <code><a href="#state%20callback"><strong>state callback</strong></a></code> can insert events using the <code><a href="#type-action"><strong>transition actions</strong></a></code> <code>next_event</code> and such an event is inserted in the event queue as the next to call the <code><a href="#state%20callback"><strong>state callback</strong></a></code> with. That is, as if it is the oldest incoming event. A dedicated <code><a href="#type-event_type">event_type()</a></code> <code>internal</code> can be used for such events making them impossible to mistake for external events. </p> <p> Inserting an event replaces the trick of calling your own state handling functions that you often would have to resort to in, for example, <code><a href="gen_fsm.html">gen_fsm</a></code> to force processing an inserted event before others. </p> <p> The <code>gen_statem</code> engine can automatically make a specialized call to the <code><a href="#state%20callback"><strong>state callback</strong></a></code> whenever a new state is entered; see <code><a href="#type-state_enter">state_enter()</a></code>. This is for writing code common to all state entries. Another way to do it is to explicitly insert an event at the <strong>state transition</strong>, and/or to use a dedicated <strong>state transition</strong> function, but that is something you will have to remember at every <strong>state transition</strong> to the state(s) that need it. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If you in <code>gen_statem</code>, for example, postpone an event in one state and then call another <strong>state callback</strong> of yours, you have not done a <strong>state change</strong> and hence the postponed event is not retried, which is logical but can be confusing. </p> </div> </div> <p> For the details of a <strong>state transition</strong>, see type <code><a href="#type-transition_option">transition_option()</a></code>. </p> <p> A <code>gen_statem</code> handles system messages as described in <code><a href="sys.html">sys</a></code>. The <code>sys</code> module can be used for debugging a <code>gen_statem</code>. </p> <p> Notice that a <code>gen_statem</code> does not trap exit signals automatically, this must be explicitly initiated in the callback module (by calling <code>process_flag(trap_exit, true)</code>. </p> <p> Unless otherwise stated, all functions in this module fail if the specified <code>gen_statem</code> does not exist or if bad arguments are specified. </p> <p> The <code>gen_statem</code> process can go into hibernation; see <code><a href="proc_lib.html#hibernate-3">proc_lib:hibernate/3</a></code>. It is done when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> or <code><a href="#Module:init-1">Module:init/1</a></code> specifies <code>hibernate</code> in the returned <code><a href="#type-action">Actions</a></code> list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see <code>erlang:hibernate/3</code>. </p> <p> There is also a server start option <code><a href="#type-enter_loop_opt"> {hibernate_after, Timeout} </a></code> for <code><a href="#start-3">start/3,4</a></code>, <code><a href="#start_monitor-3">start_monitor/3,4</a></code>, <code><a href="#start_link-3">start_link/3,4</a></code> or <code><a href="#enter_loop-4">enter_loop/4,5,6</a></code>, that may be used to automatically hibernate the server. </p> <p> If the <code>gen_statem</code> process terminates, e.g. as a result of a function in the callback module returning <code>{stop,Reason}</code>, an exit signal with this <code>Reason</code> is sent to linked processes and ports. See <code> Processes</code> in the Reference Manual for details regarding error handling using exit signals. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> For some important information about distributed signals, see the <code> <i>Blocking Signaling Over Distribution</i></code> section in the <i>Processes</i> chapter of the <i>Erlang Reference Manual</i>. Blocking signaling can, for example, cause call timeouts in <code>gen_statem</code> to be significantly delayed. </p>
</div> </div> </div> </div></section> <section class="innertube"><h2 id="example" class="title-link"> <div class="title-name">Example</div>  </h2> <div class="REFBODY rb-3"> <p> The following example shows a simple pushbutton model for a toggling pushbutton implemented with <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> <code>state_functions</code>. You can push the button and it replies if it went on or off, and you can ask for a count of how many times it has been pushed to switch on. </p> <p>The following is the complete callback module file <code>pushbutton.erl</code>:</p> <pre data-language="erlang">-module(pushbutton).
-behaviour(gen_statem).

-export([start/0,push/0,get_count/0,stop/0]).
-export([terminate/3,code_change/4,init/1,callback_mode/0]).
-export([on/3,off/3]).

name() -&gt; pushbutton_statem. % The registered server name

%% API.  This example uses a registered name name()
%% and does not link to the caller.
start() -&gt;
    gen_statem:start({local,name()}, ?MODULE, [], []).
push() -&gt;
    gen_statem:call(name(), push).
get_count() -&gt;
    gen_statem:call(name(), get_count).
stop() -&gt;
    gen_statem:stop(name()).

%% Mandatory callback functions
terminate(_Reason, _State, _Data) -&gt;
    void.
code_change(_Vsn, State, Data, _Extra) -&gt;
    {ok,State,Data}.
init([]) -&gt;
    %% Set the initial state + data.  Data is used only as a counter.
    State = off, Data = 0,
    {ok,State,Data}.
callback_mode() -&gt; state_functions.

%%% state callback(s)

off({call,From}, push, Data) -&gt;
    %% Go to 'on', increment count and reply
    %% that the resulting status is 'on'
    {next_state,on,Data+1,[{reply,From,on}]};
off(EventType, EventContent, Data) -&gt;
    handle_event(EventType, EventContent, Data).

on({call,From}, push, Data) -&gt;
    %% Go to 'off' and reply that the resulting status is 'off'
    {next_state,off,Data,[{reply,From,off}]};
on(EventType, EventContent, Data) -&gt;
    handle_event(EventType, EventContent, Data).

%% Handle events common to all states
handle_event({call,From}, get_count, Data) -&gt;
    %% Reply with the current count
    {keep_state,Data,[{reply,From,Data}]};
handle_event(_, _, Data) -&gt;
    %% Ignore all other events
    {keep_state,Data}.</pre> <p>The following is a shell session when running it:</p> <pre data-language="erlang">
1&gt; pushbutton:start().
{ok,&lt;0.36.0&gt;}
2&gt; pushbutton:get_count().
0
3&gt; pushbutton:push().
on
4&gt; pushbutton:get_count().
1
5&gt; pushbutton:push().
off
6&gt; pushbutton:get_count().
1
7&gt; pushbutton:stop().
ok
8&gt; pushbutton:push().
** exception exit: {noproc,{gen_statem,call,[pushbutton_statem,push,infinity]}}
     in function  gen:do_for_proc/2 (gen.erl, line 261)
     in call from gen_statem:call/3 (gen_statem.erl, line 386)
    </pre> <p> To compare styles, here follows the same example using <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> <code>handle_event_function</code>, or rather the code to replace after function <code>init/1</code> of the <code>pushbutton.erl</code> example file above: </p> <pre data-language="erlang">callback_mode() -&gt; handle_event_function.

%%% state callback(s)

handle_event({call,From}, push, off, Data) -&gt;
    %% Go to 'on', increment count and reply
    %% that the resulting status is 'on'
    {next_state,on,Data+1,[{reply,From,on}]};
handle_event({call,From}, push, on, Data) -&gt;
    %% Go to 'off' and reply that the resulting status is 'off'
    {next_state,off,Data,[{reply,From,off}]};
%%
%% Event handling common to all states
handle_event({call,From}, get_count, State, Data) -&gt;
    %% Reply with the current count
    {next_state,State,Data,[{reply,From,Data}]};
handle_event(_, _, State, Data) -&gt;
    %% Ignore all other events
    {next_state,State,Data}.</pre> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-server_name" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-server_name">server_name()</a> = 
 {local, atom()} |
 {global, GlobalName :: term()} |
 {via, RegMod :: module(), Name :: term()}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Name specification to use when starting a <code>gen_statem</code> server. See <code><a href="#start_link-3">start_link/3</a></code> and <code><a href="#type-server_ref">server_ref()</a></code> below. </p> </div></div></article> <article class="data-types-body"><h3 id="type-server_ref" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-server_ref">server_ref()</a> = 
 pid() |
 (LocalName :: atom()) |
 {Name :: atom(), Node :: atom()} |
 {global, GlobalName :: term()} |
 {via, RegMod :: module(), ViaName :: term()}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Server specification to use when addressing a <code>gen_statem</code> server. See <code><a href="#call-2">call/2</a></code> and <code><a href="#type-server_name">server_name()</a></code> above. </p> <p>It can be:</p> <dl> <dt class="title-link"><strong><code>pid() | LocalName</code></strong></dt> <dd> <p> The <code>gen_statem</code> is locally registered. </p> </dd> <dt class="title-link"><strong><code>{Name,Node}</code></strong></dt> <dd> <p> The <code>gen_statem</code> is locally registered on another node. </p> </dd> <dt class="title-link"><strong><code>{global,GlobalName}</code></strong></dt> <dd> <p> The <code>gen_statem</code> is globally registered in <code>global</code>. </p> </dd> <dt class="title-link"><strong><code>{via,RegMod,ViaName}</code></strong></dt> <dd> <p> The <code>gen_statem</code> is registered in an alternative process registry. The registry callback module <code>RegMod</code> is to export functions <code>register_name/2</code>, <code>unregister_name/1</code>, <code>whereis_name/1</code>, and <code>send/2</code>, which are to behave like the corresponding functions in <code>global</code>. Thus, <code>{via,global,GlobalName}</code> is the same as <code>{global,GlobalName}</code>. </p> </dd> </dl> </div></div></article> <article class="data-types-body"><h3 id="type-start_opt" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-start_opt">start_opt()</a> = 
 {timeout, Time :: timeout()} |
 {spawn_opt, [<a href="proc_lib.html#type-spawn_option">proc_lib:spawn_option()</a>]} |
 <a href="#type-enter_loop_opt">enter_loop_opt()</a></code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Options that can be used when starting a <code>gen_statem</code> server through, for example, <code><a href="#start_link-3">start_link/3</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-start_ret" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-start_ret">start_ret()</a> = {ok, pid()} | ignore | {error, term()}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Return value from the <code>start()</code> and <code>start_link()</code> functions, for example, <code><a href="#start_link-3">start_link/3</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-start_mon_ret" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-start_mon_ret">start_mon_ret()</a> = 
 {ok, {pid(), reference()}} | ignore | {error, term()}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Return value from the <code><a href="#start_monitor-3">start_monitor()</a></code> functions. </p> </div></div></article> <article class="data-types-body"><h3 id="type-enter_loop_opt" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-enter_loop_opt">enter_loop_opt()</a> = 
 {hibernate_after, HibernateAfterTimeout :: timeout()} |
 {debug, Dbgs :: [<a href="sys.html#type-debug_option">sys:debug_option()</a>]}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Options that can be used when starting a <code>gen_statem</code> server through, <code><a href="#enter_loop-4">enter_loop/4-6</a></code>. </p> <dl> <dt class="title-link"><strong><code>hibernate_after</code></strong></dt> <dd> <p> <code>HibernateAfterTimeout</code> specifies that the <code>gen_statem</code> process awaits any message for <code>HibernateAfterTimeout</code> milliseconds and if no message is received, the process goes into hibernation automatically (by calling <code><a href="proc_lib.html#hibernate-3">proc_lib:hibernate/3</a></code>). </p> </dd> <dt class="title-link"><strong><code>debug</code></strong></dt> <dd> <p> For every entry in <code>Dbgs</code>, the corresponding function in <code><a href="sys.html">sys</a></code> is called. </p> </dd> </dl> </div></div></article> <article class="data-types-body"><h3 id="type-from" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-from">from()</a> = {To :: pid(), Tag :: <a href="#type-reply_tag">reply_tag()</a>}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Destination to use when replying through, for example, the <code><a href="#type-action">action()</a></code> <code>{reply,From,Reply}</code> to a process that has called the <code>gen_statem</code> server using <code><a href="#call-2">call/2</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-reply_tag" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-reply_tag">reply_tag()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> A handle that associates a reply to the corresponding request. </p> </div></div></article> <article class="data-types-body"><h3 id="type-state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-state">state()</a> = <a href="#type-state_name">state_name()</a> | term()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> If the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code>handle_event_function</code>, the state can be any term. After a <strong>state change</strong> (<code>NextState =/= State</code>), all postponed events are retried. </p> </div></div></article> <article class="data-types-body"><h3 id="type-state_name" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-state_name">state_name()</a> = atom()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> If the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code>state_functions</code>, the state must be an atom. After a <strong>state change</strong> (<code>NextState =/= State</code>), all postponed events are retried. Note that the state <code>terminate</code> is not possible to use since it would collide with the optional callback function <code><a href="#Module:terminate-3">Module:terminate/3</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-data" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-data">data()</a> = term()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> A term in which the state machine implementation is to store any server data it needs. The difference between this and the <code><a href="#type-state">state()</a></code> itself is that a change in this data does not cause postponed events to be retried. Hence, if a change in this data would change the set of events that are handled, then that data item is to be made a part of the state. </p> </div></div></article> <article class="data-types-body"><h3 id="type-event_type" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-event_type">event_type()</a> = 
 <a href="#type-external_event_type">external_event_type()</a> | <a href="#type-timeout_event_type">timeout_event_type()</a> | internal</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> There are 3 categories of events: <code><a href="#type-external_event_type">external</a></code>, <code><a href="#type-timeout_event_type">timeout</a></code>, and <code>internal</code>. </p> <p> <code>internal</code> events can only be generated by the state machine itself through the <strong>transition action</strong> <code><a href="#type-action">next_event</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-external_event_type" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-external_event_type">external_event_type()</a> = {call, From :: <a href="#type-from">from()</a>} | cast | info</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> External events are of 3 types: <code>{call,From}</code>, <code>cast</code>, or <code>info</code>. Type <code>call</code> originates from the API functions <code><a href="#call-2">call/2</a></code> and <code><a href="#send_request-2">send_request/2</a></code>. For calls, the event contains whom to reply to. Type <code>cast</code> originates from the API function <code><a href="#cast-2">cast/2</a></code>. Type <code>info</code> originates from regular process messages sent to the <code>gen_statem</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-timeout_event_type" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-timeout_event_type">timeout_event_type()</a> = 
 timeout | {timeout, Name :: term()} | state_timeout</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> There are 3 types of time-out events that the state machine can generate for itself with the corresponding <code><a href="#type-timeout_action">timeout_action()</a></code>s. </p> </div></div></article> <article class="data-types-body"><h3 id="type-event_content" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-event_content">event_content()</a> = term()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Any event's content can be any term. </p> <p> See <code><a href="#type-event_type">event_type</a></code> that describes the origins of the different event types, which is also where the event content comes from. </p> </div></div></article> <article class="data-types-body"><h3 id="type-callback_mode_result" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-callback_mode_result">callback_mode_result()</a> = 
 <a href="#type-callback_mode">callback_mode()</a> | [<a href="#type-callback_mode">callback_mode()</a> | <a href="#type-state_enter">state_enter()</a>]</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> This is the return type from <code><a href="#Module:callback_mode-0">Module:callback_mode/0</a></code> and selects <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> and whether to do <code><a href="#type-state_enter"><strong>state enter calls</strong></a></code>, or not. </p> </div></div></article> <article class="data-types-body"><h3 id="type-callback_mode" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-callback_mode">callback_mode()</a> = state_functions | handle_event_function</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> The <strong>callback mode</strong> is selected with the return value from <code><a href="#Module:callback_mode-0">Module:callback_mode/0</a></code>: </p> <dl> <dt class="title-link"><strong><code>state_functions</code></strong></dt> <dd> <p> The state must be of type <code><a href="#type-state_name">state_name()</a></code> and one callback function per state, that is, <code><a href="#Module:StateName-3">Module:StateName/3</a></code>, is used. </p> </dd> <dt class="title-link"><strong><code>handle_event_function</code></strong></dt> <dd> <p> The state can be any term and the callback function <code><a href="#Module:handle_event-4">Module:handle_event/4</a></code> is used for all states. </p> </dd> </dl> <p> The function <code><a href="#Module:callback_mode-0">Module:callback_mode/0</a></code> is called when starting the <code>gen_statem</code>, after code change and after changing the callback module with any of the actions <code><a href="#type-action">change_callback_module</a></code>, <code><a href="#type-action">push_callback_module</a></code> or <code><a href="#type-action">pop_callback_module</a></code>. The result is cached for subsequent calls to <code><a href="#state%20callback">state callbacks</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-state_enter" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-state_enter">state_enter()</a> = state_enter</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Whether the state machine should use <strong>state enter calls</strong> or not is selected when starting the <code>gen_statem</code> and after code change using the return value from <code><a href="#Module:callback_mode-0">Module:callback_mode/0</a></code>. </p> <p> If <code><a href="#Module:callback_mode-0">Module:callback_mode/0</a></code> returns a list containing <code>state_enter</code>, the <code>gen_statem</code> engine will, at every <strong>state change</strong>, call the <code><a href="#state%20callback">state callback</a></code> with arguments <code>(enter, OldState, Data)</code> or <code>(enter, OldState, State, Data)</code>, depending on the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code>. This may look like an event but is really a call performed after the previous <code><a href="#state%20callback"><strong>state callback</strong></a></code> returned and before any event is delivered to the new <code><a href="#state%20callback"><strong>state callback</strong></a></code>. See <code><a href="#Module:StateName-3">Module:StateName/3</a></code> and <code><a href="#Module:handle_event-4">Module:handle_event/4</a></code>. Such a call can be repeated by returning a <code><a href="#type-state_callback_result"> repeat_state </a></code> or <code><a href="#type-state_callback_result"> repeat_state_and_data </a></code> tuple from the <strong>state callback</strong>. </p> <p> If <code><a href="#Module:callback_mode-0">Module:callback_mode/0</a></code> does not return such a list, no <strong>state enter calls</strong> are done. </p> <p> If <code><a href="#Module:code_change-4">Module:code_change/4</a></code> should transform the state, it is regarded as a state rename and not a <strong>state change</strong>, which will not cause a <strong>state enter call</strong>. </p> <p> Note that a <strong>state enter call</strong> <strong>will</strong> be done right before entering the initial state even though this actually is not a <strong>state change</strong>. In this case <code>OldState =:= State</code>, which cannot happen for a subsequent state change, but will happen when repeating the <strong>state enter call</strong>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-transition_option" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-transition_option">transition_option()</a> = 
 <a href="#type-postpone">postpone()</a> |
 <a href="#type-hibernate">hibernate()</a> |
 <a href="#type-event_timeout">event_timeout()</a> |
 <a href="#type-generic_timeout">generic_timeout()</a> |
 <a href="#type-state_timeout">state_timeout()</a></code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Transition options can be set by <code><a href="#type-action">actions</a></code> and modify the <strong>state transition</strong>. The <strong>state transition</strong> takes place when the <code><a href="#state%20callback"><strong>state callback</strong></a></code> has processed an event and returns. Here are the sequence of steps for a <strong>state transition</strong>: </p> <ol> <li> <p> All returned <code><a href="#type-action">actions</a></code> are processed in order of appearance. In this step all replies generated by any <code><a href="#type-reply_action">reply_action()</a></code> are sent. Other actions set <code>transition_option()</code>s that come into play in subsequent steps. </p> </li> <li> <p> If <code><a href="#type-state_enter"> <strong>state enter calls</strong> </a></code> are used, and either it is the initial state or one of the callback results <code><a href="#type-state_callback_result"> repeat_state_and_data </a></code> or <code><a href="#type-state_callback_result"> repeat_state_and_data </a></code> is used the <code>gen_statem</code> engine calls the current state callback with arguments <code><a href="#type-state_enter">(enter, State, Data)</a></code> or <code><a href="#type-state_enter">(enter, State, State, Data)</a></code> (depending on <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code>) and when it returns starts again from the top of this sequence. </p> <p> If <code><a href="#type-state_enter"> <strong>state enter calls</strong> </a></code> are used, and the state changes the <code>gen_statem</code> engine calls the new state callback with arguments <code><a href="#type-state_enter">(enter, OldState, Data)</a></code> or <code><a href="#type-state_enter">(enter, OldState, State, Data)</a></code> (depending on <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code>) and when it returns starts again from the top of this sequence. </p> </li> <li> <p> If <code><a href="#type-postpone">postpone()</a></code> is <code>true</code>, the current event is postponed. </p> </li> <li> <p> If this is a <strong>state change</strong>, the queue of incoming events is reset to start with the oldest postponed. </p> </li> <li> <p> All events stored with <code><a href="#type-action">action()</a></code> <code>next_event</code> are inserted to be processed before previously queued events. </p> </li> <li> <p> Time-out timers <code><a href="#type-event_timeout">event_timeout()</a></code>, <code><a href="#type-generic_timeout">generic_timeout()</a></code> and <code><a href="#type-state_timeout">state_timeout()</a></code> are handled. Time-outs with zero time are guaranteed to be delivered to the state machine before any external not yet received event so if there is such a time-out requested, the corresponding time-out zero event is enqueued as the newest received event; that is after already queued events such as inserted and postponed events. </p> <p> Any event cancels an <code><a href="#type-event_timeout">event_timeout()</a></code> so a zero time event time-out is only generated if the event queue is empty. </p> <p> A <strong>state change</strong> cancels a <code><a href="#type-state_timeout">state_timeout()</a></code> and any new transition option of this type belongs to the new state, that is; a <code><a href="#type-state_timeout">state_timeout()</a></code> applies to the state the state machine enters. </p> </li> <li> <p> If there are enqueued events the <code><a href="#state%20callback"><strong>state callback</strong></a></code> for the possibly new state is called with the oldest enqueued event, and we start again from the top of this sequence. </p> </li> <li> <p> Otherwise the <code>gen_statem</code> goes into <code>receive</code> or hibernation (if <code><a href="#type-hibernate">hibernate()</a></code> is <code>true</code>) to wait for the next message. In hibernation the next non-system event awakens the <code>gen_statem</code>, or rather the next incoming message awakens the <code>gen_statem</code>, but if it is a system event it goes right back into hibernation. When a new message arrives the <code><a href="#state%20callback"><strong>state callback</strong></a></code> is called with the corresponding event, and we start again from the top of this sequence. </p> </li> </ol> </div></div></article> <article class="data-types-body"><h3 id="type-postpone" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-postpone">postpone()</a> = boolean()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> If <code>true</code>, postpones the current event and retries it after a <strong>state change</strong> (<code>NextState =/= State</code>). </p> </div></div></article> <article class="data-types-body"><h3 id="type-hibernate" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-hibernate">hibernate()</a> = boolean()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> If <code>true</code>, hibernates the <code>gen_statem</code> by calling <code><a href="proc_lib.html#hibernate-3">proc_lib:hibernate/3</a></code> before going into <code>receive</code> to wait for a new external event. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling <code> erlang:garbage_collect/0 </code> to simulate that the <code>gen_statem</code> entered hibernation and immediately got awakened by an enqueued event. </p> </div> </div> </div></div></article> <article class="data-types-body"><h3 id="type-event_timeout" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-event_timeout">event_timeout()</a> = timeout() | integer()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Starts a timer set by <code><a href="#type-enter_action">enter_action()</a></code> <code>timeout</code>. When the timer expires an event of <code><a href="#type-event_type">event_type()</a></code> <code>timeout</code> will be generated. See <code>erlang:start_timer/4</code> for how <code>Time</code> and <code><a href="#type-timeout_option">Options</a></code> are interpreted. Future <code>erlang:start_timer/4</code> <code>Options</code> will not necessarily be supported. </p> <p> Any event that arrives cancels this time-out. Note that a retried or inserted event counts as arrived. So does a state time-out zero event, if it was generated before this time-out is requested. </p> <p> If <code>Time</code> is <code>infinity</code>, no timer is started, as it never would expire anyway. </p> <p> If <code>Time</code> is relative and <code>0</code> no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event, but after already queued events. </p> <p> Note that it is not possible nor needed to cancel this time-out, as it is cancelled automatically by any other event. </p> </div></div></article> <article class="data-types-body"><h3 id="type-generic_timeout" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-generic_timeout">generic_timeout()</a> = timeout() | integer()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Starts a timer set by <code><a href="#type-enter_action">enter_action()</a></code> <code>{timeout,Name}</code>. When the timer expires an event of <code><a href="#type-event_type">event_type()</a></code> <code>{timeout,Name}</code> will be generated. See <code>erlang:start_timer/4</code> for how <code>Time</code> and <code><a href="#type-timeout_option">Options</a></code> are interpreted. Future <code>erlang:start_timer/4</code> <code>Options</code> will not necessarily be supported. </p> <p> If <code>Time</code> is <code>infinity</code>, no timer is started, as it never would expire anyway. </p> <p> If <code>Time</code> is relative and <code>0</code> no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event. </p> <p> Setting a timer with the same <code>Name</code> while it is running will restart it with the new time-out value. Therefore it is possible to cancel a specific time-out by setting it to <code>infinity</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-state_timeout" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-state_timeout">state_timeout()</a> = timeout() | integer()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Starts a timer set by <code><a href="#type-enter_action">enter_action()</a></code> <code>state_timeout</code>. When the timer expires an event of <code><a href="#type-event_type">event_type()</a></code> <code>state_timeout</code> will be generated. See <code>erlang:start_timer/4</code> for how <code>Time</code> and <code><a href="#type-timeout_option">Options</a></code> are interpreted. Future <code>erlang:start_timer/4</code> <code>Options</code> will not necessarily be supported. </p> <p> If <code>Time</code> is <code>infinity</code>, no timer is started, as it never would expire anyway. </p> <p> If <code>Time</code> is relative and <code>0</code> no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event. </p> <p> Setting this timer while it is running will restart it with the new time-out value. Therefore it is possible to cancel this time-out by setting it to <code>infinity</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-timeout_option" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-timeout_option">timeout_option()</a> = {abs, Abs :: boolean()}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> If <code>Abs</code> is <code>true</code> an absolute timer is started, and if it is <code>false</code> a relative, which is the default. See <code> erlang:start_timer/4 </code> for details. </p>  </div></div></article> <article class="data-types-body"><h3 id="type-action" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-action">action()</a> = 
 postpone |
 {postpone, Postpone :: <a href="#type-postpone">postpone()</a>} |
 {next_event,
 EventType :: <a href="#type-event_type">event_type()</a>,
 EventContent :: <a href="#type-event_content">event_content()</a>} |
 {change_callback_module, NewModule :: module()} |
 {push_callback_module, NewModule :: module()} |
 pop_callback_module |
 <a href="#type-enter_action">enter_action()</a></code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> These <strong>transition actions</strong> can be invoked by returning them from the <code><a href="#state%20callback"><strong>state callback</strong></a></code> when it is called with an <code><a href="#type-event_type">event</a></code>, from <code><a href="#Module:init-1">Module:init/1</a></code> or by giving them to <code><a href="#enter_loop-5">enter_loop/5,6</a></code>. </p> <p> Actions are executed in the containing list order. </p> <p> Actions that set <code><a href="#type-transition_option"> transition options </a></code> override any previous of the same type, so the last in the containing list wins. For example, the last <code><a href="#type-postpone">postpone()</a></code> overrides any previous <code>postpone()</code> in the list. </p> <dl> <dt class="title-link"><strong><code>postpone</code></strong></dt> <dd> <p> Sets the <code><a href="#type-transition_option"> transition_option() </a></code> <code><a href="#type-postpone">postpone()</a></code> for this <strong>state transition</strong>. This action is ignored when returned from <code><a href="#Module:init-1">Module:init/1</a></code> or given to <code><a href="#enter_loop-5">enter_loop/5,6</a></code>, as there is no event to postpone in those cases. </p> </dd> <dt class="title-link"><strong><code>next_event</code></strong></dt> <dd> <p> This action does not set any <code><a href="#type-transition_option"> transition_option() </a></code> but instead stores the specified <code>EventType</code> and <code>EventContent</code> for insertion after all actions have been executed. </p> <p> The stored events are inserted in the queue as the next to process before any already queued events. The order of these stored events is preserved, so the first <code>next_event</code> in the containing list becomes the first to process. </p> <p> An event of type <code><a href="#type-event_type">internal</a></code> is to be used when you want to reliably distinguish an event inserted this way from any external event. </p> </dd> <dt class="title-link"><strong> <code>change_callback_module</code> </strong></dt> <dd> <p> Changes the callback module to <code>NewModule</code> which will be used when calling all subsequent <code><a href="#state%20callback">state callbacks</a></code>. </p> <p> The <code>gen_statem</code> engine will find out the <code><a href="#type-callback_mode"> <strong>callback mode</strong> </a></code> of <code>NewModule</code> by calling <code><a href="#Module:callback_mode-0"> NewModule:callback_mode/0 </a></code> before the next <code><a href="#state%20callback">state callback</a></code>. </p> <p> Changing the callback module does not affect the <strong>state transition</strong> in any way, it only changes which module that handles the events. Be aware that all relevant callback functions in <code>NewModule</code> such as the <code><a href="#state%20callback">state callback</a></code>, <code><a href="#Module:code_change-4">NewModule:code_change/4</a></code>, <code><a href="#Module:format_status-1"> NewModule:format_status/1 </a></code> and <code><a href="#Module:terminate-3"> NewModule:terminate/3 </a></code> must be able to handle the state and data from the old module. </p> </dd> <dt class="title-link"><strong> <code>push_callback_module</code> </strong></dt> <dd> <p> Pushes the current callback module to the top of an internal stack of callback modules and changes the callback module to <code>NewModule</code>. Otherwise like <code>{change_callback_module, NewModule}</code> above. </p> </dd> <dt class="title-link"><strong> <code>pop_callback_module</code> </strong></dt> <dd> Pops the top module from the internal stack of callback modules and changes the callback module to be the popped module. If the stack is empty the server fails. Otherwise like <code>{change_callback_module, NewModule}</code> above. </dd> </dl> </div></div></article> <article class="data-types-body"><h3 id="type-enter_action" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-enter_action">enter_action()</a> = 
 hibernate |
 {hibernate, Hibernate :: <a href="#type-hibernate">hibernate()</a>} |
 <a href="#type-timeout_action">timeout_action()</a> |
 <a href="#type-reply_action">reply_action()</a></code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> These <strong>transition actions</strong> can be invoked by returning them from the <code><a href="#state%20callback"><strong>state callback</strong></a></code>, from <code><a href="#Module:init-1">Module:init/1</a></code> or by giving them to <code><a href="#enter_loop-5">enter_loop/5,6</a></code>. </p> <p> Actions are executed in the containing list order. </p> <p> Actions that set <code><a href="#type-transition_option">transition options</a></code> override any previous of the same type, so the last in the containing list wins. For example, the last <code><a href="#type-event_timeout">event_timeout()</a></code> overrides any previous <code>event_timeout()</code> in the list. </p> <dl> <dt class="title-link"><strong><code>hibernate</code></strong></dt> <dd> <p> Sets the <code><a href="#type-transition_option">transition_option()</a></code> <code><a href="#type-hibernate">hibernate()</a></code> for this <strong>state transition</strong>. </p> </dd> </dl> </div></div></article> <article class="data-types-body"><h3 id="type-timeout_action" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-timeout_action">timeout_action()</a> = 
 (Time :: <a href="#type-event_timeout">event_timeout()</a>) |
 {timeout,
 Time :: <a href="#type-event_timeout">event_timeout()</a>,
 EventContent :: <a href="#type-event_content">event_content()</a>} |
 {timeout,
 Time :: <a href="#type-event_timeout">event_timeout()</a>,
 EventContent :: <a href="#type-event_content">event_content()</a>,
 Options :: <a href="#type-timeout_option">timeout_option()</a> | [<a href="#type-timeout_option">timeout_option()</a>]} |
 {{timeout, Name :: term()},
 Time :: <a href="#type-generic_timeout">generic_timeout()</a>,
 EventContent :: <a href="#type-event_content">event_content()</a>} |
 {{timeout, Name :: term()},
 Time :: <a href="#type-generic_timeout">generic_timeout()</a>,
 EventContent :: <a href="#type-event_content">event_content()</a>,
 Options :: <a href="#type-timeout_option">timeout_option()</a> | [<a href="#type-timeout_option">timeout_option()</a>]} |
 {state_timeout,
 Time :: <a href="#type-state_timeout">state_timeout()</a>,
 EventContent :: <a href="#type-event_content">event_content()</a>} |
 {state_timeout,
 Time :: <a href="#type-state_timeout">state_timeout()</a>,
 EventContent :: <a href="#type-event_content">event_content()</a>,
 Options :: <a href="#type-timeout_option">timeout_option()</a> | [<a href="#type-timeout_option">timeout_option()</a>]} |
 <a href="#type-timeout_cancel_action">timeout_cancel_action()</a> |
 <a href="#type-timeout_update_action">timeout_update_action()</a></code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> These <strong>transition actions</strong> can be invoked by returning them from the <code><a href="#state%20callback"><strong>state callback</strong></a></code>, from <code><a href="#Module:init-1">Module:init/1</a></code> or by giving them to <code><a href="#enter_loop-5">enter_loop/5,6</a></code>. </p> <p> These time-out actions sets time-out <code><a href="#type-transition_option">transition options</a></code>. </p> <dl> <dt class="title-link"><strong><code>Time</code></strong></dt> <dd> <p> Short for <code>{timeout,Time,Time}</code>, that is, the time-out message is the time-out time. This form exists to make the <code><a href="#state%20callback"><strong>state callback</strong></a></code> return value <code>{next_state,NextState,NewData,Time}</code> allowed like for <code>gen_fsm</code>. </p> </dd> <dt class="title-link"><strong><code>timeout</code></strong></dt> <dd> <p> Sets the <code><a href="#type-transition_option">transition_option()</a></code> <code><a href="#type-event_timeout">event_timeout()</a></code> to <code>Time</code> with <code>EventContent</code> and time-out options <code><a href="#type-timeout_option">Options</a></code>. </p> </dd> <dt class="title-link"><strong><code>{timeout,Name}</code></strong></dt> <dd> <p> Sets the <code><a href="#type-transition_option">transition_option()</a></code> <code><a href="#type-generic_timeout">generic_timeout()</a></code> to <code>Time</code> for <code>Name</code> with <code>EventContent</code> and time-out options <code><a href="#type-timeout_option">Options</a></code>. </p> </dd> <dt class="title-link"><strong><code>state_timeout</code></strong></dt> <dd> <p> Sets the <code><a href="#type-transition_option">transition_option()</a></code> <code><a href="#type-state_timeout">state_timeout()</a></code> to <code>Time</code> with <code>EventContent</code> and time-out options <code><a href="#type-timeout_option">Options</a></code>. </p> </dd> </dl> </div></div></article> <article class="data-types-body"><h3 id="type-timeout_cancel_action" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-timeout_cancel_action">timeout_cancel_action()</a> = 
 {timeout, cancel} |
 {{timeout, Name :: term()}, cancel} |
 {state_timeout, cancel}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> This is a shorter and clearer form of <code><a href="#type-timeout_action"> timeout_action() </a></code> with <code>Time = infinity</code> which cancels a time-out. </p> </div></div></article> <article class="data-types-body"><h3 id="type-timeout_update_action" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-timeout_update_action">timeout_update_action()</a> = 
 {timeout, update, EventContent :: <a href="#type-event_content">event_content()</a>} |
 {{timeout, Name :: term()},
 update,
 EventContent :: <a href="#type-event_content">event_content()</a>} |
 {state_timeout, update, EventContent :: <a href="#type-event_content">event_content()</a>}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Updates a time-out with a new <code>EventContent</code>. See <code><a href="#type-timeout_action"> timeout_action() </a></code> for how to start a time-out. </p> <p> If no time-out of the same type is active instead insert the time-out event just like when starting a time-out with relative <code>Time = 0</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-reply_action" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-reply_action">reply_action()</a> = {reply, From :: <a href="#type-from">from()</a>, Reply :: term()}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> This <strong>transition action</strong> can be invoked by returning it from the <code><a href="#state%20callback"><strong>state callback</strong></a></code>, from <code><a href="#Module:init-1">Module:init/1</a></code> or by giving it to <code><a href="#enter_loop-5">enter_loop/5,6</a></code>. </p> <p> It does not set any <code><a href="#type-transition_option"> transition_option() </a></code> but instead replies to a caller waiting for a reply in <code><a href="#call-2">call/2</a></code>. <code>From</code> must be the term from argument <code><a href="#type-event_type">{call,From}</a></code> in a call to a <code><a href="#state%20callback"><strong>state callback</strong></a></code>. </p> <p> Note that using this action from <code><a href="#Module:init-1">Module:init/1</a></code> or <code><a href="#enter_loop-5">enter_loop/5,6</a></code> would be weird on the border of witchcraft since there has been no earlier call to a <code><a href="#state%20callback"><strong>state callback</strong></a></code> in this server. </p> </div></div></article> <article class="data-types-body"><h3 id="type-init_result" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-init_result">init_result(StateType)</a> = <a href="#type-init_result">init_result</a>(StateType, term())</code><br> <pre data-language="erlang"><code><a name="type-init_result">init_result(StateType, DataType)</a> = 
 {ok, State :: StateType, Data :: DataType} |
 {ok,
 State :: StateType,
 Data :: DataType,
 Actions :: [<a href="#type-action">action()</a>] | <a href="#type-action">action()</a>} |
 ignore |
 {stop, Reason :: term()} |
 {error, Reason :: term()}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> For a succesful initialization, <code>State</code> is the initial <code><a href="#type-state">state()</a></code> and <code>Data</code> the initial server <code><a href="#type-data">data()</a></code> of the <code>gen_statem</code>. </p> <p> The <code><a href="#type-action">Actions</a></code> are executed when entering the first <code><a href="#type-state">state</a></code> just as for a <code><a href="#state%20callback"><strong>state callback</strong></a></code>, except that the action <code>postpone</code> is forced to <code>false</code> since there is no event to postpone. </p> <p> For an unsuccesful initialization, <code>{stop, Reason}</code>, <code>{error, Reason}</code> or <code>ignore</code> should be used; see <code><a href="#start_link-3">start_link/3,4</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-state_enter_result" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-state_enter_result">state_enter_result(State)</a> = <a href="#type-state_enter_result">state_enter_result</a>(State, term())</code><br> <pre data-language="erlang"><code><a name="type-state_enter_result">state_enter_result(State, DataType)</a> = 
 {next_state, State, NewData :: DataType} |
 {next_state, State,
 NewData :: DataType,
 Actions :: [<a href="#type-enter_action">enter_action()</a>] | <a href="#type-enter_action">enter_action()</a>} |
 <a href="#type-state_callback_result">state_callback_result</a>(<a href="#type-enter_action">enter_action()</a>)</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> <code>State</code> is the current state and it cannot be changed since the state callback was called with a <code><a href="#type-state_enter"><strong>state enter call</strong></a></code>. </p> <dl> <dt class="title-link"><strong><code>next_state</code></strong></dt> <dd> <p> The <code>gen_statem</code> does a state transition to <code>State</code>, which has to be the current state, sets <code>NewData</code>, and executes all <code>Actions</code>. </p> </dd> </dl> </div></div></article> <article class="data-types-body"><h3 id="type-event_handler_result" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-event_handler_result">event_handler_result(StateType)</a> = 
 <a href="#type-event_handler_result">event_handler_result</a>(StateType, term())</code></pre>
<br> <pre data-language="erlang"><code><a name="type-event_handler_result">event_handler_result(StateType, DataType)</a> = 
 {next_state, NextState :: StateType, NewData :: DataType} |
 {next_state,
 NextState :: StateType,
 NewData :: DataType,
 Actions :: [<a href="#type-action">action()</a>] | <a href="#type-action">action()</a>} |
 <a href="#type-state_callback_result">state_callback_result</a>(<a href="#type-action">action()</a>)</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> <code>StateType</code> is <code><a href="#type-state_name">state_name()</a></code> if <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code>state_functions</code>, or <code><a href="#type-state">state()</a></code> if <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code>handle_event_function</code>. </p> <dl> <dt class="title-link"><strong><code>next_state</code></strong></dt> <dd> <p> The <code>gen_statem</code> does a <strong>state transition</strong> to <code>NextState</code> (which can be the same as the current state), sets <code>NewData</code>, and executes all <code>Actions</code>. If <code>NextState =/= CurrentState</code> the <strong>state transition</strong> is a <strong>state change</strong>. </p> </dd> </dl> </div></div></article> <article class="data-types-body"><h3 id="type-state_callback_result" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-state_callback_result">state_callback_result(ActionType)</a> = 
 <a href="#type-state_callback_result">state_callback_result</a>(ActionType, term())</code></pre>
<br> <pre data-language="erlang"><code><a name="type-state_callback_result">state_callback_result(ActionType, DataType)</a> = 
 {keep_state, NewData :: DataType} |
 {keep_state,
 NewData :: DataType,
 Actions :: [ActionType] | ActionType} |
 keep_state_and_data |
 {keep_state_and_data, Actions :: [ActionType] | ActionType} |
 {repeat_state, NewData :: DataType} |
 {repeat_state,
 NewData :: DataType,
 Actions :: [ActionType] | ActionType} |
 repeat_state_and_data |
 {repeat_state_and_data, Actions :: [ActionType] | ActionType} |
 stop |
 {stop, Reason :: term()} |
 {stop, Reason :: term(), NewData :: DataType} |
 {stop_and_reply,
 Reason :: term(),
 Replies :: [<a href="#type-reply_action">reply_action()</a>] | <a href="#type-reply_action">reply_action()</a>} |
 {stop_and_reply,
 Reason :: term(),
 Replies :: [<a href="#type-reply_action">reply_action()</a>] | <a href="#type-reply_action">reply_action()</a>,
 NewData :: DataType}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> <code>ActionType</code> is <code><a href="#type-enter_action">enter_action()</a></code> if the state callback was called with a <code><a href="#type-state_enter"><strong>state enter call</strong></a></code> and <code><a href="#type-action">action()</a></code> if the state callback was called with an event. </p> <dl> <dt class="title-link"><strong><code>keep_state</code></strong></dt> <dd> <p> The same as <code>{next_state,CurrentState,NewData,Actions}</code>. </p> </dd> <dt class="title-link"><strong><code>keep_state_and_data</code></strong></dt> <dd> <p> The same as <code>{keep_state,CurrentData,Actions}</code>. </p> </dd> <dt class="title-link"><strong><code>repeat_state</code></strong></dt> <dd> <p> If the <code>gen_statem</code> runs with <code><a href="#type-state_enter"><strong>state enter calls</strong></a></code>, the <strong>state enter call</strong> is repeated, see type <code><a href="#type-transition_option">transition_option()</a></code>, other than that <code>repeat_state</code> is the same as <code>keep_state</code>. </p> </dd> <dt class="title-link"><strong><code>repeat_state_and_data</code></strong></dt> <dd> <p> The same as <code>{repeat_state,CurrentData,Actions}</code>. </p> </dd> <dt class="title-link"><strong><code>stop</code></strong></dt> <dd> <p> Terminates the <code>gen_statem</code> by calling <code><a href="#Module:terminate-3">Module:terminate/3</a></code> with <code>Reason</code> and <code>NewData</code>, if specified. An exit signal with this reason is sent to linked processes and ports. The default <code>Reason</code> is <code>normal</code>. </p> </dd> <dt class="title-link"><strong><code>stop_and_reply</code></strong></dt> <dd> <p> Sends all <code>Replies</code>, then terminates the <code>gen_statem</code> by calling <code><a href="#Module:terminate-3">Module:terminate/3</a></code> with <code>Reason</code> and <code>NewData</code>, if specified. An exit signal with this reason is sent to linked processes and ports. </p> </dd> </dl> <p> All these terms are tuples or atoms and this property will hold in any future version of <code>gen_statem</code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-request_id" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-request_id">request_id()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> An opaque request identifier. See <code><a href="#send_request-2">send_request/2</a></code> for details. </p> </div></div></article> <article class="data-types-body"><h3 id="type-request_id_collection" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-request_id_collection">request_id_collection()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> An opaque collection of request identifiers (<code><a href="#type-request_id">request_id()</a></code>) where each request identifier can be associated with a label chosen by the user. For more information see <code><a href="#reqids_new-0">reqids_new/0</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-response_timeout" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-response_timeout">response_timeout()</a> = timeout() | {abs, integer()}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Used to set a time limit on how long to wait for a response using either <code><a href="#receive_response-2">receive_response/2</a></code>, <code><a href="#receive_response-3">receive_response/3</a></code>, <code><a href="#wait_response-2">wait_response/2</a></code>, or <code><a href="#wait_response-3">wait_response/3</a></code>. The time unit used is <code>millisecond</code>. Currently valid values: </p> <dl> <dt class="title-link"><strong><code>0..4294967295</code></strong></dt> <dd><p> Timeout relative to current time in milliseconds. </p></dd> <dt class="title-link"><strong><code>infinity</code></strong></dt> <dd><p> Infinite timeout. That is, the operation will never time out. </p></dd> <dt class="title-link"><strong><code>{abs, Timeout}</code></strong></dt> <dd><p> An absolute <code>Erlang monotonic time</code> timeout in milliseconds. That is, the operation will time out when <code>erlang:monotonic_time(millisecond)</code> returns a value larger than or equal to <code>Timeout</code>. <code>Timeout</code> is not allowed to identify a time further into the future than <code>4294967295</code> milliseconds. Identifying the timeout using an absolute timeout value is especially handy when you have a deadline for responses corresponding to a complete collection of requests (<code><a href="#type-request_id_collection">request_id_collection()</a></code>) , since you do not have to recalculate the relative time until the deadline over and over again. </p></dd> </dl> </div></div></article> <article class="data-types-body"><h3 id="type-format_status" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-format_status">format_status()</a> = 
 #{state =&gt; <a href="#type-state">state()</a>,
 data =&gt; <a href="#type-data">data()</a>,
 reason =&gt; term(),
 queue =&gt; [{<a href="#type-event_type">event_type()</a>, <a href="#type-event_content">event_content()</a>}],
 postponed =&gt; [{<a href="#type-event_type">event_type()</a>, <a href="#type-event_content">event_content()</a>}],
 timeouts =&gt; [{<a href="#type-timeout_event_type">timeout_event_type()</a>, <a href="#type-event_content">event_content()</a>}],
 log =&gt; [<a href="sys.html#type-system_event">sys:system_event()</a>]}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> A map that describes the <code>gen_statem</code> status. The keys are: </p> <dl> <dt class="title-link"><strong><code>state</code></strong></dt> <dd>The current state of the <code>gen_statem</code> process.</dd> <dt class="title-link"><strong><code>data</code></strong></dt> <dd>The state data of the the <code>gen_statem</code> process.</dd> <dt class="title-link"><strong><code>reason</code></strong></dt> <dd>The reason that caused the state machine to terminate.</dd> <dt class="title-link"><strong><code>queue</code></strong></dt> <dd>The event queue of the <code>gen_statem</code> process.</dd> <dt class="title-link"><strong><code>postponed</code></strong></dt> <dd> The <code><a href="#type-postpone">postponed</a></code> events queue of the <code>gen_statem</code> process. </dd> <dt class="title-link"><strong><code>timeouts</code></strong></dt> <dd> The active <code><a href="#type-timeout_action">time-outs</a></code> of the <code>gen_statem</code> process. </dd> <dt class="title-link"><strong><code>log</code></strong></dt> <dd> The <code><a href="sys.html#log-2">sys log</a></code> of the server. </dd> </dl> <p> New associations may be added to the status map without prior notice. </p> </div></div></article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="call-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>call(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>, Request :: <code>term()</code>) -&gt;
 Reply :: <code>term()</code></code></pre>
<div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <h3 id="call-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>call(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>,
 Request :: <code>term()</code>,
 Timeout ::
 <code>timeout()</code> |
 {clean_timeout, T :: <code>timeout()</code>} |
 {dirty_timeout, T :: <code>timeout()</code>}) -&gt;
 Reply :: <code>term()</code></code></pre>
<div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Makes a synchronous call to the <code>gen_statem</code> <code><a href="#type-server_ref">ServerRef</a></code> by sending a request and waiting until its reply arrives. The <code>gen_statem</code> calls the <code><a href="#state%20callback"><strong>state callback</strong></a></code> with <code><a href="#type-event_type">event_type()</a></code> <code>{call,From}</code> and event content <code>Request</code>. </p> <p> A <code>Reply</code> is generated when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns with <code>{reply,From,Reply}</code> as one <code><a href="#type-action">action()</a></code>, and that <code>Reply</code> becomes the return value of this function. </p> <p> <code>Timeout</code> is an integer &gt; 0, which specifies how many milliseconds to wait for a reply, or the atom <code>infinity</code> to wait indefinitely, which is the default. If no reply is received within the specified time, the function call fails. </p> <p> Previous issue with late replies that could occur when having network issues or using <code>dirty_timeout</code> is now prevented by use of <code><i>process aliases</i></code>. <code>{clean_timeout, T}</code> and <code>{dirty_timeout, T}</code> therefore no longer serves any purpose and will work the same as <code>Timeout</code> while all of them also being equally efficient. </p> <p> The call can also fail, for example, if the <code>gen_statem</code> dies before or during this function call. </p> <p> When this call fails it <code>exits</code> the calling process. The exit term is on the form <code>{Reason, Location}</code> where <code>Location = {gen_statem,call,ArgList}</code>. See <code><a href="gen_server.html#call-3"> gen_server:call/3 </a></code> that has a description of relevant values for the <code>Reason</code> in the exit term. </p> </div></div></article><article class="func"><h3 id="cast-2" class="bold_code title-link func-head">  <code>cast(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>, Msg :: <code>term()</code>) -&gt; ok</code><div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends an asynchronous event to the <code>gen_statem</code> <code><a href="#type-server_ref">ServerRef</a></code> and returns <code>ok</code> immediately, ignoring if the destination node or <code>gen_statem</code> does not exist. The <code>gen_statem</code> calls the <code><a href="#state%20callback"><strong>state callback</strong></a></code> with <code><a href="#type-event_type">event_type()</a></code> <code>cast</code> and event content <code>Msg</code>. </p> </div></div></article><article class="func"><h3 id="check_response-2" class="bold_code title-link func-head">  <code>check_response(Msg, ReqId) -&gt; Result</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Msg = term()</code></div> <div class="REFTYPES rt-1"><code>ReqId = <a href="#type-request_id">request_id()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Response = 
 {reply, Reply :: term()} |
 {error, {Reason :: term(), <a href="#type-server_ref">server_ref()</a>}}</code></pre></div> <div class="REFTYPES rt-1"><code>Result = Response | no_reply</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Check if <code>Msg</code> is a response corresponding to the request identifier <code>ReqId</code>. The request must have been made by <code><a href="#send_request-2">send_request/2</a></code>. If <code>Msg</code> is a reply to the handle <code>ReqId</code> the result of the request is returned in <code>Reply</code>. Otherwise returns <code>no_reply</code> and no cleanup is done, and thus the function shall be invoked repeatedly until a reply is returned. </p> <p> The return value <code>Reply</code> is generated when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns with <code>{reply,From,Reply}</code> as one <code><a href="#type-action">action()</a></code>, and that <code>Reply</code> becomes the return value of this function. </p> <p> The function returns an error if the <code>gen_statem</code> dies before or during this request. </p> </div></div></article><article class="func"><h3 id="check_response-3" class="bold_code title-link func-head">  <code>check_response(Msg, ReqIdCollection, Delete) -&gt; Result</code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Msg = term()</code></div> <div class="REFTYPES rt-1"><code>ReqIdCollection = <a href="#type-request_id_collection">request_id_collection()</a></code></div> <div class="REFTYPES rt-1"><code>Delete = boolean()</code></div> <div class="REFTYPES rt-1"><pre><code>Response = 
 {reply, Reply :: term()} |
 {error, {Reason :: term(), <a href="#type-server_ref">server_ref()</a>}}</code></pre></div> <div class="REFTYPES rt-1"><pre><code>Result = 
 {Response,
 Label :: term(),
 NewReqIdCollection :: <a href="#type-request_id_collection">request_id_collection()</a>} |
 no_request | no_reply</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Check if <code>Msg</code> is a response corresponding to a request identifier saved in <code>ReqIdCollection</code>. All request identifiers of <code>ReqIdCollection</code> must correspond to requests that have been made using <code><a href="#send_request-2">send_request/2</a></code> or <code><a href="#send_request-4">send_request/4</a></code>, and all request must have been made by the process calling this function. </p> <p> The <code>Label</code> in the response equals the <code>Label</code> associated with the request identifier that the response corresponds to. The <code>Label</code> of a request identifier is associated when <code><a href="#reqids_add-3">saving the request id</a></code> in a request identifier collection, or when sending the request using <code><a href="#send_request-4">send_request/4</a></code>. </p> <p> Compared to <code><a href="#check_response-2">check_response/2</a></code>, the returned result associated with a specific request identifier or an exception associated with a specific request identifier will be wrapped in a 3-tuple. The first element of this tuple equals the value that would have been produced by <code>check_response/2</code>, the second element equals the <code>Label</code> associated with the specific request identifier, and the third element <code>NewReqIdCollection</code> is a possibly modified request identifier collection. </p> <p> If <code>ReqIdCollection</code> is empty, the atom <code>no_request</code> will be returned. If <code>Msg</code> does not correspond to any of the request identifiers in <code>ReqIdCollection</code>, the atom <code>no_reply</code> is returned. </p> <p> If <code>Delete</code> equals <code>true</code>, the association with <code>Label</code> will have been deleted from <code>ReqIdCollection</code> in the resulting <code>NewReqIdCollection</code>. If <code>Delete</code> equals <code>false</code>, <code>NewReqIdCollection</code> will equal <code>ReqIdCollection</code>. Note that deleting an association is not for free and that a collection containing already handled requests can still be used by subsequent calls to <code>check_response/3</code>, <code><a href="#receive_response-3">receive_response/3</a></code>, and <code><a href="#wait_response-3">wait_response/3</a></code>. However, without deleting handled associations, the above calls will not be able to detect when there are no more outstanding requests to handle, so you will have to keep track of this some other way than relying on a <code>no_request</code> return. Note that if you pass a collection only containing associations of already handled or abandoned requests to <code>check_response/3</code>, it will always return <code>no_reply</code>. </p> </div></div></article><article class="func"><h3 id="enter_loop-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>enter_loop(Module :: <code>module()</code>,
 Opts :: [<code><a href="#type-enter_loop_opt">enter_loop_opt()</a></code>],
 State :: <code><a href="#type-state">state()</a></code>,
 Data :: <code><a href="#type-data">data()</a></code>) -&gt;
 <code>no_return()</code></code></pre>
<div class="title-since"><span class="since">OTP 19.1</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> The same as <code><a href="#enter_loop-6">enter_loop/6</a></code> with <code>Actions = []</code> except that no <code><a href="#type-server_name">server_name()</a></code> must have been registered. This creates an anonymous server. </p> </div></div></article><article class="func"><h3 id="enter_loop-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>enter_loop(Module :: <code>module()</code>,
 Opts :: [<code><a href="#type-enter_loop_opt">enter_loop_opt()</a></code>],
 State :: <code><a href="#type-state">state()</a></code>,
 Data :: <code><a href="#type-data">data()</a></code>,
 Server_or_Actions :: <code><a href="#type-server_name">server_name()</a></code> | <code>pid()</code> | [<code><a href="#type-action">action()</a></code>]) -&gt;
 <code>no_return()</code></code></pre>
<div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> If <code>Server_or_Actions</code> is a <code>list()</code>, the same as <code><a href="#enter_loop-6">enter_loop/6</a></code> except that no <code><a href="#type-server_name">server_name()</a></code> must have been registered and <code>Actions = Server_or_Actions</code>. This creates an anonymous server. </p> <p> Otherwise the same as <code><a href="#enter_loop-6">enter_loop/6</a></code> with <code>Server = Server_or_Actions</code> and <code>Actions = []</code>. </p> </div></div></article><article class="func"><h3 id="enter_loop-6" class="bold_code title-link func-head">  <pre data-language="erlang"><code>enter_loop(Module :: <code>module()</code>,
 Opts :: [<code><a href="#type-enter_loop_opt">enter_loop_opt()</a></code>],
 State :: <code><a href="#type-state">state()</a></code>,
 Data :: <code><a href="#type-data">data()</a></code>,
 Server :: <code><a href="#type-server_name">server_name()</a></code> | <code>pid()</code>,
 Actions :: [<code><a href="#type-action">action()</a></code>] | <code><a href="#type-action">action()</a></code>) -&gt;
 <code>no_return()</code></code></pre>
<div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Makes the calling process become a <code>gen_statem</code>. Does not return, instead the calling process enters the <code>gen_statem</code> receive loop and becomes a <code>gen_statem</code> server. The process <strong>must</strong> have been started using one of the start functions in <code><a href="proc_lib.html">proc_lib</a></code>. The user is responsible for any initialization of the process, including registering a name for it. </p> <p> This function is useful when a more complex initialization procedure is needed than the <code>gen_statem</code> behavior provides. </p> <p> <code>Module</code>, <code>Opts</code> have the same meaning as when calling <code><a href="#start_link-3">start[_link|_monitor]/3,4</a></code>. </p> <p> If <code>Server</code> is <code>self()</code> an anonymous server is created just as when using <code><a href="#start_link-3">start[_link|_monitor]/3</a></code>. If <code>Server</code> is a <code><a href="#type-server_name">server_name()</a></code> a named server is created just as when using <code><a href="#start_link-4">start[_link|_monitor]/4</a></code>. However, the <code><a href="#type-server_name">server_name()</a></code> name must have been registered accordingly <strong>before</strong> this function is called. </p> <p> <code>State</code>, <code>Data</code>, and <code>Actions</code> have the same meanings as in the return value of <code><a href="#Module:init-1">Module:init/1</a></code>. Also, the callback module does not need to export a <code><a href="#Module:init-1">Module:init/1</a></code> function. </p> <p> The function fails if the calling process was not started by a <code><a href="proc_lib.html">proc_lib</a></code> start function, or if it is not registered according to <code><a href="#type-server_name">server_name()</a></code>. </p> </div></div></article><article class="func"><h3 id="receive_response-1" class="bold_code title-link func-head">  <code>receive_response(ReqId) -&gt; Result</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ReqId = <a href="#type-request_id">request_id()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Response = 
 {reply, Reply :: term()} |
 {error, {Reason :: term(), <a href="#type-server_ref">server_ref()</a>}}</code></pre></div> <div class="REFTYPES rt-1"><code>Result = Response | timeout</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> The same as calling <code><a href="#receive_response-2">gen_statem:receive_response(ReqId, infinity)</a></code>. </p> </div></div></article><article class="func"><h3 id="receive_response-2" class="bold_code title-link func-head">  <code>receive_response(ReqId, Timeout) -&gt; Result</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ReqId = <a href="#type-request_id">request_id()</a></code></div> <div class="REFTYPES rt-1"><code>Timeout = <a href="#type-response_timeout">response_timeout()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Response = 
 {reply, Reply :: term()} |
 {error, {Reason :: term(), <a href="#type-server_ref">server_ref()</a>}}</code></pre></div> <div class="REFTYPES rt-1"><code>Result = Response | timeout</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Receive a response corresponding to the request identifier <code>ReqId</code>- The request must have been made by <code><a href="#send_request-2">send_request/2</a></code> to the <code>gen_statem</code> process. This function must be called from the same process from which <code><a href="#send_request-2">send_request/2</a></code> was made. </p> <p> <code>Timeout</code> specifies how long to wait for a response. If no response is received within the specified time, the function returns <code>timeout</code>. Assuming that the server executes on a node supporting aliases (introduced in OTP 24) the request will also be abandoned. That is, no response will be received after a timeout. Otherwise, a stray response might be received at a later time. </p> <p> The return value <code>Reply</code> is generated when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns with <code>{reply,From,Reply}</code> as one <code><a href="#type-action">action()</a></code>, and that <code>Reply</code> becomes the return value of this function. </p> <p> The function returns an error if the <code>gen_statem</code> dies before or during this function call. </p> <p> The difference between <code><a href="#wait_response-2">wait_response/2</a></code> and <code>receive_response/2</code> is that <code>receive_response/2</code> abandons the request at timeout so that a potential future response is ignored, while <code>wait_response/2</code> does not. </p> </div></div></article><article class="func"><h3 id="receive_response-3" class="bold_code title-link func-head">  <code>receive_response(ReqIdCollection, Timeout, Delete) -&gt; Result</code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ReqIdCollection = <a href="#type-request_id_collection">request_id_collection()</a></code></div> <div class="REFTYPES rt-1"><code>Timeout = <a href="#type-response_timeout">response_timeout()</a></code></div> <div class="REFTYPES rt-1"><code>Delete = boolean()</code></div> <div class="REFTYPES rt-1"><pre><code>Response = 
 {reply, Reply :: term()} |
 {error, {Reason :: term(), <a href="#type-server_ref">server_ref()</a>}}</code></pre></div> <div class="REFTYPES rt-1"><pre><code>Result = 
 {Response,
 Label :: term(),
 NewReqIdCollection :: <a href="#type-request_id_collection">request_id_collection()</a>} |
 no_request | timeout</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Receive a response corresponding to a request identifier saved in <code>ReqIdCollection</code>. All request identifiers of <code>ReqIdCollection</code> must correspond to requests that have been made using <code><a href="#send_request-2">send_request/2</a></code> or <code><a href="#send_request-4">send_request/4</a></code>, and all request must have been made by the process calling this function. </p> <p> The <code>Label</code> in the response equals the <code>Label</code> associated with the request identifier that the response corresponds to. The <code>Label</code> of a request identifier is associated when <code><a href="#reqids_add-3">adding the request id</a></code> in a request identifier collection, or when sending the request using <code><a href="#send_request-4">send_request/4</a></code>. </p> <p> Compared to <code><a href="#receive_response-2">receive_response/2</a></code>, the returned result associated with a specific request identifier will be wrapped in a 3-tuple. The first element of this tuple equals the value that would have been produced by <code>receive_response/2</code>, the second element equals the <code>Label</code> associated with the specific request identifier, and the third element <code>NewReqIdCollection</code> is a possibly modified request identifier collection. </p> <p> If <code>ReqIdCollection</code> is empty, the atom <code>no_request</code> will be returned. </p> <p> <code>Timeout</code> specifies how long to wait for a response. If no response is received within the specified time, the function returns <code>timeout</code>. Assuming that the server executes on a node supporting aliases (introduced in OTP 24) all requests identified by <code>ReqIdCollection</code> will also be abandoned. That is, no responses will be received after a timeout. Otherwise, stray responses might be received at a later time. </p> <p> The difference between <code>receive_response/3</code> and <code><a href="#wait_response-3">wait_response/3</a></code> is that <code>receive_response/3</code> abandons the requests at timeout so that potential future responses are ignored, while <code>wait_response/3</code> does not. </p> <p> If <code>Delete</code> equals <code>true</code>, the association with <code>Label</code> will have been deleted from <code>ReqIdCollection</code> in the resulting <code>NewReqIdCollection</code>. If <code>Delete</code> equals <code>false</code>, <code>NewReqIdCollection</code> will equal <code>ReqIdCollection</code>. Note that deleting an association is not for free and that a collection containing already handled requests can still be used by subsequent calls to <code>receive_response/3</code>, <code><a href="#check_response-3">check_response/3</a></code>, and <code><a href="#wait_response-3">wait_response/3</a></code>. However, without deleting handled associations, the above calls will not be able to detect when there are no more outstanding requests to handle, so you will have to keep track of this some other way than relying on a <code>no_request</code> return. Note that if you pass a collection only containing associations of already handled or abandoned requests to <code>receive_response/3</code>, it will always block until a timeout determined by <code>Timeout</code> is triggered. </p> </div></div></article><article class="func"><h3 id="reply-1" class="bold_code title-link func-head">  <code>reply(Replies :: [<code><a href="#type-reply_action">reply_action()</a></code>] | <code><a href="#type-reply_action">reply_action()</a></code>) -&gt; ok</code><div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <h3 id="reply-2" class="bold_code title-link func-head">  <code>reply(From :: <code><a href="#type-from">from()</a></code>, Reply :: <code>term()</code>) -&gt; ok</code><div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> This function can be used by a <code>gen_statem</code> to explicitly send a reply to a process that waits in <code><a href="#call-2">call/2</a></code> when the reply cannot be defined in the return value of a <code><a href="#state%20callback"><strong>state callback</strong></a></code>. </p> <p> <code>From</code> must be the term from argument <code><a href="#type-event_type">{call,From}</a></code> to the <code><a href="#state%20callback"><strong>state callback</strong></a></code>. A reply or multiple replies canalso be sent using one or several <code><a href="#type-reply_action">reply_action()</a></code>s from a <code><a href="#state%20callback"><strong>state callback</strong></a></code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> A reply sent with this function is not visible in <code><a href="sys.html">sys</a></code> debug output. </p> </div> </div> </div></div></article><article class="func"><h3 id="reqids_add-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>reqids_add(ReqId :: <code><a href="#type-request_id">request_id()</a></code>,
 Label :: <code>term()</code>,
 ReqIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code>) -&gt;
 NewReqIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Saves <code>ReqId</code> and associates a <code>Label</code> with the request identifier by adding this information to <code>ReqIdCollection</code> and returning the resulting request identifier collection. </p> </div></div></article><article class="func"><h3 id="reqids_new-0" class="bold_code title-link func-head">  <code>reqids_new() -&gt; NewReqIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code></code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a new empty request identifier collection. A request identifier collection can be utilized in order the handle multiple outstanding requests. </p> <p> Request identifiers of requests made by <code><a href="#send_request-2">send_request/2</a></code> can be saved in a request identifier collection using <code><a href="#reqids_add-3">reqids_add/3</a></code>. Such a collection of request identifiers can later be used in order to get one response corresponding to a request in the collection by passing the collection as argument to <code><a href="#receive_response-3">receive_response/3</a></code>, <code><a href="#wait_response-3">wait_response/3</a></code>, or, <code><a href="#check_response-3">check_response/3</a></code>. </p> <p> <code><a href="#reqids_size-1">reqids_size/1</a></code> can be used to determine the amount of request identifiers in a request identifier collection. </p> </div></div></article><article class="func"><h3 id="reqids_size-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>reqids_size(ReqIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code>) -&gt;
 <code>integer() &gt;= 0</code></code></pre>
<div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns the amount of request identifiers saved in <code>ReqIdCollection</code>. </p> </div></div></article><article class="func"><h3 id="reqids_to_list-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>reqids_to_list(ReqIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code>) -&gt;
 [{ReqId :: <code><a href="#type-request_id">request_id()</a></code>, Label :: <code>term()</code>}]</code></pre>
<div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a list of <code>{ReqId, Label}</code> tuples which corresponds to all request identifiers with their associated labels present in the <code>ReqIdCollection</code> collection. </p> </div></div></article><article class="func"><h3 id="send_request-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send_request(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>, Request :: <code>term()</code>) -&gt;
 ReqId :: <code><a href="#type-request_id">request_id()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends an asynchronous <code>call</code> request <code>Request</code> to the <code>gen_statem</code> process identified by <code>ServerRef</code> and returns a request identifier <code>ReqId</code>. The return value <code>ReqId</code> shall later be used with <code><a href="#receive_response-2"> receive_response/2</a></code>, <code><a href="#wait_response-2"> wait_response/2</a></code>, or <code><a href="#check_response-2"> check_response/2</a></code> to fetch the actual result of the request. Besides passing the request identifier directly to these functions, it can also be saved in a request identifier collection using <code><a href="#reqids_add-3">reqids_add/3</a></code>. Such a collection of request identifiers can later be used in order to get one response corresponding to a request in the collection by passing the collection as argument to <code><a href="#receive_response-3">receive_response/3</a></code>, <code><a href="#wait_response-3">wait_response/3</a></code>, or <code><a href="#check_response-3">check_response/3</a></code>. If you are about to save the request identifier in a request identifier collection, you may want to consider using <code><a href="#send_request-4">send_request/4</a></code> instead. </p> <p> The call <code>gen_statem:wait_response(gen_statem:send_request(ServerRef,Request), Timeout)</code> can be seen as equivalent to <code><a href="#call-3">gen_statem:call(Server,Request,Timeout)</a></code>, ignoring the error handling. </p> <p> The <code>gen_statem</code> calls the <code><a href="#state%20callback"><strong>state callback</strong></a></code> with <code><a href="#type-event_type">event_type()</a></code> <code>{call,From}</code> and event content <code>Request</code>. </p> <p> A <code>Reply</code> is generated when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns with <code>{reply,From,Reply}</code> as one <code><a href="#type-action">action()</a></code>, and that <code>Reply</code> becomes the return value of <code><a href="#receive_response-2"> receive_response/1,2</a></code>, <code><a href="#wait_response-2"> wait_response/1,2</a></code>, or <code><a href="#check_response-2"> check_response/2</a></code> function. </p> </div></div></article><article class="func"><h3 id="send_request-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>send_request(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>,
 Request :: <code>term()</code>,
 Label :: <code>term()</code>,
 ReqIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code>) -&gt;
 NewReqIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Sends an asynchronous <code>call</code> request <code>Request</code> to the <code>gen_statem</code> process identified by <code>ServerRef</code>. The <code>Label</code> will be associated with the request identifier of the operation and added to the returned request identifier collection <code>NewReqIdCollection</code>. The collection can later be used in order to get one response corresponding to a request in the collection by passing the collection as argument to <code><a href="#receive_response-3">receive_response/3</a></code>, <code><a href="#wait_response-3">wait_response/3</a></code>, or, <code><a href="#check_response-3">check_response/3</a></code>. </p> <p> The same as calling <code><a href="#reqids_add-3">gen_statem:reqids_add</a></code>(<code><a href="#send_request-2">statem:send_request</a></code><code>(ServerRef, Request), Label, ReqIdCollection)</code>, but calling <code>send_request/4</code> is slightly more efficient. </p> </div></div></article><article class="func"><h3 id="start-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>start(Module :: <code>module()</code>, Args :: <code>term()</code>, Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;
 <code><a href="#type-start_ret">start_ret()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <h3 id="start-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>start(ServerName :: <code><a href="#type-server_name">server_name()</a></code>,
 Module :: <code>module()</code>,
 Args :: <code>term()</code>,
 Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;
 <code><a href="#type-start_ret">start_ret()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Creates a standalone <code>gen_statem</code> process according to OTP design principles (using <code><a href="proc_lib.html">proc_lib</a></code> primitives). As it does not get linked to the calling process, this start function cannot be used by a supervisor to start a child. </p> <p> For a description of arguments and return values, see <code><a href="#start_link-3">start_link/3,4</a></code>. </p> </div></div></article><article class="func"><h3 id="start_link-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>start_link(Module :: <code>module()</code>,
 Args :: <code>term()</code>,
 Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;
 <code><a href="#type-start_ret">start_ret()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <h3 id="start_link-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>start_link(ServerName :: <code><a href="#type-server_name">server_name()</a></code>,
 Module :: <code>module()</code>,
 Args :: <code>term()</code>,
 Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;
 <code><a href="#type-start_ret">start_ret()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Creates a <code>gen_statem</code> process according to OTP design principles (using <code><a href="proc_lib.html">proc_lib</a></code> primitives) that is linked to the calling process. This is essential when the <code>gen_statem</code> must be part of a supervision tree so it gets linked to its supervisor. </p> <p> The <code>gen_statem</code> process calls <code><a href="#Module:init-1">Module:init/1</a></code> to initialize the server. To ensure a synchronized startup procedure, <code>start_link/3,4</code> does not return until <code><a href="#Module:init-1">Module:init/1</a></code> has returned. </p> <p> <code>ServerName</code> specifies the <code><a href="#type-server_name">server_name()</a></code> to register for the <code>gen_statem</code>. If the <code>gen_statem</code> is started with <code>start_link/3</code>, no <code>ServerName</code> is provided and the <code>gen_statem</code> is not registered. </p> <p><code>Module</code> is the name of the callback module.</p> <p> <code>Args</code> is an arbitrary term that is passed as the argument to <code><a href="#Module:init-1">Module:init/1</a></code>. </p> <ul> <li> <p> If option <code><a href="#type-start_opt"> {timeout,Time} </a></code> is present in <code>Opts</code>, the <code>gen_statem</code> is allowed to spend <code>Time</code> milliseconds initializing or it terminates and the start function returns <code><a href="#type-start_ret">{error,timeout}</a></code>. </p> </li> <li> <p>If option <code><a href="#type-enter_loop_opt"> {hibernate_after,HibernateAfterTimeout} </a></code> is present, the <code>gen_statem</code> process awaits any message for <code>HibernateAfterTimeout</code> milliseconds and if no message is received, the process goes into hibernation automatically (by calling <code><a href="proc_lib.html#hibernate-3">proc_lib:hibernate/3</a></code>). </p> </li> <li> <p> If option <code><a href="#type-enter_loop_opt"> {debug,Dbgs} </a></code> is present in <code>Opts</code>, debugging through <code><a href="sys.html">sys</a></code> is activated. </p> </li> <li> <p> If option <code><a href="#type-start_opt"> {spawn_opt,SpawnOpts} </a></code> is present in <code>Opts</code>, <code>SpawnOpts</code> is passed as option list to <code>erlang:spawn_opt/2</code>, which is used to spawn the <code>gen_statem</code> process. </p> </li> </ul> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Using spawn option <code>monitor</code> is not allowed, it causes this function to fail with reason <code>badarg</code>. </p> </div> </div> <p> If the <code>gen_statem</code> is successfully created and initialized, this function returns <code><a href="#type-start_ret">{ok,Pid}</a></code>, where <code>Pid</code> is the <code>pid()</code> of the <code>gen_statem</code>. If a process with the specified <code>ServerName</code> exists already, this function returns <code><a href="#type-start_ret">{error,{already_started,Pid}}</a></code>, where <code>Pid</code> is the <code>pid()</code> of that process. </p> <p> If <code>Module:init/1</code> fails with <code>Reason</code>, this function returns <code><a href="#type-start_ret">{error, Reason}</a></code>. If <code>Module:init/1</code> returns <code><a href="#type-start_ret">{stop, Reason}</a></code>, <code><a href="#type-start_ret">{shutdown, Reason}</a></code> or <code><a href="#type-start_ret">ignore</a></code>, the process is terminated and this function returns <code><a href="#type-start_ret">{error,Reason}</a></code> or <code><a href="#type-start_ret">ignore</a></code>, respectively. An exit signal with the same <code>Reason</code> (or <code>normal</code> if <code>Module:init/1</code> returns <code>ignore</code>) is set to linked processes and ports, including the process calling <code>start_link/3,4</code>. </p> <p>The difference between returning <code>{stop, Reason}</code> and <code>{error, Reason}</code> (from <code>Module:init/1</code>) is that <code>error</code> results in a graceful ("silent") termination. </p> </div></div></article><article class="func"><h3 id="start_monitor-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>start_monitor(Module :: <code>module()</code>,
 Args :: <code>term()</code>,
 Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;
 <code><a href="#type-start_mon_ret">start_mon_ret()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <h3 id="start_monitor-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>start_monitor(ServerName :: <code><a href="#type-server_name">server_name()</a></code>,
 Module :: <code>module()</code>,
 Args :: <code>term()</code>,
 Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;
 <code><a href="#type-start_mon_ret">start_mon_ret()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Creates a standalone <code>gen_statem</code> process according to OTP design principles (using <code><a href="proc_lib.html">proc_lib</a></code> primitives) and atomically sets up a monitor to the newly created process. As it does not get linked to the calling process, this start function cannot be used by a supervisor to start a child. </p> <p> For a description of arguments and return values, see <code><a href="#start_link-3">start_link/3,4</a></code>. Note that the return value on successful start differs from <code>start_link/3,4</code>. <code>start_monitor/3,4</code> will return <code>{ok,{Pid,Mon}}</code> where <code>Pid</code> is the process identifier of the process, and <code>Mon</code> is a reference to the monitor set up to monitor the process. If the start is not successful, the caller will be blocked until the <code>DOWN</code> message has been received and removed from the message queue. </p> </div></div></article><article class="func"><h3 id="stop-1" class="bold_code title-link func-head">  <code>stop(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>) -&gt; ok</code><div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> The same as <code><a href="#stop-3">stop(ServerRef, normal, infinity)</a></code>. </p> </div></div></article><article class="func"><h3 id="stop-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>stop(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>,
 Reason :: <code>term()</code>,
 Timeout :: <code>timeout()</code>) -&gt;
 ok</code></pre>
<div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Orders the <code>gen_statem</code> <code><a href="#type-server_ref">ServerRef</a></code> to exit with the specified <code>Reason</code> and waits for it to terminate. The <code>gen_statem</code> calls <code><a href="#Module:terminate-3">Module:terminate/3</a></code> before exiting. </p> <p> This function returns <code>ok</code> if the server terminates with the expected reason. Any other reason than <code>normal</code>, <code>shutdown</code>, or <code>{shutdown,Term}</code> causes an error report to be issued through <code>logger(3)</code>. An exit signal with the same reason is sent to linked processes and ports. The default <code>Reason</code> is <code>normal</code>. </p> <p> <code>Timeout</code> is an integer &gt; 0, which specifies how many milliseconds to wait for the server to terminate, or the atom <code>infinity</code> to wait indefinitely. Defaults to <code>infinity</code>. If the server does not terminate within the specified time, the call exits the calling process with reason <code>timeout</code>. </p> <p> If the process does not exist, the call exits the calling process with reason <code>noproc</code>, and with reason <code>{nodedown,Node}</code> if the connection fails to the remote <code>Node</code> where the server runs. </p> </div></div></article><article class="func"><h3 id="wait_response-1" class="bold_code title-link func-head">  <code>wait_response(ReqId) -&gt; Result</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ReqId = <a href="#type-request_id">request_id()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Response = 
 {reply, Reply :: term()} |
 {error, {Reason :: term(), <a href="#type-server_ref">server_ref()</a>}}</code></pre></div> <div class="REFTYPES rt-1"><code>Result = Response | timeout</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> The same as calling <code><a href="#receive_response-2">gen_statem:receive_response(ReqId, infinity)</a></code>. </p> </div></div></article><article class="func"><h3 id="wait_response-2" class="bold_code title-link func-head">  <code>wait_response(ReqId, WaitTime) -&gt; Result</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ReqId = <a href="#type-request_id">request_id()</a></code></div> <div class="REFTYPES rt-1"><code>WaitTime = <a href="#type-response_timeout">response_timeout()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Response = 
 {reply, Reply :: term()} |
 {error, {Reason :: term(), <a href="#type-server_ref">server_ref()</a>}}</code></pre></div> <div class="REFTYPES rt-1"><code>Result = Response | timeout</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Wait for a response corresponding to the request identifier <code>ReqId</code>. The request must have been made by <code><a href="#send_request-2">send_request/2</a></code> to the <code>gen_statem</code> process. This function must be called from the same process from which <code><a href="#send_request-2">send_request/2</a></code> was made. </p> <p> <code>WaitTime</code> specifies how long to wait for a reply. If no reply is received within the specified time, the function returns <code>timeout</code> and no cleanup is done, and thus the function can be invoked repeatedly until a reply is returned. </p> <p> The return value <code>Reply</code> is generated when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns with <code>{reply,From,Reply}</code> as one <code><a href="#type-action">action()</a></code>, and that <code>Reply</code> becomes the return value of this function. </p> <p> The function returns an error if the <code>gen_statem</code> dies before or during this function call. </p> <p> The difference between <code><a href="#receive_response-2">receive_response/2</a></code> and <code>wait_response/2</code> is that <code>receive_response/2</code> abandons the request at timeout so that a potential future response is ignored, while <code>wait_response/2</code> does not. </p> </div></div></article><article class="func"><h3 id="wait_response-3" class="bold_code title-link func-head">  <code>wait_response(ReqIdCollection, WaitTime, Delete) -&gt; Result</code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ReqIdCollection = <a href="#type-request_id_collection">request_id_collection()</a></code></div> <div class="REFTYPES rt-1"><code>WaitTime = <a href="#type-response_timeout">response_timeout()</a></code></div> <div class="REFTYPES rt-1"><code>Delete = boolean()</code></div> <div class="REFTYPES rt-1"><pre><code>Response = 
 {reply, Reply :: term()} |
 {error, {Reason :: term(), <a href="#type-server_ref">server_ref()</a>}}</code></pre></div> <div class="REFTYPES rt-1"><pre><code>Result = 
 {Response,
 Label :: term(),
 NewReqIdCollection :: <a href="#type-request_id_collection">request_id_collection()</a>} |
 no_request | timeout</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Wait for a response corresponding to a request identifier saved in <code>ReqIdCollection</code>. All request identifiers of <code>ReqIdCollection</code> must correspond to requests that have been made using <code><a href="#send_request-2">send_request/2</a></code> or <code><a href="#send_request-4">send_request/4</a></code>, and all request must have been made by the process calling this function. </p> <p> The <code>Label</code> in the response equals the <code>Label</code> associated with the request identifier that the response corresponds to. The <code>Label</code> of a request identifier is associated when <code><a href="#reqids_add-3">saving the request id</a></code> in a request identifier collection, or when sending the request using <code><a href="#send_request-4">send_request/4</a></code>. </p> <p> Compared to <code><a href="#wait_response-2">wait_response/2</a></code>, the returned result associated with a specific request identifier or an exception associated with a specific request identifier will be wrapped in a 3-tuple. The first element of this tuple equals the value that would have been produced by <code>wait_response/2</code>, the second element equals the <code>Label</code> associated with the specific request identifier, and the third element <code>NewReqIdCollection</code> is a possibly modified request identifier collection. </p> <p> If <code>ReqIdCollection</code> is empty, <code>no_request</code> will be returned. If no response is received before the <code>WaitTime</code> timeout has triggered, the atom <code>timeout</code> is returned. It is valid to continue waiting for a response as many times as needed up until a response has been received and completed by <code>check_response()</code>, <code>receive_response()</code>, or <code>wait_response()</code>. </p> <p> The difference between <code><a href="#receive_response-3">receive_response/3</a></code> and <code>wait_response/3</code> is that <code>receive_response/3</code> abandons requests at timeout so that a potential future responses are ignored, while <code>wait_response/3</code> does not. </p> <p> If <code>Delete</code> equals <code>true</code>, the association with <code>Label</code> will have been deleted from <code>ReqIdCollection</code> in the resulting <code>NewReqIdCollection</code>. If <code>Delete</code> equals <code>false</code>, <code>NewReqIdCollection</code> will equal <code>ReqIdCollection</code>. Note that deleting an association is not for free and that a collection containing already handled requests can still be used by subsequent calls to <code>wait_response/3</code>, <code><a href="#check_response-3">check_response/3</a></code>, and <code><a href="#receive_response-3">receive_response/3</a></code>. However, without deleting handled associations, the above calls will not be able to detect when there are no more outstanding requests to handle, so you will have to keep track of this some other way than relying on a <code>no_request</code> return. Note that if you pass a collection only containing associations of already handled or abandoned requests to <code>wait_response/3</code>, it will always block until a timeout determined by <code>WaitTime</code> is triggered and then return <code>no_reply</code>. </p> </div></div></article> </div> <section class="innertube"><h2 id="callback-functions" class="title-link"> <div class="title-name">Callback Functions</div>  </h2> <div class="REFBODY rb-3"> <p> The following functions are to be exported from a <code>gen_statem</code> callback module. </p> </div></section><div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><div class="bold_code func-head"><h3 id="Module:callback_mode-0" class="title-link">  <div class="title-name">Module:callback_mode() -&gt; CallbackMode</div> <div class="title-since"><span class="since">OTP 19.1</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>CallbackMode = <a href="#type-callback_mode">callback_mode()</a> | [ <a href="#type-callback_mode">callback_mode()</a> | <a href="#type-state_enter">state_enter()</a> ]</code><br> </div> </div> <div class="REFBODY rb-7"> <p> This function is called by a <code>gen_statem</code> when it needs to find out the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> of the callback module. The value is cached by <code>gen_statem</code> for efficiency reasons, so this function is only called once after server start, after code change, and after changing the callback module, but before the first <code><a href="#state%20callback"><strong>state callback</strong></a></code> in the current callback module's code version is called. More occasions may be added in future versions of <code>gen_statem</code>. </p> <p> Server start happens either when <code><a href="#Module:init-1">Module:init/1</a></code> returns or when <code><a href="#enter_loop-4">enter_loop/4-6</a></code> is called. Code change happens when <code><a href="#Module:code_change-4">Module:code_change/4</a></code> returns. A change of the callback module happens when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns any of the actions <code><a href="#type-action">change_callback_module</a></code>, <code><a href="#type-action">push_callback_module</a></code> or <code><a href="#type-action">pop_callback_module</a></code>. </p> <p> The <code>CallbackMode</code> is either just <code><a href="#type-callback_mode">callback_mode()</a></code> or a list containing <code><a href="#type-callback_mode">callback_mode()</a></code> and possibly the atom <code><a href="#type-state_enter">state_enter</a></code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> If this function's body does not return an inline constant value the callback module is doing something strange. </p> </div> </div> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="Module:code_change-4" class="title-link">  <div class="title-name">Module:code_change(OldVsn, OldState, OldData, Extra) -&gt; Result </div> <div class="title-since"><span class="since">OTP 19.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>OldVsn = Vsn | {down,Vsn}</code><br> </div> <div class="REFTYPES rt-4"> <code>Vsn = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>OldState = NewState = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>Extra = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>Result = {ok,NewState,NewData} | Reason</code><br> </div> <div class="REFTYPES rt-4"> <code>OldState = NewState = <a href="#type-state">state()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>OldData = NewData = <a href="#type-data">data()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Reason = term()</code><br> </div> </div> <div class="REFBODY rb-7"> <div class="note"> <div class="label">Note</div> <div class="content">

<p> This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with <code>Change = {advanced,Extra}</code> specified in the <code>.appup</code> file is made when <code>code_change/4</code> is not implemented the process will crash with exit reason <code>undef</code>. </p> </div> </div> <p> This function is called by a <code>gen_statem</code> when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction <code>{update,Module,Change,...}</code>, where <code>Change = {advanced,Extra}</code>, is specified in the <code>appup</code> file. For more information, see <code>OTP Design Principles</code>. </p> <p> For an upgrade, <code>OldVsn</code> is <code>Vsn</code>, and for a downgrade, <code>OldVsn</code> is <code>{down,Vsn}</code>. <code>Vsn</code> is defined by the <code>vsn</code> attribute(s) of the old version of the callback module <code>Module</code>. If no such attribute is defined, the version is the checksum of the Beam file. </p> <p> <code>OldState</code> and <code>OldData</code> is the internal state of the <code>gen_statem</code>. </p> <p> <code>Extra</code> is passed "as is" from the <code>{advanced,Extra}</code> part of the update instruction. </p> <p> If successful, the function must return the updated internal state in an <code>{ok,NewState,NewData}</code> tuple. </p> <p> If the function returns a failure <code>Reason</code>, the ongoing upgrade fails and rolls back to the old release. Note that <code>Reason</code> cannot be an <code>{ok,_,_}</code> tuple since that will be regarded as a <code>{ok,NewState,NewData}</code> tuple, and that a tuple matching <code>{ok,_}</code> is an also invalid failure <code>Reason</code>. It is recommended to use an atom as <code>Reason</code> since it will be wrapped in an <code>{error,Reason}</code> tuple. </p> <p> Also note when upgrading a <code>gen_statem</code>, this function and hence the <code>Change = {advanced,Extra}</code> parameter in the <code>appup</code> file is not only needed to update the internal state or to act on the <code>Extra</code> argument. It is also needed if an upgrade or downgrade should change <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code>, or else the <strong>callback mode</strong> after the code change will not be honoured, most probably causing a server crash. </p> <p> If the server changes callback module using any of the actions <code><a href="#type-action">change_callback_module</a></code>, <code><a href="#type-action">push_callback_module</a></code> or <code><a href="#type-action">pop_callback_module</a></code>, be aware that it is always the current callback module that will get this callback call. That the current callback module handles the current state and data update should be no surprise, but it must be able to handle even parts of the state and data that it is not familiar with, somehow. </p> <p> In the supervisor <code>child specification</code> there is a list of modules which is recommended to contain only the callback module. For a <code>gen_statem</code> with multiple callback modules there is no real need to list all of them, it may not even be possible since the list could change after code upgrade. If this list would contain only the start callback module, as recommended, what is important is to upgrade <strong>that</strong> module whenever a <strong>synchronized code replacement</strong> is done. Then the release handler concludes that an upgrade that upgrades <strong>that</strong> module needs to suspend, code change, and resume any server whose child specification declares that it is using <strong>that</strong> module. And again; the <strong>current</strong> callback module will get the <code>Module:code_change/4</code> call. </p> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="Module:init-1" class="title-link">  <div class="title-name">Module:init(Args) -&gt; Result(StateType)</div> <div class="title-since"><span class="since">OTP 19.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Args = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>Result(StateType) = <a href="#type-init_result">init_result(StateType)</a></code><br> </div> </div> <div class="REFBODY rb-7">  <p id="Module:init-1"> Whenever a <code>gen_statem</code> is started using <code><a href="#start_link-3">start_link/3,4</a></code>, <code><a href="#start_monitor-3">start_monitor/3,4</a></code>, or <code><a href="#start-3">start/3,4</a></code>, this function is called by the new process to initialize the implementation state and server data. </p> <p> <code>Args</code> is the <code>Args</code> argument provided to that start function. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Note that if the <code>gen_statem</code> is started through <code><a href="proc_lib.html">proc_lib</a></code> and <code><a href="#enter_loop-4">enter_loop/4-6</a></code>, this callback will never be called. Since this callback is not optional it can in that case be implemented as: </p> <pre data-language="erlang">
-spec init(_) -&gt; no_return().
init(Args) -&gt; erlang:error(not_implemented, [Args]).</pre> </div> </div> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="Module:format_status-1" class="title-link">  <div class="title-name">Module:format_status(Status) -&gt; NewStatus</div> <div class="title-since"><span class="since">OTP 25.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Status = <a href="#type-format_status">format_status()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>NewStatus = <a href="#type-format_status">format_status()</a></code><br> </div> </div> <div class="REFBODY rb-7"> <div class="note"> <div class="label">Note</div> <div class="content">

<p> This callback is optional, so a callback module does not need to export it. The <code>gen_statem</code> module provides a default implementation of this function that returns <code>{State,Data}</code>. </p> <p> If this callback is exported but fails, to hide possibly sensitive data, the default function will instead return <code>{State,Info}</code>, where <code>Info</code> says nothing but the fact that <code>format_status/2</code> has crashed. </p> </div> </div> <p>This function is called by a <code>gen_statem</code> process when any of the following apply:</p> <ul> <li> <p><code><a href="sys.html#get_status-1">sys:get_status/1,2</a></code> is invoked to get the <code>gen_statem</code> status.</p> </li> <li> <p>The <code>gen_statem</code> process terminates abnormally and logs an error.</p> </li> </ul> <p> This function is useful for changing the form and appearance of the <code>gen_statem</code> status for these cases. A callback module wishing to change the <code><a href="sys.html#get_status-1">sys:get_status/1,2</a></code> return value and how its status appears in termination error logs exports an instance of <code>format_status/1</code>, which will get a map <code>Status</code> that describes the current states of the <code>gen_statem</code>, and shall return a map <code>NewStatus</code> containing the same keys as the input map, but it may transform some values. </p> <p> One use case for this function is to return compact alternative state representations to avoid having large state terms printed in log files. Another is to hide sensitive data from being written to the error log. </p> <p>Example:</p> <pre data-language="erlang">format_status(Status) -&gt;
  maps:map(
    fun(state,State) -&gt;
            maps:remove(private_key, State);
       (message,{password, _Pass}) -&gt;
            {password, removed};
       (_,Value) -&gt;
            Value
    end, Status).</pre> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="Module:format_status-2" class="title-link">  <div class="title-name">Module:format_status(Opt, [PDict,State,Data]) -&gt; Status </div> <div class="title-since"><span class="since">OTP 19.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Opt = normal | terminate</code><br> </div> <div class="REFTYPES rt-4"> <code>PDict = [{Key, Value}]</code><br> </div> <div class="REFTYPES rt-4"> <code>State = <a href="#type-state">state()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Data = <a href="#type-data">data()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Key = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>Value = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>Status = term()</code><br> </div> </div> <div class="REFBODY rb-7"> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This callback is deprecated, in new code use <code><a href="#Module:format_status-1"> format_status/1</a></code>. If a <code><a href="#Module:format_status-1">format_status/1</a></code> callback exists, then this function will never be called.</p> </div> </div> <div class="note"> <div class="label">Note</div> <div class="content">

<p> This callback is optional, so a callback module does not need to export it. The <code>gen_statem</code> module provides a default implementation of this function that returns <code>{State,Data}</code>. </p> <p> If this callback is exported but fails, to hide possibly sensitive data, the default function will instead return <code>{State,Info}</code>, where <code>Info</code> says nothing but the fact that <code>format_status/2</code> has crashed. </p> </div> </div> <p>This function is called by a <code>gen_statem</code> process when any of the following apply:</p> <ul> <li> One of <code><a href="sys.html#get_status-1">sys:get_status/1,2</a></code> is invoked to get the <code>gen_statem</code> status. <code>Opt</code> is set to the atom <code>normal</code> for this case. </li> <li> The <code>gen_statem</code> terminates abnormally and logs an error. <code>Opt</code> is set to the atom <code>terminate</code> for this case. </li> </ul> <p> This function is useful for changing the form and appearance of the <code>gen_statem</code> status for these cases. A callback module wishing to change the <code><a href="sys.html#get_status-1">sys:get_status/1,2</a></code> return value and how its status appears in termination error logs exports an instance of <code>format_status/2</code>, which returns a term describing the current status of the <code>gen_statem</code>. </p> <p> <code>PDict</code> is the current value of the process dictionary of the <code>gen_statem</code>. </p> <p> <code><a href="#type-state">State</a></code> is the internal state of the <code>gen_statem</code>. </p> <p> <code><a href="#type-data">Data</a></code> is the internal server data of the <code>gen_statem</code>. </p> <p> The function is to return <code>Status</code>, a term that contains the appropriate details of the current state and status of the <code>gen_statem</code>. There are no restrictions on the form <code>Status</code> can take, but for the <code><a href="sys.html#get_status-1">sys:get_status/1,2</a></code> case (when <code>Opt</code> is <code>normal</code>), the recommended form for the <code>Status</code> value is <code>[{data, [{"State", Term}]}]</code>, where <code>Term</code> provides relevant details of the <code>gen_statem</code> state. Following this recommendation is not required, but it makes the callback module status consistent with the rest of the <code><a href="sys.html#get_status-1">sys:get_status/1,2</a></code> return value. </p> <p> One use for this function is to return compact alternative state representations to avoid having large state terms printed in log files. Another use is to hide sensitive data from being written to the error log. </p> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="Module:StateName-3" class="title-link">  <div class="title-name">Module:StateName(enter, OldState, Data) -&gt; StateEnterResult(StateName) </div> <div class="title-since"><span class="since">OTP 19.0</span></div> </h3></div> <div class="bold_code func-head"><h3 id="Module:StateName-3" class="title-link">  <div class="title-name">Module:StateName(EventType, EventContent, Data) -&gt; StateFunctionResult </div> <div class="title-since"><span class="since">OTP 19.0</span></div> </h3></div> <div class="bold_code func-head"><h3 id="Module:handle_event-4" class="title-link">  <div class="title-name">Module:handle_event(enter, OldState, State, Data) -&gt; StateEnterResult(State) </div> <div class="title-since"><span class="since">OTP 19.0</span></div> </h3></div> <div class="bold_code func-head"><h3 id="Module:handle_event-4" class="title-link">  <div class="title-name">Module:handle_event(EventType, EventContent, State, Data) -&gt; HandleEventResult </div> <div class="title-since"><span class="since">OTP 19.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>EventType = <a href="#type-event_type">event_type()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>EventContent = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>State = <a href="#type-state">state()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Data = NewData = <a href="#type-data">data()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>StateEnterResult(StateName) = <a href="#type-state_enter_result">state_enter_result(StateName)</a></code><br> </div> <div class="REFTYPES rt-4"> <code>StateFunctionResult = <a href="#type-event_handler_result">event_handler_result</a>(<a href="#type-state_name">state_name()</a>)</code><br> </div> <div class="REFTYPES rt-4"> <code>StateEnterResult(State) = <a href="#type-state_enter_result">state_enter_result(State)</a></code><br> </div> <div class="REFTYPES rt-4"> <code>HandleEventResult = <a href="#type-event_handler_result">event_handler_result</a>(<a href="#type-state">state()</a>)</code><br> </div> </div> <div class="REFBODY rb-7"> <p> Whenever a <code>gen_statem</code> receives an event from <code><a href="#call-2">call/2</a></code>, <code><a href="#cast-2">cast/2</a></code>, or as a normal process message, one of these functions is called. If <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code>state_functions</code>, <code>Module:StateName/3</code> is called, and if it is <code>handle_event_function</code>, <code>Module:handle_event/4</code> is called. </p> <p> If <code>EventType</code> is <code><a href="#type-event_type">{call,From}</a></code>, the caller waits for a reply. The reply can be sent from this or from any other <code><a href="#state%20callback"><strong>state callback</strong></a></code> by returning with <code>{reply,From,Reply}</code> in <code><a href="#type-action">Actions</a></code>, in <code><a href="#type-reply_action">Replies</a></code>, or by calling <code><a href="#reply-2">reply(From, Reply)</a></code>. </p> <p> If this function returns with a next state that does not match equal (<code>=/=</code>) to the current state, all postponed events are retried in the next state. </p> <p> The only difference between <code>StateFunctionResult</code> and <code>HandleEventResult</code> is that for <code>StateFunctionResult</code> the next state must be an atom, but for <code>HandleEventResult</code> there is no restriction on the next state. </p> <p> For options that can be set and actions that can be done by <code>gen_statem</code> after returning from this function, see <code><a href="#type-action">action()</a></code>. </p> <p> When the <code>gen_statem</code> runs with <code><a href="#type-state_enter"><strong>state enter calls</strong></a></code>, these functions are also called with arguments <code>(enter, OldState, ...)</code> during every <strong>state change</strong>. In this case there are some restrictions on the <code><a href="#type-enter_action">actions</a></code> that may be returned: <code><a href="#type-postpone">postpone()</a></code> is not allowed since a <strong>state enter call</strong> is not an event so there is no event to postpone, and <code><a href="#type-action">{next_event,_,_}</a></code> is not allowed since using <strong>state enter calls</strong> should not affect how events are consumed and produced. You may also not change states from this call. Should you return <code>{next_state,NextState, ...}</code> with <code>NextState =/= State</code> the <code>gen_statem</code> crashes. Note that it is actually allowed to use <code>{repeat_state, NewData, ...}</code> although it makes little sense since you immediately will be called again with a new <strong>state enter call</strong> making this just a weird way of looping, and there are better ways to loop in Erlang. If you do not update <code>NewData</code> and have some loop termination condition, or if you use <code>{repeat_state_and_data, _}</code> or <code>repeat_state_and_data</code> you have an infinite loop! You are advised to use <code>{keep_state,...}</code>, <code>{keep_state_and_data,_}</code> or <code>keep_state_and_data</code> since changing states from a <strong>state enter call</strong> is not possible anyway. </p> <p> Note the fact that you can use <code>throw</code> to return the result, which can be useful. For example to bail out with <code>throw(keep_state_and_data)</code> from deep within complex code that cannot return <code>{next_state,State,Data}</code> because <code>State</code> or <code>Data</code> is no longer in scope. </p> </div> </div></article><article class="func"><div class="bold_code func-head"><h3 id="Module:terminate-3" class="title-link">  <div class="title-name">Module:terminate(Reason, State, Data) -&gt; Ignored</div> <div class="title-since"><span class="since">OTP 19.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Reason = normal | shutdown | {shutdown,term()} | term()</code><br> </div> <div class="REFTYPES rt-4"> <code>State = <a href="#type-state">state()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Data = <a href="#type-data">data()</a></code><br> </div> <div class="REFTYPES rt-4"> <code>Ignored = term()</code><br> </div> </div> <div class="REFBODY rb-7"> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This callback is optional, so callback modules need not export it. The <code>gen_statem</code> module provides a default implementation without cleanup.</p> </div> </div> <p> This function is called by a <code>gen_statem</code> when it is about to terminate. It is to be the opposite of <code><a href="#Module:init-1">Module:init/1</a></code> and do any necessary cleaning up. When it returns, the <code>gen_statem</code> terminates with <code>Reason</code>. The return value is ignored.</p> <p> <code>Reason</code> is a term denoting the stop reason and <code><a href="#type-state">State</a></code> is the internal state of the <code>gen_statem</code>. </p> <p> <code>Reason</code> depends on why the <code>gen_statem</code> is terminating. If it is because another callback function has returned, a stop tuple <code>{stop,Reason}</code> in <code><a href="#type-action">Actions</a></code>, <code>Reason</code> has the value specified in that tuple. If it is because of a failure, <code>Reason</code> is the error reason. </p> <p> If the <code>gen_statem</code> is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with <code>Reason = shutdown</code> if both the following conditions apply:</p> <ul> <li> <p> The <code>gen_statem</code> has been set to trap exit signals. </p> </li> <li> <p> The shutdown strategy as defined in the supervisor's child specification is an integer time-out value, not <code>brutal_kill</code>. </p> </li> </ul> <p> Even if the <code>gen_statem</code> is <strong>not</strong> part of a supervision tree, this function is called if it receives an <code>'EXIT'</code> message from its parent. <code>Reason</code> is the same as in the <code>'EXIT'</code> message. </p> <p> Otherwise, the <code>gen_statem</code> is immediately terminated. </p> <p> Notice that for any other reason than <code>normal</code>, <code>shutdown</code>, or <code>{shutdown,Term}</code>, the <code>gen_statem</code> is assumed to terminate because of an error and an error report is issued using <code>logger(3)</code>. </p> <p> When the <code>gen_statem</code> process exits, an exit signal with the same reason is sent to linked processes and ports. </p> </div> </div></article> </div> <section class="innertube"><h2 id="see-also" class="title-link"> <div class="title-name">See Also</div>  </h2> <div class="REFBODY rb-3"> <p> <code><a href="gen_event.html">gen_event(3)</a></code>, <code><a href="gen_fsm.html">gen_fsm(3)</a></code>, <code><a href="gen_server.html">gen_server(3)</a></code>, <code><a href="proc_lib.html">proc_lib(3)</a></code>, <code><a href="supervisor.html">supervisor(3)</a></code>, <code><a href="sys.html">sys(3)</a></code>. </p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
