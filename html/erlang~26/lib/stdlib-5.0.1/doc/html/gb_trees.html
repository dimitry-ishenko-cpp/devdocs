  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">gb_trees</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">General balanced trees.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module provides Prof. Arne Andersson's General Balanced Trees. These have no storage overhead compared to unbalanced binary trees, and their performance is better than AVL trees.</p> <p>This module considers two keys as different if and only if they do not compare equal (<code>==</code>).</p> </div> </div></section> <section class="innertube"><h2 id="data-structure" class="title-link"> <div class="title-name">Data Structure</div>  </h2> <div class="REFBODY rb-3"> <p>Trees and iterators are built using opaque data structures that should not be pattern-matched from outside this module.</p> <p>There is no attempt to balance trees after deletions. As deletions do not increase the height of a tree, this should be OK.</p> <p>The original balance condition <strong>h(T) &lt;= ceil(c * log(|T|))</strong> has been changed to the similar (but not quite equivalent) condition <strong>2 ^ h(T) &lt;= |T| ^ c</strong>. This should also be OK.</p> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-tree" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-tree">tree(Key, Value)</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>A general balanced tree.</p></div></div></article> <article class="data-types-body"><h3 id="type-tree" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-tree">tree()</a> = <a href="#type-tree">tree</a>(term(), term())</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-iter" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-iter">iter(Key, Value)</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>A general balanced tree iterator.</p></div></div></article> <article class="data-types-body"><h3 id="type-iter" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-iter">iter()</a> = <a href="#type-iter">iter</a>(term(), term())</code><br> </div> </h3> </article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="balance-1" class="bold_code title-link func-head">  <code>balance(Tree1) -&gt; Tree2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree1 = Tree2 = <a href="#type-tree">tree</a>(Key, Value)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Rebalances <code>Tree1</code>. Notice that this is rarely necessary, but can be motivated when many nodes have been deleted from the tree without further insertions. Rebalancing can then be forced to minimize lookup times, as deletion does not rebalance the tree.</p> </div></div></article><article class="func"><h3 id="delete-2" class="bold_code title-link func-head">  <code>delete(Key, Tree1) -&gt; Tree2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree1 = Tree2 = <a href="#type-tree">tree</a>(Key, Value)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Removes the node with key <code>Key</code> from <code>Tree1</code> and returns the new tree. Assumes that the key is present in the tree, crashes otherwise.</p> </div></div></article><article class="func"><h3 id="delete_any-2" class="bold_code title-link func-head">  <code>delete_any(Key, Tree1) -&gt; Tree2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree1 = Tree2 = <a href="#type-tree">tree</a>(Key, Value)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Removes the node with key <code>Key</code> from <code>Tree1</code> if the key is present in the tree, otherwise does nothing. Returns the new tree.</p> </div></div></article><article class="func"><h3 id="take-2" class="bold_code title-link func-head">  <code>take(Key, Tree1) -&gt; {Value, Tree2}</code><div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree1 = Tree2 = <a href="#type-tree">tree</a>(Key, term())</code></div>  <div class="REFTYPES rt-1"><code>Key = Value = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a value <code>Value</code> from node with key <code>Key</code> and new <code>Tree2</code> without the node with this value. Assumes that the node with key is present in the tree, crashes otherwise.</p> </div></div></article><article class="func"><h3 id="take_any-2" class="bold_code title-link func-head">  <code>take_any(Key, Tree1) -&gt; {Value, Tree2} | error</code><div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree1 = Tree2 = <a href="#type-tree">tree</a>(Key, term())</code></div>  <div class="REFTYPES rt-1"><code>Key = Value = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a value <code>Value</code> from node with key <code>Key</code> and new <code>Tree2</code> without the node with this value. Returns <code>error</code> if the node with the key is not present in the tree.</p> </div></div></article><article class="func"><h3 id="empty-0" class="bold_code title-link func-head">  <code>empty() -&gt; <code><a href="#type-tree">tree</a></code>(<code>none()</code>, <code>none()</code>)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new empty tree.</p> </div></div></article><article class="func"><h3 id="enter-3" class="bold_code title-link func-head">  <code>enter(Key, Value, Tree1) -&gt; Tree2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree1 = Tree2 = <a href="#type-tree">tree</a>(Key, Value)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Inserts <code>Key</code> with value <code>Value</code> into <code>Tree1</code> if the key is not present in the tree, otherwise updates <code>Key</code> to value <code>Value</code> in <code>Tree1</code>. Returns the new tree.</p> </div></div></article><article class="func"><h3 id="from_orddict-1" class="bold_code title-link func-head">  <code>from_orddict(List) -&gt; Tree</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List = [{Key, Value}]</code></div> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree</a>(Key, Value)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Turns an ordered list <code>List</code> of key-value tuples into a tree. The list must not contain duplicate keys.</p> </div></div></article><article class="func"><h3 id="get-2" class="bold_code title-link func-head">  <code>get(Key, Tree) -&gt; Value</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree</a>(Key, Value)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Retrieves the value stored with <code>Key</code> in <code>Tree</code>. Assumes that the key is present in the tree, crashes otherwise.</p> </div></div></article><article class="func"><h3 id="insert-3" class="bold_code title-link func-head">  <code>insert(Key, Value, Tree1) -&gt; Tree2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree1 = Tree2 = <a href="#type-tree">tree</a>(Key, Value)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Inserts <code>Key</code> with value <code>Value</code> into <code>Tree1</code> and returns the new tree. Assumes that the key is not present in the tree, crashes otherwise.</p> </div></div></article><article class="func"><h3 id="is_defined-2" class="bold_code title-link func-head">  <code>is_defined(Key, Tree) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree</a>(Key, Value :: term())</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Key</code> is present in <code>Tree</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="is_empty-1" class="bold_code title-link func-head">  <code>is_empty(Tree) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Tree</code> is an empty tree, othwewise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="iterator-1" class="bold_code title-link func-head">  <code>iterator(Tree) -&gt; Iter</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree</a>(Key, Value)</code></div> <div class="REFTYPES rt-1"><code>Iter = <a href="#type-iter">iter</a>(Key, Value)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns an iterator that can be used for traversing the entries of <code>Tree</code>; see <code><a href="#next-1">next/1</a></code>. The implementation of this is very efficient; traversing the whole tree using <code>next/1</code> is only slightly slower than getting the list of all elements using <code><a href="#to_list-1">to_list/1</a></code> and traversing that. The main advantage of the iterator approach is that it does not require the complete list of all elements to be built in memory at one time.</p> </div></div></article><article class="func"><h3 id="iterator_from-2" class="bold_code title-link func-head">  <code>iterator_from(Key, Tree) -&gt; Iter</code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree</a>(Key, Value)</code></div> <div class="REFTYPES rt-1"><code>Iter = <a href="#type-iter">iter</a>(Key, Value)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns an iterator that can be used for traversing the entries of <code>Tree</code>; see <code><a href="#next-1">next/1</a></code>. The difference as compared to the iterator returned by <code><a href="#iterator-1">iterator/1</a></code> is that the first key greater than or equal to <code>Key</code> is returned.</p> </div></div></article><article class="func"><h3 id="keys-1" class="bold_code title-link func-head">  <code>keys(Tree) -&gt; [Key]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree</a>(Key, Value :: term())</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the keys in <code>Tree</code> as an ordered list.</p> </div></div></article><article class="func"><h3 id="largest-1" class="bold_code title-link func-head">  <code>largest(Tree) -&gt; {Key, Value}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree</a>(Key, Value)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>{Key, Value}</code>, where <code>Key</code> is the largest key in <code>Tree</code>, and <code>Value</code> is the value associated with this key. Assumes that the tree is not empty.</p> </div></div></article><article class="func"><h3 id="lookup-2" class="bold_code title-link func-head">  <code>lookup(Key, Tree) -&gt; none | {value, Value}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree</a>(Key, Value)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Looks up <code>Key</code> in <code>Tree</code>. Returns <code>{value, Value}</code>, or <code>none</code> if <code>Key</code> is not present.</p> </div></div></article><article class="func"><h3 id="map-2" class="bold_code title-link func-head">  <code>map(Function, Tree1) -&gt; Tree2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Function = fun((K :: Key, V1 :: Value1) -&gt; V2 :: Value2)</code></div> <div class="REFTYPES rt-1"><code>Tree1 = <a href="#type-tree">tree</a>(Key, Value1)</code></div> <div class="REFTYPES rt-1"><code>Tree2 = <a href="#type-tree">tree</a>(Key, Value2)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Maps function F(K, V1) -&gt; V2 to all key-value pairs of tree <code>Tree1</code>. Returns a new tree <code>Tree2</code> with the same set of keys as <code>Tree1</code> and the new set of values <code>V2</code>.</p> </div></div></article><article class="func"><h3 id="next-1" class="bold_code title-link func-head">  <code>next(Iter1) -&gt; none | {Key, Value, Iter2}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Iter1 = Iter2 = <a href="#type-iter">iter</a>(Key, Value)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>{Key, Value, Iter2}</code>, where <code>Key</code> is the smallest key referred to by iterator <code>Iter1</code>, and <code>Iter2</code> is the new iterator to be used for traversing the remaining nodes, or the atom <code>none</code> if no nodes remain.</p> </div></div></article><article class="func"><h3 id="size-1" class="bold_code title-link func-head">  <code>size(Tree) -&gt; <code>integer() &gt;= 0</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the number of nodes in <code>Tree</code>.</p> </div></div></article><article class="func"><h3 id="smallest-1" class="bold_code title-link func-head">  <code>smallest(Tree) -&gt; {Key, Value}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree</a>(Key, Value)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>{Key, Value}</code>, where <code>Key</code> is the smallest key in <code>Tree</code>, and <code>Value</code> is the value associated with this key. Assumes that the tree is not empty.</p> </div></div></article><article class="func"><h3 id="take_largest-1" class="bold_code title-link func-head">  <code>take_largest(Tree1) -&gt; {Key, Value, Tree2}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree1 = Tree2 = <a href="#type-tree">tree</a>(Key, Value)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>{Key, Value, Tree2}</code>, where <code>Key</code> is the largest key in <code>Tree1</code>, <code>Value</code> is the value associated with this key, and <code>Tree2</code> is this tree with the corresponding node deleted. Assumes that the tree is not empty.</p> </div></div></article><article class="func"><h3 id="take_smallest-1" class="bold_code title-link func-head">  <code>take_smallest(Tree1) -&gt; {Key, Value, Tree2}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree1 = Tree2 = <a href="#type-tree">tree</a>(Key, Value)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>{Key, Value, Tree2}</code>, where <code>Key</code> is the smallest key in <code>Tree1</code>, <code>Value</code> is the value associated with this key, and <code>Tree2</code> is this tree with the corresponding node deleted. Assumes that the tree is not empty.</p> </div></div></article><article class="func"><h3 id="to_list-1" class="bold_code title-link func-head">  <code>to_list(Tree) -&gt; [{Key, Value}]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree</a>(Key, Value)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Converts a tree into an ordered list of key-value tuples.</p> </div></div></article><article class="func"><h3 id="update-3" class="bold_code title-link func-head">  <code>update(Key, Value, Tree1) -&gt; Tree2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree1 = Tree2 = <a href="#type-tree">tree</a>(Key, Value)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Updates <code>Key</code> to value <code>Value</code> in <code>Tree1</code> and returns the new tree. Assumes that the key is present in the tree.</p> </div></div></article><article class="func"><h3 id="values-1" class="bold_code title-link func-head">  <code>values(Tree) -&gt; [Value]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Tree = <a href="#type-tree">tree</a>(Key :: term(), Value)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the values in <code>Tree</code> as an ordered list, sorted by their corresponding keys. Duplicates are not removed.</p> </div></div></article> </div> <section class="innertube"><h2 id="see-also" class="title-link"> <div class="title-name">See Also</div>  </h2> <div class="REFBODY rb-3"> <p><code><a href="dict.html">dict(3)</a></code>, <code><a href="gb_sets.html">gb_sets(3)</a></code></p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
