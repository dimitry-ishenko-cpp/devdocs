  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">rand</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Pseudo random number generation.</div> <h2 id="since" class="title-link"> <div class="title-name">Since</div>  </h2> <div class="REFBODY module-since"> Module rand was introduced in OTP 18.0. </div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p> This module provides a pseudo random number generator. The module contains a number of algorithms. The uniform distribution algorithms are based on the <code><a href="http://xorshift.di.unimi.it"> Xoroshiro and Xorshift algorithms </a></code> by Sebastiano Vigna. The normal distribution algorithm uses the <code><a href="http://www.jstatsoft.org/v05/i08"> Ziggurat Method by Marsaglia and Tsang </a></code> on top of the uniform distribution algorithm. </p> <p> For most algorithms, jump functions are provided for generating non-overlapping sequences for parallel computations. The jump functions perform calculations equivalent to perform a large number of repeated calls for calculating new states, but execute in a time roughly equivalent to one regular iteration per generator bit. </p> <p> At the end of this module documentation there are also some <code><a href="#niche_algorithms"> niche algorithms </a></code> to be used without this module's normal <code><a href="#plug_in_api"> plug-in framework API </a></code> that may be useful for special purposes like short generation time when quality is not essential, for seeding other generators, and such. </p> <h3 id="algorithms">  The following algorithms are provided: </h3> <dl> <dt class="title-link"> <strong><code>exsss</code></strong><div class="title-since since">OTP 22.0</div> </dt> <dd> <p>Xorshift116**, 58 bits precision and period of 2^116-1</p> <p>Jump function: equivalent to 2^64 calls</p> <p> This is the Xorshift116 generator combined with the StarStar scrambler from the 2018 paper by David Blackman and Sebastiano Vigna: <code><a href="http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf"> Scrambled Linear Pseudorandom Number Generators </a></code> </p> <p> The generator does not need 58-bit rotates so it is faster than the Xoroshiro116 generator, and when combined with the StarStar scrambler it does not have any weak low bits like <code>exrop</code> (Xoroshiro116+). </p> <p> Alas, this combination is about 10% slower than <code>exrop</code>, but is despite that the <code><a href="#default-algorithm"> <strong>default algorithm</strong> </a></code> thanks to its statistical qualities. </p> </dd> <dt class="title-link"> <strong><code>exro928ss</code></strong><div class="title-since since">OTP 22.0</div> </dt> <dd> <p>Xoroshiro928**, 58 bits precision and a period of 2^928-1</p> <p>Jump function: equivalent to 2^512 calls</p> <p> This is a 58 bit version of Xoroshiro1024**, from the 2018 paper by David Blackman and Sebastiano Vigna: <code><a href="http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf"> Scrambled Linear Pseudorandom Number Generators </a></code> that on a 64 bit Erlang system executes only about 40% slower than the <code><a href="#default-algorithm"> <strong>default</strong> exsss <strong>algorithm</strong> </a></code> but with much longer period and better statistical properties, but on the flip side a larger state. </p> <p> Many thanks to Sebastiano Vigna for his help with the 58 bit adaption. </p> </dd> <dt class="title-link"> <strong><code>exrop</code></strong><div class="title-since since">OTP 20.0</div> </dt> <dd> <p>Xoroshiro116+, 58 bits precision and period of 2^116-1</p> <p>Jump function: equivalent to 2^64 calls</p> </dd> <dt class="title-link"> <strong><code>exs1024s</code></strong><div class="title-since since">OTP 20.0</div> </dt> <dd> <p>Xorshift1024*, 64 bits precision and a period of 2^1024-1</p> <p>Jump function: equivalent to 2^512 calls</p> </dd> <dt class="title-link"> <strong><code>exsp</code></strong><div class="title-since since">OTP 20.0</div> </dt> <dd> <p>Xorshift116+, 58 bits precision and period of 2^116-1</p> <p>Jump function: equivalent to 2^64 calls</p> <p> This is a corrected version of the previous <code><a href="#default-algorithm"> <strong>default algorithm</strong>, </a></code> that now has been superseded by Xoroshiro116+ (<code>exrop</code>). Since there is no native 58 bit rotate instruction this algorithm executes a little (say &lt; 15%) faster than <code>exrop</code>. See the <code><a href="http://xorshift.di.unimi.it">algorithms' homepage</a></code>. </p> </dd> </dl> <h3 id="default-algorithm">  The current <strong id="default-algorithm">default algorithm</strong> is <code><a href="#algorithms"> exsss (Xorshift116**). </a></code> If a specific algorithm is required, ensure to always use <code><a href="#seed-1"> seed/1</a></code> to initialize the state. </h3> <p> Which algorithm that is the default may change between Erlang/OTP releases, and is selected to be one with high speed, small state and "good enough" statistical properties. </p> <p> Undocumented (old) algorithms are deprecated but still implemented so old code relying on them will produce the same pseudo random sequences as before. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> There were a number of problems in the implementation of the now undocumented algorithms, which is why they are deprecated. The new algorithms are a bit slower but do not have these problems: </p> <p> Uniform integer ranges had a skew in the probability distribution that was not noticable for small ranges but for large ranges less than the generator's precision the probability to produce a low number could be twice the probability for a high. </p> <p> Uniform integer ranges larger than or equal to the generator's precision used a floating point fallback that only calculated with 52 bits which is smaller than the requested range and therefore were not all numbers in the requested range even possible to produce. </p> <p> Uniform floats had a non-uniform density so small values i.e less than 0.5 had got smaller intervals decreasing as the generated value approached 0.0 although still uniformly distributed for sufficiently large subranges. The new algorithms produces uniformly distributed floats on the form N * 2.0^(-53) hence equally spaced. </p> </div> </div> <p>Every time a random number is requested, a state is used to calculate it and a new state is produced. The state can either be implicit or be an explicit argument and return value.</p> <p>The functions with implicit state use the process dictionary variable <code>rand_seed</code> to remember the current state.</p> <p>If a process calls <code><a href="#uniform-0">uniform/0</a></code>, <code><a href="#uniform-1">uniform/1</a></code> or <code><a href="#uniform_real-0">uniform_real/0</a></code> without setting a seed first, <code><a href="#seed-1">seed/1</a></code> is called automatically with the <code><a href="#default-algorithm"> <strong>default algorithm</strong> </a></code> and creates a non-constant seed.</p> <p>The functions with explicit state never use the process dictionary.</p> <p><strong>Examples:</strong></p> <p> Simple use; creates and seeds the <code><a href="#default-algorithm"> <strong>default algorithm</strong> </a></code> with a non-constant seed if not already done: </p> <pre data-language="erlang">
R0 = rand:uniform(),
R1 = rand:uniform(),</pre> <p>Use a specified algorithm:</p> <pre data-language="erlang">
_ = rand:seed(exs928ss),
R2 = rand:uniform(),</pre> <p>Use a specified algorithm with a constant seed:</p> <pre data-language="erlang">
_ = rand:seed(exs928ss, {123, 123534, 345345}),
R3 = rand:uniform(),</pre> <p>Use the functional API with a non-constant seed:</p> <pre data-language="erlang">
S0 = rand:seed_s(exsss),
{R4, S1} = rand:uniform_s(S0),</pre> <p>Textbook basic form Box-Muller standard normal deviate</p> <pre data-language="erlang">
R5 = rand:uniform_real(),
R6 = rand:uniform(),
SND0 = math:sqrt(-2 * math:log(R5)) * math:cos(math:pi() * R6)</pre> <p>Create a standard normal deviate:</p> <pre data-language="erlang">
{SND1, S2} = rand:normal_s(S1),</pre> <p>Create a normal deviate with mean -3 and variance 0.5:</p> <pre data-language="erlang">
{ND0, S3} = rand:normal_s(-3, 0.5, S2),</pre> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The builtin random number generator algorithms are not cryptographically strong. If a cryptographically strong random number generator is needed, use something like <code>crypto:rand_seed/0</code>. </p> </div> </div> <p> For all these generators except <code>exro928ss</code> and <code>exsss</code> the lowest bit(s) has got a slightly less random behaviour than all other bits. 1 bit for <code>exrop</code> (and <code>exsp</code>), and 3 bits for <code>exs1024s</code>. See for example the explanation in the <code><a href="http://xoroshiro.di.unimi.it/xoroshiro128plus.c"> Xoroshiro128+ </a></code> generator source code: </p> <pre data-language="erlang">
Beside passing BigCrush, this generator passes the PractRand test suite
up to (and included) 16TB, with the exception of binary rank tests,
which fail due to the lowest bit being an LFSR; all other bits pass all
tests. We suggest to use a sign test to extract a random Boolean value.</pre> <p> If this is a problem; to generate a boolean with these algorithms use something like this: </p> <pre data-language="erlang">(rand:uniform(256) &gt; 128) % -&gt; boolean()</pre> <pre data-language="erlang">((rand:uniform(256) - 1) bsr 7) % -&gt; 0 | 1</pre> <p> For a general range, with <code>N = 1</code> for <code>exrop</code>, and <code>N = 3</code> for <code>exs1024s</code>: </p> <pre data-language="erlang">(((rand:uniform(Range bsl N) - 1) bsr N) + 1)</pre> <p> The floating point generating functions in this module waste the lowest bits when converting from an integer so they avoid this snag. </p> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-builtin_alg" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-builtin_alg">builtin_alg()</a> = 
 exsss | exro928ss | exrop | exs1024s | exsp | exs64 |
 exsplus | exs1024 | dummy</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-alg" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-alg">alg()</a> = <a href="#type-builtin_alg">builtin_alg()</a> | atom()</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-alg_handler" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-alg_handler">alg_handler()</a> = 
 #{type := <a href="#type-alg">alg()</a>,
 bits =&gt; integer() &gt;= 0,
 weak_low_bits =&gt; integer() &gt;= 0,
 max =&gt; integer() &gt;= 0,
 next :=
 fun((<a href="#type-alg_state">alg_state()</a>) -&gt; {integer() &gt;= 0, <a href="#type-alg_state">alg_state()</a>}),
 uniform =&gt; fun((<a href="#type-state">state()</a>) -&gt; {float(), <a href="#type-state">state()</a>}),
 uniform_n =&gt;
 fun((integer() &gt;= 1, <a href="#type-state">state()</a>) -&gt; {integer() &gt;= 1, <a href="#type-state">state()</a>}),
 jump =&gt; fun((<a href="#type-state">state()</a>) -&gt; <a href="#type-state">state()</a>)}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-alg_state" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-alg_state">alg_state()</a> = 
 <a href="#type-exsplus_state">exsplus_state()</a> |
 <a href="#type-exro928_state">exro928_state()</a> |
 <a href="#type-exrop_state">exrop_state()</a> |
 <a href="#type-exs1024_state">exs1024_state()</a> |
 <a href="#type-exs64_state">exs64_state()</a> |
 <a href="#type-dummy_state">dummy_state()</a> |
 term()</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-state">state()</a> = {<a href="#type-alg_handler">alg_handler()</a>, <a href="#type-alg_state">alg_state()</a>}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>Algorithm-dependent state.</p></div></div></article> <article class="data-types-body"><h3 id="type-export_state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-export_state">export_state()</a> = {<a href="#type-alg">alg()</a>, <a href="#type-alg_state">alg_state()</a>}</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> Algorithm-dependent state that can be printed or saved to file. </p> </div></div></article> <article class="data-types-body"><h3 id="type-seed" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-seed">seed()</a> = 
 [integer()] | integer() | {integer(), integer(), integer()}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p> A seed value for the generator. </p> <p> A list of integers sets the generator's internal state directly, after algorithm-dependent checks of the value and masking to the proper word size. The number of integers must be equal to the number of state words in the generator. </p> <p> An integer is used as the initial state for a SplitMix64 generator. The output values of that is then used for setting the generator's internal state after masking to the proper word size and if needed avoiding zero values. </p> <p> A traditional 3-tuple of integers seed is passed through algorithm-dependent hashing functions to create the generator's initial state. </p> </div></div></article> <article class="data-types-body"><h3 id="type-exsplus_state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-exsplus_state">exsplus_state()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>Algorithm specific internal state</p></div></div></article> <article class="data-types-body"><h3 id="type-exro928_state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-exro928_state">exro928_state()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>Algorithm specific internal state</p></div></div></article> <article class="data-types-body"><h3 id="type-exrop_state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-exrop_state">exrop_state()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>Algorithm specific internal state</p></div></div></article> <article class="data-types-body"><h3 id="type-exs1024_state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-exs1024_state">exs1024_state()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>Algorithm specific internal state</p></div></div></article> <article class="data-types-body"><h3 id="type-exs64_state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-exs64_state">exs64_state()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>Algorithm specific internal state</p></div></div></article> <article class="data-types-body"><h3 id="type-dummy_state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-dummy_state">dummy_state()</a> = <a href="#type-uint58">uint58()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>Algorithm specific internal state</p></div></div></article> <article class="data-types-body"><h3 id="type-splitmix64_state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-splitmix64_state">splitmix64_state()</a> = <a href="#type-uint64">uint64()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>Algorithm specific state</p></div></div></article> <article class="data-types-body"><h3 id="type-uint58" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-uint58">uint58()</a> = 0..288230376151711743</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>0 .. (2^58 - 1)</p></div></div></article> <article class="data-types-body"><h3 id="type-uint64" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-uint64">uint64()</a> = 0..18446744073709551615</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>0 .. (2^64 - 1)</p></div></div></article> <article class="data-types-body"><h3 id="type-mwc59_state" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-mwc59_state">mwc59_state()</a> = 1..574882961707499518</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>1 .. ((16#1ffb072 * 2^29 - 1) - 1)</p></div></div></article> </div> <section class="innertube"><h2 id="plug-in-framework-api" class="title-link"> <div class="title-name">Plug-in framework API</div>  </h2> </section><div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="bytes-1" class="bold_code title-link func-head">  <code>bytes(N :: <code>integer() &gt;= 0</code>) -&gt; Bytes :: <code>binary()</code></code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns, for a specified integer <code>N &gt;= 0</code>, a <code>binary()</code> with that number of random bytes. Generates as many random numbers as required using the selected algorithm to compose the binary, and updates the state in the process dictionary accordingly. </p> </div></div></article><article class="func"><h3 id="bytes_s-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>bytes_s(N :: <code>integer() &gt;= 0</code>, State :: <code><a href="#type-state">state()</a></code>) -&gt;
 {Bytes :: <code>binary()</code>, NewState :: <code><a href="#type-state">state()</a></code>}</code></pre>
<div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns, for a specified integer <code>N &gt;= 0</code> and a state, a <code>binary()</code> with that number of random bytes, and a new state. Generates as many random numbers as required using the selected algorithm to compose the binary, and the new state. </p> </div></div></article><article class="func"><h3 id="export_seed-0" class="bold_code title-link func-head">  <code>export_seed() -&gt; undefined | <code><a href="#type-export_state">export_state()</a></code></code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the random number state in an external format. To be used with <code><a href="#seed-1">seed/1</a></code>.</p> </div></div></article><article class="func"><h3 id="export_seed_s-1" class="bold_code title-link func-head">  <code>export_seed_s(State :: <code><a href="#type-state">state()</a></code>) -&gt; <code><a href="#type-export_state">export_state()</a></code></code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the random number generator state in an external format. To be used with <code><a href="#seed-1">seed/1</a></code>.</p> </div></div></article><article class="func"><h3 id="jump-0" class="bold_code title-link func-head">  <code>jump() -&gt; NewState :: <code><a href="#type-state">state()</a></code></code><div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the state after performing jump calculation to the state in the process dictionary.</p> <p>This function generates a <code>not_implemented</code> error exception when the jump function is not implemented for the algorithm specified in the state in the process dictionary.</p> </div></div></article><article class="func"><h3 id="jump-1" class="bold_code title-link func-head">  <code>jump(State :: <code><a href="#type-state">state()</a></code>) -&gt; NewState :: <code><a href="#type-state">state()</a></code></code><div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the state after performing jump calculation to the given state. </p> <p>This function generates a <code>not_implemented</code> error exception when the jump function is not implemented for the algorithm specified in the state.</p> </div></div></article><article class="func"><h3 id="normal-0" class="bold_code title-link func-head">  <code>normal() -&gt; <code>float()</code></code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a standard normal deviate float (that is, the mean is 0 and the standard deviation is 1) and updates the state in the process dictionary.</p> </div></div></article><article class="func"><h3 id="normal-2" class="bold_code title-link func-head">  <code>normal(Mean :: <code>number()</code>, Variance :: <code>number()</code>) -&gt; <code>float()</code></code><div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a normal N(Mean, Variance) deviate float and updates the state in the process dictionary.</p> </div></div></article><article class="func"><h3 id="normal_s-1" class="bold_code title-link func-head">  <code>normal_s(State :: <code><a href="#type-state">state()</a></code>) -&gt; {<code>float()</code>, NewState :: <code><a href="#type-state">state()</a></code>}</code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns, for a specified state, a standard normal deviate float (that is, the mean is 0 and the standard deviation is 1) and a new state.</p> </div></div></article><article class="func"><h3 id="normal_s-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>normal_s(Mean :: <code>number()</code>,
 Variance :: <code>number()</code>,
 State0 :: <code><a href="#type-state">state()</a></code>) -&gt;
 {<code>float()</code>, NewS :: <code><a href="#type-state">state()</a></code>}</code></pre>
<div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns, for a specified state, a normal N(Mean, Variance) deviate float and a new state.</p> </div></div></article><article class="func"><h3 id="seed-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>seed(AlgOrStateOrExpState ::
 <code><a href="#type-builtin_alg">builtin_alg()</a></code> | <code><a href="#type-state">state()</a></code> | <code><a href="#type-export_state">export_state()</a></code>) -&gt;
 <code><a href="#type-state">state()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <h3 id="seed-1" class="bold_code title-link func-head">  <code>seed(Alg :: default) -&gt; <code><a href="#type-state">state()</a></code></code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Seeds random number generation with the specifed algorithm and time-dependent data if <code>AlgOrStateOrExpState</code> is an algorithm. <code>Alg = default</code> is an alias for the <code><a href="#default-algorithm"> <strong>default algorithm</strong>. </a></code> </p> <p>Otherwise recreates the exported seed in the process dictionary, and returns the state. See also <code><a href="#export_seed-0">export_seed/0</a></code>.</p> </div></div></article><article class="func"><h3 id="seed-2" class="bold_code title-link func-head">  <code>seed(Alg :: <code><a href="#type-builtin_alg">builtin_alg()</a></code>, Seed :: <code><a href="#type-seed">seed()</a></code>) -&gt; <code><a href="#type-state">state()</a></code></code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <h3 id="seed-2" class="bold_code title-link func-head">  <code>seed(Alg :: default, Seed :: <code><a href="#type-seed">seed()</a></code>) -&gt; <code><a href="#type-state">state()</a></code></code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Seeds random number generation with the specified algorithm and integers in the process dictionary and returns the state. <code>Alg = default</code> is an alias for the <code><a href="#default-algorithm"> <strong>default algorithm</strong>. </a></code> </p> </div></div></article><article class="func"><h3 id="seed_s-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>seed_s(AlgOrStateOrExpState ::
 <code><a href="#type-builtin_alg">builtin_alg()</a></code> | <code><a href="#type-state">state()</a></code> | <code><a href="#type-export_state">export_state()</a></code>) -&gt;
 <code><a href="#type-state">state()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <h3 id="seed_s-1" class="bold_code title-link func-head">  <code>seed_s(Alg :: default) -&gt; <code><a href="#type-state">state()</a></code></code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Seeds random number generation with the specifed algorithm and time-dependent data if <code>AlgOrStateOrExpState</code> is an algorithm. <code>Alg = default</code> is an alias for the <code><a href="#default-algorithm"> <strong>default algorithm</strong>. </a></code> </p> <p>Otherwise recreates the exported seed and returns the state. See also <code><a href="#export_seed-0"> export_seed/0</a></code>.</p> </div></div></article><article class="func"><h3 id="seed_s-2" class="bold_code title-link func-head">  <code>seed_s(Alg :: <code><a href="#type-builtin_alg">builtin_alg()</a></code>, Seed :: <code><a href="#type-seed">seed()</a></code>) -&gt; <code><a href="#type-state">state()</a></code></code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <h3 id="seed_s-2" class="bold_code title-link func-head">  <code>seed_s(Alg :: default, Seed :: <code><a href="#type-seed">seed()</a></code>) -&gt; <code><a href="#type-state">state()</a></code></code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Seeds random number generation with the specified algorithm and integers and returns the state. <code>Alg = default</code> is an alias for the <code><a href="#default-algorithm"> <strong>default algorithm</strong>. </a></code> </p> </div></div></article><article class="func"><h3 id="uniform-0" class="bold_code title-link func-head">  <code>uniform() -&gt; X :: <code>float()</code></code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a random float uniformly distributed in the value range <code>0.0 =&lt; X &lt; 1.0</code> and updates the state in the process dictionary. </p> <p> The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> This function may return exactly <code>0.0</code> which can be fatal for certain applications. If that is undesired you can use <code>(1.0 - rand:uniform())</code> to get the interval <code>0.0 &lt; X =&lt; 1.0</code>, or instead use <code><a href="#uniform_real-0">uniform_real/0</a></code>. </p> <p> If neither endpoint is desired you can test and re-try like this: </p> <pre data-language="erlang">
my_uniform() -&gt;
    case rand:uniform() of
        0.0 -&gt; my_uniform();
	X -&gt; X
    end
end.</pre> </div> </div> </div></div></article><article class="func"><h3 id="uniform_real-0" class="bold_code title-link func-head">  <code>uniform_real() -&gt; X :: <code>float()</code></code><div class="title-since"><span class="since">OTP 21.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a random float uniformly distributed in the value range <code>DBL_MIN =&lt; X &lt; 1.0</code> and updates the state in the process dictionary. </p> <p> Conceptually, a random real number <code>R</code> is generated from the interval <code>0 =&lt; R &lt; 1</code> and then the closest rounded down normalized number in the IEEE 754 Double precision format is returned. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> The generated numbers from this function has got better granularity for small numbers than the regular <code><a href="#uniform-0">uniform/0</a></code> because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algorithms doing for example <code>1.0 / X</code> or <code>math:log(X)</code>. </p> </div> </div> <p> See <code><a href="#uniform_real_s-1">uniform_real_s/1</a></code> for more explanation. </p> </div></div></article><article class="func"><h3 id="uniform-1" class="bold_code title-link func-head">  <code>uniform(N :: <code>integer() &gt;= 1</code>) -&gt; X :: <code>integer() &gt;= 1</code></code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns, for a specified integer <code>N &gt;= 1</code>, a random integer uniformly distributed in the value range <code>1 =&lt; X =&lt; N</code> and updates the state in the process dictionary.</p> </div></div></article><article class="func"><h3 id="uniform_s-1" class="bold_code title-link func-head">  <code>uniform_s(State :: <code><a href="#type-state">state()</a></code>) -&gt; {X :: <code>float()</code>, NewState :: <code><a href="#type-state">state()</a></code>}</code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns, for a specified state, random float uniformly distributed in the value range <code>0.0 =&lt; X &lt; 1.0</code> and a new state. </p> <p> The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> This function may return exactly <code>0.0</code> which can be fatal for certain applications. If that is undesired you can use <code>(1.0 - rand:uniform(State))</code> to get the interval <code>0.0 &lt; X =&lt; 1.0</code>, or instead use <code><a href="#uniform_real_s-1">uniform_real_s/1</a></code>. </p> <p> If neither endpoint is desired you can test and re-try like this: </p> <pre data-language="erlang">
my_uniform(State) -&gt;
    case rand:uniform(State) of
        {0.0, NewState} -&gt; my_uniform(NewState);
	Result -&gt; Result
    end
end.</pre> </div> </div> </div></div></article><article class="func"><h3 id="uniform_real_s-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>uniform_real_s(State :: <code><a href="#type-state">state()</a></code>) -&gt;
 {X :: <code>float()</code>, NewState :: <code><a href="#type-state">state()</a></code>}</code></pre>
<div class="title-since"><span class="since">OTP 21.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns, for a specified state, a random float uniformly distributed in the value range <code>DBL_MIN =&lt; X &lt; 1.0</code> and updates the state in the process dictionary. </p> <p> Conceptually, a random real number <code>R</code> is generated from the interval <code>0 =&lt; R &lt; 1</code> and then the closest rounded down normalized number in the IEEE 754 Double precision format is returned. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> The generated numbers from this function has got better granularity for small numbers than the regular <code><a href="#uniform_s-1">uniform_s/1</a></code> because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algorithms doing for example <code>1.0 / X</code> or <code>math:log(X)</code>. </p> </div> </div> <p> The concept implicates that the probability to get exactly zero is extremely low; so low that this function is in fact guaranteed to never return zero. The smallest number that it might return is <code>DBL_MIN</code>, which is 2.0^(-1022). </p> <p> The value range stated at the top of this function description is technically correct, but <code>0.0 =&lt; X &lt; 1.0</code> is a better description of the generated numbers' statistical distribution. Except that exactly 0.0 is never returned, which is not possible to observe statistically. </p> <p> For example; for all sub ranges <code>N*2.0^(-53) =&lt; X &lt; (N+1)*2.0^(-53)</code> where <code>0 =&lt; integer(N) &lt; 2.0^53</code> the probability is the same. Compare that with the form of the numbers generated by <code><a href="#uniform_s-1">uniform_s/1</a></code>. </p> <p> Having to generate extra random bits for small numbers costs a little performance. This function is about 20% slower than the regular <code><a href="#uniform_s-1">uniform_s/1</a></code> </p> </div></div></article><article class="func"><h3 id="uniform_s-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>uniform_s(N :: <code>integer() &gt;= 1</code>, State :: <code><a href="#type-state">state()</a></code>) -&gt;
 {X :: <code>integer() &gt;= 1</code>, NewState :: <code><a href="#type-state">state()</a></code>}</code></pre>
<div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns, for a specified integer <code>N &gt;= 1</code> and a state, a random integer uniformly distributed in the value range <code>1 =&lt; X =&lt; N</code> and a new state.</p> </div></div></article> </div> <section class="innertube"><h2 id="niche-algorithms-api" class="title-link"> <div class="title-name">Niche algorithms API</div>  </h2> <div class="REFBODY rb-3">  <p id="niche_algorithms"> This section contains special purpose algorithms that does not use the <code><a href="#plug_in_api">plug-in framework API</a></code>, for example for speed reasons. </p> <p> Since these algorithms lack the plug-in framework support, generating numbers in a range other than the generator's own generated range may become a problem. </p> <p> There are at least 3 ways to do this, assuming that the range is less than the generator's range: </p> <dl> <dt class="title-link"><strong>Modulo</strong></dt> <dd> <p> To generate a number <code>V</code> in the range 0..<code>Range</code>-1: </p> <ul> <li>Generate a number <code>X</code>.</li> <li> Use <code>V = X rem Range</code> as your value. </li> </ul> <p> This method uses <code>rem</code>, that is, the remainder of an integer division, which is a slow operation. </p> <p> Low bits from the generator propagate straight through to the generated value, so if the generator has got weaknesses in the low bits this method propagates them too. </p> <p> If <code>Range</code> is not a divisor of the generator range, the generated numbers have a bias. Example: </p> <p> Say the generator generates a byte, that is, the generator range is 0..255, and the desired range is 0..99 (<code>Range=100</code>). Then there are 3 generator outputs that produce the value 0, that is; 0, 100 and 200. But there are only 2 generator outputs that produce the value 99, which are; 99 and 199. So the probability for a value <code>V</code> in 0..55 is 3/2 times the probability for the other values 56..99. </p> <p> If <code>Range</code> is much smaller than the generator range, then this bias gets hard to detect. The rule of thumb is that if <code>Range</code> is smaller than the square root of the generator range, the bias is small enough. Example: </p> <p> A byte generator when <code>Range=20</code>. There are 12 (<code>256 div 20</code>) possibilities to generate the highest numbers and one more to generate a number <code>V</code> &lt; 16 (<code>256 rem 20</code>). So the probability is 13/12 for a low number versus a high. To detect that difference with some confidence you would need to generate a lot more numbers than the generator range, 256 in this small example. </p> </dd> <dt class="title-link"><strong>Truncated multiplication</strong></dt> <dd> <p> To generate a number <code>V</code> in the range 0..<code>Range</code>-1, when you have a generator with the range 0..2^<code>Bits</code>-1: </p> <ul> <li>Generate a number <code>X</code>.</li> <li> Use <code>V = X*Range bsr Bits</code> as your value. </li> </ul> <p> If the multiplication <code>X*Range</code> creates a bignum this method becomes very slow. </p> <p> High bits from the generator propagate through to the generated value, so if the generator has got weaknesses in the high bits this method propagates them too. </p> <p> If <code>Range</code> is not a divisor of the generator range, the generated numbers have a bias, pretty much as for the <strong>Modulo</strong> method above. </p> </dd> <dt class="title-link"><strong>Shift or mask</strong></dt> <dd> <p> To generate a number in the range 0..2^<code>RBits</code>-1, when you have a generator with the range 0..2^<code>Bits</code>: </p> <ul> <li>Generate a number <code>X</code>.</li> <li> Use <code>V = X band ((1 bsl RBits)-1)</code> or <code>V = X bsr (Bits-RBits)</code> as your value. </li> </ul> <p> Masking with <code>band</code> preserves the low bits, and right shifting with <code>bsr</code> preserves the high, so if the generator has got weaknesses in high or low bits; choose the right operator. </p> <p> If the generator has got a range that is not a power of 2 and this method is used anyway, it introduces bias in the same way as for the <strong>Modulo</strong> method above. </p> </dd> <dt class="title-link"><strong>Rejection</strong></dt> <dd> <ul> <li>Generate a number <code>X</code>.</li> <li> If <code>X</code> is in the range, use <code>V = X</code> as your value, otherwise reject it and repeat. </li> </ul> <p> In theory it is not certain that this method will ever complete, but in practice you ensure that the probability of rejection is low. Then the probability for yet another iteration decreases exponentially so the expected mean number of iterations will often be between 1 and 2. Also, since the base generator is a full length generator, a value that will break the loop must eventually be generated. </p> </dd> </dl> <p> Chese methods can be combined, such as using the <strong>Modulo</strong> method and only if the generator value would create bias use <strong>Rejection</strong>. Or using <strong>Shift or mask</strong> to reduce the size of a generator value so that <strong>Truncated multiplication</strong> will not create a bignum. </p> <p> The recommended way to generate a floating point number (IEEE 745 double, that has got a 53-bit mantissa) in the range 0..1, that is 0.0 =&lt; <code>V</code> &lt;1.0 is to generate a 53-bit number <code>X</code> and then use <code>V = X * (1.0/((1 bsl 53)))</code> as your value. This will create a value on the form <code>N</code>*2^-53 with equal probability for every possible <code>N</code> for the range. </p> </div></section><div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="splitmix64_next-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>splitmix64_next(AlgState :: <code>integer()</code>) -&gt;
 {X :: <code><a href="#type-uint64">uint64()</a></code>,
 NewAlgState :: <code><a href="#type-splitmix64_state">splitmix64_state()</a></code>}</code></pre>
<div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a random 64-bit integer <code>X</code> and a new generator state <code>NewAlgState</code>, according to the SplitMix64 algorithm. </p> <p> This generator is used internally in the <code>rand</code> module for seeding other generators since it is of a quite different breed which reduces the probability for creating an accidentally bad seed. </p> </div></div></article><article class="func"><h3 id="exsp_next-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>exsp_next(AlgState :: <code><a href="#type-exsplus_state">exsplus_state()</a></code>) -&gt;
 {X :: <code><a href="#type-uint58">uint58()</a></code>, NewAlgState :: <code><a href="#type-exsplus_state">exsplus_state()</a></code>}</code></pre>
<div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a random 58-bit integer <code>X</code> and a new generator state <code>NewAlgState</code>, according to the Xorshift116+ algorithm. </p> <p> This is an API function into the internal implementation of the <code><a href="#algorithms">exsp</a></code> algorithm that enables using it without the overhead of the plug-in framework, which might be useful for time critial applications. On a typical 64 bit Erlang VM this approach executes in just above 30% (1/3) of the time for the default algorithm through this module's normal plug-in framework. </p> <p> To seed this generator use <code><a href="#seed_s-1"> {_, AlgState} = rand:seed_s(exsp) </a></code> or <code><a href="#seed_s-1"> {_, AlgState} = rand:seed_s(exsp, Seed) </a></code> with a specific <code>Seed</code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> This function offers no help in generating a number on a selected range, nor in generating a floating point number. It is easy to accidentally mess up the fairly good statistical properties of this generator when doing either. See the recepies at the start of this <code><a href="#niche_algorithms"> Niche algorithms API </a></code> description. Note also the caveat about weak low bits that this generator suffers from. The generator is exported in this form primarily for performance. </p> </div> </div> </div></div></article><article class="func"><h3 id="exsp_jump-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>exsp_jump(AlgState :: <code><a href="#type-exsplus_state">exsplus_state()</a></code>) -&gt;
 NewAlgState :: <code><a href="#type-exsplus_state">exsplus_state()</a></code></code></pre>
<div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a new generator state equivalent of the state after iterating over <code><a href="#exsp_next-1">exsp_next/1</a></code> 2^64 times. </p> <p> See the description of jump functions at the top of this module description. </p> </div></div></article><article class="func"><h3 id="mwc59-1" class="bold_code title-link func-head">  <code>mwc59(CX0 :: <code><a href="#type-mwc59_state">mwc59_state()</a></code>) -&gt; CX1 :: <code><a href="#type-mwc59_state">mwc59_state()</a></code></code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a new generator state <code>CX1</code>, according to a Multiply With Carry generator, which is an efficient implementation of a Multiplicative Congruential Generator with a power of 2 multiplier and a prime modulus. </p> <p> This generator uses the multiplier 2^32 and the modulus 16#7fa6502 * 2^32 - 1, which have been selected, in collaboration with Sebastiano Vigna, to avoid bignum operations and still get good statistical quality. It can be written as:<br> <code>C = CX0 bsr 32</code><br> <code>X = CX0 band ((1 bsl 32)-1))</code><br> <code>CX1 = 16#7fa6502 * X + C</code> </p> <p> Because the generator uses a multiplier that is a power of 2 it gets statistical flaws for collision tests and birthday spacings tests in 2 and 3 dimensions, and even these caveats apply only to the MWC "digit", that is the low 32 bits (due to the multiplier) of the generator state. </p> <p> The quality of the output value improves much by using a scrambler instead of just taking the low bits. Function <code><a href="#mwc59_value32-1"> mwc59_value32 </a></code> is a fast scrambler that returns a decent 32-bit number. The slightly slower <code><a href="#mwc59_value-1"> mwc59_value </a></code> scrambler returns 59 bits of very good quality, and <code><a href="#mwc59_float-1">mwc59_float</a></code> returns a <code>float()</code> of very good quality. </p> <p> The low bits of the base generator are surprisingly good, so the lowest 16 bits actually pass fairly strict PRNG tests, despite the generator's weaknesses that lie in the high bits of the 32-bit MWC "digit". It is recommended to use <code>rem</code> on the the generator state, or bit mask extracting the lowest bits to produce numbers in a range 16 bits or less. See the recepies at the start of this <code><a href="#niche_algorithms"> Niche algorithms API </a></code> description. </p> <p> On a typical 64 bit Erlang VM this generator executes in below 8% (1/13) of the time for the default algorithm in the <code><a href="#plug_in_api"> plug-in framework API </a></code> of this module. With the <code><a href="#mwc59_value32-1"> mwc59_value32 </a></code> scrambler the total time becomes 16% (1/6), and with <code><a href="#mwc59_value-1"> mwc59_value </a></code> it becomes 20% (1/5) of the time for the default algorithm. With <code><a href="#mwc59_float-1">mwc59_float</a></code> the total time is 60% of the time for the default algorithm generating a <code>float()</code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> This generator is a niche generator for high speed applications. It has a much shorter period than the default generator, which in itself is a quality concern, although when used with the value scramblers it passes strict PRNG tests. The generator is much faster than <code><a href="#exsp_next-1">exsp_next/1</a></code> but with a bit lower quality. </p> </div> </div> </div></div></article><article class="func"><h3 id="mwc59_value32-1" class="bold_code title-link func-head">  <code>mwc59_value32(CX :: <code><a href="#type-mwc59_state">mwc59_state()</a></code>) -&gt; V :: 0..4294967295</code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a 32-bit value <code>V</code> from a generator state <code>CX</code>. The generator state is scrambled using an 8-bit xorshift which masks the statistical imperfecions of the base generator <code><a href="#mwc59-1">mwc59</a></code> enough to produce numbers of decent quality. Still some problems in 2- and 3-dimensional birthday spacing and collision tests show through. </p> <p> When using this scrambler it is in general better to use the high bits of the value than the low. The lowest 8 bits are of good quality and pass right through from the base generator. They are combined with the next 8 in the xorshift making the low 16 good quality, but in the range 16..31 bits there are weaker bits that you do not want to have as the high bits of your generated values. Therefore it is in general safer to shift out low bits. See the recepies at the start of this <code><a href="#niche_algorithms"> Niche algorithms API </a></code> description. </p> <p> For a non power of 2 range less than about 16 bits (to not get too much bias and to avoid bignums) truncated multiplication can be used, which is much faster than using <code>rem</code>: <code>(Range*V) bsr 32</code>. </p> </div></div></article><article class="func"><h3 id="mwc59_value-1" class="bold_code title-link func-head">  <code>mwc59_value(CX :: <code><a href="#type-mwc59_state">mwc59_state()</a></code>) -&gt; V :: 0..576460752303423487</code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a 59-bit value <code>V</code> from a generator state <code>CX</code>. The generator state is scrambled using an 4-bit followed by a 27-bit xorshift, which masks the statistical imperfecions of the base generator <code><a href="#mwc59-1">mwc59</a></code> enough that all 59 bits are of very good quality. </p> <p> Be careful to not accidentaly create a bignum when handling the value <code>V</code>. </p> <p> It is in general general better to use the high bits from this scrambler than the low. See the recepies at the start of this <code><a href="#niche_algorithms"> Niche algorithms API </a></code> description. </p> <p> For a non power of 2 range less than about 29 bits (to not get too much bias and to avoid bignums) truncated multiplication can be used, which is much faster than using <code>rem</code>. Example for range 1'000'000'000; the range is 30 bits, we use 29 bits from the generator, adding up to 59 bits, which is not a bignum: <code>(1000000000 * (V bsr (59-29))) bsr 29</code>. </p> </div></div></article><article class="func"><h3 id="mwc59_float-1" class="bold_code title-link func-head">  <code>mwc59_float(CX :: <code><a href="#type-mwc59_state">mwc59_state()</a></code>) -&gt; V :: <code>float()</code></code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns the generator value <code>V</code> from a generator state <code>CX</code>, as a <code>float()</code>. The generator state is scrambled as with <code><a href="#mwc59_value-1"> mwc59_value/1 </a></code> before converted to a <code>float()</code>. </p> </div></div></article><article class="func"><h3 id="mwc59_seed-0" class="bold_code title-link func-head">  <code>mwc59_seed() -&gt; CX :: <code><a href="#type-mwc59_state">mwc59_state()</a></code></code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <h3 id="mwc59_seed-1" class="bold_code title-link func-head">  <code>mwc59_seed(S :: 0..288230376151711743) -&gt; CX :: <code><a href="#type-mwc59_state">mwc59_state()</a></code></code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Returns a generator state <code>CX</code>. <code>S</code> is hashed to create the generator state, to avoid that similar seeds create similar sequences. </p> <p> Without <code>S</code>, the generator state is created as for <code><a href="#seed_s-1">seed_s(atom())</a></code>. </p> </div></div></article> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
