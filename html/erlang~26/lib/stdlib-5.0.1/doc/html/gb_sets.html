  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">gb_sets</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Sets represented by general balanced trees.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module provides ordered sets using Prof. Arne Andersson's General Balanced Trees. Ordered sets can be much more efficient than using ordered lists, for larger sets, but depends on the application.</p> <p>The data representing a set as used by this module is to be regarded as opaque by other modules. In abstract terms, the representation is a composite type of existing Erlang terms. See note on <code>data types</code>. Any code assuming knowledge of the format is running on thin ice.</p> <p>This module considers two elements as different if and only if they do not compare equal (<code>==</code>).</p> </div> </div></section> <section class="innertube"><h2 id="complexity-note" class="title-link"> <div class="title-name">Complexity Note</div>  </h2> <div class="REFBODY rb-3"> <p>The complexity on set operations is bounded by either <strong>O(|S|)</strong> or <strong>O(|T| * log(|S|))</strong>, where S is the largest given set, depending on which is fastest for any particular function call. For operating on sets of almost equal size, this implementation is about 3 times slower than using ordered-list sets directly. For sets of very different sizes, however, this solution can be arbitrarily much faster; in practical cases, often 10-100 times. This implementation is particularly suited for accumulating elements a few at a time, building up a large set (&gt; 100-200 elements), and repeatedly testing for membership in the current set.</p> <p>As with normal tree structures, lookup (membership testing), insertion, and deletion have logarithmic complexity.</p> </div></section> <section class="innertube"><h2 id="compatibility" class="title-link"> <div class="title-name">Compatibility</div>  </h2> <div class="REFBODY rb-3"> <p>See the <code><a href="sets.html#compatibility">Compatibility Section in the sets(3) module</a></code> for information about the compatibility of the different implementations of sets in the Standard Library.</p> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-set" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-set">set(Element)</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>A general balanced set.</p></div></div></article> <article class="data-types-body"><h3 id="type-set" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-set">set()</a> = <a href="#type-set">set</a>(term())</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-iter" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-iter">iter(Element)</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>A general balanced set iterator.</p></div></div></article> <article class="data-types-body"><h3 id="type-iter" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-iter">iter()</a> = <a href="#type-iter">iter</a>(term())</code><br> </div> </h3> </article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="add-2" class="bold_code title-link func-head">  <code>add(Element, Set1) -&gt; Set2</code> </h3> <h3 id="add_element-2" class="bold_code title-link func-head">  <code>add_element(Element, Set1) -&gt; Set2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new set formed from <code>Set1</code> with <code>Element</code> inserted. If <code>Element</code> is already an element in <code>Set1</code>, nothing is changed.</p> </div></div></article><article class="func"><h3 id="balance-1" class="bold_code title-link func-head">  <code>balance(Set1) -&gt; Set2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Rebalances the tree representation of <code>Set1</code>. Notice that this is rarely necessary, but can be motivated when a large number of elements have been deleted from the tree without further insertions. Rebalancing can then be forced to minimise lookup times, as deletion does not rebalance the tree.</p> </div></div></article><article class="func"><h3 id="del_element-2" class="bold_code title-link func-head">  <code>del_element(Element, Set1) -&gt; Set2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new set formed from <code>Set1</code> with <code>Element</code> removed. If <code>Element</code> is not an element in <code>Set1</code>, nothing is changed.</p> </div></div></article><article class="func"><h3 id="delete-2" class="bold_code title-link func-head">  <code>delete(Element, Set1) -&gt; Set2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new set formed from <code>Set1</code> with <code>Element</code> removed. Assumes that <code>Element</code> is present in <code>Set1</code>.</p> </div></div></article><article class="func"><h3 id="delete_any-2" class="bold_code title-link func-head">  <code>delete_any(Element, Set1) -&gt; Set2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new set formed from <code>Set1</code> with <code>Element</code> removed. If <code>Element</code> is not an element in <code>Set1</code>, nothing is changed.</p> </div></div></article><article class="func"><h3 id="difference-2" class="bold_code title-link func-head">  <code>difference(Set1, Set2) -&gt; Set3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = Set3 = <a href="#type-set">set</a>(Element)</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns only the elements of <code>Set1</code> that are not also elements of <code>Set2</code>.</p> </div></div></article><article class="func"><h3 id="empty-0" class="bold_code title-link func-head">  <code>empty() -&gt; Set</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(none())</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new empty set.</p> </div></div></article><article class="func"><h3 id="filter-2" class="bold_code title-link func-head">  <code>filter(Pred, Set1) -&gt; Set2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Element) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Filters elements in <code>Set1</code> using predicate function <code>Pred</code>.</p> </div></div></article><article class="func"><h3 id="fold-3" class="bold_code title-link func-head">  <code>fold(Function, Acc0, Set) -&gt; Acc1</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Function = fun((Element, AccIn) -&gt; AccOut)</code></div> <div class="REFTYPES rt-1"><code>Acc0 = Acc1 = AccIn = AccOut = Acc</code></div>    <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Folds <code>Function</code> over every element in <code>Set</code> returning the final value of the accumulator.</p> </div></div></article><article class="func"><h3 id="from_list-1" class="bold_code title-link func-head">  <code>from_list(List) -&gt; Set</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List = [Element]</code></div> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a set of the elements in <code>List</code>, where <code>List</code> can be unordered and contain duplicates.</p> </div></div></article><article class="func"><h3 id="from_ordset-1" class="bold_code title-link func-head">  <code>from_ordset(List) -&gt; Set</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List = [Element]</code></div> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Turns an ordered-set list <code>List</code> into a set. The list must not contain duplicates.</p> </div></div></article><article class="func"><h3 id="insert-2" class="bold_code title-link func-head">  <code>insert(Element, Set1) -&gt; Set2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new set formed from <code>Set1</code> with <code>Element</code> inserted. Assumes that <code>Element</code> is not present in <code>Set1</code>.</p> </div></div></article><article class="func"><h3 id="intersection-1" class="bold_code title-link func-head">  <code>intersection(SetList) -&gt; Set</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>SetList = [<a href="#type-set">set</a>(Element), ...]</code></div> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the intersection of the non-empty list of sets.</p> </div></div></article><article class="func"><h3 id="intersection-2" class="bold_code title-link func-head">  <code>intersection(Set1, Set2) -&gt; Set3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = Set3 = <a href="#type-set">set</a>(Element)</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the intersection of <code>Set1</code> and <code>Set2</code>.</p> </div></div></article><article class="func"><h3 id="is_disjoint-2" class="bold_code title-link func-head">  <code>is_disjoint(Set1, Set2) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Set1</code> and <code>Set2</code> are disjoint (have no elements in common), otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="is_element-2" class="bold_code title-link func-head">  <code>is_element(Element, Set) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Element</code> is an element of <code>Set</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="is_empty-1" class="bold_code title-link func-head">  <code>is_empty(Set) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Set</code> is an empty set, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="is_member-2" class="bold_code title-link func-head">  <code>is_member(Element, Set) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Element</code> is an element of <code>Set</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="is_set-1" class="bold_code title-link func-head">  <code>is_set(Term) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Term = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Term</code> appears to be a set, otherwise <code>false</code>. This function will return <code>true</code> for any term that coincides with the representation of a <code>gb_set</code>, while not really being a <code>gb_set</code>, thus it might return false positive results. See also note on <code>data types</code>.</p> </div></div></article><article class="func"><h3 id="is_subset-2" class="bold_code title-link func-head">  <code>is_subset(Set1, Set2) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> when every element of <code>Set1</code> is also a member of <code>Set2</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="iterator-1" class="bold_code title-link func-head">  <code>iterator(Set) -&gt; Iter</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> <div class="REFTYPES rt-1"><code>Iter = <a href="#type-iter">iter</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns an iterator that can be used for traversing the entries of <code>Set</code>; see <code><a href="#next-1">next/1</a></code>. The implementation of this is very efficient; traversing the whole set using <code>next/1</code> is only slightly slower than getting the list of all elements using <code><a href="#to_list-1">to_list/1</a></code> and traversing that. The main advantage of the iterator approach is that it does not require the complete list of all elements to be built in memory at one time.</p> </div></div></article><article class="func"><h3 id="iterator_from-2" class="bold_code title-link func-head">  <code>iterator_from(Element, Set) -&gt; Iter</code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> <div class="REFTYPES rt-1"><code>Iter = <a href="#type-iter">iter</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns an iterator that can be used for traversing the entries of <code>Set</code>; see <code><a href="#next-1">next/1</a></code>. The difference as compared to the iterator returned by <code><a href="#iterator-1">iterator/1</a></code> is that the first element greater than or equal to <code>Element</code> is returned.</p> </div></div></article><article class="func"><h3 id="largest-1" class="bold_code title-link func-head">  <code>largest(Set) -&gt; Element</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the largest element in <code>Set</code>. Assumes that <code>Set</code> is not empty.</p> </div></div></article><article class="func"><h3 id="new-0" class="bold_code title-link func-head">  <code>new() -&gt; Set</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(none())</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new empty set.</p> </div></div></article><article class="func"><h3 id="next-1" class="bold_code title-link func-head">  <code>next(Iter1) -&gt; {Element, Iter2} | none</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Iter1 = Iter2 = <a href="#type-iter">iter</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>{Element, Iter2}</code>, where <code>Element</code> is the smallest element referred to by iterator <code>Iter1</code>, and <code>Iter2</code> is the new iterator to be used for traversing the remaining elements, or the atom <code>none</code> if no elements remain.</p> </div></div></article><article class="func"><h3 id="singleton-1" class="bold_code title-link func-head">  <code>singleton(Element) -&gt; <code><a href="#type-set">set</a></code>(Element)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a set containing only element <code>Element</code>. </p> </div></div></article><article class="func"><h3 id="size-1" class="bold_code title-link func-head">  <code>size(Set) -&gt; <code>integer() &gt;= 0</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the number of elements in <code>Set</code>.</p> </div></div></article><article class="func"><h3 id="smallest-1" class="bold_code title-link func-head">  <code>smallest(Set) -&gt; Element</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the smallest element in <code>Set</code>. Assumes that <code>Set</code> is not empty.</p> </div></div></article><article class="func"><h3 id="subtract-2" class="bold_code title-link func-head">  <code>subtract(Set1, Set2) -&gt; Set3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = Set3 = <a href="#type-set">set</a>(Element)</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns only the elements of <code>Set1</code> that are not also elements of <code>Set2</code>.</p> </div></div></article><article class="func"><h3 id="take_largest-1" class="bold_code title-link func-head">  <code>take_largest(Set1) -&gt; {Element, Set2}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>{Element, Set2}</code>, where <code>Element</code> is the largest element in <code>Set1</code>, and <code>Set2</code> is this set with <code>Element</code> deleted. Assumes that <code>Set1</code> is not empty.</p> </div></div></article><article class="func"><h3 id="take_smallest-1" class="bold_code title-link func-head">  <code>take_smallest(Set1) -&gt; {Element, Set2}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>{Element, Set2}</code>, where <code>Element</code> is the smallest element in <code>Set1</code>, and <code>Set2</code> is this set with <code>Element</code> deleted. Assumes that <code>Set1</code> is not empty.</p> </div></div></article><article class="func"><h3 id="to_list-1" class="bold_code title-link func-head">  <code>to_list(Set) -&gt; List</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> <div class="REFTYPES rt-1"><code>List = [Element]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the elements of <code>Set</code> as a list.</p> </div></div></article><article class="func"><h3 id="union-1" class="bold_code title-link func-head">  <code>union(SetList) -&gt; Set</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>SetList = [<a href="#type-set">set</a>(Element), ...]</code></div> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the merged (union) set of the list of sets.</p> </div></div></article><article class="func"><h3 id="union-2" class="bold_code title-link func-head">  <code>union(Set1, Set2) -&gt; Set3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = Set3 = <a href="#type-set">set</a>(Element)</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the merged (union) set of <code>Set1</code> and <code>Set2</code>.</p> </div></div></article> </div> <section class="innertube"><h2 id="see-also" class="title-link"> <div class="title-name">See Also</div>  </h2> <div class="REFBODY rb-3"> <p><code><a href="gb_trees.html">gb_trees(3)</a></code>, <code><a href="ordsets.html">ordsets(3)</a></code>, <code><a href="sets.html">sets(3)</a></code></p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
