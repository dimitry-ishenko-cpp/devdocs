  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">queue</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Abstract data type for FIFO queues.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module provides (double-ended) FIFO queues in an efficient manner.</p> <p>All functions fail with reason <code>badarg</code> if arguments are of wrong type, for example, queue arguments are not queues, indexes are not integers, and list arguments are not lists. Improper lists cause internal crashes. An index out of range for a queue also causes a failure with reason <code>badarg</code>.</p> <p>Some functions, where noted, fail with reason <code>empty</code> for an empty queue.</p> <p>The data representing a queue as used by this module is to be regarded as opaque by other modules. In abstract terms, the representation is a composite type of existing Erlang terms. See note on <code>data types</code>. Any code assuming knowledge of the format is running on thin ice.</p> <p>All operations have an amortized O(1) running time, except <code><a href="#all-2">all/2</a></code>, <code><a href="#any-2">any/2</a></code>, <code><a href="#delete-2">delete/2</a></code>, <code><a href="#delete_r-2">delete_r/2</a></code>, <code><a href="#delete_with-2">delete_with/2</a></code>, <code><a href="#delete_with_r-2">delete_with_r/2</a></code>, <code><a href="#filter-2">filter/2</a></code>, <code><a href="#filtermap-2">filtermap/2</a></code>, <code><a href="#fold-3">fold/3</a></code>, <code><a href="#join-2">join/2</a></code>, <code><a href="#len-1">len/1</a></code>, <code><a href="#member-2">member/2</a></code>, <code><a href="#split-2">split/2</a></code> that have O(n). To minimize the size of a queue minimizing the amount of garbage built by queue operations, the queues do not contain explicit length information, and that is why <code>len/1</code> is O(n). If better performance for this particular operation is essential, it is easy for the caller to keep track of the length.</p> <p>Queues are double-ended. The mental picture of a queue is a line of people (items) waiting for their turn. The queue front is the end with the item that has waited the longest. The queue rear is the end an item enters when it starts to wait. If instead using the mental picture of a list, the front is called head and the rear is called tail.</p> <p>Entering at the front and exiting at the rear are reverse operations on the queue.</p> <p>This module has three sets of interface functions: the <strong>"Original API"</strong>, the <strong>"Extended API"</strong>, and the <strong>"Okasaki API"</strong>.</p> <p>The "Original API" and the "Extended API" both use the mental picture of a waiting line of items. Both have reverse operations suffixed "_r".</p> <p>The "Original API" item removal functions return compound terms with both the removed item and the resulting queue. The "Extended API" contains alternative functions that build less garbage and functions for just inspecting the queue ends. Also the "Okasaki API" functions build less garbage.</p> <p>The "Okasaki API" is inspired by "Purely Functional Data Structures" by Chris Okasaki. It regards queues as lists. This API is by many regarded as strange and avoidable. For example, many reverse operations have lexically reversed names, some with more readable but perhaps less understandable aliases.</p> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-queue" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-queue">queue(Item)</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>As returned by <code><a href="#new-0">new/0</a></code>.</p></div></div></article> <article class="data-types-body"><h3 id="type-queue" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-queue">queue()</a> = <a href="#type-queue">queue</a>(term())</code><br> </div> </h3> </article> </div> <section class="innertube"><h2 id="original-api" class="title-link"> <div class="title-name">Original API</div>  </h2> </section><div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="all-2" class="bold_code title-link func-head">  <code>all(Pred, Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; <code>boolean()</code></code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Item) -&gt; boolean())</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Pred(Item)</code> returns <code>true</code> for all items <code>Item</code> in <code>Q</code>, otherwise <code>false</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
2&gt; <code>queue:all(fun (E) -&gt; E &gt; 3 end, Queue).</code>
false
3&gt; <code>queue:all(fun (E) -&gt; E &gt; 0 end, Queue).</code>
true</pre> </div></div></article><article class="func"><h3 id="any-2" class="bold_code title-link func-head">  <code>any(Pred, Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; <code>boolean()</code></code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Item) -&gt; boolean())</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Pred(Item)</code> returns <code>true</code> for at least one item <code>Item</code> in <code>Q</code>, otherwise <code>false</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
2&gt; <code>queue:any(fun (E) -&gt; E &gt; 10 end, Queue).</code>
false
3&gt; <code>queue:any(fun (E) -&gt; E &gt; 3 end, Queue).</code>
true</pre> </div></div></article><article class="func"><h3 id="delete-2" class="bold_code title-link func-head">  <code>delete(Item, Q1) -&gt; Q2</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Item = T</code></div> <div class="REFTYPES rt-1"><code>Q1 = Q2 = <a href="#type-queue">queue</a>(T)</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a copy of <code>Q1</code> where the first item matching <code>Item</code> is deleted, if there is such an item.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
2&gt; <code>Queue1 = queue:delete(3, Queue).</code>
3&gt; <code>queue:member(3, Queue1).</code>
false</pre> </div></div></article><article class="func"><h3 id="delete_r-2" class="bold_code title-link func-head">  <code>delete_r(Item, Q1) -&gt; Q2</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Item = T</code></div> <div class="REFTYPES rt-1"><code>Q1 = Q2 = <a href="#type-queue">queue</a>(T)</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a copy of <code>Q1</code> where the last item matching <code>Item</code> is deleted, if there is such an item.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,3,5]).</code>
2&gt; <code>Queue1 = queue:delete_r(3, Queue).</code>
3&gt; <code>queue:to_list(Queue1).</code>
[1,2,3,4,5]</pre> </div></div></article><article class="func"><h3 id="delete_with-2" class="bold_code title-link func-head">  <code>delete_with(Pred, Q1) -&gt; Q2</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Item) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>Q1 = Q2 = <a href="#type-queue">queue</a>(Item)</code></div>  <div class="REFTYPES rt-1"><code>Item = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a copy of <code>Q1</code> where the first item for which <code>Pred</code> returns <code>true</code> is deleted, if there is such an item.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([100,1,2,3,4,5]).</code>
2&gt; <code>Queue1 = queue:delete_with(fun (E) -&gt; E &gt; 0, Queue).</code>
3&gt; <code>queue:to_list(Queue1).</code>
[1,2,3,4,5]</pre> </div></div></article><article class="func"><h3 id="delete_with_r-2" class="bold_code title-link func-head">  <code>delete_with_r(Pred, Q1) -&gt; Q2</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Item) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>Q1 = Q2 = <a href="#type-queue">queue</a>(Item)</code></div>  <div class="REFTYPES rt-1"><code>Item = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a copy of <code>Q1</code> where the last item for which <code>Pred</code> returns <code>true</code> is deleted, if there is such an item.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5,100]).</code>
2&gt; <code>Queue1 = queue:delete_with(fun (E) -&gt; E &gt; 10, Queue).</code>
3&gt; <code>queue:to_list(Queue1).</code>
[1,2,3,4,5]</pre> </div></div></article><article class="func"><h3 id="filter-2" class="bold_code title-link func-head">  <code>filter(Fun, Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((Item) -&gt; boolean() | [Item])</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a queue <code>Q2</code> that is the result of calling <code>Fun(Item)</code> on all items in <code>Q1</code>.</p> <p>If <code>Fun(Item)</code> returns <code>true</code>, <code>Item</code> is copied to the result queue. If it returns <code>false</code>, <code>Item</code> is not copied. If it returns a list, the list elements are inserted instead of <code>Item</code> in the result queue.</p> <p><strong>Example 1:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>Queue1 = queue:filter(fun (E) -&gt; E &gt; 2 end, Queue).</code>
{[5],[3,4]}
3&gt; <code>queue:to_list(Queue1).</code>
[3,4,5]</pre> <p>So, <code>Fun(Item)</code> returning <code>[Item]</code> is thereby semantically equivalent to returning <code>true</code>, just as returning <code>[]</code> is semantically equivalent to returning <code>false</code>. But returning a list builds more garbage than returning an atom.</p> <p><strong>Example 2:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>Queue1 = queue:filter(fun (E) -&gt; [E, E+1] end, Queue).</code>
{[6,5,5,4,4,3],[1,2,2,3]}
3&gt; <code>queue:to_list(Queue1).</code>
[1,2,2,3,3,4,4,5,5,6]</pre> </div></div></article><article class="func"><h3 id="filtermap-2" class="bold_code title-link func-head">  <code>filtermap(Fun, Q1) -&gt; Q2</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((Item) -&gt; boolean() | {true, Value})</code></div> <div class="REFTYPES rt-1"><code>Q1 = <a href="#type-queue">queue</a>(Item)</code></div> <div class="REFTYPES rt-1"><code>Q2 = <a href="#type-queue">queue</a>(Item | Value)</code></div> <div class="REFTYPES rt-1"><code>Item = Value = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a queue <code>Q2</code> that is the result of calling <code>Fun(Item)</code> on all items in <code>Q1</code>.</p> <p>If <code>Fun(Item)</code> returns <code>true</code>, <code>Item</code> is copied to the result queue. If it returns <code>false</code>, <code>Item</code> is not copied. If it returns <code>{true, NewItem}</code>, the queue element at this position is replaced with <code>NewItem</code> in the result queue.</p> <p><strong>Example 1:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>Queue1 = queue:filtermap(fun (E) -&gt; E &gt; 2 end, Queue).</code>
{[5],[3,4]}
3&gt; <code>queue:to_list(Queue1).</code>
[3,4,5]
4&gt; <code>Queue1 = queue:filtermap(fun (E) -&gt; {true, E+100} end, Queue).</code>
{"ihg","ef"}
5&gt; <code>queue:to_list(Queue1).</code>
"efghi</pre> </div></div></article><article class="func"><h3 id="fold-3" class="bold_code title-link func-head">  <code>fold(Fun, Acc0, Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Acc1</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((Item, AccIn) -&gt; AccOut)</code></div> <div class="REFTYPES rt-1"><code>Acc0 = Acc1 = AccIn = AccOut = term()</code></div>    </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Calls <code>Fun(Item, AccIn)</code> on successive items <code>Item</code> of <code>Queue</code>, starting with <code>AccIn == Acc0</code>. The queue is traversed in queue order, that is, from front to rear. <code>Fun/2</code> must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. <code>Acc0</code> is returned if the queue is empty.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>queue:fold(fun(X, Sum) -&gt; X + Sum end, 0, queue:from_list([1,2,3,4,5])).</code>
15
2&gt; <code>queue:fold(fun(X, Prod) -&gt; X * Prod end, 1, queue:from_list([1,2,3,4,5])).</code>
120</pre> </div></div></article><article class="func"><h3 id="from_list-1" class="bold_code title-link func-head">  <code>from_list(L :: [Item]) -&gt; <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a queue containing the items in <code>L</code> in the same order; the head item of the list becomes the front item of the queue.</p> </div></div></article><article class="func"><h3 id="in-2" class="bold_code title-link func-head">  <code>in(Item, Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Inserts <code>Item</code> at the rear of queue <code>Q1</code>. Returns the resulting queue <code>Q2</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>Queue1 = queue:in(100, Queue).</code>
{[100,5,4,3],[1,2]}
3&gt; <code>queue:to_list(Queue1).</code>
[1,2,3,4,5,100]</pre> </div></div></article><article class="func"><h3 id="in_r-2" class="bold_code title-link func-head">  <code>in_r(Item, Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Inserts <code>Item</code> at the front of queue <code>Q1</code>. Returns the resulting queue <code>Q2</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>Queue1 = queue:in_r(100, Queue).</code>
{[5,4,3],[100,1,2]}
3&gt; <code>queue:to_list(Queue1).</code>
[100,1,2,3,4,5]</pre> </div></div></article><article class="func"><h3 id="is_empty-1" class="bold_code title-link func-head">  <code>is_empty(Q :: <code><a href="#type-queue">queue()</a></code>) -&gt; <code>boolean()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Tests if <code>Q</code> is empty and returns <code>true</code> if so, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="is_queue-1" class="bold_code title-link func-head">  <code>is_queue(Term :: <code>term()</code>) -&gt; <code>boolean()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Tests if <code>Term</code> is a queue and returns <code>true</code> if so, otherwise <code>false</code>. Note that the test will return <code>true</code> for a term coinciding with the representation of a queue, even when not constructed by thus module. See also note on <code>data types</code>.</p> </div></div></article><article class="func"><h3 id="join-2" class="bold_code title-link func-head">  <code>join(Q1 :: <code><a href="#type-queue">queue</a></code>(Item), Q2 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q3 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a queue <code>Q3</code> that is the result of joining <code>Q1</code> and <code>Q2</code> with <code>Q1</code> in front of <code>Q2</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue1 = queue:from_list([1,3]).</code>
{[3],[1]}
2&gt; <code>Queue2 = queue:from_list([2,4]).</code>
{[4],[2]}
3&gt; <code>queue:to_list(queue:join(Queue1, Queue2)).</code>
[1,3,2,4]</pre> </div></div></article><article class="func"><h3 id="len-1" class="bold_code title-link func-head">  <code>len(Q :: <code><a href="#type-queue">queue()</a></code>) -&gt; <code>integer() &gt;= 0</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Calculates and returns the length of queue <code>Q</code>.</p> </div></div></article><article class="func"><h3 id="member-2" class="bold_code title-link func-head">  <code>member(Item, Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; <code>boolean()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Item</code> matches some element in <code>Q</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="new-0" class="bold_code title-link func-head">  <code>new() -&gt; <code><a href="#type-queue">queue</a></code>(<code>none()</code>)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns an empty queue.</p> </div></div></article><article class="func"><h3 id="out-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>out(Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt;
 {{value, Item}, Q2 :: <code><a href="#type-queue">queue</a></code>(Item)} |
 {empty, Q1 :: <code><a href="#type-queue">queue</a></code>(Item)}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Removes the item at the front of queue <code>Q1</code>. Returns tuple <code>{{value, Item}, Q2}</code>, where <code>Item</code> is the item removed and <code>Q2</code> is the resulting queue. If <code>Q1</code> is empty, tuple <code>{empty, Q1}</code> is returned.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>{{value, 1=Item}, Queue1} = queue:out(Queue).</code>
{{value,1},{[5,4,3],[2]}}
3&gt; <code>queue:to_list(Queue1).</code>
[2,3,4,5]</pre> </div></div></article><article class="func"><h3 id="out_r-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>out_r(Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt;
 {{value, Item}, Q2 :: <code><a href="#type-queue">queue</a></code>(Item)} |
 {empty, Q1 :: <code><a href="#type-queue">queue</a></code>(Item)}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Removes the item at the rear of queue <code>Q1</code>. Returns tuple <code>{{value, Item}, Q2}</code>, where <code>Item</code> is the item removed and <code>Q2</code> is the new queue. If <code>Q1</code> is empty, tuple <code>{empty, Q1}</code> is returned.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>{{value, 5=Item}, Queue1} = queue:out_r(Queue).</code>
{{value,5},{[4,3],[1,2]}}
3&gt; <code>queue:to_list(Queue1).</code>
[1,2,3,4]</pre> </div></div></article><article class="func"><h3 id="reverse-1" class="bold_code title-link func-head">  <code>reverse(Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a queue <code>Q2</code> containing the items of <code>Q1</code> in the reverse order.</p> </div></div></article><article class="func"><h3 id="split-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>split(N :: <code>integer() &gt;= 0</code>, Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt;
 {Q2 :: <code><a href="#type-queue">queue</a></code>(Item), Q3 :: <code><a href="#type-queue">queue</a></code>(Item)}</code></pre> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Splits <code>Q1</code> in two. The <code>N</code> front items are put in <code>Q2</code> and the rest in <code>Q3</code>.</p> </div></div></article><article class="func"><h3 id="to_list-1" class="bold_code title-link func-head">  <code>to_list(Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; [Item]</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list of the items in the queue in the same order; the front item of the queue becomes the head of the list.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>List == queue:to_list(Queue).</code>
true</pre> </div></div></article> </div> <section class="innertube"><h2 id="extended-api" class="title-link"> <div class="title-name">Extended API</div>  </h2> </section><div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="drop-1" class="bold_code title-link func-head">  <code>drop(Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a queue <code>Q2</code> that is the result of removing the front item from <code>Q1</code>.</p> <p>Fails with reason <code>empty</code> if <code>Q1</code> is empty.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>Queue = queue:drop(Queue).</code>
{[5,4,3],[2]}
3&gt; <code>queue:to_list(Queue1).</code>
[2,3,4,5]</pre> </div></div></article><article class="func"><h3 id="drop_r-1" class="bold_code title-link func-head">  <code>drop_r(Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a queue <code>Q2</code> that is the result of removing the rear item from <code>Q1</code>.</p> <p>Fails with reason <code>empty</code> if <code>Q1</code> is empty.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>Queue = queue:drop_r(Queue).</code>
{[4,3],[1,2]}
3&gt; <code>queue:to_list(Queue1).</code>
[1,2,3,4]</pre> </div></div></article><article class="func"><h3 id="get-1" class="bold_code title-link func-head">  <code>get(Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Item</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>Item</code> at the front of queue <code>Q</code>.</p> <p>Fails with reason <code>empty</code> if <code>Q</code> is empty.</p> <p><strong>Example 1:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>1 == queue:get(Queue).</code>
true</pre> </div></div></article><article class="func"><h3 id="get_r-1" class="bold_code title-link func-head">  <code>get_r(Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Item</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>Item</code> at the rear of queue <code>Q</code>.</p> <p>Fails with reason <code>empty</code> if <code>Q</code> is empty.</p> <p><strong>Example 1:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
2&gt; <code>5 == queue:get_r(Queue).</code>
true</pre> </div></div></article><article class="func"><h3 id="peek-1" class="bold_code title-link func-head">  <code>peek(Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; empty | {value, Item}</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns tuple <code>{value, Item}</code>, where <code>Item</code> is the front item of <code>Q</code>, or <code>empty</code> if <code>Q</code> is empty.</p> <p><strong>Example 1:</strong></p> <pre data-language="erlang">
1&gt; <code>queue:peek(queue:new()).</code>
empty
2&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
3&gt; <code>queue:peek(Queue).</code>
{value, 1}</pre> </div></div></article><article class="func"><h3 id="peek_r-1" class="bold_code title-link func-head">  <code>peek_r(Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; empty | {value, Item}</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns tuple <code>{value, Item}</code>, where <code>Item</code> is the rear item of <code>Q</code>, or <code>empty</code> if <code>Q</code> is empty.</p> <p><strong>Example 1:</strong></p> <pre data-language="erlang">
1&gt; <code>queue:peek_r(queue:new()).</code>
empty
2&gt; <code>Queue = queue:from_list([1,2,3,4,5]).</code>
{[5,4,3],[1,2]}
3&gt; <code>queue:peek_r(Queue).</code>
{value, 5}</pre> </div></div></article> </div> <section class="innertube"><h2 id="okasaki-api" class="title-link"> <div class="title-name">Okasaki API</div>  </h2> </section><div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="cons-2" class="bold_code title-link func-head">  <code>cons(Item, Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Inserts <code>Item</code> at the head of queue <code>Q1</code>. Returns the new queue <code>Q2</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:cons(0, queue:from_list([1,2,3])).</code>
{[3,2],[0,1]}
2&gt; <code>queue:to_list(Queue).</code>
[0,1,2,3]</pre> </div></div></article><article class="func"><h3 id="daeh-1" class="bold_code title-link func-head">  <code>daeh(Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Item</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the tail item of queue <code>Q</code>.</p> <p>Fails with reason <code>empty</code> if <code>Q</code> is empty.</p> <p><strong>Example 1:</strong></p> <pre data-language="erlang">
1&gt; <code>queue:daeh(queue:from_list([1,2,3])).</code>
3</pre> </div></div></article><article class="func"><h3 id="head-1" class="bold_code title-link func-head">  <code>head(Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Item</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>Item</code> from the head of queue <code>Q</code>.</p> <p>Fails with reason <code>empty</code> if <code>Q</code> is empty.</p> <p><strong>Example 1:</strong></p> <pre data-language="erlang">
1&gt; <code>queue:head(queue:from_list([1,2,3])).</code>
1</pre> </div></div></article><article class="func"><h3 id="init-1" class="bold_code title-link func-head">  <code>init(Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a queue <code>Q2</code> that is the result of removing the tail item from <code>Q1</code>.</p> <p>Fails with reason <code>empty</code> if <code>Q1</code> is empty.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:init(queue:from_list([1,2,3])).</code>
{[2],[1]}
2&gt; <code>queue:to_list(Queue).</code>
[1,2]</pre> </div></div></article><article class="func"><h3 id="lait-1" class="bold_code title-link func-head">  <code>lait(Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a queue <code>Q2</code> that is the result of removing the tail item from <code>Q1</code>.</p> <p>Fails with reason <code>empty</code> if <code>Q1</code> is empty.</p> <p>The name <code>lait/1</code> is a misspelling - do not use it anymore.</p> </div></div></article><article class="func"><h3 id="last-1" class="bold_code title-link func-head">  <code>last(Q :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Item</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the tail item of queue <code>Q</code>.</p> <p>Fails with reason <code>empty</code> if <code>Q</code> is empty.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>queue:last(queue:from_list([1,2,3])).</code>
3</pre> </div></div></article><article class="func"><h3 id="liat-1" class="bold_code title-link func-head">  <code>liat(Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a queue <code>Q2</code> that is the result of removing the tail item from <code>Q1</code>.</p> <p>Fails with reason <code>empty</code> if <code>Q1</code> is empty.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:liat(queue:from_list([1,2,3])).</code>
{[2],[1]}
2&gt; <code>queue:to_list(Queue).</code>
[1,2]</pre> </div></div></article><article class="func"><h3 id="snoc-2" class="bold_code title-link func-head">  <code>snoc(Q1 :: <code><a href="#type-queue">queue</a></code>(Item), Item) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Inserts <code>Item</code> as the tail item of queue <code>Q1</code>. Returns the new queue <code>Q2</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>Queue = queue:snoc(queue:from_list([1,2,3]), 4).</code>
{[4,3,2],[1]}
2&gt; <code>queue:to_list(Queue).</code>
[1,2,3,4]</pre> </div></div></article><article class="func"><h3 id="tail-1" class="bold_code title-link func-head">  <code>tail(Q1 :: <code><a href="#type-queue">queue</a></code>(Item)) -&gt; Q2 :: <code><a href="#type-queue">queue</a></code>(Item)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a queue <code>Q2</code> that is the result of removing the head item from <code>Q1</code>.</p> <p>Fails with reason <code>empty</code> if <code>Q1</code> is empty.</p> </div></div></article> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
