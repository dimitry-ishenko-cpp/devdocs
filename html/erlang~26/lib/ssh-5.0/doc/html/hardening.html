<div class="innertube"> <h1 id="Hardening">6 Hardening</h1> <h2 id="introduction" class="title-link"> <div class="title-name">6.1 Introduction</div>  </h2> <p>The Erlang/OTP SSH application is intended to be used in other applications as a library. </p> <p>Different applications using this library may have very different requirements. One application could be running on a high performance server, while another is running on a small device with very limited cpu capacity. For example, the first one may accept many users simultaneously logged in, while the second one wants to limit them to only one. </p> <p>That simple example shows that it is impossible to deliver the SSH application with default values on hardening options as well on other options that suites every need. </p> <p>The purpose of this guide is to discuss the different hardening options available, as a guide to the reader. Configuration in general is described in the <code><a href="configurations.html">Configuration in SSH</a></code> chapter. </p> <h2 id="resilience-to-dos-attacks" class="title-link"> <div class="title-name">6.2 Resilience to DoS attacks</div>  </h2> <p>The following applies to daemons (servers).</p> <p>DoS (Denial of Service) attacks are hard to fight at the node level. Here are firewalls and other means needed, but that is out of scope for this guide. However, some measures could be taken in the configuration of the SSH server to increase the resilence. The options to use are:</p> <h3 id="counters-and-parallelism" class="title-link"> <div class="title-name">Counters and parallelism</div>  </h3> <dl> <dt class="title-link"><strong><code><a href="ssh.html#hardening_daemon_options--max_sessions">max_sessions</a></code></strong></dt> <dd> The maximum number of simultaneous sessions that are accepted at any time for this daemon. This includes sessions that are being authorized. The default is that an unlimited number of simultaneous sessions are allowed. It is a good candidate to set if the capacity of the server is low or a capacity margin is needed. </dd> <dt class="title-link"><strong><code><a href="ssh.html#hardening_daemon_options--max_channels">max_channels</a></code></strong></dt> <dd> The maximum number of channels that are accepted for each connection. The default is unlimited. </dd> <dt class="title-link"><strong><code><a href="ssh.html#hardening_daemon_options--parallel_login">parallel_login</a></code></strong></dt> <dd> If set to false (the default value), only one login is handled at a time. If set to true, the number of simultaneous login attempts are limited by the value of the <code><a href="ssh.html#hardening_daemon_options--max_sessions">max_sessions</a></code> option. </dd> </dl> <h3 id="timeouts" class="title-link"> <div class="title-name">Timeouts</div>  </h3> <dl> <dt class="title-link"><strong><code><a href="ssh.html#type-hello_timeout_daemon_option">hello_timeout</a></code></strong></dt> <dd> If the client fails to send the first ssh message after a tcp connection setup within this time (in milliseconds), the connection is closed. The default value is 30 seconds. This is actually a generous time, so it can lowered to make the daemon less prone to DoS attacks. </dd> <dt class="title-link"><strong><code><a href="ssh.html#type-negotiation_timeout_daemon_option">negotiation_timeout</a></code></strong></dt> <dd> Maximum time in milliseconds for the authentication negotiation counted from the TCP connection establishment. If the client fails to log in within this time the connection is closed. The default value is 2 minutes. It is quite a long time, but can lowered if the client is supposed to be fast like if it is a program logging in. </dd> <dt class="title-link"><strong><code><a href="ssh.html#type-max_idle_time_common_option">idle_time</a></code></strong></dt> <dd> Sets a time-out on a connection when no channels are left after closing the final one. It defaults to infinity. </dd> <dt class="title-link"><strong><code><a href="ssh.html#type-max_initial_idle_time_daemon_option">max_initial_idle_time</a></code></strong></dt> <dd> Sets a time-out on a connection that will expire if no channel is opened on the connection. The timeout is started when the authentication phase is completed. It defaults to infinity. </dd> </dl> <p>A figure clarifies when a timeout is started and when it triggers: </p> <div class="doc-image-wrapper">  <p class="doc-image-caption">Figure 6.1: SSH server timeouts</p> </div> <h2 id="verifying-the-remote-daemon--server--in-an-ssh-client" class="title-link"> <div class="title-name">6.3 Verifying the remote daemon (server) in an SSH client</div>  </h2> <p>Every SSH server presents a public key - the <i>host key</i> - to the client while keeping the corresponding private key in relatively safe privacy. </p> <p>The client checks that the host that presented the public key also possesses the private key of the key-pair. That check is part of the SSH protocol. </p> <p>But how can the client know that the host <i>really</i> is the one that it tried to connect to and not an evil one impersonating the expected one using its own valid key-pair? There are two alternatives available with the default key handling plugin <code><a href="ssh_file.html">ssh_file</a></code>. The alternatives are: </p> <dl> <dt class="title-link"><strong>Pre-store the host key</strong></dt> <dd> <ul> <li> For the default handler ssh_file, store the valid host keys in the file <code><a href="ssh_file.html#FILE-known_hosts">known_hosts</a></code> and set the option <code><a href="ssh.html#hardening_client_options--silently_accept_hosts">silently_accept_hosts</a></code> to <code>false</code>. </li> <li>or, write a specialized key handler using the <code><a href="ssh_client_key_api.html">SSH client key API</a></code> that accesses the pre-shared key in some other way. </li> </ul> </dd> <dt class="title-link"><strong>Pre-store the "fingerprint" (checksum) of the host key</strong></dt> <dd> <ul> <li> <code><a href="ssh.html#hardening_client_options--silently_accept_hosts">silently_accept_hosts</a></code> <ul> <li><code><a href="ssh.html#type-accept_callback">accept_callback()</a></code></li> <li><code><a href="ssh.html#type-accept_hosts">{HashAlgoSpec, accept_callback()}</a></code></li> </ul> </li> </ul> </dd> </dl> <h2 id="verifying-the-remote-client-in-a-daemon--server-" class="title-link"> <div class="title-name">6.4 Verifying the remote client in a daemon (server)</div>  </h2> <dl> <dt class="title-link"><strong>Password checking</strong></dt> <dd> <p>The default password checking is with the list in the <code><a href="ssh.html#option-user_passwords">user_passwords</a></code> option in the SSH daemon. It could be replaced with a <code><a href="ssh.html#option-pwdfun">pwdfun</a></code> plugin. The arity four variant (<code><a href="ssh.html#type-pwdfun_4">pwdfun_4()</a></code>) can also be used for introducing delays after failed password checking attempts. Here is a simple example of such a pwdfun: </p> <pre data-language="erlang">fun(User, Password, _PeerAddress, State) -&gt;
        case lists:member({User,Password}, my_user_pwds()) of
            true -&gt;
                {true, undefined}; % Reset delay time
            false when State == undefined -&gt;
                timer:sleep(1000),
                {false, 2000}; % Next delay is 2000 ms
            false when is_integer(State) -&gt;
                timer:sleep(State),
                {false, 2*State} % Double the delay for each failure
        end
end.</pre> <p>If a public key is used for logging in, there is normally no checking of the user name. It could be enabled by setting the option <code><a href="ssh.html#option-pk_check_user">pk_check_user</a></code> to <code>true</code>. In that case the pwdfun will get the atom <code>pubkey</code> in the password argument. </p> </dd> </dl> <h2 id="hardening-in-the-cryptographic-area" class="title-link"> <div class="title-name">6.5 Hardening in the cryptographic area</div>  </h2> <h3 id="algorithm-selection" class="title-link"> <div class="title-name">Algorithm selection</div>  </h3> <p>One of the cornerstones of security in SSH is cryptography. The development in crypto analysis is fast, and yesterday's secure algorithms are unsafe today. Therefore some algorithms are no longer enabled by default and that group grows with time. See the <code><span>SSH (App)</span></code> for a list of supported and of disabled algorithms. In the User's Guide the chapter <code><a href="configure_algos.html">Configuring algorithms in SSH</a></code> describes the options for enabling or disabling algorithms - <code><a href="ssh.html#type-preferred_algorithms_common_option">preferred_algorithms</a></code> and <code><a href="ssh.html#type-modify_algorithms_common_option">modify_algorithms</a></code>. </p> <h3 id="re-keying" class="title-link"> <div class="title-name">Re-keying</div>  </h3> <p>In the setup of the SSH connection a secret cipher key is generated by co-operation of the client and the server. Keeping this key secret is crucial for keeping the communication secret. As time passes and encrypted messages are exchanged, the probability that a listener could guess that key increases. </p> <p>The SSH protocol therefore has a special operation defined - <i>key re-negotiation</i> or <i>re-keying</i>. Any side (client or server) could initiate the re-keying and the result is a new cipher key. The result is that the eves-dropper has to restart its evil and dirty craftmanship. </p> <p>See the option <code><a href="ssh.html#type-rekey_limit_common_option">rekey_limit</a></code> for a description. </p> <h2 id="hardening-of-the-ssh-protocol---both-daemons-and-clients" class="title-link"> <div class="title-name">6.6 Hardening of the SSH protocol - both daemons and clients</div>  </h2> <h3 id="disabling-shell-and-exec-in-a-daemon" class="title-link"> <div class="title-name">Disabling shell and exec in a daemon</div>  </h3> <p>A daemon has two services for evaluating tasks on behalf of a remote client. The <i>exec</i> server-side service takes a string provided by the client, evaluates it and returns the result. The <i>shell</i> function enables the client to open a shell in the shell host. </p> <p>Those service could - and should - be disabled when they are not needed. The options <code><a href="ssh.html#type-exec_daemon_option">exec</a></code> and <code><a href="ssh.html#type-shell_daemon_option">shell</a></code> are enabled per default but could be set to <code>disabled</code> if not needed. The same options could also install handlers for the string(s) passed from the client to the server. </p> <h3 id="the-id-string" class="title-link"> <div class="title-name">The id string</div>  </h3> <p>One way to reduce the risk of intrusion is to not convey which software and which version the intruder is connected to. This limits the risk of an intruder exploiting known faults or peculiarities learned by reading the public code. </p> <p>Each SSH client or daemon presents themselves to each other with brand and version. This may look like</p> <pre data-language="erlang">SSH-2.0-Erlang/4.10</pre> <p>or</p> <pre data-language="erlang">SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3</pre> <p>This brand and version may be changed with the option <code><a href="ssh.html#type-id_string_common_option">id_string</a></code>. We start a daemon with that option: </p> <pre data-language="erlang">ssh:daemon(1234, [{id_string,"hi there"}, ... ]).</pre> <p>and the daemon will present itself as:</p> <pre data-language="erlang">SSH-2.0-hi there</pre> <p>It is possible to replace the string with one randomly generated for each connection attempt. See the reference manual for <code><a href="ssh.html#type-id_string_common_option">id_string</a></code>. </p> <h2 id="client-connection-options" class="title-link"> <div class="title-name">6.7 Client connection options</div>  </h2> <p>A client could limit the time for the initial tcp connection establishment with the option <code><a href="ssh.html#type-connect_timeout_client_option">connect_timeout</a></code>. The time is in milliseconds, and the initial value is infinity. </p> <p>The negotiation (session setup time) time can be limited with the <i>parameter</i> <code>NegotiationTimeout</code> in a call establishing an ssh session, for example <code>ssh:connect/3</code>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
