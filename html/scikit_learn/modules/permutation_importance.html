<section id="permutation-feature-importance"> <h1 id="permutation-importance">4.2. Permutation feature importance</h1> <p>Permutation feature importance is a model inspection technique that can be used for any <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fitted"><span class="xref std std-term">fitted</span></a> <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-estimator"><span class="xref std std-term">estimator</span></a> when the data is tabular. This is especially useful for non-linear or opaque <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-estimators"><span class="xref std std-term">estimators</span></a>. The permutation feature importance is defined to be the decrease in a model score when a single feature value is randomly shuffled <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. This procedure breaks the relationship between the feature and the target, thus the drop in the model score is indicative of how much the model depends on the feature. This technique benefits from being model agnostic and can be calculated many times with different permutations of the feature.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Features that are deemed of <strong>low importance for a bad model</strong> (low cross-validation score) could be <strong>very important for a good model</strong>. Therefore it is always important to evaluate the predictive power of a model using a held-out set (or better with cross-validation) prior to computing importances. Permutation importance does not reflect to the intrinsic predictive value of a feature by itself but <strong>how important this feature is for a particular model</strong>.</p> </div> <p>The <a class="reference internal" href="generated/sklearn.inspection.permutation_importance.html#sklearn.inspection.permutation_importance" title="sklearn.inspection.permutation_importance"><code>permutation_importance</code></a> function calculates the feature importance of <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-estimators"><span class="xref std std-term">estimators</span></a> for a given dataset. The <code>n_repeats</code> parameter sets the number of times a feature is randomly shuffled and returns a sample of feature importances.</p> <p>Let’s consider the following trained regression model:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import load_diabetes
&gt;&gt;&gt; from sklearn.model_selection import train_test_split
&gt;&gt;&gt; from sklearn.linear_model import Ridge
&gt;&gt;&gt; diabetes = load_diabetes()
&gt;&gt;&gt; X_train, X_val, y_train, y_val = train_test_split(
...     diabetes.data, diabetes.target, random_state=0)
...
&gt;&gt;&gt; model = Ridge(alpha=1e-2).fit(X_train, y_train)
&gt;&gt;&gt; model.score(X_val, y_val)
0.356...
</pre> <p>Its validation performance, measured via the <span class="math notranslate nohighlight">\(R^2\)</span> score, is significantly larger than the chance level. This makes it possible to use the <a class="reference internal" href="generated/sklearn.inspection.permutation_importance.html#sklearn.inspection.permutation_importance" title="sklearn.inspection.permutation_importance"><code>permutation_importance</code></a> function to probe which features are most predictive:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.inspection import permutation_importance
&gt;&gt;&gt; r = permutation_importance(model, X_val, y_val,
...                            n_repeats=30,
...                            random_state=0)
...
&gt;&gt;&gt; for i in r.importances_mean.argsort()[::-1]:
...     if r.importances_mean[i] - 2 * r.importances_std[i] &gt; 0:
...         print(f"{diabetes.feature_names[i]:&lt;8}"
...               f"{r.importances_mean[i]:.3f}"
...               f" +/- {r.importances_std[i]:.3f}")
...
s5      0.204 +/- 0.050
bmi     0.176 +/- 0.048
bp      0.088 +/- 0.033
sex     0.056 +/- 0.023
</pre> <p>Note that the importance values for the top features represent a large fraction of the reference score of 0.356.</p> <p>Permutation importances can be computed either on the training set or on a held-out testing or validation set. Using a held-out set makes it possible to highlight which features contribute the most to the generalization power of the inspected model. Features that are important on the training set but not on the held-out set might cause the model to overfit.</p> <p>The permutation feature importance is the decrease in a model score when a single feature value is randomly shuffled. The score function to be used for the computation of importances can be specified with the <code>scoring</code> argument, which also accepts multiple scorers. Using multiple scorers is more computationally efficient than sequentially calling <a class="reference internal" href="generated/sklearn.inspection.permutation_importance.html#sklearn.inspection.permutation_importance" title="sklearn.inspection.permutation_importance"><code>permutation_importance</code></a> several times with a different scorer, as it reuses model predictions.</p> <p>An example of using multiple scorers is shown below, employing a list of metrics, but more input formats are possible, as documented in <a class="reference internal" href="model_evaluation.html#multimetric-scoring"><span class="std std-ref">Using multiple metric evaluation</span></a>.</p> <pre data-language="python">&gt;&gt;&gt; scoring = ['r2', 'neg_mean_absolute_percentage_error', 'neg_mean_squared_error']
&gt;&gt;&gt; r_multi = permutation_importance(
...     model, X_val, y_val, n_repeats=30, random_state=0, scoring=scoring)
...
&gt;&gt;&gt; for metric in r_multi:
...     print(f"{metric}")
...     r = r_multi[metric]
...     for i in r.importances_mean.argsort()[::-1]:
...         if r.importances_mean[i] - 2 * r.importances_std[i] &gt; 0:
...             print(f"    {diabetes.feature_names[i]:&lt;8}"
...                   f"{r.importances_mean[i]:.3f}"
...                   f" +/- {r.importances_std[i]:.3f}")
...
r2
    s5      0.204 +/- 0.050
    bmi     0.176 +/- 0.048
    bp      0.088 +/- 0.033
    sex     0.056 +/- 0.023
neg_mean_absolute_percentage_error
    s5      0.081 +/- 0.020
    bmi     0.064 +/- 0.015
    bp      0.029 +/- 0.010
neg_mean_squared_error
    s5      1013.866 +/- 246.445
    bmi     872.726 +/- 240.298
    bp      438.663 +/- 163.022
    sex     277.376 +/- 115.123
</pre> <p>The ranking of the features is approximately the same for different metrics even if the scales of the importance values are very different. However, this is not guaranteed and different metrics might lead to significantly different feature importances, in particular for models trained for imbalanced classification problems, for which the choice of the classification metric can be critical.</p> <section id="outline-of-the-permutation-importance-algorithm"> <h2>
<span class="section-number">4.2.1. </span>Outline of the permutation importance algorithm</h2> <ul> <li>Inputs: fitted predictive model <span class="math notranslate nohighlight">\(m\)</span>, tabular dataset (training or validation) <span class="math notranslate nohighlight">\(D\)</span>.</li> <li>Compute the reference score <span class="math notranslate nohighlight">\(s\)</span> of the model <span class="math notranslate nohighlight">\(m\)</span> on data <span class="math notranslate nohighlight">\(D\)</span> (for instance the accuracy for a classifier or the <span class="math notranslate nohighlight">\(R^2\)</span> for a regressor).</li> <li>
<p>For each feature <span class="math notranslate nohighlight">\(j\)</span> (column of <span class="math notranslate nohighlight">\(D\)</span>):</p> <ul> <li>
<p>For each repetition <span class="math notranslate nohighlight">\(k\)</span> in <span class="math notranslate nohighlight">\({1, ..., K}\)</span>:</p> <ul class="simple"> <li>Randomly shuffle column <span class="math notranslate nohighlight">\(j\)</span> of dataset <span class="math notranslate nohighlight">\(D\)</span> to generate a corrupted version of the data named <span class="math notranslate nohighlight">\(\tilde{D}_{k,j}\)</span>.</li> <li>Compute the score <span class="math notranslate nohighlight">\(s_{k,j}\)</span> of model <span class="math notranslate nohighlight">\(m\)</span> on corrupted data <span class="math notranslate nohighlight">\(\tilde{D}_{k,j}\)</span>.</li> </ul> </li> <li>
<p>Compute importance <span class="math notranslate nohighlight">\(i_j\)</span> for feature <span class="math notranslate nohighlight">\(f_j\)</span> defined as:</p> <div class="math notranslate nohighlight"> \[i_j = s - \frac{1}{K} \sum_{k=1}^{K} s_{k,j}\]</div> </li> </ul> </li> </ul> </section> <section id="relation-to-impurity-based-importance-in-trees"> <h2>
<span class="section-number">4.2.2. </span>Relation to impurity-based importance in trees</h2> <p>Tree-based models provide an alternative measure of <a class="reference internal" href="ensemble.html#random-forest-feature-importance"><span class="std std-ref">feature importances based on the mean decrease in impurity</span></a> (MDI). Impurity is quantified by the splitting criterion of the decision trees (Gini, Log Loss or Mean Squared Error). However, this method can give high importance to features that may not be predictive on unseen data when the model is overfitting. Permutation-based feature importance, on the other hand, avoids this issue, since it can be computed on unseen data.</p> <p>Furthermore, impurity-based feature importance for trees are <strong>strongly biased</strong> and <strong>favor high cardinality features</strong> (typically numerical features) over low cardinality features such as binary features or categorical variables with a small number of possible categories.</p> <p>Permutation-based feature importances do not exhibit such a bias. Additionally, the permutation feature importance may be computed performance metric on the model predictions and can be used to analyze any model class (not just tree-based models).</p> <p>The following example highlights the limitations of impurity-based feature importance in contrast to permutation-based feature importance: <a class="reference internal" href="../auto_examples/inspection/plot_permutation_importance.html#sphx-glr-auto-examples-inspection-plot-permutation-importance-py"><span class="std std-ref">Permutation Importance vs Random Forest Feature Importance (MDI)</span></a>.</p> </section> <section id="misleading-values-on-strongly-correlated-features"> <h2>
<span class="section-number">4.2.3. </span>Misleading values on strongly correlated features</h2> <p>When two features are correlated and one of the features is permuted, the model will still have access to the feature through its correlated feature. This will result in a lower importance value for both features, where they might <em>actually</em> be important.</p> <p>One way to handle this is to cluster features that are correlated and only keep one feature from each cluster. This strategy is explored in the following example: <a class="reference internal" href="../auto_examples/inspection/plot_permutation_importance_multicollinear.html#sphx-glr-auto-examples-inspection-plot-permutation-importance-multicollinear-py"><span class="std std-ref">Permutation Importance with Multicollinear or Correlated Features</span></a>.</p> <aside class="topic"> <p class="topic-title">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../auto_examples/inspection/plot_permutation_importance.html#sphx-glr-auto-examples-inspection-plot-permutation-importance-py"><span class="std std-ref">Permutation Importance vs Random Forest Feature Importance (MDI)</span></a></li> <li><a class="reference internal" href="../auto_examples/inspection/plot_permutation_importance_multicollinear.html#sphx-glr-auto-examples-inspection-plot-permutation-importance-multicollinear-py"><span class="std std-ref">Permutation Importance with Multicollinear or Correlated Features</span></a></li> </ul> </aside> <aside class="topic"> <p class="topic-title">References:</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id2" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span> <p>L. Breiman, <a class="reference external" href="https://doi.org/10.1023/A:1010933404324">“Random Forests”</a>, Machine Learning, 45(1), 5-32, 2001.</p> </aside> </aside> </aside> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/permutation_importance.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/permutation_importance.html</a>
  </p>
</div>
