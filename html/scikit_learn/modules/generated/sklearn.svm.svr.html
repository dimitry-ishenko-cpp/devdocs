<section id="sklearn-svm-svr"> <h1>sklearn.svm.SVR</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.svm.SVR"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.svm.</span><span class="sig-name descname">SVR</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">kernel</span><span class="o">=</span><span class="default_value">'rbf'</span></em>, <em class="sig-param"><span class="n">degree</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">gamma</span><span class="o">=</span><span class="default_value">'scale'</span></em>, <em class="sig-param"><span class="n">coef0</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">C</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">shrinking</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">cache_size</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">-1</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/svm/_classes.py#L1063"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Epsilon-Support Vector Regression.</p> <p>The free parameters in the model are C and epsilon.</p> <p>The implementation is based on libsvm. The fit time complexity is more than quadratic with the number of samples which makes it hard to scale to datasets with more than a couple of 10000 samples. For large datasets consider using <a class="reference internal" href="sklearn.svm.linearsvr.html#sklearn.svm.LinearSVR" title="sklearn.svm.LinearSVR"><code>LinearSVR</code></a> or <a class="reference internal" href="sklearn.linear_model.sgdregressor.html#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><code>SGDRegressor</code></a> instead, possibly after a <a class="reference internal" href="sklearn.kernel_approximation.nystroem.html#sklearn.kernel_approximation.Nystroem" title="sklearn.kernel_approximation.Nystroem"><code>Nystroem</code></a> transformer.</p> <p>Read more in the <a class="reference internal" href="../svm.html#svm-regression"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>kernel</strong><span class="classifier">{‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’} or callable, default=’rbf’</span>
</dt>
<dd>
<p>Specifies the kernel type to be used in the algorithm. If none is given, ‘rbf’ will be used. If a callable is given it is used to precompute the kernel matrix.</p> </dd> <dt>
<strong>degree</strong><span class="classifier">int, default=3</span>
</dt>
<dd>
<p>Degree of the polynomial kernel function (‘poly’). Ignored by all other kernels.</p> </dd> <dt>
<strong>gamma</strong><span class="classifier">{‘scale’, ‘auto’} or float, default=’scale’</span>
</dt>
<dd>
<p>Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.</p> <ul class="simple"> <li>if <code>gamma='scale'</code> (default) is passed then it uses 1 / (n_features * X.var()) as value of gamma,</li> <li>if ‘auto’, uses 1 / n_features.</li> </ul> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.22: </span>The default value of <code>gamma</code> changed from ‘auto’ to ‘scale’.</p> </div> </dd> <dt>
<strong>coef0</strong><span class="classifier">float, default=0.0</span>
</dt>
<dd>
<p>Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.</p> </dd> <dt>
<strong>tol</strong><span class="classifier">float, default=1e-3</span>
</dt>
<dd>
<p>Tolerance for stopping criterion.</p> </dd> <dt>
<strong>C</strong><span class="classifier">float, default=1.0</span>
</dt>
<dd>
<p>Regularization parameter. The strength of the regularization is inversely proportional to C. Must be strictly positive. The penalty is a squared l2 penalty.</p> </dd> <dt>
<strong>epsilon</strong><span class="classifier">float, default=0.1</span>
</dt>
<dd>
<p>Epsilon in the epsilon-SVR model. It specifies the epsilon-tube within which no penalty is associated in the training loss function with points predicted within a distance epsilon from the actual value.</p> </dd> <dt>
<strong>shrinking</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether to use the shrinking heuristic. See the <a class="reference internal" href="../svm.html#shrinking-svm"><span class="std std-ref">User Guide</span></a>.</p> </dd> <dt>
<strong>cache_size</strong><span class="classifier">float, default=200</span>
</dt>
<dd>
<p>Specify the size of the kernel cache (in MB).</p> </dd> <dt>
<strong>verbose</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.</p> </dd> <dt>
<strong>max_iter</strong><span class="classifier">int, default=-1</span>
</dt>
<dd>
<p>Hard limit on iterations within solver, or -1 for no limit.</p> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>class_weight_</strong><span class="classifier">ndarray of shape (n_classes,)</span>
</dt>
<dd>
<p>Multipliers of parameter C for each class. Computed based on the <code>class_weight</code> parameter.</p> </dd> <dt>
<a class="reference internal" href="#sklearn.svm.SVR.coef_" title="sklearn.svm.SVR.coef_"><code>coef_</code></a><span class="classifier">ndarray of shape (1, n_features)</span>
</dt>
<dd>
<p>Weights assigned to the features when <code>kernel="linear"</code>.</p> </dd> <dt>
<strong>dual_coef_</strong><span class="classifier">ndarray of shape (1, n_SV)</span>
</dt>
<dd>
<p>Coefficients of the support vector in the decision function.</p> </dd> <dt>
<strong>fit_status_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>0 if correctly fitted, 1 otherwise (will raise warning)</p> </dd> <dt>
<strong>intercept_</strong><span class="classifier">ndarray of shape (1,)</span>
</dt>
<dd>
<p>Constants in decision function.</p> </dd> <dt>
<strong>n_features_in_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.24.</span></p> </div> </dd> <dt>
<strong>feature_names_in_</strong><span class="classifier">ndarray of shape (<code>n_features_in_</code>,)</span>
</dt>
<dd>
<p>Names of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>. Defined only when <code>X</code> has feature names that are all strings.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </dd> <dt>
<strong>n_iter_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of iterations run by the optimization routine to fit the model.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.1.</span></p> </div> </dd> <dt>
<a class="reference internal" href="#sklearn.svm.SVR.n_support_" title="sklearn.svm.SVR.n_support_"><code>n_support_</code></a><span class="classifier">ndarray of shape (1,), dtype=int32</span>
</dt>
<dd>
<p>Number of support vectors for each class.</p> </dd> <dt>
<strong>shape_fit_</strong><span class="classifier">tuple of int of shape (n_dimensions_of_X,)</span>
</dt>
<dd>
<p>Array dimensions of training vector <code>X</code>.</p> </dd> <dt>
<strong>support_</strong><span class="classifier">ndarray of shape (n_SV,)</span>
</dt>
<dd>
<p>Indices of support vectors.</p> </dd> <dt>
<strong>support_vectors_</strong><span class="classifier">ndarray of shape (n_SV, n_features)</span>
</dt>
<dd>
<p>Support vectors.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.svm.nusvr.html#sklearn.svm.NuSVR" title="sklearn.svm.NuSVR"><code>NuSVR</code></a></dt>
<dd>
<p>Support Vector Machine for regression implemented using libsvm using a parameter to control the number of support vectors.</p> </dd> <dt><a class="reference internal" href="sklearn.svm.linearsvr.html#sklearn.svm.LinearSVR" title="sklearn.svm.LinearSVR"><code>LinearSVR</code></a></dt>
<dd>
<p>Scalable Linear Support Vector Machine for regression implemented using liblinear.</p> </dd> </dl> </div> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="r4ae6a8049c28-1" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span> <p><a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/papers/libsvm.pdf">LIBSVM: A Library for Support Vector Machines</a></p> </div> <div class="citation" id="r4ae6a8049c28-2" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span> <p><a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.1639">Platt, John (1999). “Probabilistic outputs for support vector machines and comparison to regularizedlikelihood methods.”</a></p> </div> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.svm import SVR
&gt;&gt;&gt; from sklearn.pipeline import make_pipeline
&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; n_samples, n_features = 10, 5
&gt;&gt;&gt; rng = np.random.RandomState(0)
&gt;&gt;&gt; y = rng.randn(n_samples)
&gt;&gt;&gt; X = rng.randn(n_samples, n_features)
&gt;&gt;&gt; regr = make_pipeline(StandardScaler(), SVR(C=1.0, epsilon=0.2))
&gt;&gt;&gt; regr.fit(X, y)
Pipeline(steps=[('standardscaler', StandardScaler()),
                ('svr', SVR(epsilon=0.2))])
</pre> <h4 class="rubric">Methods</h4> <table class="autosummary longtable docutils align-default">  <tr>
<td><p><a class="reference internal" href="#sklearn.svm.SVR.fit" title="sklearn.svm.SVR.fit"><code>fit</code></a>(X, y[, sample_weight])</p></td> <td><p>Fit the SVM model according to the given training data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.SVR.get_params" title="sklearn.svm.SVR.get_params"><code>get_params</code></a>([deep])</p></td> <td><p>Get parameters for this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.SVR.predict" title="sklearn.svm.SVR.predict"><code>predict</code></a>(X)</p></td> <td><p>Perform regression on samples in X.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.SVR.score" title="sklearn.svm.SVR.score"><code>score</code></a>(X, y[, sample_weight])</p></td> <td><p>Return the coefficient of determination of the prediction.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.SVR.set_params" title="sklearn.svm.SVR.set_params"><code>set_params</code></a>(**params)</p></td> <td><p>Set the parameters of this estimator.</p></td> </tr>  </table> <dl class="py property"> <dt class="sig sig-object py" id="sklearn.svm.SVR.coef_"> <em class="property">property</em><span class="sig-name descname">coef_</span>
</dt> <dd>
<p>Weights assigned to the features when <code>kernel="linear"</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>ndarray of shape (n_features, n_classes)</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/svm/_base.py#L122"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit the SVM model according to the given training data.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features) or (n_samples, n_samples)</span>
</dt>
<dd>
<p>Training vectors, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of features. For kernel=”precomputed”, the expected shape of X is (n_samples, n_samples).</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,)</span>
</dt>
<dd>
<p>Target values (class labels in classification, real numbers in regression).</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Fitted estimator.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>If X and y are not C-ordered and contiguous arrays of np.float64 and X is not a scipy.sparse.csr_matrix, X and/or y may be copied.</p> <p>If X is a dense array, then the other methods will not support sparse matrices as input.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L194"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="sklearn.svm.SVR.n_support_"> <em class="property">property</em><span class="sig-name descname">n_support_</span>
</dt> <dd>
<p>Number of support vectors for each class.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.predict"> <span class="sig-name descname">predict</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/svm/_base.py#L417"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform regression on samples in X.</p> <p>For an one-class model, +1 (inlier) or -1 (outlier) is returned.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>For kernel=”precomputed”, the expected shape of X is (n_samples_test, n_samples_train).</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>y_pred</strong><span class="classifier">ndarray of shape (n_samples,)</span>
</dt>
<dd>
<p>The predicted values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.score"> <span class="sig-name descname">score</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L677"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the coefficient of determination of the prediction.</p> <p>The coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> is defined as <span class="math notranslate nohighlight">\((1 - \frac{u}{v})\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is the residual sum of squares <code>((y_true - y_pred)** 2).sum()</code> and <span class="math notranslate nohighlight">\(v\)</span> is the total sum of squares <code>((y_true - y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a <span class="math notranslate nohighlight">\(R^2\)</span> score of 0.0.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape <code>(n_samples, n_samples_fitted)</code>, where <code>n_samples_fitted</code> is the number of samples used in the fitting for the estimator.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs)</span>
</dt>
<dd>
<p>True values for <code>X</code>.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Sample weights.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>score</strong><span class="classifier">float</span>
</dt>
<dd>
<p><span class="math notranslate nohighlight">\(R^2\)</span> of <code>self.predict(X)</code> wrt. <code>y</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The <span class="math notranslate nohighlight">\(R^2\)</span> score used when calling <code>score</code> on a regressor uses <code>multioutput='uniform_average'</code> from version 0.23 to keep consistent with default value of <a class="reference internal" href="sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>. This influences the <code>score</code> method of all the multioutput regressors (except for <a class="reference internal" href="sklearn.multioutput.multioutputregressor.html#sklearn.multioutput.MultiOutputRegressor" title="sklearn.multioutput.MultiOutputRegressor"><code>MultiOutputRegressor</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L218"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="examples-using-sklearn-svm-svr"> <h2>Examples using <code>sklearn.svm.SVR</code>
</h2> <div class="sphx-glr-thumbnails">
<div class="sphx-glr-thumbcontainer" tooltip="This is an example showing the prediction latency of various scikit-learn estimators.">
<img alt="Prediction Latency" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/applications/plot_prediction_latency.html#sphx-glr-auto-examples-applications-plot-prediction-latency-py"><span class="std std-ref">Prediction Latency</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="Both kernel ridge regression (KRR) and SVR learn a non-linear function by employing the kernel ...">
<img alt="Comparison of kernel ridge regression and SVR" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/miscellaneous/plot_kernel_ridge_regression.html#sphx-glr-auto-examples-miscellaneous-plot-kernel-ridge-regression-py"><span class="std std-ref">Comparison of kernel ridge regression and SVR</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="Toy example of 1D regression using linear, polynomial and RBF kernels.">
<img alt="Support Vector Regression (SVR) using linear and non-linear kernels" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/svm/plot_svm_regression.html#sphx-glr-auto-examples-svm-plot-svm-regression-py"><span class="std std-ref">Support Vector Regression (SVR) using linear and non-linear kernels</span></a></p>  </div>
</div>
</section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/generated/sklearn.svm.SVR.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/generated/sklearn.svm.SVR.html</a>
  </p>
</div>
