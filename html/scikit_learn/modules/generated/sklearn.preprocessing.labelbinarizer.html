<section id="sklearn-preprocessing-labelbinarizer"> <h1>sklearn.preprocessing.LabelBinarizer</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.preprocessing.LabelBinarizer"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.preprocessing.</span><span class="sig-name descname">LabelBinarizer</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">neg_label</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">pos_label</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">sparse_output</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/preprocessing/_label.py#L169"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Binarize labels in a one-vs-all fashion.</p> <p>Several regression and binary classification algorithms are available in scikit-learn. A simple way to extend these algorithms to the multi-class classification case is to use the so-called one-vs-all scheme.</p> <p>At learning time, this simply consists in learning one regressor or binary classifier per class. In doing so, one needs to convert multi-class labels to binary labels (belong or does not belong to the class). LabelBinarizer makes this process easy with the transform method.</p> <p>At prediction time, one assigns the class for which the corresponding model gave the greatest confidence. LabelBinarizer makes this easy with the inverse_transform method.</p> <p>Read more in the <a class="reference internal" href="../preprocessing_targets.html#preprocessing-targets"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>neg_label</strong><span class="classifier">int, default=0</span>
</dt>
<dd>
<p>Value with which negative labels must be encoded.</p> </dd> <dt>
<strong>pos_label</strong><span class="classifier">int, default=1</span>
</dt>
<dd>
<p>Value with which positive labels must be encoded.</p> </dd> <dt>
<strong>sparse_output</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>True if the returned array from transform is desired to be in sparse CSR format.</p> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>classes_</strong><span class="classifier">ndarray of shape (n_classes,)</span>
</dt>
<dd>
<p>Holds the label for each class.</p> </dd> <dt>
<strong>y_type_</strong><span class="classifier">str</span>
</dt>
<dd>
<p>Represents the type of the target data as evaluated by utils.multiclass.type_of_target. Possible type are ‘continuous’, ‘continuous-multioutput’, ‘binary’, ‘multiclass’, ‘multiclass-multioutput’, ‘multilabel-indicator’, and ‘unknown’.</p> </dd> <dt>
<strong>sparse_input_</strong><span class="classifier">bool</span>
</dt>
<dd>
<p>True if the input data to transform is given as a sparse matrix, False otherwise.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.preprocessing.label_binarize.html#sklearn.preprocessing.label_binarize" title="sklearn.preprocessing.label_binarize"><code>label_binarize</code></a></dt>
<dd>
<p>Function to perform the transform operation of LabelBinarizer with fixed classes.</p> </dd> <dt><a class="reference internal" href="sklearn.preprocessing.onehotencoder.html#sklearn.preprocessing.OneHotEncoder" title="sklearn.preprocessing.OneHotEncoder"><code>OneHotEncoder</code></a></dt>
<dd>
<p>Encode categorical features using a one-hot aka one-of-K scheme.</p> </dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn import preprocessing
&gt;&gt;&gt; lb = preprocessing.LabelBinarizer()
&gt;&gt;&gt; lb.fit([1, 2, 6, 4, 2])
LabelBinarizer()
&gt;&gt;&gt; lb.classes_
array([1, 2, 4, 6])
&gt;&gt;&gt; lb.transform([1, 6])
array([[1, 0, 0, 0],
       [0, 0, 0, 1]])
</pre> <p>Binary targets transform to a column vector</p> <pre data-language="python">&gt;&gt;&gt; lb = preprocessing.LabelBinarizer()
&gt;&gt;&gt; lb.fit_transform(['yes', 'no', 'no', 'yes'])
array([[1],
       [0],
       [0],
       [1]])
</pre> <p>Passing a 2D matrix for multilabel classification</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; lb.fit(np.array([[0, 1, 1], [1, 0, 0]]))
LabelBinarizer()
&gt;&gt;&gt; lb.classes_
array([0, 1, 2])
&gt;&gt;&gt; lb.transform([0, 1, 2, 1])
array([[1, 0, 0],
       [0, 1, 0],
       [0, 0, 1],
       [0, 1, 0]])
</pre> <h4 class="rubric">Methods</h4> <table class="autosummary longtable docutils align-default">  <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.LabelBinarizer.fit" title="sklearn.preprocessing.LabelBinarizer.fit"><code>fit</code></a>(y)</p></td> <td><p>Fit label binarizer.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.LabelBinarizer.fit_transform" title="sklearn.preprocessing.LabelBinarizer.fit_transform"><code>fit_transform</code></a>(y)</p></td> <td><p>Fit label binarizer/transform multi-class labels to binary labels.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.LabelBinarizer.get_params" title="sklearn.preprocessing.LabelBinarizer.get_params"><code>get_params</code></a>([deep])</p></td> <td><p>Get parameters for this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.LabelBinarizer.inverse_transform" title="sklearn.preprocessing.LabelBinarizer.inverse_transform"><code>inverse_transform</code></a>(Y[, threshold])</p></td> <td><p>Transform binary labels back to multi-class labels.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.LabelBinarizer.set_params" title="sklearn.preprocessing.LabelBinarizer.set_params"><code>set_params</code></a>(**params)</p></td> <td><p>Set the parameters of this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.LabelBinarizer.transform" title="sklearn.preprocessing.LabelBinarizer.transform"><code>transform</code></a>(y)</p></td> <td><p>Transform multi-class labels to binary labels.</p></td> </tr>  </table> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.LabelBinarizer.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/preprocessing/_label.py#L264"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit label binarizer.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>y</strong><span class="classifier">ndarray of shape (n_samples,) or (n_samples, n_classes)</span>
</dt>
<dd>
<p>Target values. The 2-d matrix should only contain 0 and 1, represents multilabel classification.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Returns the instance itself.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.LabelBinarizer.fit_transform"> <span class="sig-name descname">fit_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/preprocessing/_label.py#L305"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit label binarizer/transform multi-class labels to binary labels.</p> <p>The output of transform is sometimes referred to as the 1-of-K coding scheme.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>y</strong><span class="classifier">{ndarray, sparse matrix} of shape (n_samples,) or (n_samples, n_classes)</span>
</dt>
<dd>
<p>Target values. The 2-d matrix should only contain 0 and 1, represents multilabel classification. Sparse matrix can be CSR, CSC, COO, DOK, or LIL.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>Y</strong><span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_classes)</span>
</dt>
<dd>
<p>Shape will be (n_samples, 1) for binary problems. Sparse matrix will be of CSR format.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.LabelBinarizer.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L194"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.LabelBinarizer.inverse_transform"> <span class="sig-name descname">inverse_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">Y</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/preprocessing/_label.py#L361"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform binary labels back to multi-class labels.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>Y</strong><span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_classes)</span>
</dt>
<dd>
<p>Target values. All sparse matrices are converted to CSR before inverse transformation.</p> </dd> <dt>
<strong>threshold</strong><span class="classifier">float, default=None</span>
</dt>
<dd>
<p>Threshold used in the binary and multi-label cases.</p> <p>Use 0 when <code>Y</code> contains the output of decision_function (classifier). Use 0.5 when <code>Y</code> contains the output of predict_proba.</p> <p>If None, the threshold is assumed to be half way between neg_label and pos_label.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>y</strong><span class="classifier">{ndarray, sparse matrix} of shape (n_samples,)</span>
</dt>
<dd>
<p>Target values. Sparse matrix will be of CSR format.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>In the case when the binary labels are fractional (probabilistic), inverse_transform chooses the class with the greatest value. Typically, this allows to use the output of a linear model’s decision_function method directly as the input of inverse_transform.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.LabelBinarizer.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L218"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.LabelBinarizer.transform"> <span class="sig-name descname">transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/preprocessing/_label.py#L327"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform multi-class labels to binary labels.</p> <p>The output of transform is sometimes referred to by some authors as the 1-of-K coding scheme.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>y</strong><span class="classifier">{array, sparse matrix} of shape (n_samples,) or (n_samples, n_classes)</span>
</dt>
<dd>
<p>Target values. The 2-d matrix should only contain 0 and 1, represents multilabel classification. Sparse matrix can be CSR, CSC, COO, DOK, or LIL.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>Y</strong><span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_classes)</span>
</dt>
<dd>
<p>Shape will be (n_samples, 1) for binary problems. Sparse matrix will be of CSR format.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="examples-using-sklearn-preprocessing-labelbinarizer"> <h2>Examples using <code>sklearn.preprocessing.LabelBinarizer</code>
</h2> <div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example benchmarks outlier detection algorithms, local_outlier_factor (LOF) and isolation_...">
<img alt="Evaluation of outlier detection estimators" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/miscellaneous/plot_outlier_detection_bench.html#sphx-glr-auto-examples-miscellaneous-plot-outlier-detection-bench-py"><span class="std std-ref">Evaluation of outlier detection estimators</span></a></p>  </div></div>
</section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/generated/sklearn.preprocessing.LabelBinarizer.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/generated/sklearn.preprocessing.LabelBinarizer.html</a>
  </p>
</div>
