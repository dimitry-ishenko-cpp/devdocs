<section id="sklearn-linear-model-sgdregressor"> <h1>sklearn.linear_model.SGDRegressor</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.linear_model.SGDRegressor"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.linear_model.</span><span class="sig-name descname">SGDRegressor</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">loss</span><span class="o">=</span><span class="default_value">'squared_error'</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">penalty</span><span class="o">=</span><span class="default_value">'l2'</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">l1_ratio</span><span class="o">=</span><span class="default_value">0.15</span></em>, <em class="sig-param"><span class="n">fit_intercept</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">learning_rate</span><span class="o">=</span><span class="default_value">'invscaling'</span></em>, <em class="sig-param"><span class="n">eta0</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">power_t</span><span class="o">=</span><span class="default_value">0.25</span></em>, <em class="sig-param"><span class="n">early_stopping</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">validation_fraction</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">n_iter_no_change</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">warm_start</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">average</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/linear_model/_stochastic_gradient.py#L1694"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Linear model fitted by minimizing a regularized empirical loss with SGD.</p> <p>SGD stands for Stochastic Gradient Descent: the gradient of the loss is estimated each sample at a time and the model is updated along the way with a decreasing strength schedule (aka learning rate).</p> <p>The regularizer is a penalty added to the loss function that shrinks model parameters towards the zero vector using either the squared euclidean norm L2 or the absolute norm L1 or a combination of both (Elastic Net). If the parameter update crosses the 0.0 value because of the regularizer, the update is truncated to 0.0 to allow for learning sparse models and achieve online feature selection.</p> <p>This implementation works with data represented as dense numpy arrays of floating point values for the features.</p> <p>Read more in the <a class="reference internal" href="../sgd.html#sgd"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>loss</strong><span class="classifier">str, default=’squared_error’</span>
</dt>
<dd>
<p>The loss function to be used. The possible values are ‘squared_error’, ‘huber’, ‘epsilon_insensitive’, or ‘squared_epsilon_insensitive’</p> <p>The ‘squared_error’ refers to the ordinary least squares fit. ‘huber’ modifies ‘squared_error’ to focus less on getting outliers correct by switching from squared to linear loss past a distance of epsilon. ‘epsilon_insensitive’ ignores errors less than epsilon and is linear past that; this is the loss function used in SVR. ‘squared_epsilon_insensitive’ is the same but becomes squared loss past a tolerance of epsilon.</p> <p>More details about the losses formulas can be found in the <a class="reference internal" href="../sgd.html#sgd-mathematical-formulation"><span class="std std-ref">User Guide</span></a>.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.0: </span>The loss ‘squared_loss’ was deprecated in v1.0 and will be removed in version 1.2. Use <code>loss='squared_error'</code> which is equivalent.</p> </div> </dd> <dt>
<strong>penalty</strong><span class="classifier">{‘l2’, ‘l1’, ‘elasticnet’}, default=’l2’</span>
</dt>
<dd>
<p>The penalty (aka regularization term) to be used. Defaults to ‘l2’ which is the standard regularizer for linear SVM models. ‘l1’ and ‘elasticnet’ might bring sparsity to the model (feature selection) not achievable with ‘l2’.</p> </dd> <dt>
<strong>alpha</strong><span class="classifier">float, default=0.0001</span>
</dt>
<dd>
<p>Constant that multiplies the regularization term. The higher the value, the stronger the regularization. Also used to compute the learning rate when set to <code>learning_rate</code> is set to ‘optimal’.</p> </dd> <dt>
<strong>l1_ratio</strong><span class="classifier">float, default=0.15</span>
</dt>
<dd>
<p>The Elastic Net mixing parameter, with 0 &lt;= l1_ratio &lt;= 1. l1_ratio=0 corresponds to L2 penalty, l1_ratio=1 to L1. Only used if <code>penalty</code> is ‘elasticnet’.</p> </dd> <dt>
<strong>fit_intercept</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether the intercept should be estimated or not. If False, the data is assumed to be already centered.</p> </dd> <dt>
<strong>max_iter</strong><span class="classifier">int, default=1000</span>
</dt>
<dd>
<p>The maximum number of passes over the training data (aka epochs). It only impacts the behavior in the <code>fit</code> method, and not the <a class="reference internal" href="#sklearn.linear_model.SGDRegressor.partial_fit" title="sklearn.linear_model.SGDRegressor.partial_fit"><code>partial_fit</code></a> method.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.19.</span></p> </div> </dd> <dt>
<strong>tol</strong><span class="classifier">float, default=1e-3</span>
</dt>
<dd>
<p>The stopping criterion. If it is not None, training will stop when (loss &gt; best_loss - tol) for <code>n_iter_no_change</code> consecutive epochs. Convergence is checked against the training loss or the validation loss depending on the <code>early_stopping</code> parameter.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.19.</span></p> </div> </dd> <dt>
<strong>shuffle</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether or not the training data should be shuffled after each epoch.</p> </dd> <dt>
<strong>verbose</strong><span class="classifier">int, default=0</span>
</dt>
<dd>
<p>The verbosity level.</p> </dd> <dt>
<strong>epsilon</strong><span class="classifier">float, default=0.1</span>
</dt>
<dd>
<p>Epsilon in the epsilon-insensitive loss functions; only if <code>loss</code> is ‘huber’, ‘epsilon_insensitive’, or ‘squared_epsilon_insensitive’. For ‘huber’, determines the threshold at which it becomes less important to get the prediction exactly right. For epsilon-insensitive, any differences between the current prediction and the correct label are ignored if they are less than this threshold.</p> </dd> <dt>
<strong>random_state</strong><span class="classifier">int, RandomState instance, default=None</span>
</dt>
<dd>
<p>Used for shuffling the data, when <code>shuffle</code> is set to <code>True</code>. Pass an int for reproducible output across multiple function calls. See <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-random_state"><span class="xref std std-term">Glossary</span></a>.</p> </dd> <dt>
<strong>learning_rate</strong><span class="classifier">str, default=’invscaling’</span>
</dt>
<dd>
<p>The learning rate schedule:</p> <ul> <li>‘constant’: <code>eta = eta0</code>
</li> <li>‘optimal’: <code>eta = 1.0 / (alpha * (t + t0))</code> where t0 is chosen by a heuristic proposed by Leon Bottou.</li> <li>‘invscaling’: <code>eta = eta0 / pow(t, power_t)</code>
</li> <li>
<p>‘adaptive’: eta = eta0, as long as the training keeps decreasing. Each time n_iter_no_change consecutive epochs fail to decrease the training loss by tol or fail to increase validation score by tol if early_stopping is True, the current learning rate is divided by 5.</p>  <div class="versionadded"> <p><span class="versionmodified added">New in version 0.20: </span>Added ‘adaptive’ option</p> </div>  </li> </ul> </dd> <dt>
<strong>eta0</strong><span class="classifier">float, default=0.01</span>
</dt>
<dd>
<p>The initial learning rate for the ‘constant’, ‘invscaling’ or ‘adaptive’ schedules. The default value is 0.01.</p> </dd> <dt>
<strong>power_t</strong><span class="classifier">float, default=0.25</span>
</dt>
<dd>
<p>The exponent for inverse scaling learning rate.</p> </dd> <dt>
<strong>early_stopping</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>Whether to use early stopping to terminate training when validation score is not improving. If set to True, it will automatically set aside a fraction of training data as validation and terminate training when validation score returned by the <code>score</code> method is not improving by at least <code>tol</code> for <code>n_iter_no_change</code> consecutive epochs.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.20: </span>Added ‘early_stopping’ option</p> </div> </dd> <dt>
<strong>validation_fraction</strong><span class="classifier">float, default=0.1</span>
</dt>
<dd>
<p>The proportion of training data to set aside as validation set for early stopping. Must be between 0 and 1. Only used if <code>early_stopping</code> is True.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.20: </span>Added ‘validation_fraction’ option</p> </div> </dd> <dt>
<strong>n_iter_no_change</strong><span class="classifier">int, default=5</span>
</dt>
<dd>
<p>Number of iterations with no improvement to wait before stopping fitting. Convergence is checked against the training loss or the validation loss depending on the <code>early_stopping</code> parameter.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.20: </span>Added ‘n_iter_no_change’ option</p> </div> </dd> <dt>
<strong>warm_start</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-warm_start"><span class="xref std std-term">the Glossary</span></a>.</p> <p>Repeatedly calling fit or partial_fit when warm_start is True can result in a different solution than when calling fit a single time because of the way the data is shuffled. If a dynamic learning rate is used, the learning rate is adapted depending on the number of samples already seen. Calling <code>fit</code> resets this counter, while <code>partial_fit</code> will result in increasing the existing counter.</p> </dd> <dt>
<strong>average</strong><span class="classifier">bool or int, default=False</span>
</dt>
<dd>
<p>When set to True, computes the averaged SGD weights across all updates and stores the result in the <code>coef_</code> attribute. If set to an int greater than 1, averaging will begin once the total number of samples seen reaches <code>average</code>. So <code>average=10</code> will begin averaging after seeing 10 samples.</p> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>coef_</strong><span class="classifier">ndarray of shape (n_features,)</span>
</dt>
<dd>
<p>Weights assigned to the features.</p> </dd> <dt>
<strong>intercept_</strong><span class="classifier">ndarray of shape (1,)</span>
</dt>
<dd>
<p>The intercept term.</p> </dd> <dt>
<strong>n_iter_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The actual number of iterations before reaching the stopping criterion.</p> </dd> <dt>
<strong>t_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of weight updates performed during training. Same as <code>(n_iter_ * n_samples)</code>.</p> </dd> <dt>
<strong>n_features_in_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.24.</span></p> </div> </dd> <dt>
<strong>feature_names_in_</strong><span class="classifier">ndarray of shape (<code>n_features_in_</code>,)</span>
</dt>
<dd>
<p>Names of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>. Defined only when <code>X</code> has feature names that are all strings.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.linear_model.huberregressor.html#sklearn.linear_model.HuberRegressor" title="sklearn.linear_model.HuberRegressor"><code>HuberRegressor</code></a></dt>
<dd>
<p>Linear regression model that is robust to outliers.</p> </dd> <dt><a class="reference internal" href="sklearn.linear_model.lars.html#sklearn.linear_model.Lars" title="sklearn.linear_model.Lars"><code>Lars</code></a></dt>
<dd>
<p>Least Angle Regression model.</p> </dd> <dt><a class="reference internal" href="sklearn.linear_model.lasso.html#sklearn.linear_model.Lasso" title="sklearn.linear_model.Lasso"><code>Lasso</code></a></dt>
<dd>
<p>Linear Model trained with L1 prior as regularizer.</p> </dd> <dt><a class="reference internal" href="sklearn.linear_model.ransacregressor.html#sklearn.linear_model.RANSACRegressor" title="sklearn.linear_model.RANSACRegressor"><code>RANSACRegressor</code></a></dt>
<dd>
<p>RANSAC (RANdom SAmple Consensus) algorithm.</p> </dd> <dt><a class="reference internal" href="sklearn.linear_model.ridge.html#sklearn.linear_model.Ridge" title="sklearn.linear_model.Ridge"><code>Ridge</code></a></dt>
<dd>
<p>Linear least squares with l2 regularization.</p> </dd> <dt><a class="reference internal" href="sklearn.svm.svr.html#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>sklearn.svm.SVR</code></a></dt>
<dd>
<p>Epsilon-Support Vector Regression.</p> </dd> <dt><a class="reference internal" href="sklearn.linear_model.theilsenregressor.html#sklearn.linear_model.TheilSenRegressor" title="sklearn.linear_model.TheilSenRegressor"><code>TheilSenRegressor</code></a></dt>
<dd>
<p>Theil-Sen Estimator robust multivariate regression model.</p> </dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.linear_model import SGDRegressor
&gt;&gt;&gt; from sklearn.pipeline import make_pipeline
&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler
&gt;&gt;&gt; n_samples, n_features = 10, 5
&gt;&gt;&gt; rng = np.random.RandomState(0)
&gt;&gt;&gt; y = rng.randn(n_samples)
&gt;&gt;&gt; X = rng.randn(n_samples, n_features)
&gt;&gt;&gt; # Always scale the input. The most convenient way is to use a pipeline.
&gt;&gt;&gt; reg = make_pipeline(StandardScaler(),
...                     SGDRegressor(max_iter=1000, tol=1e-3))
&gt;&gt;&gt; reg.fit(X, y)
Pipeline(steps=[('standardscaler', StandardScaler()),
                ('sgdregressor', SGDRegressor())])
</pre> <h4 class="rubric">Methods</h4> <table class="autosummary longtable docutils align-default">  <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.SGDRegressor.densify" title="sklearn.linear_model.SGDRegressor.densify"><code>densify</code></a>()</p></td> <td><p>Convert coefficient matrix to dense array format.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.SGDRegressor.fit" title="sklearn.linear_model.SGDRegressor.fit"><code>fit</code></a>(X, y[, coef_init, intercept_init, ...])</p></td> <td><p>Fit linear model with Stochastic Gradient Descent.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.SGDRegressor.get_params" title="sklearn.linear_model.SGDRegressor.get_params"><code>get_params</code></a>([deep])</p></td> <td><p>Get parameters for this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.SGDRegressor.partial_fit" title="sklearn.linear_model.SGDRegressor.partial_fit"><code>partial_fit</code></a>(X, y[, sample_weight])</p></td> <td><p>Perform one epoch of stochastic gradient descent on given samples.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.SGDRegressor.predict" title="sklearn.linear_model.SGDRegressor.predict"><code>predict</code></a>(X)</p></td> <td><p>Predict using the linear model.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.SGDRegressor.score" title="sklearn.linear_model.SGDRegressor.score"><code>score</code></a>(X, y[, sample_weight])</p></td> <td><p>Return the coefficient of determination of the prediction.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.SGDRegressor.set_params" title="sklearn.linear_model.SGDRegressor.set_params"><code>set_params</code></a>(**params)</p></td> <td><p>Set the parameters of this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.SGDRegressor.sparsify" title="sklearn.linear_model.SGDRegressor.sparsify"><code>sparsify</code></a>()</p></td> <td><p>Convert coefficient matrix to sparse format.</p></td> </tr>  </table> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.SGDRegressor.densify"> <span class="sig-name descname">densify</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/linear_model/_base.py#L477"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert coefficient matrix to dense array format.</p> <p>Converts the <code>coef_</code> member (back) to a numpy.ndarray. This is the default format of <code>coef_</code> and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>self</dt>
<dd>
<p>Fitted estimator.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.SGDRegressor.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">coef_init</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">intercept_init</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/linear_model/_stochastic_gradient.py#L1536"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit linear model with Stochastic Gradient Descent.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix}, shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Training data.</p> </dd> <dt>
<strong>y</strong><span class="classifier">ndarray of shape (n_samples,)</span>
</dt>
<dd>
<p>Target values.</p> </dd> <dt>
<strong>coef_init</strong><span class="classifier">ndarray of shape (n_features,), default=None</span>
</dt>
<dd>
<p>The initial coefficients to warm-start the optimization.</p> </dd> <dt>
<strong>intercept_init</strong><span class="classifier">ndarray of shape (1,), default=None</span>
</dt>
<dd>
<p>The initial intercept to warm-start the optimization.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like, shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Weights applied to individual samples (1. for unweighted).</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Fitted <code>SGDRegressor</code> estimator.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.SGDRegressor.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L194"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.SGDRegressor.partial_fit"> <span class="sig-name descname">partial_fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/linear_model/_stochastic_gradient.py#L1445"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform one epoch of stochastic gradient descent on given samples.</p> <p>Internally, this method uses <code>max_iter = 1</code>. Therefore, it is not guaranteed that a minimum of the cost function is reached after calling it once. Matters such as objective convergence and early stopping should be handled by the user.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix}, shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Subset of training data.</p> </dd> <dt>
<strong>y</strong><span class="classifier">numpy array of shape (n_samples,)</span>
</dt>
<dd>
<p>Subset of target values.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like, shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Weights applied to individual samples. If not provided, uniform weights are assumed.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Returns an instance of self.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.SGDRegressor.predict"> <span class="sig-name descname">predict</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/linear_model/_stochastic_gradient.py#L1592"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict using the linear model.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix}, shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Input data.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>ndarray of shape (n_samples,)</dt>
<dd>
<p>Predicted target values per element in X.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.SGDRegressor.score"> <span class="sig-name descname">score</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L677"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the coefficient of determination of the prediction.</p> <p>The coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> is defined as <span class="math notranslate nohighlight">\((1 - \frac{u}{v})\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is the residual sum of squares <code>((y_true - y_pred)** 2).sum()</code> and <span class="math notranslate nohighlight">\(v\)</span> is the total sum of squares <code>((y_true - y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a <span class="math notranslate nohighlight">\(R^2\)</span> score of 0.0.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape <code>(n_samples, n_samples_fitted)</code>, where <code>n_samples_fitted</code> is the number of samples used in the fitting for the estimator.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs)</span>
</dt>
<dd>
<p>True values for <code>X</code>.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Sample weights.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>score</strong><span class="classifier">float</span>
</dt>
<dd>
<p><span class="math notranslate nohighlight">\(R^2\)</span> of <code>self.predict(X)</code> wrt. <code>y</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The <span class="math notranslate nohighlight">\(R^2\)</span> score used when calling <code>score</code> on a regressor uses <code>multioutput='uniform_average'</code> from version 0.23 to keep consistent with default value of <a class="reference internal" href="sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>. This influences the <code>score</code> method of all the multioutput regressors (except for <a class="reference internal" href="sklearn.multioutput.multioutputregressor.html#sklearn.multioutput.MultiOutputRegressor" title="sklearn.multioutput.MultiOutputRegressor"><code>MultiOutputRegressor</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.SGDRegressor.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L218"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.SGDRegressor.sparsify"> <span class="sig-name descname">sparsify</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/linear_model/_base.py#L497"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert coefficient matrix to sparse format.</p> <p>Converts the <code>coef_</code> member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.</p> <p>The <code>intercept_</code> member is not converted.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>self</dt>
<dd>
<p>Fitted estimator.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>For non-sparse models, i.e. when there are not many zeros in <code>coef_</code>, this may actually <em>increase</em> memory usage, so use this method with care. A rule of thumb is that the number of zero elements, which can be computed with <code>(coef_ == 0).sum()</code>, must be more than 50% for this to provide significant benefits.</p> <p>After calling this method, further fitting with the partial_fit method (if any) will not work until you call densify.</p> </dd>
</dl> </dd>
</dl> <section id="examples-using-sklearn-linear-model-sgdregressor"> <h2>Examples using <code>sklearn.linear_model.SGDRegressor</code>
</h2> <div class="sphx-glr-thumbnails">
<div class="sphx-glr-thumbcontainer" tooltip="This is an example showing the prediction latency of various scikit-learn estimators.">
<img alt="Prediction Latency" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/applications/plot_prediction_latency.html#sphx-glr-auto-examples-applications-plot-prediction-latency-py"><span class="std std-ref">Prediction Latency</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="Contours of where the penalty is equal to 1 for the three penalties L1, L2 and elastic-net.">
<img alt="SGD: Penalties" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/linear_model/plot_sgd_penalties.html#sphx-glr-auto-examples-linear-model-plot-sgd-penalties-py"><span class="std std-ref">SGD: Penalties</span></a></p>  </div>
</div>
</section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/generated/sklearn.linear_model.SGDRegressor.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/generated/sklearn.linear_model.SGDRegressor.html</a>
  </p>
</div>
