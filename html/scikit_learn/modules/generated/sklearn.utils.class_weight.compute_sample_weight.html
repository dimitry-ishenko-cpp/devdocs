<section id="sklearn-utils-class-weight-compute-sample-weight"> <h1>sklearn.utils.class_weight.compute_sample_weight</h1> <dl class="py function"> <dt class="sig sig-object py" id="sklearn.utils.class_weight.compute_sample_weight"> <span class="sig-prename descclassname">sklearn.utils.class_weight.</span><span class="sig-name descname">compute_sample_weight</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">class_weight</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/utils/class_weight.py#L79"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate sample weights by class for unbalanced datasets.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>class_weight</strong><span class="classifier">dict, list of dicts, “balanced”, or None</span>
</dt>
<dd>
<p>Weights associated with classes in the form <code>{class_label: weight}</code>. If not given, all classes are supposed to have weight one. For multi-output problems, a list of dicts can be provided in the same order as the columns of y.</p> <p>Note that for multioutput (including multilabel) weights should be defined for each class of every column in its own dict. For example, for four-class multilabel classification weights should be [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of [{1:1}, {2:5}, {3:1}, {4:1}].</p> <p>The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data: <code>n_samples / (n_classes * np.bincount(y))</code>.</p> <p>For multi-output, the weights of each column of y will be multiplied.</p> </dd> <dt>
<strong>y</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples,) or (n_samples, n_outputs)</span>
</dt>
<dd>
<p>Array of original class labels per sample.</p> </dd> <dt>
<strong>indices</strong><span class="classifier">array-like of shape (n_subsample,), default=None</span>
</dt>
<dd>
<p>Array of indices to be used in a subsample. Can be of length less than n_samples in the case of a subsample, or equal to n_samples in the case of a bootstrap subsample with repeated indices. If None, the sample weight will be calculated over the full sample. Only “balanced” is supported for class_weight if this is provided.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>sample_weight_vect</strong><span class="classifier">ndarray of shape (n_samples,)</span>
</dt>
<dd>
<p>Array with sample weights as applied to the original y.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/generated/sklearn.utils.class_weight.compute_sample_weight.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/generated/sklearn.utils.class_weight.compute_sample_weight.html</a>
  </p>
</div>
