<section id="sklearn-preprocessing-robustscaler"> <h1>sklearn.preprocessing.RobustScaler</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.preprocessing.</span><span class="sig-name descname">RobustScaler</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">with_centering</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">with_scaling</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">quantile_range</span><span class="o">=</span><span class="default_value">(25.0, 75.0)</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">unit_variance</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/preprocessing/_data.py#L1341"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Scale features using statistics that are robust to outliers.</p> <p>This Scaler removes the median and scales the data according to the quantile range (defaults to IQR: Interquartile Range). The IQR is the range between the 1st quartile (25th quantile) and the 3rd quartile (75th quantile).</p> <p>Centering and scaling happen independently on each feature by computing the relevant statistics on the samples in the training set. Median and interquartile range are then stored to be used on later data using the <a class="reference internal" href="#sklearn.preprocessing.RobustScaler.transform" title="sklearn.preprocessing.RobustScaler.transform"><code>transform</code></a> method.</p> <p>Standardization of a dataset is a common requirement for many machine learning estimators. Typically this is done by removing the mean and scaling to unit variance. However, outliers can often influence the sample mean / variance in a negative way. In such cases, the median and the interquartile range often give better results.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.17.</span></p> </div> <p>Read more in the <a class="reference internal" href="../preprocessing.html#preprocessing-scaler"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>with_centering</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If <code>True</code>, center the data before scaling. This will cause <a class="reference internal" href="#sklearn.preprocessing.RobustScaler.transform" title="sklearn.preprocessing.RobustScaler.transform"><code>transform</code></a> to raise an exception when attempted on sparse matrices, because centering them entails building a dense matrix which in common use cases is likely to be too large to fit in memory.</p> </dd> <dt>
<strong>with_scaling</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If <code>True</code>, scale the data to interquartile range.</p> </dd> <dt>
<strong>quantile_range</strong><span class="classifier">tuple (q_min, q_max), 0.0 &lt; q_min &lt; q_max &lt; 100.0, default=(25.0, 75.0)</span>
</dt>
<dd>
<p>Quantile range used to calculate <code>scale_</code>. By default this is equal to the IQR, i.e., <code>q_min</code> is the first quantile and <code>q_max</code> is the third quantile.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.18.</span></p> </div> </dd> <dt>
<strong>copy</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If <code>False</code>, try to avoid a copy and do inplace scaling instead. This is not guaranteed to always work inplace; e.g. if the data is not a NumPy array or scipy.sparse CSR matrix, a copy may still be returned.</p> </dd> <dt>
<strong>unit_variance</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>If <code>True</code>, scale data so that normally distributed features have a variance of 1. In general, if the difference between the x-values of <code>q_max</code> and <code>q_min</code> for a standard normal distribution is greater than 1, the dataset will be scaled down. If less than 1, the dataset will be scaled up.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.24.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>center_</strong><span class="classifier">array of floats</span>
</dt>
<dd>
<p>The median value for each feature in the training set.</p> </dd> <dt>
<strong>scale_</strong><span class="classifier">array of floats</span>
</dt>
<dd>
<p>The (scaled) interquartile range for each feature in the training set.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.17: </span><em>scale_</em> attribute.</p> </div> </dd> <dt>
<strong>n_features_in_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.24.</span></p> </div> </dd> <dt>
<strong>feature_names_in_</strong><span class="classifier">ndarray of shape (<code>n_features_in_</code>,)</span>
</dt>
<dd>
<p>Names of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>. Defined only when <code>X</code> has feature names that are all strings.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.preprocessing.robust_scale.html#sklearn.preprocessing.robust_scale" title="sklearn.preprocessing.robust_scale"><code>robust_scale</code></a></dt>
<dd>
<p>Equivalent function without the estimator API.</p> </dd> <dt><a class="reference internal" href="sklearn.decomposition.pca.html#sklearn.decomposition.PCA" title="sklearn.decomposition.PCA"><code>sklearn.decomposition.PCA</code></a></dt>
<dd>
<p>Further removes the linear correlation across features with ‘whiten=True’.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>For a comparison of the different scalers, transformers, and normalizers, see <a class="reference internal" href="../../auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py"><span class="std std-ref">examples/preprocessing/plot_all_scaling.py</span></a>.</p> <p><a class="reference external" href="https://en.wikipedia.org/wiki/Median">https://en.wikipedia.org/wiki/Median</a> <a class="reference external" href="https://en.wikipedia.org/wiki/Interquartile_range">https://en.wikipedia.org/wiki/Interquartile_range</a></p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.preprocessing import RobustScaler
&gt;&gt;&gt; X = [[ 1., -2.,  2.],
...      [ -2.,  1.,  3.],
...      [ 4.,  1., -2.]]
&gt;&gt;&gt; transformer = RobustScaler().fit(X)
&gt;&gt;&gt; transformer
RobustScaler()
&gt;&gt;&gt; transformer.transform(X)
array([[ 0. , -2. ,  0. ],
       [-1. ,  0. ,  0.4],
       [ 1. ,  0. , -1.6]])
</pre> <h4 class="rubric">Methods</h4> <table class="autosummary longtable docutils align-default">  <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.RobustScaler.fit" title="sklearn.preprocessing.RobustScaler.fit"><code>fit</code></a>(X[, y])</p></td> <td><p>Compute the median and quantiles to be used for scaling.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.RobustScaler.fit_transform" title="sklearn.preprocessing.RobustScaler.fit_transform"><code>fit_transform</code></a>(X[, y])</p></td> <td><p>Fit to data, then transform it.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.RobustScaler.get_feature_names_out" title="sklearn.preprocessing.RobustScaler.get_feature_names_out"><code>get_feature_names_out</code></a>([input_features])</p></td> <td><p>Get output feature names for transformation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.RobustScaler.get_params" title="sklearn.preprocessing.RobustScaler.get_params"><code>get_params</code></a>([deep])</p></td> <td><p>Get parameters for this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.RobustScaler.inverse_transform" title="sklearn.preprocessing.RobustScaler.inverse_transform"><code>inverse_transform</code></a>(X)</p></td> <td><p>Scale back the data to the original representation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.RobustScaler.set_params" title="sklearn.preprocessing.RobustScaler.set_params"><code>set_params</code></a>(**params)</p></td> <td><p>Set the parameters of this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.preprocessing.RobustScaler.transform" title="sklearn.preprocessing.RobustScaler.transform"><code>transform</code></a>(X)</p></td> <td><p>Center and scale the data.</p></td> </tr>  </table> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/preprocessing/_data.py#L1466"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the median and quantiles to be used for scaling.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>The data used to compute the median and quantiles used for later scaling along the features axis.</p> </dd> <dt>
<strong>y</strong><span class="classifier">Ignored</span>
</dt>
<dd>
<p>Not used, present here for API consistency by convention.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Fitted scaler.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.fit_transform"> <span class="sig-name descname">fit_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">fit_params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L839"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit to data, then transform it.</p> <p>Fits transformer to <code>X</code> and <code>y</code> with optional parameters <code>fit_params</code> and returns a transformed version of <code>X</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Input samples.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs), default=None</span>
</dt>
<dd>
<p>Target values (None for unsupervised transformations).</p> </dd> <dt>
<strong>**fit_params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Additional fit parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X_new</strong><span class="classifier">ndarray array of shape (n_samples, n_features_new)</span>
</dt>
<dd>
<p>Transformed array.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.get_feature_names_out"> <span class="sig-name descname">get_feature_names_out</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_features</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L880"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get output feature names for transformation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>input_features</strong><span class="classifier">array-like of str or None, default=None</span>
</dt>
<dd>
<p>Input features.</p> <ul class="simple"> <li>If <code>input_features</code> is <code>None</code>, then <code>feature_names_in_</code> is used as feature names in. If <code>feature_names_in_</code> is not defined, then the following input feature names are generated: <code>["x0", "x1", ..., "x(n_features_in_ - 1)"]</code>.</li> <li>If <code>input_features</code> is an array-like, then <code>input_features</code> must match <code>feature_names_in_</code> if <code>feature_names_in_</code> is defined.</li> </ul> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>feature_names_out</strong><span class="classifier">ndarray of str objects</span>
</dt>
<dd>
<p>Same as input features.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L194"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.inverse_transform"> <span class="sig-name descname">inverse_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/preprocessing/_data.py#L1565"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Scale back the data to the original representation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>The rescaled data to be transformed back.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X_tr</strong><span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Transformed array.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L218"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.transform"> <span class="sig-name descname">transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/preprocessing/_data.py#L1532"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Center and scale the data.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>The data used to scale along the specified axis.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X_tr</strong><span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Transformed array.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="examples-using-sklearn-preprocessing-robustscaler"> <h2>Examples using <code>sklearn.preprocessing.RobustScaler</code>
</h2> <div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Feature 0 (median income in a block) and feature 5 (average house occupancy) of the california_...">
<img alt="Compare the effect of different scalers on data with outliers" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py"><span class="std std-ref">Compare the effect of different scalers on data with outliers</span></a></p>  </div></div>
</section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/generated/sklearn.preprocessing.RobustScaler.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/generated/sklearn.preprocessing.RobustScaler.html</a>
  </p>
</div>
