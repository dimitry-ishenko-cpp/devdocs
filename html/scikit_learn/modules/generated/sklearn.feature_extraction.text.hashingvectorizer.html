<section id="sklearn-feature-extraction-text-hashingvectorizer"> <h1>sklearn.feature_extraction.text.HashingVectorizer</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.feature_extraction.text.</span><span class="sig-name descname">HashingVectorizer</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">*</span></em>, <em class="sig-param"><span class="n">input='content'</span></em>, <em class="sig-param"><span class="n">encoding='utf-8'</span></em>, <em class="sig-param"><span class="n">decode_error='strict'</span></em>, <em class="sig-param"><span class="n">strip_accents=None</span></em>, <em class="sig-param"><span class="n">lowercase=True</span></em>, <em class="sig-param"><span class="n">preprocessor=None</span></em>, <em class="sig-param"><span class="n">tokenizer=None</span></em>, <em class="sig-param"><span class="n">stop_words=None</span></em>, <em class="sig-param"><span class="n">token_pattern='(?u)\\b\\w\\w+\\b'</span></em>, <em class="sig-param"><span class="n">ngram_range=(1</span></em>, <em class="sig-param"><span class="n">1)</span></em>, <em class="sig-param"><span class="n">analyzer='word'</span></em>, <em class="sig-param"><span class="n">n_features=1048576</span></em>, <em class="sig-param"><span class="n">binary=False</span></em>, <em class="sig-param"><span class="n">norm='l2'</span></em>, <em class="sig-param"><span class="n">alternate_sign=True</span></em>, <em class="sig-param"><span class="n">dtype=&lt;class 'numpy.float64'&gt;</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/feature_extraction/text.py#L565"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert a collection of text documents to a matrix of token occurrences.</p> <p>It turns a collection of text documents into a scipy.sparse matrix holding token occurrence counts (or binary occurrence information), possibly normalized as token frequencies if norm=’l1’ or projected on the euclidean unit sphere if norm=’l2’.</p> <p>This text vectorizer implementation uses the hashing trick to find the token string name to feature integer index mapping.</p> <p>This strategy has several advantages:</p> <ul class="simple"> <li>it is very low memory scalable to large datasets as there is no need to store a vocabulary dictionary in memory.</li> <li>it is fast to pickle and un-pickle as it holds no state besides the constructor parameters.</li> <li>it can be used in a streaming (partial fit) or parallel pipeline as there is no state computed during fit.</li> </ul> <p>There are also a couple of cons (vs using a CountVectorizer with an in-memory vocabulary):</p> <ul class="simple"> <li>there is no way to compute the inverse transform (from feature indices to string feature names) which can be a problem when trying to introspect which features are most important to a model.</li> <li>there can be collisions: distinct tokens can be mapped to the same feature index. However in practice this is rarely an issue if n_features is large enough (e.g. 2 ** 18 for text classification problems).</li> <li>no IDF weighting as this would render the transformer stateful.</li> </ul> <p>The hash function employed is the signed 32-bit version of Murmurhash3.</p> <p>Read more in the <a class="reference internal" href="../feature_extraction.html#text-feature-extraction"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>input</strong><span class="classifier">{‘filename’, ‘file’, ‘content’}, default=’content’</span>
</dt>
<dd>
<ul class="simple"> <li>If <code>'filename'</code>, the sequence passed as an argument to fit is expected to be a list of filenames that need reading to fetch the raw content to analyze.</li> <li>If <code>'file'</code>, the sequence items must have a ‘read’ method (file-like object) that is called to fetch the bytes in memory.</li> <li>If <code>'content'</code>, the input is expected to be a sequence of items that can be of type string or byte.</li> </ul> </dd> <dt>
<strong>encoding</strong><span class="classifier">str, default=’utf-8’</span>
</dt>
<dd>
<p>If bytes or files are given to analyze, this encoding is used to decode.</p> </dd> <dt>
<strong>decode_error</strong><span class="classifier">{‘strict’, ‘ignore’, ‘replace’}, default=’strict’</span>
</dt>
<dd>
<p>Instruction on what to do if a byte sequence is given to analyze that contains characters not of the given <code>encoding</code>. By default, it is ‘strict’, meaning that a UnicodeDecodeError will be raised. Other values are ‘ignore’ and ‘replace’.</p> </dd> <dt>
<strong>strip_accents</strong><span class="classifier">{‘ascii’, ‘unicode’}, default=None</span>
</dt>
<dd>
<p>Remove accents and perform other character normalization during the preprocessing step. ‘ascii’ is a fast method that only works on characters that have a direct ASCII mapping. ‘unicode’ is a slightly slower method that works on any characters. None (default) does nothing.</p> <p>Both ‘ascii’ and ‘unicode’ use NFKD normalization from <a class="reference external" href="https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize" title="(in Python v3.10)"><code>unicodedata.normalize</code></a>.</p> </dd> <dt>
<strong>lowercase</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Convert all characters to lowercase before tokenizing.</p> </dd> <dt>
<strong>preprocessor</strong><span class="classifier">callable, default=None</span>
</dt>
<dd>
<p>Override the preprocessing (string transformation) stage while preserving the tokenizing and n-grams generation steps. Only applies if <code>analyzer</code> is not callable.</p> </dd> <dt>
<strong>tokenizer</strong><span class="classifier">callable, default=None</span>
</dt>
<dd>
<p>Override the string tokenization step while preserving the preprocessing and n-grams generation steps. Only applies if <code>analyzer == 'word'</code>.</p> </dd> <dt>
<strong>stop_words</strong><span class="classifier">{‘english’}, list, default=None</span>
</dt>
<dd>
<p>If ‘english’, a built-in stop word list for English is used. There are several known issues with ‘english’ and you should consider an alternative (see <a class="reference internal" href="../feature_extraction.html#stop-words"><span class="std std-ref">Using stop words</span></a>).</p> <p>If a list, that list is assumed to contain stop words, all of which will be removed from the resulting tokens. Only applies if <code>analyzer == 'word'</code>.</p> </dd> <dt>
<strong>token_pattern</strong><span class="classifier">str, default=r”(?u)\b\w\w+\b”</span>
</dt>
<dd>
<p>Regular expression denoting what constitutes a “token”, only used if <code>analyzer == 'word'</code>. The default regexp selects tokens of 2 or more alphanumeric characters (punctuation is completely ignored and always treated as a token separator).</p> <p>If there is a capturing group in token_pattern then the captured group content, not the entire match, becomes the token. At most one capturing group is permitted.</p> </dd> <dt>
<strong>ngram_range</strong><span class="classifier">tuple (min_n, max_n), default=(1, 1)</span>
</dt>
<dd>
<p>The lower and upper boundary of the range of n-values for different n-grams to be extracted. All values of n such that min_n &lt;= n &lt;= max_n will be used. For example an <code>ngram_range</code> of <code>(1, 1)</code> means only unigrams, <code>(1, 2)</code> means unigrams and bigrams, and <code>(2, 2)</code> means only bigrams. Only applies if <code>analyzer</code> is not callable.</p> </dd> <dt>
<strong>analyzer</strong><span class="classifier">{‘word’, ‘char’, ‘char_wb’} or callable, default=’word’</span>
</dt>
<dd>
<p>Whether the feature should be made of word or character n-grams. Option ‘char_wb’ creates character n-grams only from text inside word boundaries; n-grams at the edges of words are padded with space.</p> <p>If a callable is passed it is used to extract the sequence of features out of the raw, unprocessed input.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.21: </span>Since v0.21, if <code>input</code> is <code>'filename'</code> or <code>'file'</code>, the data is first read from the file and then passed to the given callable analyzer.</p> </div> </dd> <dt>
<strong>n_features</strong><span class="classifier">int, default=(2 ** 20)</span>
</dt>
<dd>
<p>The number of features (columns) in the output matrices. Small numbers of features are likely to cause hash collisions, but large numbers will cause larger coefficient dimensions in linear learners.</p> </dd> <dt>
<strong>binary</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>If True, all non zero counts are set to 1. This is useful for discrete probabilistic models that model binary events rather than integer counts.</p> </dd> <dt>
<strong>norm</strong><span class="classifier">{‘l1’, ‘l2’}, default=’l2’</span>
</dt>
<dd>
<p>Norm used to normalize term vectors. None for no normalization.</p> </dd> <dt>
<strong>alternate_sign</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>When True, an alternating sign is added to the features as to approximately conserve the inner product in the hashed space even for small n_features. This approach is similar to sparse random projection.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.19.</span></p> </div> </dd> <dt>
<strong>dtype</strong><span class="classifier">type, default=np.float64</span>
</dt>
<dd>
<p>Type of the matrix returned by fit_transform() or transform().</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.feature_extraction.text.countvectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><code>CountVectorizer</code></a></dt>
<dd>
<p>Convert a collection of text documents to a matrix of token counts.</p> </dd> <dt><a class="reference internal" href="sklearn.feature_extraction.text.tfidfvectorizer.html#sklearn.feature_extraction.text.TfidfVectorizer" title="sklearn.feature_extraction.text.TfidfVectorizer"><code>TfidfVectorizer</code></a></dt>
<dd>
<p>Convert a collection of raw documents to a matrix of TF-IDF features.</p> </dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.feature_extraction.text import HashingVectorizer
&gt;&gt;&gt; corpus = [
...     'This is the first document.',
...     'This document is the second document.',
...     'And this is the third one.',
...     'Is this the first document?',
... ]
&gt;&gt;&gt; vectorizer = HashingVectorizer(n_features=2**4)
&gt;&gt;&gt; X = vectorizer.fit_transform(corpus)
&gt;&gt;&gt; print(X.shape)
(4, 16)
</pre> <h4 class="rubric">Methods</h4> <table class="autosummary longtable docutils align-default">  <tr>
<td><p><a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.build_analyzer" title="sklearn.feature_extraction.text.HashingVectorizer.build_analyzer"><code>build_analyzer</code></a>()</p></td> <td><p>Return a callable to process input data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.build_preprocessor" title="sklearn.feature_extraction.text.HashingVectorizer.build_preprocessor"><code>build_preprocessor</code></a>()</p></td> <td><p>Return a function to preprocess the text before tokenization.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.build_tokenizer" title="sklearn.feature_extraction.text.HashingVectorizer.build_tokenizer"><code>build_tokenizer</code></a>()</p></td> <td><p>Return a function that splits a string into a sequence of tokens.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.decode" title="sklearn.feature_extraction.text.HashingVectorizer.decode"><code>decode</code></a>(doc)</p></td> <td><p>Decode the input into a string of unicode symbols.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.fit" title="sklearn.feature_extraction.text.HashingVectorizer.fit"><code>fit</code></a>(X[, y])</p></td> <td><p>No-op: this transformer is stateless.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.fit_transform" title="sklearn.feature_extraction.text.HashingVectorizer.fit_transform"><code>fit_transform</code></a>(X[, y])</p></td> <td><p>Transform a sequence of documents to a document-term matrix.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.get_params" title="sklearn.feature_extraction.text.HashingVectorizer.get_params"><code>get_params</code></a>([deep])</p></td> <td><p>Get parameters for this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.get_stop_words" title="sklearn.feature_extraction.text.HashingVectorizer.get_stop_words"><code>get_stop_words</code></a>()</p></td> <td><p>Build or fetch the effective stop words list.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.partial_fit" title="sklearn.feature_extraction.text.HashingVectorizer.partial_fit"><code>partial_fit</code></a>(X[, y])</p></td> <td><p>No-op: this transformer is stateless.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.set_params" title="sklearn.feature_extraction.text.HashingVectorizer.set_params"><code>set_params</code></a>(**params)</p></td> <td><p>Set the parameters of this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.transform" title="sklearn.feature_extraction.text.HashingVectorizer.transform"><code>transform</code></a>(X)</p></td> <td><p>Transform a sequence of documents to a document-term matrix.</p></td> </tr>  </table> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.build_analyzer"> <span class="sig-name descname">build_analyzer</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/feature_extraction/text.py#L418"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a callable to process input data.</p> <p>The callable handles that handles preprocessing, tokenization, and n-grams generation.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>analyzer: callable</dt>
<dd>
<p>A function to handle preprocessing, tokenization and n-grams generation.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.build_preprocessor"> <span class="sig-name descname">build_preprocessor</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/feature_extraction/text.py#L321"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a function to preprocess the text before tokenization.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>preprocessor: callable</dt>
<dd>
<p>A function to preprocess the text before tokenization.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.build_tokenizer"> <span class="sig-name descname">build_tokenizer</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/feature_extraction/text.py#L348"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a function that splits a string into a sequence of tokens.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>tokenizer: callable</dt>
<dd>
<p>A function to split a string into a sequence of tokens.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.decode"> <span class="sig-name descname">decode</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">doc</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/feature_extraction/text.py#L208"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Decode the input into a string of unicode symbols.</p> <p>The decoding strategy depends on the vectorizer parameters.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>doc</strong><span class="classifier">bytes or str</span>
</dt>
<dd>
<p>The string to decode.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>doc: str</dt>
<dd>
<p>A string of unicode symbols.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/feature_extraction/text.py#L794"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>No-op: this transformer is stateless.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">ndarray of shape [n_samples, n_features]</span>
</dt>
<dd>
<p>Training data.</p> </dd> <dt>
<strong>y</strong><span class="classifier">Ignored</span>
</dt>
<dd>
<p>Not used, present for API consistency by convention.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>HashingVectorizer instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.fit_transform"> <span class="sig-name descname">fit_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/feature_extraction/text.py#L852"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform a sequence of documents to a document-term matrix.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">iterable over raw text documents, length = n_samples</span>
</dt>
<dd>
<p>Samples. Each sample must be a text document (either bytes or unicode strings, file name or file object depending on the constructor argument) which will be tokenized and hashed.</p> </dd> <dt>
<strong>y</strong><span class="classifier">any</span>
</dt>
<dd>
<p>Ignored. This parameter exists only for compatibility with sklearn.pipeline.Pipeline.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">sparse matrix of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Document-term matrix.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L194"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.get_stop_words"> <span class="sig-name descname">get_stop_words</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/feature_extraction/text.py#L368"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Build or fetch the effective stop words list.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>stop_words: list or None</dt>
<dd>
<p>A list of stop words.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.partial_fit"> <span class="sig-name descname">partial_fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/feature_extraction/text.py#L773"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>No-op: this transformer is stateless.</p> <p>This method is just there to mark the fact that this transformer can work in a streaming setup.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">ndarray of shape [n_samples, n_features]</span>
</dt>
<dd>
<p>Training data.</p> </dd> <dt>
<strong>y</strong><span class="classifier">Ignored</span>
</dt>
<dd>
<p>Not used, present for API consistency by convention.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>HashingVectorizer instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L218"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.transform"> <span class="sig-name descname">transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/feature_extraction/text.py#L822"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform a sequence of documents to a document-term matrix.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">iterable over raw text documents, length = n_samples</span>
</dt>
<dd>
<p>Samples. Each sample must be a text document (either bytes or unicode strings, file name or file object depending on the constructor argument) which will be tokenized and hashed.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">sparse matrix of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Document-term matrix.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="examples-using-sklearn-feature-extraction-text-hashingvectorizer"> <h2>Examples using <code>sklearn.feature_extraction.text.HashingVectorizer</code>
</h2> <div class="sphx-glr-thumbnails">
<div class="sphx-glr-thumbcontainer" tooltip="This is an example showing how scikit-learn can be used for classification using an out-of-core...">
<img alt="Out-of-core classification of text documents" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/applications/plot_out_of_core_classification.html#sphx-glr-auto-examples-applications-plot-out-of-core-classification-py"><span class="std std-ref">Out-of-core classification of text documents</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="This is an example showing how the scikit-learn API can be used to cluster documents by topics ...">
<img alt="Clustering text documents using k-means" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/text/plot_document_clustering.html#sphx-glr-auto-examples-text-plot-document-clustering-py"><span class="std std-ref">Clustering text documents using k-means</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="In this example we illustrate text vectorization, which is the process of representing non-nume...">
<img alt="FeatureHasher and DictVectorizer Comparison" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/text/plot_hashing_vs_dict_vectorizer.html#sphx-glr-auto-examples-text-plot-hashing-vs-dict-vectorizer-py"><span class="std std-ref">FeatureHasher and DictVectorizer Comparison</span></a></p>  </div>
</div>
</section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/generated/sklearn.feature_extraction.text.HashingVectorizer.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/generated/sklearn.feature_extraction.text.HashingVectorizer.html</a>
  </p>
</div>
