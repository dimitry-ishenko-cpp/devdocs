<section id="sklearn-cross-decomposition-plscanonical"> <h1>sklearn.cross_decomposition.PLSCanonical</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.cross_decomposition.</span><span class="sig-name descname">PLSCanonical</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_components</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">algorithm</span><span class="o">=</span><span class="default_value">'nipals'</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/cross_decomposition/_pls.py#L667"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Partial Least Squares transformer and regressor.</p> <p>Read more in the <a class="reference internal" href="../cross_decomposition.html#cross-decomposition"><span class="std std-ref">User Guide</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>n_components</strong><span class="classifier">int, default=2</span>
</dt>
<dd>
<p>Number of components to keep. Should be in <code>[1, min(n_samples,
n_features, n_targets)]</code>.</p> </dd> <dt>
<strong>scale</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether to scale <code>X</code> and <code>Y</code>.</p> </dd> <dt>
<strong>algorithm</strong><span class="classifier">{‘nipals’, ‘svd’}, default=’nipals’</span>
</dt>
<dd>
<p>The algorithm used to estimate the first singular vectors of the cross-covariance matrix. ‘nipals’ uses the power method while ‘svd’ will compute the whole SVD.</p> </dd> <dt>
<strong>max_iter</strong><span class="classifier">int, default=500</span>
</dt>
<dd>
<p>The maximum number of iterations of the power method when <code>algorithm='nipals'</code>. Ignored otherwise.</p> </dd> <dt>
<strong>tol</strong><span class="classifier">float, default=1e-06</span>
</dt>
<dd>
<p>The tolerance used as convergence criteria in the power method: the algorithm stops whenever the squared norm of <code>u_i - u_{i-1}</code> is less than <code>tol</code>, where <code>u</code> corresponds to the left singular vector.</p> </dd> <dt>
<strong>copy</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether to copy <code>X</code> and <code>Y</code> in fit before applying centering, and potentially scaling. If False, these operations will be done inplace, modifying both arrays.</p> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>x_weights_</strong><span class="classifier">ndarray of shape (n_features, n_components)</span>
</dt>
<dd>
<p>The left singular vectors of the cross-covariance matrices of each iteration.</p> </dd> <dt>
<strong>y_weights_</strong><span class="classifier">ndarray of shape (n_targets, n_components)</span>
</dt>
<dd>
<p>The right singular vectors of the cross-covariance matrices of each iteration.</p> </dd> <dt>
<strong>x_loadings_</strong><span class="classifier">ndarray of shape (n_features, n_components)</span>
</dt>
<dd>
<p>The loadings of <code>X</code>.</p> </dd> <dt>
<strong>y_loadings_</strong><span class="classifier">ndarray of shape (n_targets, n_components)</span>
</dt>
<dd>
<p>The loadings of <code>Y</code>.</p> </dd> <dt>
<strong>x_rotations_</strong><span class="classifier">ndarray of shape (n_features, n_components)</span>
</dt>
<dd>
<p>The projection matrix used to transform <code>X</code>.</p> </dd> <dt>
<strong>y_rotations_</strong><span class="classifier">ndarray of shape (n_features, n_components)</span>
</dt>
<dd>
<p>The projection matrix used to transform <code>Y</code>.</p> </dd> <dt>
<a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical.coef_" title="sklearn.cross_decomposition.PLSCanonical.coef_"><code>coef_</code></a><span class="classifier">ndarray of shape (n_features, n_targets)</span>
</dt>
<dd>
<p>The coefficients of the linear model.</p> </dd> <dt>
<strong>intercept_</strong><span class="classifier">ndarray of shape (n_targets,)</span>
</dt>
<dd>
<p>The intercepts of the linear model such that <code>Y</code> is approximated as <code>Y = X @ coef_ + intercept_</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.1.</span></p> </div> </dd> <dt>
<strong>n_iter_</strong><span class="classifier">list of shape (n_components,)</span>
</dt>
<dd>
<p>Number of iterations of the power method, for each component. Empty if <code>algorithm='svd'</code>.</p> </dd> <dt>
<strong>n_features_in_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p> </dd> <dt>
<strong>feature_names_in_</strong><span class="classifier">ndarray of shape (<code>n_features_in_</code>,)</span>
</dt>
<dd>
<p>Names of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>. Defined only when <code>X</code> has feature names that are all strings.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.cross_decomposition.cca.html#sklearn.cross_decomposition.CCA" title="sklearn.cross_decomposition.CCA"><code>CCA</code></a></dt>
<dd>
<p>Canonical Correlation Analysis.</p> </dd> <dt><a class="reference internal" href="sklearn.cross_decomposition.plssvd.html#sklearn.cross_decomposition.PLSSVD" title="sklearn.cross_decomposition.PLSSVD"><code>PLSSVD</code></a></dt>
<dd>
<p>Partial Least Square SVD.</p> </dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.cross_decomposition import PLSCanonical
&gt;&gt;&gt; X = [[0., 0., 1.], [1.,0.,0.], [2.,2.,2.], [2.,5.,4.]]
&gt;&gt;&gt; Y = [[0.1, -0.2], [0.9, 1.1], [6.2, 5.9], [11.9, 12.3]]
&gt;&gt;&gt; plsca = PLSCanonical(n_components=2)
&gt;&gt;&gt; plsca.fit(X, Y)
PLSCanonical()
&gt;&gt;&gt; X_c, Y_c = plsca.transform(X, Y)
</pre> <h4 class="rubric">Methods</h4> <table class="autosummary longtable docutils align-default">  <tr>
<td><p><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical.fit" title="sklearn.cross_decomposition.PLSCanonical.fit"><code>fit</code></a>(X, Y)</p></td> <td><p>Fit model to data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical.fit_transform" title="sklearn.cross_decomposition.PLSCanonical.fit_transform"><code>fit_transform</code></a>(X[, y])</p></td> <td><p>Learn and apply the dimension reduction on the train data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical.get_feature_names_out" title="sklearn.cross_decomposition.PLSCanonical.get_feature_names_out"><code>get_feature_names_out</code></a>([input_features])</p></td> <td><p>Get output feature names for transformation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical.get_params" title="sklearn.cross_decomposition.PLSCanonical.get_params"><code>get_params</code></a>([deep])</p></td> <td><p>Get parameters for this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical.inverse_transform" title="sklearn.cross_decomposition.PLSCanonical.inverse_transform"><code>inverse_transform</code></a>(X[, Y])</p></td> <td><p>Transform data back to its original space.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical.predict" title="sklearn.cross_decomposition.PLSCanonical.predict"><code>predict</code></a>(X[, copy])</p></td> <td><p>Predict targets of given samples.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical.score" title="sklearn.cross_decomposition.PLSCanonical.score"><code>score</code></a>(X, y[, sample_weight])</p></td> <td><p>Return the coefficient of determination of the prediction.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical.set_params" title="sklearn.cross_decomposition.PLSCanonical.set_params"><code>set_params</code></a>(**params)</p></td> <td><p>Set the parameters of this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical.transform" title="sklearn.cross_decomposition.PLSCanonical.transform"><code>transform</code></a>(X[, Y, copy])</p></td> <td><p>Apply the dimension reduction.</p></td> </tr>  </table> <dl class="py property"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.coef_"> <em class="property">property</em><span class="sig-name descname">coef_</span>
</dt> <dd>
<p>The coefficients of the linear model.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/cross_decomposition/_pls.py#L198"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit model to data.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Training vectors, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of predictors.</p> </dd> <dt>
<strong>Y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_targets)</span>
</dt>
<dd>
<p>Target vectors, where <code>n_samples</code> is the number of samples and <code>n_targets</code> is the number of response variables.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Fitted model.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.fit_transform"> <span class="sig-name descname">fit_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/cross_decomposition/_pls.py#L479"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Learn and apply the dimension reduction on the train data.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Training vectors, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of predictors.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples, n_targets), default=None</span>
</dt>
<dd>
<p>Target vectors, where <code>n_samples</code> is the number of samples and <code>n_targets</code> is the number of response variables.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">ndarray of shape (n_samples, n_components)</span>
</dt>
<dd>
<p>Return <code>x_scores</code> if <code>Y</code> is not given, <code>(x_scores, y_scores)</code> otherwise.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.get_feature_names_out"> <span class="sig-name descname">get_feature_names_out</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_features</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L909"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get output feature names for transformation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>input_features</strong><span class="classifier">array-like of str or None, default=None</span>
</dt>
<dd>
<p>Only used to validate feature names with the names seen in <a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical.fit" title="sklearn.cross_decomposition.PLSCanonical.fit"><code>fit</code></a>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>feature_names_out</strong><span class="classifier">ndarray of str objects</span>
</dt>
<dd>
<p>Transformed feature names.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L194"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.inverse_transform"> <span class="sig-name descname">inverse_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/cross_decomposition/_pls.py#L404"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform data back to its original space.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_components)</span>
</dt>
<dd>
<p>New data, where <code>n_samples</code> is the number of samples and <code>n_components</code> is the number of pls components.</p> </dd> <dt>
<strong>Y</strong><span class="classifier">array-like of shape (n_samples, n_components)</span>
</dt>
<dd>
<p>New target, where <code>n_samples</code> is the number of samples and <code>n_components</code> is the number of pls components.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X_reconstructed</strong><span class="classifier">ndarray of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Return the reconstructed <code>X</code> data.</p> </dd> <dt>
<strong>Y_reconstructed</strong><span class="classifier">ndarray of shape (n_samples, n_targets)</span>
</dt>
<dd>
<p>Return the reconstructed <code>X</code> target. Only returned when <code>Y</code> is given.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This transformation will only be exact if <code>n_components=n_features</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.predict"> <span class="sig-name descname">predict</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/cross_decomposition/_pls.py#L448"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict targets of given samples.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Samples.</p> </dd> <dt>
<strong>copy</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether to copy <code>X</code> and <code>Y</code>, or perform in-place normalization.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>y_pred</strong><span class="classifier">ndarray of shape (n_samples,) or (n_samples, n_targets)</span>
</dt>
<dd>
<p>Returns predicted values.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This call requires the estimation of a matrix of shape <code>(n_features, n_targets)</code>, which may be an issue in high dimensional space.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.score"> <span class="sig-name descname">score</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L677"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the coefficient of determination of the prediction.</p> <p>The coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> is defined as <span class="math notranslate nohighlight">\((1 - \frac{u}{v})\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is the residual sum of squares <code>((y_true - y_pred)** 2).sum()</code> and <span class="math notranslate nohighlight">\(v\)</span> is the total sum of squares <code>((y_true - y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a <span class="math notranslate nohighlight">\(R^2\)</span> score of 0.0.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape <code>(n_samples, n_samples_fitted)</code>, where <code>n_samples_fitted</code> is the number of samples used in the fitting for the estimator.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs)</span>
</dt>
<dd>
<p>True values for <code>X</code>.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Sample weights.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>score</strong><span class="classifier">float</span>
</dt>
<dd>
<p><span class="math notranslate nohighlight">\(R^2\)</span> of <code>self.predict(X)</code> wrt. <code>y</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The <span class="math notranslate nohighlight">\(R^2\)</span> score used when calling <code>score</code> on a regressor uses <code>multioutput='uniform_average'</code> from version 0.23 to keep consistent with default value of <a class="reference internal" href="sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>. This influences the <code>score</code> method of all the multioutput regressors (except for <a class="reference internal" href="sklearn.multioutput.multioutputregressor.html#sklearn.multioutput.MultiOutputRegressor" title="sklearn.multioutput.MultiOutputRegressor"><code>MultiOutputRegressor</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L218"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.transform"> <span class="sig-name descname">transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/cross_decomposition/_pls.py#L365"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the dimension reduction.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Samples to transform.</p> </dd> <dt>
<strong>Y</strong><span class="classifier">array-like of shape (n_samples, n_targets), default=None</span>
</dt>
<dd>
<p>Target vectors.</p> </dd> <dt>
<strong>copy</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether to copy <code>X</code> and <code>Y</code>, or perform in-place normalization.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>x_scores, y_scores</strong><span class="classifier">array-like or tuple of array-like</span>
</dt>
<dd>
<p>Return <code>x_scores</code> if <code>Y</code> is not given, <code>(x_scores, y_scores)</code> otherwise.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="examples-using-sklearn-cross-decomposition-plscanonical"> <h2>Examples using <code>sklearn.cross_decomposition.PLSCanonical</code>
</h2> <div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Simple usage of various cross decomposition algorithms:">
<img alt="Compare cross decomposition methods" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/cross_decomposition/plot_compare_cross_decomposition.html#sphx-glr-auto-examples-cross-decomposition-plot-compare-cross-decomposition-py"><span class="std std-ref">Compare cross decomposition methods</span></a></p>  </div></div>
</section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/generated/sklearn.cross_decomposition.PLSCanonical.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/generated/sklearn.cross_decomposition.PLSCanonical.html</a>
  </p>
</div>
