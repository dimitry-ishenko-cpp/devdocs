<section id="sklearn-linear-model-huberregressor"> <h1>sklearn.linear_model.HuberRegressor</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.linear_model.HuberRegressor"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.linear_model.</span><span class="sig-name descname">HuberRegressor</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">1.35</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">warm_start</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">fit_intercept</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/linear_model/_huber.py#L126"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>L2-regularized linear regression model that is robust to outliers.</p> <p>The Huber Regressor optimizes the squared loss for the samples where <code>|(y - Xw - c) / sigma| &lt; epsilon</code> and the absolute loss for the samples where <code>|(y - Xw - c) / sigma| &gt; epsilon</code>, where the model coefficients <code>w</code>, the intercept <code>c</code> and the scale <code>sigma</code> are parameters to be optimized. The parameter sigma makes sure that if y is scaled up or down by a certain factor, one does not need to rescale epsilon to achieve the same robustness. Note that this does not take into account the fact that the different features of X may be of different scales.</p> <p>The Huber loss function has the advantage of not being heavily influenced by the outliers while not completely ignoring their effect.</p> <p>Read more in the <a class="reference internal" href="../linear_model.html#huber-regression"><span class="std std-ref">User Guide</span></a></p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.18.</span></p> </div> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>epsilon</strong><span class="classifier">float, greater than 1.0, default=1.35</span>
</dt>
<dd>
<p>The parameter epsilon controls the number of samples that should be classified as outliers. The smaller the epsilon, the more robust it is to outliers.</p> </dd> <dt>
<strong>max_iter</strong><span class="classifier">int, default=100</span>
</dt>
<dd>
<p>Maximum number of iterations that <code>scipy.optimize.minimize(method="L-BFGS-B")</code> should run for.</p> </dd> <dt>
<strong>alpha</strong><span class="classifier">float, default=0.0001</span>
</dt>
<dd>
<p>Strength of the squared L2 regularization. Note that the penalty is equal to <code>alpha * ||w||^2</code>. Must be in the range <code>[0, inf)</code>.</p> </dd> <dt>
<strong>warm_start</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>This is useful if the stored attributes of a previously used model has to be reused. If set to False, then the coefficients will be rewritten for every call to fit. See <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-warm_start"><span class="xref std std-term">the Glossary</span></a>.</p> </dd> <dt>
<strong>fit_intercept</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether or not to fit the intercept. This can be set to False if the data is already centered around the origin.</p> </dd> <dt>
<strong>tol</strong><span class="classifier">float, default=1e-05</span>
</dt>
<dd>
<p>The iteration will stop when <code>max{|proj g_i | i = 1, ..., n}</code> &lt;= <code>tol</code> where pg_i is the i-th component of the projected gradient.</p> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>coef_</strong><span class="classifier">array, shape (n_features,)</span>
</dt>
<dd>
<p>Features got by optimizing the L2-regularized Huber loss.</p> </dd> <dt>
<strong>intercept_</strong><span class="classifier">float</span>
</dt>
<dd>
<p>Bias.</p> </dd> <dt>
<strong>scale_</strong><span class="classifier">float</span>
</dt>
<dd>
<p>The value by which <code>|y - Xw - c|</code> is scaled down.</p> </dd> <dt>
<strong>n_features_in_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.24.</span></p> </div> </dd> <dt>
<strong>feature_names_in_</strong><span class="classifier">ndarray of shape (<code>n_features_in_</code>,)</span>
</dt>
<dd>
<p>Names of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>. Defined only when <code>X</code> has feature names that are all strings.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </dd> <dt>
<strong>n_iter_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of iterations that <code>scipy.optimize.minimize(method="L-BFGS-B")</code> has run for.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.20: </span>In SciPy &lt;= 1.0.0 the number of lbfgs iterations may exceed <code>max_iter</code>. <code>n_iter_</code> will now report at most <code>max_iter</code>.</p> </div> </dd> <dt>
<strong>outliers_</strong><span class="classifier">array, shape (n_samples,)</span>
</dt>
<dd>
<p>A boolean mask which is set to True where the samples are identified as outliers.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.linear_model.ransacregressor.html#sklearn.linear_model.RANSACRegressor" title="sklearn.linear_model.RANSACRegressor"><code>RANSACRegressor</code></a></dt>
<dd>
<p>RANSAC (RANdom SAmple Consensus) algorithm.</p> </dd> <dt><a class="reference internal" href="sklearn.linear_model.theilsenregressor.html#sklearn.linear_model.TheilSenRegressor" title="sklearn.linear_model.TheilSenRegressor"><code>TheilSenRegressor</code></a></dt>
<dd>
<p>Theil-Sen Estimator robust multivariate regression model.</p> </dd> <dt><a class="reference internal" href="sklearn.linear_model.sgdregressor.html#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><code>SGDRegressor</code></a></dt>
<dd>
<p>Fitted by minimizing a regularized empirical loss with SGD.</p> </dd> </dl> </div> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="re4616ef910fb-1" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span> <p>Peter J. Huber, Elvezio M. Ronchetti, Robust Statistics Concomitant scale estimates, pg 172</p> </div> <div class="citation" id="re4616ef910fb-2" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span> <p>Art B. Owen (2006), A robust hybrid of lasso and ridge regression. <a class="reference external" href="https://statweb.stanford.edu/~owen/reports/hhu.pdf">https://statweb.stanford.edu/~owen/reports/hhu.pdf</a></p> </div> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.linear_model import HuberRegressor, LinearRegression
&gt;&gt;&gt; from sklearn.datasets import make_regression
&gt;&gt;&gt; rng = np.random.RandomState(0)
&gt;&gt;&gt; X, y, coef = make_regression(
...     n_samples=200, n_features=2, noise=4.0, coef=True, random_state=0)
&gt;&gt;&gt; X[:4] = rng.uniform(10, 20, (4, 2))
&gt;&gt;&gt; y[:4] = rng.uniform(10, 20, 4)
&gt;&gt;&gt; huber = HuberRegressor().fit(X, y)
&gt;&gt;&gt; huber.score(X, y)
-7.284...
&gt;&gt;&gt; huber.predict(X[:1,])
array([806.7200...])
&gt;&gt;&gt; linear = LinearRegression().fit(X, y)
&gt;&gt;&gt; print("True coefficients:", coef)
True coefficients: [20.4923...  34.1698...]
&gt;&gt;&gt; print("Huber coefficients:", huber.coef_)
Huber coefficients: [17.7906... 31.0106...]
&gt;&gt;&gt; print("Linear Regression coefficients:", linear.coef_)
Linear Regression coefficients: [-1.9221...  7.0226...]
</pre> <h4 class="rubric">Methods</h4> <table class="autosummary longtable docutils align-default">  <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.HuberRegressor.fit" title="sklearn.linear_model.HuberRegressor.fit"><code>fit</code></a>(X, y[, sample_weight])</p></td> <td><p>Fit the model according to the given training data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.HuberRegressor.get_params" title="sklearn.linear_model.HuberRegressor.get_params"><code>get_params</code></a>([deep])</p></td> <td><p>Get parameters for this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.HuberRegressor.predict" title="sklearn.linear_model.HuberRegressor.predict"><code>predict</code></a>(X)</p></td> <td><p>Predict using the linear model.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.HuberRegressor.score" title="sklearn.linear_model.HuberRegressor.score"><code>score</code></a>(X, y[, sample_weight])</p></td> <td><p>Return the coefficient of determination of the prediction.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.linear_model.HuberRegressor.set_params" title="sklearn.linear_model.HuberRegressor.set_params"><code>set_params</code></a>(**params)</p></td> <td><p>Set the parameters of this estimator.</p></td> </tr>  </table> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.HuberRegressor.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/linear_model/_huber.py#L265"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit the model according to the given training data.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like, shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Training vector, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of features.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like, shape (n_samples,)</span>
</dt>
<dd>
<p>Target vector relative to X.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like, shape (n_samples,)</span>
</dt>
<dd>
<p>Weight given to each sample.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Fitted <code>HuberRegressor</code> estimator.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.HuberRegressor.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L194"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.HuberRegressor.predict"> <span class="sig-name descname">predict</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/linear_model/_base.py#L372"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict using the linear model.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like or sparse matrix, shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Samples.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>C</strong><span class="classifier">array, shape (n_samples,)</span>
</dt>
<dd>
<p>Returns predicted values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.HuberRegressor.score"> <span class="sig-name descname">score</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L677"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the coefficient of determination of the prediction.</p> <p>The coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> is defined as <span class="math notranslate nohighlight">\((1 - \frac{u}{v})\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is the residual sum of squares <code>((y_true - y_pred)** 2).sum()</code> and <span class="math notranslate nohighlight">\(v\)</span> is the total sum of squares <code>((y_true - y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a <span class="math notranslate nohighlight">\(R^2\)</span> score of 0.0.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape <code>(n_samples, n_samples_fitted)</code>, where <code>n_samples_fitted</code> is the number of samples used in the fitting for the estimator.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs)</span>
</dt>
<dd>
<p>True values for <code>X</code>.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Sample weights.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>score</strong><span class="classifier">float</span>
</dt>
<dd>
<p><span class="math notranslate nohighlight">\(R^2\)</span> of <code>self.predict(X)</code> wrt. <code>y</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The <span class="math notranslate nohighlight">\(R^2\)</span> score used when calling <code>score</code> on a regressor uses <code>multioutput='uniform_average'</code> from version 0.23 to keep consistent with default value of <a class="reference internal" href="sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>. This influences the <code>score</code> method of all the multioutput regressors (except for <a class="reference internal" href="sklearn.multioutput.multioutputregressor.html#sklearn.multioutput.MultiOutputRegressor" title="sklearn.multioutput.MultiOutputRegressor"><code>MultiOutputRegressor</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.linear_model.HuberRegressor.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L218"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="examples-using-sklearn-linear-model-huberregressor"> <h2>Examples using <code>sklearn.linear_model.HuberRegressor</code>
</h2> <div class="sphx-glr-thumbnails">
<div class="sphx-glr-thumbcontainer" tooltip="Fit Ridge and HuberRegressor on a dataset with outliers.">
<img alt="HuberRegressor vs Ridge on dataset with strong outliers" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/linear_model/plot_huber_vs_ridge.html#sphx-glr-auto-examples-linear-model-plot-huber-vs-ridge-py"><span class="std std-ref">HuberRegressor vs Ridge on dataset with strong outliers</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="Here a sine function is fit with a polynomial of order 3, for values close to zero.">
<img alt="Robust linear estimator fitting" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/linear_model/plot_robust_fit.html#sphx-glr-auto-examples-linear-model-plot-robust-fit-py"><span class="std std-ref">Robust linear estimator fitting</span></a></p>  </div>
</div>
</section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/generated/sklearn.linear_model.HuberRegressor.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/generated/sklearn.linear_model.HuberRegressor.html</a>
  </p>
</div>
