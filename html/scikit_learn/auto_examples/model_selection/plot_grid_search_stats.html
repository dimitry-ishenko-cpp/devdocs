<div class="sphx-glr-download-link-note admonition note"> <p class="admonition-title">Note</p> <p>Click <a class="reference internal" href="#sphx-glr-download-auto-examples-model-selection-plot-grid-search-stats-py"><span class="std std-ref">here</span></a> to download the full example code or to run this example in your browser via Binder</p> </div> <section class="sphx-glr-example-title" id="statistical-comparison-of-models-using-grid-search"> <h1 id="sphx-glr-auto-examples-model-selection-plot-grid-search-stats-py">Statistical comparison of models using grid search</h1> <p>This example illustrates how to statistically compare the performance of models trained and evaluated using <a class="reference internal" href="../../modules/generated/sklearn.model_selection.gridsearchcv.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a>.</p> <p>We will start by simulating moon shaped data (where the ideal separation between classes is non-linear), adding to it a moderate degree of noise. Datapoints will belong to one of two possible classes to be predicted by two features. We will simulate 50 samples for each class:</p> <pre data-language="python">import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.datasets import make_moons

X, y = make_moons(noise=0.352, random_state=1, n_samples=100)

sns.scatterplot(
    x=X[:, 0], y=X[:, 1], hue=y, marker="o", s=25, edgecolor="k", legend=False
).set_title("Data")
plt.show()
</pre> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAMAAAACDyzWAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8qNh9FAAABy1BMVEX////9/f35+fnj4+Mfd7T+/v77+/vx8fEAAAD/fw7X19f+fg3t7e2/v78edrMODg4edLDp6eng4OAcbaXQ0NA6S1j09PSvsLGfn5/a2totRlcrQVD6fA1sSSoGBgb39/fU09MzSFcdcaskSmQmRFjHx8caYZJJVmDe3d3v7++tra1AUV1PXGRmSTAzRE9oU0GakIh5SiLMy8u1t7iFeG3FxcS9u7pWYWluTzVdRC5eXl4aaJ7n5+cbWYQaXYsiTWsfT3AnSF4cVX7CwcF2Zlh/cWV/f3+gVhRvXEyUiX+BiIz0eQ15gYeKjpFgSTZmTzpxYFEaZZnOzc3dbgyNgXdAT1npcwwlJSWYUxeETR1tWEWLTxufpKYXFxdwRiF7bF8cUnc/Pz9hQienq61KSkofHx+FhYXtdgyuWxKxq6ZaZW1wSCWXnJ/OZw22sa1ye4C2XRBsdXvWagtnQyQqKSh4eHiSURilnZc3Nze9YA+nWBKVlpfKZAuqqKaOk5eqo57lcQyyWg1ha3J+Sh2gl5Blb3Vubm6cnJwwMDBmZmbFYw5xcXGIiIgNM04VQ2NTU1MPLUJqampeaHBHLxl0Ogi3tLJeMwwXKDQ/RUnqyNJ+AAAgAElEQVR42uyd608b2RmHx/aMmVi+X2M7wTewMfa6DU5wF9/thiaunSxILhsFtEZcklq0iHRpq7KhFRKbpAmXjbTa/rmdOeMA0RoDYWaOsX/PBwI28bzMPHrP/RyGAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHARt3meH11aXrd99mpw1o5bA9QR8PZ4dfK9xTJ99tVJ3oRbA9QRcEr8x75myZ2+yEFAoK6AzAo/y0wdrY2uHdmlcpnnbzPTq0ujC+9suEtAcQHd/DIzOeupvl5esjG2dX5nfNzG7HzwVG+/XdDiNgGlBWSWvif/6N2W3bN1QE5v5z24TUANAd3bC2LR++5EQNu7NfGFD7hNQI0ieHX0w/TU1NLMJwE1b5d2TVPjQu0QAIUFfM2vx4lpAf5EQKfQDmEYLwQEigtoX7PYRkhZuyMK6OHTwrdB/rXw9T0EBEoK2OmIFlLesuXN9OySRRBwgj+qThm1C2uv0z8tQECgpICnQ3G6I4tlNbgmCMg01sR+QMP/LJYjHQQEAAAAAAAAAAAAAAAARdDo4iNgeIjrNP0loI4Hw4WuvwSM8zqkhSFCx8f7S8ARfgT1kCGi7543BISACAhAQAABERCAgAACQkAAAQEEhIAAAgIICAE7aEyL2FASAlLDmWoVIhnsYQUB6aD1W1mWjW5BIghIhcU8K+LTwCIISIN6lghYDsAiCEiD6RYRMMTBIghIA87lEPyr7EIiCEhHQGOyXPQ14BAEpIZxAp0wEBBAQAgIICCAgBAQQEAAAXtTXV06OQXIRBbHGyAgBFSP9PbkGQG9uVxODwEhoKqcETCOIhgC0hRwbWn50wl9AbJXCASEgOoJaHgzP/4TX5V+mCUVQggIAdUTkLC6OgwZ0LiVSNTdUK4PBVz/fgjqgPFUlmWjLswe7EMBj5aHQMDNOXH2YGEHzlEX0O108g2nndmeYZiGxxvc5ieHQMAEmb5qjsE56gJKnc8zzIyQ+D4sjFqW0wwEhIAU4YZBwEZBFLCyAuf6T0BmGATUNvNmayuJNXQQkBL6xWTSA/8gIMDzhoAAAgI8bwgIASEgwPOGgBAQAQE8bwgIAREQgIAAAiKgKxEI5iATBKQFV/eVIjEoCAEpURO3i3a4sFcqBKSTAENksmkrDZ8gIA3cZSLgXA0+QUAaaHxEwIoHPkFAKmxGBf+sKT18goBU0LfL+VLKAJ0gIC1ynim0gSHgWXTtkGs/jicMAekElPM7WDabwk4YEJBOQPvkJLdC93OM5tvJDagJAZUMqNdGBLVI2FxIGfH0IaDSAlqTXd6aiIhvOdp4+hBQuYCknTBK3UbHNqVzVkN4+hBQuYD0sZY1XNzv1jey75BOmsbTh4AKBqRJZ9rjXd+plkjpjH2qICCdgLikUDyH/UE8fQhIJyB9o+nKePHwISCtgDBqBgFvTEAAAgIICAHl/BtrsaQJ7kFASuRSUdZa2oR8EJAOGdIRHkEzHALSQVpBkkUKhIA0BXRswT4ISIVkWBTwMOZybeLsQgioCNz4Px6c29vt9TtYc+kXoSY459JCwEERUNfun4xie/LtD394cu5eMbq9RCJFWiL5RQg4IAKSNSD9klF+8+LWrVsvnvb6FZc0YzsJAdUXsLq6dHpcq+nt6NqODAF97KOMYn92S+S590IBrRkIqL6A6e3JEwEnRn80vBmV4bjWK2YU+4ZHuWQ5/i8i4Mteox31KJmxbYKAdA+s3hYPS3/3T7kEvGRG0XyMFPJ+xTazMt4jAt6z9fidQLNiDZf2OQhIV8DlH4Uvk6Paawd0pYxSExeMmP2KrYv77gfBv7981/N39CvJ9gOGgYB0BVxYF7484KUGY2BkZET3hQFdKaNI+/lFFdtOTX//7vO7D7XQ64YJOEuOUv/CgISMkqlyvX9jf1f6cGkswqrgwsyADgvfb14RfJ0MeDG2VCUc9ZMyumlWosnMGZHzhrcRcjExB6n4iZJ4isK34ZS8vmyEIr42xtZugIBup5NvOO3M9ozYDfNenm6Yi//S8pltTBdDkXJMJ69/4mLPbBPLTfpfQBOp6s0wM8uMfB3RF5KLSC2PDam41Mm8c1tno/ISGrY3ogimEJBGMiQyoVBax0blEPCCMrIoND0KSrV89VLLWuaGjdsQh4ADE9CKyxeqK7aR+N6c2LPjl7P3Rb/lK5Uzbgg41AFdlkCsOJf3y1oF3BIHbLIxCAgBL8V8Y0XWjh23VKoXvRAQAtLAQHbxMhdWICAEpEFcaliXpiAgBKRCRtzKNTzYh3BCwD7GHSsWSi4dAwFvfkABk+n6HSSa3aYrqeqBXN6VQT+AaUgEXPS1Kr5r9xFn8mY2PHZSJdPXQ75mr2nV9kzItYXpCRCQmRfHgc2Ra9bmnUUyizBx4mNU/NDz26g6f/hKC/V0mxnlj8/RGjUQUPWAMmQvgvDZBSN6+5UHuTrHO/g6haKhKJ32cG4Z2ZYW6t2+5MevjGXNhZSyNb7Aw7vPvnrMQUCVA4oRVdjE6SsboWI5lrvap9TmPjveoUFWobDlc0W+2kI9t1+cJRtWdtzjm1fiar3HEFDlgKRcFJYmInCTsYRLLJMdVzxhWkf65Ryf8uhiXvLx3FKzyf4q7/aqpkofV1ayzuh9Tpbr3dVCQHUDMowJ2cU8JjVgt1pW1nEsZrPKFccYpDPmbJ+lLMe5CY6rkRRZvOTw8K6UUCNKHmH37/8SAf8+AQFVDiidKpVCUoNVOinOevAlO6Q528nd0wzl8UfD+dT5i3+1iYo1XLzsNaS4zIp2O1elFfP34hBQ7YC4YLDzZOtSTe5AnBy4c70PNdb2VnqV4pwn8/HyLe+PQhlsjXiUvLmar+8I/v3nEeqAFAPqNCWOW6zV31d9dJqGK5RQeKsOw9cvX337NA4BKQZkJ02J8MHhoX8I12/of/7tA46BgDQDqh9a2exx1prSMwACUggodXBw6GBZ19na2nA8bdu0k4OA1APayn4+pMakXT7f3uCP2Wr2y5VSygABaQekE3sF2dJJezMdEX6eG/wl5XVxiYk1pYWAtANK+1sV3+kCXhfZKaY16HtFdpbO51cgIPWA9Kb06VU4Oc7tGE8mkn0+dV4rzfDP1iFgnwUkCRhtXOMjNiJhNlzu89VDoTOb40DAPgqILClnr7NfqpY4bO7zjp1GnuwJpoeAfRaQu9lyRP3XSV/VlrR+bV6W+kF68ZxJgbmMz5dwfnklsO5rRZo6BgL2W0CcaatxrUkoDzoCBmUIpuqvFCJ73aYtu8XDbaz+a6xTd0/Z+y0tQ0BZklZKbEibQzL05IyQSV6FbptsSTNgw4N1tAgElIWVMQfrGJPj3IfOPOtQl7eS0rxuFwSEgL/C8DG2J8s0z/3wZ/P+z9Imb5mbEBACKsdiRZot1uWtKTJlNb8LASGggk3yX8Q8d3jcbWi6Vp5zFDMaCAgBZWi3TO7Vus3mdx4eHBwetyrT3f6Trr45r2BM3oe//6sGAlIIiHOaVJ4MY0xVwnNjXfoevUXWkbWyLQqTZR8/+9Odl08DEFD1a06lShWfukOkGbJQ1N/lb3VZKQ2qGMghs6/uQ0DVL+kXn3lrQ8VLaqTx526ropz+KDvnpzA15+ELsmTuKwio9iU7XW9q9q8FesxMMdaSmzYKd/6bO9KqdQio9iUz1nP7fhVDmoNYnO+jO//nl6J/f3wEAdW+pLQngVnNDMilI4L10aSyF9loumLjl68WPHkl+Pc3AwRU+5JuqQ64yKhqYNMX2lR2dvxWxcxay5cfH3Tf/93dR0EGAqp9SS4YKrZ8A3fGVq6s/F4fEFCuLojxwTtfev3goBRm2YgNAv6fvTP/S2Lr4/goII4sIZsPigIKLomCSAKFO15wCVzQFHzU7FaaWi6paV537Wa3bmXL8+c+zDmDmrEOAwzD+fzgC186cGDenHO+3/Ndbuvt06q/e+FD2DmzhMHfiFzVvl4m7vgsi1G/MG8B/KvqXcn5HSkJoMrpdBblFYCa6VdlaT/xcupBptXH6kYMAXhLb96HfrzeJAFsYPiegHaNVnz6+PlnuiPjSefm54p6BOAtFRYTDdLPH5MAPv3v47DbX8Pn8zlsB7Cg+WOXRNz+M82Hz0OwoPVHIUPetvJ0dlvDDAA5xcRB+7NHcPf/btTwpZjcEP4BNoQsB7Dt0yeQBbqW3pfRwpL+TIletczvDe446hkCoOEaQKA//8yjGXD6M4x5bk7z69jaudxqvYEZb5oHKmMO+pi3BEOHwessDah0YE2UaTeZ9Kc4I0fPvIcKhVHOkG+dwQ3OmYNSZhghX66NEKB/H2dnQNP6WtnceBQPoHNgrTctcP4PBN3LvmJ5pNYjAKBbzggACTfMhztSbPN+yFgrU2k3wZSY+QFBT8VI5M3Ysn5ENleXDve05mfIQJVVOPMJQGELjLTRMALAsCP6fmji++dR1Z3HrdkZEFmuPGIUDAfAWfsqHa+rGVIojvOKPwyzruK4wG3GmAFgLGVwQMfRMyDDbbl0GBI9O1Jz05LvAEMA/rIx6YnuqXghiQ4ns+7scmOjTZUjFCIAf1GBIjTNSbp7I/2trOdWGV+m6mu7OLShlGO5qryOhlEel5ePR86+KAJw6tOWm9brCfjpOKQg/c11CEC2DYhPwNmbrmf3b6nxsXkajmlvtZBFALJvQDFUZDbZrVTmMekJSL8I0GbJIwDzEcCCwI4AH3NQCPjsXwdusaXUsSFbyBoxBGD+AfgSpJEdzgIDb9FkdyVc/dE/BgGkISpwoKaaW9vMZK9igbaEhwBMh8hEWjvx2Lqrxp9vJGqMqkARArWJjlFYbHUDDP7IeC+bJreaehGA6QVQmiRRfbsCfGJDi7FfoycCHBfMSBGA9KsNhHiMWW9s6hLNs+QtBuyznDzgDxseJD6YiT4EYBpWF1do3d3zEuM1kwCysQFn0V/DfdSPWuzgg8EDCMC07G88ATMRWs9zttDlV2GemepdVU+cmKle7gH7lOcuBGB61b81SI9nmXGaBRZ7C9X+Dr3B0NWClhIEYJp1bzhgLWUhf1glWELH/FSvP608WthYRFZw7stSp1MMFGUJwOd9lJ9A0yYqxBCAOSEnJ7rLtlcv4XI7Mt+lxgQ2cW5RvtzvXAdQZaEcxm9R1HTqohazGgcRip3aTL+h0ZlBHF8x8RCAuWAWl3iD7kqKFiOHqBIn1kchrEifrW6/ck+l3V+IIQBzQMp5Yr1yH1C6eO1BrFZwPBq6GjNROQJg6YBtOQcKqJ1eEPslgY/SxXWwFVy0IGxYV19figDMwoBaK0YkHc1Sxn+arlTqfMNWcFGDm0ubO8Sy7mUMAZj5ARWCFqbVzE/QMK+kMAPKQWhfZ1QrRLNsPGOfpzsnAITpa9xuxi8/fLAHXDildvVyeXs7+yoFswHA6Q4AYCfz12CLd/JoyU/VZaG8+6QBQwAyb0Cw3DZXlwN9InkWEfUPVPnQNiREADJwQGftXK64c5rl96KkolacSJMu1as1CwIwowPiPVToxsvYPhkk2KbwVc0DWeeLAgRgrgyoKEfulRQ0ROfOxUlG7gWp6O3LCMDcGFCrQl9uy4mNlbYLANgTbaYvtYC3YQPuQnGGfVK8bVN6cgjYDqCoW8zlyppzIVS+SAedTZENYeVwi7vFpYl7YJImuVYF+GE6Am7ZDmAjiCFpf5ILU+Byp5gr7olSktBDBCavuzBsoDYLBVYtk+nqpMl2AOGsInnBROA0t0NMysZ1iuXITkSY94m3CDF+s4zLra7IrE+UbGZdiQCkBmAWgpji6p6vZSmQ8K4qXGR5FMOctvLyOrqaqvK/tyUSaWWdQABS0xBYsPTMK10hnxGE1jRHou1qVEE4A9J8Gtm/tLow/zL+/5UEY+e2IQCjqdDY+aBWz0AXtgckbK+YE/1/EzEHjQ3TO4iXxNYuRtmCG1PgpBpfdzgRgMlrdGifiV4YMmE74W290BRcnfJcTZgcm05nS5kHmO9xmEjCUZsn0M/HEID0SWtUjC9TDBsoemI0tqaWJeETgEVtNvErVK3XM5WwImSJyH5+z/C3AAFIow2gr+aK24+pret1PRLJnC0lAk9XiVt/QtGYAIVRxSOvtal9CAH1VXUbBGCGBwSTzGoouVYfgvCwubupvD5vdmp9b4aIHBQ16hRvk4S5EXqjLyPvCTV+u92ViIF9j3DuqDdKEYAZH5AGJpmNUIr/hLdfkmJZ0vr+U2JzWlYjCU3FZ8ldWwf6zYkv7RE3CKaV0OI+n4incLFpK+gdxRCAGR9QEZlktk8dQHHc0vSa04Dne5y5jacDLHUnd846PUdc1LUbsSAhrNyamM+koESaF/ebeQOqq6aeZAYTKDviwcv3XgjUu67YBDphDExHctEtvLpP1dX6Hwvbkf54s3Ir45W3AHIqarmyGkoTICZsDhE4ooiXJ2oFdaXcscOrGmC0d9Kn1ZuPLnen+iLC7RpEAMYW2awQSPR31dO32RgQf8D4laoRWXqmULyKe4gBnBwC9XCc9ZyYisUVyqS/BafmKBaUZYt44XUrAjCKiHat53fg3qO+6rzkXdXdLH8j0iPoZYsHoLSiQ/xAT2u4jnVrULDjVSIAo+jNe+yqYfUm0Sz9/RtWAjgLTvAX4h21KveNazSHehpcnoNCDAEYWYWgP/U57JL++Dz0425VIRsBdDoOcfzCxJbsDdYAyCkmWgA+ewR+efQs9ONeMTzV1PD5fA6L6gOW9tlN5kzPRE6RCgEYB0BDFAD/KCaEKqRSuY8PbQOEW1vzorunc7wUAUhpCWbbDBj3q2igK05HC1KKQyvLMdG8UDaOAIxphHzJDyMk3gJtmtpt6aMnXYpMKS5QwgOerlEEYAwRbpgPd6TY5n3CDfOBtW6Y2OL5CCN5jxZvXX0nTCk2qOCDjmkEYCyRjuj7xCqcNUd0tgUTzfBKinU3OVaP/2qrJydTilvJGbBTjgBkzYDSpe09AGCQmguwbeYQH9swhLfV5eGU4rNasAfkn+l0xutYQ565qdIXyR/p7LN7zTx0v/MRQIMbtpejNAMWOYiAarU3zM5+F5FSPBRC8bh7rqbOqXhApG5eETi7g+OCrd9LV0vnD3HB0eWNIz2evE2IAMyPPaCXyLVdodYAxrAL6N26QuwJkVIMHgkNHGy6/Zd655wT8N9Nv7nEicwogWDr8spXqfJOHrX0FSAA80FOX/CoxUXNTy1agGnCUfZ6RjEsqEj+enABV/vfQv/ILkg/Dq4mViKQ5sKPAMwPqURU89qUEJ2mKE6cryDYkasgf/1+FC6rEBnAb2FTfHEVPi0PAYgUW+ZJNa4Obkf5qxxEudaG60EUzhM7xsHfw6ddoOJG0B1+Hv8hJLVQOhvwtCEAkaLrpckeiI7IUI1s7vWPylkyJKttY1294/jd3nZeruNq9zdH2BCCwfx4k2FjAldP9iMAkSiv7v9+C816Y6DFm/J02Gp1bUcytxsclz++ebXYL3vA1X6fOh11QBCA+SSY+E7kA0gdF4KxmWhRicI2+Y0dH8cUdC/5haD/O763jQBEoqiCJcDQYci8MBGzmmA+QX+j1KLEGiCAFwhAJMqCBu6KOUzT6mIy0ydYgpeECMBUVL8/rcxfAGeJlDzBRgPmnEp+PZVvHOKDQTMyQlJZg17U1HZUlOUtgEqfe2JlI7Tz4zUBAE+SOnPm9AU89yJ/riX1CMBENEDUbxEzsDJlpsQTWc2g3vniVGhBXSWP/JSG1PhZbJoMei15B6CoTtGY5GSmgLVfhjCkNlOlD4a88PxLu0FfCgjSX80oN5oV1ki4kq7keoWT1cltiL8bMhNHbYMO6lHY9NdzywUAyQYa5UmZFLD8Wvt/EHU31JS8Qfyr6K9omQsAhlsIJXU42VoDOtQUIupuGBDXzkGKSqKmL4sAJBMd4jVRu6UyXXe50YmowzDncGVlQHs9A+4cUH6qxKuaswlAni6xNpK3LxNqcgMQjTat3xOl4zlhOBCmR/8OYUM4UlgW+peOEurrwC4j5P/tne1PGtkegEe4I4NAiIRQzQWGD5dEzRLAaiMs33yDmFWiBFGDpobWGmJvb9v1bdvYRrPb2iZNs7V/72VmELFVtwVnBpzn+UBKNcxvOI9nzuvvRP/9679+/c/9O1pB5UKllbhdt48XEzuNfJXiWPVtab6tzAmOM49NsJqAQua/v/zPd0f9O1FW12+l9DtOcdXZlC7Q7YmInV/eBNRNPdN/QstX6Yp35u0joNk903VVwKJ+6SRH1WO2np0gIAJeXwO20TP9RwrHS8XdqR4ERMAr9VC2rAU39eyx+wpjHZssBgHNRtxIPptNRX7gNzOF/Mmtetr7NLFIeVtdwJpYZ9Ef6Zk+XV9ynaZucbzGn3r7vBQPUN7dJaBvOpszI0RZ21u52vRfk9mJbOtLo3pTyrza0hTl3VUCbq+/ce5sDplwYW3TePLi69lbCzrnjlsev3n6to3kNAhoEoEXzqv3eOtOPZvWSmPaTla3fbhirQ5hazMkzpV+yruLBHx9oNVDw4Zf2b7yTdqMen6YUqu5ABdL16QsarZ+IbRwhIAdxHf1kHEoOdaCaxdP3HEtQ1Yp0uoHxpV9S4eJGzrouUOX0zWbQ0CD65qNifjJNfWClunMFTNhQlVMLITiTWsie2Ou9kIJTFVXYombfqHaVhJXBGyNoc2i03WQv6Zcx564nMHjs47oDyW3nMX1dnIIyf03zo9Mag/5wygCGklWnbwvjV9TD+0tTKyOd8Z3NbixuqHnIiF/6Zs0mAhoBPWkeRuC5RHng5cSASOggQIWp426XgefJbe4uRN8tRkRENBIptRDLtf0eu6Ii81pwMVErBrLdayDjsRUIiAgoKH0p3acwZJe6/P61DTgjYdaQWnnH0wLlgUBrxh9SKzmJ3X6bFmdgD3IXR7oSLoRkIAM4UibSYnV345qh4W8fYCABGQIY2oD07leb/X51tqbTkNABPw5zg9C0O7Vc39+TveBDgREwAu0NOBPEoKyHvTrl69f/35bPEj1CQhoHO6015s+X02SVs5I37eOgIJvYW02VKjVePbNWnck+HU2P3Zk5QQ2JpR35WU0+rJyLmAlk8m4LSRgTcFFdWRtWj0UpvglJlga48u7T4oKQlSqP3XSn6z1CL6gnrDgSxUBjeUvr/LqrSfuS3vLy+/7rShgVs10FqQGNLq8Hy8rr8uPtXevzyL33r2sLziTHQ6H3SoCenbVAZjjPQQ0ghmpzmhdwI8XP8uER5p/ySrbMnPrr3a+/J0TENAI+vvqyJcfwUKzjZaqAWvfyUnBIwsIaGonRMEdHrBgGxDMKu/Ku2j0nTIMszwiBD5EfZ79sgMBEdAwGgPR0oAgV8rhR2m7gIAISEBAeVtJQHeiMIqACKg/g9NTD75f7nK0vvOmlLUhIALqTG6lOHcY/9a0zLrT6XLuFBAQAfUlouZ0+c60wtKlpdEISEA6sbHVdErCBVNBLe0FAiKgvuRdVwqoLY0OxhEQAfXlSDVt7tsDJnvn39QagceTCIiA+mKbr7X25l58t+p+eCpUXXggICAC6n1H06FQNnLFD8TbOp5L7kFABDSN7VgytBFAQAQ0BXF7t9bLWYqLCIiApqDmSb02nSECIqDOfZykOsrzpoCACGgGPVo6w9M9BERAU9hQ5vRcmwEEREBTCMRLS6ebXTugiICd5FJLW5TE8cLe5frPf8+HgAj4s3gWktXVWzgM0z5fOljJGrHdzuYbRsDuRt7LTw9q/1xcdzmdc6m223KimvHtuQGHYOZCu8msGwG7GPf8gWvr+ET9t5aqYyfRQpU3NTEx1hA3qiVdrereK0ko6a2L7aY2REAz0RLyJ9WD5ya0ZEXZn/dvc6tW482fL7k+OtVOl9H7RFkxpl5n1oOA3Ys2hvdcTc+x4GrxeBLN4oPzQy0ju/of8Kb2mLQR8KUcAnYvWo78onokxIm6bvB48Kc/RKs6XY2qM64kHjwd0zv2Xu2v59k2AnYvcbXdV1J3Z4obK89Pqy1MaGgCzuXP3w9nk6XqWK/uwU8/V5Z0p2wI2LWIo+u1Huvped01lNhrZVijoJ58XmpaW+2OGDEvYsuvnB6m/AICdjH+7MRErs3KSo4/Cc7tmnHY0tDRgx4BAS1P79P8VLRbg0dAoLwREAEJCChvBERAAgIEBAQkoG5ie6EaGrMhIAKaw5GyNXgni4AIaAr1hVFrEQREQDNwH2uruhIIiIBmIGurug5eIyACmkK+qG4NlhEQAc15Bs8/2Xr1oju3BiPgXaDnbCzRpV8bAgLljYAISEBglfJ+vB/2Nt6IM+XwwwgCIqBxzPz24ULAj96RyCfOC0ZAQxloCCiWPwqC7P0DARHQFAGHpMXaayWtvZMdDocdARHQOAHHJSUf2ftK/eEsKSAgAurQ8JPqjH4jYKZJQGpABNSL/r468g2PYNqACGhGJ8RGJwQBDcTnn/H6/QFBWB7RhmHSDMMgoIGk1bagRxCkAQaiEZCpOKC8ERABCQgobwREQAICBAQEJCBAQEBABAQEBAREQEBAQEAEBAQEBERAQEBAQAQEBAQEREBAQEBABAQEBAREQEBAQEAEBAQEBERAQEBAQAQEBATKGwEBAYHyRkAEJCCgvBEQAQkIKG8EREACAgQEBCQgQ+nxHA0hIAGZhBhJHZ6u5G0ISECmYEsFnU7nzjQCEpApbD9zKoR6EJCAzCC3pAqYDCCg3jzeDzeOa9VOLtxHQMEzqwoYExFQb2Z++9AkYCWTybgRUBDnizX/niRoAxrAQJOAn3gEa7izyd1QTkRAgwX0lpff9yOgquCQzXo3bbaAr88i9969lLU3ssPhsDMTgoB6NPykOqOXBVTIhEeafwkBEfD26e+rI38voLD8kRoQAc15BKttn/AAbUAENAyff1N6VmUAAAF8SURBVMbr9wdqFd+IEPgQ9Xn2yw4EREDDUMeeJY8gSAOCXCmHH6Xt9IIR0BzETgsIrCWggIAISEBAeSMgAhIQUN7CsGR3gHWwS8OdJaBdAmth7ywBe+zDev2p2Y37q76Dl9LpSsP2HhobXIrGOVYgIAJyKQTUD3lG5lLdcVMAAAAAAABwK1zKCqIbfzwKv5s05H4mK2XpnkHfnLf8qQ+D2uRSVhC9eB3+q+9Pr8+I+7n/+4hBAlYGIv7KowAKtcuA/gLuv6+9vPzdoBsySECFfmkSgTpfQJukbLP/8+HdE3BQiiBQ5wtol8aVNtPynRNQrDzEn5YafjdkBdFFwOjdFPDzIzsytdR0uSkrCI/gH/dvCJe6oxPy+Q52QsTP5UHsaZtGVhA9UYZhPhgzDBPw+6Xf/EZc6rPXk8lkWA/TJo2sILpi3EC0R72ftBEVrcoACgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAV/B8FRgarEFRNYgAAAABJRU5ErkJggg==" srcset="../../_images/sphx_glr_plot_grid_search_stats_001.png" alt="Data" class="sphx-glr-single-img"><p>We will compare the performance of <a class="reference internal" href="../../modules/generated/sklearn.svm.svc.html#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a> estimators that vary on their <code>kernel</code> parameter, to decide which choice of this hyper-parameter predicts our simulated data best. We will evaluate the performance of the models using <a class="reference internal" href="../../modules/generated/sklearn.model_selection.repeatedstratifiedkfold.html#sklearn.model_selection.RepeatedStratifiedKFold" title="sklearn.model_selection.RepeatedStratifiedKFold"><code>RepeatedStratifiedKFold</code></a>, repeating 10 times a 10-fold stratified cross validation using a different randomization of the data in each repetition. The performance will be evaluated using <a class="reference internal" href="../../modules/generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a>.</p> <pre data-language="python">from sklearn.model_selection import GridSearchCV, RepeatedStratifiedKFold
from sklearn.svm import SVC

param_grid = [
    {"kernel": ["linear"]},
    {"kernel": ["poly"], "degree": [2, 3]},
    {"kernel": ["rbf"]},
]

svc = SVC(random_state=0)

cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=10, random_state=0)

search = GridSearchCV(estimator=svc, param_grid=param_grid, scoring="roc_auc", cv=cv)
search.fit(X, y)
</pre> <div class="output_subarea output_html rendered_html output_result"> <div id="sk-container-id-42" class="sk-top-container">
<div class="sk-text-repr-fallback">
<pre>GridSearchCV(cv=RepeatedStratifiedKFold(n_repeats=10, n_splits=10, random_state=0),
             estimator=SVC(random_state=0),
             param_grid=[{'kernel': ['linear']},
                         {'degree': [2, 3], 'kernel': ['poly']},
                         {'kernel': ['rbf']}],
             scoring='roc_auc')</pre>
<b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br>On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b>
</div>
<div class="sk-container" hidden><div class="sk-item sk-dashed-wrapped">
<div class="sk-label-container"><div class="sk-label sk-toggleable">
<input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-195" type="checkbox"><label for="sk-estimator-id-195" class="sk-toggleable__label sk-toggleable__label-arrow">GridSearchCV</label><div class="sk-toggleable__content"><pre>GridSearchCV(cv=RepeatedStratifiedKFold(n_repeats=10, n_splits=10, random_state=0),
             estimator=SVC(random_state=0),
             param_grid=[{'kernel': ['linear']},
                         {'degree': [2, 3], 'kernel': ['poly']},
                         {'kernel': ['rbf']}],
             scoring='roc_auc')</pre></div>
</div></div>
<div class="sk-parallel"><div class="sk-parallel-item"><div class="sk-item">
<div class="sk-label-container"><div class="sk-label sk-toggleable">
<input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-196" type="checkbox"><label for="sk-estimator-id-196" class="sk-toggleable__label sk-toggleable__label-arrow">estimator: SVC</label><div class="sk-toggleable__content"><pre>SVC(random_state=0)</pre></div>
</div></div>
<div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable">
<input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-197" type="checkbox"><label for="sk-estimator-id-197" class="sk-toggleable__label sk-toggleable__label-arrow">SVC</label><div class="sk-toggleable__content"><pre>SVC(random_state=0)</pre></div>
</div></div></div>
</div></div></div>
</div></div>
</div> </div> <br> <br><p>We can now inspect the results of our search, sorted by their <code>mean_test_score</code>:</p> <pre data-language="python">import pandas as pd

results_df = pd.DataFrame(search.cv_results_)
results_df = results_df.sort_values(by=["rank_test_score"])
results_df = results_df.set_index(
    results_df["params"].apply(lambda x: "_".join(str(val) for val in x.values()))
).rename_axis("kernel")
results_df[["params", "rank_test_score", "mean_test_score", "std_test_score"]]
</pre> <div class="output_subarea output_html rendered_html output_result"> <div>  <table class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>params</th> <th>rank_test_score</th> <th>mean_test_score</th> <th>std_test_score</th> </tr> <tr> <th>kernel</th> <th></th> <th></th> <th></th> <th></th> </tr> </thead>  <tr> <th>rbf</th> <td>{'kernel': 'rbf'}</td> <td>1</td> <td>0.9400</td> <td>0.079297</td> </tr> <tr> <th>linear</th> <td>{'kernel': 'linear'}</td> <td>2</td> <td>0.9300</td> <td>0.077846</td> </tr> <tr> <th>3_poly</th> <td>{'degree': 3, 'kernel': 'poly'}</td> <td>3</td> <td>0.9044</td> <td>0.098776</td> </tr> <tr> <th>2_poly</th> <td>{'degree': 2, 'kernel': 'poly'}</td> <td>4</td> <td>0.6852</td> <td>0.169106</td> </tr>  </table> </div> </div> <br> <br><p>We can see that the estimator using the <code>'rbf'</code> kernel performed best, closely followed by <code>'linear'</code>. Both estimators with a <code>'poly'</code> kernel performed worse, with the one using a two-degree polynomial achieving a much lower performance than all other models.</p> <p>Usually, the analysis just ends here, but half the story is missing. The output of <a class="reference internal" href="../../modules/generated/sklearn.model_selection.gridsearchcv.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a> does not provide information on the certainty of the differences between the models. We don’t know if these are <strong>statistically</strong> significant. To evaluate this, we need to conduct a statistical test. Specifically, to contrast the performance of two models we should statistically compare their AUC scores. There are 100 samples (AUC scores) for each model as we repreated 10 times a 10-fold cross-validation.</p> <p>However, the scores of the models are not independent: all models are evaluated on the <strong>same</strong> 100 partitions, increasing the correlation between the performance of the models. Since some partitions of the data can make the distinction of the classes particularly easy or hard to find for all models, the models scores will co-vary.</p> <p>Let’s inspect this partition effect by plotting the performance of all models in each fold, and calculating the correlation between models across folds:</p> <pre data-language="python"># create df of model scores ordered by performance
model_scores = results_df.filter(regex=r"split\d*_test_score")

# plot 30 examples of dependency between cv fold and AUC scores
fig, ax = plt.subplots()
sns.lineplot(
    data=model_scores.transpose().iloc[:30],
    dashes=False,
    palette="Set1",
    marker="o",
    alpha=0.5,
    ax=ax,
)
ax.set_xlabel("CV test fold", size=12, labelpad=10)
ax.set_ylabel("Model AUC", size=12)
ax.tick_params(bottom=True, labelbottom=False)
plt.show()

# print correlation of AUC scores across folds
print(f"Correlation of models:\n {model_scores.transpose().corr()}")
</pre> <img src="data:image/png;base64,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" srcset="../../_images/sphx_glr_plot_grid_search_stats_002.png" alt="plot grid search stats" class="sphx-glr-single-img"><pre data-language="none">Correlation of models:
 kernel       rbf    linear    3_poly    2_poly
kernel
rbf     1.000000  0.882561  0.783392  0.351390
linear  0.882561  1.000000  0.746492  0.298688
3_poly  0.783392  0.746492  1.000000  0.355440
2_poly  0.351390  0.298688  0.355440  1.000000
</pre> <p>We can observe that the performance of the models highly depends on the fold.</p> <p>As a consequence, if we assume independence between samples we will be underestimating the variance computed in our statistical tests, increasing the number of false positive errors (i.e. detecting a significant difference between models when such does not exist) <a class="footnote-reference brackets" href="#id10" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p> <p>Several variance-corrected statistical tests have been developed for these cases. In this example we will show how to implement one of them (the so called Nadeau and Bengio’s corrected t-test) under two different statistical frameworks: frequentist and Bayesian.</p> <section id="comparing-two-models-frequentist-approach"> <h2>Comparing two models: frequentist approach</h2> <p>We can start by asking: “Is the first model significantly better than the second model (when ranked by <code>mean_test_score</code>)?”</p> <p>To answer this question using a frequentist approach we could run a paired t-test and compute the p-value. This is also known as Diebold-Mariano test in the forecast literature <a class="footnote-reference brackets" href="#id14" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>. Many variants of such a t-test have been developed to account for the ‘non-independence of samples problem’ described in the previous section. We will use the one proven to obtain the highest replicability scores (which rate how similar the performance of a model is when evaluating it on different random partitions of the same dataset) while maintaining a low rate of false positives and false negatives: the Nadeau and Bengio’s corrected t-test <a class="footnote-reference brackets" href="#id11" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> that uses a 10 times repeated 10-fold cross validation <a class="footnote-reference brackets" href="#id12" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p> <p>This corrected paired t-test is computed as:</p> <div class="math notranslate nohighlight"> \[t=\frac{\frac{1}{k \cdot r}\sum_{i=1}^{k}\sum_{j=1}^{r}x_{ij}} {\sqrt{(\frac{1}{k \cdot r}+\frac{n_{test}}{n_{train}})\hat{\sigma}^2}}\]</div> <p>where <span class="math notranslate nohighlight">\(k\)</span> is the number of folds, <span class="math notranslate nohighlight">\(r\)</span> the number of repetitions in the cross-validation, <span class="math notranslate nohighlight">\(x\)</span> is the difference in performance of the models, <span class="math notranslate nohighlight">\(n_{test}\)</span> is the number of samples used for testing, <span class="math notranslate nohighlight">\(n_{train}\)</span> is the number of samples used for training, and <span class="math notranslate nohighlight">\(\hat{\sigma}^2\)</span> represents the variance of the observed differences.</p> <p>Let’s implement a corrected right-tailed paired t-test to evaluate if the performance of the first model is significantly better than that of the second model. Our null hypothesis is that the second model performs at least as good as the first model.</p> <pre data-language="python">import numpy as np
from scipy.stats import t


def corrected_std(differences, n_train, n_test):
    """Corrects standard deviation using Nadeau and Bengio's approach.

    Parameters
    ----------
    differences : ndarray of shape (n_samples,)
        Vector containing the differences in the score metrics of two models.
    n_train : int
        Number of samples in the training set.
    n_test : int
        Number of samples in the testing set.

    Returns
    -------
    corrected_std : float
        Variance-corrected standard deviation of the set of differences.
    """
    # kr = k times r, r times repeated k-fold crossvalidation,
    # kr equals the number of times the model was evaluated
    kr = len(differences)
    corrected_var = np.var(differences, ddof=1) * (1 / kr + n_test / n_train)
    corrected_std = np.sqrt(corrected_var)
    return corrected_std


def compute_corrected_ttest(differences, df, n_train, n_test):
    """Computes right-tailed paired t-test with corrected variance.

    Parameters
    ----------
    differences : array-like of shape (n_samples,)
        Vector containing the differences in the score metrics of two models.
    df : int
        Degrees of freedom.
    n_train : int
        Number of samples in the training set.
    n_test : int
        Number of samples in the testing set.

    Returns
    -------
    t_stat : float
        Variance-corrected t-statistic.
    p_val : float
        Variance-corrected p-value.
    """
    mean = np.mean(differences)
    std = corrected_std(differences, n_train, n_test)
    t_stat = mean / std
    p_val = t.sf(np.abs(t_stat), df)  # right-tailed t-test
    return t_stat, p_val
</pre> <pre data-language="python">model_1_scores = model_scores.iloc[0].values  # scores of the best model
model_2_scores = model_scores.iloc[1].values  # scores of the second-best model

differences = model_1_scores - model_2_scores

n = differences.shape[0]  # number of test sets
df = n - 1
n_train = len(list(cv.split(X, y))[0][0])
n_test = len(list(cv.split(X, y))[0][1])

t_stat, p_val = compute_corrected_ttest(differences, df, n_train, n_test)
print(f"Corrected t-value: {t_stat:.3f}\nCorrected p-value: {p_val:.3f}")
</pre> <pre data-language="none">Corrected t-value: 0.750
Corrected p-value: 0.227
</pre> <p>We can compare the corrected t- and p-values with the uncorrected ones:</p> <pre data-language="python">t_stat_uncorrected = np.mean(differences) / np.sqrt(np.var(differences, ddof=1) / n)
p_val_uncorrected = t.sf(np.abs(t_stat_uncorrected), df)

print(
    f"Uncorrected t-value: {t_stat_uncorrected:.3f}\n"
    f"Uncorrected p-value: {p_val_uncorrected:.3f}"
)
</pre> <pre data-language="none">Uncorrected t-value: 2.611
Uncorrected p-value: 0.005
</pre> <p>Using the conventional significance alpha level at <code>p=0.05</code>, we observe that the uncorrected t-test concludes that the first model is significantly better than the second.</p> <p>With the corrected approach, in contrast, we fail to detect this difference.</p> <p>In the latter case, however, the frequentist approach does not let us conclude that the first and second model have an equivalent performance. If we wanted to make this assertion we need to use a Bayesian approach.</p> </section> <section id="comparing-two-models-bayesian-approach"> <h2>Comparing two models: Bayesian approach</h2> <p>We can use Bayesian estimation to calculate the probability that the first model is better than the second. Bayesian estimation will output a distribution followed by the mean <span class="math notranslate nohighlight">\(\mu\)</span> of the differences in the performance of two models.</p> <p>To obtain the posterior distribution we need to define a prior that models our beliefs of how the mean is distributed before looking at the data, and multiply it by a likelihood function that computes how likely our observed differences are, given the values that the mean of differences could take.</p> <p>Bayesian estimation can be carried out in many forms to answer our question, but in this example we will implement the approach suggested by Benavoli and colleagues <a class="footnote-reference brackets" href="#id13" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.</p> <p>One way of defining our posterior using a closed-form expression is to select a prior conjugate to the likelihood function. Benavoli and colleagues <a class="footnote-reference brackets" href="#id13" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> show that when comparing the performance of two classifiers we can model the prior as a Normal-Gamma distribution (with both mean and variance unknown) conjugate to a normal likelihood, to thus express the posterior as a normal distribution. Marginalizing out the variance from this normal posterior, we can define the posterior of the mean parameter as a Student’s t-distribution. Specifically:</p> <div class="math notranslate nohighlight"> \[St(\mu;n-1,\overline{x},(\frac{1}{n}+\frac{n_{test}}{n_{train}}) \hat{\sigma}^2)\]</div> <p>where <span class="math notranslate nohighlight">\(n\)</span> is the total number of samples, <span class="math notranslate nohighlight">\(\overline{x}\)</span> represents the mean difference in the scores, <span class="math notranslate nohighlight">\(n_{test}\)</span> is the number of samples used for testing, <span class="math notranslate nohighlight">\(n_{train}\)</span> is the number of samples used for training, and <span class="math notranslate nohighlight">\(\hat{\sigma}^2\)</span> represents the variance of the observed differences.</p> <p>Notice that we are using Nadeau and Bengio’s corrected variance in our Bayesian approach as well.</p> <p>Let’s compute and plot the posterior:</p> <pre data-language="python"># initialize random variable
t_post = t(
    df, loc=np.mean(differences), scale=corrected_std(differences, n_train, n_test)
)
</pre> <p>Let’s plot the posterior distribution:</p> <pre data-language="python">x = np.linspace(t_post.ppf(0.001), t_post.ppf(0.999), 100)

plt.plot(x, t_post.pdf(x))
plt.xticks(np.arange(-0.04, 0.06, 0.01))
plt.fill_between(x, t_post.pdf(x), 0, facecolor="blue", alpha=0.2)
plt.ylabel("Probability density")
plt.xlabel(r"Mean difference ($\mu$)")
plt.title("Posterior distribution")
plt.show()
</pre> <img src="data:image/png;base64,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" srcset="../../_images/sphx_glr_plot_grid_search_stats_003.png" alt="Posterior distribution" class="sphx-glr-single-img"><p>We can calculate the probability that the first model is better than the second by computing the area under the curve of the posterior distribution from zero to infinity. And also the reverse: we can calculate the probability that the second model is better than the first by computing the area under the curve from minus infinity to zero.</p> <pre data-language="python">better_prob = 1 - t_post.cdf(0)

print(
    f"Probability of {model_scores.index[0]} being more accurate than "
    f"{model_scores.index[1]}: {better_prob:.3f}"
)
print(
    f"Probability of {model_scores.index[1]} being more accurate than "
    f"{model_scores.index[0]}: {1 - better_prob:.3f}"
)
</pre> <pre data-language="none">Probability of rbf being more accurate than linear: 0.773
Probability of linear being more accurate than rbf: 0.227
</pre> <p>In contrast with the frequentist approach, we can compute the probability that one model is better than the other.</p> <p>Note that we obtained similar results as those in the frequentist approach. Given our choice of priors, we are essentially performing the same computations, but we are allowed to make different assertions.</p> <section id="region-of-practical-equivalence"> <h3>Region of Practical Equivalence</h3> <p>Sometimes we are interested in determining the probabilities that our models have an equivalent performance, where “equivalent” is defined in a practical way. A naive approach <a class="footnote-reference brackets" href="#id13" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> would be to define estimators as practically equivalent when they differ by less than 1% in their accuracy. But we could also define this practical equivalence taking into account the problem we are trying to solve. For example, a difference of 5% in accuracy would mean an increase of $1000 in sales, and we consider any quantity above that as relevant for our business.</p> <p>In this example we are going to define the Region of Practical Equivalence (ROPE) to be <span class="math notranslate nohighlight">\([-0.01, 0.01]\)</span>. That is, we will consider two models as practically equivalent if they differ by less than 1% in their performance.</p> <p>To compute the probabilities of the classifiers being practically equivalent, we calculate the area under the curve of the posterior over the ROPE interval:</p> <pre data-language="python">rope_interval = [-0.01, 0.01]
rope_prob = t_post.cdf(rope_interval[1]) - t_post.cdf(rope_interval[0])

print(
    f"Probability of {model_scores.index[0]} and {model_scores.index[1]} "
    f"being practically equivalent: {rope_prob:.3f}"
)
</pre> <pre data-language="none">Probability of rbf and linear being practically equivalent: 0.432
</pre> <p>We can plot how the posterior is distributed over the ROPE interval:</p> <pre data-language="python">x_rope = np.linspace(rope_interval[0], rope_interval[1], 100)

plt.plot(x, t_post.pdf(x))
plt.xticks(np.arange(-0.04, 0.06, 0.01))
plt.vlines([-0.01, 0.01], ymin=0, ymax=(np.max(t_post.pdf(x)) + 1))
plt.fill_between(x_rope, t_post.pdf(x_rope), 0, facecolor="blue", alpha=0.2)
plt.ylabel("Probability density")
plt.xlabel(r"Mean difference ($\mu$)")
plt.title("Posterior distribution under the ROPE")
plt.show()
</pre> <img src="data:image/png;base64,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" srcset="../../_images/sphx_glr_plot_grid_search_stats_004.png" alt="Posterior distribution under the ROPE" class="sphx-glr-single-img"><p>As suggested in <a class="footnote-reference brackets" href="#id13" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>, we can further interpret these probabilities using the same criteria as the frequentist approach: is the probability of falling inside the ROPE bigger than 95% (alpha value of 5%)? In that case we can conclude that both models are practically equivalent.</p> <p>The Bayesian estimation approach also allows us to compute how uncertain we are about our estimation of the difference. This can be calculated using credible intervals. For a given probability, they show the range of values that the estimated quantity, in our case the mean difference in performance, can take. For example, a 50% credible interval [x, y] tells us that there is a 50% probability that the true (mean) difference of performance between models is between x and y.</p> <p>Let’s determine the credible intervals of our data using 50%, 75% and 95%:</p> <pre data-language="python">cred_intervals = []
intervals = [0.5, 0.75, 0.95]

for interval in intervals:
    cred_interval = list(t_post.interval(interval))
    cred_intervals.append([interval, cred_interval[0], cred_interval[1]])

cred_int_df = pd.DataFrame(
    cred_intervals, columns=["interval", "lower value", "upper value"]
).set_index("interval")
cred_int_df
</pre> <div class="output_subarea output_html rendered_html output_result"> <div>  <table class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>lower value</th> <th>upper value</th> </tr> <tr> <th>interval</th> <th></th> <th></th> </tr> </thead>  <tr> <th>0.50</th> <td>0.000977</td> <td>0.019023</td> </tr> <tr> <th>0.75</th> <td>-0.005422</td> <td>0.025422</td> </tr> <tr> <th>0.95</th> <td>-0.016445</td> <td>0.036445</td> </tr>  </table> </div> </div> <br> <br><p>As shown in the table, there is a 50% probability that the true mean difference between models will be between 0.000977 and 0.019023, 70% probability that it will be between -0.005422 and 0.025422, and 95% probability that it will be between -0.016445 and 0.036445.</p> </section> </section> <section id="pairwise-comparison-of-all-models-frequentist-approach"> <h2>Pairwise comparison of all models: frequentist approach</h2> <p>We could also be interested in comparing the performance of all our models evaluated with <a class="reference internal" href="../../modules/generated/sklearn.model_selection.gridsearchcv.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a>. In this case we would be running our statistical test multiple times, which leads us to the <a class="reference external" href="https://en.wikipedia.org/wiki/Multiple_comparisons_problem">multiple comparisons problem</a>.</p> <p>There are many possible ways to tackle this problem, but a standard approach is to apply a <a class="reference external" href="https://en.wikipedia.org/wiki/Bonferroni_correction">Bonferroni correction</a>. Bonferroni can be computed by multiplying the p-value by the number of comparisons we are testing.</p> <p>Let’s compare the performance of the models using the corrected t-test:</p> <pre data-language="python">from itertools import combinations
from math import factorial

n_comparisons = factorial(len(model_scores)) / (
    factorial(2) * factorial(len(model_scores) - 2)
)
pairwise_t_test = []

for model_i, model_k in combinations(range(len(model_scores)), 2):
    model_i_scores = model_scores.iloc[model_i].values
    model_k_scores = model_scores.iloc[model_k].values
    differences = model_i_scores - model_k_scores
    t_stat, p_val = compute_corrected_ttest(differences, df, n_train, n_test)
    p_val *= n_comparisons  # implement Bonferroni correction
    # Bonferroni can output p-values higher than 1
    p_val = 1 if p_val &gt; 1 else p_val
    pairwise_t_test.append(
        [model_scores.index[model_i], model_scores.index[model_k], t_stat, p_val]
    )

pairwise_comp_df = pd.DataFrame(
    pairwise_t_test, columns=["model_1", "model_2", "t_stat", "p_val"]
).round(3)
pairwise_comp_df
</pre> <div class="output_subarea output_html rendered_html output_result"> <div>  <table class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>model_1</th> <th>model_2</th> <th>t_stat</th> <th>p_val</th> </tr> </thead>  <tr> <th>0</th> <td>rbf</td> <td>linear</td> <td>0.750</td> <td>1.000</td> </tr> <tr> <th>1</th> <td>rbf</td> <td>3_poly</td> <td>1.657</td> <td>0.302</td> </tr> <tr> <th>2</th> <td>rbf</td> <td>2_poly</td> <td>4.565</td> <td>0.000</td> </tr> <tr> <th>3</th> <td>linear</td> <td>3_poly</td> <td>1.111</td> <td>0.807</td> </tr> <tr> <th>4</th> <td>linear</td> <td>2_poly</td> <td>4.276</td> <td>0.000</td> </tr> <tr> <th>5</th> <td>3_poly</td> <td>2_poly</td> <td>3.851</td> <td>0.001</td> </tr>  </table> </div> </div> <br> <br><p>We observe that after correcting for multiple comparisons, the only model that significantly differs from the others is <code>'2_poly'</code>. <code>'rbf'</code>, the model ranked first by <a class="reference internal" href="../../modules/generated/sklearn.model_selection.gridsearchcv.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a>, does not significantly differ from <code>'linear'</code> or <code>'3_poly'</code>.</p> </section> <section id="pairwise-comparison-of-all-models-bayesian-approach"> <h2>Pairwise comparison of all models: Bayesian approach</h2> <p>When using Bayesian estimation to compare multiple models, we don’t need to correct for multiple comparisons (for reasons why see <a class="footnote-reference brackets" href="#id13" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>).</p> <p>We can carry out our pairwise comparisons the same way as in the first section:</p> <pre data-language="python">pairwise_bayesian = []

for model_i, model_k in combinations(range(len(model_scores)), 2):
    model_i_scores = model_scores.iloc[model_i].values
    model_k_scores = model_scores.iloc[model_k].values
    differences = model_i_scores - model_k_scores
    t_post = t(
        df, loc=np.mean(differences), scale=corrected_std(differences, n_train, n_test)
    )
    worse_prob = t_post.cdf(rope_interval[0])
    better_prob = 1 - t_post.cdf(rope_interval[1])
    rope_prob = t_post.cdf(rope_interval[1]) - t_post.cdf(rope_interval[0])

    pairwise_bayesian.append([worse_prob, better_prob, rope_prob])

pairwise_bayesian_df = pd.DataFrame(
    pairwise_bayesian, columns=["worse_prob", "better_prob", "rope_prob"]
).round(3)

pairwise_comp_df = pairwise_comp_df.join(pairwise_bayesian_df)
pairwise_comp_df
</pre> <div class="output_subarea output_html rendered_html output_result"> <div>  <table class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>model_1</th> <th>model_2</th> <th>t_stat</th> <th>p_val</th> <th>worse_prob</th> <th>better_prob</th> <th>rope_prob</th> </tr> </thead>  <tr> <th>0</th> <td>rbf</td> <td>linear</td> <td>0.750</td> <td>1.000</td> <td>0.068</td> <td>0.500</td> <td>0.432</td> </tr> <tr> <th>1</th> <td>rbf</td> <td>3_poly</td> <td>1.657</td> <td>0.302</td> <td>0.018</td> <td>0.882</td> <td>0.100</td> </tr> <tr> <th>2</th> <td>rbf</td> <td>2_poly</td> <td>4.565</td> <td>0.000</td> <td>0.000</td> <td>1.000</td> <td>0.000</td> </tr> <tr> <th>3</th> <td>linear</td> <td>3_poly</td> <td>1.111</td> <td>0.807</td> <td>0.063</td> <td>0.750</td> <td>0.187</td> </tr> <tr> <th>4</th> <td>linear</td> <td>2_poly</td> <td>4.276</td> <td>0.000</td> <td>0.000</td> <td>1.000</td> <td>0.000</td> </tr> <tr> <th>5</th> <td>3_poly</td> <td>2_poly</td> <td>3.851</td> <td>0.001</td> <td>0.000</td> <td>1.000</td> <td>0.000</td> </tr>  </table> </div> </div> <br> <br><p>Using the Bayesian approach we can compute the probability that a model performs better, worse or practically equivalent to another.</p> <p>Results show that the model ranked first by <a class="reference internal" href="../../modules/generated/sklearn.model_selection.gridsearchcv.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a> <code>'rbf'</code>, has approximately a 6.8% chance of being worse than <code>'linear'</code>, and a 1.8% chance of being worse than <code>'3_poly'</code>. <code>'rbf'</code> and <code>'linear'</code> have a 43% probability of being practically equivalent, while <code>'rbf'</code> and <code>'3_poly'</code> have a 10% chance of being so.</p> <p>Similarly to the conclusions obtained using the frequentist approach, all models have a 100% probability of being better than <code>'2_poly'</code>, and none have a practically equivalent performance with the latter.</p> </section> <section id="take-home-messages"> <h2>Take-home messages</h2> <ul class="simple"> <li>Small differences in performance measures might easily turn out to be merely by chance, but not because one model predicts systematically better than the other. As shown in this example, statistics can tell you how likely that is.</li> <li>When statistically comparing the performance of two models evaluated in GridSearchCV, it is necessary to correct the calculated variance which could be underestimated since the scores of the models are not independent from each other.</li> <li>A frequentist approach that uses a (variance-corrected) paired t-test can tell us if the performance of one model is better than another with a degree of certainty above chance.</li> <li>A Bayesian approach can provide the probabilities of one model being better, worse or practically equivalent than another. It can also tell us how confident we are of knowing that the true differences of our models fall under a certain range of values.</li> <li>If multiple models are statistically compared, a multiple comparisons correction is needed when using the frequentist approach.</li> </ul> <aside class="topic"> <p class="topic-title">References</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id10" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span> <p>Dietterich, T. G. (1998). <a class="reference external" href="http://web.cs.iastate.edu/~jtian/cs573/Papers/Dietterich-98.pdf">Approximate statistical tests for comparing supervised classification learning algorithms</a>. Neural computation, 10(7).</p> </aside> <aside class="footnote brackets" id="id11" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span> <p>Nadeau, C., &amp; Bengio, Y. (2000). <a class="reference external" href="https://papers.nips.cc/paper/1661-inference-for-the-generalization-error.pdf">Inference for the generalization error</a>. In Advances in neural information processing systems.</p> </aside> <aside class="footnote brackets" id="id12" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span> <p>Bouckaert, R. R., &amp; Frank, E. (2004). <a class="reference external" href="https://www.cms.waikato.ac.nz/~ml/publications/2004/bouckaert-frank.pdf">Evaluating the replicability of significance tests for comparing learning algorithms</a>. In Pacific-Asia Conference on Knowledge Discovery and Data Mining.</p> </aside> <aside class="footnote brackets" id="id13" role="note"> <span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id5">1</a>,<a role="doc-backlink" href="#id6">2</a>,<a role="doc-backlink" href="#id7">3</a>,<a role="doc-backlink" href="#id8">4</a>,<a role="doc-backlink" href="#id9">5</a>)</span> <p>Benavoli, A., Corani, G., Demšar, J., &amp; Zaffalon, M. (2017). <a class="reference external" href="http://www.jmlr.org/papers/volume18/16-305/16-305.pdf">Time for a change: a tutorial for comparing multiple classifiers through Bayesian analysis</a>. The Journal of Machine Learning Research, 18(1). See the Python library that accompanies this paper <a class="reference external" href="https://github.com/janezd/baycomp">here</a>.</p> </aside> <aside class="footnote brackets" id="id14" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">5</a><span class="fn-bracket">]</span></span> <p>Diebold, F.X. &amp; Mariano R.S. (1995). <a class="reference external" href="http://www.est.uc3m.es/esp/nueva_docencia/comp_col_get/lade/tecnicas_prediccion/Practicas0708/Comparing%20Predictive%20Accuracy%20(Dielbold).pdf">Comparing predictive accuracy</a> Journal of Business &amp; economic statistics, 20(1), 134-144.</p> </aside> </aside> </aside> <p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes 1.095 seconds)</p> <div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-auto-examples-model-selection-plot-grid-search-stats-py"> <div class="binder-badge docutils container"> <a class="reference external image-reference" href="https://mybinder.org/v2/gh/scikit-learn/scikit-learn/1.1.X?urlpath=lab/tree/notebooks/auto_examples/model_selection/plot_grid_search_stats.ipynb"><img alt="Launch binder" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTA5IiBoZWlnaHQ9IjIwIj48bGluZWFyR3JhZGllbnQgaWQ9ImIiIHgyPSIwIiB5Mj0iMTAwJSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjYmJiIiBzdG9wLW9wYWNpdHk9Ii4xIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLW9wYWNpdHk9Ii4xIi8+PC9saW5lYXJHcmFkaWVudD48Y2xpcFBhdGggaWQ9ImEiPjxyZWN0IHdpZHRoPSIxMDkiIGhlaWdodD0iMjAiIHJ4PSIzIiBmaWxsPSIjZmZmIi8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjYSkiPjxwYXRoIGZpbGw9IiM1NTUiIGQ9Ik0wIDBoNjR2MjBIMHoiLz48cGF0aCBmaWxsPSIjNTc5YWNhIiBkPSJNNjQgMGg0NXYyMEg2NHoiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMCAwaDEwOXYyMEgweiIvPjwvZz48ZyBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0iRGVqYVZ1IFNhbnMsVmVyZGFuYSxHZW5ldmEsc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMTAiPjxpbWFnZSB4PSI1IiB5PSIzIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRmtBQUFCWkNBTUFBQUJpMVhpZEFBQUI4bEJNVkVYLy8vOVhtc3JtWllIMW9sSlhtc3Ixb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEpYbXNybVpZSDFvbEwxb2xKWG1zcjFvbEpYbXNybVpZSDFvbEwxb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xMMW9sSlhtc3JtWllIMW9sTDFvbEwwbkZmMW9sSlhtc3JtWllIMW9sSlhtc3E4ZFpiMW9sSlhtc3JtWllIMW9sSlhtc3BYbXNwWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xMMW9sTGVhSVZYbXNybVpZSDFvbEwxb2xMMW9sSlhtc3JtWllIMW9sTG5hMzFYbXNyMW9sSlhtc3Ixb2xKWG1zcm1aWUgxb2xMcW9WcjFvbEpYbXNyMW9sSlhtc3JtWllIMW9sTDFvbEtrZmFQb2JYdnZpR2FiZ2FkWG1zcVRoS3VvZktIbVo0RG9ibnIxb2xKWG1zcjFvbEpYbXNwWG1zcjFvbEpYbXNyZlo0VHVoV24xb2xMMW9sSlhtc3FCaTdYMW9sSlhtc3BabXNsYm1NaGJtc2RlbXNWZmw4Wmdtc05pbThKcGs4RjBtN1I0bTdGNW5MQjZqYmg3amJpRGlyT0VpYk9HbkthTWhxK1BuYUNWZzZxV2c2cWVnS2FmZjZXaG5wS29mS0d0bm9teGVaeTNub0c2ZFppK24zdkNjcFBEY3BQR24zYkxiNC9NYjQ3VWJJclZhNHJZb0dqZGFJYmVhSVhob1dIbVpZSG9iWHZwY0hqcWRIWHJlSExyb1Zyc2ZHL3VoR251aDJid2oySHhrMTd5bDF2em1sanptMWowbmxYMW9sTDNBSlhXQUFBQWJYUlNUbE1BRUJBUUh4OGdJQ0F1TGpBd01EdzlQVUJBUUVwUVVGQlhWMWhnWUdCa2NIQndjWGw4Z0lDQWdvaUlrSkNRbEppY25KMmdvS0NtcUsrd3NMQzR1c0RBd01qUDBORFExTmJXM056ZzRPRGk1KzN2OFBEdzgvVDA5UFgyOXZiMzkvZjUrZnI3Ky96OC9QejkvdjcremN6Q3hnQUFCQzVKUkVGVWVBSE4xdWwzazBVVUJ2Q2IxQ1RWcG1wYWl0QUdTTFNwU3VLQ0xXcGJUS05KRkdsY1NNQUZGNjNpVW1SY2NORzZnTGJ1eGtYVTY2SkFVZWYvOUxTcG1YbnlMcjNUNUFPL3J6bDV6ajEzN3AxMzZCSVN5NDRmS0pYdUdOL2QxOVBVZlllTzY3Wm5xdGYyS0gzM0lkMXBzWG9GZFczMHNQWjFzTXZzMkQwNjBBSHF3czRGSGVKb2pMWnFudzUzY21mdmcrWFI4bUMwT0VqdXhyWEVrWDV5ZGVWSkxWSWxWMGUxMFBYazVrN2RZZUh1N0NqMWorNDl1S2c3dUxVNjF0R0x3MWxxMjd1Z1FZbGNsSEM0Ymd2N1ZRK1RBeWo1WmMvVWpzUHZzMXNkNWNXcnlXT2J0dldUMkVQYTRydG5XVzNKa3BqZ2dFcGJPc1ByN0Y3RXlOZXd0cEJJc2xBN3A0M0hDc253b29YVEVjM1VtUG1DTm41bHJxVEp4eTZuUm1jYXZHWlZ0LzNEYTJwRDVOSHZzT0hKQ3JkYzFHMnIzRElUcFU3eWljN3cvN1J4bmpjMGt0NUdDNGRqaXYyU3ozRmIyaUVaZzQxL2Rkc0ZEb3l1WXJJa21GZWh6MEhSMnRoUGdRcU15UVliMk90QjBXeHNaM0JlRzMrd3BSYjF2emwyVVlCb2c4RmZHaHR0RktqdEFjbG5aWXJSbzlyeUc5dUcvRlpRVTRBRWc4WkU5TGpHTXpUbXFLWFBMbmxXVm5JbFFRVHZ4SmY4aXA3VmdqWmp5VlByancxdGU1b3RNN1JtUDd4bStzSzJHdjlJOEdpKytCUmJFa1I5RUJ3OHpSVWNLeHdwNzN4a2FMaXFRYitrR2R1SlROSEc3MnpjVzlMb0pncVF4cFAzL1RqLy9jM3lCMHRxemFtbDA1LytvckhMa3NWTys5NWtYNy83cWdKdm5qbHJmcjJHZ3N5eDBlb3k5dVB6TjVTUGQ4NmFYZ2dPc0VLVzJQcno3ZHUzVklEMy90enMvc1NSczJ3N292VkhLdGpyWDJwZDdaTWxUeEFZZkJBTDlqaUR3ZkxrcTU1VG03aWZoTWxUR1B5Q0FzN1JGUmhuNDdKbmxjQjlSTTVUOTdBU3VaWEljVk51VURJbmRwRGJkc2ZycXNPcHBlWGw1WStYVktkakZDVGgrekdhVnVqMGQ5enkwNVBQSzNRekJhbXhkd3RUQ3J6eWcvMlJ2ZjJFc3RVam9yZEd3YS9reDltU0pMcjhtTEx0Q1c4SEhHSmMyUjVoUzIxOUlpRjZQblR1c09xY01sNTdnbTBaOGthbktNQVFnMHFTeXVaZm43ekl0c2JHeU85UWxueFkwZUN1RDFYTDJ5cy9Nc3JRaGx0RTdVZzB1Rk96dWZKRkUyUHhCby9ZQXg4WFBQZER3V04wTXJEUllJWkYwbVNNS0NOSGdhSVZGb0JiTm9MSjd0RVFES3hHRjBrY0xRaW1vakNab3B2ME9rTk95V0NDZzlYTVZBaTdBUkp6UWRNMlFVaDBnbUJvempjM1NrZzZkU0JScURHWVNVT3U2NlpnK0kyZk5acy9NMy9mL0dybC9YbnlGMUd3M1ZLQ2V6MFBONUlVZkZMcXZnVU40QzBxTnFZczVZaFBMK2FWWllERTRJcFVrNTdvU0ZuSm00RnlDcXFPRTBqaFkyU015TEZvbzU2enlvNmJlY09TNVVWRGRqN1ZpaDB6cCt0Y01od1JwQmVMeXF0SWpsSktBSVpTYkk4U0dTRjNrMHBBM21SNXRIdXdQRm9hN043cmVvcTJicUNzQWsxSHFDdTV1dkkxbjZKdVJYSStTMU1jbzU0WW1ZVHdjbjZBZWljK2tzc1hpOFhwWEM0VjN0Ny9BRHVUTkthUUpkU2NBQUFBQUVsRlRrU3VRbUNDIi8+IDx0ZXh0IHg9IjQxNSIgeT0iMTUwIiBmaWxsPSIjMDEwMTAxIiBmaWxsLW9wYWNpdHk9Ii4zIiB0cmFuc2Zvcm09InNjYWxlKC4xKSIgdGV4dExlbmd0aD0iMzcwIj5sYXVuY2g8L3RleHQ+PHRleHQgeD0iNDE1IiB5PSIxNDAiIHRyYW5zZm9ybT0ic2NhbGUoLjEpIiB0ZXh0TGVuZ3RoPSIzNzAiPmxhdW5jaDwvdGV4dD48dGV4dCB4PSI4NTUiIHk9IjE1MCIgZmlsbD0iIzAxMDEwMSIgZmlsbC1vcGFjaXR5PSIuMyIgdHJhbnNmb3JtPSJzY2FsZSguMSkiIHRleHRMZW5ndGg9IjM1MCI+YmluZGVyPC90ZXh0Pjx0ZXh0IHg9Ijg1NSIgeT0iMTQwIiB0cmFuc2Zvcm09InNjYWxlKC4xKSIgdGV4dExlbmd0aD0iMzUwIj5iaW5kZXI8L3RleHQ+PC9nPiA8L3N2Zz4=" width="150px"></a> </div> <div class="sphx-glr-download sphx-glr-download-python docutils container"> <p><a class="reference download internal" download="" href="https://scikit-learn.org/1.1/_downloads/efb3df90d4ec295fa0dafe6c8b46211b/plot_grid_search_stats.py"><code>Download Python source code: plot_grid_search_stats.py</code></a></p> </div> <div class="sphx-glr-download sphx-glr-download-jupyter docutils container"> <p><a class="reference download internal" download="" href="https://scikit-learn.org/1.1/_downloads/2402de18d671ce5087e3760b2540184f/plot_grid_search_stats.ipynb"><code>Download Jupyter notebook: plot_grid_search_stats.ipynb</code></a></p> </div> </div>  </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/auto_examples/model_selection/plot_grid_search_stats.html" class="_attribution-link">https://scikit-learn.org/1.1/auto_examples/model_selection/plot_grid_search_stats.html</a>
  </p>
</div>
