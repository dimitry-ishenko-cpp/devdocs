<h1 class="main-heading">Struct Arc</h1>
<pre class="rust item-decl" data-language="rust">pub struct Arc&lt;T, A = Global&gt;where
    A: Allocator,
    T: ?Sized,{ /* private fields */ }</pre>
<p>A thread-safe reference-counting pointer. ‘Arc’ stands for ‘Atomically Reference Counted’.</p> <p>The type <code>Arc&lt;T&gt;</code> provides shared ownership of a value of type <code>T</code>, allocated in the heap. Invoking <a href="../clone/trait.clone.html#tymethod.clone" title="method std::clone::Clone::clone"><code>clone</code></a> on <code>Arc</code> produces a new <code>Arc</code> instance, which points to the same allocation on the heap as the source <code>Arc</code>, while increasing a reference count. When the last <code>Arc</code> pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as “inner value”) is also dropped.</p> <p>Shared references in Rust disallow mutation by default, and <code>Arc</code> is no exception: you cannot generally obtain a mutable reference to something inside an <code>Arc</code>. If you need to mutate through an <code>Arc</code>, use <a href="struct.mutex.html"><code>Mutex</code></a>, <a href="struct.rwlock.html"><code>RwLock</code></a>, or one of the <a href="atomic/index.html" title="mod std::sync::atomic"><code>Atomic</code></a> types.</p> <p><strong>Note</strong>: This type is only available on platforms that support atomic loads and stores of pointers, which includes all platforms that support the <code>std</code> crate but not all those which only support <a href="https://doc.rust-lang.org/alloc/index.html" title="mod alloc"><code>alloc</code></a>. This may be detected at compile time using <code>#[cfg(target_has_atomic = "ptr")]</code>.</p> <h3 id="thread-safety">Thread Safety</h3> <p>Unlike <a href="../rc/struct.rc.html" title="struct std::rc::Rc"><code>Rc&lt;T&gt;</code></a>, <code>Arc&lt;T&gt;</code> uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted allocations between threads, consider using <a href="../rc/struct.rc.html" title="struct std::rc::Rc"><code>Rc&lt;T&gt;</code></a> for lower overhead. <a href="../rc/struct.rc.html" title="struct std::rc::Rc"><code>Rc&lt;T&gt;</code></a> is a safe default, because the compiler will catch any attempt to send an <a href="../rc/struct.rc.html" title="struct std::rc::Rc"><code>Rc&lt;T&gt;</code></a> between threads. However, a library might choose <code>Arc&lt;T&gt;</code> in order to give library consumers more flexibility.</p> <p><code>Arc&lt;T&gt;</code> will implement <a href="../marker/trait.send.html" title="trait std::marker::Send"><code>Send</code></a> and <a href="../marker/trait.sync.html" title="trait std::marker::Sync"><code>Sync</code></a> as long as the <code>T</code> implements <a href="../marker/trait.send.html" title="trait std::marker::Send"><code>Send</code></a> and <a href="../marker/trait.sync.html" title="trait std::marker::Sync"><code>Sync</code></a>. Why can’t you put a non-thread-safe type <code>T</code> in an <code>Arc&lt;T&gt;</code> to make it thread-safe? This may be a bit counter-intuitive at first: after all, isn’t the point of <code>Arc&lt;T&gt;</code> thread safety? The key is this: <code>Arc&lt;T&gt;</code> makes it thread safe to have multiple ownership of the same data, but it doesn’t add thread safety to its data. Consider <code>Arc&lt;<a href="../cell/struct.refcell.html" title="struct std::cell::RefCell">RefCell&lt;T&gt;</a>&gt;</code>. <a href="../cell/struct.refcell.html" title="struct std::cell::RefCell"><code>RefCell&lt;T&gt;</code></a> isn’t <a href="../marker/trait.sync.html" title="trait std::marker::Sync"><code>Sync</code></a>, and if <code>Arc&lt;T&gt;</code> was always <a href="../marker/trait.send.html" title="trait std::marker::Send"><code>Send</code></a>, <code>Arc&lt;<a href="../cell/struct.refcell.html" title="struct std::cell::RefCell">RefCell&lt;T&gt;</a>&gt;</code> would be as well. But then we’d have a problem: <a href="../cell/struct.refcell.html" title="struct std::cell::RefCell"><code>RefCell&lt;T&gt;</code></a> is not thread safe; it keeps track of the borrowing count using non-atomic operations.</p> <p>In the end, this means that you may need to pair <code>Arc&lt;T&gt;</code> with some sort of <a href="index.html"><code>std::sync</code></a> type, usually <a href="struct.mutex.html"><code>Mutex&lt;T&gt;</code></a>.</p> <h3 id="breaking-cycles-with-weak">Breaking cycles with <code>Weak</code>
</h3> <p>The <a href="struct.arc.html#method.downgrade" title="associated function std::sync::Arc::downgrade"><code>downgrade</code></a> method can be used to create a non-owning <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> pointer. A <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> pointer can be <a href="struct.weak.html#method.upgrade" title="method std::sync::Weak::upgrade"><code>upgrade</code></a>d to an <code>Arc</code>, but this will return <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> if the value stored in the allocation has already been dropped. In other words, <code>Weak</code> pointers do not keep the value inside the allocation alive; however, they <em>do</em> keep the allocation (the backing store for the value) alive.</p> <p>A cycle between <code>Arc</code> pointers will never be deallocated. For this reason, <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> is used to break cycles. For example, a tree could have strong <code>Arc</code> pointers from parent nodes to children, and <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> pointers from children back to their parents.</p> <h2 id="cloning-references">Cloning references</h2> <p>Creating a new reference from an existing reference-counted pointer is done using the <code>Clone</code> trait implemented for <a href="struct.arc.html" title="struct std::sync::Arc"><code>Arc&lt;T&gt;</code></a> and <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak&lt;T&gt;</code></a>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;
let foo = Arc::new(vec![1.0, 2.0, 3.0]);
// The two syntaxes below are equivalent.
let a = foo.clone();
let b = Arc::clone(&amp;foo);
// a, b, and foo are all Arcs that point to the same memory location</pre></div> <h3 id="deref-behavior">
<code>Deref</code> behavior</h3> <p><code>Arc&lt;T&gt;</code> automatically dereferences to <code>T</code> (via the <a href="../ops/trait.deref.html" title="trait std::ops::Deref"><code>Deref</code></a> trait), so you can call <code>T</code>’s methods on a value of type <code>Arc&lt;T&gt;</code>. To avoid name clashes with <code>T</code>’s methods, the methods of <code>Arc&lt;T&gt;</code> itself are associated functions, called using <a href="../../book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">fully qualified syntax</a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let my_arc = Arc::new(());
let my_weak = Arc::downgrade(&amp;my_arc);</pre></div> <p><code>Arc&lt;T&gt;</code>’s implementations of traits like <code>Clone</code> may also be called using fully qualified syntax. Some people prefer to use fully qualified syntax, while others prefer using method-call syntax.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let arc = Arc::new(());
// Method-call syntax
let arc2 = arc.clone();
// Fully qualified syntax
let arc3 = Arc::clone(&amp;arc);</pre></div> <p><a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak&lt;T&gt;</code></a> does not auto-dereference to <code>T</code>, because the inner value may have already been dropped.</p> <h2 id="examples">Examples</h2> <p>Sharing some immutable data between threads:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;
use std::thread;

let five = Arc::new(5);

for _ in 0..10 {
    let five = Arc::clone(&amp;five);

    thread::spawn(move || {
        println!("{five:?}");
    });
}</pre></div> <p>Sharing a mutable <a href="atomic/struct.atomicusize.html" title="sync::atomic::AtomicUsize"><code>AtomicUsize</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

let val = Arc::new(AtomicUsize::new(5));

for _ in 0..10 {
    let val = Arc::clone(&amp;val);

    thread::spawn(move || {
        let v = val.fetch_add(1, Ordering::Relaxed);
        println!("{v:?}");
    });
}</pre></div> <p>See the <a href="../rc/index.html#examples" title="mod std::rc"><code>rc</code> documentation</a> for more examples of reference counting in general.</p> <h3 id="implementations" class="section-header">Implementations</h3>
<div id="implementations-list">
<summary><section id="impl-Arc%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#372">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Arc&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.new" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#385">Source</a></span><pre class="code-header" data-language="rust">pub fn new(data: T) -&gt; Arc&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Constructs a new <code>Arc&lt;T&gt;</code>.</p> <h5 id="examples-1">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);</pre></div> </div>
<summary><section id="method.new_cyclic" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.60.0">1.60.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#450-452">Source</a></span><pre class="code-header" data-language="rust">pub fn new_cyclic&lt;F&gt;(data_fn: F) -&gt; Arc&lt;T&gt;where
    F: FnOnce(&amp;Weak&lt;T&gt;) -&gt; T,</pre></section></summary><div class="docblock">
<p>Constructs a new <code>Arc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the allocation, to allow you to construct a <code>T</code> which holds a weak pointer to itself.</p> <p>Generally, a structure circularly referencing itself, either directly or indirectly, should not hold a strong reference to itself to prevent a memory leak. Using this function, you get access to the weak pointer during the initialization of <code>T</code>, before the <code>Arc&lt;T&gt;</code> is created, such that you can clone and store it inside the <code>T</code>.</p> <p><code>new_cyclic</code> first allocates the managed allocation for the <code>Arc&lt;T&gt;</code>, then calls your closure, giving it a <code>Weak&lt;T&gt;</code> to this allocation, and only afterwards completes the construction of the <code>Arc&lt;T&gt;</code> by placing the <code>T</code> returned from your closure into the allocation.</p> <p>Since the new <code>Arc&lt;T&gt;</code> is not fully-constructed until <code>Arc&lt;T&gt;::new_cyclic</code> returns, calling <a href="struct.weak.html#method.upgrade" title="method std::sync::Weak::upgrade"><code>upgrade</code></a> on the weak reference inside your closure will fail and result in a <code>None</code> value.</p> <h5 id="panics">Panics</h5> <p>If <code>data_fn</code> panics, the panic is propagated to the caller, and the temporary <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak&lt;T&gt;</code></a> is dropped normally.</p> <h5 id="example">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::{Arc, Weak};

struct Gadget {
    me: Weak&lt;Gadget&gt;,
}

impl Gadget {
    /// Constructs a reference counted Gadget.
    fn new() -&gt; Arc&lt;Self&gt; {
        // `me` is a `Weak&lt;Gadget&gt;` pointing at the new allocation of the
        // `Arc` we're constructing.
        Arc::new_cyclic(|me| {
            // Create the actual struct here.
            Gadget { me: me.clone() }
        })
    }

    /// Returns a reference counted pointer to Self.
    fn me(&amp;self) -&gt; Arc&lt;Self&gt; {
        self.me.upgrade().unwrap()
    }
}</pre></div> </div>
<summary><section id="method.new_uninit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.82.0">1.82.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#479">Source</a></span><pre class="code-header" data-language="rust">pub fn new_uninit() -&gt; Arc&lt;MaybeUninit&lt;T&gt;&gt;</pre></section></summary><div class="docblock">
<p>Constructs a new <code>Arc</code> with uninitialized contents.</p> <h5 id="examples-2">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]

use std::sync::Arc;

let mut five = Arc::&lt;u32&gt;::new_uninit();

// Deferred initialization:
Arc::get_mut(&amp;mut five).unwrap().write(5);

let five = unsafe { five.assume_init() };

assert_eq!(*five, 5)</pre></div> </div>
<summary><section id="method.new_zeroed" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#513">Source</a><pre class="code-header" data-language="rust">pub fn new_zeroed() -&gt; Arc&lt;MaybeUninit&lt;T&gt;&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>new_zeroed_alloc</code> <a href="https://github.com/rust-lang/rust/issues/129396">#129396</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory being filled with <code>0</code> bytes.</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-3">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_zeroed_alloc)]

use std::sync::Arc;

let zero = Arc::&lt;u32&gt;::new_zeroed();
let zero = unsafe { zero.assume_init() };

assert_eq!(*zero, 0)</pre></div> </div>
<summary><section id="method.pin" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.33.0">1.33.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#528">Source</a></span><pre class="code-header" data-language="rust">pub fn pin(data: T) -&gt; Pin&lt;Arc&lt;T&gt;&gt;</pre></section></summary><div class="docblock">
<p>Constructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>, then <code>data</code> will be pinned in memory and unable to be moved.</p> </div>
<summary><section id="method.try_pin" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#535">Source</a><pre class="code-header" data-language="rust">pub fn try_pin(data: T) -&gt; Result&lt;Pin&lt;Arc&lt;T&gt;&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>, return an error if allocation fails.</p> </div>
<summary><section id="method.try_new" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#552">Source</a><pre class="code-header" data-language="rust">pub fn try_new(data: T) -&gt; Result&lt;Arc&lt;T&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Arc&lt;T&gt;</code>, returning an error if allocation fails.</p> <h5 id="examples-4">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]
use std::sync::Arc;

let five = Arc::try_new(5)?;</pre></div> </div>
<summary><section id="method.try_new_uninit" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#586">Source</a><pre class="code-header" data-language="rust">pub fn try_new_uninit() -&gt; Result&lt;Arc&lt;MaybeUninit&lt;T&gt;&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Arc</code> with uninitialized contents, returning an error if allocation fails.</p> <h5 id="examples-5">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]
#![feature(get_mut_unchecked)]

use std::sync::Arc;

let mut five = Arc::&lt;u32&gt;::try_new_uninit()?;

// Deferred initialization:
Arc::get_mut(&amp;mut five).unwrap().write(5);

let five = unsafe { five.assume_init() };

assert_eq!(*five, 5);</pre></div> </div>
<summary><section id="method.try_new_zeroed" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#619">Source</a><pre class="code-header" data-language="rust">pub fn try_new_zeroed() -&gt; Result&lt;Arc&lt;MaybeUninit&lt;T&gt;&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory being filled with <code>0</code> bytes, returning an error if allocation fails.</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-6">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature( allocator_api)]

use std::sync::Arc;

let zero = Arc::&lt;u32&gt;::try_new_zeroed()?;
let zero = unsafe { zero.assume_init() };

assert_eq!(*zero, 0);</pre></div> </div>
</div>
<summary><section id="impl-Arc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#630">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Arc&lt;T, A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.new_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#646">Source</a><pre class="code-header" data-language="rust">pub fn new_in(data: T, alloc: A) -&gt; Arc&lt;T, A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Arc&lt;T&gt;</code> in the provided allocator.</p> <h5 id="examples-7">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::sync::Arc;
use std::alloc::System;

let five = Arc::new_in(5, System);</pre></div> </div>
<summary><section id="method.new_uninit_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#687">Source</a><pre class="code-header" data-language="rust">pub fn new_uninit_in(alloc: A) -&gt; Arc&lt;MaybeUninit&lt;T&gt;, A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Arc</code> with uninitialized contents in the provided allocator.</p> <h5 id="examples-8">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]
#![feature(allocator_api)]

use std::sync::Arc;
use std::alloc::System;

let mut five = Arc::&lt;u32, _&gt;::new_uninit_in(System);

let five = unsafe {
    // Deferred initialization:
    Arc::get_mut_unchecked(&amp;mut five).as_mut_ptr().write(5);

    five.assume_init()
};

assert_eq!(*five, 5)</pre></div> </div>
<summary><section id="method.new_zeroed_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#725">Source</a><pre class="code-header" data-language="rust">pub fn new_zeroed_in(alloc: A) -&gt; Arc&lt;MaybeUninit&lt;T&gt;, A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory being filled with <code>0</code> bytes, in the provided allocator.</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-9">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::sync::Arc;
use std::alloc::System;

let zero = Arc::&lt;u32, _&gt;::new_zeroed_in(System);
let zero = unsafe { zero.assume_init() };

assert_eq!(*zero, 0)</pre></div> </div>
<summary><section id="method.new_cyclic_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#770-772">Source</a><pre class="code-header" data-language="rust">pub fn new_cyclic_in&lt;F&gt;(data_fn: F, alloc: A) -&gt; Arc&lt;T, A&gt;where
    F: FnOnce(&amp;Weak&lt;T, A&gt;) -&gt; T,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Arc&lt;T, A&gt;</code> in the given allocator while giving you a <code>Weak&lt;T, A&gt;</code> to the allocation, to allow you to construct a <code>T</code> which holds a weak pointer to itself.</p> <p>Generally, a structure circularly referencing itself, either directly or indirectly, should not hold a strong reference to itself to prevent a memory leak. Using this function, you get access to the weak pointer during the initialization of <code>T</code>, before the <code>Arc&lt;T, A&gt;</code> is created, such that you can clone and store it inside the <code>T</code>.</p> <p><code>new_cyclic_in</code> first allocates the managed allocation for the <code>Arc&lt;T, A&gt;</code>, then calls your closure, giving it a <code>Weak&lt;T, A&gt;</code> to this allocation, and only afterwards completes the construction of the <code>Arc&lt;T, A&gt;</code> by placing the <code>T</code> returned from your closure into the allocation.</p> <p>Since the new <code>Arc&lt;T, A&gt;</code> is not fully-constructed until <code>Arc&lt;T, A&gt;::new_cyclic_in</code> returns, calling <a href="struct.weak.html#method.upgrade" title="method std::sync::Weak::upgrade"><code>upgrade</code></a> on the weak reference inside your closure will fail and result in a <code>None</code> value.</p> <h5 id="panics-1">Panics</h5> <p>If <code>data_fn</code> panics, the panic is propagated to the caller, and the temporary <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak&lt;T&gt;</code></a> is dropped normally.</p> <h5 id="example-1">Example</h5> <p>See <a href="struct.arc.html#method.new_cyclic" title="associated function std::sync::Arc::new_cyclic"><code>new_cyclic</code></a></p> </div>
<summary><section id="method.pin_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#835-837">Source</a><pre class="code-header" data-language="rust">pub fn pin_in(data: T, alloc: A) -&gt; Pin&lt;Arc&lt;T, A&gt;&gt;where
    A: 'static,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator. If <code>T</code> does not implement <code>Unpin</code>, then <code>data</code> will be pinned in memory and unable to be moved.</p> </div>
<summary><section id="method.try_pin_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#846-848">Source</a><pre class="code-header" data-language="rust">pub fn try_pin_in(data: T, alloc: A) -&gt; Result&lt;Pin&lt;Arc&lt;T, A&gt;&gt;, AllocError&gt;where
    A: 'static,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator, return an error if allocation fails.</p> </div>
<summary><section id="method.try_new_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#869">Source</a><pre class="code-header" data-language="rust">pub fn try_new_in(data: T, alloc: A) -&gt; Result&lt;Arc&lt;T, A&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Arc&lt;T, A&gt;</code> in the provided allocator, returning an error if allocation fails.</p> <h5 id="examples-10">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::sync::Arc;
use std::alloc::System;

let five = Arc::try_new_in(5, System)?;</pre></div> </div>
<summary><section id="method.try_new_uninit_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#911">Source</a><pre class="code-header" data-language="rust">pub fn try_new_uninit_in(alloc: A) -&gt; Result&lt;Arc&lt;MaybeUninit&lt;T&gt;, A&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Arc</code> with uninitialized contents, in the provided allocator, returning an error if allocation fails.</p> <h5 id="examples-11">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]
#![feature(get_mut_unchecked)]

use std::sync::Arc;
use std::alloc::System;

let mut five = Arc::&lt;u32, _&gt;::try_new_uninit_in(System)?;

let five = unsafe {
    // Deferred initialization:
    Arc::get_mut_unchecked(&amp;mut five).as_mut_ptr().write(5);

    five.assume_init()
};

assert_eq!(*five, 5);</pre></div> </div>
<summary><section id="method.try_new_zeroed_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#950">Source</a><pre class="code-header" data-language="rust">pub fn try_new_zeroed_in(alloc: A) -&gt; Result&lt;Arc&lt;MaybeUninit&lt;T&gt;, A&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory being filled with <code>0</code> bytes, in the provided allocator, returning an error if allocation fails.</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-12">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::sync::Arc;
use std::alloc::System;

let zero = Arc::&lt;u32, _&gt;::try_new_zeroed_in(System)?;
let zero = unsafe { zero.assume_init() };

assert_eq!(*zero, 0);</pre></div> </div>
<summary><section id="method.try_unwrap" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#997">Source</a></span><pre class="code-header" data-language="rust">pub fn try_unwrap(this: Arc&lt;T, A&gt;) -&gt; Result&lt;T, Arc&lt;T, A&gt;&gt;</pre></section></summary><div class="docblock">
<p>Returns the inner value, if the <code>Arc</code> has exactly one strong reference.</p> <p>Otherwise, an <a href="../result/enum.result.html#variant.Err" title="variant std::result::Result::Err"><code>Err</code></a> is returned with the same <code>Arc</code> that was passed in.</p> <p>This will succeed even if there are outstanding weak references.</p> <p>It is strongly recommended to use <a href="struct.arc.html#method.into_inner" title="associated function std::sync::Arc::into_inner"><code>Arc::into_inner</code></a> instead if you don’t keep the <code>Arc</code> in the <a href="../result/enum.result.html#variant.Err" title="variant std::result::Result::Err"><code>Err</code></a> case. Immediately dropping the <a href="../result/enum.result.html#variant.Err" title="variant std::result::Result::Err"><code>Err</code></a>-value, as the expression <code>Arc::try_unwrap(this).ok()</code> does, can cause the strong count to drop to zero and the inner value of the <code>Arc</code> to be dropped. For instance, if two threads execute such an expression in parallel, there is a race condition without the possibility of unsafety: The threads could first both check whether they own the last instance in <code>Arc::try_unwrap</code>, determine that they both do not, and then both discard and drop their instance in the call to <a href="../result/enum.result.html#method.ok" title="method std::result::Result::ok"><code>ok</code></a>. In this scenario, the value inside the <code>Arc</code> is safely destroyed by exactly one of the threads, but neither thread will ever be able to use the value.</p> <h5 id="examples-13">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let x = Arc::new(3);
assert_eq!(Arc::try_unwrap(x), Ok(3));

let x = Arc::new(4);
let _y = Arc::clone(&amp;x);
assert_eq!(*Arc::try_unwrap(x).unwrap_err(), 4);</pre></div> </div>
<summary><section id="method.into_inner" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1112">Source</a></span><pre class="code-header" data-language="rust">pub fn into_inner(this: Arc&lt;T, A&gt;) -&gt; Option&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Returns the inner value, if the <code>Arc</code> has exactly one strong reference.</p> <p>Otherwise, <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is returned and the <code>Arc</code> is dropped.</p> <p>This will succeed even if there are outstanding weak references.</p> <p>If <code>Arc::into_inner</code> is called on every clone of this <code>Arc</code>, it is guaranteed that exactly one of the calls returns the inner value. This means in particular that the inner value is not dropped.</p> <p><a href="struct.arc.html#method.try_unwrap" title="associated function std::sync::Arc::try_unwrap"><code>Arc::try_unwrap</code></a> is conceptually similar to <code>Arc::into_inner</code>, but it is meant for different use-cases. If used as a direct replacement for <code>Arc::into_inner</code> anyway, such as with the expression <code><a href="struct.arc.html#method.try_unwrap" title="associated function std::sync::Arc::try_unwrap">Arc::try_unwrap</a>(this).<a href="../result/enum.result.html#method.ok" title="method std::result::Result::ok">ok</a>()</code>, then it does <strong>not</strong> give the same guarantee as described in the previous paragraph. For more information, see the examples below and read the documentation of <a href="struct.arc.html#method.try_unwrap" title="associated function std::sync::Arc::try_unwrap"><code>Arc::try_unwrap</code></a>.</p> <h5 id="examples-14">Examples</h5> <p>Minimal example demonstrating the guarantee that <code>Arc::into_inner</code> gives.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let x = Arc::new(3);
let y = Arc::clone(&amp;x);

// Two threads calling `Arc::into_inner` on both clones of an `Arc`:
let x_thread = std::thread::spawn(|| Arc::into_inner(x));
let y_thread = std::thread::spawn(|| Arc::into_inner(y));

let x_inner_value = x_thread.join().unwrap();
let y_inner_value = y_thread.join().unwrap();

// One of the threads is guaranteed to receive the inner value:
assert!(matches!(
    (x_inner_value, y_inner_value),
    (None, Some(3)) | (Some(3), None)
));
// The result could also be `(None, None)` if the threads called
// `Arc::try_unwrap(x).ok()` and `Arc::try_unwrap(y).ok()` instead.</pre></div> <p>A more practical example demonstrating the need for <code>Arc::into_inner</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

// Definition of a simple singly linked list using `Arc`:
#[derive(Clone)]
struct LinkedList&lt;T&gt;(Option&lt;Arc&lt;Node&lt;T&gt;&gt;&gt;);
struct Node&lt;T&gt;(T, Option&lt;Arc&lt;Node&lt;T&gt;&gt;&gt;);

// Dropping a long `LinkedList&lt;T&gt;` relying on the destructor of `Arc`
// can cause a stack overflow. To prevent this, we can provide a
// manual `Drop` implementation that does the destruction in a loop:
impl&lt;T&gt; Drop for LinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut link = self.0.take();
        while let Some(arc_node) = link.take() {
            if let Some(Node(_value, next)) = Arc::into_inner(arc_node) {
                link = next;
            }
        }
    }
}

// Implementation of `new` and `push` omitted
impl&lt;T&gt; LinkedList&lt;T&gt; {
    /* ... */
}

// The following code could have still caused a stack overflow
// despite the manual `Drop` impl if that `Drop` impl had used
// `Arc::try_unwrap(arc).ok()` instead of `Arc::into_inner(arc)`.

// Create a long list and clone it
let mut x = LinkedList::new();
let size = 100000;
for i in 0..size {
    x.push(i); // Adds i to the front of x
}
let y = x.clone();

// Drop the clones in parallel
let x_thread = std::thread::spawn(|| drop(x));
let y_thread = std::thread::spawn(|| drop(y));
x_thread.join().unwrap();
y_thread.join().unwrap();</pre></div> </div>
</div>
<summary><section id="impl-Arc%3C%5BT%5D%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1140">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Arc&lt;[T]&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.new_uninit_slice" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.82.0">1.82.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1166">Source</a></span><pre class="code-header" data-language="rust">pub fn new_uninit_slice(len: usize) -&gt; Arc&lt;[MaybeUninit&lt;T&gt;]&gt;</pre></section></summary><div class="docblock">
<p>Constructs a new atomically reference-counted slice with uninitialized contents.</p> <h5 id="examples-15">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]

use std::sync::Arc;

let mut values = Arc::&lt;[u32]&gt;::new_uninit_slice(3);

// Deferred initialization:
let data = Arc::get_mut(&amp;mut values).unwrap();
data[0].write(1);
data[1].write(2);
data[2].write(3);

let values = unsafe { values.assume_init() };

assert_eq!(*values, [1, 2, 3])</pre></div> </div>
<summary><section id="method.new_zeroed_slice" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1194">Source</a><pre class="code-header" data-language="rust">pub fn new_zeroed_slice(len: usize) -&gt; Arc&lt;[MaybeUninit&lt;T&gt;]&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>new_zeroed_alloc</code> <a href="https://github.com/rust-lang/rust/issues/129396">#129396</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new atomically reference-counted slice with uninitialized contents, with the memory being filled with <code>0</code> bytes.</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-16">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_zeroed_alloc)]

use std::sync::Arc;

let values = Arc::&lt;[u32]&gt;::new_zeroed_slice(3);
let values = unsafe { values.assume_init() };

assert_eq!(*values, [0, 0, 0])</pre></div> </div>
<summary><section id="method.into_array" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1215">Source</a><pre class="code-header" data-language="rust">pub fn into_array&lt;const N: usize&gt;(self) -&gt; Option&lt;Arc&lt;[T; N]&gt;&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_as_array</code> <a href="https://github.com/rust-lang/rust/issues/133508">#133508</a>)</span>
</div></span></summary><div class="docblock">
<p>Converts the reference-counted slice into a reference-counted array.</p> <p>This operation does not reallocate; the underlying array of the slice is simply reinterpreted as an array type.</p> <p>If <code>N</code> is not exactly equal to the length of <code>self</code>, then this method returns <code>None</code>.</p> </div>
</div>
<summary><section id="impl-Arc%3C%5BT%5D,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1228">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Arc&lt;[T], A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.new_uninit_slice_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1257">Source</a><pre class="code-header" data-language="rust">pub fn new_uninit_slice_in(len: usize, alloc: A) -&gt; Arc&lt;[MaybeUninit&lt;T&gt;], A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new atomically reference-counted slice with uninitialized contents in the provided allocator.</p> <h5 id="examples-17">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]
#![feature(allocator_api)]

use std::sync::Arc;
use std::alloc::System;

let mut values = Arc::&lt;[u32], _&gt;::new_uninit_slice_in(3, System);

let values = unsafe {
    // Deferred initialization:
    Arc::get_mut_unchecked(&amp;mut values)[0].as_mut_ptr().write(1);
    Arc::get_mut_unchecked(&amp;mut values)[1].as_mut_ptr().write(2);
    Arc::get_mut_unchecked(&amp;mut values)[2].as_mut_ptr().write(3);

    values.assume_init()
};

assert_eq!(*values, [1, 2, 3])</pre></div> </div>
<summary><section id="method.new_zeroed_slice_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1285">Source</a><pre class="code-header" data-language="rust">pub fn new_zeroed_slice_in(len: usize, alloc: A) -&gt; Arc&lt;[MaybeUninit&lt;T&gt;], A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new atomically reference-counted slice with uninitialized contents, with the memory being filled with <code>0</code> bytes, in the provided allocator.</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-18">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::sync::Arc;
use std::alloc::System;

let values = Arc::&lt;[u32], _&gt;::new_zeroed_slice_in(3, System);
let values = unsafe { values.assume_init() };

assert_eq!(*values, [0, 0, 0])</pre></div> </div>
</div>
<summary><section id="impl-Arc%3CMaybeUninit%3CT%3E,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1302">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Arc&lt;MaybeUninit&lt;T&gt;, A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.assume_init" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.82.0">1.82.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1334">Source</a></span><pre class="code-header" data-language="rust">pub unsafe fn assume_init(self) -&gt; Arc&lt;T, A&gt;</pre></section></summary><div class="docblock">
<p>Converts to <code>Arc&lt;T&gt;</code>.</p> <h5 id="safety">Safety</h5> <p>As with <a href="../mem/union.maybeuninit.html#method.assume_init" title="method std::mem::MaybeUninit::assume_init"><code>MaybeUninit::assume_init</code></a>, it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</p> <h5 id="examples-19">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]

use std::sync::Arc;

let mut five = Arc::&lt;u32&gt;::new_uninit();

// Deferred initialization:
Arc::get_mut(&amp;mut five).unwrap().write(5);

let five = unsafe { five.assume_init() };

assert_eq!(*five, 5)</pre></div> </div>
</div>
<summary><section id="impl-Arc%3C%5BMaybeUninit%3CT%3E%5D,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1340">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Arc&lt;[MaybeUninit&lt;T&gt;], A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.assume_init-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.82.0">1.82.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1375">Source</a></span><pre class="code-header" data-language="rust">pub unsafe fn assume_init(self) -&gt; Arc&lt;[T], A&gt;</pre></section></summary><div class="docblock">
<p>Converts to <code>Arc&lt;[T]&gt;</code>.</p> <h5 id="safety-1">Safety</h5> <p>As with <a href="../mem/union.maybeuninit.html#method.assume_init" title="method std::mem::MaybeUninit::assume_init"><code>MaybeUninit::assume_init</code></a>, it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</p> <h5 id="examples-20">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]

use std::sync::Arc;

let mut values = Arc::&lt;[u32]&gt;::new_uninit_slice(3);

// Deferred initialization:
let data = Arc::get_mut(&amp;mut values).unwrap();
data[0].write(1);
data[1].write(2);
data[2].write(3);

let values = unsafe { values.assume_init() };

assert_eq!(*values, [1, 2, 3])</pre></div> </div>
</div>
<summary><section id="impl-Arc%3CT%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1381">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Arc&lt;T&gt;where
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.from_raw" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1443">Source</a></span><pre class="code-header" data-language="rust">pub unsafe fn from_raw(ptr: *const T) -&gt; Arc&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Constructs an <code>Arc&lt;T&gt;</code> from a raw pointer.</p> <p>The raw pointer must have been previously returned by a call to <a href="struct.arc.html#method.into_raw" title="associated function std::sync::Arc::into_raw"><code>Arc&lt;U&gt;::into_raw</code></a> with the following requirements:</p> <ul> <li>If <code>U</code> is sized, it must have the same size and alignment as <code>T</code>. This is trivially true if <code>U</code> is <code>T</code>.</li> <li>If <code>U</code> is unsized, its data pointer must have the same size and alignment as <code>T</code>. This is trivially true if <code>Arc&lt;U&gt;</code> was constructed through <code>Arc&lt;T&gt;</code> and then converted to <code>Arc&lt;U&gt;</code> through an <a href="../../reference/type-coercions.html#unsized-coercions">unsized coercion</a>.</li> </ul> <p>Note that if <code>U</code> or <code>U</code>’s data pointer is not <code>T</code> but has the same size and alignment, this is basically like transmuting references of different types. See <a href="../intrinsics/fn.transmute.html" title="fn std::intrinsics::transmute"><code>mem::transmute</code></a> for more information on what restrictions apply in this case.</p> <p>The user of <code>from_raw</code> has to make sure a specific value of <code>T</code> is only dropped once.</p> <p>This function is unsafe because improper use may lead to memory unsafety, even if the returned <code>Arc&lt;T&gt;</code> is never accessed.</p> <h5 id="examples-21">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let x = Arc::new("hello".to_owned());
let x_ptr = Arc::into_raw(x);

unsafe {
    // Convert back to an `Arc` to prevent leak.
    let x = Arc::from_raw(x_ptr);
    assert_eq!(&amp;*x, "hello");

    // Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.
}

// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!</pre></div> <p>Convert a slice back into its original array:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let x: Arc&lt;[u32]&gt; = Arc::new([1, 2, 3]);
let x_ptr: *const [u32] = Arc::into_raw(x);

unsafe {
    let x: Arc&lt;[u32; 3]&gt; = Arc::from_raw(x_ptr.cast::&lt;[u32; 3]&gt;());
    assert_eq!(&amp;*x, &amp;[1, 2, 3]);
}</pre></div> </div>
<summary><section id="method.increment_strong_count" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1477">Source</a></span><pre class="code-header" data-language="rust">pub unsafe fn increment_strong_count(ptr: *const T)</pre></section></summary><div class="docblock">
<p>Increments the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the provided pointer by one.</p> <h5 id="safety-2">Safety</h5> <p>The pointer must have been obtained through <code>Arc::into_raw</code>, and the associated <code>Arc</code> instance must be valid (i.e. the strong count must be at least 1) for the duration of this method.</p> <h5 id="examples-22">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);

unsafe {
    let ptr = Arc::into_raw(five);
    Arc::increment_strong_count(ptr);

    // This assertion is deterministic because we haven't shared
    // the `Arc` between threads.
    let five = Arc::from_raw(ptr);
    assert_eq!(2, Arc::strong_count(&amp;five));
}</pre></div> </div>
<summary><section id="method.decrement_strong_count" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1513">Source</a></span><pre class="code-header" data-language="rust">pub unsafe fn decrement_strong_count(ptr: *const T)</pre></section></summary><div class="docblock">
<p>Decrements the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the provided pointer by one.</p> <h5 id="safety-3">Safety</h5> <p>The pointer must have been obtained through <code>Arc::into_raw</code>, and the associated <code>Arc</code> instance must be valid (i.e. the strong count must be at least 1) when invoking this method. This method can be used to release the final <code>Arc</code> and backing storage, but <strong>should not</strong> be called after the final <code>Arc</code> has been released.</p> <h5 id="examples-23">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);

unsafe {
    let ptr = Arc::into_raw(five);
    Arc::increment_strong_count(ptr);

    // Those assertions are deterministic because we haven't shared
    // the `Arc` between threads.
    let five = Arc::from_raw(ptr);
    assert_eq!(2, Arc::strong_count(&amp;five));
    Arc::decrement_strong_count(ptr);
    assert_eq!(1, Arc::strong_count(&amp;five));
}</pre></div> </div>
</div>
<summary><section id="impl-Arc%3CT,+A%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1518">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Arc&lt;T, A&gt;where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.allocator" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1526">Source</a><pre class="code-header" data-language="rust">pub fn allocator(this: &amp;Arc&lt;T, A&gt;) -&gt; &amp;A</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns a reference to the underlying allocator.</p> <p>Note: this is an associated function, which means that you have to call it as <code>Arc::allocator(&amp;a)</code> instead of <code>a.allocator()</code>. This is so that there is no conflict with a method on the inner type.</p> </div>
<summary><section id="method.into_raw" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1549">Source</a></span><pre class="code-header" data-language="rust">pub fn into_raw(this: Arc&lt;T, A&gt;) -&gt; *const T</pre></section></summary><div class="docblock">
<p>Consumes the <code>Arc</code>, returning the wrapped pointer.</p> <p>To avoid a memory leak the pointer must be converted back to an <code>Arc</code> using <a href="struct.arc.html#method.from_raw" title="associated function std::sync::Arc::from_raw"><code>Arc::from_raw</code></a>.</p> <h5 id="examples-24">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let x = Arc::new("hello".to_owned());
let x_ptr = Arc::into_raw(x);
assert_eq!(unsafe { &amp;*x_ptr }, "hello");</pre></div> </div>
<summary><section id="method.into_raw_with_allocator" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1574">Source</a><pre class="code-header" data-language="rust">pub fn into_raw_with_allocator(this: Arc&lt;T, A&gt;) -&gt; (*const T, A)</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Consumes the <code>Arc</code>, returning the wrapped pointer and allocator.</p> <p>To avoid a memory leak the pointer must be converted back to an <code>Arc</code> using <a href="struct.arc.html#method.from_raw_in" title="associated function std::sync::Arc::from_raw_in"><code>Arc::from_raw_in</code></a>.</p> <h5 id="examples-25">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]
use std::sync::Arc;
use std::alloc::System;

let x = Arc::new_in("hello".to_owned(), System);
let (ptr, alloc) = Arc::into_raw_with_allocator(x);
assert_eq!(unsafe { &amp;*ptr }, "hello");
let x = unsafe { Arc::from_raw_in(ptr, alloc) };
assert_eq!(&amp;*x, "hello");</pre></div> </div>
<summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1601">Source</a></span><pre class="code-header" data-language="rust">pub fn as_ptr(this: &amp;Arc&lt;T, A&gt;) -&gt; *const T</pre></section></summary><div class="docblock">
<p>Provides a raw pointer to the data.</p> <p>The counts are not affected in any way and the <code>Arc</code> is not consumed. The pointer is valid for as long as there are strong counts in the <code>Arc</code>.</p> <h5 id="examples-26">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let x = Arc::new("hello".to_owned());
let y = Arc::clone(&amp;x);
let x_ptr = Arc::as_ptr(&amp;x);
assert_eq!(x_ptr, Arc::as_ptr(&amp;y));
assert_eq!(unsafe { &amp;*x_ptr }, "hello");</pre></div> </div>
<summary><section id="method.from_raw_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1679">Source</a><pre class="code-header" data-language="rust">pub unsafe fn from_raw_in(ptr: *const T, alloc: A) -&gt; Arc&lt;T, A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs an <code>Arc&lt;T, A&gt;</code> from a raw pointer.</p> <p>The raw pointer must have been previously returned by a call to <a href="struct.arc.html#method.into_raw" title="associated function std::sync::Arc::into_raw"><code>Arc&lt;U, A&gt;::into_raw</code></a> with the following requirements:</p> <ul> <li>If <code>U</code> is sized, it must have the same size and alignment as <code>T</code>. This is trivially true if <code>U</code> is <code>T</code>.</li> <li>If <code>U</code> is unsized, its data pointer must have the same size and alignment as <code>T</code>. This is trivially true if <code>Arc&lt;U&gt;</code> was constructed through <code>Arc&lt;T&gt;</code> and then converted to <code>Arc&lt;U&gt;</code> through an <a href="../../reference/type-coercions.html#unsized-coercions">unsized coercion</a>.</li> </ul> <p>Note that if <code>U</code> or <code>U</code>’s data pointer is not <code>T</code> but has the same size and alignment, this is basically like transmuting references of different types. See <a href="../intrinsics/fn.transmute.html" title="fn std::intrinsics::transmute"><code>mem::transmute</code></a> for more information on what restrictions apply in this case.</p> <p>The raw pointer must point to a block of memory allocated by <code>alloc</code></p> <p>The user of <code>from_raw</code> has to make sure a specific value of <code>T</code> is only dropped once.</p> <p>This function is unsafe because improper use may lead to memory unsafety, even if the returned <code>Arc&lt;T&gt;</code> is never accessed.</p> <h5 id="examples-27">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::sync::Arc;
use std::alloc::System;

let x = Arc::new_in("hello".to_owned(), System);
let x_ptr = Arc::into_raw(x);

unsafe {
    // Convert back to an `Arc` to prevent leak.
    let x = Arc::from_raw_in(x_ptr, System);
    assert_eq!(&amp;*x, "hello");

    // Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.
}

// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!</pre></div> <p>Convert a slice back into its original array:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::sync::Arc;
use std::alloc::System;

let x: Arc&lt;[u32], _&gt; = Arc::new_in([1, 2, 3], System);
let x_ptr: *const [u32] = Arc::into_raw(x);

unsafe {
    let x: Arc&lt;[u32; 3], _&gt; = Arc::from_raw_in(x_ptr.cast::&lt;[u32; 3]&gt;(), System);
    assert_eq!(&amp;*x, &amp;[1, 2, 3]);
}</pre></div> </div>
<summary><section id="method.downgrade" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1704-1706">Source</a></span><pre class="code-header" data-language="rust">pub fn downgrade(this: &amp;Arc&lt;T, A&gt;) -&gt; Weak&lt;T, A&gt;where
    A: Clone,</pre></section></summary><div class="docblock">
<p>Creates a new <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> pointer to this allocation.</p> <h5 id="examples-28">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);

let weak_five = Arc::downgrade(&amp;five);</pre></div> </div>
<summary><section id="method.weak_count" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.15.0">1.15.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1764">Source</a></span><pre class="code-header" data-language="rust">pub fn weak_count(this: &amp;Arc&lt;T, A&gt;) -&gt; usize</pre></section></summary><div class="docblock">
<p>Gets the number of <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> pointers to this allocation.</p> <h5 id="safety-4">Safety</h5> <p>This method by itself is safe, but using it correctly requires extra care. Another thread can change the weak count at any time, including potentially between calling this method and acting on the result.</p> <h5 id="examples-29">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);
let _weak_five = Arc::downgrade(&amp;five);

// This assertion is deterministic because we haven't shared
// the `Arc` or `Weak` between threads.
assert_eq!(1, Arc::weak_count(&amp;five));</pre></div> </div>
<summary><section id="method.strong_count" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.15.0">1.15.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1794">Source</a></span><pre class="code-header" data-language="rust">pub fn strong_count(this: &amp;Arc&lt;T, A&gt;) -&gt; usize</pre></section></summary><div class="docblock">
<p>Gets the number of strong (<code>Arc</code>) pointers to this allocation.</p> <h5 id="safety-5">Safety</h5> <p>This method by itself is safe, but using it correctly requires extra care. Another thread can change the strong count at any time, including potentially between calling this method and acting on the result.</p> <h5 id="examples-30">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);
let _also_five = Arc::clone(&amp;five);

// This assertion is deterministic because we haven't shared
// the `Arc` between threads.
assert_eq!(2, Arc::strong_count(&amp;five));</pre></div> </div>
<summary><section id="method.increment_strong_count_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1832-1834">Source</a><pre class="code-header" data-language="rust">pub unsafe fn increment_strong_count_in(ptr: *const T, alloc: A)where
    A: Clone,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Increments the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the provided pointer by one.</p> <h5 id="safety-6">Safety</h5> <p>The pointer must have been obtained through <code>Arc::into_raw</code>, and the associated <code>Arc</code> instance must be valid (i.e. the strong count must be at least 1) for the duration of this method,, and <code>ptr</code> must point to a block of memory allocated by <code>alloc</code>.</p> <h5 id="examples-31">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::sync::Arc;
use std::alloc::System;

let five = Arc::new_in(5, System);

unsafe {
    let ptr = Arc::into_raw(five);
    Arc::increment_strong_count_in(ptr, System);

    // This assertion is deterministic because we haven't shared
    // the `Arc` between threads.
    let five = Arc::from_raw_in(ptr, System);
    assert_eq!(2, Arc::strong_count(&amp;five));
}</pre></div> </div>
<summary><section id="method.decrement_strong_count_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1878">Source</a><pre class="code-header" data-language="rust">pub unsafe fn decrement_strong_count_in(ptr: *const T, alloc: A)</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Decrements the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the provided pointer by one.</p> <h5 id="safety-7">Safety</h5> <p>The pointer must have been obtained through <code>Arc::into_raw</code>, the associated <code>Arc</code> instance must be valid (i.e. the strong count must be at least 1) when invoking this method, and <code>ptr</code> must point to a block of memory allocated by <code>alloc</code>. This method can be used to release the final <code>Arc</code> and backing storage, but <strong>should not</strong> be called after the final <code>Arc</code> has been released.</p> <h5 id="examples-32">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::sync::Arc;
use std::alloc::System;

let five = Arc::new_in(5, System);

unsafe {
    let ptr = Arc::into_raw(five);
    Arc::increment_strong_count_in(ptr, System);

    // Those assertions are deterministic because we haven't shared
    // the `Arc` between threads.
    let five = Arc::from_raw_in(ptr, System);
    assert_eq!(2, Arc::strong_count(&amp;five));
    Arc::decrement_strong_count_in(ptr, System);
    assert_eq!(1, Arc::strong_count(&amp;five));
}</pre></div> </div>
<summary><section id="method.ptr_eq" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#1928">Source</a></span><pre class="code-header" data-language="rust">pub fn ptr_eq(this: &amp;Arc&lt;T, A&gt;, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the two <code>Arc</code>s point to the same allocation in a vein similar to <a href="../ptr/fn.eq.html" title="ptr::eq"><code>ptr::eq</code></a>. This function ignores the metadata of <code>dyn Trait</code> pointers.</p> <h5 id="examples-33">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);
let same_five = Arc::clone(&amp;five);
let other_five = Arc::new(5);

assert!(Arc::ptr_eq(&amp;five, &amp;same_five));
assert!(!Arc::ptr_eq(&amp;five, &amp;other_five));</pre></div> </div>
</div>
<summary><section id="impl-Arc%3CT,+A%3E-2" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2218">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Arc&lt;T, A&gt;where
    T: CloneToUninit + ?Sized,
    A: Allocator + Clone,</pre></section></summary><div class="impl-items">
<summary><section id="method.make_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2271">Source</a></span><pre class="code-header" data-language="rust">pub fn make_mut(this: &amp;mut Arc&lt;T, A&gt;) -&gt; &amp;mut T</pre></section></summary><div class="docblock">
<p>Makes a mutable reference into the given <code>Arc</code>.</p> <p>If there are other <code>Arc</code> pointers to the same allocation, then <code>make_mut</code> will <a href="../clone/trait.clone.html#tymethod.clone" title="method std::clone::Clone::clone"><code>clone</code></a> the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</p> <p>However, if there are no other <code>Arc</code> pointers to this allocation, but some <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> pointers, then the <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> pointers will be dissociated and the inner value will not be cloned.</p> <p>See also <a href="struct.arc.html#method.get_mut" title="associated function std::sync::Arc::get_mut"><code>get_mut</code></a>, which will fail rather than cloning the inner value or dissociating <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> pointers.</p> <h5 id="examples-34">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let mut data = Arc::new(5);

*Arc::make_mut(&amp;mut data) += 1;         // Won't clone anything
let mut other_data = Arc::clone(&amp;data); // Won't clone inner data
*Arc::make_mut(&amp;mut data) += 1;         // Clones inner data
*Arc::make_mut(&amp;mut data) += 1;         // Won't clone anything
*Arc::make_mut(&amp;mut other_data) *= 2;   // Won't clone anything

// Now `data` and `other_data` point to different allocations.
assert_eq!(*data, 8);
assert_eq!(*other_data, 12);</pre></div> <p><a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> pointers will be dissociated:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let mut data = Arc::new(75);
let weak = Arc::downgrade(&amp;data);

assert!(75 == *data);
assert!(75 == *weak.upgrade().unwrap());

*Arc::make_mut(&amp;mut data) += 1;

assert!(76 == *data);
assert!(weak.upgrade().is_none());</pre></div> </div>
</div>
<summary><section id="impl-Arc%3CT,+A%3E-3" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2344">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Arc&lt;T, A&gt;where
    T: Clone,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.unwrap_or_clone" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.76.0">1.76.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2375">Source</a></span><pre class="code-header" data-language="rust">pub fn unwrap_or_clone(this: Arc&lt;T, A&gt;) -&gt; T</pre></section></summary><div class="docblock">
<p>If we have the only reference to <code>T</code> then unwrap it. Otherwise, clone <code>T</code> and return the clone.</p> <p>Assuming <code>arc_t</code> is of type <code>Arc&lt;T&gt;</code>, this function is functionally equivalent to <code>(*arc_t).clone()</code>, but will avoid cloning the inner value where possible.</p> <h5 id="examples-35">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let inner = String::from("test");
let ptr = inner.as_ptr();

let arc = Arc::new(inner);
let inner = Arc::unwrap_or_clone(arc);
// The inner value was not cloned
assert!(ptr::eq(ptr, inner.as_ptr()));

let arc = Arc::new(inner);
let arc2 = arc.clone();
let inner = Arc::unwrap_or_clone(arc);
// Because there were 2 references, we had to clone the inner value.
assert!(!ptr::eq(ptr, inner.as_ptr()));
// `arc2` is the last reference, so when we unwrap it we get back
// the original `String`.
let inner = Arc::unwrap_or_clone(arc2);
assert!(ptr::eq(ptr, inner.as_ptr()));</pre></div> </div>
</div>
<summary><section id="impl-Arc%3CT,+A%3E-4" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2380">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Arc&lt;T, A&gt;where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.get_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2407">Source</a></span><pre class="code-header" data-language="rust">pub fn get_mut(this: &amp;mut Arc&lt;T, A&gt;) -&gt; Option&lt;&amp;mut T&gt;</pre></section></summary><div class="docblock">
<p>Returns a mutable reference into the given <code>Arc</code>, if there are no other <code>Arc</code> or <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> pointers to the same allocation.</p> <p>Returns <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> otherwise, because it is not safe to mutate a shared value.</p> <p>See also <a href="struct.arc.html#method.make_mut" title="associated function std::sync::Arc::make_mut"><code>make_mut</code></a>, which will <a href="../clone/trait.clone.html#tymethod.clone" title="method std::clone::Clone::clone"><code>clone</code></a> the inner value when there are other <code>Arc</code> pointers.</p> <h5 id="examples-36">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let mut x = Arc::new(3);
*Arc::get_mut(&amp;mut x).unwrap() = 4;
assert_eq!(*x, 4);

let _y = Arc::clone(&amp;x);
assert!(Arc::get_mut(&amp;mut x).is_none());</pre></div> </div>
<summary><section id="method.get_mut_unchecked" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2482">Source</a><pre class="code-header" data-language="rust">pub unsafe fn get_mut_unchecked(this: &amp;mut Arc&lt;T, A&gt;) -&gt; &amp;mut T</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>get_mut_unchecked</code> <a href="https://github.com/rust-lang/rust/issues/63292">#63292</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns a mutable reference into the given <code>Arc</code>, without any check.</p> <p>See also <a href="struct.arc.html#method.get_mut" title="associated function std::sync::Arc::get_mut"><code>get_mut</code></a>, which is safe and does appropriate checks.</p> <h5 id="safety-8">Safety</h5> <p>If any other <code>Arc</code> or <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a> pointers to the same allocation exist, then they must not be dereferenced or have active borrows for the duration of the returned borrow, and their inner type must be exactly the same as the inner type of this Rc (including lifetimes). This is trivially the case if no such pointers exist, for example immediately after <code>Arc::new</code>.</p> <h5 id="examples-37">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]

use std::sync::Arc;

let mut x = Arc::new(String::new());
unsafe {
    Arc::get_mut_unchecked(&amp;mut x).push_str("foo")
}
assert_eq!(*x, "foo");</pre></div> <p>Other <code>Arc</code> pointers to the same allocation must be to the same type.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]

use std::sync::Arc;

let x: Arc&lt;str&gt; = Arc::from("Hello, world!");
let mut y: Arc&lt;[u8]&gt; = x.clone().into();
unsafe {
    // this is Undefined Behavior, because x's inner type is str, not [u8]
    Arc::get_mut_unchecked(&amp;mut y).fill(0xff); // 0xff is invalid in UTF-8
}
println!("{}", &amp;*x); // Invalid UTF-8 in a str</pre></div> <p>Other <code>Arc</code> pointers to the same allocation must be to the exact same type, including lifetimes.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]

use std::sync::Arc;

let x: Arc&lt;&amp;str&gt; = Arc::new("Hello, world!");
{
    let s = String::from("Oh, no!");
    let mut y: Arc&lt;&amp;str&gt; = x.clone().into();
    unsafe {
        // this is Undefined Behavior, because x's inner type
        // is &amp;'long str, not &amp;'short str
        *Arc::get_mut_unchecked(&amp;mut y) = &amp;s;
    }
}
println!("{}", &amp;*x); // Use-after-free</pre></div> </div>
</div>
<summary><section id="impl-Arc%3Cdyn+Any+%2B+Send+%2B+Sync,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2597">Source</a><pre class="code-header" data-language="rust">impl&lt;A&gt; Arc&lt;dyn Any + Sync + Send, A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.downcast" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2618-2620">Source</a></span><pre class="code-header" data-language="rust">pub fn downcast&lt;T&gt;(self) -&gt; Result&lt;Arc&lt;T, A&gt;, Arc&lt;dyn Any + Sync + Send, A&gt;&gt;where
    T: Any + Send + Sync,</pre></section></summary><div class="docblock">
<p>Attempts to downcast the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete type.</p> <h5 id="examples-38">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::any::Any;
use std::sync::Arc;

fn print_if_string(value: Arc&lt;dyn Any + Send + Sync&gt;) {
    if let Ok(string) = value.downcast::&lt;String&gt;() {
        println!("String ({}): {}", string.len(), string);
    }
}

let my_string = "Hello World".to_string();
print_if_string(Arc::new(my_string));
print_if_string(Arc::new(0i8));</pre></div> </div>
<summary><section id="method.downcast_unchecked" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2660-2662">Source</a><pre class="code-header" data-language="rust">pub unsafe fn downcast_unchecked&lt;T&gt;(self) -&gt; Arc&lt;T, A&gt;where
    T: Any + Send + Sync,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>downcast_unchecked</code> <a href="https://github.com/rust-lang/rust/issues/90850">#90850</a>)</span>
</div></span></summary><div class="docblock">
<p>Downcasts the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete type.</p> <p>For a safe alternative see <a href="struct.arc.html#method.downcast" title="method std::sync::Arc::downcast"><code>downcast</code></a>.</p> <h5 id="examples-39">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(downcast_unchecked)]

use std::any::Any;
use std::sync::Arc;

let x: Arc&lt;dyn Any + Send + Sync&gt; = Arc::new(1_usize);

unsafe {
    assert_eq!(*x.downcast_unchecked::&lt;usize&gt;(), 1);
}</pre></div> <h5 id="safety-9">Safety</h5> <p>The contained value must be of type <code>T</code>. Calling this method with the incorrect type is <em>undefined behavior</em>.</p> </div>
</div>
</div>
<h3 id="trait-implementations" class="section-header">Trait Implementations</h3>
<div id="trait-implementations-list">
<summary><section id="impl-AsFd-for-Arc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0">1.64.0</span><a class="src" href="https://doc.rust-lang.org/src/std/os/fd/owned.rs.html#416-421">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T: AsFd + ?Sized&gt; AsFd for Arc&lt;T&gt;This impl allows implementing traits that require AsFd on Arc.
</pre></section></summary><div class="docblock"> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::net::UdpSocket;
use std::sync::Arc;

trait MyTrait: AsFd {}
impl MyTrait for Arc&lt;UdpSocket&gt; {}
impl MyTrait for Box&lt;UdpSocket&gt; {}</pre></div> </div>
<div class="impl-items">
<summary><section id="method.as_fd" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/fd/owned.rs.html#418-420">Source</a><pre class="code-header" data-language="rust">fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt;</pre></section></summary><div class="docblock">Borrows the file descriptor. <a href="../os/fd/trait.asfd.html#tymethod.as_fd">Read more</a>
</div>
</div>
<summary><section id="impl-AsHandle-for-Arc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.71.0">1.71.0</span><a class="src" href="https://doc.rust-lang.org/src/std/os/windows/io/handle.rs.html#473-478">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T: AsHandle + ?Sized&gt; AsHandle for Arc&lt;T&gt;Available on Windows only.This impl allows implementing traits that require AsHandle on Arc.
</pre></section></summary><div class="docblock"> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::fs::File;
use std::sync::Arc;

trait MyTrait: AsHandle {}
impl MyTrait for Arc&lt;File&gt; {}
impl MyTrait for Box&lt;File&gt; {}</pre></div> </div>
<div class="impl-items">
<summary><section id="method.as_handle" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/windows/io/handle.rs.html#475-477">Source</a><pre class="code-header" data-language="rust">fn as_handle(&amp;self) -&gt; BorrowedHandle&lt;'_&gt;</pre></section></summary><div class="docblock">Borrows the handle. <a href="../os/windows/io/trait.ashandle.html#tymethod.as_handle">Read more</a>
</div>
</div>
<summary><section id="impl-AsRawFd-for-Arc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.63.0">1.63.0</span><a class="src" href="https://doc.rust-lang.org/src/std/os/fd/raw.rs.html#254-259">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T: AsRawFd&gt; AsRawFd for Arc&lt;T&gt;This impl allows implementing traits that require AsRawFd on Arc.
</pre></section></summary><div class="docblock"> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::net::UdpSocket;
use std::sync::Arc;
trait MyTrait: AsRawFd {
}
impl MyTrait for Arc&lt;UdpSocket&gt; {}
impl MyTrait for Box&lt;UdpSocket&gt; {}</pre></div> </div>
<div class="impl-items">
<summary><section id="method.as_raw_fd" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/fd/raw.rs.html#256-258">Source</a><pre class="code-header" data-language="rust">fn as_raw_fd(&amp;self) -&gt; RawFd</pre></section></summary><div class="docblock">Extracts the raw file descriptor. <a href="../os/fd/trait.asrawfd.html#tymethod.as_raw_fd">Read more</a>
</div>
</div>
<summary><section id="impl-AsRef%3CT%3E-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3918">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; AsRef&lt;T&gt; for Arc&lt;T, A&gt;where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3919">Source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsSocket-for-Arc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.71.0">1.71.0</span><a class="src" href="https://doc.rust-lang.org/src/std/os/windows/io/socket.rs.html#267-272">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T: AsSocket&gt; AsSocket for Arc&lt;T&gt;Available on Windows only.This impl allows implementing traits that require AsSocket on Arc.
</pre></section></summary><div class="docblock"> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::net::UdpSocket;
use std::sync::Arc;

trait MyTrait: AsSocket {}
impl MyTrait for Arc&lt;UdpSocket&gt; {}
impl MyTrait for Box&lt;UdpSocket&gt; {}</pre></div> </div>
<div class="impl-items">
<summary><section id="method.as_socket" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/windows/io/socket.rs.html#269-271">Source</a><pre class="code-header" data-language="rust">fn as_socket(&amp;self) -&gt; BorrowedSocket&lt;'_&gt;</pre></section></summary><div class="docblock">Borrows the socket.</div>
</div>
<summary><section id="impl-Borrow%3CT%3E-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3911">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Borrow&lt;T&gt; for Arc&lt;T, A&gt;where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3912">Source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="../borrow/trait.borrow.html#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-Clone-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2142">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Clone for Arc&lt;T, A&gt;where
    A: Allocator + Clone,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2158">Source</a><pre class="code-header" data-language="rust">fn clone(&amp;self) -&gt; Arc&lt;T, A&gt;</pre></section></summary><div class="docblock">
<p>Makes a clone of the <code>Arc</code> pointer.</p> <p>This creates another pointer to the same allocation, increasing the strong reference count.</p> <h5 id="examples-41">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);

let _ = Arc::clone(&amp;five);</pre></div> </div>
<summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/clone.rs.html#174">Source</a></span><pre class="code-header" data-language="rust">fn clone_from(&amp;mut self, source: &amp;Self)</pre></section></summary><div class="docblock">Performs copy-assignment from <code>source</code>. <a href="../clone/trait.clone.html#method.clone_from">Read more</a>
</div>
</div>
<summary><section id="impl-Debug-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3445">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Debug for Arc&lt;T, A&gt;where
    T: Debug + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3446">Source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="../fmt/trait.debug.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Default-for-Arc%3C%5BT%5D%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3543">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; Default for Arc&lt;[T]&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.default-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3548">Source</a><pre class="code-header" data-language="rust">fn default() -&gt; Arc&lt;[T]&gt;</pre></section></summary><div class="docblock">
<p>Creates an empty <code>[T]</code> inside an Arc</p> <p>This may or may not share an allocation with other Arcs.</p> </div>
</div>
<summary><section id="impl-Default-for-Arc%3CCStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3524">Source</a></span><pre class="code-header" data-language="rust">impl Default for Arc&lt;CStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.default-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3529">Source</a><pre class="code-header" data-language="rust">fn default() -&gt; Arc&lt;CStr&gt;</pre></section></summary><div class="docblock">
<p>Creates an empty CStr inside an Arc</p> <p>This may or may not share an allocation with other Arcs.</p> </div>
</div>
<summary><section id="impl-Default-for-Arc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3460">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; Default for Arc&lt;T&gt;where
    T: Default,</pre></section></summary><div class="impl-items">
<summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3471">Source</a><pre class="code-header" data-language="rust">fn default() -&gt; Arc&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Creates a new <code>Arc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.</p> <h5 id="examples-42">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let x: Arc&lt;i32&gt; = Default::default();
assert_eq!(*x, 0);</pre></div> </div>
</div>
<summary><section id="impl-Default-for-Arc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3509">Source</a></span><pre class="code-header" data-language="rust">impl Default for Arc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.default-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3514">Source</a><pre class="code-header" data-language="rust">fn default() -&gt; Arc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Creates an empty str inside an Arc</p> <p>This may or may not share an allocation with other Arcs.</p> </div>
</div>
<summary><section id="impl-Deref-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2196">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Deref for Arc&lt;T, A&gt;where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2197">Source</a><pre class="code-header" data-language="rust">type Target = T</pre></section></summary><div class="docblock">The resulting type after dereferencing.</div>
<summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2200">Source</a><pre class="code-header" data-language="rust">fn deref(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Dereferences the value.</div>
</div>
<summary><section id="impl-Display-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3438">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Display for Arc&lt;T, A&gt;where
    T: Display + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3439">Source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="../fmt/trait.display.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Drop-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2518">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Drop for Arc&lt;T, A&gt;where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2545">Source</a><pre class="code-header" data-language="rust">fn drop(&amp;mut self)</pre></section></summary><div class="docblock">
<p>Drops the <code>Arc</code>.</p> <p>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are <a href="struct.weak.html" title="struct std::sync::Weak"><code>Weak</code></a>, so we <code>drop</code> the inner value.</p> <h5 id="examples-40">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

struct Foo;

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!("dropped!");
    }
}

let foo  = Arc::new(Foo);
let foo2 = Arc::clone(&amp;foo);

drop(foo);    // Doesn't print anything
drop(foo2);   // Prints "dropped!"</pre></div> </div>
</div>
<summary><section id="impl-Error-for-Arc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#4013">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; Error for Arc&lt;T&gt;where
    T: Error + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.description" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#4015">Source</a><pre class="code-header" data-language="rust">fn description(&amp;self) -&gt; &amp;str</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.42.0: use the Display impl or to_string()</span>
</div></span><div class="docblock"> <a href="../error/trait.error.html#method.description">Read more</a>
</div>
<summary><section id="method.cause" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#4020">Source</a><pre class="code-header" data-language="rust">fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt;</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.33.0: replaced by Error::source, which can support downcasting</span>
</div></span><summary><section id="method.source" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#4024">Source</a><pre class="code-header" data-language="rust">fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt;</pre></section></summary><div class="docblock">Returns the lower-level source of this error, if any. <a href="../error/trait.error.html#method.source">Read more</a>
</div>
<summary><section id="method.provide" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#4028">Source</a><pre class="code-header" data-language="rust">fn provide&lt;'a&gt;(&amp;'a self, req: &amp;mut Request&lt;'a&gt;)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>error_generic_member_access</code> <a href="https://github.com/rust-lang/rust/issues/99301">#99301</a>)</span>
</div></span><div class="docblock">Provides type-based access to context intended for error reports. <a href="../error/trait.error.html#method.provide">Read more</a>
</div>
</div>
<summary><section id="impl-From%3C%26%5BT%5D%3E-for-Arc%3C%5BT%5D%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3620">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;&amp;[T]&gt; for Arc&lt;[T]&gt;where
    T: Clone,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3632">Source</a><pre class="code-header" data-language="rust">fn from(v: &amp;[T]) -&gt; Arc&lt;[T]&gt;</pre></section></summary><div class="docblock">
<p>Allocates a reference-counted slice and fills it by cloning <code>v</code>’s items.</p> <h5 id="example-4">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let original: &amp;[i32] = &amp;[1, 2, 3];
let shared: Arc&lt;[i32]&gt; = Arc::from(original);
assert_eq!(&amp;[1, 2, 3], &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26CStr%3E-for-Arc%3CCStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/ffi/c_str.rs.html#907">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;CStr&gt; for Arc&lt;CStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/ffi/c_str.rs.html#911">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;CStr) -&gt; Arc&lt;CStr&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>&amp;CStr</code> into a <code>Arc&lt;CStr&gt;</code>, by copying the contents into a newly allocated <a href="struct.arc.html" title="struct std::sync::Arc"><code>Arc</code></a>.</p> </div>
</div>
<summary><section id="impl-From%3C%26OsStr%3E-for-Arc%3COsStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1303-1310">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;OsStr&gt; for Arc&lt;OsStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-17" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1306-1309">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;OsStr) -&gt; Arc&lt;OsStr&gt;</pre></section></summary><div class="docblock">
<p>Copies the string into a newly allocated <code><a href="struct.arc.html" title="struct std::sync::Arc">Arc</a>&lt;<a href="../ffi/struct.osstr.html" title="struct std::ffi::OsStr">OsStr</a>&gt;</code>.</p> </div>
</div>
<summary><section id="impl-From%3C%26Path%3E-for-Arc%3CPath%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1996-2003">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;Path&gt; for Arc&lt;Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-20" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1999-2002">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;Path) -&gt; Arc&lt;Path&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="../path/struct.path.html" title="struct std::path::Path"><code>Path</code></a> into an <a href="struct.arc.html" title="struct std::sync::Arc"><code>Arc</code></a> by copying the <a href="../path/struct.path.html" title="struct std::path::Path"><code>Path</code></a> data into a new <a href="struct.arc.html" title="struct std::sync::Arc"><code>Arc</code></a> buffer.</p> </div>
</div>
<summary><section id="impl-From%3C%26mut+%5BT%5D%3E-for-Arc%3C%5BT%5D%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3639">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;&amp;mut [T]&gt; for Arc&lt;[T]&gt;where
    T: Clone,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3652">Source</a><pre class="code-header" data-language="rust">fn from(v: &amp;mut [T]) -&gt; Arc&lt;[T]&gt;</pre></section></summary><div class="docblock">
<p>Allocates a reference-counted slice and fills it by cloning <code>v</code>’s items.</p> <h5 id="example-5">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut original = [1, 2, 3];
let original: &amp;mut [i32] = &amp;mut original;
let shared: Arc&lt;[i32]&gt; = Arc::from(original);
assert_eq!(&amp;[1, 2, 3], &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26mut+CStr%3E-for-Arc%3CCStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/ffi/c_str.rs.html#919">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;mut CStr&gt; for Arc&lt;CStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/ffi/c_str.rs.html#923">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;mut CStr) -&gt; Arc&lt;CStr&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>&amp;mut CStr</code> into a <code>Arc&lt;CStr&gt;</code>, by copying the contents into a newly allocated <a href="struct.arc.html" title="struct std::sync::Arc"><code>Arc</code></a>.</p> </div>
</div>
<summary><section id="impl-From%3C%26mut+OsStr%3E-for-Arc%3COsStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1313-1319">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;mut OsStr&gt; for Arc&lt;OsStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-18" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1316-1318">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;mut OsStr) -&gt; Arc&lt;OsStr&gt;</pre></section></summary><div class="docblock">
<p>Copies the string into a newly allocated <code><a href="struct.arc.html" title="struct std::sync::Arc">Arc</a>&lt;<a href="../ffi/struct.osstr.html" title="struct std::ffi::OsStr">OsStr</a>&gt;</code>.</p> </div>
</div>
<summary><section id="impl-From%3C%26mut+Path%3E-for-Arc%3CPath%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2006-2012">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;mut Path&gt; for Arc&lt;Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-21" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2009-2011">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;mut Path) -&gt; Arc&lt;Path&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="../path/struct.path.html" title="struct std::path::Path"><code>Path</code></a> into an <a href="struct.arc.html" title="struct std::sync::Arc"><code>Arc</code></a> by copying the <a href="../path/struct.path.html" title="struct std::path::Path"><code>Path</code></a> data into a new <a href="struct.arc.html" title="struct std::sync::Arc"><code>Arc</code></a> buffer.</p> </div>
</div>
<summary><section id="impl-From%3C%26mut+str%3E-for-Arc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3678">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;mut str&gt; for Arc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3691">Source</a><pre class="code-header" data-language="rust">fn from(v: &amp;mut str) -&gt; Arc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Allocates a reference-counted <code>str</code> and copies <code>v</code> into it.</p> <h5 id="example-7">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut original = String::from("eggplant");
let original: &amp;mut str = &amp;mut original;
let shared: Arc&lt;str&gt; = Arc::from(original);
assert_eq!("eggplant", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Arc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3659">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for Arc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3670">Source</a><pre class="code-header" data-language="rust">fn from(v: &amp;str) -&gt; Arc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Allocates a reference-counted <code>str</code> and copies <code>v</code> into it.</p> <h5 id="example-6">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let shared: Arc&lt;str&gt; = Arc::from("eggplant");
assert_eq!("eggplant", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%5BT;+N%5D%3E-for-Arc%3C%5BT%5D%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.74.0">1.74.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3599">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, const N: usize&gt; From&lt;[T; N]&gt; for Arc&lt;[T]&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3613">Source</a><pre class="code-header" data-language="rust">fn from(v: [T; N]) -&gt; Arc&lt;[T]&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="../primitive.array.html" title="primitive array"><code>[T; N]</code></a> into an <code>Arc&lt;[T]&gt;</code>.</p> <p>The conversion moves the array into a newly allocated <code>Arc</code>.</p> <h5 id="example-3">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let original: [i32; 3] = [1, 2, 3];
let shared: Arc&lt;[i32]&gt; = Arc::from(original);
assert_eq!(&amp;[1, 2, 3], &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3CArc%3CW%3E%3E-for-RawWaker" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/task.rs.html#121">Source</a></span><pre class="code-header" data-language="rust">impl&lt;W&gt; From&lt;Arc&lt;W&gt;&gt; for RawWakerwhere
    W: Wake + Send + Sync + 'static,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-15" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/task.rs.html#125">Source</a><pre class="code-header" data-language="rust">fn from(waker: Arc&lt;W&gt;) -&gt; RawWaker</pre></section></summary><div class="docblock">
<p>Use a <code>Wake</code>-able type as a <code>RawWaker</code>.</p> <p>No heap allocations or atomic operations are used for this conversion.</p> </div>
</div>
<summary><section id="impl-From%3CArc%3CW%3E%3E-for-Waker" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/task.rs.html#109">Source</a></span><pre class="code-header" data-language="rust">impl&lt;W&gt; From&lt;Arc&lt;W&gt;&gt; for Wakerwhere
    W: Wake + Send + Sync + 'static,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-14" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/task.rs.html#113">Source</a><pre class="code-header" data-language="rust">fn from(waker: Arc&lt;W&gt;) -&gt; Waker</pre></section></summary><div class="docblock">
<p>Use a <a href="../task/trait.wake.html" title="trait std::task::Wake"><code>Wake</code></a>-able type as a <code>Waker</code>.</p> <p>No heap allocations or atomic operations are used for this conversion.</p> </div>
</div>
<summary><section id="impl-From%3CArc%3Cstr%3E%3E-for-Arc%3C%5Bu8%5D%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.62.0">1.62.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3792">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;Arc&lt;str&gt;&gt; for Arc&lt;[u8]&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-13" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3804">Source</a><pre class="code-header" data-language="rust">fn from(rc: Arc&lt;str&gt;) -&gt; Arc&lt;[u8]&gt;</pre></section></summary><div class="docblock">
<p>Converts an atomically reference-counted string slice into a byte slice.</p> <h5 id="example-12">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let string: Arc&lt;str&gt; = Arc::from("eggplant");
let bytes: Arc&lt;[u8]&gt; = Arc::from(string);
assert_eq!("eggplant".as_bytes(), bytes.as_ref());</pre></div> </div>
</div>
<summary><section id="impl-From%3CBox%3CT,+A%3E%3E-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3717">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; From&lt;Box&lt;T, A&gt;&gt; for Arc&lt;T, A&gt;where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3729">Source</a><pre class="code-header" data-language="rust">fn from(v: Box&lt;T, A&gt;) -&gt; Arc&lt;T, A&gt;</pre></section></summary><div class="docblock">
<p>Move a boxed object to a new, reference-counted allocation.</p> <h5 id="example-9">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let unique: Box&lt;str&gt; = Box::from("eggplant");
let shared: Arc&lt;str&gt; = Arc::from(unique);
assert_eq!("eggplant", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3CCString%3E-for-Arc%3CCStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/ffi/c_str.rs.html#895">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;CString&gt; for Arc&lt;CStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/ffi/c_str.rs.html#899">Source</a><pre class="code-header" data-language="rust">fn from(s: CString) -&gt; Arc&lt;CStr&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="../ffi/struct.cstring.html" title="struct std::ffi::CString"><code>CString</code></a> into an <code><a href="struct.arc.html" title="struct std::sync::Arc">Arc</a>&lt;<a href="../ffi/struct.cstr.html" title="struct std::ffi::CStr">CStr</a>&gt;</code> by moving the <a href="../ffi/struct.cstring.html" title="struct std::ffi::CString"><code>CString</code></a> data into a new <a href="struct.arc.html" title="struct std::sync::Arc"><code>Arc</code></a> buffer.</p> </div>
</div>
<summary><section id="impl-From%3CCow%3C'a,+B%3E%3E-for-Arc%3CB%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3765-3768">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, B&gt; From&lt;Cow&lt;'a, B&gt;&gt; for Arc&lt;B&gt;where
    B: ToOwned + ?Sized,
    Arc&lt;B&gt;: From&lt;&amp;'a B&gt; + From&lt;&lt;B as ToOwned&gt;::Owned&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-12" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3783">Source</a><pre class="code-header" data-language="rust">fn from(cow: Cow&lt;'a, B&gt;) -&gt; Arc&lt;B&gt;</pre></section></summary><div class="docblock">
<p>Creates an atomically reference-counted pointer from a clone-on-write pointer by copying its content.</p> <h5 id="example-11">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let cow: Cow&lt;'_, str&gt; = Cow::Borrowed("eggplant");
let shared: Arc&lt;str&gt; = Arc::from(cow);
assert_eq!("eggplant", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3COsString%3E-for-Arc%3COsStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1292-1300">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;OsString&gt; for Arc&lt;OsStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-16" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1296-1299">Source</a><pre class="code-header" data-language="rust">fn from(s: OsString) -&gt; Arc&lt;OsStr&gt;</pre></section></summary><div class="docblock">
<p>Converts an <a href="../ffi/struct.osstring.html" title="struct std::ffi::OsString"><code>OsString</code></a> into an <code><a href="struct.arc.html" title="struct std::sync::Arc">Arc</a>&lt;<a href="../ffi/struct.osstr.html" title="struct std::ffi::OsStr">OsStr</a>&gt;</code> by moving the <a href="../ffi/struct.osstring.html" title="struct std::ffi::OsString"><code>OsString</code></a> data into a new <a href="struct.arc.html" title="struct std::sync::Arc"><code>Arc</code></a> buffer.</p> </div>
</div>
<summary><section id="impl-From%3CPathBuf%3E-for-Arc%3CPath%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1985-1993">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;PathBuf&gt; for Arc&lt;Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-19" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1989-1992">Source</a><pre class="code-header" data-language="rust">fn from(s: PathBuf) -&gt; Arc&lt;Path&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="../path/struct.pathbuf.html" title="struct std::path::PathBuf"><code>PathBuf</code></a> into an <code><a href="struct.arc.html" title="struct std::sync::Arc">Arc</a>&lt;<a href="../path/struct.path.html" title="struct std::path::Path">Path</a>&gt;</code> by moving the <a href="../path/struct.pathbuf.html" title="struct std::path::PathBuf"><code>PathBuf</code></a> data into a new <a href="struct.arc.html" title="struct std::sync::Arc"><code>Arc</code></a> buffer.</p> </div>
</div>
<summary><section id="impl-From%3CString%3E-for-Arc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3698">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;String&gt; for Arc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3710">Source</a><pre class="code-header" data-language="rust">fn from(v: String) -&gt; Arc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Allocates a reference-counted <code>str</code> and copies <code>v</code> into it.</p> <h5 id="example-8">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let unique: String = "eggplant".to_owned();
let shared: Arc&lt;str&gt; = Arc::from(unique);
assert_eq!("eggplant", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3CT%3E-for-Arc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3577">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;T&gt; for Arc&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3592">Source</a><pre class="code-header" data-language="rust">fn from(t: T) -&gt; Arc&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>T</code> into an <code>Arc&lt;T&gt;</code></p> <p>The conversion moves the value into a newly allocated <code>Arc</code>. It is equivalent to calling <code>Arc::new(t)</code>.</p> <h5 id="example-2">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 5;
let arc = Arc::new(5);

assert_eq!(Arc::from(x), arc);</pre></div> </div>
</div>
<summary><section id="impl-From%3CVec%3CT,+A%3E%3E-for-Arc%3C%5BT%5D,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3736">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; From&lt;Vec&lt;T, A&gt;&gt; for Arc&lt;[T], A&gt;where
    A: Allocator + Clone,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-11" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3748">Source</a><pre class="code-header" data-language="rust">fn from(v: Vec&lt;T, A&gt;) -&gt; Arc&lt;[T], A&gt;</pre></section></summary><div class="docblock">
<p>Allocates a reference-counted slice and moves <code>v</code>’s items into it.</p> <h5 id="example-10">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let unique: Vec&lt;i32&gt; = vec![1, 2, 3];
let shared: Arc&lt;[i32]&gt; = Arc::from(unique);
assert_eq!(&amp;[1, 2, 3], &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-FromIterator%3CT%3E-for-Arc%3C%5BT%5D%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.37.0">1.37.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3826">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; FromIterator&lt;T&gt; for Arc&lt;[T]&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3865">Source</a><pre class="code-header" data-language="rust">fn from_iter&lt;I&gt;(iter: I) -&gt; Arc&lt;[T]&gt;where
    I: IntoIterator&lt;Item = T&gt;,</pre></section></summary><div class="docblock">
<p>Takes each element in the <code>Iterator</code> and collects it into an <code>Arc&lt;[T]&gt;</code>.</p> <h5 id="performance-characteristics">Performance characteristics</h5>
<h6 id="the-general-case">The general case</h6> <p>In the general case, collecting into <code>Arc&lt;[T]&gt;</code> is done by first collecting into a <code>Vec&lt;T&gt;</code>. That is, when writing the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let evens: Arc&lt;[u8]&gt; = (0..10).filter(|&amp;x| x % 2 == 0).collect();</pre></div> <p>this behaves as if we wrote:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let evens: Arc&lt;[u8]&gt; = (0..10).filter(|&amp;x| x % 2 == 0)
    .collect::&lt;Vec&lt;_&gt;&gt;() // The first set of allocations happens here.
    .into(); // A second allocation for `Arc&lt;[T]&gt;` happens here.</pre></div> <p>This will allocate as many times as needed for constructing the <code>Vec&lt;T&gt;</code> and then it will allocate once for turning the <code>Vec&lt;T&gt;</code> into the <code>Arc&lt;[T]&gt;</code>.</p> <h6 id="iterators-of-known-length">Iterators of known length</h6> <p>When your <code>Iterator</code> implements <code>TrustedLen</code> and is of an exact size, a single allocation will be made for the <code>Arc&lt;[T]&gt;</code>. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let evens: Arc&lt;[u8]&gt; = (0..10).collect(); // Just a single allocation happens here.</pre></div> </div>
</div>
<summary><section id="impl-Hash-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3569">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Hash for Arc&lt;T, A&gt;where
    T: Hash + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3570">Source</a><pre class="code-header" data-language="rust">fn hash&lt;H&gt;(&amp;self, state: &amp;mut H)where
    H: Hasher,</pre></section></summary><div class="docblock">Feeds this value into the given <a href="../hash/trait.hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="../hash/trait.hash.html#tymethod.hash">Read more</a>
</div>
<summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="src" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#235-237">Source</a></span><pre class="code-header" data-language="rust">fn hash_slice&lt;H&gt;(data: &amp;[Self], state: &amp;mut H)where
    H: Hasher,
    Self: Sized,</pre></section></summary><div class="docblock">Feeds a slice of this type into the given <a href="../hash/trait.hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="../hash/trait.hash.html#method.hash_slice">Read more</a>
</div>
</div>
<summary><section id="impl-Ord-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3415">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Ord for Arc&lt;T, A&gt;where
    T: Ord + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3430">Source</a><pre class="code-header" data-language="rust">fn cmp(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; Ordering</pre></section></summary><div class="docblock">
<p>Comparison for two <code>Arc</code>s.</p> <p>The two are compared by calling <code>cmp()</code> on their inner values.</p> <h5 id="examples-50">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;
use std::cmp::Ordering;

let five = Arc::new(5);

assert_eq!(Ordering::Less, five.cmp(&amp;Arc::new(6)));</pre></div> </div>
<summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#980-982">Source</a></span><pre class="code-header" data-language="rust">fn max(self, other: Self) -&gt; Selfwhere
    Self: Sized,</pre></section></summary><div class="docblock">Compares and returns the maximum of two values. <a href="../cmp/trait.ord.html#method.max">Read more</a>
</div>
<summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1001-1003">Source</a></span><pre class="code-header" data-language="rust">fn min(self, other: Self) -&gt; Selfwhere
    Self: Sized,</pre></section></summary><div class="docblock">Compares and returns the minimum of two values. <a href="../cmp/trait.ord.html#method.min">Read more</a>
</div>
<summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1027-1029">Source</a></span><pre class="code-header" data-language="rust">fn clamp(self, min: Self, max: Self) -&gt; Selfwhere
    Self: Sized,</pre></section></summary><div class="docblock">Restrict a value to a certain interval. <a href="../cmp/trait.ord.html#method.clamp">Read more</a>
</div>
</div>
<summary><section id="impl-PartialEq-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3281">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; PartialEq for Arc&lt;T, A&gt;where
    T: PartialEq + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3300">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>Equality for two <code>Arc</code>s.</p> <p>Two <code>Arc</code>s are equal if their inner values are equal, even if they are stored in different allocation.</p> <p>If <code>T</code> also implements <code>Eq</code> (implying reflexivity of equality), two <code>Arc</code>s that point to the same allocation are always equal.</p> <h5 id="examples-43">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);

assert!(five == Arc::new(5));</pre></div> </div>
<summary><section id="method.ne" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3321">Source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>Inequality for two <code>Arc</code>s.</p> <p>Two <code>Arc</code>s are not equal if their inner values are not equal.</p> <p>If <code>T</code> also implements <code>Eq</code> (implying reflexivity of equality), two <code>Arc</code>s that point to the same value are always equal.</p> <h5 id="examples-44">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);

assert!(five != Arc::new(6));</pre></div> </div>
</div>
<summary><section id="impl-PartialOrd-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3327">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; PartialOrd for Arc&lt;T, A&gt;where
    T: PartialOrd + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3342">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">
<p>Partial comparison for two <code>Arc</code>s.</p> <p>The two are compared by calling <code>partial_cmp()</code> on their inner values.</p> <h5 id="examples-45">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;
use std::cmp::Ordering;

let five = Arc::new(5);

assert_eq!(Some(Ordering::Less), five.partial_cmp(&amp;Arc::new(6)));</pre></div> </div>
<summary><section id="method.lt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3359">Source</a><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>Less-than comparison for two <code>Arc</code>s.</p> <p>The two are compared by calling <code>&lt;</code> on their inner values.</p> <h5 id="examples-46">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);

assert!(five &lt; Arc::new(6));</pre></div> </div>
<summary><section id="method.le" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3376">Source</a><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>‘Less than or equal to’ comparison for two <code>Arc</code>s.</p> <p>The two are compared by calling <code>&lt;=</code> on their inner values.</p> <h5 id="examples-47">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);

assert!(five &lt;= Arc::new(5));</pre></div> </div>
<summary><section id="method.gt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3393">Source</a><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>Greater-than comparison for two <code>Arc</code>s.</p> <p>The two are compared by calling <code>&gt;</code> on their inner values.</p> <h5 id="examples-48">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);

assert!(five &gt; Arc::new(4));</pre></div> </div>
<summary><section id="method.ge" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3410">Source</a><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>‘Greater than or equal to’ comparison for two <code>Arc</code>s.</p> <p>The two are compared by calling <code>&gt;=</code> on their inner values.</p> <h5 id="examples-49">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;

let five = Arc::new(5);

assert!(five &gt;= Arc::new(5));</pre></div> </div>
</div>
<summary><section id="impl-Pointer-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3452">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Pointer for Arc&lt;T, A&gt;where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3453">Source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="../fmt/trait.pointer.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Read-for-Arc%3CFile%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span><a class="src" href="https://doc.rust-lang.org/src/std/fs.rs.html#1258-1278">Source</a></span><pre class="code-header" data-language="rust">impl Read for Arc&lt;File&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.read" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#1259-1261">Source</a><pre class="code-header" data-language="rust">fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Pull some bytes from this source into the specified buffer, returning how many bytes were read. <a href="../io/trait.read.html#tymethod.read">Read more</a>
</div>
<summary><section id="method.read_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#1262-1264">Source</a><pre class="code-header" data-language="rust">fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Like <code>read</code>, except that it reads into a slice of buffers. <a href="../io/trait.read.html#method.read_vectored">Read more</a>
</div>
<summary><section id="method.read_buf" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#1265-1267">Source</a><pre class="code-header" data-language="rust">fn read_buf(&amp;mut self, cursor: BorrowedCursor&lt;'_&gt;) -&gt; Result&lt;()&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>read_buf</code> <a href="https://github.com/rust-lang/rust/issues/78485">#78485</a>)</span>
</div></span><div class="docblock">Pull some bytes from this source into the specified buffer. <a href="../io/trait.read.html#method.read_buf">Read more</a>
</div>
<summary><section id="method.is_read_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#1269-1271">Source</a><pre class="code-header" data-language="rust">fn is_read_vectored(&amp;self) -&gt; bool</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>can_vector</code> <a href="https://github.com/rust-lang/rust/issues/69941">#69941</a>)</span>
</div></span><div class="docblock">Determines if this <code>Read</code>er has an efficient <code>read_vectored</code> implementation. <a href="../io/trait.read.html#method.is_read_vectored">Read more</a>
</div>
<summary><section id="method.read_to_end" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#1272-1274">Source</a><pre class="code-header" data-language="rust">fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Reads all bytes until EOF in this source, placing them into <code>buf</code>. <a href="../io/trait.read.html#method.read_to_end">Read more</a>
</div>
<summary><section id="method.read_to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#1275-1277">Source</a><pre class="code-header" data-language="rust">fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Reads all bytes until EOF in this source, appending them to <code>buf</code>. <a href="../io/trait.read.html#method.read_to_string">Read more</a>
</div>
<summary><section id="method.read_exact" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#974-976">Source</a></span><pre class="code-header" data-language="rust">fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;()&gt;</pre></section></summary><div class="docblock">Reads the exact number of bytes required to fill <code>buf</code>. <a href="../io/trait.read.html#method.read_exact">Read more</a>
</div>
<summary><section id="method.read_buf_exact" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1010-1012">Source</a><pre class="code-header" data-language="rust">fn read_buf_exact(&amp;mut self, cursor: BorrowedCursor&lt;'_&gt;) -&gt; Result&lt;()&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>read_buf</code> <a href="https://github.com/rust-lang/rust/issues/78485">#78485</a>)</span>
</div></span><div class="docblock">Reads the exact number of bytes required to fill <code>cursor</code>. <a href="../io/trait.read.html#method.read_buf_exact">Read more</a>
</div>
<summary><section id="method.by_ref" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1049-1054">Source</a></span><pre class="code-header" data-language="rust">fn by_ref(&amp;mut self) -&gt; &amp;mut Selfwhere
    Self: Sized,</pre></section></summary><div class="docblock">Creates a “by reference” adaptor for this instance of <code>Read</code>. <a href="../io/trait.read.html#method.by_ref">Read more</a>
</div>
<summary><section id="method.bytes" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1092-1097">Source</a></span><pre class="code-header" data-language="rust">fn bytes(self) -&gt; Bytes&lt;Self&gt; ⓘwhere
    Self: Sized,</pre></section></summary><div class="docblock">Transforms this <code>Read</code> instance to an <a href="../iter/trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> over its bytes. <a href="../io/trait.read.html#method.bytes">Read more</a>
</div>
<summary><section id="method.chain" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1130-1135">Source</a></span><pre class="code-header" data-language="rust">fn chain&lt;R: Read&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt; ⓘwhere
    Self: Sized,</pre></section></summary><div class="docblock">Creates an adapter which will chain this stream with another. <a href="../io/trait.read.html#method.chain">Read more</a>
</div>
<summary><section id="method.take" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1169-1174">Source</a></span><pre class="code-header" data-language="rust">fn take(self, limit: u64) -&gt; Take&lt;Self&gt; ⓘwhere
    Self: Sized,</pre></section></summary><div class="docblock">Creates an adapter which will read at most <code>limit</code> bytes from it. <a href="../io/trait.read.html#method.take">Read more</a>
</div>
</div>
<summary><section id="impl-Seek-for-Arc%3CFile%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span><a class="src" href="https://doc.rust-lang.org/src/std/fs.rs.html#1297-1301">Source</a></span><pre class="code-header" data-language="rust">impl Seek for Arc&lt;File&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.seek" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#1298-1300">Source</a><pre class="code-header" data-language="rust">fn seek(&amp;mut self, pos: SeekFrom) -&gt; Result&lt;u64&gt;</pre></section></summary><div class="docblock">Seek to an offset, in bytes, in a stream. <a href="../io/trait.seek.html#tymethod.seek">Read more</a>
</div>
<summary><section id="method.rewind" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#2010-2013">Source</a></span><pre class="code-header" data-language="rust">fn rewind(&amp;mut self) -&gt; Result&lt;()&gt;</pre></section></summary><div class="docblock">Rewind to the beginning of a stream. <a href="../io/trait.seek.html#method.rewind">Read more</a>
</div>
<summary><section id="method.stream_len" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#2050-2061">Source</a><pre class="code-header" data-language="rust">fn stream_len(&amp;mut self) -&gt; Result&lt;u64&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>seek_stream_len</code> <a href="https://github.com/rust-lang/rust/issues/59359">#59359</a>)</span>
</div></span><div class="docblock">Returns the length of this stream (in bytes). <a href="../io/trait.seek.html#method.stream_len">Read more</a>
</div>
<summary><section id="method.stream_position" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#2087-2089">Source</a></span><pre class="code-header" data-language="rust">fn stream_position(&amp;mut self) -&gt; Result&lt;u64&gt;</pre></section></summary><div class="docblock">Returns the current seek position from the start of the stream. <a href="../io/trait.seek.html#method.stream_position">Read more</a>
</div>
<summary><section id="method.seek_relative" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#2115-2118">Source</a></span><pre class="code-header" data-language="rust">fn seek_relative(&amp;mut self, offset: i64) -&gt; Result&lt;()&gt;</pre></section></summary><div class="docblock">Seeks relative to the current position. <a href="../io/trait.seek.html#method.seek_relative">Read more</a>
</div>
</div>
<summary><section id="impl-TryFrom%3CArc%3C%5BT%5D,+A%3E%3E-for-Arc%3C%5BT;+N%5D,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3811">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A, const N: usize&gt; TryFrom&lt;Arc&lt;[T], A&gt;&gt; for Arc&lt;[T; N], A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3812">Source</a><pre class="code-header" data-language="rust">type Error = Arc&lt;[T], A&gt;</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3814">Source</a><pre class="code-header" data-language="rust">fn try_from(
    boxed_slice: Arc&lt;[T], A&gt;,
) -&gt; Result&lt;Arc&lt;[T; N], A&gt;, &lt;Arc&lt;[T; N], A&gt; as TryFrom&lt;Arc&lt;[T], A&gt;&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
<summary><section id="impl-Write-for-Arc%3CFile%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span><a class="src" href="https://doc.rust-lang.org/src/std/fs.rs.html#1280-1295">Source</a></span><pre class="code-header" data-language="rust">impl Write for Arc&lt;File&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.write" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#1281-1283">Source</a><pre class="code-header" data-language="rust">fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Writes a buffer into this writer, returning how many bytes were written. <a href="../io/trait.write.html#tymethod.write">Read more</a>
</div>
<summary><section id="method.write_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#1284-1286">Source</a><pre class="code-header" data-language="rust">fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Like <a href="../io/trait.write.html#tymethod.write" title="method std::io::Write::write"><code>write</code></a>, except that it writes from a slice of buffers. <a href="../io/trait.write.html#method.write_vectored">Read more</a>
</div>
<summary><section id="method.is_write_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#1288-1290">Source</a><pre class="code-header" data-language="rust">fn is_write_vectored(&amp;self) -&gt; bool</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>can_vector</code> <a href="https://github.com/rust-lang/rust/issues/69941">#69941</a>)</span>
</div></span><div class="docblock">Determines if this <code>Write</code>r has an efficient <a href="../io/trait.write.html#method.write_vectored" title="method std::io::Write::write_vectored"><code>write_vectored</code></a> implementation. <a href="../io/trait.write.html#method.is_write_vectored">Read more</a>
</div>
<summary><section id="method.flush" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#1292-1294">Source</a><pre class="code-header" data-language="rust">fn flush(&amp;mut self) -&gt; Result&lt;()&gt;</pre></section></summary><div class="docblock">Flushes this output stream, ensuring that all intermediately buffered contents reach their destination. <a href="../io/trait.write.html#tymethod.flush">Read more</a>
</div>
<summary><section id="method.write_all" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1751-1763">Source</a></span><pre class="code-header" data-language="rust">fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;</pre></section></summary><div class="docblock">Attempts to write an entire buffer into this writer. <a href="../io/trait.write.html#method.write_all">Read more</a>
</div>
<summary><section id="method.write_all_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1813-1828">Source</a><pre class="code-header" data-language="rust">fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; Result&lt;()&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>write_all_vectored</code> <a href="https://github.com/rust-lang/rust/issues/70436">#70436</a>)</span>
</div></span><div class="docblock">Attempts to write multiple buffers into this writer. <a href="../io/trait.write.html#method.write_all_vectored">Read more</a>
</div>
<summary><section id="method.write_fmt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1866-1902">Source</a></span><pre class="code-header" data-language="rust">fn write_fmt(&amp;mut self, fmt: Arguments&lt;'_&gt;) -&gt; Result&lt;()&gt;</pre></section></summary><div class="docblock">Writes a formatted string into this writer, returning any error encountered. <a href="../io/trait.write.html#method.write_fmt">Read more</a>
</div>
<summary><section id="method.by_ref-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1926-1931">Source</a></span><pre class="code-header" data-language="rust">fn by_ref(&amp;mut self) -&gt; &amp;mut Selfwhere
    Self: Sized,</pre></section></summary><div class="docblock">Creates a “by reference” adapter for this instance of <code>Write</code>. <a href="../io/trait.write.html#method.by_ref">Read more</a>
</div>
</div>
<section id="impl-CoerceUnsized%3CArc%3CU,+A%3E%3E-for-Arc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#257">Source</a><pre class="code-header" data-language="rust">impl&lt;T, U, A&gt; CoerceUnsized&lt;Arc&lt;U, A&gt;&gt; for Arc&lt;T, A&gt;where
    T: Unsize&lt;U&gt; + ?Sized,
    A: Allocator,
    U: ?Sized,</pre></section><section id="impl-DerefPure-for-Arc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2212">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; DerefPure for Arc&lt;T, A&gt;where
    A: Allocator,
    T: ?Sized,</pre></section><section id="impl-DispatchFromDyn%3CArc%3CU%3E%3E-for-Arc%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#260">Source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; DispatchFromDyn&lt;Arc&lt;U&gt;&gt; for Arc&lt;T&gt;where
    T: Unsize&lt;U&gt; + ?Sized,
    U: ?Sized,</pre></section><section id="impl-Eq-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3435">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Eq for Arc&lt;T, A&gt;where
    T: Eq + ?Sized,
    A: Allocator,</pre></section><section id="impl-PinCoerceUnsized-for-Arc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2206">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; PinCoerceUnsized for Arc&lt;T, A&gt;where
    A: Allocator,
    T: ?Sized,</pre></section><section id="impl-Send-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#249">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Send for Arc&lt;T, A&gt;where
    T: Sync + Send + ?Sized,
    A: Allocator + Send,</pre></section><section id="impl-Sync-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#251">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Sync for Arc&lt;T, A&gt;where
    T: Sync + Send + ?Sized,
    A: Allocator + Sync,</pre></section><section id="impl-Unpin-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.33.0">1.33.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3925">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Unpin for Arc&lt;T, A&gt;where
    A: Allocator,
    T: ?Sized,</pre></section><section id="impl-UnwindSafe-for-Arc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#254">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; UnwindSafe for Arc&lt;T, A&gt;where
    T: RefUnwindSafe + ?Sized,
    A: Allocator + UnwindSafe,</pre></section>
</div>
<h3 id="synthetic-implementations" class="section-header">Auto Trait Implementations</h3>
<div id="synthetic-implementations-list">
<section id="impl-Freeze-for-Arc%3CT,+A%3E" class="impl"><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Freeze for Arc&lt;T, A&gt;where
    A: Freeze,
    T: ?Sized,</pre></section><section id="impl-RefUnwindSafe-for-Arc%3CT,+A%3E" class="impl"><pre class="code-header" data-language="rust">impl&lt;T, A&gt; RefUnwindSafe for Arc&lt;T, A&gt;where
    A: RefUnwindSafe,
    T: RefUnwindSafe + ?Sized,</pre></section>
</div>
<h3 id="blanket-implementations" class="section-header">Blanket Implementations</h3>
<div id="blanket-implementations-list">
<summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#138">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Any for Twhere
    T: 'static + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#139">Source</a><pre class="code-header" data-language="rust">fn type_id(&amp;self) -&gt; TypeId</pre></section></summary><div class="docblock">Gets the <code>TypeId</code> of <code>self</code>. <a href="../any/trait.any.html#tymethod.type_id">Read more</a>
</div>
</div>
<summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#209">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Borrow&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#211">Source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="../borrow/trait.borrow.html#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; BorrowMut&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#218">Source</a><pre class="code-header" data-language="rust">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</pre></section></summary><div class="docblock">Mutably borrows from an owned value. <a href="../borrow/trait.borrowmut.html#tymethod.borrow_mut">Read more</a>
</div>
</div>
<summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/clone.rs.html#273">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; CloneToUninit for Twhere
    T: Clone,</pre></section></summary><div class="impl-items">
<summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/clone.rs.html#275">Source</a><pre class="code-header" data-language="rust">unsafe fn clone_to_uninit(&amp;self, dst: *mut u8)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code> <a href="https://github.com/rust-lang/rust/issues/126799">#126799</a>)</span>
</div></span><div class="docblock">Performs copy-assignment from <code>self</code> to <code>dst</code>. <a href="../clone/trait.clonetouninit.html#tymethod.clone_to_uninit">Read more</a>
</div>
</div>
<summary><section id="impl-From%3C!%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#784">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;!&gt; for T</pre></section></summary><div class="impl-items">
<summary><section id="method.from-23" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#785">Source</a><pre class="code-header" data-language="rust">fn from(t: !) -&gt; T</pre></section></summary><div class="docblock">Converts to this type from the input type.</div>
</div>
<summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#767">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;T&gt; for T</pre></section></summary><div class="impl-items">
<summary><section id="method.from-22" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#770">Source</a><pre class="code-header" data-language="rust">fn from(t: T) -&gt; T</pre></section></summary><div class="docblock">
<p>Returns the argument unchanged.</p> </div>
</div>
<summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#750-752">Source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; Into&lt;U&gt; for Twhere
    U: From&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#760">Source</a><pre class="code-header" data-language="rust">fn into(self) -&gt; U</pre></section></summary><div class="docblock">
<p>Calls <code>U::from(self)</code>.</p> <p>That is, this conversion is whatever the implementation of <code><a href="../convert/trait.from.html" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p> </div>
</div>
<summary><section id="impl-Receiver-for-P" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/ops/deref.rs.html#418-420">Source</a><pre class="code-header" data-language="rust">impl&lt;P, T&gt; Receiver for Pwhere
    P: Deref&lt;Target = T&gt; + ?Sized,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Target-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/ops/deref.rs.html#422">Source</a><pre class="code-header" data-language="rust">type Target = T</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>arbitrary_self_types</code> <a href="https://github.com/rust-lang/rust/issues/44874">#44874</a>)</span>
</div></span><div class="docblock">The target type on which the method may be called.</div>
</div>
<summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#82-84">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; ToOwned for Twhere
    T: Clone,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#86">Source</a><pre class="code-header" data-language="rust">type Owned = T</pre></section></summary><div class="docblock">The resulting type after obtaining ownership.</div>
<summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#87">Source</a><pre class="code-header" data-language="rust">fn to_owned(&amp;self) -&gt; T</pre></section></summary><div class="docblock">Creates owned data from borrowed data, usually by cloning. <a href="../borrow/trait.toowned.html#tymethod.to_owned">Read more</a>
</div>
<summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#91">Source</a><pre class="code-header" data-language="rust">fn clone_into(&amp;self, target: &amp;mut T)</pre></section></summary><div class="docblock">Uses borrowed data to replace owned data, usually by cloning. <a href="../borrow/trait.toowned.html#method.clone_into">Read more</a>
</div>
</div>
<summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2677">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; ToString for Twhere
    T: Display + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2679">Source</a><pre class="code-header" data-language="rust">fn to_string(&amp;self) -&gt; String</pre></section></summary><div class="docblock">Converts the given value to a <code>String</code>. <a href="../string/trait.tostring.html#tymethod.to_string">Read more</a>
</div>
</div>
<summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#807-809">Source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryFrom&lt;U&gt; for Twhere
    U: Into&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error-2" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#811">Source</a><pre class="code-header" data-language="rust">type Error = Infallible</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#814">Source</a><pre class="code-header" data-language="rust">fn try_from(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
<summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#792-794">Source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryInto&lt;U&gt; for Twhere
    U: TryFrom&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#796">Source</a><pre class="code-header" data-language="rust">type Error = &lt;U as TryFrom&lt;T&gt;&gt;::Error</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#799">Source</a><pre class="code-header" data-language="rust">fn try_into(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html" class="_attribution-link">https://doc.rust-lang.org/std/sync/struct.Arc.html</a>
  </p>
</div>
