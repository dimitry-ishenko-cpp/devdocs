<h1 class="main-heading">Function std::intrinsics::const_eval_select</h1>
<pre class="rust item-decl" data-language="rust">pub unsafe extern "rust-intrinsic" fn const_eval_select&lt;ARG, F, G, RET&gt;(
    arg: ARG,
    called_in_const: F,
    called_at_rt: G
) -&gt; RET
where
    ARG: Tuple,
    G: FnOnce&lt;ARG, Output = RET&gt;,
    F: FnOnce&lt;ARG, Output = RET&gt;,</pre>
<span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>core_intrinsics</code>)</span>
</div></span><p>Selects which function to call depending on the context.</p> <p>If this function is evaluated at compile-time, then a call to this intrinsic will be replaced with a call to <code>called_in_const</code>. It gets replaced with a call to <code>called_at_rt</code> otherwise.</p> <h2 id="type-requirements">Type Requirements</h2> <p>The two functions must be both function items. They cannot be function pointers or closures. The first function must be a <code>const fn</code>.</p> <p><code>arg</code> will be the tupled arguments that will be passed to either one of the two functions, therefore, both functions must accept the same type of arguments. Both functions must return RET.</p> <h2 id="safety">Safety</h2> <p>The two functions must behave observably equivalent. Safe code in other crates may assume that calling a <code>const fn</code> at compile-time and at run-time produces the same result. A function that produces a different result when evaluated at run-time, or has any other observable side-effects, is <em>unsound</em>.</p> <p>Here is an example of how this could cause a problem:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(const_eval_select)]
#![feature(core_intrinsics)]
use std::hint::unreachable_unchecked;
use std::intrinsics::const_eval_select;

// Crate A
pub const fn inconsistent() -&gt; i32 {
    fn runtime() -&gt; i32 { 1 }
    const fn compiletime() -&gt; i32 { 2 }

    unsafe {
        // and `runtime`.
        const_eval_select((), compiletime, runtime)
    }
}

// Crate B
const X: i32 = inconsistent();
let x = inconsistent();
if x != X { unsafe { unreachable_unchecked(); }}</pre></div> <p>This code causes Undefined Behavior when being run, since the <code>unreachable_unchecked</code> is actually being reached. The bug is in <em>crate A</em>, which violates the principle that a <code>const fn</code> must behave the same at compile-time and at run-time. The unsafe code in crate B is fine.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/intrinsics/fn.const_eval_select.html" class="_attribution-link">https://doc.rust-lang.org/std/intrinsics/fn.const_eval_select.html</a>
  </p>
</div>
