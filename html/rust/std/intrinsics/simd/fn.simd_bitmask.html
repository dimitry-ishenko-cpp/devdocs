<h1 class="main-heading">Function simd_bitmask</h1>
<pre class="rust item-decl" data-language="rust">pub unsafe extern "rust-intrinsic" fn simd_bitmask&lt;T, U&gt;(x: T) -&gt; U</pre>
<span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>core_intrinsics</code>)</span>
</div></span><p>Truncates an integer vector to a bitmask.</p> <p><code>T</code> must be an integer vector.</p> <p><code>U</code> must be either the smallest unsigned integer with at least as many bits as the length of <code>T</code>, or the smallest array of <code>u8</code> with at least as many bits as the length of <code>T</code>.</p> <p>Each element is truncated to a single bit and packed into the result.</p> <p>No matter whether the output is an array or an unsigned integer, it is treated as a single contiguous list of bits. The bitmask is always packed on the least-significant side of the output, and padded with 0s in the most-significant bits. The order of the bits depends on endianness:</p> <ul> <li>On little endian, the least significant bit corresponds to the first vector element.</li> <li>On big endian, the least significant bit corresponds to the last vector element.</li> </ul> <p>For example, <code>[!0, 0, !0, !0]</code> packs to</p> <ul> <li>
<code>0b1101u8</code> or <code>[0b1101]</code> on little endian, and</li> <li>
<code>0b1011u8</code> or <code>[0b1011]</code> on big endian.</li> </ul> <p>To consider a larger example, <code>[!0, 0, 0, 0, 0, 0, 0, 0, !0, !0, 0, 0, 0, 0, !0, 0]</code> packs to</p> <ul> <li>
<code>0b0100001100000001u16</code> or <code>[0b00000001, 0b01000011]</code> on little endian, and</li> <li>
<code>0b1000000011000010u16</code> or <code>[0b10000000, 0b11000010]</code> on big endian.</li> </ul> <p>And finally, a non-power-of-2 example with multiple bytes: <code>[!0, !0, 0, !0, 0, 0, !0, 0, !0, 0]</code> packs to</p> <ul> <li>
<code>0b0101001011u16</code> or <code>[0b01001011, 0b01]</code> on little endian, and</li> <li>
<code>0b1101001010u16</code> or <code>[0b11, 0b01001010]</code> on big endian.</li> </ul> <h2 id="safety">Safety</h2> <p><code>x</code> must contain only <code>0</code> and <code>!0</code>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/intrinsics/simd/fn.simd_bitmask.html" class="_attribution-link">https://doc.rust-lang.org/std/intrinsics/simd/fn.simd_bitmask.html</a>
  </p>
</div>
