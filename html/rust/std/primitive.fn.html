<h1 class="main-heading">Primitive Type fn</h1>
<p>Function pointers, like <code>fn(usize) -&gt; bool</code>.</p> <p><em>See also the traits <a href="ops/trait.fn.html" title="trait std::ops::Fn"><code>Fn</code></a>, <a href="ops/trait.fnmut.html" title="trait std::ops::FnMut"><code>FnMut</code></a>, and <a href="ops/trait.fnonce.html" title="trait std::ops::FnOnce"><code>FnOnce</code></a>.</em></p> <p>Function pointers are pointers that point to <em>code</em>, not data. They can be called just like functions. Like references, function pointers are, among other things, assumed to not be null, so if you want to pass a function pointer over FFI and be able to accommodate null pointers, make your type <a href="option/index.html#options-and-pointers-nullable-pointers" title="mod std::option"><code>Option&lt;fn()&gt;</code></a> with your required signature.</p> <h4 id="safety">Safety</h4> <p>Plain function pointers are obtained by casting either plain functions, or closures that don’t capture an environment:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">fn add_one(x: usize) -&gt; usize {
    x + 1
}

let ptr: fn(usize) -&gt; usize = add_one;
assert_eq!(ptr(5), 6);

let clos: fn(usize) -&gt; usize = |x| x + 5;
assert_eq!(clos(5), 10);</pre></div> <p>In addition to varying based on their signature, function pointers come in two flavors: safe and unsafe. Plain <code>fn()</code> function pointers can only point to safe functions, while <code>unsafe fn()</code> function pointers can point to safe or unsafe functions.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">fn add_one(x: usize) -&gt; usize {
    x + 1
}

unsafe fn add_one_unsafely(x: usize) -&gt; usize {
    x + 1
}

let safe_ptr: fn(usize) -&gt; usize = add_one;

//ERROR: mismatched types: expected normal fn, found unsafe fn
//let bad_ptr: fn(usize) -&gt; usize = add_one_unsafely;

let unsafe_ptr: unsafe fn(usize) -&gt; usize = add_one_unsafely;
let really_safe_ptr: unsafe fn(usize) -&gt; usize = add_one;</pre></div> <h4 id="abi">ABI</h4> <p>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the <code>extern</code> keyword before the type, followed by the ABI in question. The default ABI is “Rust”, i.e., <code>fn()</code> is the exact same type as <code>extern "Rust" fn()</code>. A pointer to a function with C ABI would have type <code>extern "C" fn()</code>.</p> <p><code>extern "ABI" { ... }</code> blocks declare functions with ABI “ABI”. The default here is “C”, i.e., functions declared in an <code>extern {...}</code> block have “C” ABI.</p> <p>For more information and a list of supported ABIs, see <a href="https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions">the nomicon’s section on foreign calling conventions</a>.</p> <h4 id="variadic-functions">Variadic functions</h4> <p>Extern function declarations with the “C” or “cdecl” ABIs can also be <em>variadic</em>, allowing them to be called with a variable number of arguments. Normal Rust functions, even those with an <code>extern "ABI"</code>, cannot be variadic. For more information, see <a href="https://doc.rust-lang.org/nomicon/ffi.html#variadic-functions">the nomicon’s section on variadic functions</a>.</p> <h4 id="creating-function-pointers">Creating function pointers</h4> <p>When <code>bar</code> is the name of a function, then the expression <code>bar</code> is <em>not</em> a function pointer. Rather, it denotes a value of an unnameable type that uniquely identifies the function <code>bar</code>. The value is zero-sized because the type already identifies the function. This has the advantage that “calling” the value (it implements the <code>Fn*</code> traits) does not require dynamic dispatch.</p> <p>This zero-sized type <em>coerces</em> to a regular function pointer. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::mem;

fn bar(x: i32) {}

let not_bar_ptr = bar; // `not_bar_ptr` is zero-sized, uniquely identifying `bar`
assert_eq!(mem::size_of_val(&amp;not_bar_ptr), 0);

let bar_ptr: fn(i32) = not_bar_ptr; // force coercion to function pointer
assert_eq!(mem::size_of_val(&amp;bar_ptr), mem::size_of::&lt;usize&gt;());

let footgun = &amp;bar; // this is a shared reference to the zero-sized type identifying `bar`</pre></div> <p>The last line shows that <code>&amp;bar</code> is not a function pointer either. Rather, it is a reference to the function-specific ZST. <code>&amp;bar</code> is basically never what you want when <code>bar</code> is a function.</p> <h4 id="casting-to-and-from-integers">Casting to and from integers</h4> <p>You can cast function pointers directly to integers:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let fnptr: fn(i32) -&gt; i32 = |x| x+2;
let fnptr_addr = fnptr as usize;</pre></div> <p>However, a direct cast back is not possible. You need to use <code>transmute</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let fnptr = fnptr_addr as *const ();
let fnptr: fn(i32) -&gt; i32 = unsafe { std::mem::transmute(fnptr) };
assert_eq!(fnptr(40), 42);</pre></div> <p>Crucially, we <code>as</code>-cast to a raw pointer before <code>transmute</code>ing to a function pointer. This avoids an integer-to-pointer <code>transmute</code>, which can be problematic. Transmuting between raw pointers and function pointers (i.e., two pointer types) is fine.</p> <p>Note that all of this is not portable to platforms where function pointers and data pointers have different sizes.</p> <h4 id="abi-compatibility">ABI compatibility</h4> <p>Generally, when a function is declared with one signature and called via a function pointer with a different signature, the two signatures must be <em>ABI-compatible</em> or else calling the function via that function pointer is Undefined Behavior. ABI compatibility is a lot stricter than merely having the same memory layout; for example, even if <code>i32</code> and <code>f32</code> have the same size and alignment, they might be passed in different registers and hence not be ABI-compatible.</p> <p>ABI compatibility as a concern only arises in code that alters the type of function pointers, code that imports functions via <code>extern</code> blocks, and in code that combines <code>#[target_feature]</code> with <code>extern fn</code>. Altering the type of function pointers is wildly unsafe (as in, a lot more unsafe than even <a href="mem/fn.transmute_copy.html" title="fn std::mem::transmute_copy"><code>transmute_copy</code></a>), and should only occur in the most exceptional circumstances. Most Rust code just imports functions via <code>use</code>. <code>#[target_feature]</code> is also used rarely. So, most likely you do not have to worry about ABI compatibility.</p> <p>But assuming such circumstances, what are the rules? For this section, we are only considering the ABI of direct Rust-to-Rust calls, not linking in general – once functions are imported via <code>extern</code> blocks, there are more things to consider that we do not go into here.</p> <p>For two signatures to be considered <em>ABI-compatible</em>, they must use a compatible ABI string, must take the same number of arguments, the individual argument types and the return types must be ABI-compatible, and the target feature requirements must be met (see the subsection below for the last point). The ABI string is declared via <code>extern "ABI" fn(...) -&gt; ...</code>; note that <code>fn name(...) -&gt; ...</code> implicitly uses the <code>"Rust"</code> ABI string and <code>extern fn name(...) -&gt; ...</code> implicitly uses the <code>"C"</code> ABI string.</p> <p>The ABI strings are guaranteed to be compatible if they are the same, or if the caller ABI string is <code>$X-unwind</code> and the callee ABI string is <code>$X</code>, where <code>$X</code> is one of the following: “C”, “aapcs”, “fastcall”, “stdcall”, “system”, “sysv64”, “thiscall”, “vectorcall”, “win64”.</p> <p>The following types are guaranteed to be ABI-compatible:</p> <ul> <li>
<code>*const T</code>, <code>*mut T</code>, <code>&amp;T</code>, <code>&amp;mut T</code>, <code>Box&lt;T&gt;</code> (specifically, only <code>Box&lt;T, Global&gt;</code>), and <code>NonNull&lt;T&gt;</code> are all ABI-compatible with each other for all <code>T</code>. They are also ABI-compatible with each other for <em>different</em> <code>T</code> if they have the same metadata type (<code>&lt;T as Pointee&gt;::Metadata</code>).</li> <li>
<code>usize</code> is ABI-compatible with the <code>uN</code> integer type of the same size, and likewise <code>isize</code> is ABI-compatible with the <code>iN</code> integer type of the same size.</li> <li>
<code>char</code> is ABI-compatible with <code>u32</code>.</li> <li>Any two <code>fn</code> (function pointer) types are ABI-compatible with each other if they have the same ABI string or the ABI string only differs in a trailing <code>-unwind</code>, independent of the rest of their signature. (This means you can pass <code>fn()</code> to a function expecting <code>fn(i32)</code>, and the call will be valid ABI-wise. The callee receives the result of transmuting the function pointer from <code>fn()</code> to <code>fn(i32)</code>; that transmutation is itself a well-defined operation, it’s just almost certainly UB to later call that function pointer.)</li> <li>Any two types with size 0 and alignment 1 are ABI-compatible.</li> <li>A <code>repr(transparent)</code> type <code>T</code> is ABI-compatible with its unique non-trivial field, i.e., the unique field that doesn’t have size 0 and alignment 1 (if there is such a field).</li> <li>
<code>i32</code> is ABI-compatible with <code>NonZero&lt;i32&gt;</code>, and similar for all other integer types.</li> <li>If <code>T</code> is guaranteed to be subject to the <a href="option/index.html#representation">null pointer optimization</a>, then <code>T</code> and <code>Option&lt;T&gt;</code> are ABI-compatible.</li> </ul> <p>Furthermore, ABI compatibility satisfies the following general properties:</p> <ul> <li>Every type is ABI-compatible with itself.</li> <li>If <code>T1</code> and <code>T2</code> are ABI-compatible and <code>T2</code> and <code>T3</code> are ABI-compatible, then so are <code>T1</code> and <code>T3</code> (i.e., ABI-compatibility is transitive).</li> <li>If <code>T1</code> and <code>T2</code> are ABI-compatible, then so are <code>T2</code> and <code>T1</code> (i.e., ABI-compatibility is symmetric).</li> </ul> <p>More signatures can be ABI-compatible on specific targets, but that should not be relied upon since it is not portable and not a stable guarantee.</p> <p>Noteworthy cases of types <em>not</em> being ABI-compatible in general are:</p> <ul> <li>
<code>bool</code> vs <code>u8</code>, <code>i32</code> vs <code>u32</code>, <code>char</code> vs <code>i32</code>: on some targets, the calling conventions for these types differ in terms of what they guarantee for the remaining bits in the register that are not used by the value.</li> <li>
<code>i32</code> vs <code>f32</code> are not compatible either, as has already been mentioned above.</li> <li>
<code>struct Foo(u32)</code> and <code>u32</code> are not compatible (without <code>repr(transparent)</code>) since structs are aggregate types and often passed in a different way than primitives like <code>i32</code>.</li> </ul> <p>Note that these rules describe when two completely known types are ABI-compatible. When considering ABI compatibility of a type declared in another crate (including the standard library), consider that any type that has a private field or the <code>#[non_exhaustive]</code> attribute may change its layout as a non-breaking update unless documented otherwise – so for instance, even if such a type is a 1-ZST or <code>repr(transparent)</code> right now, this might change with any library version bump.</p> <p>If the declared signature and the signature of the function pointer are ABI-compatible, then the function call behaves as if every argument was <a href="mem/fn.transmute.html" title="fn std::mem::transmute"><code>transmute</code>d</a> from the type in the function pointer to the type at the function declaration, and the return value is <a href="mem/fn.transmute.html" title="fn std::mem::transmute"><code>transmute</code>d</a> from the type in the declaration to the type in the pointer. All the usual caveats and concerns around transmutation apply; for instance, if the function expects a <code>NonZero&lt;i32&gt;</code> and the function pointer uses the ABI-compatible type <code>Option&lt;NonZero&lt;i32&gt;&gt;</code>, and the value used for the argument is <code>None</code>, then this call is Undefined Behavior since transmuting <code>None::&lt;NonZero&lt;i32&gt;&gt;</code> to <code>NonZero&lt;i32&gt;</code> violates the non-zero requirement.</p> <h5 id="requirements-concerning-target-features">Requirements concerning target features</h5> <p>Under some conditions, the signature used by the caller and the callee can be ABI-incompatible even if the exact same ABI string and types are being used. As an example, the <code>std::arch::x86_64::__m256</code> type has a different <code>extern "C"</code> ABI when the <code>avx</code> feature is enabled vs when it is not enabled.</p> <p>Therefore, to ensure ABI compatibility when code using different target features is combined (such as via <code>#[target_feature]</code>), we further require that one of the following conditions is met:</p> <ul> <li>The function uses the <code>"Rust"</code> ABI string (which is the default without <code>extern</code>).</li> <li>Caller and callee are using the exact same set of target features. For the callee we consider the features enabled (via <code>#[target_feature]</code> and <code>-C target-feature</code>/<code>-C target-cpu</code>) at the declaration site; for the caller we consider the features enabled at the call site.</li> <li>Neither any argument nor the return value involves a SIMD type (<code>#[repr(simd)]</code>) that is not behind a pointer indirection (i.e., <code>*mut __m256</code> is fine, but <code>(i32, __m256)</code> is not).</li> </ul> <h4 id="trait-implementations-1">Trait implementations</h4> <p>In this documentation the shorthand <code>fn(T₁, T₂, …, Tₙ)</code> is used to represent non-variadic function pointers of varying length. Note that this is a convenience notation to avoid repetitive documentation, not valid Rust syntax.</p> <p>The following traits are implemented for function pointers with any number of arguments and any ABI.</p> <ul> <li><a href="cmp/trait.partialeq.html" title="trait std::cmp::PartialEq"><code>PartialEq</code></a></li> <li><a href="cmp/trait.eq.html" title="trait std::cmp::Eq"><code>Eq</code></a></li> <li><a href="cmp/trait.partialord.html" title="trait std::cmp::PartialOrd"><code>PartialOrd</code></a></li> <li><a href="cmp/trait.ord.html" title="trait std::cmp::Ord"><code>Ord</code></a></li> <li><a href="hash/trait.hash.html" title="trait std::hash::Hash"><code>Hash</code></a></li> <li><a href="fmt/trait.pointer.html" title="trait std::fmt::Pointer"><code>Pointer</code></a></li> <li><a href="fmt/derive.debug.html" title="derive std::fmt::Debug"><code>Debug</code></a></li> <li><a href="clone/trait.clone.html" title="trait std::clone::Clone"><code>Clone</code></a></li> <li><a href="marker/trait.copy.html" title="trait std::marker::Copy"><code>Copy</code></a></li> <li><a href="marker/trait.send.html" title="trait std::marker::Send"><code>Send</code></a></li> <li><a href="marker/trait.sync.html" title="trait std::marker::Sync"><code>Sync</code></a></li> <li><a href="marker/trait.unpin.html" title="trait std::marker::Unpin"><code>Unpin</code></a></li> <li><a href="panic/trait.unwindsafe.html" title="trait std::panic::UnwindSafe"><code>UnwindSafe</code></a></li> <li><a href="panic/trait.refunwindsafe.html" title="trait std::panic::RefUnwindSafe"><code>RefUnwindSafe</code></a></li> </ul> <p>Note that while this type implements <code>PartialEq</code>, comparing function pointers is unreliable: pointers to the same function can compare inequal (because functions are duplicated in multiple codegen units), and pointers to <em>different</em> functions can compare equal (since identical functions can be deduplicated within a codegen unit).</p> <p>In addition, all <em>safe</em> function pointers implement <a href="ops/trait.fn.html" title="trait std::ops::Fn"><code>Fn</code></a>, <a href="ops/trait.fnmut.html" title="trait std::ops::FnMut"><code>FnMut</code></a>, and <a href="ops/trait.fnonce.html" title="trait std::ops::FnOnce"><code>FnOnce</code></a>, because these traits are specially known to the compiler.</p> <h3 id="synthetic-implementations" class="section-header">Auto Trait Implementations</h3>
<div id="synthetic-implementations-list">
<section id="impl-Freeze-for-fn(T)+-%3E+Ret" class="impl"><pre class="code-header" data-language="rust">impl&lt;Ret, T&gt; Freeze for fn(T₁, T₂, …, Tₙ) -&gt; Ret</pre></section><section id="impl-RefUnwindSafe-for-fn(T)+-%3E+Ret" class="impl"><pre class="code-header" data-language="rust">impl&lt;Ret, T&gt; RefUnwindSafe for fn(T₁, T₂, …, Tₙ) -&gt; Ret</pre></section><section id="impl-Send-for-fn(T)+-%3E+Ret" class="impl"><pre class="code-header" data-language="rust">impl&lt;Ret, T&gt; Send for fn(T₁, T₂, …, Tₙ) -&gt; Ret</pre></section><section id="impl-Sync-for-fn(T)+-%3E+Ret" class="impl"><pre class="code-header" data-language="rust">impl&lt;Ret, T&gt; Sync for fn(T₁, T₂, …, Tₙ) -&gt; Ret</pre></section><section id="impl-Unpin-for-fn(T)+-%3E+Ret" class="impl"><pre class="code-header" data-language="rust">impl&lt;Ret, T&gt; Unpin for fn(T₁, T₂, …, Tₙ) -&gt; Ret</pre></section><section id="impl-UnwindSafe-for-fn(T)+-%3E+Ret" class="impl"><pre class="code-header" data-language="rust">impl&lt;Ret, T&gt; UnwindSafe for fn(T₁, T₂, …, Tₙ) -&gt; Ret</pre></section>
</div>
<h3 id="blanket-implementations" class="section-header">Blanket Implementations</h3>
<div id="blanket-implementations-list">
<summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Any for Twhere
    T: 'static + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141">source</a><pre class="code-header" data-language="rust">fn type_id(&amp;self) -&gt; TypeId</pre></section></summary><div class="docblock">Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.any.html#tymethod.type_id">Read more</a>
</div>
</div>
<summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Borrow&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210">source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="borrow/trait.borrow.html#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; BorrowMut&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217">source</a><pre class="code-header" data-language="rust">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</pre></section></summary><div class="docblock">Mutably borrows from an owned value. <a href="borrow/trait.borrowmut.html#tymethod.borrow_mut">Read more</a>
</div>
</div>
<summary><section id="impl-Debug-for-F" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2131">source</a><pre class="code-header" data-language="rust">impl&lt;F&gt; Debug for Fwhere
    F: FnPtr,</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2132">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="fmt/trait.debug.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;T&gt; for T</pre></section></summary><div class="impl-items">
<summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768">source</a><pre class="code-header" data-language="rust">fn from(t: T) -&gt; T</pre></section></summary><div class="docblock">
<p>Returns the argument unchanged.</p> </div>
</div>
<summary><section id="impl-Hash-for-F" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2117">source</a><pre class="code-header" data-language="rust">impl&lt;F&gt; Hash for Fwhere
    F: FnPtr,</pre></section></summary><div class="impl-items">
<summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2118">source</a><pre class="code-header" data-language="rust">fn hash&lt;HH&gt;(&amp;self, state: &amp;mut HH)where
    HH: Hasher,</pre></section></summary><div class="docblock">Feeds this value into the given <a href="hash/trait.hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.hash.html#tymethod.hash">Read more</a>
</div>
<summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/hash/mod.rs.html#238-240">source</a></span><pre class="code-header" data-language="rust">fn hash_slice&lt;H&gt;(data: &amp;[Self], state: &amp;mut H)where
    H: Hasher,
    Self: Sized,</pre></section></summary><div class="docblock">Feeds a slice of this type into the given <a href="hash/trait.hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.hash.html#method.hash_slice">Read more</a>
</div>
</div>
<summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; Into&lt;U&gt; for Twhere
    U: From&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758">source</a><pre class="code-header" data-language="rust">fn into(self) -&gt; U</pre></section></summary><div class="docblock">
<p>Calls <code>U::from(self)</code>.</p> <p>That is, this conversion is whatever the implementation of <code><a href="convert/trait.from.html" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p> </div>
</div>
<summary><section id="impl-Ord-for-F" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2109">source</a><pre class="code-header" data-language="rust">impl&lt;F&gt; Ord for Fwhere
    F: FnPtr,</pre></section></summary><div class="impl-items">
<summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2111">source</a><pre class="code-header" data-language="rust">fn cmp(&amp;self, other: &amp;F) -&gt; Ordering</pre></section></summary><div class="docblock">This method returns an <a href="cmp/enum.ordering.html" title="enum std::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.ord.html#tymethod.cmp">Read more</a>
</div>
<summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#856-858">source</a></span><pre class="code-header" data-language="rust">fn max(self, other: Self) -&gt; Selfwhere
    Self: Sized,</pre></section></summary><div class="docblock">Compares and returns the maximum of two values. <a href="cmp/trait.ord.html#method.max">Read more</a>
</div>
<summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#877-879">source</a></span><pre class="code-header" data-language="rust">fn min(self, other: Self) -&gt; Selfwhere
    Self: Sized,</pre></section></summary><div class="docblock">Compares and returns the minimum of two values. <a href="cmp/trait.ord.html#method.min">Read more</a>
</div>
<summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#903-906">source</a></span><pre class="code-header" data-language="rust">fn clamp(self, min: Self, max: Self) -&gt; Selfwhere
    Self: Sized + PartialOrd,</pre></section></summary><div class="docblock">Restrict a value to a certain interval. <a href="cmp/trait.ord.html#method.clamp">Read more</a>
</div>
</div>
<summary><section id="impl-PartialEq-for-F" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2092">source</a><pre class="code-header" data-language="rust">impl&lt;F&gt; PartialEq for Fwhere
    F: FnPtr,</pre></section></summary><div class="impl-items">
<summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2094">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;F) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#263">source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialOrd-for-F" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2102">source</a><pre class="code-header" data-language="rust">impl&lt;F&gt; PartialOrd for Fwhere
    F: FnPtr,</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2104">source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;F) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord.html#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1180">source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord.html#method.lt">Read more</a>
</div>
<summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1198">source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord.html#method.le">Read more</a>
</div>
<summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1215">source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord.html#method.gt">Read more</a>
</div>
<summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1233">source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord.html#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-Pattern%3C'a%3E-for-F" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#922-924">source</a><pre class="code-header" data-language="rust">impl&lt;'a, F&gt; Pattern&lt;'a&gt; for Fwhere
    F: FnMut(char) -&gt; bool,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Searcher" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Searcher = CharPredicateSearcher&lt;'a, F&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Associated searcher for this pattern</div>
<summary><section id="method.into_searcher" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926">source</a><pre class="code-header" data-language="rust">fn into_searcher(self, haystack: &amp;'a str) -&gt; CharPredicateSearcher&lt;'a, F&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Constructs the associated searcher from <code>self</code> and the <code>haystack</code> to search in.</div>
<summary><section id="method.is_contained_in" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926">source</a><pre class="code-header" data-language="rust">fn is_contained_in(self, haystack: &amp;'a str) -&gt; bool</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Checks whether the pattern matches anywhere in the haystack</div>
<summary><section id="method.is_prefix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926">source</a><pre class="code-header" data-language="rust">fn is_prefix_of(self, haystack: &amp;'a str) -&gt; bool</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Checks whether the pattern matches at the front of the haystack</div>
<summary><section id="method.strip_prefix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926">source</a><pre class="code-header" data-language="rust">fn strip_prefix_of(self, haystack: &amp;'a str) -&gt; Option&lt;&amp;'a str&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Removes the pattern from the front of haystack, if it matches.</div>
<summary><section id="method.is_suffix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926">source</a><pre class="code-header" data-language="rust">fn is_suffix_of(self, haystack: &amp;'a str) -&gt; boolwhere
    CharPredicateSearcher&lt;'a, F&gt;: ReverseSearcher&lt;'a&gt;,</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Checks whether the pattern matches at the back of the haystack</div>
<summary><section id="method.strip_suffix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/str/pattern.rs.html#926">source</a><pre class="code-header" data-language="rust">fn strip_suffix_of(self, haystack: &amp;'a str) -&gt; Option&lt;&amp;'a str&gt;where
    CharPredicateSearcher&lt;'a, F&gt;: ReverseSearcher&lt;'a&gt;,</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Removes the pattern from the back of haystack, if it matches.</div>
</div>
<summary><section id="impl-Pointer-for-F" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2124">source</a><pre class="code-header" data-language="rust">impl&lt;F&gt; Pointer for Fwhere
    F: FnPtr,</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2125">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="fmt/trait.pointer.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; ToOwned for Twhere
    T: Clone,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Owned = T</pre></section></summary><div class="docblock">The resulting type after obtaining ownership.</div>
<summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88">source</a><pre class="code-header" data-language="rust">fn to_owned(&amp;self) -&gt; T</pre></section></summary><div class="docblock">Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.toowned.html#tymethod.to_owned">Read more</a>
</div>
<summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92">source</a><pre class="code-header" data-language="rust">fn clone_into(&amp;self, target: &amp;mut T)</pre></section></summary><div class="docblock">Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.toowned.html#method.clone_into">Read more</a>
</div>
</div>
<summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryFrom&lt;U&gt; for Twhere
    U: Into&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Error = Infallible</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812">source</a><pre class="code-header" data-language="rust">fn try_from(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
<summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryInto&lt;U&gt; for Twhere
    U: TryFrom&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Error = &lt;U as TryFrom&lt;T&gt;&gt;::Error</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797">source</a><pre class="code-header" data-language="rust">fn try_into(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
<section id="impl-Eq-for-F" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ptr/mod.rs.html#2099">source</a><pre class="code-header" data-language="rust">impl&lt;F&gt; Eq for Fwhere
    F: FnPtr,</pre></section>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/primitive.fn.html" class="_attribution-link">https://doc.rust-lang.org/std/primitive.fn.html</a>
  </p>
</div>
