<h1 class="main-heading">Macro std::panic</h1>
<pre class="rust item-decl" data-language="rust">macro_rules! panic {
    ($($arg:tt)*) =&gt; { ... };
}</pre>
<p>Panics the current thread.</p> <p>This allows a program to terminate immediately and provide feedback to the caller of the program.</p> <p>This macro is the perfect way to assert conditions in example code and in tests. <code>panic!</code> is closely tied with the <code>unwrap</code> method of both <a href="option/enum.option.html#method.unwrap" title="method std::option::Option::unwrap"><code>Option</code></a> and <a href="result/enum.result.html#method.unwrap" title="method std::result::Result::unwrap"><code>Result</code></a> enums. Both implementations call <code>panic!</code> when they are set to <a href="option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> or <a href="result/enum.result.html#variant.Err" title="variant std::result::Result::Err"><code>Err</code></a> variants.</p> <p>When using <code>panic!()</code> you can specify a string payload that is built using [formatting syntax]. That payload is used when injecting the panic into the calling Rust thread, causing the thread to panic entirely.</p> <p>The behavior of the default <code>std</code> hook, i.e. the code that runs directly after the panic is invoked, is to print the message payload to <code>stderr</code> along with the file/line/column information of the <code>panic!()</code> call. You can override the panic hook using <a href="panic/fn.set_hook.html"><code>std::panic::set_hook()</code></a>. Inside the hook a panic can be accessed as a <code>&amp;dyn Any + Send</code>, which contains either a <code>&amp;str</code> or <code>String</code> for regular <code>panic!()</code> invocations. (Whether a particular invocation contains the payload at type <code>&amp;str</code> or <code>String</code> is unspecified and can change.) To panic with a value of another other type, <a href="panic/fn.panic_any.html"><code>panic_any</code></a> can be used.</p> <p>See also the macro <a href="macro.compile_error.html" title="macro std::compile_error"><code>compile_error!</code></a>, for raising errors during compilation.</p> <h2 id="when-to-use-panic-vs-result">When to use <code>panic!</code> vs <code>Result</code>
</h2> <p>The Rust language provides two complementary systems for constructing / representing, reporting, propagating, reacting to, and discarding errors. These responsibilities are collectively known as “error handling.” <code>panic!</code> and <code>Result</code> are similar in that they are each the primary interface of their respective error handling systems; however, the meaning these interfaces attach to their errors and the responsibilities they fulfill within their respective error handling systems differ.</p> <p>The <code>panic!</code> macro is used to construct errors that represent a bug that has been detected in your program. With <code>panic!</code> you provide a message that describes the bug and the language then constructs an error with that message, reports it, and propagates it for you.</p> <p><code>Result</code> on the other hand is used to wrap other types that represent either the successful result of some computation, <code>Ok(T)</code>, or error types that represent an anticipated runtime failure mode of that computation, <code>Err(E)</code>. <code>Result</code> is used alongside user defined types which represent the various anticipated runtime failure modes that the associated computation could encounter. <code>Result</code> must be propagated manually, often with the help of the <code>?</code> operator and <code>Try</code> trait, and they must be reported manually, often with the help of the <code>Error</code> trait.</p> <p>For more detailed information about error handling check out the <a href="../book/ch09-00-error-handling.html">book</a> or the <a href="result/index.html"><code>std::result</code></a> module docs.</p> <h2 id="current-implementation">Current implementation</h2> <p>If the main thread panics it will terminate all your threads and end your program with code <code>101</code>.</p> <h2 id="editions">Editions</h2> <p>Behavior of the panic macros changed over editions.</p> <h3 id="2021-and-later">2021 and later</h3> <p>In Rust 2021 and later, <code>panic!</code> always requires a format string and the applicable format arguments, and is the same in <code>core</code> and <code>std</code>. Use <a href="panic/fn.panic_any.html"><code>std::panic::panic_any(x)</code></a> to panic with an arbitrary payload.</p> <h3 id="2018-and-2015">2018 and 2015</h3> <p>In Rust Editions prior to 2021, <code>std::panic!(x)</code> with a single argument directly uses that argument as a payload. This is true even if the argument is a string literal. For example, <code>panic!("problem: {reason}")</code> panics with a payload of literally <code>"problem: {reason}"</code> (a <code>&amp;'static str</code>).</p> <p><code>core::panic!(x)</code> with a single argument requires that <code>x</code> be <code>&amp;str</code>, but otherwise behaves like <code>std::panic!</code>. In particular, the string need not be a literal, and is not interpreted as a format string.</p> <h2 id="examples">Examples</h2> <div class="example-wrap should_panic">ⓘ<pre class="rust rust-example-rendered" data-language="rust">panic!();
panic!("this is a terrible mistake!");
panic!("this is a {} {message}", "fancy", message = "message");
std::panic::panic_any(4); // panic with the value of 4 to be collected elsewhere</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/macro.panic.html" class="_attribution-link">https://doc.rust-lang.org/std/macro.panic.html</a>
  </p>
</div>
