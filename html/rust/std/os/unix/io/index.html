<h1 class="main-heading">Module std::os::unix::io</h1>
<span class="item-info"><div class="stab portability">Available on <strong>Unix</strong> only.</div></span><p>Unix-specific extensions to general I/O primitives.</p> <p>Just like raw pointers, raw file descriptors point to resources with dynamic lifetimes, and they can dangle if they outlive their resources or be forged if they’re created from invalid values.</p> <p>This module provides three types for representing file descriptors, with different ownership properties: raw, borrowed, and owned, which are analogous to types used for representing pointers. These types reflect concepts of <a href="../../../io/index.html#io-safety" title="mod std::io">I/O safety</a> on Unix.</p> <div>
<table>
<thead><tr>
<th>Type</th>
<th>Analogous to</th>
</tr></thead>
<tbody> <tr>
<td><a href="../../fd/type.rawfd.html" title="type std::os::fd::RawFd"><code>RawFd</code></a></td>
<td><code>*const _</code></td>
</tr> <tr>
<td><a href="../../fd/struct.borrowedfd.html" title="struct std::os::fd::BorrowedFd"><code>BorrowedFd&lt;'a&gt;</code></a></td>
<td><code>&amp;'a _</code></td>
</tr> <tr>
<td><a href="../../fd/struct.ownedfd.html" title="struct std::os::fd::OwnedFd"><code>OwnedFd</code></a></td>
<td><code>Box&lt;_&gt;</code></td>
</tr> </tbody>
</table> </div> <p>Like raw pointers, <code>RawFd</code> values are primitive values. And in new code, they should be considered unsafe to do I/O on (analogous to dereferencing them). Rust did not always provide this guidance, so existing code in the Rust ecosystem often doesn’t mark <code>RawFd</code> usage as unsafe. Libraries are encouraged to migrate, either by adding <code>unsafe</code> to APIs that dereference <code>RawFd</code> values, or by using to <code>BorrowedFd</code> or <code>OwnedFd</code> instead.</p> <p>Like references, <code>BorrowedFd</code> values are tied to a lifetime, to ensure that they don’t outlive the resource they point to. These are safe to use. <code>BorrowedFd</code> values may be used in APIs which provide safe access to any system call except for:</p> <ul> <li> <p><code>close</code>, because that would end the dynamic lifetime of the resource without ending the lifetime of the file descriptor.</p> </li> <li> <p><code>dup2</code>/<code>dup3</code>, in the second argument, because this argument is closed and assigned a new resource, which may break the assumptions other code using that file descriptor.</p> </li> </ul> <p><code>BorrowedFd</code> values may be used in APIs which provide safe access to <code>dup</code> system calls, so types implementing <code>AsFd</code> or <code>From&lt;OwnedFd&gt;</code> should not assume they always have exclusive access to the underlying file description.</p> <p><code>BorrowedFd</code> values may also be used with <code>mmap</code>, since <code>mmap</code> uses the provided file descriptor in a manner similar to <code>dup</code> and does not require the <code>BorrowedFd</code> passed to it to live for the lifetime of the resulting mapping. That said, <code>mmap</code> is unsafe for other reasons: it operates on raw pointers, and it can have undefined behavior if the underlying storage is mutated. Mutations may come from other processes, or from the same process if the API provides <code>BorrowedFd</code> access, since as mentioned earlier, <code>BorrowedFd</code> values may be used in APIs which provide safe access to any system call. Consequently, code using <code>mmap</code> and presenting a safe API must take full responsibility for ensuring that safe Rust code cannot evoke undefined behavior through it.</p> <p>Like boxes, <code>OwnedFd</code> values conceptually own the resource they point to, and free (close) it when they are dropped.</p> <p>See the <a href="../../../io/index.html#io-safety" title="mod std::io"><code>io</code> module docs</a> for a general explanation of I/O safety.</p> <h3 id="procselfmem-and-similar-os-features">
<code>/proc/self/mem</code> and similar OS features</h3> <p>Some platforms have special files, such as <code>/proc/self/mem</code>, which provide read and write access to the process’s memory. Such reads and writes happen outside the control of the Rust compiler, so they do not uphold Rust’s memory safety guarantees.</p> <p>This does not mean that all APIs that might allow <code>/proc/self/mem</code> to be opened and read from or written must be <code>unsafe</code>. Rust’s safety guarantees only cover what the program itself can do, and not what entities outside the program can do to it. <code>/proc/self/mem</code> is considered to be such an external entity, along with <code>/proc/self/fd/*</code>, debugging interfaces, and people with physical access to the hardware. This is true even in cases where the program is controlling the external entity.</p> <p>If you desire to comprehensively prevent programs from reaching out and causing external entities to reach back in and violate memory safety, it’s necessary to use <em>sandboxing</em>, which is outside the scope of <code>std</code>.</p> <h2 id="reexports" class="small-section-header">Re-exports</h2>
<ul class="item-table"><li><div class="item-name"><code>pub use crate::os::<a class="mod" href="../../fd/index.html" title="mod std::os::fd">fd</a>::*;</code></div></li></ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/os/unix/io/index.html" class="_attribution-link">https://doc.rust-lang.org/std/os/unix/io/index.html</a>
  </p>
</div>
