<h1 class="main-heading">Module std::os::windows::ffi</h1>
<span class="item-info"><div class="stab portability">Available on <strong>Windows</strong> only.</div></span><p>Windows-specific extensions to primitives in the <a href="../../../ffi/index.html" title="mod std::ffi"><code>std::ffi</code></a> module.</p> <h2 id="overview">Overview</h2> <p>For historical reasons, the Windows API uses a form of potentially ill-formed UTF-16 encoding for strings. Specifically, the 16-bit code units in Windows strings may contain <a href="https://simonsapin.github.io/wtf-8/#ill-formed-utf-16">isolated surrogate code points which are not paired together</a>. The Unicode standard requires that surrogate code points (those in the range U+D800 to U+DFFF) always be <em>paired</em>, because in the UTF-16 encoding a <em>surrogate code unit pair</em> is used to encode a single character. For compatibility with code that does not enforce these pairings, Windows does not enforce them, either.</p> <p>While it is not always possible to convert such a string losslessly into a valid UTF-16 string (or even UTF-8), it is often desirable to be able to round-trip such a string from and to Windows APIs losslessly. For example, some Rust code may be “bridging” some Windows APIs together, just passing <code>WCHAR</code> strings among those APIs without ever really looking into the strings.</p> <p>If Rust code <em>does</em> need to look into those strings, it can convert them to valid UTF-8, possibly lossily, by substituting invalid sequences with <a href="../../../char/constant.replacement_character.html" title="constant std::char::REPLACEMENT_CHARACTER"><code>U+FFFD REPLACEMENT CHARACTER</code></a>, as is conventionally done in other Rust APIs that deal with string encodings.</p> <h2 id="osstringext-and-osstrext">
<code>OsStringExt</code> and <code>OsStrExt</code>
</h2> <p><a href="../../../ffi/struct.osstring.html" title="struct std::ffi::OsString"><code>OsString</code></a> is the Rust wrapper for owned strings in the preferred representation of the operating system. On Windows, this struct gets augmented with an implementation of the <a href="trait.osstringext.html" title="trait std::os::windows::ffi::OsStringExt"><code>OsStringExt</code></a> trait, which has an <a href="trait.osstringext.html#tymethod.from_wide" title="associated function std::os::windows::ffi::OsStringExt::from_wide"><code>OsStringExt::from_wide</code></a> method. This lets you create an <a href="../../../ffi/struct.osstring.html" title="struct std::ffi::OsString"><code>OsString</code></a> from a <code>&amp;[u16]</code> slice; presumably you get such a slice out of a <code>WCHAR</code> Windows API.</p> <p>Similarly, <a href="../../../ffi/struct.osstr.html" title="struct std::ffi::OsStr"><code>OsStr</code></a> is the Rust wrapper for borrowed strings from preferred representation of the operating system. On Windows, the <a href="trait.osstrext.html" title="trait std::os::windows::ffi::OsStrExt"><code>OsStrExt</code></a> trait provides the <a href="trait.osstrext.html#tymethod.encode_wide" title="method std::os::windows::ffi::OsStrExt::encode_wide"><code>OsStrExt::encode_wide</code></a> method, which outputs an <a href="struct.encodewide.html" title="struct std::os::windows::ffi::EncodeWide"><code>EncodeWide</code></a> iterator. You can <a href="../../../iter/trait.iterator.html#method.collect" title="method std::iter::Iterator::collect"><code>collect</code></a> this iterator, for example, to obtain a <code>Vec&lt;u16&gt;</code>; you can later get a pointer to this vector’s contents and feed it to Windows APIs.</p> <p>These traits, along with <a href="../../../ffi/struct.osstring.html" title="struct std::ffi::OsString"><code>OsString</code></a> and <a href="../../../ffi/struct.osstr.html" title="struct std::ffi::OsStr"><code>OsStr</code></a>, work in conjunction so that it is possible to <strong>round-trip</strong> strings from Windows and back, with no loss of data, even if the strings are ill-formed UTF-16.</p> <h3 id="structs" class="section-header">Structs</h3>
<ul class="item-table"><li>
<div class="item-name"><a class="struct" href="struct.encodewide.html" title="struct std::os::windows::ffi::EncodeWide">EncodeWide</a></div>
<div class="desc docblock-short">Generates a wide character sequence for potentially ill-formed UTF-16.</div>
</li></ul>
<h3 id="traits" class="section-header">Traits</h3>
<ul class="item-table">
<li>
<div class="item-name"><a class="trait" href="trait.osstrext.html" title="trait std::os::windows::ffi::OsStrExt">OsStrExt</a></div>
<div class="desc docblock-short">Windows-specific extensions to <a href="../../../ffi/struct.osstr.html" title="struct std::ffi::OsStr"><code>OsStr</code></a>.</div>
</li>
<li>
<div class="item-name"><a class="trait" href="trait.osstringext.html" title="trait std::os::windows::ffi::OsStringExt">OsStringExt</a></div>
<div class="desc docblock-short">Windows-specific extensions to <a href="../../../ffi/struct.osstring.html" title="struct std::ffi::OsString"><code>OsString</code></a>.</div>
</li>
</ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/os/windows/ffi/index.html" class="_attribution-link">https://doc.rust-lang.org/std/os/windows/ffi/index.html</a>
  </p>
</div>
