<h1 class="main-heading">Function replace</h1>
<pre class="rust item-decl" data-language="rust">pub const unsafe fn replace&lt;T&gt;(dst: *mut T, src: T) -&gt; T</pre>
<p>Moves <code>src</code> into the pointed <code>dst</code>, returning the previous <code>dst</code> value.</p> <p>Neither value is dropped.</p> <p>This function is semantically equivalent to <a href="../mem/fn.replace.html" title="fn std::mem::replace"><code>mem::replace</code></a> except that it operates on raw pointers instead of references. When references are available, <a href="../mem/fn.replace.html" title="fn std::mem::replace"><code>mem::replace</code></a> should be preferred.</p> <h2 id="safety">Safety</h2> <p>Behavior is undefined if any of the following conditions are violated:</p> <ul> <li> <p><code>dst</code> must be <a href="index.html#safety" title="mod std::ptr">valid</a> for both reads and writes.</p> </li> <li> <p><code>dst</code> must be properly aligned.</p> </li> <li> <p><code>dst</code> must point to a properly initialized value of type <code>T</code>.</p> </li> </ul> <p>Note that even if <code>T</code> has size <code>0</code>, the pointer must be properly aligned.</p> <h2 id="examples">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::ptr;

let mut rust = vec!['b', 'u', 's', 't'];

// `mem::replace` would have the same effect without requiring the unsafe
// block.
let b = unsafe {
    ptr::replace(&amp;mut rust[0], 'r')
};

assert_eq!(b, 'b');
assert_eq!(rust, &amp;['r', 'u', 's', 't']);</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/ptr/fn.replace.html" class="_attribution-link">https://doc.rust-lang.org/std/ptr/fn.replace.html</a>
  </p>
</div>
