<h1 class="main-heading">Function read_volatile</h1>
<pre class="rust item-decl" data-language="rust">pub unsafe fn read_volatile&lt;T&gt;(src: *const T) -&gt; T</pre>
<p>Performs a volatile read of the value from <code>src</code> without moving it. This leaves the memory in <code>src</code> unchanged.</p> <p>Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.</p> <h2 id="notes">Notes</h2> <p>Rust does not currently have a rigorously and formally defined memory model, so the precise semantics of what “volatile” means here is subject to change over time. That being said, the semantics will almost always end up pretty similar to <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">C11’s definition of volatile</a>.</p> <p>The compiler shouldn’t change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to <code>read_volatile</code>) are noops and may be ignored.</p> <h2 id="safety">Safety</h2> <p>Behavior is undefined if any of the following conditions are violated:</p> <ul> <li> <p><code>src</code> must be <a href="index.html#safety" title="mod std::ptr">valid</a> for reads.</p> </li> <li> <p><code>src</code> must be properly aligned.</p> </li> <li> <p><code>src</code> must point to a properly initialized value of type <code>T</code>.</p> </li> </ul> <p>Like <a href="fn.read.html" title="fn std::ptr::read"><code>read</code></a>, <code>read_volatile</code> creates a bitwise copy of <code>T</code>, regardless of whether <code>T</code> is <a href="../marker/trait.copy.html" title="trait std::marker::Copy"><code>Copy</code></a>. If <code>T</code> is not <a href="../marker/trait.copy.html" title="trait std::marker::Copy"><code>Copy</code></a>, using both the returned value and the value at <code>*src</code> can <a href="fn.read.html#ownership-of-the-returned-value" title="fn std::ptr::read">violate memory safety</a>. However, storing non-<a href="../marker/trait.copy.html" title="trait std::marker::Copy"><code>Copy</code></a> types in volatile memory is almost certainly incorrect.</p> <p>Note that even if <code>T</code> has size <code>0</code>, the pointer must be properly aligned.</p> <p>Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads. Volatile accesses behave exactly like non-atomic accesses in that regard. In particular, a race between a <code>read_volatile</code> and any write operation to the same location is undefined behavior.</p> <h2 id="examples">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 12;
let y = &amp;x as *const i32;

unsafe {
    assert_eq!(std::ptr::read_volatile(y), 12);
}</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/ptr/fn.read_volatile.html" class="_attribution-link">https://doc.rust-lang.org/std/ptr/fn.read_volatile.html</a>
  </p>
</div>
