<h1 class="main-heading">Function from_raw_parts_mut</h1>
<pre class="rust item-decl" data-language="rust">pub const unsafe fn from_raw_parts_mut&lt;'a, T&gt;(
    data: *mut T,
    len: usize,
) -&gt; &amp;'a mut [T]</pre>
<p>Performs the same functionality as <a href="fn.from_raw_parts.html" title="fn std::slice::from_raw_parts"><code>from_raw_parts</code></a>, except that a mutable slice is returned.</p> <h2 id="safety">Safety</h2> <p>Behavior is undefined if any of the following conditions are violated:</p> <ul> <li> <p><code>data</code> must be non-null, <a href="../ptr/index.html#safety" title="mod std::ptr">valid</a> for both reads and writes for <code>len * mem::size_of::&lt;T&gt;()</code> many bytes, and it must be properly aligned. This means in particular:</p> <ul> <li>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects.</li> <li>
<code>data</code> must be non-null and aligned even for zero-length slices or slices of ZSTs. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as <code>data</code> for zero-length slices using <a href="../ptr/struct.nonnull.html#method.dangling" title="associated function std::ptr::NonNull::dangling"><code>NonNull::dangling()</code></a>.</li> </ul> </li> <li> <p><code>data</code> must point to <code>len</code> consecutive properly initialized values of type <code>T</code>.</p> </li> <li> <p>The memory referenced by the returned slice must not be accessed through any other pointer (not derived from the return value) for the duration of lifetime <code>'a</code>. Both read and write accesses are forbidden.</p> </li> <li> <p>The total size <code>len * mem::size_of::&lt;T&gt;()</code> of the slice must be no larger than <code>isize::MAX</code>, and adding that size to <code>data</code> must not “wrap around” the address space. See the safety documentation of <a href="../primitive.pointer.html#method.offset" title="method pointer::offset"><code>pointer::offset</code></a>.</p> </li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts_mut.html" class="_attribution-link">https://doc.rust-lang.org/std/slice/fn.from_raw_parts_mut.html</a>
  </p>
</div>
