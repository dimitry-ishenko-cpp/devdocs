<h1 class="main-heading">Keyword mut</h1>
<p>A mutable variable, reference, or pointer.</p> <p><code>mut</code> can be used in several situations. The first is mutable variables, which can be used anywhere you can bind a value to a variable name. Some examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">// A mutable variable in the parameter list of a function.
fn foo(mut x: u8, y: u8) -&gt; u8 {
    x += y;
    x
}

// Modifying a mutable variable.
let mut a = 5;
a = 6;

assert_eq!(foo(3, 4), 7);
assert_eq!(a, 6);</pre></div> <p>The second is mutable references. They can be created from <code>mut</code> variables and must be unique: no other variables can have a mutable reference, nor a shared reference.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">// Taking a mutable reference.
fn push_two(v: &amp;mut Vec&lt;u8&gt;) {
    v.push(2);
}

// A mutable reference cannot be taken to a non-mutable variable.
let mut v = vec![0, 1];
// Passing a mutable reference.
push_two(&amp;mut v);

assert_eq!(v, vec![0, 1, 2]);</pre></div> <div class="example-wrap compile_fail">â“˜<pre class="rust rust-example-rendered" data-language="rust">let mut v = vec![0, 1];
let mut_ref_v = &amp;mut v;
#[allow(unused)]
let ref_v = &amp;v;
mut_ref_v.push(2);</pre>
</div> <p>Mutable raw pointers work much like mutable references, with the added possibility of not pointing to a valid object. The syntax is <code>*mut Type</code>.</p> <p>More information on mutable references and pointers can be found in the <a href="../reference/types/pointer.html#mutable-references-mut">Reference</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/keyword.mut.html" class="_attribution-link">https://doc.rust-lang.org/std/keyword.mut.html</a>
  </p>
</div>
