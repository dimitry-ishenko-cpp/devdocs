<h1 class="main-heading">Struct std::rc::Rc</h1>
<pre class="rust item-decl" data-language="rust">pub struct Rc&lt;T, A = Global&gt;
where
    A: Allocator,
    T: ?Sized,{ /* private fields */ }</pre>
<p>A single-threaded reference-counting pointer. â€˜Rcâ€™ stands for â€˜Reference Countedâ€™.</p> <p>See the <a href="index.html">module-level documentation</a> for more details.</p> <p>The inherent methods of <code>Rc</code> are all associated functions, which means that you have to call them as e.g., <a href="struct.rc.html#method.get_mut" title="associated function std::rc::Rc::get_mut"><code>Rc::get_mut(&amp;mut value)</code></a> instead of <code>value.get_mut()</code>. This avoids conflicts with methods of the inner type <code>T</code>.</p> <h2 id="implementations" class="small-section-header">Implementations</h2>
<div id="implementations-list">
<summary><section id="impl-Rc%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#378">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Rc&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.new" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#390">source</a><pre class="code-header" data-language="rust">pub fn new(value: T) -&gt; Rc&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Constructs a new <code>Rc&lt;T&gt;</code>.</p> <h5 id="examples">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);</pre></div> </div>
<summary><section id="method.new_cyclic" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.60.0">1.60.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#456-458">source</a></span><pre class="code-header" data-language="rust">pub fn new_cyclic&lt;F&gt;(data_fn: F) -&gt; Rc&lt;T&gt;
where
    F: FnOnce(&amp;Weak&lt;T&gt;) -&gt; T,</pre></section></summary><div class="docblock">
<p>Constructs a new <code>Rc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the allocation, to allow you to construct a <code>T</code> which holds a weak pointer to itself.</p> <p>Generally, a structure circularly referencing itself, either directly or indirectly, should not hold a strong reference to itself to prevent a memory leak. Using this function, you get access to the weak pointer during the initialization of <code>T</code>, before the <code>Rc&lt;T&gt;</code> is created, such that you can clone and store it inside the <code>T</code>.</p> <p><code>new_cyclic</code> first allocates the managed allocation for the <code>Rc&lt;T&gt;</code>, then calls your closure, giving it a <code>Weak&lt;T&gt;</code> to this allocation, and only afterwards completes the construction of the <code>Rc&lt;T&gt;</code> by placing the <code>T</code> returned from your closure into the allocation.</p> <p>Since the new <code>Rc&lt;T&gt;</code> is not fully-constructed until <code>Rc&lt;T&gt;::new_cyclic</code> returns, calling <a href="struct.weak.html#method.upgrade" title="method std::rc::Weak::upgrade"><code>upgrade</code></a> on the weak reference inside your closure will fail and result in a <code>None</code> value.</p> <h5 id="panics">Panics</h5> <p>If <code>data_fn</code> panics, the panic is propagated to the caller, and the temporary <a href="struct.weak.html" title="struct std::rc::Weak"><code>Weak&lt;T&gt;</code></a> is dropped normally.</p> <h5 id="examples-1">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::{Rc, Weak};

struct Gadget {
    me: Weak&lt;Gadget&gt;,
}

impl Gadget {
    /// Construct a reference counted Gadget.
    fn new() -&gt; Rc&lt;Self&gt; {
        // `me` is a `Weak&lt;Gadget&gt;` pointing at the new allocation of the
        // `Rc` we're constructing.
        Rc::new_cyclic(|me| {
            // Create the actual struct here.
            Gadget { me: me.clone() }
        })
    }

    /// Return a reference counted pointer to Self.
    fn me(&amp;self) -&gt; Rc&lt;Self&gt; {
        self.me.upgrade().unwrap()
    }
}</pre></div> </div>
<summary><section id="method.new_uninit" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#520">source</a><pre class="code-header" data-language="rust">pub fn new_uninit() -&gt; Rc&lt;MaybeUninit&lt;T&gt;&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code> <a href="https://github.com/rust-lang/rust/issues/63291">#63291</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Rc</code> with uninitialized contents.</p> <h5 id="examples-2">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_uninit)]
#![feature(get_mut_unchecked)]

use std::rc::Rc;

let mut five = Rc::&lt;u32&gt;::new_uninit();

// Deferred initialization:
Rc::get_mut(&amp;mut five).unwrap().write(5);

let five = unsafe { five.assume_init() };

assert_eq!(*five, 5)</pre></div> </div>
<summary><section id="method.new_zeroed" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#553">source</a><pre class="code-header" data-language="rust">pub fn new_zeroed() -&gt; Rc&lt;MaybeUninit&lt;T&gt;&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code> <a href="https://github.com/rust-lang/rust/issues/63291">#63291</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Rc</code> with uninitialized contents, with the memory being filled with <code>0</code> bytes.</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-3">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_uninit)]

use std::rc::Rc;

let zero = Rc::&lt;u32&gt;::new_zeroed();
let zero = unsafe { zero.assume_init() };

assert_eq!(*zero, 0)</pre></div> </div>
<summary><section id="method.try_new" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#575">source</a><pre class="code-header" data-language="rust">pub fn try_new(value: T) -&gt; Result&lt;Rc&lt;T&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Rc&lt;T&gt;</code>, returning an error if the allocation fails</p> <h5 id="examples-4">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]
use std::rc::Rc;

let five = Rc::try_new(5);</pre></div> </div>
<summary><section id="method.try_new_uninit" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#610">source</a><pre class="code-header" data-language="rust">pub fn try_new_uninit() -&gt; Result&lt;Rc&lt;MaybeUninit&lt;T&gt;&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Rc</code> with uninitialized contents, returning an error if the allocation fails</p> <h5 id="examples-5">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api, new_uninit)]
#![feature(get_mut_unchecked)]

use std::rc::Rc;

let mut five = Rc::&lt;u32&gt;::try_new_uninit()?;

// Deferred initialization:
Rc::get_mut(&amp;mut five).unwrap().write(5);

let five = unsafe { five.assume_init() };

assert_eq!(*five, 5);</pre></div> </div>
<summary><section id="method.try_new_zeroed" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#643">source</a><pre class="code-header" data-language="rust">pub fn try_new_zeroed() -&gt; Result&lt;Rc&lt;MaybeUninit&lt;T&gt;&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Rc</code> with uninitialized contents, with the memory being filled with <code>0</code> bytes, returning an error if the allocation fails</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-6">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api, new_uninit)]

use std::rc::Rc;

let zero = Rc::&lt;u32&gt;::try_new_zeroed()?;
let zero = unsafe { zero.assume_init() };

assert_eq!(*zero, 0);</pre></div> </div>
<summary><section id="method.pin" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.33.0">1.33.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#657">source</a></span><pre class="code-header" data-language="rust">pub fn pin(value: T) -&gt; Pin&lt;Rc&lt;T&gt;&gt;</pre></section></summary><div class="docblock">
<p>Constructs a new <code>Pin&lt;Rc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>, then <code>value</code> will be pinned in memory and unable to be moved.</p> </div>
</div>
<summary><section id="impl-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#662">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Rc&lt;T, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.allocator" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#670">source</a><pre class="code-header" data-language="rust">pub fn allocator(this: &amp;Rc&lt;T, A&gt;) -&gt; &amp;A</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns a reference to the underlying allocator.</p> <p>Note: this is an associated function, which means that you have to call it as <code>Rc::allocator(&amp;r)</code> instead of <code>r.allocator()</code>. This is so that there is no conflict with a method on the inner type.</p> </div>
<summary><section id="method.new_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#687">source</a><pre class="code-header" data-language="rust">pub fn new_in(value: T, alloc: A) -&gt; Rc&lt;T, A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Rc</code> in the provided allocator.</p> <h5 id="examples-7">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]
use std::rc::Rc;
use std::alloc::System;

let five = Rc::new_in(5, System);</pre></div> </div>
<summary><section id="method.new_uninit_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#723">source</a><pre class="code-header" data-language="rust">pub fn new_uninit_in(alloc: A) -&gt; Rc&lt;MaybeUninit&lt;T&gt;, A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Rc</code> with uninitialized contents in the provided allocator.</p> <h5 id="examples-8">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_uninit)]
#![feature(get_mut_unchecked)]
#![feature(allocator_api)]

use std::rc::Rc;
use std::alloc::System;

let mut five = Rc::&lt;u32, _&gt;::new_uninit_in(System);

let five = unsafe {
    // Deferred initialization:
    Rc::get_mut_unchecked(&amp;mut five).as_mut_ptr().write(5);

    five.assume_init()
};

assert_eq!(*five, 5)</pre></div> </div>
<summary><section id="method.new_zeroed_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#762">source</a><pre class="code-header" data-language="rust">pub fn new_zeroed_in(alloc: A) -&gt; Rc&lt;MaybeUninit&lt;T&gt;, A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Rc</code> with uninitialized contents, with the memory being filled with <code>0</code> bytes, in the provided allocator.</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-9">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_uninit)]
#![feature(allocator_api)]

use std::rc::Rc;
use std::alloc::System;

let zero = Rc::&lt;u32, _&gt;::new_zeroed_in(System);
let zero = unsafe { zero.assume_init() };

assert_eq!(*zero, 0)</pre></div> </div>
<summary><section id="method.try_new_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#790">source</a><pre class="code-header" data-language="rust">pub fn try_new_in(value: T, alloc: A) -&gt; Result&lt;Rc&lt;T, A&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Rc&lt;T&gt;</code> in the provided allocator, returning an error if the allocation fails</p> <h5 id="examples-10">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]
use std::rc::Rc;
use std::alloc::System;

let five = Rc::try_new_in(5, System);</pre></div> </div>
<summary><section id="method.try_new_uninit_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#829">source</a><pre class="code-header" data-language="rust">pub fn try_new_uninit_in(alloc: A) -&gt; Result&lt;Rc&lt;MaybeUninit&lt;T&gt;, A&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Rc</code> with uninitialized contents, in the provided allocator, returning an error if the allocation fails</p> <h5 id="examples-11">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api, new_uninit)]
#![feature(get_mut_unchecked)]

use std::rc::Rc;
use std::alloc::System;

let mut five = Rc::&lt;u32, _&gt;::try_new_uninit_in(System)?;

let five = unsafe {
    // Deferred initialization:
    Rc::get_mut_unchecked(&amp;mut five).as_mut_ptr().write(5);

    five.assume_init()
};

assert_eq!(*five, 5);</pre></div> </div>
<summary><section id="method.try_new_zeroed_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#868">source</a><pre class="code-header" data-language="rust">pub fn try_new_zeroed_in(alloc: A) -&gt; Result&lt;Rc&lt;MaybeUninit&lt;T&gt;, A&gt;, AllocError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Rc</code> with uninitialized contents, with the memory being filled with <code>0</code> bytes, in the provided allocator, returning an error if the allocation fails</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-12">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api, new_uninit)]

use std::rc::Rc;
use std::alloc::System;

let zero = Rc::&lt;u32, _&gt;::try_new_zeroed_in(System)?;
let zero = unsafe { zero.assume_init() };

assert_eq!(*zero, 0);</pre></div> </div>
<summary><section id="method.pin_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#886">source</a><pre class="code-header" data-language="rust">pub fn pin_in(value: T, alloc: A) -&gt; Pin&lt;Rc&lt;T, A&gt;&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new <code>Pin&lt;Rc&lt;T&gt;&gt;</code> in the provided allocator. If <code>T</code> does not implement <code>Unpin</code>, then <code>value</code> will be pinned in memory and unable to be moved.</p> </div>
<summary><section id="method.try_unwrap" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#911">source</a></span><pre class="code-header" data-language="rust">pub fn try_unwrap(this: Rc&lt;T, A&gt;) -&gt; Result&lt;T, Rc&lt;T, A&gt;&gt;</pre></section></summary><div class="docblock">
<p>Returns the inner value, if the <code>Rc</code> has exactly one strong reference.</p> <p>Otherwise, an <a href="../result/enum.result.html#variant.Err" title="variant std::result::Result::Err"><code>Err</code></a> is returned with the same <code>Rc</code> that was passed in.</p> <p>This will succeed even if there are outstanding weak references.</p> <h5 id="examples-13">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let x = Rc::new(3);
assert_eq!(Rc::try_unwrap(x), Ok(3));

let x = Rc::new(4);
let _y = Rc::clone(&amp;x);
assert_eq!(*Rc::try_unwrap(x).unwrap_err(), 4);</pre></div> </div>
<summary><section id="method.into_inner" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#945">source</a></span><pre class="code-header" data-language="rust">pub fn into_inner(this: Rc&lt;T, A&gt;) -&gt; Option&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Returns the inner value, if the <code>Rc</code> has exactly one strong reference.</p> <p>Otherwise, <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is returned and the <code>Rc</code> is dropped.</p> <p>This will succeed even if there are outstanding weak references.</p> <p>If <code>Rc::into_inner</code> is called on every clone of this <code>Rc</code>, it is guaranteed that exactly one of the calls returns the inner value. This means in particular that the inner value is not dropped.</p> <p>This is equivalent to <code>Rc::try_unwrap(this).ok()</code>. (Note that these are not equivalent for <a href="../sync/struct.arc.html" title="struct std::sync::Arc"><code>Arc</code></a>, due to race conditions that do not apply to <code>Rc</code>.)</p> </div>
</div>
<summary><section id="impl-Rc%3C%5BT%5D%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#950">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Rc&lt;[T]&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.new_uninit_slice" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#976">source</a><pre class="code-header" data-language="rust">pub fn new_uninit_slice(len: usize) -&gt; Rc&lt;[MaybeUninit&lt;T&gt;]&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code> <a href="https://github.com/rust-lang/rust/issues/63291">#63291</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new reference-counted slice with uninitialized contents.</p> <h5 id="examples-14">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_uninit)]
#![feature(get_mut_unchecked)]

use std::rc::Rc;

let mut values = Rc::&lt;[u32]&gt;::new_uninit_slice(3);

// Deferred initialization:
let data = Rc::get_mut(&amp;mut values).unwrap();
data[0].write(1);
data[1].write(2);
data[2].write(3);

let values = unsafe { values.assume_init() };

assert_eq!(*values, [1, 2, 3])</pre></div> </div>
<summary><section id="method.new_zeroed_slice" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1003">source</a><pre class="code-header" data-language="rust">pub fn new_zeroed_slice(len: usize) -&gt; Rc&lt;[MaybeUninit&lt;T&gt;]&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code> <a href="https://github.com/rust-lang/rust/issues/63291">#63291</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new reference-counted slice with uninitialized contents, with the memory being filled with <code>0</code> bytes.</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-15">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_uninit)]

use std::rc::Rc;

let values = Rc::&lt;[u32]&gt;::new_zeroed_slice(3);
let values = unsafe { values.assume_init() };

assert_eq!(*values, [0, 0, 0])</pre></div> </div>
</div>
<summary><section id="impl-Rc%3C%5BT%5D,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1017">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Rc&lt;[T], A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.new_uninit_slice_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1047">source</a><pre class="code-header" data-language="rust">pub fn new_uninit_slice_in(len: usize, alloc: A) -&gt; Rc&lt;[MaybeUninit&lt;T&gt;], A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new reference-counted slice with uninitialized contents.</p> <h5 id="examples-16">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_uninit)]
#![feature(get_mut_unchecked)]
#![feature(allocator_api)]

use std::rc::Rc;
use std::alloc::System;

let mut values = Rc::&lt;[u32], _&gt;::new_uninit_slice_in(3, System);

let values = unsafe {
    // Deferred initialization:
    Rc::get_mut_unchecked(&amp;mut values)[0].as_mut_ptr().write(1);
    Rc::get_mut_unchecked(&amp;mut values)[1].as_mut_ptr().write(2);
    Rc::get_mut_unchecked(&amp;mut values)[2].as_mut_ptr().write(3);

    values.assume_init()
};

assert_eq!(*values, [1, 2, 3])</pre></div> </div>
<summary><section id="method.new_zeroed_slice_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1077">source</a><pre class="code-header" data-language="rust">pub fn new_zeroed_slice_in(len: usize, alloc: A) -&gt; Rc&lt;[MaybeUninit&lt;T&gt;], A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs a new reference-counted slice with uninitialized contents, with the memory being filled with <code>0</code> bytes.</p> <p>See <a href="../mem/union.maybeuninit.html#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage of this method.</p> <h5 id="examples-17">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_uninit)]
#![feature(allocator_api)]

use std::rc::Rc;
use std::alloc::System;

let values = Rc::&lt;[u32], _&gt;::new_zeroed_slice_in(3, System);
let values = unsafe { values.assume_init() };

assert_eq!(*values, [0, 0, 0])</pre></div> </div>
</div>
<summary><section id="impl-Rc%3CMaybeUninit%3CT%3E,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1094">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Rc&lt;MaybeUninit&lt;T&gt;, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.assume_init" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1126-1128">source</a><pre class="code-header" data-language="rust">pub unsafe fn assume_init(self) -&gt; Rc&lt;T, A&gt;
where
    A: Clone,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code> <a href="https://github.com/rust-lang/rust/issues/63291">#63291</a>)</span>
</div></span></summary><div class="docblock">
<p>Converts to <code>Rc&lt;T&gt;</code>.</p> <h5 id="safety">Safety</h5> <p>As with <a href="../mem/union.maybeuninit.html#method.assume_init" title="method std::mem::MaybeUninit::assume_init"><code>MaybeUninit::assume_init</code></a>, it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</p> <h5 id="examples-18">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_uninit)]
#![feature(get_mut_unchecked)]

use std::rc::Rc;

let mut five = Rc::&lt;u32&gt;::new_uninit();

// Deferred initialization:
Rc::get_mut(&amp;mut five).unwrap().write(5);

let five = unsafe { five.assume_init() };

assert_eq!(*five, 5)</pre></div> </div>
</div>
<summary><section id="impl-Rc%3C%5BMaybeUninit%3CT%3E%5D,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1135">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Rc&lt;[MaybeUninit&lt;T&gt;], A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.assume_init-1" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1170-1172">source</a><pre class="code-header" data-language="rust">pub unsafe fn assume_init(self) -&gt; Rc&lt;[T], A&gt;
where
    A: Clone,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code> <a href="https://github.com/rust-lang/rust/issues/63291">#63291</a>)</span>
</div></span></summary><div class="docblock">
<p>Converts to <code>Rc&lt;[T]&gt;</code>.</p> <h5 id="safety-1">Safety</h5> <p>As with <a href="../mem/union.maybeuninit.html#method.assume_init" title="method std::mem::MaybeUninit::assume_init"><code>MaybeUninit::assume_init</code></a>, it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</p> <h5 id="examples-19">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_uninit)]
#![feature(get_mut_unchecked)]

use std::rc::Rc;

let mut values = Rc::&lt;[u32]&gt;::new_uninit_slice(3);

// Deferred initialization:
let data = Rc::get_mut(&amp;mut values).unwrap();
data[0].write(1);
data[1].write(2);
data[2].write(3);

let values = unsafe { values.assume_init() };

assert_eq!(*values, [1, 2, 3])</pre></div> </div>
</div>
<summary><section id="impl-Rc%3CT%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1179">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Rc&lt;T&gt;
where
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.from_raw" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1221">source</a></span><pre class="code-header" data-language="rust">pub unsafe fn from_raw(ptr: *const T) -&gt; Rc&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Constructs an <code>Rc&lt;T&gt;</code> from a raw pointer.</p> <p>The raw pointer must have been previously returned by a call to <a href="struct.rc.html#method.into_raw" title="associated function std::rc::Rc::into_raw"><code>Rc&lt;U&gt;::into_raw</code></a> where <code>U</code> must have the same size and alignment as <code>T</code>. This is trivially true if <code>U</code> is <code>T</code>. Note that if <code>U</code> is not <code>T</code> but has the same size and alignment, this is basically like transmuting references of different types. See <a href="../mem/fn.transmute.html" title="fn std::mem::transmute"><code>mem::transmute</code></a> for more information on what restrictions apply in this case.</p> <p>The raw pointer must point to a block of memory allocated by the global allocator</p> <p>The user of <code>from_raw</code> has to make sure a specific value of <code>T</code> is only dropped once.</p> <p>This function is unsafe because improper use may lead to memory unsafety, even if the returned <code>Rc&lt;T&gt;</code> is never accessed.</p> <h5 id="examples-20">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let x = Rc::new("hello".to_owned());
let x_ptr = Rc::into_raw(x);

unsafe {
    // Convert back to an `Rc` to prevent leak.
    let x = Rc::from_raw(x_ptr);
    assert_eq!(&amp;*x, "hello");

    // Further calls to `Rc::from_raw(x_ptr)` would be memory-unsafe.
}

// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!</pre></div> </div>
<summary><section id="method.increment_strong_count" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.53.0">1.53.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1252">source</a></span><pre class="code-header" data-language="rust">pub unsafe fn increment_strong_count(ptr: *const T)</pre></section></summary><div class="docblock">
<p>Increments the strong reference count on the <code>Rc&lt;T&gt;</code> associated with the provided pointer by one.</p> <h5 id="safety-2">Safety</h5> <p>The pointer must have been obtained through <code>Rc::into_raw</code>, the associated <code>Rc</code> instance must be valid (i.e. the strong count must be at least 1) for the duration of this method, and <code>ptr</code> must point to a block of memory allocated by the global allocator.</p> <h5 id="examples-21">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);

unsafe {
    let ptr = Rc::into_raw(five);
    Rc::increment_strong_count(ptr);

    let five = Rc::from_raw(ptr);
    assert_eq!(2, Rc::strong_count(&amp;five));
}</pre></div> </div>
<summary><section id="method.decrement_strong_count" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.53.0">1.53.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1286">source</a></span><pre class="code-header" data-language="rust">pub unsafe fn decrement_strong_count(ptr: *const T)</pre></section></summary><div class="docblock">
<p>Decrements the strong reference count on the <code>Rc&lt;T&gt;</code> associated with the provided pointer by one.</p> <h5 id="safety-3">Safety</h5> <p>The pointer must have been obtained through <code>Rc::into_raw</code>, the associated <code>Rc</code> instance must be valid (i.e. the strong count must be at least 1) when invoking this method, and <code>ptr</code> must point to a block of memory allocated by the global allocator. This method can be used to release the final <code>Rc</code> and backing storage, but <strong>should not</strong> be called after the final <code>Rc</code> has been released.</p> <h5 id="examples-22">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);

unsafe {
    let ptr = Rc::into_raw(five);
    Rc::increment_strong_count(ptr);

    let five = Rc::from_raw(ptr);
    assert_eq!(2, Rc::strong_count(&amp;five));
    Rc::decrement_strong_count(ptr);
    assert_eq!(1, Rc::strong_count(&amp;five));
}</pre></div> </div>
</div>
<summary><section id="impl-Rc%3CT,+A%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1291">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Rc&lt;T, A&gt;
where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.into_raw" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1308">source</a></span><pre class="code-header" data-language="rust">pub fn into_raw(this: Rc&lt;T, A&gt;) -&gt; *const T</pre></section></summary><div class="docblock">
<p>Consumes the <code>Rc</code>, returning the wrapped pointer.</p> <p>To avoid a memory leak the pointer must be converted back to an <code>Rc</code> using <a href="struct.rc.html#method.from_raw" title="associated function std::rc::Rc::from_raw"><code>Rc::from_raw</code></a>.</p> <h5 id="examples-23">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let x = Rc::new("hello".to_owned());
let x_ptr = Rc::into_raw(x);
assert_eq!(unsafe { &amp;*x_ptr }, "hello");</pre></div> </div>
<summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1332">source</a></span><pre class="code-header" data-language="rust">pub fn as_ptr(this: &amp;Rc&lt;T, A&gt;) -&gt; *const T</pre></section></summary><div class="docblock">
<p>Provides a raw pointer to the data.</p> <p>The counts are not affected in any way and the <code>Rc</code> is not consumed. The pointer is valid for as long there are strong counts in the <code>Rc</code>.</p> <h5 id="examples-24">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let x = Rc::new("hello".to_owned());
let y = Rc::clone(&amp;x);
let x_ptr = Rc::as_ptr(&amp;x);
assert_eq!(x_ptr, Rc::as_ptr(&amp;y));
assert_eq!(unsafe { &amp;*x_ptr }, "hello");</pre></div> </div>
<summary><section id="method.from_raw_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1383">source</a><pre class="code-header" data-language="rust">pub unsafe fn from_raw_in(ptr: *const T, alloc: A) -&gt; Rc&lt;T, A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Constructs an <code>Rc&lt;T, A&gt;</code> from a raw pointer in the provided allocator.</p> <p>The raw pointer must have been previously returned by a call to <a href="struct.rc.html#method.into_raw" title="associated function std::rc::Rc::into_raw"><code>Rc&lt;U, A&gt;::into_raw</code></a> where <code>U</code> must have the same size and alignment as <code>T</code>. This is trivially true if <code>U</code> is <code>T</code>. Note that if <code>U</code> is not <code>T</code> but has the same size and alignment, this is basically like transmuting references of different types. See <a href="../mem/fn.transmute.html" title="fn std::mem::transmute"><code>mem::transmute</code></a> for more information on what restrictions apply in this case.</p> <p>The raw pointer must point to a block of memory allocated by <code>alloc</code></p> <p>The user of <code>from_raw</code> has to make sure a specific value of <code>T</code> is only dropped once.</p> <p>This function is unsafe because improper use may lead to memory unsafety, even if the returned <code>Rc&lt;T&gt;</code> is never accessed.</p> <h5 id="examples-25">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::rc::Rc;
use std::alloc::System;

let x = Rc::new_in("hello".to_owned(), System);
let x_ptr = Rc::into_raw(x);

unsafe {
    // Convert back to an `Rc` to prevent leak.
    let x = Rc::from_raw_in(x_ptr, System);
    assert_eq!(&amp;*x, "hello");

    // Further calls to `Rc::from_raw(x_ptr)` would be memory-unsafe.
}

// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!</pre></div> </div>
<summary><section id="method.downgrade" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1406-1408">source</a></span><pre class="code-header" data-language="rust">pub fn downgrade(this: &amp;Rc&lt;T, A&gt;) -&gt; Weak&lt;T, A&gt;
where
    A: Clone,</pre></section></summary><div class="docblock">
<p>Creates a new <a href="struct.weak.html" title="struct std::rc::Weak"><code>Weak</code></a> pointer to this allocation.</p> <h5 id="examples-26">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);

let weak_five = Rc::downgrade(&amp;five);</pre></div> </div>
<summary><section id="method.weak_count" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.15.0">1.15.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1430">source</a></span><pre class="code-header" data-language="rust">pub fn weak_count(this: &amp;Rc&lt;T, A&gt;) -&gt; usize</pre></section></summary><div class="docblock">
<p>Gets the number of <a href="struct.weak.html" title="struct std::rc::Weak"><code>Weak</code></a> pointers to this allocation.</p> <h5 id="examples-27">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);
let _weak_five = Rc::downgrade(&amp;five);

assert_eq!(1, Rc::weak_count(&amp;five));</pre></div> </div>
<summary><section id="method.strong_count" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.15.0">1.15.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1448">source</a></span><pre class="code-header" data-language="rust">pub fn strong_count(this: &amp;Rc&lt;T, A&gt;) -&gt; usize</pre></section></summary><div class="docblock">
<p>Gets the number of strong (<code>Rc</code>) pointers to this allocation.</p> <h5 id="examples-28">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);
let _also_five = Rc::clone(&amp;five);

assert_eq!(2, Rc::strong_count(&amp;five));</pre></div> </div>
<summary><section id="method.increment_strong_count_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1482-1484">source</a><pre class="code-header" data-language="rust">pub unsafe fn increment_strong_count_in(ptr: *const T, alloc: A)
where
    A: Clone,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Increments the strong reference count on the <code>Rc&lt;T&gt;</code> associated with the provided pointer by one.</p> <h5 id="safety-4">Safety</h5> <p>The pointer must have been obtained through <code>Rc::into_raw</code>, the associated <code>Rc</code> instance must be valid (i.e. the strong count must be at least 1) for the duration of this method, and <code>ptr</code> must point to a block of memory allocated by <code>alloc</code></p> <h5 id="examples-29">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::rc::Rc;
use std::alloc::System;

let five = Rc::new_in(5, System);

unsafe {
    let ptr = Rc::into_raw(five);
    Rc::increment_strong_count_in(ptr, System);

    let five = Rc::from_raw_in(ptr, System);
    assert_eq!(2, Rc::strong_count(&amp;five));
}</pre></div> </div>
<summary><section id="method.decrement_strong_count_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1525">source</a><pre class="code-header" data-language="rust">pub unsafe fn decrement_strong_count_in(ptr: *const T, alloc: A)</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Decrements the strong reference count on the <code>Rc&lt;T&gt;</code> associated with the provided pointer by one.</p> <h5 id="safety-5">Safety</h5> <p>The pointer must have been obtained through <code>Rc::into_raw</code>, the associated <code>Rc</code> instance must be valid (i.e. the strong count must be at least 1) when invoking this method, and <code>ptr</code> must point to a block of memory allocated by <code>alloc</code>. This method can be used to release the final <code>Rc</code> and backing storage, but <strong>should not</strong> be called after the final <code>Rc</code> has been released.</p> <h5 id="examples-30">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(allocator_api)]

use std::rc::Rc;
use std::alloc::System;

let five = Rc::new_in(5, System);

unsafe {
    let ptr = Rc::into_raw(five);
    Rc::increment_strong_count_in(ptr, System);

    let five = Rc::from_raw_in(ptr, System);
    assert_eq!(2, Rc::strong_count(&amp;five));
    Rc::decrement_strong_count_in(ptr, System);
    assert_eq!(1, Rc::strong_count(&amp;five));
}</pre></div> </div>
<summary><section id="method.get_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1562">source</a></span><pre class="code-header" data-language="rust">pub fn get_mut(this: &amp;mut Rc&lt;T, A&gt;) -&gt; Option&lt;&amp;mut T&gt;</pre></section></summary><div class="docblock">
<p>Returns a mutable reference into the given <code>Rc</code>, if there are no other <code>Rc</code> or <a href="struct.weak.html" title="struct std::rc::Weak"><code>Weak</code></a> pointers to the same allocation.</p> <p>Returns <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> otherwise, because it is not safe to mutate a shared value.</p> <p>See also <a href="struct.rc.html#method.make_mut" title="associated function std::rc::Rc::make_mut"><code>make_mut</code></a>, which will <a href="../clone/trait.clone.html#tymethod.clone" title="method std::clone::Clone::clone"><code>clone</code></a> the inner value when there are other <code>Rc</code> pointers.</p> <h5 id="examples-31">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let mut x = Rc::new(3);
*Rc::get_mut(&amp;mut x).unwrap() = 4;
assert_eq!(*x, 4);

let _y = Rc::clone(&amp;x);
assert!(Rc::get_mut(&amp;mut x).is_none());</pre></div> </div>
<summary><section id="method.get_mut_unchecked" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1628">source</a><pre class="code-header" data-language="rust">pub unsafe fn get_mut_unchecked(this: &amp;mut Rc&lt;T, A&gt;) -&gt; &amp;mut T</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>get_mut_unchecked</code> <a href="https://github.com/rust-lang/rust/issues/63292">#63292</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns a mutable reference into the given <code>Rc</code>, without any check.</p> <p>See also <a href="struct.rc.html#method.get_mut" title="associated function std::rc::Rc::get_mut"><code>get_mut</code></a>, which is safe and does appropriate checks.</p> <h5 id="safety-6">Safety</h5> <p>If any other <code>Rc</code> or <a href="struct.weak.html" title="struct std::rc::Weak"><code>Weak</code></a> pointers to the same allocation exist, then they must not be dereferenced or have active borrows for the duration of the returned borrow, and their inner type must be exactly the same as the inner type of this Rc (including lifetimes). This is trivially the case if no such pointers exist, for example immediately after <code>Rc::new</code>.</p> <h5 id="examples-32">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]

use std::rc::Rc;

let mut x = Rc::new(String::new());
unsafe {
    Rc::get_mut_unchecked(&amp;mut x).push_str("foo")
}
assert_eq!(*x, "foo");</pre></div> <p>Other <code>Rc</code> pointers to the same allocation must be to the same type.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]

use std::rc::Rc;

let x: Rc&lt;str&gt; = Rc::from("Hello, world!");
let mut y: Rc&lt;[u8]&gt; = x.clone().into();
unsafe {
    // this is Undefined Behavior, because x's inner type is str, not [u8]
    Rc::get_mut_unchecked(&amp;mut y).fill(0xff); // 0xff is invalid in UTF-8
}
println!("{}", &amp;*x); // Invalid UTF-8 in a str</pre></div> <p>Other <code>Rc</code> pointers to the same allocation must be to the exact same type, including lifetimes.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(get_mut_unchecked)]

use std::rc::Rc;

let x: Rc&lt;&amp;str&gt; = Rc::new("Hello, world!");
{
    let s = String::from("Oh, no!");
    let mut y: Rc&lt;&amp;str&gt; = x.clone().into();
    unsafe {
        // this is Undefined Behavior, because x's inner type
        // is &amp;'long str, not &amp;'short str
        *Rc::get_mut_unchecked(&amp;mut y) = &amp;s;
    }
}
println!("{}", &amp;*x); // Use-after-free</pre></div> </div>
<summary><section id="method.ptr_eq" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1651">source</a></span><pre class="code-header" data-language="rust">pub fn ptr_eq(this: &amp;Rc&lt;T, A&gt;, other: &amp;Rc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the two <code>Rc</code>s point to the same allocation in a vein similar to <a href="../ptr/fn.eq.html" title="fn std::ptr::eq"><code>ptr::eq</code></a>. This function ignores the metadata of <code>dyn Trait</code> pointers.</p> <h5 id="examples-33">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);
let same_five = Rc::clone(&amp;five);
let other_five = Rc::new(5);

assert!(Rc::ptr_eq(&amp;five, &amp;same_five));
assert!(!Rc::ptr_eq(&amp;five, &amp;other_five));</pre></div> </div>
</div>
<summary><section id="impl-Rc%3CT,+A%3E-2" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1656">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Rc&lt;T, A&gt;
where
    T: Clone,
    A: Allocator + Clone,</pre></section></summary><div class="impl-items">
<summary><section id="method.make_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1710">source</a></span><pre class="code-header" data-language="rust">pub fn make_mut(this: &amp;mut Rc&lt;T, A&gt;) -&gt; &amp;mut T</pre></section></summary><div class="docblock">
<p>Makes a mutable reference into the given <code>Rc</code>.</p> <p>If there are other <code>Rc</code> pointers to the same allocation, then <code>make_mut</code> will <a href="../clone/trait.clone.html#tymethod.clone" title="method std::clone::Clone::clone"><code>clone</code></a> the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</p> <p>However, if there are no other <code>Rc</code> pointers to this allocation, but some <a href="struct.weak.html" title="struct std::rc::Weak"><code>Weak</code></a> pointers, then the <a href="struct.weak.html" title="struct std::rc::Weak"><code>Weak</code></a> pointers will be disassociated and the inner value will not be cloned.</p> <p>See also <a href="struct.rc.html#method.get_mut" title="associated function std::rc::Rc::get_mut"><code>get_mut</code></a>, which will fail rather than cloning the inner value or disassociating <a href="struct.weak.html" title="struct std::rc::Weak"><code>Weak</code></a> pointers.</p> <h5 id="examples-34">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let mut data = Rc::new(5);

*Rc::make_mut(&amp;mut data) += 1;         // Won't clone anything
let mut other_data = Rc::clone(&amp;data); // Won't clone inner data
*Rc::make_mut(&amp;mut data) += 1;         // Clones inner data
*Rc::make_mut(&amp;mut data) += 1;         // Won't clone anything
*Rc::make_mut(&amp;mut other_data) *= 2;   // Won't clone anything

// Now `data` and `other_data` point to different allocations.
assert_eq!(*data, 8);
assert_eq!(*other_data, 12);</pre></div> <p><a href="struct.weak.html" title="struct std::rc::Weak"><code>Weak</code></a> pointers will be disassociated:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let mut data = Rc::new(75);
let weak = Rc::downgrade(&amp;data);

assert!(75 == *data);
assert!(75 == *weak.upgrade().unwrap());

*Rc::make_mut(&amp;mut data) += 1;

assert!(76 == *data);
assert!(weak.upgrade().is_none());</pre></div> </div>
<summary><section id="method.unwrap_or_clone" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1773">source</a><pre class="code-header" data-language="rust">pub fn unwrap_or_clone(this: Rc&lt;T, A&gt;) -&gt; T</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>arc_unwrap_or_clone</code> <a href="https://github.com/rust-lang/rust/issues/93610">#93610</a>)</span>
</div></span></summary><div class="docblock">
<p>If we have the only reference to <code>T</code> then unwrap it. Otherwise, clone <code>T</code> and return the clone.</p> <p>Assuming <code>rc_t</code> is of type <code>Rc&lt;T&gt;</code>, this function is functionally equivalent to <code>(*rc_t).clone()</code>, but will avoid cloning the inner value where possible.</p> <h5 id="examples-35">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(arc_unwrap_or_clone)]
let inner = String::from("test");
let ptr = inner.as_ptr();

let rc = Rc::new(inner);
let inner = Rc::unwrap_or_clone(rc);
// The inner value was not cloned
assert!(ptr::eq(ptr, inner.as_ptr()));

let rc = Rc::new(inner);
let rc2 = rc.clone();
let inner = Rc::unwrap_or_clone(rc);
// Because there were 2 references, we had to clone the inner value.
assert!(!ptr::eq(ptr, inner.as_ptr()));
// `rc2` is the last reference, so when we unwrap it we get back
// the original `String`.
let inner = Rc::unwrap_or_clone(rc2);
assert!(ptr::eq(ptr, inner.as_ptr()));</pre></div> </div>
</div>
<summary><section id="impl-Rc%3Cdyn+Any,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1778">source</a><pre class="code-header" data-language="rust">impl&lt;A&gt; Rc&lt;dyn Any, A&gt;
where
    A: Allocator + Clone,</pre></section></summary><div class="impl-items">
<summary><section id="method.downcast" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1799">source</a></span><pre class="code-header" data-language="rust">pub fn downcast&lt;T&gt;(self) -&gt; Result&lt;Rc&lt;T, A&gt;, Rc&lt;dyn Any, A&gt;&gt;
where
    T: Any,</pre></section></summary><div class="docblock">
<p>Attempt to downcast the <code>Rc&lt;dyn Any&gt;</code> to a concrete type.</p> <h5 id="examples-36">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::any::Any;
use std::rc::Rc;

fn print_if_string(value: Rc&lt;dyn Any&gt;) {
    if let Ok(string) = value.downcast::&lt;String&gt;() {
        println!("String ({}): {}", string.len(), string);
    }
}

let my_string = "Hello World".to_string();
print_if_string(Rc::new(my_string));
print_if_string(Rc::new(0i8));</pre></div> </div>
<summary><section id="method.downcast_unchecked" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1840">source</a><pre class="code-header" data-language="rust">pub unsafe fn downcast_unchecked&lt;T&gt;(self) -&gt; Rc&lt;T, A&gt;
where
    T: Any,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>downcast_unchecked</code> <a href="https://github.com/rust-lang/rust/issues/90850">#90850</a>)</span>
</div></span></summary><div class="docblock">
<p>Downcasts the <code>Rc&lt;dyn Any&gt;</code> to a concrete type.</p> <p>For a safe alternative see <a href="struct.rc.html#method.downcast" title="method std::rc::Rc::downcast"><code>downcast</code></a>.</p> <h5 id="examples-37">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(downcast_unchecked)]

use std::any::Any;
use std::rc::Rc;

let x: Rc&lt;dyn Any&gt; = Rc::new(1_usize);

unsafe {
    assert_eq!(*x.downcast_unchecked::&lt;usize&gt;(), 1);
}</pre></div> <h5 id="safety-7">Safety</h5> <p>The contained value must be of type <code>T</code>. Calling this method with the incorrect type is <em>undefined behavior</em>.</p> </div>
</div>
</div>
<h2 id="trait-implementations" class="small-section-header">Trait Implementations</h2>
<div id="trait-implementations-list">
<summary><section id="impl-AsFd-for-Rc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.69.0">1.69.0</span><a class="src" href="https://doc.rust-lang.org/src/std/os/fd/owned.rs.html#407-412">source</a></span><pre class="code-header" data-language="rust">impl&lt;T: AsFd&gt; AsFd for Rc&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.as_fd" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/fd/owned.rs.html#409-411">source</a><pre class="code-header" data-language="rust">fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt;</pre></section></summary><div class="docblock">Borrows the file descriptor. <a href="../os/fd/trait.asfd.html#tymethod.as_fd">Read more</a>
</div>
</div>
<summary><section id="impl-AsHandle-for-Rc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.71.0">1.71.0</span><a class="src" href="https://doc.rust-lang.org/src/std/os/windows/io/handle.rs.html#461-466">source</a></span><pre class="code-header" data-language="rust">impl&lt;T: AsHandle&gt; AsHandle for Rc&lt;T&gt;Available on Windows only.</pre></section></summary><div class="impl-items">
<summary><section id="method.as_handle" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/windows/io/handle.rs.html#463-465">source</a><pre class="code-header" data-language="rust">fn as_handle(&amp;self) -&gt; BorrowedHandle&lt;'_&gt;</pre></section></summary><div class="docblock">Borrows the handle. <a href="../os/windows/io/trait.ashandle.html#tymethod.as_handle">Read more</a>
</div>
</div>
<summary><section id="impl-AsRawFd-for-Rc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.69.0">1.69.0</span><a class="src" href="https://doc.rust-lang.org/src/std/os/fd/raw.rs.html#261-266">source</a></span><pre class="code-header" data-language="rust">impl&lt;T: AsRawFd&gt; AsRawFd for Rc&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.as_raw_fd" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/fd/raw.rs.html#263-265">source</a><pre class="code-header" data-language="rust">fn as_raw_fd(&amp;self) -&gt; RawFd</pre></section></summary><div class="docblock">Extracts the raw file descriptor. <a href="../os/fd/trait.asrawfd.html#tymethod.as_raw_fd">Read more</a>
</div>
</div>
<summary><section id="impl-AsRef%3CT%3E-for-Rc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#3356">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; AsRef&lt;T&gt; for Rc&lt;T, A&gt;
where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#3357">source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsSocket-for-Rc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.71.0">1.71.0</span><a class="src" href="https://doc.rust-lang.org/src/std/os/windows/io/socket.rs.html#278-283">source</a></span><pre class="code-header" data-language="rust">impl&lt;T: AsSocket&gt; AsSocket for Rc&lt;T&gt;Available on Windows only.</pre></section></summary><div class="impl-items">
<summary><section id="method.as_socket" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/windows/io/socket.rs.html#280-282">source</a><pre class="code-header" data-language="rust">fn as_socket(&amp;self) -&gt; BorrowedSocket&lt;'_&gt;</pre></section></summary><div class="docblock">Borrows the socket.</div>
</div>
<summary><section id="impl-Borrow%3CT%3E-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#3349">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Borrow&lt;T&gt; for Rc&lt;T, A&gt;
where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#3350">source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="../borrow/trait.borrow.html#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-Clone-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2107">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Clone for Rc&lt;T, A&gt;
where
    A: Allocator + Clone,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2123">source</a><pre class="code-header" data-language="rust">fn clone(&amp;self) -&gt; Rc&lt;T, A&gt;</pre></section></summary><div class="docblock">
<p>Makes a clone of the <code>Rc</code> pointer.</p> <p>This creates another pointer to the same allocation, increasing the strong reference count.</p> <h5 id="examples-48">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);

let _ = Rc::clone(&amp;five);</pre></div> </div>
<summary><section id="method.clone_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/clone.rs.html#169">source</a><pre class="code-header" data-language="rust">fn clone_from(&amp;mut self, source: &amp;Self)</pre></section></summary><div class="docblock">Performs copy-assignment from <code>source</code>. <a href="../clone/trait.clone.html#method.clone_from">Read more</a>
</div>
</div>
<summary><section id="impl-Debug-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2377">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Debug for Rc&lt;T, A&gt;
where
    T: Debug + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2378">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="../fmt/trait.debug.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Default-for-Rc%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2133">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Default for Rc&lt;T&gt;
where
    T: Default,</pre></section></summary><div class="impl-items">
<summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2145">source</a><pre class="code-header" data-language="rust">fn default() -&gt; Rc&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Creates a new <code>Rc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.</p> <h5 id="examples-47">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let x: Rc&lt;i32&gt; = Default::default();
assert_eq!(*x, 0);</pre></div> </div>
</div>
<summary><section id="impl-Deref-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2048">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Deref for Rc&lt;T, A&gt;
where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Target" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Target = T</pre></section></summary><div class="docblock">The resulting type after dereferencing.</div>
<summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2052">source</a><pre class="code-header" data-language="rust">fn deref(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Dereferences the value.</div>
</div>
<summary><section id="impl-Display-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2370">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Display for Rc&lt;T, A&gt;
where
    T: Display + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2371">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="../fmt/trait.display.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Drop-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2061">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Drop for Rc&lt;T, A&gt;
where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2087">source</a><pre class="code-header" data-language="rust">fn drop(&amp;mut self)</pre></section></summary><div class="docblock">
<p>Drops the <code>Rc</code>.</p> <p>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are <a href="struct.weak.html" title="struct std::rc::Weak"><code>Weak</code></a>, so we <code>drop</code> the inner value.</p> <h5 id="examples-41">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

struct Foo;

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!("dropped!");
    }
}

let foo  = Rc::new(Foo);
let foo2 = Rc::clone(&amp;foo);

drop(foo);    // Doesn't print anything
drop(foo2);   // Prints "dropped!"</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26%5BT%5D%3E-for-Rc%3C%5BT%5D%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2434">source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;&amp;[T]&gt; for Rc&lt;[T]&gt;
where
    T: Clone,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2446">source</a><pre class="code-header" data-language="rust">fn from(v: &amp;[T]) -&gt; Rc&lt;[T]&gt;</pre></section></summary><div class="docblock">
<p>Allocate a reference-counted slice and fill it by cloning <code>v</code>â€™s items.</p> <h5 id="example-2">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let original: &amp;[i32] = &amp;[1, 2, 3];
let shared: Rc&lt;[i32]&gt; = Rc::from(original);
assert_eq!(&amp;[1, 2, 3], &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26CStr%3E-for-Rc%3CCStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/ffi/c_str.rs.html#900">source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;CStr&gt; for Rc&lt;CStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/ffi/c_str.rs.html#904">source</a><pre class="code-header" data-language="rust">fn from(s: &amp;CStr) -&gt; Rc&lt;CStr&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>&amp;CStr</code> into a <code>Rc&lt;CStr&gt;</code>, by copying the contents into a newly allocated <a href="struct.rc.html" title="struct std::rc::Rc"><code>Rc</code></a>.</p> </div>
</div>
<summary><section id="impl-From%3C%26OsStr%3E-for-Rc%3COsStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1183-1190">source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;OsStr&gt; for Rc&lt;OsStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-11" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1186-1189">source</a><pre class="code-header" data-language="rust">fn from(s: &amp;OsStr) -&gt; Rc&lt;OsStr&gt;</pre></section></summary><div class="docblock">
<p>Copies the string into a newly allocated <code><a href="struct.rc.html" title="struct std::rc::Rc">Rc</a>&lt;<a href="../ffi/struct.osstr.html" title="struct std::ffi::OsStr">OsStr</a>&gt;</code>.</p> </div>
</div>
<summary><section id="impl-From%3C%26Path%3E-for-Rc%3CPath%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1888-1895">source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;Path&gt; for Rc&lt;Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-12" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1891-1894">source</a><pre class="code-header" data-language="rust">fn from(s: &amp;Path) -&gt; Rc&lt;Path&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="../path/struct.path.html" title="struct std::path::Path"><code>Path</code></a> into an <a href="struct.rc.html" title="struct std::rc::Rc"><code>Rc</code></a> by copying the <a href="../path/struct.path.html" title="struct std::path::Path"><code>Path</code></a> data into a new <a href="struct.rc.html" title="struct std::rc::Rc"><code>Rc</code></a> buffer.</p> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Rc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2453">source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for Rc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2464">source</a><pre class="code-header" data-language="rust">fn from(v: &amp;str) -&gt; Rc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Allocate a reference-counted string slice and copy <code>v</code> into it.</p> <h5 id="example-4">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let shared: Rc&lt;str&gt; = Rc::from("statue");
assert_eq!("statue", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%5BT;+N%5D%3E-for-Rc%3C%5BT%5D%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.74.0">1.74.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2413">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, const N: usize&gt; From&lt;[T; N]&gt; for Rc&lt;[T]&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2427">source</a><pre class="code-header" data-language="rust">fn from(v: [T; N]) -&gt; Rc&lt;[T]&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="../primitive.array.html" title="primitive array"><code>[T; N]</code></a> into an <code>Rc&lt;[T]&gt;</code>.</p> <p>The conversion moves the array into a newly allocated <code>Rc</code>.</p> <h5 id="example-5">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let original: [i32; 3] = [1, 2, 3];
let shared: Rc&lt;[i32]&gt; = Rc::from(original);
assert_eq!(&amp;[1, 2, 3], &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3CBox%3CT,+A%3E%3E-for-Rc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2491">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; From&lt;Box&lt;T, A&gt;&gt; for Rc&lt;T, A&gt;
where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2503">source</a><pre class="code-header" data-language="rust">fn from(v: Box&lt;T, A&gt;) -&gt; Rc&lt;T, A&gt;</pre></section></summary><div class="docblock">
<p>Move a boxed object to a new, reference counted, allocation.</p> <h5 id="example-7">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let original: Box&lt;i32&gt; = Box::new(1);
let shared: Rc&lt;i32&gt; = Rc::from(original);
assert_eq!(1, *shared);</pre></div> </div>
</div>
<summary><section id="impl-From%3CCString%3E-for-Rc%3CCStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/ffi/c_str.rs.html#889">source</a></span><pre class="code-header" data-language="rust">impl From&lt;CString&gt; for Rc&lt;CStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/ffi/c_str.rs.html#893">source</a><pre class="code-header" data-language="rust">fn from(s: CString) -&gt; Rc&lt;CStr&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="../ffi/struct.cstring.html" title="struct std::ffi::CString"><code>CString</code></a> into an <code><a href="struct.rc.html" title="struct std::rc::Rc">Rc</a>&lt;<a href="../ffi/struct.cstr.html" title="struct std::ffi::CStr">CStr</a>&gt;</code> by moving the <a href="../ffi/struct.cstring.html" title="struct std::ffi::CString"><code>CString</code></a> data into a new <a href="struct.rc.html" title="struct std::rc::Rc"><code>Rc</code></a> buffer.</p> </div>
</div>
<summary><section id="impl-From%3CCow%3C'a,+B%3E%3E-for-Rc%3CB%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2539-2542">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, B&gt; From&lt;Cow&lt;'a, B&gt;&gt; for Rc&lt;B&gt;
where
    B: ToOwned + ?Sized,
    Rc&lt;B&gt;: From&lt;&amp;'a B&gt; + From&lt;&lt;B as ToOwned&gt;::Owned&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2557">source</a><pre class="code-header" data-language="rust">fn from(cow: Cow&lt;'a, B&gt;) -&gt; Rc&lt;B&gt;</pre></section></summary><div class="docblock">
<p>Create a reference-counted pointer from a clone-on-write pointer by copying its content.</p> <h5 id="example-8">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let cow: Cow&lt;'_, str&gt; = Cow::Borrowed("eggplant");
let shared: Rc&lt;str&gt; = Rc::from(cow);
assert_eq!("eggplant", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3COsString%3E-for-Rc%3COsStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1172-1180">source</a></span><pre class="code-header" data-language="rust">impl From&lt;OsString&gt; for Rc&lt;OsStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-14" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1176-1179">source</a><pre class="code-header" data-language="rust">fn from(s: OsString) -&gt; Rc&lt;OsStr&gt;</pre></section></summary><div class="docblock">
<p>Converts an <a href="../ffi/struct.osstring.html" title="struct std::ffi::OsString"><code>OsString</code></a> into an <code><a href="struct.rc.html" title="struct std::rc::Rc">Rc</a>&lt;<a href="../ffi/struct.osstr.html" title="struct std::ffi::OsStr">OsStr</a>&gt;</code> by moving the <a href="../ffi/struct.osstring.html" title="struct std::ffi::OsString"><code>OsString</code></a> data into a new <a href="struct.rc.html" title="struct std::rc::Rc"><code>Rc</code></a> buffer.</p> </div>
</div>
<summary><section id="impl-From%3CPathBuf%3E-for-Rc%3CPath%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1877-1885">source</a></span><pre class="code-header" data-language="rust">impl From&lt;PathBuf&gt; for Rc&lt;Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-13" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1881-1884">source</a><pre class="code-header" data-language="rust">fn from(s: PathBuf) -&gt; Rc&lt;Path&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="../path/struct.pathbuf.html" title="struct std::path::PathBuf"><code>PathBuf</code></a> into an <code><a href="struct.rc.html" title="struct std::rc::Rc">Rc</a>&lt;<a href="../path/struct.path.html" title="struct std::path::Path">Path</a>&gt;</code> by moving the <a href="../path/struct.pathbuf.html" title="struct std::path::PathBuf"><code>PathBuf</code></a> data into a new <a href="struct.rc.html" title="struct std::rc::Rc"><code>Rc</code></a> buffer.</p> </div>
</div>
<summary><section id="impl-From%3CRc%3Cstr%3E%3E-for-Rc%3C%5Bu8%5D%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.62.0">1.62.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2566">source</a></span><pre class="code-header" data-language="rust">impl From&lt;Rc&lt;str&gt;&gt; for Rc&lt;[u8]&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2578">source</a><pre class="code-header" data-language="rust">fn from(rc: Rc&lt;str&gt;) -&gt; Rc&lt;[u8]&gt;</pre></section></summary><div class="docblock">
<p>Converts a reference-counted string slice into a byte slice.</p> <h5 id="example-6">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let string: Rc&lt;str&gt; = Rc::from("eggplant");
let bytes: Rc&lt;[u8]&gt; = Rc::from(string);
assert_eq!("eggplant".as_bytes(), bytes.as_ref());</pre></div> </div>
</div>
<summary><section id="impl-From%3CString%3E-for-Rc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2472">source</a></span><pre class="code-header" data-language="rust">impl From&lt;String&gt; for Rc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2484">source</a><pre class="code-header" data-language="rust">fn from(v: String) -&gt; Rc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Allocate a reference-counted string slice and copy <code>v</code> into it.</p> <h5 id="example">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let original: String = "statue".to_owned();
let shared: Rc&lt;str&gt; = Rc::from(original);
assert_eq!("statue", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3CT%3E-for-Rc%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2392">source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;T&gt; for Rc&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2406">source</a><pre class="code-header" data-language="rust">fn from(t: T) -&gt; Rc&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Converts a generic type <code>T</code> into an <code>Rc&lt;T&gt;</code></p> <p>The conversion allocates on the heap and moves <code>t</code> from the stack into it.</p> <h5 id="example-3">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 5;
let rc = Rc::new(5);

assert_eq!(Rc::from(x), rc);</pre></div> </div>
</div>
<summary><section id="impl-From%3CVec%3CT,+A%3E%3E-for-Rc%3C%5BT%5D,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2510">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; From&lt;Vec&lt;T, A&gt;&gt; for Rc&lt;[T], A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2522">source</a><pre class="code-header" data-language="rust">fn from(v: Vec&lt;T, A&gt;) -&gt; Rc&lt;[T], A&gt;</pre></section></summary><div class="docblock">
<p>Allocate a reference-counted slice and move <code>v</code>â€™s items into it.</p> <h5 id="example-1">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let unique: Vec&lt;i32&gt; = vec![1, 2, 3];
let shared: Rc&lt;[i32]&gt; = Rc::from(unique);
assert_eq!(&amp;[1, 2, 3], &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-FromIterator%3CT%3E-for-Rc%3C%5BT%5D%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.37.0">1.37.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2599">source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; FromIterator&lt;T&gt; for Rc&lt;[T]&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2638">source</a><pre class="code-header" data-language="rust">fn from_iter&lt;I&gt;(iter: I) -&gt; Rc&lt;[T]&gt;
where
    I: IntoIterator&lt;Item = T&gt;,</pre></section></summary><div class="docblock">
<p>Takes each element in the <code>Iterator</code> and collects it into an <code>Rc&lt;[T]&gt;</code>.</p> <h5 id="performance-characteristics">Performance characteristics</h5>
<h6 id="the-general-case"><a href="#the-general-case">The general case</a></h6> <p>In the general case, collecting into <code>Rc&lt;[T]&gt;</code> is done by first collecting into a <code>Vec&lt;T&gt;</code>. That is, when writing the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let evens: Rc&lt;[u8]&gt; = (0..10).filter(|&amp;x| x % 2 == 0).collect();</pre></div> <p>this behaves as if we wrote:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let evens: Rc&lt;[u8]&gt; = (0..10).filter(|&amp;x| x % 2 == 0)
    .collect::&lt;Vec&lt;_&gt;&gt;() // The first set of allocations happens here.
    .into(); // A second allocation for `Rc&lt;[T]&gt;` happens here.</pre></div> <p>This will allocate as many times as needed for constructing the <code>Vec&lt;T&gt;</code> and then it will allocate once for turning the <code>Vec&lt;T&gt;</code> into the <code>Rc&lt;[T]&gt;</code>.</p> <h6 id="iterators-of-known-length"><a href="#iterators-of-known-length">Iterators of known length</a></h6> <p>When your <code>Iterator</code> implements <code>TrustedLen</code> and is of an exact size, a single allocation will be made for the <code>Rc&lt;[T]&gt;</code>. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let evens: Rc&lt;[u8]&gt; = (0..10).collect(); // Just a single allocation happens here.</pre></div> </div>
</div>
<summary><section id="impl-Hash-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2363">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Hash for Rc&lt;T, A&gt;
where
    T: Hash + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2364">source</a><pre class="code-header" data-language="rust">fn hash&lt;H&gt;(&amp;self, state: &amp;mut H)
where
    H: Hasher,</pre></section></summary><div class="docblock">Feeds this value into the given <a href="../hash/trait.hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="../hash/trait.hash.html#tymethod.hash">Read more</a>
</div>
<summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="src" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#242-244">source</a></span><pre class="code-header" data-language="rust">fn hash_slice&lt;H&gt;(data: &amp;[Self], state: &amp;mut H)
where
    H: Hasher,
    Self: Sized,</pre></section></summary><div class="docblock">Feeds a slice of this type into the given <a href="../hash/trait.hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="../hash/trait.hash.html#method.hash_slice">Read more</a>
</div>
</div>
<summary><section id="impl-Ord-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2341">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Ord for Rc&lt;T, A&gt;
where
    T: Ord + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2357">source</a><pre class="code-header" data-language="rust">fn cmp(&amp;self, other: &amp;Rc&lt;T, A&gt;) -&gt; Ordering</pre></section></summary><div class="docblock">
<p>Comparison for two <code>Rc</code>s.</p> <p>The two are compared by calling <code>cmp()</code> on their inner values.</p> <h5 id="examples-38">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;
use std::cmp::Ordering;

let five = Rc::new(5);

assert_eq!(Ordering::Less, five.cmp(&amp;Rc::new(6)));</pre></div> </div>
<summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#826-828">source</a></span><pre class="code-header" data-language="rust">fn max(self, other: Self) -&gt; Self
where
    Self: Sized,</pre></section></summary><div class="docblock">Compares and returns the maximum of two values. <a href="../cmp/trait.ord.html#method.max">Read more</a>
</div>
<summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#846-848">source</a></span><pre class="code-header" data-language="rust">fn min(self, other: Self) -&gt; Self
where
    Self: Sized,</pre></section></summary><div class="docblock">Compares and returns the minimum of two values. <a href="../cmp/trait.ord.html#method.min">Read more</a>
</div>
<summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#871-874">source</a></span><pre class="code-header" data-language="rust">fn clamp(self, min: Self, max: Self) -&gt; Self
where
    Self: Sized + PartialOrd,</pre></section></summary><div class="docblock">Restrict a value to a certain interval. <a href="../cmp/trait.ord.html#method.clamp">Read more</a>
</div>
</div>
<summary><section id="impl-PartialEq-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2196">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; PartialEq for Rc&lt;T, A&gt;
where
    T: PartialEq + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2216">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;Rc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>Equality for two <code>Rc</code>s.</p> <p>Two <code>Rc</code>s are equal if their inner values are equal, even if they are stored in different allocation.</p> <p>If <code>T</code> also implements <code>Eq</code> (implying reflexivity of equality), two <code>Rc</code>s that point to the same allocation are always equal.</p> <h5 id="examples-39">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);

assert!(five == Rc::new(5));</pre></div> </div>
<summary><section id="method.ne" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2238">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>Inequality for two <code>Rc</code>s.</p> <p>Two <code>Rc</code>s are not equal if their inner values are not equal.</p> <p>If <code>T</code> also implements <code>Eq</code> (implying reflexivity of equality), two <code>Rc</code>s that point to the same allocation are always equal.</p> <h5 id="examples-40">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);

assert!(five != Rc::new(6));</pre></div> </div>
</div>
<summary><section id="impl-PartialOrd-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2247">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; PartialOrd for Rc&lt;T, A&gt;
where
    T: PartialOrd + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2263">source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;Rc&lt;T, A&gt;) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">
<p>Partial comparison for two <code>Rc</code>s.</p> <p>The two are compared by calling <code>partial_cmp()</code> on their inner values.</p> <h5 id="examples-42">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;
use std::cmp::Ordering;

let five = Rc::new(5);

assert_eq!(Some(Ordering::Less), five.partial_cmp(&amp;Rc::new(6)));</pre></div> </div>
<summary><section id="method.lt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2281">source</a><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>Less-than comparison for two <code>Rc</code>s.</p> <p>The two are compared by calling <code>&lt;</code> on their inner values.</p> <h5 id="examples-43">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);

assert!(five &lt; Rc::new(6));</pre></div> </div>
<summary><section id="method.le" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2299">source</a><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>â€˜Less than or equal toâ€™ comparison for two <code>Rc</code>s.</p> <p>The two are compared by calling <code>&lt;=</code> on their inner values.</p> <h5 id="examples-44">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);

assert!(five &lt;= Rc::new(5));</pre></div> </div>
<summary><section id="method.gt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2317">source</a><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>Greater-than comparison for two <code>Rc</code>s.</p> <p>The two are compared by calling <code>&gt;</code> on their inner values.</p> <h5 id="examples-45">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);

assert!(five &gt; Rc::new(4));</pre></div> </div>
<summary><section id="method.ge" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2335">source</a><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rc&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">
<p>â€˜Greater than or equal toâ€™ comparison for two <code>Rc</code>s.</p> <p>The two are compared by calling <code>&gt;=</code> on their inner values.</p> <h5 id="examples-46">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::rc::Rc;

let five = Rc::new(5);

assert!(five &gt;= Rc::new(5));</pre></div> </div>
</div>
<summary><section id="impl-Pointer-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2384">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Pointer for Rc&lt;T, A&gt;
where
    A: Allocator,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2385">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter.</div>
</div>
<summary><section id="impl-TryFrom%3CRc%3C%5BT%5D%3E%3E-for-Rc%3C%5BT;+N%5D%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2585">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, const N: usize&gt; TryFrom&lt;Rc&lt;[T]&gt;&gt; for Rc&lt;[T; N]&gt;</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Error = Rc&lt;[T]&gt;</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2588">source</a><pre class="code-header" data-language="rust">fn try_from(
    boxed_slice: Rc&lt;[T]&gt;
) -&gt; Result&lt;Rc&lt;[T; N]&gt;, &lt;Rc&lt;[T; N]&gt; as TryFrom&lt;Rc&lt;[T]&gt;&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
<section id="impl-CoerceUnsized%3CRc%3CU,+A%3E%3E-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#342">source</a><pre class="code-header" data-language="rust">impl&lt;T, U, A&gt; CoerceUnsized&lt;Rc&lt;U, A&gt;&gt; for Rc&lt;T, A&gt;
where
    T: Unsize&lt;U&gt; + ?Sized,
    A: Allocator,
    U: ?Sized,</pre></section><section id="impl-DispatchFromDyn%3CRc%3CU%3E%3E-for-Rc%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#345">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; DispatchFromDyn&lt;Rc&lt;U&gt;&gt; for Rc&lt;T&gt;
where
    T: Unsize&lt;U&gt; + ?Sized,
    U: ?Sized,</pre></section><section id="impl-Eq-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2244">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Eq for Rc&lt;T, A&gt;
where
    T: Eq + ?Sized,
    A: Allocator,</pre></section><section id="impl-RefUnwindSafe-for-Rc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.58.0">1.58.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#339">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; RefUnwindSafe for Rc&lt;T, A&gt;
where
    T: RefUnwindSafe + ?Sized,
    A: Allocator + UnwindSafe,</pre></section><section id="impl-Send-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#326">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; !Send for Rc&lt;T, A&gt;
where
    A: Allocator,
    T: ?Sized,</pre></section><section id="impl-Sync-for-Rc%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#334">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; !Sync for Rc&lt;T, A&gt;
where
    A: Allocator,
    T: ?Sized,</pre></section><section id="impl-Unpin-for-Rc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.33.0">1.33.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#3363">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Unpin for Rc&lt;T, A&gt;
where
    A: Allocator,
    T: ?Sized,</pre></section><section id="impl-UnwindSafe-for-Rc%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#337">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; UnwindSafe for Rc&lt;T, A&gt;
where
    T: RefUnwindSafe + ?Sized,
    A: Allocator + UnwindSafe,</pre></section>
</div>
<h2 id="blanket-implementations" class="small-section-header">Blanket Implementations</h2>
<div id="blanket-implementations-list">
<summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#135">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Any for T
where
    T: 'static + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#136">source</a><pre class="code-header" data-language="rust">fn type_id(&amp;self) -&gt; TypeId</pre></section></summary><div class="docblock">Gets the <code>TypeId</code> of <code>self</code>. <a href="../any/trait.any.html#tymethod.type_id">Read more</a>
</div>
</div>
<summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#208">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Borrow&lt;T&gt; for T
where
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#210">source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="../borrow/trait.borrow.html#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#216">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; BorrowMut&lt;T&gt; for T
where
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217">source</a><pre class="code-header" data-language="rust">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</pre></section></summary><div class="docblock">Mutably borrows from an owned value. <a href="../borrow/trait.borrowmut.html#tymethod.borrow_mut">Read more</a>
</div>
</div>
<summary><section id="impl-From%3C!%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#780">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;!&gt; for T</pre></section></summary><div class="impl-items">
<summary><section id="method.from-15" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#781">source</a><pre class="code-header" data-language="rust">fn from(t: !) -&gt; T</pre></section></summary><div class="docblock">Converts to this type from the input type.</div>
</div>
<summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#763">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;T&gt; for T</pre></section></summary><div class="impl-items">
<summary><section id="method.from-16" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#766">source</a><pre class="code-header" data-language="rust">fn from(t: T) -&gt; T</pre></section></summary><div class="docblock">
<p>Returns the argument unchanged.</p> </div>
</div>
<summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#747-749">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#756">source</a><pre class="code-header" data-language="rust">fn into(self) -&gt; U</pre></section></summary><div class="docblock">
<p>Calls <code>U::from(self)</code>.</p> <p>That is, this conversion is whatever the implementation of <code><a href="../convert/trait.from.html" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p> </div>
</div>
<summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#83-85">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; ToOwned for T
where
    T: Clone,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Owned = T</pre></section></summary><div class="docblock">The resulting type after obtaining ownership.</div>
<summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#88">source</a><pre class="code-header" data-language="rust">fn to_owned(&amp;self) -&gt; T</pre></section></summary><div class="docblock">Creates owned data from borrowed data, usually by cloning. <a href="../borrow/trait.toowned.html#tymethod.to_owned">Read more</a>
</div>
<summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#92">source</a><pre class="code-header" data-language="rust">fn clone_into(&amp;self, target: &amp;mut T)</pre></section></summary><div class="docblock">Uses borrowed data to replace owned data, usually by cloning. <a href="../borrow/trait.toowned.html#method.clone_into">Read more</a>
</div>
</div>
<summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2600">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; ToString for T
where
    T: Display + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2606">source</a><pre class="code-header" data-language="rust">default fn to_string(&amp;self) -&gt; String</pre></section></summary><div class="docblock">Converts the given value to a <code>String</code>. <a href="../string/trait.tostring.html#tymethod.to_string">Read more</a>
</div>
</div>
<summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#803-805">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T
where
    U: Into&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error-2" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Error = Infallible</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#810">source</a><pre class="code-header" data-language="rust">fn try_from(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
<summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#788-790">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryInto&lt;U&gt; for T
where
    U: TryFrom&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Error = &lt;U as TryFrom&lt;T&gt;&gt;::Error</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#795">source</a><pre class="code-header" data-language="rust">fn try_into(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html" class="_attribution-link">https://doc.rust-lang.org/std/rc/struct.Rc.html</a>
  </p>
</div>
