<h1 class="main-heading">Struct std::collections::vec_deque::VecDeque</h1>
<pre class="rust item-decl" data-language="rust">pub struct VecDeque&lt;T, A = Global&gt;
where
    A: Allocator,{ /* private fields */ }</pre>
<p>A double-ended queue implemented with a growable ring buffer.</p> <p>The ‚Äúdefault‚Äù usage of this type as a queue is to use <a href="../struct.vecdeque.html#method.push_back" title="method std::collections::VecDeque::push_back"><code>push_back</code></a> to add to the queue, and <a href="../struct.vecdeque.html#method.pop_front" title="method std::collections::VecDeque::pop_front"><code>pop_front</code></a> to remove from the queue. <a href="../struct.vecdeque.html#method.extend" title="method std::collections::VecDeque::extend"><code>extend</code></a> and <a href="../struct.vecdeque.html#method.append" title="method std::collections::VecDeque::append"><code>append</code></a> push onto the back in this manner, and iterating over <code>VecDeque</code> goes front to back.</p> <p>A <code>VecDeque</code> with a known list of items can be initialized from an array:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let deq = VecDeque::from([-1, 0, 1]);</pre></div> <p>Since <code>VecDeque</code> is a ring buffer, its elements are not necessarily contiguous in memory. If you want to access the elements as a single slice, such as for efficient sorting, you can use <a href="../struct.vecdeque.html#method.make_contiguous" title="method std::collections::VecDeque::make_contiguous"><code>make_contiguous</code></a>. It rotates the <code>VecDeque</code> so that its elements do not wrap, and returns a mutable slice to the now-contiguous element sequence.</p> <h2 id="implementations" class="small-section-header">Implementations</h2>
<div id="implementations-list">
<summary><section id="impl-VecDeque%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#528">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; VecDeque&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.new" class="method"><span class="rightside"><span class="since" title="const since 1.68.0">const: 1.68.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#542">source</a></span><pre class="code-header" data-language="rust">pub const fn new() -&gt; VecDeque&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Creates an empty deque.</p> <h5 id="examples">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let deque: VecDeque&lt;u32&gt; = VecDeque::new();</pre></div> </div>
<summary><section id="method.with_capacity" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#559">source</a><pre class="code-header" data-language="rust">pub fn with_capacity(capacity: usize) -&gt; VecDeque&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Creates an empty deque with space for at least <code>capacity</code> elements.</p> <h5 id="examples-1">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let deque: VecDeque&lt;u32&gt; = VecDeque::with_capacity(10);</pre></div> </div>
</div>
<summary><section id="impl-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#564">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; VecDeque&lt;T, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.new_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#576">source</a><pre class="code-header" data-language="rust">pub const fn new_in(alloc: A) -&gt; VecDeque&lt;T, A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Creates an empty deque.</p> <h5 id="examples-2">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let deque: VecDeque&lt;u32&gt; = VecDeque::new();</pre></div> </div>
<summary><section id="method.with_capacity_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#590">source</a><pre class="code-header" data-language="rust">pub fn with_capacity_in(capacity: usize, alloc: A) -&gt; VecDeque&lt;T, A&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Creates an empty deque with space for at least <code>capacity</code> elements.</p> <h5 id="examples-3">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let deque: VecDeque&lt;u32&gt; = VecDeque::with_capacity(10);</pre></div> </div>
<summary><section id="method.get" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#643">source</a><pre class="code-header" data-language="rust">pub fn get(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt;</pre></section></summary><div class="docblock">
<p>Provides a reference to the element at the given index.</p> <p>Element at index 0 is the front of the queue.</p> <h5 id="examples-4">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.push_back(3);
buf.push_back(4);
buf.push_back(5);
buf.push_back(6);
assert_eq!(buf.get(1), Some(&amp;4));</pre></div> </div>
<summary><section id="method.get_mut" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#673">source</a><pre class="code-header" data-language="rust">pub fn get_mut(&amp;mut self, index: usize) -&gt; Option&lt;&amp;mut T&gt;</pre></section></summary><div class="docblock">
<p>Provides a mutable reference to the element at the given index.</p> <p>Element at index 0 is the front of the queue.</p> <h5 id="examples-5">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.push_back(3);
buf.push_back(4);
buf.push_back(5);
buf.push_back(6);
assert_eq!(buf[1], 4);
if let Some(elem) = buf.get_mut(1) {
    *elem = 7;
}
assert_eq!(buf[1], 7);</pre></div> </div>
<summary><section id="method.swap" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#706">source</a><pre class="code-header" data-language="rust">pub fn swap(&amp;mut self, i: usize, j: usize)</pre></section></summary><div class="docblock">
<p>Swaps elements at indices <code>i</code> and <code>j</code>.</p> <p><code>i</code> and <code>j</code> may be equal.</p> <p>Element at index 0 is the front of the queue.</p> <h5 id="panics">Panics</h5> <p>Panics if either index is out of bounds.</p> <h5 id="examples-6">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.push_back(3);
buf.push_back(4);
buf.push_back(5);
assert_eq!(buf, [3, 4, 5]);
buf.swap(0, 2);
assert_eq!(buf, [5, 4, 3]);</pre></div> </div>
<summary><section id="method.capacity" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#727">source</a><pre class="code-header" data-language="rust">pub fn capacity(&amp;self) -&gt; usize</pre></section></summary><div class="docblock">
<p>Returns the number of elements the deque can hold without reallocating.</p> <h5 id="examples-7">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let buf: VecDeque&lt;i32&gt; = VecDeque::with_capacity(10);
assert!(buf.capacity() &gt;= 10);</pre></div> </div>
<summary><section id="method.reserve_exact" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#754">source</a><pre class="code-header" data-language="rust">pub fn reserve_exact(&amp;mut self, additional: usize)</pre></section></summary><div class="docblock">
<p>Reserves the minimum capacity for at least <code>additional</code> more elements to be inserted in the given deque. Does nothing if the capacity is already sufficient.</p> <p>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer <a href="../struct.vecdeque.html#method.reserve" title="method std::collections::VecDeque::reserve"><code>reserve</code></a> if future insertions are expected.</p> <h5 id="panics-1">Panics</h5> <p>Panics if the new capacity overflows <code>usize</code>.</p> <h5 id="examples-8">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf: VecDeque&lt;i32&gt; = [1].into();
buf.reserve_exact(10);
assert!(buf.capacity() &gt;= 11);</pre></div> </div>
<summary><section id="method.reserve" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#783">source</a><pre class="code-header" data-language="rust">pub fn reserve(&amp;mut self, additional: usize)</pre></section></summary><div class="docblock">
<p>Reserves capacity for at least <code>additional</code> more elements to be inserted in the given deque. The collection may reserve more space to speculatively avoid frequent reallocations.</p> <h5 id="panics-2">Panics</h5> <p>Panics if the new capacity overflows <code>usize</code>.</p> <h5 id="examples-9">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf: VecDeque&lt;i32&gt; = [1].into();
buf.reserve(10);
assert!(buf.capacity() &gt;= 11);</pre></div> </div>
<summary><section id="method.try_reserve_exact" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.57.0">1.57.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#835">source</a></span><pre class="code-header" data-language="rust">pub fn try_reserve_exact(
    &amp;mut self,
    additional: usize
) -&gt; Result&lt;(), TryReserveError&gt;</pre></section></summary><div class="docblock">
<p>Tries to reserve the minimum capacity for at least <code>additional</code> more elements to be inserted in the given deque. After calling <code>try_reserve_exact</code>, capacity will be greater than or equal to <code>self.len() + additional</code> if it returns <code>Ok(())</code>. Does nothing if the capacity is already sufficient.</p> <p>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer <a href="../struct.vecdeque.html#method.try_reserve" title="method std::collections::VecDeque::try_reserve"><code>try_reserve</code></a> if future insertions are expected.</p> <h5 id="errors">Errors</h5> <p>If the capacity overflows <code>usize</code>, or the allocator reports a failure, then an error is returned.</p> <h5 id="examples-10">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::TryReserveError;
use std::collections::VecDeque;

fn process_data(data: &amp;[u32]) -&gt; Result&lt;VecDeque&lt;u32&gt;, TryReserveError&gt; {
    let mut output = VecDeque::new();

    // Pre-reserve the memory, exiting if we can't
    output.try_reserve_exact(data.len())?;

    // Now we know this can't OOM(Out-Of-Memory) in the middle of our complex work
    output.extend(data.iter().map(|&amp;val| {
        val * 2 + 5 // very complicated
    }));

    Ok(output)
}</pre></div> </div>
<summary><section id="method.try_reserve" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.57.0">1.57.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#883">source</a></span><pre class="code-header" data-language="rust">pub fn try_reserve(&amp;mut self, additional: usize) -&gt; Result&lt;(), TryReserveError&gt;</pre></section></summary><div class="docblock">
<p>Tries to reserve capacity for at least <code>additional</code> more elements to be inserted in the given deque. The collection may reserve more space to speculatively avoid frequent reallocations. After calling <code>try_reserve</code>, capacity will be greater than or equal to <code>self.len() + additional</code> if it returns <code>Ok(())</code>. Does nothing if capacity is already sufficient. This method preserves the contents even if an error occurs.</p> <h5 id="errors-1">Errors</h5> <p>If the capacity overflows <code>usize</code>, or the allocator reports a failure, then an error is returned.</p> <h5 id="examples-11">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::TryReserveError;
use std::collections::VecDeque;

fn process_data(data: &amp;[u32]) -&gt; Result&lt;VecDeque&lt;u32&gt;, TryReserveError&gt; {
    let mut output = VecDeque::new();

    // Pre-reserve the memory, exiting if we can't
    output.try_reserve(data.len())?;

    // Now we know this can't OOM in the middle of our complex work
    output.extend(data.iter().map(|&amp;val| {
        val * 2 + 5 // very complicated
    }));

    Ok(output)
}</pre></div> </div>
<summary><section id="method.shrink_to_fit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#914">source</a></span><pre class="code-header" data-language="rust">pub fn shrink_to_fit(&amp;mut self)</pre></section></summary><div class="docblock">
<p>Shrinks the capacity of the deque as much as possible.</p> <p>It will drop down as close as possible to the length but the allocator may still inform the deque that there is space for a few more elements.</p> <h5 id="examples-12">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::with_capacity(15);
buf.extend(0..4);
assert_eq!(buf.capacity(), 15);
buf.shrink_to_fit();
assert!(buf.capacity() &gt;= 4);</pre></div> </div>
<summary><section id="method.shrink_to" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.56.0">1.56.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#939">source</a></span><pre class="code-header" data-language="rust">pub fn shrink_to(&amp;mut self, min_capacity: usize)</pre></section></summary><div class="docblock">
<p>Shrinks the capacity of the deque with a lower bound.</p> <p>The capacity will remain at least as large as both the length and the supplied value.</p> <p>If the current capacity is less than the lower limit, this is a no-op.</p> <h5 id="examples-13">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::with_capacity(15);
buf.extend(0..4);
assert_eq!(buf.capacity(), 15);
buf.shrink_to(6);
assert!(buf.capacity() &gt;= 6);
buf.shrink_to(0);
assert!(buf.capacity() &gt;= 4);</pre></div> </div>
<summary><section id="method.truncate" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1035">source</a></span><pre class="code-header" data-language="rust">pub fn truncate(&amp;mut self, len: usize)</pre></section></summary><div class="docblock">
<p>Shortens the deque, keeping the first <code>len</code> elements and dropping the rest.</p> <p>If <code>len</code> is greater or equal to the deque‚Äôs current length, this has no effect.</p> <h5 id="examples-14">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.push_back(5);
buf.push_back(10);
buf.push_back(15);
assert_eq!(buf, [5, 10, 15]);
buf.truncate(1);
assert_eq!(buf, [5]);</pre></div> </div>
<summary><section id="method.allocator" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1082">source</a><pre class="code-header" data-language="rust">pub fn allocator(&amp;self) -&gt; &amp;A</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>allocator_api</code> <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns a reference to the underlying allocator.</p> </div>
<summary><section id="method.iter" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1102">source</a><pre class="code-header" data-language="rust">pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; ‚ìò</pre></section></summary><div class="docblock">
<p>Returns a front-to-back iterator.</p> <h5 id="examples-15">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.push_back(5);
buf.push_back(3);
buf.push_back(4);
let b: &amp;[_] = &amp;[&amp;5, &amp;3, &amp;4];
let c: Vec&lt;&amp;i32&gt; = buf.iter().collect();
assert_eq!(&amp;c[..], b);</pre></div> </div>
<summary><section id="method.iter_mut" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1125">source</a><pre class="code-header" data-language="rust">pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; ‚ìò</pre></section></summary><div class="docblock">
<p>Returns a front-to-back iterator that returns mutable references.</p> <h5 id="examples-16">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.push_back(5);
buf.push_back(3);
buf.push_back(4);
for num in buf.iter_mut() {
    *num = *num - 2;
}
let b: &amp;[_] = &amp;[&amp;mut 3, &amp;mut 1, &amp;mut 2];
assert_eq!(&amp;buf.iter_mut().collect::&lt;Vec&lt;&amp;mut i32&gt;&gt;()[..], b);</pre></div> </div>
<summary><section id="method.as_slices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1158">source</a></span><pre class="code-header" data-language="rust">pub fn as_slices(&amp;self) -&gt; (&amp;[T], &amp;[T])</pre></section></summary><div class="docblock">
<p>Returns a pair of slices which contain, in order, the contents of the deque.</p> <p>If <a href="../struct.vecdeque.html#method.make_contiguous" title="method std::collections::VecDeque::make_contiguous"><code>make_contiguous</code></a> was previously called, all elements of the deque will be in the first slice and the second slice will be empty.</p> <h5 id="examples-17">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut deque = VecDeque::new();

deque.push_back(0);
deque.push_back(1);
deque.push_back(2);

assert_eq!(deque.as_slices(), (&amp;[0, 1, 2][..], &amp;[][..]));

deque.push_front(10);
deque.push_front(9);

assert_eq!(deque.as_slices(), (&amp;[9, 10][..], &amp;[0, 1, 2][..]));</pre></div> </div>
<summary><section id="method.as_mut_slices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1192">source</a></span><pre class="code-header" data-language="rust">pub fn as_mut_slices(&amp;mut self) -&gt; (&amp;mut [T], &amp;mut [T])</pre></section></summary><div class="docblock">
<p>Returns a pair of slices which contain, in order, the contents of the deque.</p> <p>If <a href="../struct.vecdeque.html#method.make_contiguous" title="method std::collections::VecDeque::make_contiguous"><code>make_contiguous</code></a> was previously called, all elements of the deque will be in the first slice and the second slice will be empty.</p> <h5 id="examples-18">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut deque = VecDeque::new();

deque.push_back(0);
deque.push_back(1);

deque.push_front(10);
deque.push_front(9);

deque.as_mut_slices().0[0] = 42;
deque.as_mut_slices().1[0] = 24;
assert_eq!(deque.as_slices(), (&amp;[42, 10][..], &amp;[24, 1][..]));</pre></div> </div>
<summary><section id="method.len" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1212">source</a><pre class="code-header" data-language="rust">pub fn len(&amp;self) -&gt; usize</pre></section></summary><div class="docblock">
<p>Returns the number of elements in the deque.</p> <h5 id="examples-19">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut deque = VecDeque::new();
assert_eq!(deque.len(), 0);
deque.push_back(1);
assert_eq!(deque.len(), 1);</pre></div> </div>
<summary><section id="method.is_empty" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1229">source</a><pre class="code-header" data-language="rust">pub fn is_empty(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the deque is empty.</p> <h5 id="examples-20">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut deque = VecDeque::new();
assert!(deque.is_empty());
deque.push_front(1);
assert!(!deque.is_empty());</pre></div> </div>
<summary><section id="method.range" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1298-1300">source</a></span><pre class="code-header" data-language="rust">pub fn range&lt;R&gt;(&amp;self, range: R) -&gt; Iter&lt;'_, T&gt; ‚ìò
where
    R: RangeBounds&lt;usize&gt;,</pre></section></summary><div class="docblock">
<p>Creates an iterator that covers the specified range in the deque.</p> <h5 id="panics-3">Panics</h5> <p>Panics if the starting point is greater than the end point or if the end point is greater than the length of the deque.</p> <h5 id="examples-21">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let deque: VecDeque&lt;_&gt; = [1, 2, 3].into();
let range = deque.range(2..).copied().collect::&lt;VecDeque&lt;_&gt;&gt;();
assert_eq!(range, [3]);

// A full range covers all contents
let all = deque.range(..);
assert_eq!(all.len(), 3);</pre></div> </div>
<summary><section id="method.range_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1338-1340">source</a></span><pre class="code-header" data-language="rust">pub fn range_mut&lt;R&gt;(&amp;mut self, range: R) -&gt; IterMut&lt;'_, T&gt; ‚ìò
where
    R: RangeBounds&lt;usize&gt;,</pre></section></summary><div class="docblock">
<p>Creates an iterator that covers the specified mutable range in the deque.</p> <h5 id="panics-4">Panics</h5> <p>Panics if the starting point is greater than the end point or if the end point is greater than the length of the deque.</p> <h5 id="examples-22">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut deque: VecDeque&lt;_&gt; = [1, 2, 3].into();
for v in deque.range_mut(2..) {
  *v *= 2;
}
assert_eq!(deque, [1, 2, 6]);

// A full range covers all contents
for v in deque.range_mut(..) {
  *v *= 2;
}
assert_eq!(deque, [2, 4, 12]);</pre></div> </div>
<summary><section id="method.drain" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1387-1389">source</a></span><pre class="code-header" data-language="rust">pub fn drain&lt;R&gt;(&amp;mut self, range: R) -&gt; Drain&lt;'_, T, A&gt; ‚ìò
where
    R: RangeBounds&lt;usize&gt;,</pre></section></summary><div class="docblock">
<p>Removes the specified range from the deque in bulk, returning all removed elements as an iterator. If the iterator is dropped before being fully consumed, it drops the remaining removed elements.</p> <p>The returned iterator keeps a mutable borrow on the queue to optimize its implementation.</p> <h5 id="panics-5">Panics</h5> <p>Panics if the starting point is greater than the end point or if the end point is greater than the length of the deque.</p> <h5 id="leaking">Leaking</h5> <p>If the returned iterator goes out of scope without being dropped (due to <a href="../../mem/fn.forget.html" title="fn std::mem::forget"><code>mem::forget</code></a>, for example), the deque may have lost and leaked elements arbitrarily, including elements outside the range.</p> <h5 id="examples-23">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut deque: VecDeque&lt;_&gt; = [1, 2, 3].into();
let drained = deque.drain(2..).collect::&lt;VecDeque&lt;_&gt;&gt;();
assert_eq!(drained, [3]);
assert_eq!(deque, [1, 2]);

// A full range clears all contents, like `clear()` does
deque.drain(..);
assert!(deque.is_empty());</pre></div> </div>
<summary><section id="method.clear" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1441">source</a><pre class="code-header" data-language="rust">pub fn clear(&amp;mut self)</pre></section></summary><div class="docblock">
<p>Clears the deque, removing all values.</p> <h5 id="examples-24">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut deque = VecDeque::new();
deque.push_back(1);
deque.clear();
assert!(deque.is_empty());</pre></div> </div>
<summary><section id="method.contains" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1470-1472">source</a></span><pre class="code-header" data-language="rust">pub fn contains(&amp;self, x: &amp;T) -&gt; bool
where
    T: PartialEq,</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the deque contains an element equal to the given value.</p> <p>This operation is <em>O</em>(<em>n</em>).</p> <p>Note that if you have a sorted <code>VecDeque</code>, <a href="../struct.vecdeque.html#method.binary_search" title="method std::collections::VecDeque::binary_search"><code>binary_search</code></a> may be faster.</p> <h5 id="examples-25">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut deque: VecDeque&lt;u32&gt; = VecDeque::new();

deque.push_back(0);
deque.push_back(1);

assert_eq!(deque.contains(&amp;1), true);
assert_eq!(deque.contains(&amp;10), false);</pre></div> </div>
<summary><section id="method.front" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1494">source</a><pre class="code-header" data-language="rust">pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt;</pre></section></summary><div class="docblock">
<p>Provides a reference to the front element, or <code>None</code> if the deque is empty.</p> <h5 id="examples-26">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut d = VecDeque::new();
assert_eq!(d.front(), None);

d.push_back(1);
d.push_back(2);
assert_eq!(d.front(), Some(&amp;1));</pre></div> </div>
<summary><section id="method.front_mut" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1518">source</a><pre class="code-header" data-language="rust">pub fn front_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt;</pre></section></summary><div class="docblock">
<p>Provides a mutable reference to the front element, or <code>None</code> if the deque is empty.</p> <h5 id="examples-27">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut d = VecDeque::new();
assert_eq!(d.front_mut(), None);

d.push_back(1);
d.push_back(2);
match d.front_mut() {
    Some(x) =&gt; *x = 9,
    None =&gt; (),
}
assert_eq!(d.front(), Some(&amp;9));</pre></div> </div>
<summary><section id="method.back" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1538">source</a><pre class="code-header" data-language="rust">pub fn back(&amp;self) -&gt; Option&lt;&amp;T&gt;</pre></section></summary><div class="docblock">
<p>Provides a reference to the back element, or <code>None</code> if the deque is empty.</p> <h5 id="examples-28">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut d = VecDeque::new();
assert_eq!(d.back(), None);

d.push_back(1);
d.push_back(2);
assert_eq!(d.back(), Some(&amp;2));</pre></div> </div>
<summary><section id="method.back_mut" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1562">source</a><pre class="code-header" data-language="rust">pub fn back_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt;</pre></section></summary><div class="docblock">
<p>Provides a mutable reference to the back element, or <code>None</code> if the deque is empty.</p> <h5 id="examples-29">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut d = VecDeque::new();
assert_eq!(d.back(), None);

d.push_back(1);
d.push_back(2);
match d.back_mut() {
    Some(x) =&gt; *x = 9,
    None =&gt; (),
}
assert_eq!(d.back(), Some(&amp;9));</pre></div> </div>
<summary><section id="method.pop_front" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1583">source</a><pre class="code-header" data-language="rust">pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Removes the first element and returns it, or <code>None</code> if the deque is empty.</p> <h5 id="examples-30">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut d = VecDeque::new();
d.push_back(1);
d.push_back(2);

assert_eq!(d.pop_front(), Some(1));
assert_eq!(d.pop_front(), Some(2));
assert_eq!(d.pop_front(), None);</pre></div> </div>
<summary><section id="method.pop_back" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1609">source</a><pre class="code-header" data-language="rust">pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Removes the last element from the deque and returns it, or <code>None</code> if it is empty.</p> <h5 id="examples-31">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
assert_eq!(buf.pop_back(), None);
buf.push_back(1);
buf.push_back(3);
assert_eq!(buf.pop_back(), Some(3));</pre></div> </div>
<summary><section id="method.push_front" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1631">source</a><pre class="code-header" data-language="rust">pub fn push_front(&amp;mut self, value: T)</pre></section></summary><div class="docblock">
<p>Prepends an element to the deque.</p> <h5 id="examples-32">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut d = VecDeque::new();
d.push_front(1);
d.push_front(2);
assert_eq!(d.front(), Some(&amp;2));</pre></div> </div>
<summary><section id="method.push_back" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1657">source</a><pre class="code-header" data-language="rust">pub fn push_back(&amp;mut self, value: T)</pre></section></summary><div class="docblock">
<p>Appends an element to the back of the deque.</p> <h5 id="examples-33">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.push_back(1);
buf.push_back(3);
assert_eq!(3, *buf.back().unwrap());</pre></div> </div>
<summary><section id="method.swap_remove_front" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1697">source</a></span><pre class="code-header" data-language="rust">pub fn swap_remove_front(&amp;mut self, index: usize) -&gt; Option&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Removes an element from anywhere in the deque and returns it, replacing it with the first element.</p> <p>This does not preserve ordering, but is <em>O</em>(1).</p> <p>Returns <code>None</code> if <code>index</code> is out of bounds.</p> <p>Element at index 0 is the front of the queue.</p> <h5 id="examples-34">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
assert_eq!(buf.swap_remove_front(0), None);
buf.push_back(1);
buf.push_back(2);
buf.push_back(3);
assert_eq!(buf, [1, 2, 3]);

assert_eq!(buf.swap_remove_front(2), Some(3));
assert_eq!(buf, [2, 1]);</pre></div> </div>
<summary><section id="method.swap_remove_back" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1732">source</a></span><pre class="code-header" data-language="rust">pub fn swap_remove_back(&amp;mut self, index: usize) -&gt; Option&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Removes an element from anywhere in the deque and returns it, replacing it with the last element.</p> <p>This does not preserve ordering, but is <em>O</em>(1).</p> <p>Returns <code>None</code> if <code>index</code> is out of bounds.</p> <p>Element at index 0 is the front of the queue.</p> <h5 id="examples-35">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
assert_eq!(buf.swap_remove_back(0), None);
buf.push_back(1);
buf.push_back(2);
buf.push_back(3);
assert_eq!(buf, [1, 2, 3]);

assert_eq!(buf.swap_remove_back(0), Some(1));
assert_eq!(buf, [3, 2]);</pre></div> </div>
<summary><section id="method.insert" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1766">source</a></span><pre class="code-header" data-language="rust">pub fn insert(&amp;mut self, index: usize, value: T)</pre></section></summary><div class="docblock">
<p>Inserts an element at <code>index</code> within the deque, shifting all elements with indices greater than or equal to <code>index</code> towards the back.</p> <p>Element at index 0 is the front of the queue.</p> <h5 id="panics-6">Panics</h5> <p>Panics if <code>index</code> is greater than deque‚Äôs length</p> <h5 id="examples-36">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut vec_deque = VecDeque::new();
vec_deque.push_back('a');
vec_deque.push_back('b');
vec_deque.push_back('c');
assert_eq!(vec_deque, &amp;['a', 'b', 'c']);

vec_deque.insert(1, 'd');
assert_eq!(vec_deque, &amp;['a', 'd', 'b', 'c']);</pre></div> </div>
<summary><section id="method.remove" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1816">source</a><pre class="code-header" data-language="rust">pub fn remove(&amp;mut self, index: usize) -&gt; Option&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Removes and returns the element at <code>index</code> from the deque. Whichever end is closer to the removal point will be moved to make room, and all the affected elements will be moved to new positions. Returns <code>None</code> if <code>index</code> is out of bounds.</p> <p>Element at index 0 is the front of the queue.</p> <h5 id="examples-37">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.push_back(1);
buf.push_back(2);
buf.push_back(3);
assert_eq!(buf, [1, 2, 3]);

assert_eq!(buf.remove(1), Some(2));
assert_eq!(buf, [1, 3]);</pre></div> </div>
<summary><section id="method.split_off" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1868-1870">source</a></span><pre class="code-header" data-language="rust">pub fn split_off(&amp;mut self, at: usize) -&gt; VecDeque&lt;T, A&gt;
where
    A: Clone,</pre></section></summary><div class="docblock">
<p>Splits the deque into two at the given index.</p> <p>Returns a newly allocated <code>VecDeque</code>. <code>self</code> contains elements <code>[0, at)</code>, and the returned deque contains elements <code>[at, len)</code>.</p> <p>Note that the capacity of <code>self</code> does not change.</p> <p>Element at index 0 is the front of the queue.</p> <h5 id="panics-7">Panics</h5> <p>Panics if <code>at &gt; len</code>.</p> <h5 id="examples-38">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf: VecDeque&lt;_&gt; = [1, 2, 3].into();
let buf2 = buf.split_off(1);
assert_eq!(buf, [1]);
assert_eq!(buf2, [2, 3]);</pre></div> </div>
<summary><section id="method.append" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1934">source</a></span><pre class="code-header" data-language="rust">pub fn append(&amp;mut self, other: &amp;mut VecDeque&lt;T, A&gt;)</pre></section></summary><div class="docblock">
<p>Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p> <h5 id="panics-8">Panics</h5> <p>Panics if the new number of elements in self overflows a <code>usize</code>.</p> <h5 id="examples-39">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf: VecDeque&lt;_&gt; = [1, 2].into();
let mut buf2: VecDeque&lt;_&gt; = [3, 4].into();
buf.append(&amp;mut buf2);
assert_eq!(buf, [1, 2, 3, 4]);
assert_eq!(buf2, []);</pre></div> </div>
<summary><section id="method.retain" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#1989-1991">source</a></span><pre class="code-header" data-language="rust">pub fn retain&lt;F&gt;(&amp;mut self, f: F)
where
    F: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Retains only the elements specified by the predicate.</p> <p>In other words, remove all elements <code>e</code> for which <code>f(&amp;e)</code> returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</p> <h5 id="examples-40">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.extend(1..5);
buf.retain(|&amp;x| x % 2 == 0);
assert_eq!(buf, [2, 4]);</pre></div> <p>Because the elements are visited exactly once in the original order, external state may be used to decide which elements to keep.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.extend(1..6);

let keep = [false, true, true, false, true];
let mut iter = keep.iter();
buf.retain(|_| *iter.next().unwrap());
assert_eq!(buf, [2, 3, 5]);</pre></div> </div>
<summary><section id="method.retain_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.61.0">1.61.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2018-2020">source</a></span><pre class="code-header" data-language="rust">pub fn retain_mut&lt;F&gt;(&amp;mut self, f: F)
where
    F: FnMut(&amp;mut T) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Retains only the elements specified by the predicate.</p> <p>In other words, remove all elements <code>e</code> for which <code>f(&amp;e)</code> returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</p> <h5 id="examples-41">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.extend(1..5);
buf.retain_mut(|x| if *x % 2 == 0 {
    *x += 1;
    true
} else {
    false
});
assert_eq!(buf, [3, 5]);</pre></div> </div>
<summary><section id="method.resize_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.33.0">1.33.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2094">source</a></span><pre class="code-header" data-language="rust">pub fn resize_with(&amp;mut self, new_len: usize, generator: impl FnMut() -&gt; T)</pre></section></summary><div class="docblock">
<p>Modifies the deque in-place so that <code>len()</code> is equal to <code>new_len</code>, either by removing excess elements from the back or by appending elements generated by calling <code>generator</code> to the back.</p> <h5 id="examples-42">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.push_back(5);
buf.push_back(10);
buf.push_back(15);
assert_eq!(buf, [5, 10, 15]);

buf.resize_with(5, Default::default);
assert_eq!(buf, [5, 10, 15, 0, 0]);

buf.resize_with(2, || unreachable!());
assert_eq!(buf, [5, 10]);

let mut state = 100;
buf.resize_with(5, || { state += 1; state });
assert_eq!(buf, [5, 10, 101, 102, 103]);</pre></div> </div>
<summary><section id="method.make_contiguous" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.48.0">1.48.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2160">source</a></span><pre class="code-header" data-language="rust">pub fn make_contiguous(&amp;mut self) -&gt; &amp;mut [T]</pre></section></summary><div class="docblock">
<p>Rearranges the internal storage of this deque so it is one contiguous slice, which is then returned.</p> <p>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort a deque.</p> <p>Once the internal storage is contiguous, the <a href="../struct.vecdeque.html#method.as_slices" title="method std::collections::VecDeque::as_slices"><code>as_slices</code></a> and <a href="../struct.vecdeque.html#method.as_mut_slices" title="method std::collections::VecDeque::as_mut_slices"><code>as_mut_slices</code></a> methods will return the entire contents of the deque in a single slice.</p> <h5 id="examples-43">Examples</h5> <p>Sorting the content of a deque.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::with_capacity(15);

buf.push_back(2);
buf.push_back(1);
buf.push_front(3);

// sorting the deque
buf.make_contiguous().sort();
assert_eq!(buf.as_slices(), (&amp;[1, 2, 3] as &amp;[_], &amp;[] as &amp;[_]));

// sorting it in reverse order
buf.make_contiguous().sort_by(|a, b| b.cmp(a));
assert_eq!(buf.as_slices(), (&amp;[3, 2, 1] as &amp;[_], &amp;[] as &amp;[_]));</pre></div> <p>Getting immutable access to the contiguous slice.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();

buf.push_back(2);
buf.push_back(1);
buf.push_front(3);

buf.make_contiguous();
if let (slice, &amp;[]) = buf.as_slices() {
    // we can now be sure that `slice` contains all elements of the deque,
    // while still having immutable access to `buf`.
    assert_eq!(buf.len(), slice.len());
    assert_eq!(slice, &amp;[3, 2, 1] as &amp;[_]);
}</pre></div> </div>
<summary><section id="method.rotate_left" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2319">source</a></span><pre class="code-header" data-language="rust">pub fn rotate_left(&amp;mut self, n: usize)</pre></section></summary><div class="docblock">
<p>Rotates the double-ended queue <code>n</code> places to the left.</p> <p>Equivalently,</p> <ul> <li>Rotates item <code>n</code> into the first position.</li> <li>Pops the first <code>n</code> items and pushes them to the end.</li> <li>Rotates <code>len() - n</code> places to the right.</li> </ul> <h5 id="panics-9">Panics</h5> <p>If <code>n</code> is greater than <code>len()</code>. Note that <code>n == len()</code> does <em>not</em> panic and is a no-op rotation.</p> <h5 id="complexity">Complexity</h5> <p>Takes <code>*O*(min(n, len() - n))</code> time and no extra space.</p> <h5 id="examples-44">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf: VecDeque&lt;_&gt; = (0..10).collect();

buf.rotate_left(3);
assert_eq!(buf, [3, 4, 5, 6, 7, 8, 9, 0, 1, 2]);

for i in 1..10 {
    assert_eq!(i * 3 % 10, buf[0]);
    buf.rotate_left(3);
}
assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);</pre></div> </div>
<summary><section id="method.rotate_right" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2362">source</a></span><pre class="code-header" data-language="rust">pub fn rotate_right(&amp;mut self, n: usize)</pre></section></summary><div class="docblock">
<p>Rotates the double-ended queue <code>n</code> places to the right.</p> <p>Equivalently,</p> <ul> <li>Rotates the first item into position <code>n</code>.</li> <li>Pops the last <code>n</code> items and pushes them to the front.</li> <li>Rotates <code>len() - n</code> places to the left.</li> </ul> <h5 id="panics-10">Panics</h5> <p>If <code>n</code> is greater than <code>len()</code>. Note that <code>n == len()</code> does <em>not</em> panic and is a no-op rotation.</p> <h5 id="complexity-1">Complexity</h5> <p>Takes <code>*O*(min(n, len() - n))</code> time and no extra space.</p> <h5 id="examples-45">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf: VecDeque&lt;_&gt; = (0..10).collect();

buf.rotate_right(3);
assert_eq!(buf, [7, 8, 9, 0, 1, 2, 3, 4, 5, 6]);

for i in 1..10 {
    assert_eq!(0, buf[i * 3 % 10]);
    buf.rotate_right(3);
}
assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);</pre></div> </div>
<summary><section id="method.binary_search" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.54.0">1.54.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2445-2447">source</a></span><pre class="code-header" data-language="rust">pub fn binary_search(&amp;self, x: &amp;T) -&gt; Result&lt;usize, usize&gt;
where
    T: Ord,</pre></section></summary><div class="docblock">
<p>Binary searches this <code>VecDeque</code> for a given element. If the <code>VecDeque</code> is not sorted, the returned result is unspecified and meaningless.</p> <p>If the value is found then <a href="../../result/enum.result.html#variant.Ok" title="variant std::result::Result::Ok"><code>Result::Ok</code></a> is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then <a href="../../result/enum.result.html#variant.Err" title="variant std::result::Result::Err"><code>Result::Err</code></a> is returned, containing the index where a matching element could be inserted while maintaining sorted order.</p> <p>See also <a href="../struct.vecdeque.html#method.binary_search_by" title="method std::collections::VecDeque::binary_search_by"><code>binary_search_by</code></a>, <a href="../struct.vecdeque.html#method.binary_search_by_key" title="method std::collections::VecDeque::binary_search_by_key"><code>binary_search_by_key</code></a>, and <a href="../struct.vecdeque.html#method.partition_point" title="method std::collections::VecDeque::partition_point"><code>partition_point</code></a>.</p> <h5 id="examples-46">Examples</h5> <p>Looks up a series of four elements. The first is found, with a uniquely determined position; the second and third are not found; the fourth could match any position in <code>[1, 4]</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let deque: VecDeque&lt;_&gt; = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();

assert_eq!(deque.binary_search(&amp;13),  Ok(9));
assert_eq!(deque.binary_search(&amp;4),   Err(7));
assert_eq!(deque.binary_search(&amp;100), Err(13));
let r = deque.binary_search(&amp;1);
assert!(matches!(r, Ok(1..=4)));</pre></div> <p>If you want to insert an item to a sorted deque, while maintaining sort order, consider using <a href="../struct.vecdeque.html#method.partition_point" title="method std::collections::VecDeque::partition_point"><code>partition_point</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut deque: VecDeque&lt;_&gt; = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();
let num = 42;
let idx = deque.partition_point(|&amp;x| x &lt; num);
// The above is equivalent to `let idx = deque.binary_search(&amp;num).unwrap_or_else(|x| x);`
deque.insert(idx, num);
assert_eq!(deque, &amp;[0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);</pre></div> </div>
<summary><section id="method.binary_search_by" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.54.0">1.54.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2491-2493">source</a></span><pre class="code-header" data-language="rust">pub fn binary_search_by&lt;'a, F&gt;(&amp;'a self, f: F) -&gt; Result&lt;usize, usize&gt;
where
    F: FnMut(&amp;'a T) -&gt; Ordering,</pre></section></summary><div class="docblock">
<p>Binary searches this <code>VecDeque</code> with a comparator function.</p> <p>The comparator function should return an order code that indicates whether its argument is <code>Less</code>, <code>Equal</code> or <code>Greater</code> the desired target. If the <code>VecDeque</code> is not sorted or if the comparator function does not implement an order consistent with the sort order of the underlying <code>VecDeque</code>, the returned result is unspecified and meaningless.</p> <p>If the value is found then <a href="../../result/enum.result.html#variant.Ok" title="variant std::result::Result::Ok"><code>Result::Ok</code></a> is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then <a href="../../result/enum.result.html#variant.Err" title="variant std::result::Result::Err"><code>Result::Err</code></a> is returned, containing the index where a matching element could be inserted while maintaining sorted order.</p> <p>See also <a href="../struct.vecdeque.html#method.binary_search" title="method std::collections::VecDeque::binary_search"><code>binary_search</code></a>, <a href="../struct.vecdeque.html#method.binary_search_by_key" title="method std::collections::VecDeque::binary_search_by_key"><code>binary_search_by_key</code></a>, and <a href="../struct.vecdeque.html#method.partition_point" title="method std::collections::VecDeque::partition_point"><code>partition_point</code></a>.</p> <h5 id="examples-47">Examples</h5> <p>Looks up a series of four elements. The first is found, with a uniquely determined position; the second and third are not found; the fourth could match any position in <code>[1, 4]</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let deque: VecDeque&lt;_&gt; = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();

assert_eq!(deque.binary_search_by(|x| x.cmp(&amp;13)),  Ok(9));
assert_eq!(deque.binary_search_by(|x| x.cmp(&amp;4)),   Err(7));
assert_eq!(deque.binary_search_by(|x| x.cmp(&amp;100)), Err(13));
let r = deque.binary_search_by(|x| x.cmp(&amp;1));
assert!(matches!(r, Ok(1..=4)));</pre></div> </div>
<summary><section id="method.binary_search_by_key" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.54.0">1.54.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2549-2552">source</a></span><pre class="code-header" data-language="rust">pub fn binary_search_by_key&lt;'a, B, F&gt;(
    &amp;'a self,
    b: &amp;B,
    f: F
) -&gt; Result&lt;usize, usize&gt;
where
    F: FnMut(&amp;'a T) -&gt; B,
    B: Ord,</pre></section></summary><div class="docblock">
<p>Binary searches this <code>VecDeque</code> with a key extraction function.</p> <p>Assumes that the deque is sorted by the key, for instance with <a href="../struct.vecdeque.html#method.make_contiguous" title="method std::collections::VecDeque::make_contiguous"><code>make_contiguous().sort_by_key()</code></a> using the same key extraction function. If the deque is not sorted by the key, the returned result is unspecified and meaningless.</p> <p>If the value is found then <a href="../../result/enum.result.html#variant.Ok" title="variant std::result::Result::Ok"><code>Result::Ok</code></a> is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then <a href="../../result/enum.result.html#variant.Err" title="variant std::result::Result::Err"><code>Result::Err</code></a> is returned, containing the index where a matching element could be inserted while maintaining sorted order.</p> <p>See also <a href="../struct.vecdeque.html#method.binary_search" title="method std::collections::VecDeque::binary_search"><code>binary_search</code></a>, <a href="../struct.vecdeque.html#method.binary_search_by" title="method std::collections::VecDeque::binary_search_by"><code>binary_search_by</code></a>, and <a href="../struct.vecdeque.html#method.partition_point" title="method std::collections::VecDeque::partition_point"><code>partition_point</code></a>.</p> <h5 id="examples-48">Examples</h5> <p>Looks up a series of four elements in a slice of pairs sorted by their second elements. The first is found, with a uniquely determined position; the second and third are not found; the fourth could match any position in <code>[1, 4]</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let deque: VecDeque&lt;_&gt; = [(0, 0), (2, 1), (4, 1), (5, 1),
         (3, 1), (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),
         (1, 21), (2, 34), (4, 55)].into();

assert_eq!(deque.binary_search_by_key(&amp;13, |&amp;(a, b)| b),  Ok(9));
assert_eq!(deque.binary_search_by_key(&amp;4, |&amp;(a, b)| b),   Err(7));
assert_eq!(deque.binary_search_by_key(&amp;100, |&amp;(a, b)| b), Err(13));
let r = deque.binary_search_by_key(&amp;1, |&amp;(a, b)| b);
assert!(matches!(r, Ok(1..=4)));</pre></div> </div>
<summary><section id="method.partition_point" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.54.0">1.54.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2601-2603">source</a></span><pre class="code-header" data-language="rust">pub fn partition_point&lt;P&gt;(&amp;self, pred: P) -&gt; usize
where
    P: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Returns the index of the partition point according to the given predicate (the index of the first element of the second partition).</p> <p>The deque is assumed to be partitioned according to the given predicate. This means that all elements for which the predicate returns true are at the start of the deque and all elements for which the predicate returns false are at the end. For example, <code>[7, 15, 3, 5, 4, 12, 6]</code> is partitioned under the predicate <code>x % 2 != 0</code> (all odd numbers are at the start, all even at the end).</p> <p>If the deque is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.</p> <p>See also <a href="../struct.vecdeque.html#method.binary_search" title="method std::collections::VecDeque::binary_search"><code>binary_search</code></a>, <a href="../struct.vecdeque.html#method.binary_search_by" title="method std::collections::VecDeque::binary_search_by"><code>binary_search_by</code></a>, and <a href="../struct.vecdeque.html#method.binary_search_by_key" title="method std::collections::VecDeque::binary_search_by_key"><code>binary_search_by_key</code></a>.</p> <h5 id="examples-49">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let deque: VecDeque&lt;_&gt; = [1, 2, 3, 3, 5, 6, 7].into();
let i = deque.partition_point(|&amp;x| x &lt; 5);

assert_eq!(i, 4);
assert!(deque.iter().take(i).all(|&amp;x| x &lt; 5));
assert!(deque.iter().skip(i).all(|&amp;x| !(x &lt; 5)));</pre></div> <p>If you want to insert an item to a sorted deque, while maintaining sort order:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut deque: VecDeque&lt;_&gt; = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();
let num = 42;
let idx = deque.partition_point(|&amp;x| x &lt; num);
deque.insert(idx, num);
assert_eq!(deque, &amp;[0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);</pre></div> </div>
</div>
<summary><section id="impl-VecDeque%3CT,+A%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2615">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; VecDeque&lt;T, A&gt;
where
    T: Clone,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.resize" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2638">source</a></span><pre class="code-header" data-language="rust">pub fn resize(&amp;mut self, new_len: usize, value: T)</pre></section></summary><div class="docblock">
<p>Modifies the deque in-place so that <code>len()</code> is equal to new_len, either by removing excess elements from the back or by appending clones of <code>value</code> to the back.</p> <h5 id="examples-50">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let mut buf = VecDeque::new();
buf.push_back(5);
buf.push_back(10);
buf.push_back(15);
assert_eq!(buf, [5, 10, 15]);

buf.resize(2, 0);
assert_eq!(buf, [5, 10]);

buf.resize(5, 20);
assert_eq!(buf, [5, 10, 20, 20, 20]);</pre></div> </div>
</div>
</div>
<h2 id="trait-implementations" class="small-section-header">Trait Implementations</h2>
<div id="trait-implementations-list">
<summary><section id="impl-BufRead-for-VecDeque%3Cu8,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0">1.75.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#480-494">source</a></span><pre class="code-header" data-language="rust">impl&lt;A: Allocator&gt; BufRead for VecDeque&lt;u8, A&gt;</pre></section></summary><div class="docblock">
<p>BufRead is implemented for <code>VecDeque&lt;u8&gt;</code> by reading bytes from the front of the <code>VecDeque</code>.</p> </div>
<div class="impl-items">
<summary><section id="method.fill_buf" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#485-488">source</a><pre class="code-header" data-language="rust">fn fill_buf(&amp;mut self) -&gt; Result&lt;&amp;[u8]&gt;</pre></section></summary><div class="docblock">
<p>Returns the contents of the ‚Äúfront‚Äù slice as returned by <a href="../struct.vecdeque.html#method.as_slices" title="method std::collections::VecDeque::as_slices"><code>as_slices</code></a>. If the contained byte slices of the <code>VecDeque</code> are discontiguous, multiple calls to <code>fill_buf</code> will be needed to read the entire content.</p> </div>
<summary><section id="method.consume" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#491-493">source</a><pre class="code-header" data-language="rust">fn consume(&amp;mut self, amt: usize)</pre></section></summary><div class="docblock">Tells this buffer that <code>amt</code> bytes have been consumed from the buffer, so they should no longer be returned in calls to <code>read</code>. <a href="../../io/trait.bufread.html#tymethod.consume">Read more</a>
</div>
<summary><section id="method.has_data_left" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#2157-2159">source</a><pre class="code-header" data-language="rust">fn has_data_left(&amp;mut self) -&gt; Result&lt;bool&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>buf_read_has_data_left</code> <a href="https://github.com/rust-lang/rust/issues/86423">#86423</a>)</span>
</div></span><div class="docblock">Check if the underlying <code>Read</code> has any data left to be read. <a href="../../io/trait.bufread.html#method.has_data_left">Read more</a>
</div>
<summary><section id="method.read_until" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#2216-2218">source</a><pre class="code-header" data-language="rust">fn read_until(&amp;mut self, byte: u8, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Read all bytes into <code>buf</code> until the delimiter <code>byte</code> or EOF is reached. <a href="../../io/trait.bufread.html#method.read_until">Read more</a>
</div>
<summary><section id="method.read_line" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#2284-2289">source</a><pre class="code-header" data-language="rust">fn read_line(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Read all bytes until a newline (the <code>0xA</code> byte) is reached, and append them to the provided <code>String</code> buffer. <a href="../../io/trait.bufread.html#method.read_line">Read more</a>
</div>
<summary><section id="method.split" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#2322-2327">source</a><pre class="code-header" data-language="rust">fn split(self, byte: u8) -&gt; Split&lt;Self&gt; ‚ìò
where
    Self: Sized,</pre></section></summary><div class="docblock">Returns an iterator over the contents of this reader split on the byte <code>byte</code>. <a href="../../io/trait.bufread.html#method.split">Read more</a>
</div>
<summary><section id="method.lines" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#2359-2364">source</a><pre class="code-header" data-language="rust">fn lines(self) -&gt; Lines&lt;Self&gt; ‚ìò
where
    Self: Sized,</pre></section></summary><div class="docblock">Returns an iterator over the lines of this reader. <a href="../../io/trait.bufread.html#method.lines">Read more</a>
</div>
</div>
<summary><section id="impl-Clone-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#109">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Clone for VecDeque&lt;T, A&gt;
where
    T: Clone,
    A: Allocator + Clone,</pre></section></summary><div class="impl-items">
<summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#110">source</a><pre class="code-header" data-language="rust">fn clone(&amp;self) -&gt; VecDeque&lt;T, A&gt;</pre></section></summary><div class="docblock">Returns a copy of the value. <a href="../../clone/trait.clone.html#tymethod.clone">Read more</a>
</div>
<summary><section id="method.clone_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#116">source</a><pre class="code-header" data-language="rust">fn clone_from(&amp;mut self, other: &amp;VecDeque&lt;T, A&gt;)</pre></section></summary><div class="docblock">Performs copy-assignment from <code>source</code>. <a href="../../clone/trait.clone.html#method.clone_from">Read more</a>
</div>
</div>
<summary><section id="impl-Debug-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2829">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Debug for VecDeque&lt;T, A&gt;
where
    T: Debug,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2830">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="../../fmt/trait.debug.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Default-for-VecDeque%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#148">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Default for VecDeque&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#151">source</a><pre class="code-header" data-language="rust">fn default() -&gt; VecDeque&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Creates an empty deque.</p> </div>
</div>
<summary><section id="impl-Drop-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#123">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Drop for VecDeque&lt;T, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#124">source</a><pre class="code-header" data-language="rust">fn drop(&amp;mut self)</pre></section></summary><div class="docblock">Executes the destructor for this type. <a href="../../ops/trait.drop.html#tymethod.drop">Read more</a>
</div>
</div>
<summary><section id="impl-Extend%3C%26T%3E-for-VecDeque%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2812">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, A&gt; Extend&lt;&amp;'a T&gt; for VecDeque&lt;T, A&gt;
where
    T: 'a + Copy,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.extend" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2813">source</a><pre class="code-header" data-language="rust">fn extend&lt;I&gt;(&amp;mut self, iter: I)
where
    I: IntoIterator&lt;Item = &amp;'a T&gt;,</pre></section></summary><div class="docblock">Extends a collection with the contents of an iterator. <a href="../../iter/trait.extend.html#tymethod.extend">Read more</a>
</div>
<summary><section id="method.extend_one" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2818">source</a><pre class="code-header" data-language="rust">fn extend_one(&amp;mut self, _: &amp;'a T)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span>
</div></span><div class="docblock">Extends a collection with exactly one element.</div>
<summary><section id="method.extend_reserve" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2823">source</a><pre class="code-header" data-language="rust">fn extend_reserve(&amp;mut self, additional: usize)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span>
</div></span><div class="docblock">Reserves capacity in a collection for the given number of additional elements. <a href="../../iter/trait.extend.html#method.extend_reserve">Read more</a>
</div>
</div>
<summary><section id="impl-Extend%3CT%3E-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2795">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Extend&lt;T&gt; for VecDeque&lt;T, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.extend-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2796">source</a><pre class="code-header" data-language="rust">fn extend&lt;I&gt;(&amp;mut self, iter: I)
where
    I: IntoIterator&lt;Item = T&gt;,</pre></section></summary><div class="docblock">Extends a collection with the contents of an iterator. <a href="../../iter/trait.extend.html#tymethod.extend">Read more</a>
</div>
<summary><section id="method.extend_one-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2801">source</a><pre class="code-header" data-language="rust">fn extend_one(&amp;mut self, elem: T)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span>
</div></span><div class="docblock">Extends a collection with exactly one element.</div>
<summary><section id="method.extend_reserve-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2806">source</a><pre class="code-header" data-language="rust">fn extend_reserve(&amp;mut self, additional: usize)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span>
</div></span><div class="docblock">Reserves capacity in a collection for the given number of additional elements. <a href="../../iter/trait.extend.html#method.extend_reserve">Read more</a>
</div>
</div>
<summary><section id="impl-From%3C%5BT;+N%5D%3E-for-VecDeque%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.56.0">1.56.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2902">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, const N: usize&gt; From&lt;[T; N]&gt; for VecDeque&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2912">source</a><pre class="code-header" data-language="rust">fn from(arr: [T; N]) -&gt; VecDeque&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>[T; N]</code> into a <code>VecDeque&lt;T&gt;</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let deq1 = VecDeque::from([1, 2, 3, 4]);
let deq2: VecDeque&lt;_&gt; = [1, 2, 3, 4].into();
assert_eq!(deq1, deq2);</pre></div> </div>
</div>
<summary><section id="impl-From%3CVec%3CT,+A%3E%3E-for-VecDeque%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2836">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; From&lt;Vec&lt;T, A&gt;&gt; for VecDeque&lt;T, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2846">source</a><pre class="code-header" data-language="rust">fn from(other: Vec&lt;T, A&gt;) -&gt; VecDeque&lt;T, A&gt;</pre></section></summary><div class="docblock">
<p>Turn a <a href="../../vec/struct.vec.html" title="struct std::vec::Vec"><code>Vec&lt;T&gt;</code></a> into a <a href="../struct.vecdeque.html" title="struct std::collections::VecDeque"><code>VecDeque&lt;T&gt;</code></a>.</p> <p>This conversion is guaranteed to run in <em>O</em>(1) time and to not re-allocate the <code>Vec</code>‚Äôs buffer or allocate any additional memory.</p> </div>
</div>
<summary><section id="impl-From%3CVecDeque%3CT,+A%3E%3E-for-Vec%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2853">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; From&lt;VecDeque&lt;T, A&gt;&gt; for Vec&lt;T, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2883">source</a><pre class="code-header" data-language="rust">fn from(other: VecDeque&lt;T, A&gt;) -&gt; Vec&lt;T, A&gt;</pre></section></summary><div class="docblock">
<p>Turn a <a href="../struct.vecdeque.html" title="struct std::collections::VecDeque"><code>VecDeque&lt;T&gt;</code></a> into a <a href="../../vec/struct.vec.html" title="struct std::vec::Vec"><code>Vec&lt;T&gt;</code></a>.</p> <p>This never needs to re-allocate, but does need to do <em>O</em>(<em>n</em>) data movement if the circular buffer doesn‚Äôt happen to be at the beginning of the allocation.</p> <h5 id="examples-51">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

// This one is *O*(1).
let deque: VecDeque&lt;_&gt; = (1..5).collect();
let ptr = deque.as_slices().0.as_ptr();
let vec = Vec::from(deque);
assert_eq!(vec, [1, 2, 3, 4]);
assert_eq!(vec.as_ptr(), ptr);

// This one needs data rearranging.
let mut deque: VecDeque&lt;_&gt; = (1..5).collect();
deque.push_front(9);
deque.push_front(8);
let ptr = deque.as_slices().1.as_ptr();
let vec = Vec::from(deque);
assert_eq!(vec, [8, 9, 1, 2, 3, 4]);
assert_eq!(vec.as_ptr(), ptr);</pre></div> </div>
</div>
<summary><section id="impl-FromIterator%3CT%3E-for-VecDeque%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2756">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; FromIterator&lt;T&gt; for VecDeque&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2757">source</a><pre class="code-header" data-language="rust">fn from_iter&lt;I&gt;(iter: I) -&gt; VecDeque&lt;T&gt;
where
    I: IntoIterator&lt;Item = T&gt;,</pre></section></summary><div class="docblock">Creates a value from an iterator. <a href="../../iter/trait.fromiterator.html#tymethod.from_iter">Read more</a>
</div>
</div>
<summary><section id="impl-Hash-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2724">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Hash for VecDeque&lt;T, A&gt;
where
    T: Hash,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2725">source</a><pre class="code-header" data-language="rust">fn hash&lt;H&gt;(&amp;self, state: &amp;mut H)
where
    H: Hasher,</pre></section></summary><div class="docblock">Feeds this value into the given <a href="../../hash/trait.hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="../../hash/trait.hash.html#tymethod.hash">Read more</a>
</div>
<summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="src" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#242-244">source</a></span><pre class="code-header" data-language="rust">fn hash_slice&lt;H&gt;(data: &amp;[Self], state: &amp;mut H)
where
    H: Hasher,
    Self: Sized,</pre></section></summary><div class="docblock">Feeds a slice of this type into the given <a href="../../hash/trait.hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="../../hash/trait.hash.html#method.hash_slice">Read more</a>
</div>
</div>
<summary><section id="impl-Index%3Cusize%3E-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2738">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Index&lt;usize&gt; for VecDeque&lt;T, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = T</pre></section></summary><div class="docblock">The returned type after indexing.</div>
<summary><section id="method.index" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2742">source</a><pre class="code-header" data-language="rust">fn index(&amp;self, index: usize) -&gt; &amp;T</pre></section></summary><div class="docblock">Performs the indexing (<code>container[index]</code>) operation. <a href="../../ops/trait.index.html#tymethod.index">Read more</a>
</div>
</div>
<summary><section id="impl-IndexMut%3Cusize%3E-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2748">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; IndexMut&lt;usize&gt; for VecDeque&lt;T, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.index_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2750">source</a><pre class="code-header" data-language="rust">fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut T</pre></section></summary><div class="docblock">Performs the mutable indexing (<code>container[index]</code>) operation. <a href="../../ops/trait.indexmut.html#tymethod.index_mut">Read more</a>
</div>
</div>
<summary><section id="impl-IntoIterator-for-%26VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2775">source</a><pre class="code-header" data-language="rust">impl&lt;'a, T, A&gt; IntoIterator for &amp;'a VecDeque&lt;T, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Item" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></summary><div class="docblock">The type of the elements being iterated over.</div>
<summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type IntoIter = Iter&lt;'a, T&gt;</pre></section></summary><div class="docblock">Which kind of iterator are we turning this into?</div>
<summary><section id="method.into_iter" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2779">source</a><pre class="code-header" data-language="rust">fn into_iter(self) -&gt; Iter&lt;'a, T&gt; ‚ìò</pre></section></summary><div class="docblock">Creates an iterator from a value. <a href="../../iter/trait.intoiterator.html#tymethod.into_iter">Read more</a>
</div>
</div>
<summary><section id="impl-IntoIterator-for-%26mut+VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2785">source</a><pre class="code-header" data-language="rust">impl&lt;'a, T, A&gt; IntoIterator for &amp;'a mut VecDeque&lt;T, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Item-2" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Item = &amp;'a mut T</pre></section></summary><div class="docblock">The type of the elements being iterated over.</div>
<summary><section id="associatedtype.IntoIter-2" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type IntoIter = IterMut&lt;'a, T&gt;</pre></section></summary><div class="docblock">Which kind of iterator are we turning this into?</div>
<summary><section id="method.into_iter-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2789">source</a><pre class="code-header" data-language="rust">fn into_iter(self) -&gt; IterMut&lt;'a, T&gt; ‚ìò</pre></section></summary><div class="docblock">Creates an iterator from a value. <a href="../../iter/trait.intoiterator.html#tymethod.into_iter">Read more</a>
</div>
</div>
<summary><section id="impl-IntoIterator-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2763">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; IntoIterator for VecDeque&lt;T, A&gt;
where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.into_iter-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2769">source</a><pre class="code-header" data-language="rust">fn into_iter(self) -&gt; IntoIter&lt;T, A&gt; ‚ìò</pre></section></summary><div class="docblock">
<p>Consumes the deque into a front-to-back iterator yielding elements by value.</p> </div>
<summary><section id="associatedtype.Item-1" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Item = T</pre></section></summary><div class="docblock">The type of the elements being iterated over.</div>
<summary><section id="associatedtype.IntoIter-1" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type IntoIter = IntoIter&lt;T, A&gt;</pre></section></summary><div class="docblock">Which kind of iterator are we turning this into?</div>
</div>
<summary><section id="impl-Ord-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2716">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Ord for VecDeque&lt;T, A&gt;
where
    T: Ord,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2718">source</a><pre class="code-header" data-language="rust">fn cmp(&amp;self, other: &amp;VecDeque&lt;T, A&gt;) -&gt; Ordering</pre></section></summary><div class="docblock">This method returns an <a href="../../cmp/enum.ordering.html" title="enum std::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="../../cmp/trait.ord.html#tymethod.cmp">Read more</a>
</div>
<summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#826-828">source</a></span><pre class="code-header" data-language="rust">fn max(self, other: Self) -&gt; Self
where
    Self: Sized,</pre></section></summary><div class="docblock">Compares and returns the maximum of two values. <a href="../../cmp/trait.ord.html#method.max">Read more</a>
</div>
<summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#846-848">source</a></span><pre class="code-header" data-language="rust">fn min(self, other: Self) -&gt; Self
where
    Self: Sized,</pre></section></summary><div class="docblock">Compares and returns the minimum of two values. <a href="../../cmp/trait.ord.html#method.min">Read more</a>
</div>
<summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#871-874">source</a></span><pre class="code-header" data-language="rust">fn clamp(self, min: Self, max: Self) -&gt; Self
where
    Self: Sized + PartialOrd,</pre></section></summary><div class="docblock">Restrict a value to a certain interval. <a href="../../cmp/trait.ord.html#method.clamp">Read more</a>
</div>
</div>
<summary><section id="impl-PartialEq%3C%26%5BU%5D%3E-for-VecDeque%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2702">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, U, A&gt; PartialEq&lt;&amp;[U]&gt; for VecDeque&lt;T, A&gt;
where
    A: Allocator,
    T: PartialEq&lt;U&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2702">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;[U]) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3C%26%5BU;+N%5D%3E-for-VecDeque%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2705">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, U, A, const N: usize&gt; PartialEq&lt;&amp;[U; N]&gt; for VecDeque&lt;T, A&gt;
where
    A: Allocator,
    T: PartialEq&lt;U&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2705">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;[U; N]) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3C%26mut+%5BU%5D%3E-for-VecDeque%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2703">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, U, A&gt; PartialEq&lt;&amp;mut [U]&gt; for VecDeque&lt;T, A&gt;
where
    A: Allocator,
    T: PartialEq&lt;U&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2703">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;mut [U]) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3C%26mut+%5BU;+N%5D%3E-for-VecDeque%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2706">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, U, A, const N: usize&gt; PartialEq&lt;&amp;mut [U; N]&gt; for VecDeque&lt;T, A&gt;
where
    A: Allocator,
    T: PartialEq&lt;U&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2706">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;mut [U; N]) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3C%5BU;+N%5D%3E-for-VecDeque%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2704">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, U, A, const N: usize&gt; PartialEq&lt;[U; N]&gt; for VecDeque&lt;T, A&gt;
where
    A: Allocator,
    T: PartialEq&lt;U&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2704">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;[U; N]) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CVec%3CU,+A%3E%3E-for-VecDeque%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2701">source</a></span><pre class="code-header" data-language="rust">impl&lt;T, U, A&gt; PartialEq&lt;Vec&lt;U, A&gt;&gt; for VecDeque&lt;T, A&gt;
where
    A: Allocator,
    T: PartialEq&lt;U&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2701">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;Vec&lt;U, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2660">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; PartialEq for VecDeque&lt;T, A&gt;
where
    T: PartialEq,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2661">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;VecDeque&lt;T, A&gt;) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialOrd-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2709">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; PartialOrd for VecDeque&lt;T, A&gt;
where
    T: PartialOrd,
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2710">source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;VecDeque&lt;T, A&gt;) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../../cmp/trait.partialord.html#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1122">source</a><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../../cmp/trait.partialord.html#method.lt">Read more</a>
</div>
<summary><section id="method.le" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1139">source</a><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../../cmp/trait.partialord.html#method.le">Read more</a>
</div>
<summary><section id="method.gt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1155">source</a><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../../cmp/trait.partialord.html#method.gt">Read more</a>
</div>
<summary><section id="method.ge" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1172">source</a><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../../cmp/trait.partialord.html#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-Read-for-VecDeque%3Cu8,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.63.0">1.63.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#429-476">source</a></span><pre class="code-header" data-language="rust">impl&lt;A: Allocator&gt; Read for VecDeque&lt;u8, A&gt;</pre></section></summary><div class="docblock">
<p>Read is implemented for <code>VecDeque&lt;u8&gt;</code> by consuming bytes from the front of the <code>VecDeque</code>.</p> </div>
<div class="impl-items">
<summary><section id="method.read" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#434-439">source</a><pre class="code-header" data-language="rust">fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">
<p>Fill <code>buf</code> with the contents of the ‚Äúfront‚Äù slice as returned by <a href="../struct.vecdeque.html#method.as_slices" title="method std::collections::VecDeque::as_slices"><code>as_slices</code></a>. If the contained byte slices of the <code>VecDeque</code> are discontiguous, multiple calls to <code>read</code> will be needed to read the entire content.</p> </div>
<summary><section id="method.read_buf" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#442-448">source</a><pre class="code-header" data-language="rust">fn read_buf(&amp;mut self, cursor: BorrowedCursor&lt;'_&gt;) -&gt; Result&lt;()&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>read_buf</code> <a href="https://github.com/rust-lang/rust/issues/78485">#78485</a>)</span>
</div></span><div class="docblock">Pull some bytes from this source into the specified buffer. <a href="../../io/trait.read.html#method.read_buf">Read more</a>
</div>
<summary><section id="method.read_to_end" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#451-461">source</a><pre class="code-header" data-language="rust">fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Read all bytes until EOF in this source, placing them into <code>buf</code>. <a href="../../io/trait.read.html#method.read_to_end">Read more</a>
</div>
<summary><section id="method.read_to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#464-475">source</a><pre class="code-header" data-language="rust">fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Read all bytes until EOF in this source, appending them to <code>buf</code>. <a href="../../io/trait.read.html#method.read_to_string">Read more</a>
</div>
<summary><section id="method.read_vectored" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#707-709">source</a></span><pre class="code-header" data-language="rust">fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Like <code>read</code>, except that it reads into a slice of buffers. <a href="../../io/trait.read.html#method.read_vectored">Read more</a>
</div>
<summary><section id="method.is_read_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#720-722">source</a><pre class="code-header" data-language="rust">fn is_read_vectored(&amp;self) -&gt; bool</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>can_vector</code> <a href="https://github.com/rust-lang/rust/issues/69941">#69941</a>)</span>
</div></span><div class="docblock">Determines if this <code>Read</code>er has an efficient <code>read_vectored</code> implementation. <a href="../../io/trait.read.html#method.is_read_vectored">Read more</a>
</div>
<summary><section id="method.read_exact" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#869-871">source</a></span><pre class="code-header" data-language="rust">fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;()&gt;</pre></section></summary><div class="docblock">Read the exact number of bytes required to fill <code>buf</code>. <a href="../../io/trait.read.html#method.read_exact">Read more</a>
</div>
<summary><section id="method.read_buf_exact" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#903-918">source</a><pre class="code-header" data-language="rust">fn read_buf_exact(&amp;mut self, cursor: BorrowedCursor&lt;'_&gt;) -&gt; Result&lt;()&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>read_buf</code> <a href="https://github.com/rust-lang/rust/issues/78485">#78485</a>)</span>
</div></span><div class="docblock">Read the exact number of bytes required to fill <code>cursor</code>. <a href="../../io/trait.read.html#method.read_buf_exact">Read more</a>
</div>
<summary><section id="method.by_ref-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#955-960">source</a><pre class="code-header" data-language="rust">fn by_ref(&amp;mut self) -&gt; &amp;mut Self
where
    Self: Sized,</pre></section></summary><div class="docblock">Creates a ‚Äúby reference‚Äù adaptor for this instance of <code>Read</code>. <a href="../../io/trait.read.html#method.by_ref">Read more</a>
</div>
<summary><section id="method.bytes" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#998-1003">source</a><pre class="code-header" data-language="rust">fn bytes(self) -&gt; Bytes&lt;Self&gt; ‚ìò
where
    Self: Sized,</pre></section></summary><div class="docblock">Transforms this <code>Read</code> instance to an <a href="../../iter/trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> over its bytes. <a href="../../io/trait.read.html#method.bytes">Read more</a>
</div>
<summary><section id="method.chain" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1036-1041">source</a><pre class="code-header" data-language="rust">fn chain&lt;R: Read&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt; ‚ìò
where
    Self: Sized,</pre></section></summary><div class="docblock">Creates an adapter which will chain this stream with another. <a href="../../io/trait.read.html#method.chain">Read more</a>
</div>
<summary><section id="method.take" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1075-1080">source</a><pre class="code-header" data-language="rust">fn take(self, limit: u64) -&gt; Take&lt;Self&gt; ‚ìò
where
    Self: Sized,</pre></section></summary><div class="docblock">Creates an adapter which will read at most <code>limit</code> bytes from it. <a href="../../io/trait.read.html#method.take">Read more</a>
</div>
</div>
<summary><section id="impl-Write-for-VecDeque%3Cu8,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.63.0">1.63.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#498-530">source</a></span><pre class="code-header" data-language="rust">impl&lt;A: Allocator&gt; Write for VecDeque&lt;u8, A&gt;</pre></section></summary><div class="docblock">
<p>Write is implemented for <code>VecDeque&lt;u8&gt;</code> by appending to the <code>VecDeque</code>, growing it as needed.</p> </div>
<div class="impl-items">
<summary><section id="method.write" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#500-503">source</a><pre class="code-header" data-language="rust">fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Write a buffer into this writer, returning how many bytes were written. <a href="../../io/trait.write.html#tymethod.write">Read more</a>
</div>
<summary><section id="method.write_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#506-513">source</a><pre class="code-header" data-language="rust">fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; Result&lt;usize&gt;</pre></section></summary><div class="docblock">Like <a href="../../io/trait.write.html#tymethod.write" title="method std::io::Write::write"><code>write</code></a>, except that it writes from a slice of buffers. <a href="../../io/trait.write.html#method.write_vectored">Read more</a>
</div>
<summary><section id="method.is_write_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#516-518">source</a><pre class="code-header" data-language="rust">fn is_write_vectored(&amp;self) -&gt; bool</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>can_vector</code> <a href="https://github.com/rust-lang/rust/issues/69941">#69941</a>)</span>
</div></span><div class="docblock">Determines if this <code>Write</code>r has an efficient <a href="../../io/trait.write.html#method.write_vectored" title="method std::io::Write::write_vectored"><code>write_vectored</code></a> implementation. <a href="../../io/trait.write.html#method.is_write_vectored">Read more</a>
</div>
<summary><section id="method.write_all" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#521-524">source</a><pre class="code-header" data-language="rust">fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;</pre></section></summary><div class="docblock">Attempts to write an entire buffer into this writer. <a href="../../io/trait.write.html#method.write_all">Read more</a>
</div>
<summary><section id="method.flush" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#527-529">source</a><pre class="code-header" data-language="rust">fn flush(&amp;mut self) -&gt; Result&lt;()&gt;</pre></section></summary><div class="docblock">Flush this output stream, ensuring that all intermediately buffered contents reach their destination. <a href="../../io/trait.write.html#tymethod.flush">Read more</a>
</div>
<summary><section id="method.write_all_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1685-1703">source</a><pre class="code-header" data-language="rust">fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; Result&lt;()&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>write_all_vectored</code> <a href="https://github.com/rust-lang/rust/issues/70436">#70436</a>)</span>
</div></span><div class="docblock">Attempts to write multiple buffers into this writer. <a href="../../io/trait.write.html#method.write_all_vectored">Read more</a>
</div>
<summary><section id="method.write_fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1741-1773">source</a><pre class="code-header" data-language="rust">fn write_fmt(&amp;mut self, fmt: Arguments&lt;'_&gt;) -&gt; Result&lt;()&gt;</pre></section></summary><div class="docblock">Writes a formatted string into this writer, returning any error encountered. <a href="../../io/trait.write.html#method.write_fmt">Read more</a>
</div>
<summary><section id="method.by_ref" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1797-1802">source</a><pre class="code-header" data-language="rust">fn by_ref(&amp;mut self) -&gt; &amp;mut Self
where
    Self: Sized,</pre></section></summary><div class="docblock">Creates a ‚Äúby reference‚Äù adapter for this instance of <code>Write</code>. <a href="../../io/trait.write.html#method.by_ref">Read more</a>
</div>
</div>
<section id="impl-Eq-for-VecDeque%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/mod.rs.html#2699">source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Eq for VecDeque&lt;T, A&gt;
where
    T: Eq,
    A: Allocator,</pre></section>
</div>
<h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations</h2>
<div id="synthetic-implementations-list">
<section id="impl-RefUnwindSafe-for-VecDeque%3CT,+A%3E" class="impl"><pre class="code-header" data-language="rust">impl&lt;T, A&gt; RefUnwindSafe for VecDeque&lt;T, A&gt;
where
    A: RefUnwindSafe,
    T: RefUnwindSafe,</pre></section><section id="impl-Send-for-VecDeque%3CT,+A%3E" class="impl"><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Send for VecDeque&lt;T, A&gt;
where
    A: Send,
    T: Send,</pre></section><section id="impl-Sync-for-VecDeque%3CT,+A%3E" class="impl"><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Sync for VecDeque&lt;T, A&gt;
where
    A: Sync,
    T: Sync,</pre></section><section id="impl-Unpin-for-VecDeque%3CT,+A%3E" class="impl"><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Unpin for VecDeque&lt;T, A&gt;
where
    A: Unpin,
    T: Unpin,</pre></section><section id="impl-UnwindSafe-for-VecDeque%3CT,+A%3E" class="impl"><pre class="code-header" data-language="rust">impl&lt;T, A&gt; UnwindSafe for VecDeque&lt;T, A&gt;
where
    A: UnwindSafe,
    T: UnwindSafe,</pre></section>
</div>
<h2 id="blanket-implementations" class="small-section-header">Blanket Implementations</h2>
<div id="blanket-implementations-list">
<summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#135">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Any for T
where
    T: 'static + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#136">source</a><pre class="code-header" data-language="rust">fn type_id(&amp;self) -&gt; TypeId</pre></section></summary><div class="docblock">Gets the <code>TypeId</code> of <code>self</code>. <a href="../../any/trait.any.html#tymethod.type_id">Read more</a>
</div>
</div>
<summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#208">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Borrow&lt;T&gt; for T
where
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#210">source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="../../borrow/trait.borrow.html#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#216">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; BorrowMut&lt;T&gt; for T
where
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217">source</a><pre class="code-header" data-language="rust">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</pre></section></summary><div class="docblock">Mutably borrows from an owned value. <a href="../../borrow/trait.borrowmut.html#tymethod.borrow_mut">Read more</a>
</div>
</div>
<summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#763">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;T&gt; for T</pre></section></summary><div class="impl-items">
<summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#766">source</a><pre class="code-header" data-language="rust">fn from(t: T) -&gt; T</pre></section></summary><div class="docblock">
<p>Returns the argument unchanged.</p> </div>
</div>
<summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#747-749">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#756">source</a><pre class="code-header" data-language="rust">fn into(self) -&gt; U</pre></section></summary><div class="docblock">
<p>Calls <code>U::from(self)</code>.</p> <p>That is, this conversion is whatever the implementation of <code><a href="../../convert/trait.from.html" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p> </div>
</div>
<summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#83-85">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; ToOwned for T
where
    T: Clone,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Owned = T</pre></section></summary><div class="docblock">The resulting type after obtaining ownership.</div>
<summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#88">source</a><pre class="code-header" data-language="rust">fn to_owned(&amp;self) -&gt; T</pre></section></summary><div class="docblock">Creates owned data from borrowed data, usually by cloning. <a href="../../borrow/trait.toowned.html#tymethod.to_owned">Read more</a>
</div>
<summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#92">source</a><pre class="code-header" data-language="rust">fn clone_into(&amp;self, target: &amp;mut T)</pre></section></summary><div class="docblock">Uses borrowed data to replace owned data, usually by cloning. <a href="../../borrow/trait.toowned.html#method.clone_into">Read more</a>
</div>
</div>
<summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#803-805">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T
where
    U: Into&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Error = Infallible</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#810">source</a><pre class="code-header" data-language="rust">fn try_from(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
<summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#788-790">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryInto&lt;U&gt; for T
where
    U: TryFrom&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Error = &lt;U as TryFrom&lt;T&gt;&gt;::Error</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#795">source</a><pre class="code-header" data-language="rust">fn try_into(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/collections/vec_deque/struct.VecDeque.html" class="_attribution-link">https://doc.rust-lang.org/std/collections/vec_deque/struct.VecDeque.html</a>
  </p>
</div>
