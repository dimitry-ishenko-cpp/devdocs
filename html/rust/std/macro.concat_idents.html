<h1 class="main-heading">Macro std::concat_idents</h1>
<pre class="rust item-decl" data-language="rust">macro_rules! concat_idents {
    ($($e:ident),+ $(,)?) =&gt; { ... };
}</pre>
<span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>concat_idents</code> <a href="https://github.com/rust-lang/rust/issues/29599">#29599</a>)</span>
</div></span><p>Concatenates identifiers into one identifier.</p> <p>This macro takes any number of comma-separated identifiers, and concatenates them all into one, yielding an expression which is a new identifier. Note that hygiene makes it such that this macro cannot capture local variables. Also, as a general rule, macros are only allowed in item, statement or expression position. That means while you may use this macro for referring to existing variables, functions or modules etc, you cannot define a new one with it.</p> <h2 id="examples">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(concat_idents)]

fn foobar() -&gt; u32 { 23 }

let f = concat_idents!(foo, bar);
println!("{}", f());

// fn concat_idents!(new, fun, name) { } // not usable in this way!</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/macro.concat_idents.html" class="_attribution-link">https://doc.rust-lang.org/std/macro.concat_idents.html</a>
  </p>
</div>
