<h1 class="main-heading">Keyword match</h1>
<p>Control flow based on pattern matching.</p> <p><code>match</code> can be used to run code conditionally. Every pattern must be handled exhaustively either explicitly or by using wildcards like <code>_</code> in the <code>match</code>. Since <code>match</code> is an expression, values can also be returned.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let opt = Option::None::&lt;usize&gt;;
let x = match opt {
    Some(int) =&gt; int,
    None =&gt; 10,
};
assert_eq!(x, 10);

let a_number = Option::Some(10);
match a_number {
    Some(x) if x &lt;= 5 =&gt; println!("0 to 5 num = {x}"),
    Some(x @ 6..=10) =&gt; println!("6 to 10 num = {x}"),
    None =&gt; panic!(),
    // all other numbers
    _ =&gt; panic!(),
}</pre></div> <p><code>match</code> can be used to gain access to the inner members of an enum and use them directly.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">enum Outer {
    Double(Option&lt;u8&gt;, Option&lt;String&gt;),
    Single(Option&lt;u8&gt;),
    Empty
}

let get_inner = Outer::Double(None, Some(String::new()));
match get_inner {
    Outer::Double(None, Some(st)) =&gt; println!("{st}"),
    Outer::Single(opt) =&gt; println!("{opt:?}"),
    _ =&gt; panic!(),
}</pre></div> <p>For more information on <code>match</code> and matching in general, see the <a href="../reference/expressions/match-expr.html">Reference</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/keyword.match.html" class="_attribution-link">https://doc.rust-lang.org/std/keyword.match.html</a>
  </p>
</div>
