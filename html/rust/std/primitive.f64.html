<h1 class="main-heading">Primitive Type f64</h1>
<p>A 64-bit floating point type (specifically, the “binary64” type defined in IEEE 754-2008).</p> <p>This type is very similar to <a href="primitive.f32.html" title="primitive f32"><code>f32</code></a>, but has increased precision by using twice as many bits. Please see <a href="primitive.f32.html" title="primitive f32">the documentation for <code>f32</code></a> or <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">Wikipedia on double precision values</a> for more information.</p> <p><em><a href="f64/consts/index.html" title="mod std::f64::consts">See also the <code>std::f64::consts</code> module</a>.</em></p> <h3 id="implementations" class="section-header">Implementations</h3>
<div id="implementations-list">
<summary><section id="impl-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/f64.rs.html#31-1228">source</a><pre class="code-header" data-language="rust">impl f64</pre></section></summary><div class="impl-items">
<summary><section id="method.floor" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#51-53">source</a></span><pre class="code-header" data-language="rust">pub fn floor(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the largest integer less than or equal to <code>self</code>.</p> <p>This function always returns the precise result.</p> <h5 id="examples">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 3.7_f64;
let g = 3.0_f64;
let h = -3.7_f64;

assert_eq!(f.floor(), 3.0);
assert_eq!(g.floor(), 3.0);
assert_eq!(h.floor(), -4.0);</pre></div> </div>
<summary><section id="method.ceil" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#73-75">source</a></span><pre class="code-header" data-language="rust">pub fn ceil(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the smallest integer greater than or equal to <code>self</code>.</p> <p>This function always returns the precise result.</p> <h5 id="examples-1">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 3.01_f64;
let g = 4.0_f64;

assert_eq!(f.ceil(), 4.0);
assert_eq!(g.ceil(), 4.0);</pre></div> </div>
<summary><section id="method.round" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#101-103">source</a></span><pre class="code-header" data-language="rust">pub fn round(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the nearest integer to <code>self</code>. If a value is half-way between two integers, round away from <code>0.0</code>.</p> <p>This function always returns the precise result.</p> <h5 id="examples-2">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 3.3_f64;
let g = -3.3_f64;
let h = -3.7_f64;
let i = 3.5_f64;
let j = 4.5_f64;

assert_eq!(f.round(), 3.0);
assert_eq!(g.round(), -3.0);
assert_eq!(h.round(), -4.0);
assert_eq!(i.round(), 4.0);
assert_eq!(j.round(), 5.0);</pre></div> </div>
<summary><section id="method.round_ties_even" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.77.0">1.77.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#127-129">source</a></span><pre class="code-header" data-language="rust">pub fn round_ties_even(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the nearest integer to a number. Rounds half-way cases to the number with an even least significant digit.</p> <p>This function always returns the precise result.</p> <h5 id="examples-3">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 3.3_f64;
let g = -3.3_f64;
let h = 3.5_f64;
let i = 4.5_f64;

assert_eq!(f.round_ties_even(), 3.0);
assert_eq!(g.round_ties_even(), -3.0);
assert_eq!(h.round_ties_even(), 4.0);
assert_eq!(i.round_ties_even(), 4.0);</pre></div> </div>
<summary><section id="method.trunc" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#152-154">source</a></span><pre class="code-header" data-language="rust">pub fn trunc(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the integer part of <code>self</code>. This means that non-integer numbers are always truncated towards zero.</p> <p>This function always returns the precise result.</p> <h5 id="examples-4">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 3.7_f64;
let g = 3.0_f64;
let h = -3.7_f64;

assert_eq!(f.trunc(), 3.0);
assert_eq!(g.trunc(), 3.0);
assert_eq!(h.trunc(), -3.0);</pre></div> </div>
<summary><section id="method.fract" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#175-177">source</a></span><pre class="code-header" data-language="rust">pub fn fract(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the fractional part of <code>self</code>.</p> <p>This function always returns the precise result.</p> <h5 id="examples-5">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 3.6_f64;
let y = -3.6_f64;
let abs_difference_x = (x.fract() - 0.6).abs();
let abs_difference_y = (y.fract() - (-0.6)).abs();

assert!(abs_difference_x &lt; 1e-10);
assert!(abs_difference_y &lt; 1e-10);</pre></div> </div>
<summary><section id="method.abs" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#198-200">source</a></span><pre class="code-header" data-language="rust">pub fn abs(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Computes the absolute value of <code>self</code>.</p> <p>This function always returns the precise result.</p> <h5 id="examples-6">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 3.5_f64;
let y = -3.5_f64;

assert_eq!(x.abs(), x);
assert_eq!(y.abs(), -y);

assert!(f64::NAN.abs().is_nan());</pre></div> </div>
<summary><section id="method.signum" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#222-224">source</a></span><pre class="code-header" data-language="rust">pub fn signum(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns a number that represents the sign of <code>self</code>.</p> <ul> <li>
<code>1.0</code> if the number is positive, <code>+0.0</code> or <code>INFINITY</code>
</li> <li>
<code>-1.0</code> if the number is negative, <code>-0.0</code> or <code>NEG_INFINITY</code>
</li> <li>NaN if the number is NaN</li> </ul> <h5 id="examples-7">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 3.5_f64;

assert_eq!(f.signum(), 1.0);
assert_eq!(f64::NEG_INFINITY.signum(), -1.0);

assert!(f64::NAN.signum().is_nan());</pre></div> </div>
<summary><section id="method.copysign" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.35.0">1.35.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#251-253">source</a></span><pre class="code-header" data-language="rust">pub fn copysign(self, sign: f64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns a number composed of the magnitude of <code>self</code> and the sign of <code>sign</code>.</p> <p>Equal to <code>self</code> if the sign of <code>self</code> and <code>sign</code> are the same, otherwise equal to <code>-self</code>. If <code>self</code> is a NaN, then a NaN with the sign bit of <code>sign</code> is returned. Note, however, that conserving the sign bit on NaN across arithmetical operations is not generally guaranteed. See <a href="primitive.f32.html" title="primitive f32">explanation of NaN as a special value</a> for more info.</p> <h5 id="examples-8">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 3.5_f64;

assert_eq!(f.copysign(0.42), 3.5_f64);
assert_eq!(f.copysign(-0.42), -3.5_f64);
assert_eq!((-f).copysign(0.42), 3.5_f64);
assert_eq!((-f).copysign(-0.42), -3.5_f64);

assert!(f64::NAN.copysign(1.0).is_nan());</pre></div> </div>
<summary><section id="method.mul_add" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#292-294">source</a></span><pre class="code-header" data-language="rust">pub fn mul_add(self, a: f64, b: f64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Fused multiply-add. Computes <code>(self * a) + b</code> with only one rounding error, yielding a more accurate result than an unfused multiply-add.</p> <p>Using <code>mul_add</code> <em>may</em> be more performant than an unfused multiply-add if the target architecture has a dedicated <code>fma</code> CPU instruction. However, this is not always true, and will be heavily dependant on designing algorithms with specific target hardware in mind.</p> <h5 id="precision">Precision</h5> <p>The result of this operation is guaranteed to be the rounded infinite-precision result. It is specified by IEEE 754 as <code>fusedMultiplyAdd</code> and guaranteed not to change.</p> <h5 id="examples-9">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let m = 10.0_f64;
let x = 4.0_f64;
let b = 60.0_f64;

assert_eq!(m.mul_add(x, b), 100.0);
assert_eq!(m * x + b, 100.0);

let one_plus_eps = 1.0_f64 + f64::EPSILON;
let one_minus_eps = 1.0_f64 - f64::EPSILON;
let minus_one = -1.0_f64;

// The exact result (1 + eps) * (1 - eps) = 1 - eps * eps.
assert_eq!(one_plus_eps.mul_add(one_minus_eps, minus_one), -f64::EPSILON * f64::EPSILON);
// Different rounding with the non-fused multiply and add.
assert_eq!(one_plus_eps * one_minus_eps + minus_one, 0.0);</pre></div> </div>
<summary><section id="method.div_euclid" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#322-328">source</a></span><pre class="code-header" data-language="rust">pub fn div_euclid(self, rhs: f64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Calculates Euclidean division, the matching method for <code>rem_euclid</code>.</p> <p>This computes the integer <code>n</code> such that <code>self = n * rhs + self.rem_euclid(rhs)</code>. In other words, the result is <code>self / rhs</code> rounded to the integer <code>n</code> such that <code>self &gt;= n * rhs</code>.</p> <h5 id="precision-1">Precision</h5> <p>The result of this operation is guaranteed to be the rounded infinite-precision result.</p> <h5 id="examples-10">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a: f64 = 7.0;
let b = 4.0;
assert_eq!(a.div_euclid(b), 1.0); // 7.0 &gt; 4.0 * 1.0
assert_eq!((-a).div_euclid(b), -2.0); // -7.0 &gt;= 4.0 * -2.0
assert_eq!(a.div_euclid(-b), -1.0); // 7.0 &gt;= -4.0 * -1.0
assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 &gt;= -4.0 * 2.0</pre></div> </div>
<summary><section id="method.rem_euclid" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#363-366">source</a></span><pre class="code-header" data-language="rust">pub fn rem_euclid(self, rhs: f64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Calculates the least nonnegative remainder of <code>self (mod rhs)</code>.</p> <p>In particular, the return value <code>r</code> satisfies <code>0.0 &lt;= r &lt; rhs.abs()</code> in most cases. However, due to a floating point round-off error it can result in <code>r == rhs.abs()</code>, violating the mathematical definition, if <code>self</code> is much smaller than <code>rhs.abs()</code> in magnitude and <code>self &lt; 0.0</code>. This result is not an element of the function’s codomain, but it is the closest floating point number in the real numbers and thus fulfills the property <code>self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)</code> approximately.</p> <h5 id="precision-2">Precision</h5> <p>The result of this operation is guaranteed to be the rounded infinite-precision result.</p> <h5 id="examples-11">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a: f64 = 7.0;
let b = 4.0;
assert_eq!(a.rem_euclid(b), 3.0);
assert_eq!((-a).rem_euclid(b), 1.0);
assert_eq!(a.rem_euclid(-b), 3.0);
assert_eq!((-a).rem_euclid(-b), 1.0);
// limitation due to round-off error
assert!((-f64::EPSILON).rem_euclid(3.0) != 0.0);</pre></div> </div>
<summary><section id="method.powi" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#391-393">source</a></span><pre class="code-header" data-language="rust">pub fn powi(self, n: i32) -&gt; f64</pre></section></summary><div class="docblock">
<p>Raises a number to an integer power.</p> <p>Using this function is generally faster than using <code>powf</code>. It might have a different sequence of rounding operations than <code>powf</code>, so the results are not guaranteed to agree.</p> <h5 id="unspecified-precision">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-12">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 2.0_f64;
let abs_difference = (x.powi(2) - (x * x)).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.powf" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#414-416">source</a></span><pre class="code-header" data-language="rust">pub fn powf(self, n: f64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Raises a number to a floating point power.</p> <h5 id="unspecified-precision-1">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-13">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 2.0_f64;
let abs_difference = (x.powf(2.0) - (x * x)).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.sqrt" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#443-445">source</a></span><pre class="code-header" data-language="rust">pub fn sqrt(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the square root of a number.</p> <p>Returns NaN if <code>self</code> is a negative number other than <code>-0.0</code>.</p> <h5 id="precision-3">Precision</h5> <p>The result of this operation is guaranteed to be the rounded infinite-precision result. It is specified by IEEE 754 as <code>squareRoot</code> and guaranteed not to change.</p> <h5 id="examples-14">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let positive = 4.0_f64;
let negative = -4.0_f64;
let negative_zero = -0.0_f64;

assert_eq!(positive.sqrt(), 2.0);
assert!(negative.sqrt().is_nan());
assert!(negative_zero.sqrt() == negative_zero);</pre></div> </div>
<summary><section id="method.exp" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#470-472">source</a></span><pre class="code-header" data-language="rust">pub fn exp(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns <code>e^(self)</code>, (the exponential function).</p> <h5 id="unspecified-precision-2">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-15">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let one = 1.0_f64;
// e^1
let e = one.exp();

// ln(e) - 1 == 0
let abs_difference = (e.ln() - 1.0).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.exp2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#495-497">source</a></span><pre class="code-header" data-language="rust">pub fn exp2(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns <code>2^(self)</code>.</p> <h5 id="unspecified-precision-3">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-16">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 2.0_f64;

// 2^2 - 4 == 0
let abs_difference = (f.exp2() - 4.0).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.ln" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#522-524">source</a></span><pre class="code-header" data-language="rust">pub fn ln(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the natural logarithm of the number.</p> <h5 id="unspecified-precision-4">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-17">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let one = 1.0_f64;
// e^1
let e = one.exp();

// ln(e) - 1 == 0
let abs_difference = (e.ln() - 1.0).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.log" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#551-553">source</a></span><pre class="code-header" data-language="rust">pub fn log(self, base: f64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the logarithm of the number with respect to an arbitrary base.</p> <p>The result might not be correctly rounded owing to implementation details; <code>self.log2()</code> can produce more accurate results for base 2, and <code>self.log10()</code> can produce more accurate results for base 10.</p> <h5 id="unspecified-precision-5">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-18">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let twenty_five = 25.0_f64;

// log5(25) - 2 == 0
let abs_difference = (twenty_five.log(5.0) - 2.0).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.log2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#576-578">source</a></span><pre class="code-header" data-language="rust">pub fn log2(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the base 2 logarithm of the number.</p> <h5 id="unspecified-precision-6">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-19">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let four = 4.0_f64;

// log2(4) - 2 == 0
let abs_difference = (four.log2() - 2.0).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.log10" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#601-603">source</a></span><pre class="code-header" data-language="rust">pub fn log10(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the base 10 logarithm of the number.</p> <h5 id="unspecified-precision-7">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-20">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let hundred = 100.0_f64;

// log10(100) - 2 == 0
let abs_difference = (hundred.log10() - 2.0).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.abs_sub" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#643-645">source</a></span><pre class="code-header" data-language="rust">pub fn abs_sub(self, other: f64) -&gt; f64</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.10.0: you probably meant <code>(self - other).abs()</code>: this operation is <code>(self - other).max(0.0)</code> except that <code>abs_sub</code> also propagates NaNs (also known as <code>fdim</code> in C). If you truly need the positive difference, consider using that expression or the C function <code>fdim</code>, depending on how you wish to handle NaN (please consider filing an issue describing your use-case too).</span>
</div></span></summary><div class="docblock">
<p>The positive difference of two numbers.</p> <ul> <li>If <code>self &lt;= other</code>: <code>0.0</code>
</li> <li>Else: <code>self - other</code>
</li> </ul> <h5 id="unspecified-precision-8">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>fdim</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-21">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 3.0_f64;
let y = -3.0_f64;

let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();
let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();

assert!(abs_difference_x &lt; 1e-10);
assert!(abs_difference_y &lt; 1e-10);</pre></div> </div>
<summary><section id="method.cbrt" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#670-672">source</a></span><pre class="code-header" data-language="rust">pub fn cbrt(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the cube root of a number.</p> <h5 id="unspecified-precision-9">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>cbrt</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-22">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 8.0_f64;

// x^(1/3) - 2 == 0
let abs_difference = (x.cbrt() - 2.0).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.hypot" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#701-703">source</a></span><pre class="code-header" data-language="rust">pub fn hypot(self, other: f64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Compute the distance between the origin and a point (<code>x</code>, <code>y</code>) on the Euclidean plane. Equivalently, compute the length of the hypotenuse of a right-angle triangle with other sides having length <code>x.abs()</code> and <code>y.abs()</code>.</p> <h5 id="unspecified-precision-10">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>hypot</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-23">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 2.0_f64;
let y = 3.0_f64;

// sqrt(x^2 + y^2)
let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.sin" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#725-727">source</a></span><pre class="code-header" data-language="rust">pub fn sin(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Computes the sine of a number (in radians).</p> <h5 id="unspecified-precision-11">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-24">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = std::f64::consts::FRAC_PI_2;

let abs_difference = (x.sin() - 1.0).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.cos" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#749-751">source</a></span><pre class="code-header" data-language="rust">pub fn cos(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Computes the cosine of a number (in radians).</p> <h5 id="unspecified-precision-12">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-25">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 2.0 * std::f64::consts::PI;

let abs_difference = (x.cos() - 1.0).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.tan" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#774-776">source</a></span><pre class="code-header" data-language="rust">pub fn tan(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Computes the tangent of a number (in radians).</p> <h5 id="unspecified-precision-13">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>tan</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-26">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = std::f64::consts::FRAC_PI_4;
let abs_difference = (x.tan() - 1.0).abs();

assert!(abs_difference &lt; 1e-14);</pre></div> </div>
<summary><section id="method.asin" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#804-806">source</a></span><pre class="code-header" data-language="rust">pub fn asin(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].</p> <h5 id="unspecified-precision-14">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>asin</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-27">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = std::f64::consts::FRAC_PI_2;

// asin(sin(pi/2))
let abs_difference = (f.sin().asin() - std::f64::consts::FRAC_PI_2).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.acos" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#834-836">source</a></span><pre class="code-header" data-language="rust">pub fn acos(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].</p> <h5 id="unspecified-precision-15">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>acos</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-28">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = std::f64::consts::FRAC_PI_4;

// acos(cos(pi/4))
let abs_difference = (f.cos().acos() - std::f64::consts::FRAC_PI_4).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.atan" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#863-865">source</a></span><pre class="code-header" data-language="rust">pub fn atan(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];</p> <h5 id="unspecified-precision-16">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>atan</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-29">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 1.0_f64;

// atan(tan(1))
let abs_difference = (f.tan().atan() - 1.0).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.atan2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#904-906">source</a></span><pre class="code-header" data-language="rust">pub fn atan2(self, other: f64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Computes the four quadrant arctangent of <code>self</code> (<code>y</code>) and <code>other</code> (<code>x</code>) in radians.</p> <ul> <li>
<code>x = 0</code>, <code>y = 0</code>: <code>0</code>
</li> <li>
<code>x &gt;= 0</code>: <code>arctan(y/x)</code> -&gt; <code>[-pi/2, pi/2]</code>
</li> <li>
<code>y &gt;= 0</code>: <code>arctan(y/x) + pi</code> -&gt; <code>(pi/2, pi]</code>
</li> <li>
<code>y &lt; 0</code>: <code>arctan(y/x) - pi</code> -&gt; <code>(-pi, -pi/2)</code>
</li> </ul> <h5 id="unspecified-precision-17">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>atan2</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-30">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">// Positive angles measured counter-clockwise
// from positive x axis
// -pi/4 radians (45 deg clockwise)
let x1 = 3.0_f64;
let y1 = -3.0_f64;

// 3pi/4 radians (135 deg counter-clockwise)
let x2 = -3.0_f64;
let y2 = 3.0_f64;

let abs_difference_1 = (y1.atan2(x1) - (-std::f64::consts::FRAC_PI_4)).abs();
let abs_difference_2 = (y2.atan2(x2) - (3.0 * std::f64::consts::FRAC_PI_4)).abs();

assert!(abs_difference_1 &lt; 1e-10);
assert!(abs_difference_2 &lt; 1e-10);</pre></div> </div>
<summary><section id="method.sin_cos" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#934-936">source</a></span><pre class="code-header" data-language="rust">pub fn sin_cos(self) -&gt; (f64, f64)</pre></section></summary><div class="docblock">
<p>Simultaneously computes the sine and cosine of the number, <code>x</code>. Returns <code>(sin(x), cos(x))</code>.</p> <h5 id="unspecified-precision-18">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>(f64::sin(x), f64::cos(x))</code>. Note that this might change in the future.</p> <h5 id="examples-31">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = std::f64::consts::FRAC_PI_4;
let f = x.sin_cos();

let abs_difference_0 = (f.0 - x.sin()).abs();
let abs_difference_1 = (f.1 - x.cos()).abs();

assert!(abs_difference_0 &lt; 1e-10);
assert!(abs_difference_1 &lt; 1e-10);</pre></div> </div>
<summary><section id="method.exp_m1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#963-965">source</a></span><pre class="code-header" data-language="rust">pub fn exp_m1(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns <code>e^(self) - 1</code> in a way that is accurate even if the number is close to zero.</p> <h5 id="unspecified-precision-19">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>expm1</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-32">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 1e-16_f64;

// for very small x, e^x is approximately 1 + x + x^2 / 2
let approx = x + x * x / 2.0;
let abs_difference = (x.exp_m1() - approx).abs();

assert!(abs_difference &lt; 1e-20);</pre></div> </div>
<summary><section id="method.ln_1p" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#993-995">source</a></span><pre class="code-header" data-language="rust">pub fn ln_1p(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns <code>ln(1+n)</code> (natural logarithm) more accurately than if the operations were performed separately.</p> <h5 id="unspecified-precision-20">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>log1p</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-33">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 1e-16_f64;

// for very small x, ln(1 + x) is approximately x - x^2 / 2
let approx = x - x * x / 2.0;
let abs_difference = (x.ln_1p() - approx).abs();

assert!(abs_difference &lt; 1e-20);</pre></div> </div>
<summary><section id="method.sinh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#1023-1025">source</a></span><pre class="code-header" data-language="rust">pub fn sinh(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Hyperbolic sine function.</p> <h5 id="unspecified-precision-21">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>sinh</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-34">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let e = std::f64::consts::E;
let x = 1.0_f64;

let f = x.sinh();
// Solving sinh() at 1 gives `(e^2-1)/(2e)`
let g = ((e * e) - 1.0) / (2.0 * e);
let abs_difference = (f - g).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.cosh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#1053-1055">source</a></span><pre class="code-header" data-language="rust">pub fn cosh(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Hyperbolic cosine function.</p> <h5 id="unspecified-precision-22">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>cosh</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-35">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let e = std::f64::consts::E;
let x = 1.0_f64;
let f = x.cosh();
// Solving cosh() at 1 gives this result
let g = ((e * e) + 1.0) / (2.0 * e);
let abs_difference = (f - g).abs();

// Same result
assert!(abs_difference &lt; 1.0e-10);</pre></div> </div>
<summary><section id="method.tanh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#1083-1085">source</a></span><pre class="code-header" data-language="rust">pub fn tanh(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Hyperbolic tangent function.</p> <h5 id="unspecified-precision-23">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>tanh</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-36">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let e = std::f64::consts::E;
let x = 1.0_f64;

let f = x.tanh();
// Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`
let g = (1.0 - e.powi(-2)) / (1.0 + e.powi(-2));
let abs_difference = (f - g).abs();

assert!(abs_difference &lt; 1.0e-10);</pre></div> </div>
<summary><section id="method.asinh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#1109-1113">source</a></span><pre class="code-header" data-language="rust">pub fn asinh(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Inverse hyperbolic sine function.</p> <h5 id="unspecified-precision-24">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-37">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 1.0_f64;
let f = x.sinh().asinh();

let abs_difference = (f - x).abs();

assert!(abs_difference &lt; 1.0e-10);</pre></div> </div>
<summary><section id="method.acosh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#1137-1143">source</a></span><pre class="code-header" data-language="rust">pub fn acosh(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Inverse hyperbolic cosine function.</p> <h5 id="unspecified-precision-25">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-38">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 1.0_f64;
let f = x.cosh().acosh();

let abs_difference = (f - x).abs();

assert!(abs_difference &lt; 1.0e-10);</pre></div> </div>
<summary><section id="method.atanh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/f64.rs.html#1167-1169">source</a></span><pre class="code-header" data-language="rust">pub fn atanh(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Inverse hyperbolic tangent function.</p> <h5 id="unspecified-precision-26">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next.</p> <h5 id="examples-39">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let e = std::f64::consts::E;
let f = e.tanh().atanh();

let abs_difference = (f - e).abs();

assert!(abs_difference &lt; 1.0e-10);</pre></div> </div>
<summary><section id="method.gamma" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/f64.rs.html#1194-1196">source</a><pre class="code-header" data-language="rust">pub fn gamma(self) -&gt; f64</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_gamma</code> <a href="https://github.com/rust-lang/rust/issues/99842">#99842</a>)</span>
</div></span></summary><div class="docblock">
<p>Gamma function.</p> <h5 id="unspecified-precision-27">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>tgamma</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-40">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(float_gamma)]
let x = 5.0f64;

let abs_difference = (x.gamma() - 24.0).abs();

assert!(abs_difference &lt;= f64::EPSILON);</pre></div> </div>
<summary><section id="method.ln_gamma" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/f64.rs.html#1223-1227">source</a><pre class="code-header" data-language="rust">pub fn ln_gamma(self) -&gt; (f64, i32)</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_gamma</code> <a href="https://github.com/rust-lang/rust/issues/99842">#99842</a>)</span>
</div></span></summary><div class="docblock">
<p>Natural logarithm of the absolute value of the gamma function</p> <p>The integer part of the tuple indicates the sign of the gamma function.</p> <h5 id="unspecified-precision-28">Unspecified precision</h5> <p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and can even differ within the same execution from one invocation to the next. This function currently corresponds to the <code>lgamma_r</code> from libc on Unix and Windows. Note that this might change in the future.</p> <h5 id="examples-41">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(float_gamma)]
let x = 2.0f64;

let abs_difference = (x.ln_gamma().0 - 0.0).abs();

assert!(abs_difference &lt;= f64::EPSILON);</pre></div> </div>
</div>
<summary><section id="impl-f64-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#384">source</a><pre class="code-header" data-language="rust">impl f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedconstant.RADIX" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#387">source</a></span><pre class="code-header" data-language="rust">pub const RADIX: u32 = 2u32</pre></section></summary><div class="docblock">
<p>The radix or base of the internal representation of <code>f64</code>.</p> </div>
<summary><section id="associatedconstant.MANTISSA_DIGITS" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#391">source</a></span><pre class="code-header" data-language="rust">pub const MANTISSA_DIGITS: u32 = 53u32</pre></section></summary><div class="docblock">
<p>Number of significant digits in base 2.</p> </div>
<summary><section id="associatedconstant.DIGITS" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#401">source</a></span><pre class="code-header" data-language="rust">pub const DIGITS: u32 = 15u32</pre></section></summary><div class="docblock">
<p>Approximate number of significant digits in base 10.</p> <p>This is the maximum <i>x</i> such that any decimal number with <i>x</i> significant digits can be converted to <code>f64</code> and back without loss.</p> <p>Equal to floor(log<sub>10</sub> 2<sup><a href="primitive.f64.html#associatedconstant.MANTISSA_DIGITS" title="associated constant f64::MANTISSA_DIGITS"><code>MANTISSA_DIGITS</code></a> − 1</sup>).</p> </div>
<summary><section id="associatedconstant.EPSILON" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#412">source</a></span><pre class="code-header" data-language="rust">pub const EPSILON: f64 = 2.2204460492503131E-16f64</pre></section></summary><div class="docblock">
<p><a href="https://en.wikipedia.org/wiki/Machine_epsilon">Machine epsilon</a> value for <code>f64</code>.</p> <p>This is the difference between <code>1.0</code> and the next larger representable number.</p> <p>Equal to 2<sup>1 − <a href="primitive.f64.html#associatedconstant.MANTISSA_DIGITS" title="associated constant f64::MANTISSA_DIGITS"><code>MANTISSA_DIGITS</code></a></sup>.</p> </div>
<summary><section id="associatedconstant.MIN" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#420">source</a></span><pre class="code-header" data-language="rust">pub const MIN: f64 = -1.7976931348623157E+308f64</pre></section></summary><div class="docblock">
<p>Smallest finite <code>f64</code> value.</p> <p>Equal to −<a href="primitive.f64.html#associatedconstant.MAX" title="associated constant f64::MAX"><code>MAX</code></a>.</p> </div>
<summary><section id="associatedconstant.MIN_POSITIVE" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#427">source</a></span><pre class="code-header" data-language="rust">pub const MIN_POSITIVE: f64 = 2.2250738585072014E-308f64</pre></section></summary><div class="docblock">
<p>Smallest positive normal <code>f64</code> value.</p> <p>Equal to 2<sup><a href="primitive.f64.html#associatedconstant.MIN_EXP" title="associated constant f64::MIN_EXP"><code>MIN_EXP</code></a> − 1</sup>.</p> </div>
<summary><section id="associatedconstant.MAX" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#436">source</a></span><pre class="code-header" data-language="rust">pub const MAX: f64 = 1.7976931348623157E+308f64</pre></section></summary><div class="docblock">
<p>Largest finite <code>f64</code> value.</p> <p>Equal to (1 − 2<sup>−<a href="primitive.f64.html#associatedconstant.MANTISSA_DIGITS" title="associated constant f64::MANTISSA_DIGITS"><code>MANTISSA_DIGITS</code></a></sup>) 2<sup><a href="primitive.f64.html#associatedconstant.MAX_EXP" title="associated constant f64::MAX_EXP"><code>MAX_EXP</code></a></sup>.</p> </div>
<summary><section id="associatedconstant.MIN_EXP" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#443">source</a></span><pre class="code-header" data-language="rust">pub const MIN_EXP: i32 = -1_021i32</pre></section></summary><div class="docblock">
<p>One greater than the minimum possible normal power of 2 exponent.</p> <p>If <i>x</i> = <code>MIN_EXP</code>, then normal numbers ≥ 0.5 × 2<sup><i>x</i></sup>.</p> </div>
<summary><section id="associatedconstant.MAX_EXP" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#449">source</a></span><pre class="code-header" data-language="rust">pub const MAX_EXP: i32 = 1_024i32</pre></section></summary><div class="docblock">
<p>Maximum possible power of 2 exponent.</p> <p>If <i>x</i> = <code>MAX_EXP</code>, then normal numbers &lt; 1 × 2<sup><i>x</i></sup>.</p> </div>
<summary><section id="associatedconstant.MIN_10_EXP" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#457">source</a></span><pre class="code-header" data-language="rust">pub const MIN_10_EXP: i32 = -307i32</pre></section></summary><div class="docblock">
<p>Minimum <i>x</i> for which 10<sup><i>x</i></sup> is normal.</p> <p>Equal to ceil(log<sub>10</sub> <a href="primitive.f64.html#associatedconstant.MIN_POSITIVE" title="associated constant f64::MIN_POSITIVE"><code>MIN_POSITIVE</code></a>).</p> </div>
<summary><section id="associatedconstant.MAX_10_EXP" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#464">source</a></span><pre class="code-header" data-language="rust">pub const MAX_10_EXP: i32 = 308i32</pre></section></summary><div class="docblock">
<p>Maximum <i>x</i> for which 10<sup><i>x</i></sup> is normal.</p> <p>Equal to floor(log<sub>10</sub> <a href="primitive.f64.html#associatedconstant.MAX" title="associated constant f64::MAX"><code>MAX</code></a>).</p> </div>
<summary><section id="associatedconstant.NAN" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#479">source</a></span><pre class="code-header" data-language="rust">pub const NAN: f64 = NaN_f64</pre></section></summary><div class="docblock">
<p>Not a Number (NaN).</p> <p>Note that IEEE 754 doesn’t define just a single NaN value; a plethora of bit patterns are considered to be NaN. Furthermore, the standard makes a difference between a “signaling” and a “quiet” NaN, and allows inspecting its “payload” (the unspecified bits in the bit pattern). This constant isn’t guaranteed to equal to any specific NaN bitpattern, and the stability of its representation over Rust versions and target platforms isn’t guaranteed.</p> </div>
<summary><section id="associatedconstant.INFINITY" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#482">source</a></span><pre class="code-header" data-language="rust">pub const INFINITY: f64 = +Inf_f64</pre></section></summary><div class="docblock">
<p>Infinity (∞).</p> </div>
<summary><section id="associatedconstant.NEG_INFINITY" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#485">source</a></span><pre class="code-header" data-language="rust">pub const NEG_INFINITY: f64 = -Inf_f64</pre></section></summary><div class="docblock">
<p>Negative infinity (−∞).</p> </div>
<summary><section id="method.is_nan" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/72505" title="Tracking issue for const_float_classify">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#501">source</a></span><pre class="code-header" data-language="rust">pub fn is_nan(self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if this value is NaN.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let nan = f64::NAN;
let f = 7.0_f64;

assert!(nan.is_nan());
assert!(!f.is_nan());</pre></div> </div>
<summary><section id="method.is_infinite" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/72505" title="Tracking issue for const_float_classify">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#536">source</a></span><pre class="code-header" data-language="rust">pub fn is_infinite(self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if this value is positive infinity or negative infinity, and <code>false</code> otherwise.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 7.0f64;
let inf = f64::INFINITY;
let neg_inf = f64::NEG_INFINITY;
let nan = f64::NAN;

assert!(!f.is_infinite());
assert!(!nan.is_infinite());

assert!(inf.is_infinite());
assert!(neg_inf.is_infinite());</pre></div> </div>
<summary><section id="method.is_finite" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/72505" title="Tracking issue for const_float_classify">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#561">source</a></span><pre class="code-header" data-language="rust">pub fn is_finite(self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if this number is neither infinite nor NaN.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 7.0f64;
let inf: f64 = f64::INFINITY;
let neg_inf: f64 = f64::NEG_INFINITY;
let nan: f64 = f64::NAN;

assert!(f.is_finite());

assert!(!nan.is_finite());
assert!(!inf.is_finite());
assert!(!neg_inf.is_finite());</pre></div> </div>
<summary><section id="method.is_subnormal" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.53.0, const unstable">1.53.0 (const: <a href="https://github.com/rust-lang/rust/issues/72505" title="Tracking issue for const_float_classify">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#589">source</a></span><pre class="code-header" data-language="rust">pub fn is_subnormal(self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the number is <a href="https://en.wikipedia.org/wiki/Denormal_number">subnormal</a>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308_f64
let max = f64::MAX;
let lower_than_min = 1.0e-308_f64;
let zero = 0.0_f64;

assert!(!min.is_subnormal());
assert!(!max.is_subnormal());

assert!(!zero.is_subnormal());
assert!(!f64::NAN.is_subnormal());
assert!(!f64::INFINITY.is_subnormal());
// Values between `0` and `min` are Subnormal.
assert!(lower_than_min.is_subnormal());</pre></div> </div>
<summary><section id="method.is_normal" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/72505" title="Tracking issue for const_float_classify">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#616">source</a></span><pre class="code-header" data-language="rust">pub fn is_normal(self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the number is neither zero, infinite, <a href="https://en.wikipedia.org/wiki/Denormal_number">subnormal</a>, or NaN.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308f64
let max = f64::MAX;
let lower_than_min = 1.0e-308_f64;
let zero = 0.0f64;

assert!(min.is_normal());
assert!(max.is_normal());

assert!(!zero.is_normal());
assert!(!f64::NAN.is_normal());
assert!(!f64::INFINITY.is_normal());
// Values between `0` and `min` are Subnormal.
assert!(!lower_than_min.is_normal());</pre></div> </div>
<summary><section id="method.classify" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/72505" title="Tracking issue for const_float_classify">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#635">source</a></span><pre class="code-header" data-language="rust">pub fn classify(self) -&gt; FpCategory</pre></section></summary><div class="docblock">
<p>Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::num::FpCategory;

let num = 12.4_f64;
let inf = f64::INFINITY;

assert_eq!(num.classify(), FpCategory::Normal);
assert_eq!(inf.classify(), FpCategory::Infinite);</pre></div> </div>
<summary><section id="method.is_sign_positive" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/72505" title="Tracking issue for const_float_classify">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#719">source</a></span><pre class="code-header" data-language="rust">pub fn is_sign_positive(self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if <code>self</code> has a positive sign, including <code>+0.0</code>, NaNs with positive sign bit and positive infinity. Note that IEEE 754 doesn’t assign any meaning to the sign bit in case of a NaN, and as Rust doesn’t guarantee that the bit pattern of NaNs are conserved over arithmetic operations, the result of <code>is_sign_positive</code> on a NaN might produce an unexpected result in some cases. See <a href="primitive.f32.html" title="primitive f32">explanation of NaN as a special value</a> for more info.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 7.0_f64;
let g = -7.0_f64;

assert!(f.is_sign_positive());
assert!(!g.is_sign_positive());</pre></div> </div>
<summary><section id="method.is_sign_negative" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/72505" title="Tracking issue for const_float_classify">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#750">source</a></span><pre class="code-header" data-language="rust">pub fn is_sign_negative(self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if <code>self</code> has a negative sign, including <code>-0.0</code>, NaNs with negative sign bit and negative infinity. Note that IEEE 754 doesn’t assign any meaning to the sign bit in case of a NaN, and as Rust doesn’t guarantee that the bit pattern of NaNs are conserved over arithmetic operations, the result of <code>is_sign_negative</code> on a NaN might produce an unexpected result in some cases. See <a href="primitive.f32.html" title="primitive f32">explanation of NaN as a special value</a> for more info.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f = 7.0_f64;
let g = -7.0_f64;

assert!(!f.is_sign_negative());
assert!(g.is_sign_negative());</pre></div> </div>
<summary><section id="method.next_up" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#794">source</a><pre class="code-header" data-language="rust">pub const fn next_up(self) -&gt; f64</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_next_up_down</code> <a href="https://github.com/rust-lang/rust/issues/91399">#91399</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns the least number greater than <code>self</code>.</p> <p>Let <code>TINY</code> be the smallest representable positive <code>f64</code>. Then,</p> <ul> <li>if <code>self.is_nan()</code>, this returns <code>self</code>;</li> <li>if <code>self</code> is <a href="primitive.f64.html#associatedconstant.NEG_INFINITY" title="associated constant f64::NEG_INFINITY"><code>NEG_INFINITY</code></a>, this returns <a href="primitive.f64.html#associatedconstant.MIN" title="associated constant f64::MIN"><code>MIN</code></a>;</li> <li>if <code>self</code> is <code>-TINY</code>, this returns -0.0;</li> <li>if <code>self</code> is -0.0 or +0.0, this returns <code>TINY</code>;</li> <li>if <code>self</code> is <a href="primitive.f64.html#associatedconstant.MAX" title="associated constant f64::MAX"><code>MAX</code></a> or <a href="primitive.f64.html#associatedconstant.INFINITY" title="associated constant f64::INFINITY"><code>INFINITY</code></a>, this returns <a href="primitive.f64.html#associatedconstant.INFINITY" title="associated constant f64::INFINITY"><code>INFINITY</code></a>;</li> <li>otherwise the unique least value greater than <code>self</code> is returned.</li> </ul> <p>The identity <code>x.next_up() == -(-x).next_down()</code> holds for all non-NaN <code>x</code>. When <code>x</code> is finite <code>x == x.next_up().next_down()</code> also holds.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(float_next_up_down)]
// f64::EPSILON is the difference between 1.0 and the next number up.
assert_eq!(1.0f64.next_up(), 1.0 + f64::EPSILON);
// But not for most numbers.
assert!(0.1f64.next_up() &lt; 0.1 + f64::EPSILON);
assert_eq!(9007199254740992f64.next_up(), 9007199254740994.0);</pre></div> </div>
<summary><section id="method.next_down" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#844">source</a><pre class="code-header" data-language="rust">pub const fn next_down(self) -&gt; f64</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_next_up_down</code> <a href="https://github.com/rust-lang/rust/issues/91399">#91399</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns the greatest number less than <code>self</code>.</p> <p>Let <code>TINY</code> be the smallest representable positive <code>f64</code>. Then,</p> <ul> <li>if <code>self.is_nan()</code>, this returns <code>self</code>;</li> <li>if <code>self</code> is <a href="primitive.f64.html#associatedconstant.INFINITY" title="associated constant f64::INFINITY"><code>INFINITY</code></a>, this returns <a href="primitive.f64.html#associatedconstant.MAX" title="associated constant f64::MAX"><code>MAX</code></a>;</li> <li>if <code>self</code> is <code>TINY</code>, this returns 0.0;</li> <li>if <code>self</code> is -0.0 or +0.0, this returns <code>-TINY</code>;</li> <li>if <code>self</code> is <a href="primitive.f64.html#associatedconstant.MIN" title="associated constant f64::MIN"><code>MIN</code></a> or <a href="primitive.f64.html#associatedconstant.NEG_INFINITY" title="associated constant f64::NEG_INFINITY"><code>NEG_INFINITY</code></a>, this returns <a href="primitive.f64.html#associatedconstant.NEG_INFINITY" title="associated constant f64::NEG_INFINITY"><code>NEG_INFINITY</code></a>;</li> <li>otherwise the unique greatest value less than <code>self</code> is returned.</li> </ul> <p>The identity <code>x.next_down() == -(-x).next_up()</code> holds for all non-NaN <code>x</code>. When <code>x</code> is finite <code>x == x.next_down().next_up()</code> also holds.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(float_next_up_down)]
let x = 1.0f64;
// Clamp value into range [0, 1).
let clamped = x.clamp(0.0, 1.0f64.next_down());
assert!(clamped &lt; 1.0);
assert_eq!(clamped.next_up(), 1.0);</pre></div> </div>
<summary><section id="method.recip" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#877">source</a></span><pre class="code-header" data-language="rust">pub fn recip(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Takes the reciprocal (inverse) of a number, <code>1/x</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 2.0_f64;
let abs_difference = (x.recip() - (1.0 / x)).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.to_degrees" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#894">source</a></span><pre class="code-header" data-language="rust">pub fn to_degrees(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Converts radians to degrees.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let angle = std::f64::consts::PI;

let abs_difference = (angle.to_degrees() - 180.0).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.to_radians" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#914">source</a></span><pre class="code-header" data-language="rust">pub fn to_radians(self) -&gt; f64</pre></section></summary><div class="docblock">
<p>Converts degrees to radians.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let angle = 180.0_f64;

let abs_difference = (angle.to_radians() - std::f64::consts::PI).abs();

assert!(abs_difference &lt; 1e-10);</pre></div> </div>
<summary><section id="method.max" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#935">source</a></span><pre class="code-header" data-language="rust">pub fn max(self, other: f64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the maximum of the two numbers, ignoring NaN.</p> <p>If one of the arguments is NaN, then the other argument is returned. This follows the IEEE 754-2008 semantics for maxNum, except for handling of signaling NaNs; this function handles all NaNs the same way and avoids maxNum’s problems with associativity. This also matches the behavior of libm’s fmax.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 1.0_f64;
let y = 2.0_f64;

assert_eq!(x.max(y), y);</pre></div> </div>
<summary><section id="method.min" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#955">source</a></span><pre class="code-header" data-language="rust">pub fn min(self, other: f64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the minimum of the two numbers, ignoring NaN.</p> <p>If one of the arguments is NaN, then the other argument is returned. This follows the IEEE 754-2008 semantics for minNum, except for handling of signaling NaNs; this function handles all NaNs the same way and avoids minNum’s problems with associativity. This also matches the behavior of libm’s fmin.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = 1.0_f64;
let y = 2.0_f64;

assert_eq!(x.min(y), x);</pre></div> </div>
<summary><section id="method.maximum" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#982">source</a><pre class="code-header" data-language="rust">pub fn maximum(self, other: f64) -&gt; f64</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_minimum_maximum</code> <a href="https://github.com/rust-lang/rust/issues/91079">#91079</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns the maximum of the two numbers, propagating NaN.</p> <p>This returns NaN when <em>either</em> argument is NaN, as opposed to <a href="primitive.f64.html#method.max" title="method f64::max"><code>f64::max</code></a> which only returns NaN when <em>both</em> arguments are NaN.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(float_minimum_maximum)]
let x = 1.0_f64;
let y = 2.0_f64;

assert_eq!(x.maximum(y), y);
assert!(x.maximum(f64::NAN).is_nan());</pre></div> <p>If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater of the two numbers. For this operation, -0.0 is considered to be less than +0.0. Note that this follows the semantics specified in IEEE 754-2019.</p> <p>Also note that “propagation” of NaNs here doesn’t necessarily mean that the bitpattern of a NaN operand is conserved; see <a href="primitive.f32.html" title="primitive f32">explanation of NaN as a special value</a> for more info.</p> </div>
<summary><section id="method.minimum" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1017">source</a><pre class="code-header" data-language="rust">pub fn minimum(self, other: f64) -&gt; f64</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_minimum_maximum</code> <a href="https://github.com/rust-lang/rust/issues/91079">#91079</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns the minimum of the two numbers, propagating NaN.</p> <p>This returns NaN when <em>either</em> argument is NaN, as opposed to <a href="primitive.f64.html#method.min" title="method f64::min"><code>f64::min</code></a> which only returns NaN when <em>both</em> arguments are NaN.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(float_minimum_maximum)]
let x = 1.0_f64;
let y = 2.0_f64;

assert_eq!(x.minimum(y), x);
assert!(x.minimum(f64::NAN).is_nan());</pre></div> <p>If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser of the two numbers. For this operation, -0.0 is considered to be less than +0.0. Note that this follows the semantics specified in IEEE 754-2019.</p> <p>Also note that “propagation” of NaNs here doesn’t necessarily mean that the bitpattern of a NaN operand is conserved; see <a href="primitive.f32.html" title="primitive f32">explanation of NaN as a special value</a> for more info.</p> </div>
<summary><section id="method.midpoint" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1043">source</a><pre class="code-header" data-language="rust">pub fn midpoint(self, other: f64) -&gt; f64</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>num_midpoint</code> <a href="https://github.com/rust-lang/rust/issues/110840">#110840</a>)</span>
</div></span></summary><div class="docblock">
<p>Calculates the middle point of <code>self</code> and <code>rhs</code>.</p> <p>This returns NaN when <em>either</em> argument is NaN or if a combination of +inf and -inf is provided as arguments.</p> <h5 id="examples-42">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(num_midpoint)]
assert_eq!(1f64.midpoint(4.0), 2.5);
assert_eq!((-5.5f64).midpoint(8.0), 1.25);</pre></div> </div>
<summary><section id="method.to_int_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1090-1092">source</a></span><pre class="code-header" data-language="rust">pub unsafe fn to_int_unchecked&lt;Int&gt;(self) -&gt; Intwhere
    f64: FloatToInt&lt;Int&gt;,</pre></section></summary><div class="docblock">
<p>Rounds toward zero and converts to any primitive integer type, assuming that the value is finite and fits in that type.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let value = 4.6_f64;
let rounded = unsafe { value.to_int_unchecked::&lt;u16&gt;() };
assert_eq!(rounded, 4);

let value = -128.9_f64;
let rounded = unsafe { value.to_int_unchecked::&lt;i8&gt;() };
assert_eq!(rounded, i8::MIN);</pre></div> <h5 id="safety">Safety</h5> <p>The value must:</p> <ul> <li>Not be <code>NaN</code>
</li> <li>Not be infinite</li> <li>Be representable in the return type <code>Int</code>, after truncating off its fractional part</li> </ul> </div>
<summary><section id="method.to_bits" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: <a href="https://github.com/rust-lang/rust/issues/72447" title="Tracking issue for const_float_bits_conv">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1120">source</a></span><pre class="code-header" data-language="rust">pub fn to_bits(self) -&gt; u64</pre></section></summary><div class="docblock">
<p>Raw transmutation to <code>u64</code>.</p> <p>This is currently identical to <code>transmute::&lt;f64, u64&gt;(self)</code> on all platforms.</p> <p>See <a href="primitive.f64.html#method.from_bits" title="associated function f64::from_bits"><code>from_bits</code></a> for some discussion of the portability of this operation (there are almost no issues).</p> <p>Note that this function is distinct from <code>as</code> casting, which attempts to preserve the <em>numeric</em> value, and not the bitwise value.</p> <h5 id="examples-43">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert!((1f64).to_bits() != 1f64 as u64); // to_bits() is not casting!
assert_eq!((12.5f64).to_bits(), 0x4029000000000000);</pre></div> </div>
<summary><section id="method.from_bits" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: <a href="https://github.com/rust-lang/rust/issues/72447" title="Tracking issue for const_float_bits_conv">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1191">source</a></span><pre class="code-header" data-language="rust">pub fn from_bits(v: u64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Raw transmutation from <code>u64</code>.</p> <p>This is currently identical to <code>transmute::&lt;u64, f64&gt;(v)</code> on all platforms. It turns out this is incredibly portable, for two reasons:</p> <ul> <li>Floats and Ints have the same endianness on all supported platforms.</li> <li>IEEE 754 very precisely specifies the bit layout of floats.</li> </ul> <p>However there is one caveat: prior to the 2008 version of IEEE 754, how to interpret the NaN signaling bit wasn’t actually specified. Most platforms (notably x86 and ARM) picked the interpretation that was ultimately standardized in 2008, but some didn’t (notably MIPS). As a result, all signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</p> <p>Rather than trying to preserve signaling-ness cross-platform, this implementation favors preserving the exact bits. This means that any payloads encoded in NaNs will be preserved even if the result of this method is sent over the network from an x86 machine to a MIPS one.</p> <p>If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.</p> <p>If the input isn’t NaN, then there is no portability concern.</p> <p>If you don’t care about signaling-ness (very likely), then there is no portability concern.</p> <p>Note that this function is distinct from <code>as</code> casting, which attempts to preserve the <em>numeric</em> value, and not the bitwise value.</p> <h5 id="examples-44">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v = f64::from_bits(0x4029000000000000);
assert_eq!(v, 12.5);</pre></div> </div>
<summary><section id="method.to_be_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const unstable">1.40.0 (const: <a href="https://github.com/rust-lang/rust/issues/72447" title="Tracking issue for const_float_bits_conv">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1264">source</a></span><pre class="code-header" data-language="rust">pub fn to_be_bytes(self) -&gt; [u8; 8]</pre></section></summary><div class="docblock">
<p>Return the memory representation of this floating point number as a byte array in big-endian (network) byte order.</p> <p>See <a href="primitive.f64.html#method.from_bits" title="associated function f64::from_bits"><code>from_bits</code></a> for some discussion of the portability of this operation (there are almost no issues).</p> <h5 id="examples-45">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bytes = 12.5f64.to_be_bytes();
assert_eq!(bytes, [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);</pre></div> </div>
<summary><section id="method.to_le_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const unstable">1.40.0 (const: <a href="https://github.com/rust-lang/rust/issues/72447" title="Tracking issue for const_float_bits_conv">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1285">source</a></span><pre class="code-header" data-language="rust">pub fn to_le_bytes(self) -&gt; [u8; 8]</pre></section></summary><div class="docblock">
<p>Return the memory representation of this floating point number as a byte array in little-endian byte order.</p> <p>See <a href="primitive.f64.html#method.from_bits" title="associated function f64::from_bits"><code>from_bits</code></a> for some discussion of the portability of this operation (there are almost no issues).</p> <h5 id="examples-46">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bytes = 12.5f64.to_le_bytes();
assert_eq!(bytes, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);</pre></div> </div>
<summary><section id="method.to_ne_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const unstable">1.40.0 (const: <a href="https://github.com/rust-lang/rust/issues/72447" title="Tracking issue for const_float_bits_conv">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1319">source</a></span><pre class="code-header" data-language="rust">pub fn to_ne_bytes(self) -&gt; [u8; 8]</pre></section></summary><div class="docblock">
<p>Return the memory representation of this floating point number as a byte array in native byte order.</p> <p>As the target platform’s native endianness is used, portable code should use <a href="primitive.f64.html#method.to_be_bytes" title="method f64::to_be_bytes"><code>to_be_bytes</code></a> or <a href="primitive.f64.html#method.to_le_bytes" title="method f64::to_le_bytes"><code>to_le_bytes</code></a>, as appropriate, instead.</p> <p>See <a href="primitive.f64.html#method.from_bits" title="associated function f64::from_bits"><code>from_bits</code></a> for some discussion of the portability of this operation (there are almost no issues).</p> <h5 id="examples-47">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bytes = 12.5f64.to_ne_bytes();
assert_eq!(
    bytes,
    if cfg!(target_endian = "big") {
        [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
    } else {
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]
    }
);</pre></div> </div>
<summary><section id="method.from_be_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const unstable">1.40.0 (const: <a href="https://github.com/rust-lang/rust/issues/72447" title="Tracking issue for const_float_bits_conv">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1338">source</a></span><pre class="code-header" data-language="rust">pub fn from_be_bytes(bytes: [u8; 8]) -&gt; f64</pre></section></summary><div class="docblock">
<p>Create a floating point value from its representation as a byte array in big endian.</p> <p>See <a href="primitive.f64.html#method.from_bits" title="associated function f64::from_bits"><code>from_bits</code></a> for some discussion of the portability of this operation (there are almost no issues).</p> <h5 id="examples-48">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let value = f64::from_be_bytes([0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
assert_eq!(value, 12.5);</pre></div> </div>
<summary><section id="method.from_le_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const unstable">1.40.0 (const: <a href="https://github.com/rust-lang/rust/issues/72447" title="Tracking issue for const_float_bits_conv">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1357">source</a></span><pre class="code-header" data-language="rust">pub fn from_le_bytes(bytes: [u8; 8]) -&gt; f64</pre></section></summary><div class="docblock">
<p>Create a floating point value from its representation as a byte array in little endian.</p> <p>See <a href="primitive.f64.html#method.from_bits" title="associated function f64::from_bits"><code>from_bits</code></a> for some discussion of the portability of this operation (there are almost no issues).</p> <h5 id="examples-49">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let value = f64::from_le_bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);
assert_eq!(value, 12.5);</pre></div> </div>
<summary><section id="method.from_ne_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const unstable">1.40.0 (const: <a href="https://github.com/rust-lang/rust/issues/72447" title="Tracking issue for const_float_bits_conv">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1387">source</a></span><pre class="code-header" data-language="rust">pub fn from_ne_bytes(bytes: [u8; 8]) -&gt; f64</pre></section></summary><div class="docblock">
<p>Create a floating point value from its representation as a byte array in native endian.</p> <p>As the target platform’s native endianness is used, portable code likely wants to use <a href="primitive.f64.html#method.from_be_bytes" title="associated function f64::from_be_bytes"><code>from_be_bytes</code></a> or <a href="primitive.f64.html#method.from_le_bytes" title="associated function f64::from_le_bytes"><code>from_le_bytes</code></a>, as appropriate instead.</p> <p>See <a href="primitive.f64.html#method.from_bits" title="associated function f64::from_bits"><code>from_bits</code></a> for some discussion of the portability of this operation (there are almost no issues).</p> <h5 id="examples-50">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let value = f64::from_ne_bytes(if cfg!(target_endian = "big") {
    [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
} else {
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]
});
assert_eq!(value, 12.5);</pre></div> </div>
<summary><section id="method.total_cmp" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.62.0">1.62.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1453">source</a></span><pre class="code-header" data-language="rust">pub fn total_cmp(&amp;self, other: &amp;f64) -&gt; Ordering</pre></section></summary><div class="docblock">
<p>Return the ordering between <code>self</code> and <code>other</code>.</p> <p>Unlike the standard partial comparison between floating point numbers, this comparison always produces an ordering in accordance to the <code>totalOrder</code> predicate as defined in the IEEE 754 (2008 revision) floating point standard. The values are ordered in the following sequence:</p> <ul> <li>negative quiet NaN</li> <li>negative signaling NaN</li> <li>negative infinity</li> <li>negative numbers</li> <li>negative subnormal numbers</li> <li>negative zero</li> <li>positive zero</li> <li>positive subnormal numbers</li> <li>positive numbers</li> <li>positive infinity</li> <li>positive signaling NaN</li> <li>positive quiet NaN.</li> </ul> <p>The ordering established by this function does not always agree with the <a href="cmp/trait.partialord.html" title="trait std::cmp::PartialOrd"><code>PartialOrd</code></a> and <a href="cmp/trait.partialeq.html" title="trait std::cmp::PartialEq"><code>PartialEq</code></a> implementations of <code>f64</code>. For example, they consider negative and positive zero equal, while <code>total_cmp</code> doesn’t.</p> <p>The interpretation of the signaling NaN bit follows the definition in the IEEE 754 standard, which may not match the interpretation by some of the older, non-conformant (e.g. MIPS) hardware implementations.</p> <h5 id="example">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">struct GoodBoy {
    name: String,
    weight: f64,
}

let mut bois = vec![
    GoodBoy { name: "Pucci".to_owned(), weight: 0.1 },
    GoodBoy { name: "Woofer".to_owned(), weight: 99.0 },
    GoodBoy { name: "Yapper".to_owned(), weight: 10.0 },
    GoodBoy { name: "Chonk".to_owned(), weight: f64::INFINITY },
    GoodBoy { name: "Abs. Unit".to_owned(), weight: f64::NAN },
    GoodBoy { name: "Floaty".to_owned(), weight: -5.0 },
];

bois.sort_by(|a, b| a.weight.total_cmp(&amp;b.weight));

// `f64::NAN` could be positive or negative, which will affect the sort order.
if f64::NAN.is_sign_negative() {
    assert!(bois.into_iter().map(|b| b.weight)
        .zip([f64::NAN, -5.0, 0.1, 10.0, 99.0, f64::INFINITY].iter())
        .all(|(a, b)| a.to_bits() == b.to_bits()))
} else {
    assert!(bois.into_iter().map(|b| b.weight)
        .zip([-5.0, 0.1, 10.0, 99.0, f64::INFINITY, f64::NAN].iter())
        .all(|(a, b)| a.to_bits() == b.to_bits()))
}</pre></div> </div>
<summary><section id="method.clamp" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/f64.rs.html#1508">source</a></span><pre class="code-header" data-language="rust">pub fn clamp(self, min: f64, max: f64) -&gt; f64</pre></section></summary><div class="docblock">
<p>Restrict a value to a certain interval unless it is NaN.</p> <p>Returns <code>max</code> if <code>self</code> is greater than <code>max</code>, and <code>min</code> if <code>self</code> is less than <code>min</code>. Otherwise this returns <code>self</code>.</p> <p>Note that this function returns NaN if the initial value was NaN as well.</p> <h5 id="panics">Panics</h5> <p>Panics if <code>min &gt; max</code>, <code>min</code> is NaN, or <code>max</code> is NaN.</p> <h5 id="examples-51">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert!((-3.0f64).clamp(-2.0, 1.0) == -2.0);
assert!((0.0f64).clamp(-2.0, 1.0) == 0.0);
assert!((2.0f64).clamp(-2.0, 1.0) == 1.0);
assert!((f64::NAN).clamp(-2.0, 1.0).is_nan());</pre></div> </div>
</div>
</div>
<h3 id="trait-implementations" class="section-header">Trait Implementations</h3>
<div id="trait-implementations-list">
<summary><section id="impl-Add%3C%26f64%3E-for-%26f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112">source</a></span><pre class="code-header" data-language="rust">impl Add&lt;&amp;f64&gt; for &amp;f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-13" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Add&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>+</code> operator.</div>
<summary><section id="method.add-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112">source</a><pre class="code-header" data-language="rust">fn add(self, other: &amp;f64) -&gt; &lt;f64 as Add&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>+</code> operation. <a href="ops/trait.add.html#tymethod.add">Read more</a>
</div>
</div>
<summary><section id="impl-Add%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112">source</a></span><pre class="code-header" data-language="rust">impl Add&lt;&amp;f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-12" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Add&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>+</code> operator.</div>
<summary><section id="method.add-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112">source</a><pre class="code-header" data-language="rust">fn add(self, other: &amp;f64) -&gt; &lt;f64 as Add&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>+</code> operation. <a href="ops/trait.add.html#tymethod.add">Read more</a>
</div>
</div>
<summary><section id="impl-Add%3Cf64%3E-for-%26f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Add&lt;f64&gt; for &amp;'a f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-11" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Add&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>+</code> operator.</div>
<summary><section id="method.add-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112">source</a><pre class="code-header" data-language="rust">fn add(self, other: f64) -&gt; &lt;f64 as Add&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>+</code> operation. <a href="ops/trait.add.html#tymethod.add">Read more</a>
</div>
</div>
<summary><section id="impl-Add-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/90080" title="Tracking issue for const_ops">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112">source</a></span><pre class="code-header" data-language="rust">impl Add for f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-10" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = f64</pre></section></summary><div class="docblock">The resulting type after applying the <code>+</code> operator.</div>
<summary><section id="method.add" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#112">source</a><pre class="code-header" data-language="rust">const fn add(self, other: f64) -&gt; f64</pre></section></summary><div class="docblock">Performs the <code>+</code> operation. <a href="ops/trait.add.html#tymethod.add">Read more</a>
</div>
</div>
<summary><section id="impl-AddAssign%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0">1.22.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#768">source</a></span><pre class="code-header" data-language="rust">impl AddAssign&lt;&amp;f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.add_assign" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#768">source</a><pre class="code-header" data-language="rust">fn add_assign(&amp;mut self, other: &amp;f64)</pre></section></summary><div class="docblock">Performs the <code>+=</code> operation. <a href="ops/trait.addassign.html#tymethod.add_assign">Read more</a>
</div>
</div>
<summary><section id="impl-AddAssign-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#768">source</a></span><pre class="code-header" data-language="rust">impl AddAssign for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.add_assign-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#768">source</a><pre class="code-header" data-language="rust">fn add_assign(&amp;mut self, other: f64)</pre></section></summary><div class="docblock">Performs the <code>+=</code> operation. <a href="ops/trait.addassign.html#tymethod.add_assign">Read more</a>
</div>
</div>
<summary><section id="impl-Clone-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#227-232">source</a></span><pre class="code-header" data-language="rust">impl Clone for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#227-232">source</a><pre class="code-header" data-language="rust">fn clone(&amp;self) -&gt; f64</pre></section></summary><div class="docblock">Returns a copy of the value. <a href="clone/trait.clone.html#tymethod.clone">Read more</a>
</div>
<summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/clone.rs.html#169">source</a></span><pre class="code-header" data-language="rust">fn clone_from(&amp;mut self, source: &amp;Self)</pre></section></summary><div class="docblock">Performs copy-assignment from <code>source</code>. <a href="clone/trait.clone.html#method.clone_from">Read more</a>
</div>
</div>
<summary><section id="impl-Debug-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#230">source</a></span><pre class="code-header" data-language="rust">impl Debug for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#230">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, fmt: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="fmt/trait.debug.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Default-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/default.rs.html#183">source</a></span><pre class="code-header" data-language="rust">impl Default for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/default.rs.html#183">source</a><pre class="code-header" data-language="rust">fn default() -&gt; f64</pre></section></summary><div class="docblock">
<p>Returns the default value of <code>0.0</code></p> </div>
</div>
<summary><section id="impl-Display-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#230">source</a></span><pre class="code-header" data-language="rust">impl Display for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#230">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, fmt: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="fmt/trait.display.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Div%3C%26f64%3E-for-%26f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509">source</a></span><pre class="code-header" data-language="rust">impl Div&lt;&amp;f64&gt; for &amp;f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-17" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Div&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>/</code> operator.</div>
<summary><section id="method.div-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509">source</a><pre class="code-header" data-language="rust">fn div(self, other: &amp;f64) -&gt; &lt;f64 as Div&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>/</code> operation. <a href="ops/trait.div.html#tymethod.div">Read more</a>
</div>
</div>
<summary><section id="impl-Div%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509">source</a></span><pre class="code-header" data-language="rust">impl Div&lt;&amp;f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-16" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Div&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>/</code> operator.</div>
<summary><section id="method.div-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509">source</a><pre class="code-header" data-language="rust">fn div(self, other: &amp;f64) -&gt; &lt;f64 as Div&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>/</code> operation. <a href="ops/trait.div.html#tymethod.div">Read more</a>
</div>
</div>
<summary><section id="impl-Div%3Cf64%3E-for-%26f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Div&lt;f64&gt; for &amp;'a f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-14" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Div&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>/</code> operator.</div>
<summary><section id="method.div" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509">source</a><pre class="code-header" data-language="rust">fn div(self, other: f64) -&gt; &lt;f64 as Div&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>/</code> operation. <a href="ops/trait.div.html#tymethod.div">Read more</a>
</div>
</div>
<summary><section id="impl-Div-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509">source</a></span><pre class="code-header" data-language="rust">impl Div for f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-15" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = f64</pre></section></summary><div class="docblock">The resulting type after applying the <code>/</code> operator.</div>
<summary><section id="method.div-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#509">source</a><pre class="code-header" data-language="rust">fn div(self, other: f64) -&gt; f64</pre></section></summary><div class="docblock">Performs the <code>/</code> operation. <a href="ops/trait.div.html#tymethod.div">Read more</a>
</div>
</div>
<summary><section id="impl-DivAssign%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0">1.22.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#950">source</a></span><pre class="code-header" data-language="rust">impl DivAssign&lt;&amp;f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.div_assign-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#950">source</a><pre class="code-header" data-language="rust">fn div_assign(&amp;mut self, other: &amp;f64)</pre></section></summary><div class="docblock">Performs the <code>/=</code> operation. <a href="ops/trait.divassign.html#tymethod.div_assign">Read more</a>
</div>
</div>
<summary><section id="impl-DivAssign-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#950">source</a></span><pre class="code-header" data-language="rust">impl DivAssign for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.div_assign" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#950">source</a><pre class="code-header" data-language="rust">fn div_assign(&amp;mut self, other: f64)</pre></section></summary><div class="docblock">Performs the <code>/=</code> operation. <a href="ops/trait.divassign.html#tymethod.div_assign">Read more</a>
</div>
</div>
<summary><section id="impl-From%3Cbool%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.68.0">1.68.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#202">source</a></span><pre class="code-header" data-language="rust">impl From&lt;bool&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#202">source</a><pre class="code-header" data-language="rust">fn from(small: bool) -&gt; f64</pre></section></summary><div class="docblock">
<p>Converts a <a href="primitive.bool.html" title="primitive bool"><code>bool</code></a> to <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> losslessly. The resulting value is positive <code>0.0</code> for <code>false</code> and <code>1.0</code> for <code>true</code> values.</p> <h5 id="examples-52">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x: f64 = false.into();
assert_eq!(x, 0.0);
assert!(x.is_sign_positive());

let y: f64 = true.into();
assert_eq!(y, 1.0);</pre></div> </div>
</div>
<summary><section id="impl-From%3Cf16%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#170">source</a></span><pre class="code-header" data-language="rust">impl From&lt;f16&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#170">source</a><pre class="code-header" data-language="rust">fn from(small: f16) -&gt; f64</pre></section></summary><div class="docblock">
<p>Converts <a href="primitive.f16.html" title="primitive f16"><code>f16</code></a> to <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> losslessly.</p> </div>
</div>
<summary><section id="impl-From%3Cf32%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#172">source</a></span><pre class="code-header" data-language="rust">impl From&lt;f32&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#172">source</a><pre class="code-header" data-language="rust">fn from(small: f32) -&gt; f64</pre></section></summary><div class="docblock">
<p>Converts <a href="primitive.f32.html" title="primitive f32"><code>f32</code></a> to <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> losslessly.</p> </div>
</div>
<summary><section id="impl-From%3Cf64%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#174">source</a></span><pre class="code-header" data-language="rust">impl From&lt;f64&gt; for f128</pre></section></summary><div class="impl-items">
<summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#174">source</a><pre class="code-header" data-language="rust">fn from(small: f64) -&gt; f128</pre></section></summary><div class="docblock">
<p>Converts <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> to <a href="primitive.f128.html" title="primitive f128"><code>f128</code></a> losslessly.</p> </div>
</div>
<summary><section id="impl-From%3Ci16%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#157">source</a></span><pre class="code-header" data-language="rust">impl From&lt;i16&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.from-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#157">source</a><pre class="code-header" data-language="rust">fn from(small: i16) -&gt; f64</pre></section></summary><div class="docblock">
<p>Converts <a href="primitive.i16.html" title="primitive i16"><code>i16</code></a> to <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> losslessly.</p> </div>
</div>
<summary><section id="impl-From%3Ci32%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#158">source</a></span><pre class="code-header" data-language="rust">impl From&lt;i32&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#158">source</a><pre class="code-header" data-language="rust">fn from(small: i32) -&gt; f64</pre></section></summary><div class="docblock">
<p>Converts <a href="primitive.i32.html" title="primitive i32"><code>i32</code></a> to <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> losslessly.</p> </div>
</div>
<summary><section id="impl-From%3Ci8%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#155">source</a></span><pre class="code-header" data-language="rust">impl From&lt;i8&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#155">source</a><pre class="code-header" data-language="rust">fn from(small: i8) -&gt; f64</pre></section></summary><div class="docblock">
<p>Converts <a href="primitive.i8.html" title="primitive i8"><code>i8</code></a> to <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> losslessly.</p> </div>
</div>
<summary><section id="impl-From%3Cu16%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#164">source</a></span><pre class="code-header" data-language="rust">impl From&lt;u16&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#164">source</a><pre class="code-header" data-language="rust">fn from(small: u16) -&gt; f64</pre></section></summary><div class="docblock">
<p>Converts <a href="primitive.u16.html" title="primitive u16"><code>u16</code></a> to <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> losslessly.</p> </div>
</div>
<summary><section id="impl-From%3Cu32%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#165">source</a></span><pre class="code-header" data-language="rust">impl From&lt;u32&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.from-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#165">source</a><pre class="code-header" data-language="rust">fn from(small: u32) -&gt; f64</pre></section></summary><div class="docblock">
<p>Converts <a href="primitive.u32.html" title="primitive u32"><code>u32</code></a> to <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> losslessly.</p> </div>
</div>
<summary><section id="impl-From%3Cu8%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#162">source</a></span><pre class="code-header" data-language="rust">impl From&lt;u8&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#162">source</a><pre class="code-header" data-language="rust">fn from(small: u8) -&gt; f64</pre></section></summary><div class="docblock">
<p>Converts <a href="primitive.u8.html" title="primitive u8"><code>u8</code></a> to <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> losslessly.</p> </div>
</div>
<summary><section id="impl-FromStr-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/num/dec2flt/mod.rs.html#164">source</a></span><pre class="code-header" data-language="rust">impl FromStr for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.from_str" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/num/dec2flt/mod.rs.html#164">source</a><pre class="code-header" data-language="rust">fn from_str(src: &amp;str) -&gt; Result&lt;f64, ParseFloatError&gt;</pre></section></summary><div class="docblock">
<p>Converts a string in base 10 to a float. Accepts an optional decimal exponent.</p> <p>This function accepts strings such as</p> <ul> <li>‘3.14’</li> <li>‘-3.14’</li> <li>‘2.5E10’, or equivalently, ‘2.5e10’</li> <li>‘2.5E-10’</li> <li>‘5.’</li> <li>‘.5’, or, equivalently, ‘0.5’</li> <li>‘inf’, ‘-inf’, ‘+infinity’, ‘NaN’</li> </ul> <p>Note that alphabetical characters are not case-sensitive.</p> <p>Leading and trailing whitespace represent an error.</p> <h5 id="grammar">Grammar</h5> <p>All strings that adhere to the following <a href="https://www.w3.org/TR/REC-xml/#sec-notation">EBNF</a> grammar when lowercased will result in an <a href="result/enum.result.html#variant.Ok" title="variant std::result::Result::Ok"><code>Ok</code></a> being returned:</p> <div class="example-wrap"><pre class="language-txt">Float  ::= Sign? ( 'inf' | 'infinity' | 'nan' | Number )
Number ::= ( Digit+ |
             Digit+ '.' Digit* |
             Digit* '.' Digit+ ) Exp?
Exp    ::= 'e' Sign? Digit+
Sign   ::= [+-]
Digit  ::= [0-9]
</pre></div>
<h5 id="arguments">Arguments</h5> <ul> <li>src - A string</li> </ul> <h5 id="return-value">Return value</h5> <p><code>Err(ParseFloatError)</code> if the string did not represent a valid number. Otherwise, <code>Ok(n)</code> where <code>n</code> is the closest representable floating-point number to the number represented by <code>src</code> (following the same rules for rounding as for the results of primitive operations).</p> </div>
<summary><section id="associatedtype.Err" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Err = ParseFloatError</pre></section></summary><div class="docblock">The associated error which can be returned from parsing.</div>
</div>
<summary><section id="impl-LowerExp-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#230">source</a></span><pre class="code-header" data-language="rust">impl LowerExp for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#230">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, fmt: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="fmt/trait.lowerexp.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Mul%3C%26f64%3E-for-%26f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351">source</a></span><pre class="code-header" data-language="rust">impl Mul&lt;&amp;f64&gt; for &amp;f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Mul&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>*</code> operator.</div>
<summary><section id="method.mul-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351">source</a><pre class="code-header" data-language="rust">fn mul(self, other: &amp;f64) -&gt; &lt;f64 as Mul&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>*</code> operation. <a href="ops/trait.mul.html#tymethod.mul">Read more</a>
</div>
</div>
<summary><section id="impl-Mul%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351">source</a></span><pre class="code-header" data-language="rust">impl Mul&lt;&amp;f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Mul&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>*</code> operator.</div>
<summary><section id="method.mul-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351">source</a><pre class="code-header" data-language="rust">fn mul(self, other: &amp;f64) -&gt; &lt;f64 as Mul&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>*</code> operation. <a href="ops/trait.mul.html#tymethod.mul">Read more</a>
</div>
</div>
<summary><section id="impl-Mul%3Cf64%3E-for-%26f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Mul&lt;f64&gt; for &amp;'a f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Mul&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>*</code> operator.</div>
<summary><section id="method.mul" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351">source</a><pre class="code-header" data-language="rust">fn mul(self, other: f64) -&gt; &lt;f64 as Mul&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>*</code> operation. <a href="ops/trait.mul.html#tymethod.mul">Read more</a>
</div>
</div>
<summary><section id="impl-Mul-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351">source</a></span><pre class="code-header" data-language="rust">impl Mul for f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = f64</pre></section></summary><div class="docblock">The resulting type after applying the <code>*</code> operator.</div>
<summary><section id="method.mul-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#351">source</a><pre class="code-header" data-language="rust">fn mul(self, other: f64) -&gt; f64</pre></section></summary><div class="docblock">Performs the <code>*</code> operation. <a href="ops/trait.mul.html#tymethod.mul">Read more</a>
</div>
</div>
<summary><section id="impl-MulAssign%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0">1.22.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#893">source</a></span><pre class="code-header" data-language="rust">impl MulAssign&lt;&amp;f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.mul_assign" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#893">source</a><pre class="code-header" data-language="rust">fn mul_assign(&amp;mut self, other: &amp;f64)</pre></section></summary><div class="docblock">Performs the <code>*=</code> operation. <a href="ops/trait.mulassign.html#tymethod.mul_assign">Read more</a>
</div>
</div>
<summary><section id="impl-MulAssign-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#893">source</a></span><pre class="code-header" data-language="rust">impl MulAssign for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.mul_assign-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#893">source</a><pre class="code-header" data-language="rust">fn mul_assign(&amp;mut self, other: f64)</pre></section></summary><div class="docblock">Performs the <code>*=</code> operation. <a href="ops/trait.mulassign.html#tymethod.mul_assign">Read more</a>
</div>
</div>
<summary><section id="impl-Neg-for-%26f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701">source</a></span><pre class="code-header" data-language="rust">impl Neg for &amp;f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Neg&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>-</code> operator.</div>
<summary><section id="method.neg" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701">source</a><pre class="code-header" data-language="rust">fn neg(self) -&gt; &lt;f64 as Neg&gt;::Output</pre></section></summary><div class="docblock">Performs the unary <code>-</code> operation. <a href="ops/trait.neg.html#tymethod.neg">Read more</a>
</div>
</div>
<summary><section id="impl-Neg-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701">source</a></span><pre class="code-header" data-language="rust">impl Neg for f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = f64</pre></section></summary><div class="docblock">The resulting type after applying the <code>-</code> operator.</div>
<summary><section id="method.neg-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#701">source</a><pre class="code-header" data-language="rust">fn neg(self) -&gt; f64</pre></section></summary><div class="docblock">Performs the unary <code>-</code> operation. <a href="ops/trait.neg.html#tymethod.neg">Read more</a>
</div>
</div>
<summary><section id="impl-PartialEq-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/92391" title="Tracking issue for const_cmp">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1500-1502">source</a></span><pre class="code-header" data-language="rust">impl PartialEq for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1500-1502">source</a><pre class="code-header" data-language="rust">const fn eq(&amp;self, other: &amp;f64) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1500-1502">source</a><pre class="code-header" data-language="rust">const fn ne(&amp;self, other: &amp;f64) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialOrd-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554">source</a></span><pre class="code-header" data-language="rust">impl PartialOrd for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554">source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;f64) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord.html#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554">source</a><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;f64) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord.html#method.lt">Read more</a>
</div>
<summary><section id="method.le" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554">source</a><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;f64) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord.html#method.le">Read more</a>
</div>
<summary><section id="method.ge" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554">source</a><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;f64) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord.html#method.ge">Read more</a>
</div>
<summary><section id="method.gt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/cmp.rs.html#1554">source</a><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;f64) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord.html#method.gt">Read more</a>
</div>
</div>
<summary><section id="impl-Product%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Product&lt;&amp;'a f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.product-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150">source</a><pre class="code-header" data-language="rust">fn product&lt;I&gt;(iter: I) -&gt; f64where
    I: Iterator&lt;Item = &amp;'a f64&gt;,</pre></section></summary><div class="docblock">Method which takes an iterator and generates <code>Self</code> from the elements by multiplying the items.</div>
</div>
<summary><section id="impl-Product-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150">source</a></span><pre class="code-header" data-language="rust">impl Product for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.product" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150">source</a><pre class="code-header" data-language="rust">fn product&lt;I&gt;(iter: I) -&gt; f64where
    I: Iterator&lt;Item = f64&gt;,</pre></section></summary><div class="docblock">Method which takes an iterator and generates <code>Self</code> from the elements by multiplying the items.</div>
</div>
<summary><section id="impl-Rem%3C%26f64%3E-for-%26f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626">source</a></span><pre class="code-header" data-language="rust">impl Rem&lt;&amp;f64&gt; for &amp;f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-21" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Rem&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>%</code> operator.</div>
<summary><section id="method.rem-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626">source</a><pre class="code-header" data-language="rust">fn rem(self, other: &amp;f64) -&gt; &lt;f64 as Rem&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>%</code> operation. <a href="ops/trait.rem.html#tymethod.rem">Read more</a>
</div>
</div>
<summary><section id="impl-Rem%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626">source</a></span><pre class="code-header" data-language="rust">impl Rem&lt;&amp;f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-19" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Rem&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>%</code> operator.</div>
<summary><section id="method.rem-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626">source</a><pre class="code-header" data-language="rust">fn rem(self, other: &amp;f64) -&gt; &lt;f64 as Rem&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>%</code> operation. <a href="ops/trait.rem.html#tymethod.rem">Read more</a>
</div>
</div>
<summary><section id="impl-Rem%3Cf64%3E-for-%26f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Rem&lt;f64&gt; for &amp;'a f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-20" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Rem&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>%</code> operator.</div>
<summary><section id="method.rem-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626">source</a><pre class="code-header" data-language="rust">fn rem(self, other: f64) -&gt; &lt;f64 as Rem&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>%</code> operation. <a href="ops/trait.rem.html#tymethod.rem">Read more</a>
</div>
</div>
<summary><section id="impl-Rem-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626">source</a></span><pre class="code-header" data-language="rust">impl Rem for f64</pre></section></summary><div class="docblock">
<p>The remainder from the division of two floats.</p> <p>The remainder has the same sign as the dividend and is computed as: <code>x - (x / y).trunc() * y</code>.</p> <h4 id="examples-53">Examples</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x: f32 = 50.50;
let y: f32 = 8.125;
let remainder = x - (x / y).trunc() * y;

// The answer to both operations is 1.75
assert_eq!(x % y, remainder);</pre></div> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-18" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = f64</pre></section></summary><div class="docblock">The resulting type after applying the <code>%</code> operator.</div>
<summary><section id="method.rem" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#626">source</a><pre class="code-header" data-language="rust">fn rem(self, other: f64) -&gt; f64</pre></section></summary><div class="docblock">Performs the <code>%</code> operation. <a href="ops/trait.rem.html#tymethod.rem">Read more</a>
</div>
</div>
<summary><section id="impl-RemAssign%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0">1.22.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#1011">source</a></span><pre class="code-header" data-language="rust">impl RemAssign&lt;&amp;f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.rem_assign" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#1011">source</a><pre class="code-header" data-language="rust">fn rem_assign(&amp;mut self, other: &amp;f64)</pre></section></summary><div class="docblock">Performs the <code>%=</code> operation. <a href="ops/trait.remassign.html#tymethod.rem_assign">Read more</a>
</div>
</div>
<summary><section id="impl-RemAssign-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#1011">source</a></span><pre class="code-header" data-language="rust">impl RemAssign for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.rem_assign-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#1011">source</a><pre class="code-header" data-language="rust">fn rem_assign(&amp;mut self, other: f64)</pre></section></summary><div class="docblock">Performs the <code>%=</code> operation. <a href="ops/trait.remassign.html#tymethod.rem_assign">Read more</a>
</div>
</div>
<summary><section id="impl-SimdElement-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/portable-simd/crates/core_simd/src/vector.rs.html#1165">source</a><pre class="code-header" data-language="rust">impl SimdElement for f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Mask" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Mask = i64</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>portable_simd</code> <a href="https://github.com/rust-lang/rust/issues/86656">#86656</a>)</span>
</div></span><div class="docblock">The mask element type corresponding to this element type.</div>
</div>
<summary><section id="impl-Sub%3C%26f64%3E-for-%26f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221">source</a></span><pre class="code-header" data-language="rust">impl Sub&lt;&amp;f64&gt; for &amp;f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Sub&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>-</code> operator.</div>
<summary><section id="method.sub" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221">source</a><pre class="code-header" data-language="rust">fn sub(self, other: &amp;f64) -&gt; &lt;f64 as Sub&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>-</code> operation. <a href="ops/trait.sub.html#tymethod.sub">Read more</a>
</div>
</div>
<summary><section id="impl-Sub%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221">source</a></span><pre class="code-header" data-language="rust">impl Sub&lt;&amp;f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-8" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Sub&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>-</code> operator.</div>
<summary><section id="method.sub-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221">source</a><pre class="code-header" data-language="rust">fn sub(self, other: &amp;f64) -&gt; &lt;f64 as Sub&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>-</code> operation. <a href="ops/trait.sub.html#tymethod.sub">Read more</a>
</div>
</div>
<summary><section id="impl-Sub%3Cf64%3E-for-%26f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Sub&lt;f64&gt; for &amp;'a f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;f64 as Sub&gt;::Output</pre></section></summary><div class="docblock">The resulting type after applying the <code>-</code> operator.</div>
<summary><section id="method.sub-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221">source</a><pre class="code-header" data-language="rust">fn sub(self, other: f64) -&gt; &lt;f64 as Sub&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>-</code> operation. <a href="ops/trait.sub.html#tymethod.sub">Read more</a>
</div>
</div>
<summary><section id="impl-Sub-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221">source</a></span><pre class="code-header" data-language="rust">impl Sub for f64</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-9" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = f64</pre></section></summary><div class="docblock">The resulting type after applying the <code>-</code> operator.</div>
<summary><section id="method.sub-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#221">source</a><pre class="code-header" data-language="rust">fn sub(self, other: f64) -&gt; f64</pre></section></summary><div class="docblock">Performs the <code>-</code> operation. <a href="ops/trait.sub.html#tymethod.sub">Read more</a>
</div>
</div>
<summary><section id="impl-SubAssign%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0">1.22.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#835">source</a></span><pre class="code-header" data-language="rust">impl SubAssign&lt;&amp;f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.sub_assign" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#835">source</a><pre class="code-header" data-language="rust">fn sub_assign(&amp;mut self, other: &amp;f64)</pre></section></summary><div class="docblock">Performs the <code>-=</code> operation. <a href="ops/trait.subassign.html#tymethod.sub_assign">Read more</a>
</div>
</div>
<summary><section id="impl-SubAssign-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#835">source</a></span><pre class="code-header" data-language="rust">impl SubAssign for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.sub_assign-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/ops/arith.rs.html#835">source</a><pre class="code-header" data-language="rust">fn sub_assign(&amp;mut self, other: f64)</pre></section></summary><div class="docblock">Performs the <code>-=</code> operation. <a href="ops/trait.subassign.html#tymethod.sub_assign">Read more</a>
</div>
</div>
<summary><section id="impl-Sum%3C%26f64%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Sum&lt;&amp;'a f64&gt; for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.sum-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150">source</a><pre class="code-header" data-language="rust">fn sum&lt;I&gt;(iter: I) -&gt; f64where
    I: Iterator&lt;Item = &amp;'a f64&gt;,</pre></section></summary><div class="docblock">Method which takes an iterator and generates <code>Self</code> from the elements by “summing up” the items.</div>
</div>
<summary><section id="impl-Sum-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150">source</a></span><pre class="code-header" data-language="rust">impl Sum for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.sum" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/iter/traits/accum.rs.html#150">source</a><pre class="code-header" data-language="rust">fn sum&lt;I&gt;(iter: I) -&gt; f64where
    I: Iterator&lt;Item = f64&gt;,</pre></section></summary><div class="docblock">Method which takes an iterator and generates <code>Self</code> from the elements by “summing up” the items.</div>
</div>
<summary><section id="impl-UpperExp-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#230">source</a></span><pre class="code-header" data-language="rust">impl UpperExp for f64</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/fmt/float.rs.html#230">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, fmt: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="fmt/trait.upperexp.html#tymethod.fmt">Read more</a>
</div>
</div>
<section id="impl-Copy-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/1.80.0/src/core/marker.rs.html#420-430">source</a></span><pre class="code-header" data-language="rust">impl Copy for f64</pre></section><section id="impl-FloatToInt%3Ci128%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;i128&gt; for f64</pre></section><section id="impl-FloatToInt%3Ci16%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;i16&gt; for f64</pre></section><section id="impl-FloatToInt%3Ci32%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;i32&gt; for f64</pre></section><section id="impl-FloatToInt%3Ci64%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;i64&gt; for f64</pre></section><section id="impl-FloatToInt%3Ci8%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;i8&gt; for f64</pre></section><section id="impl-FloatToInt%3Cisize%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;isize&gt; for f64</pre></section><section id="impl-FloatToInt%3Cu128%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;u128&gt; for f64</pre></section><section id="impl-FloatToInt%3Cu16%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;u16&gt; for f64</pre></section><section id="impl-FloatToInt%3Cu32%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;u32&gt; for f64</pre></section><section id="impl-FloatToInt%3Cu64%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;u64&gt; for f64</pre></section><section id="impl-FloatToInt%3Cu8%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;u8&gt; for f64</pre></section><section id="impl-FloatToInt%3Cusize%3E-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/num.rs.html#39">source</a><pre class="code-header" data-language="rust">impl FloatToInt&lt;usize&gt; for f64</pre></section><section id="impl-SimdCast-for-f64" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/portable-simd/crates/core_simd/src/cast.rs.html#51">source</a><pre class="code-header" data-language="rust">impl SimdCast for f64</pre></section>
</div>
<h3 id="synthetic-implementations" class="section-header">Auto Trait Implementations</h3>
<div id="synthetic-implementations-list">
<section id="impl-Freeze-for-f64" class="impl"><pre class="code-header" data-language="rust">impl Freeze for f64</pre></section><section id="impl-RefUnwindSafe-for-f64" class="impl"><pre class="code-header" data-language="rust">impl RefUnwindSafe for f64</pre></section><section id="impl-Send-for-f64" class="impl"><pre class="code-header" data-language="rust">impl Send for f64</pre></section><section id="impl-Sync-for-f64" class="impl"><pre class="code-header" data-language="rust">impl Sync for f64</pre></section><section id="impl-Unpin-for-f64" class="impl"><pre class="code-header" data-language="rust">impl Unpin for f64</pre></section><section id="impl-UnwindSafe-for-f64" class="impl"><pre class="code-header" data-language="rust">impl UnwindSafe for f64</pre></section>
</div>
<h3 id="blanket-implementations" class="section-header">Blanket Implementations</h3>
<div id="blanket-implementations-list">
<summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#140">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Any for Twhere
    T: 'static + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/any.rs.html#141">source</a><pre class="code-header" data-language="rust">fn type_id(&amp;self) -&gt; TypeId</pre></section></summary><div class="docblock">Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.any.html#tymethod.type_id">Read more</a>
</div>
</div>
<summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#208">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Borrow&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#210">source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="borrow/trait.borrow.html#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#216">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; BorrowMut&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/borrow.rs.html#217">source</a><pre class="code-header" data-language="rust">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</pre></section></summary><div class="docblock">Mutably borrows from an owned value. <a href="borrow/trait.borrowmut.html#tymethod.borrow_mut">Read more</a>
</div>
</div>
<summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#765">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;T&gt; for T</pre></section></summary><div class="impl-items">
<summary><section id="method.from-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#768">source</a><pre class="code-header" data-language="rust">fn from(t: T) -&gt; T</pre></section></summary><div class="docblock">
<p>Returns the argument unchanged.</p> </div>
</div>
<summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#748-750">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; Into&lt;U&gt; for Twhere
    U: From&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#758">source</a><pre class="code-header" data-language="rust">fn into(self) -&gt; U</pre></section></summary><div class="docblock">
<p>Calls <code>U::from(self)</code>.</p> <p>That is, this conversion is whatever the implementation of <code><a href="convert/trait.from.html" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p> </div>
</div>
<summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#83-85">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; ToOwned for Twhere
    T: Clone,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Owned = T</pre></section></summary><div class="docblock">The resulting type after obtaining ownership.</div>
<summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#88">source</a><pre class="code-header" data-language="rust">fn to_owned(&amp;self) -&gt; T</pre></section></summary><div class="docblock">Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.toowned.html#tymethod.to_owned">Read more</a>
</div>
<summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/alloc/borrow.rs.html#92">source</a><pre class="code-header" data-language="rust">fn clone_into(&amp;self, target: &amp;mut T)</pre></section></summary><div class="docblock">Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.toowned.html#method.clone_into">Read more</a>
</div>
</div>
<summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2552">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; ToString for Twhere
    T: Display + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/alloc/string.rs.html#2558">source</a><pre class="code-header" data-language="rust">default fn to_string(&amp;self) -&gt; String</pre></section></summary><div class="docblock">Converts the given value to a <code>String</code>. <a href="string/trait.tostring.html#tymethod.to_string">Read more</a>
</div>
</div>
<summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#805-807">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryFrom&lt;U&gt; for Twhere
    U: Into&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Error = Infallible</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#812">source</a><pre class="code-header" data-language="rust">fn try_from(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
<summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#790-792">source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryInto&lt;U&gt; for Twhere
    U: TryFrom&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Error = &lt;U as TryFrom&lt;T&gt;&gt;::Error</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.0/src/core/convert/mod.rs.html#797">source</a><pre class="code-header" data-language="rust">fn try_into(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/primitive.f64.html" class="_attribution-link">https://doc.rust-lang.org/std/primitive.f64.html</a>
  </p>
</div>
