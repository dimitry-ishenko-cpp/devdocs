<h1 class="main-heading">Keyword const</h1>
<p>Compile-time constants, compile-time evaluable functions, and raw pointers.</p> <h3 id="compile-time-constants">Compile-time constants</h3> <p>Sometimes a certain value is used many times throughout a program, and it can become inconvenient to copy it over and over. What’s more, it’s not always possible or desirable to make it a variable that gets carried around to each function that needs it. In these cases, the <code>const</code> keyword provides a convenient alternative to code duplication:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">const THING: u32 = 0xABAD1DEA;

let foo = 123 + THING;</pre></div> <p>Constants must be explicitly typed; unlike with <code>let</code>, you can’t ignore their type and let the compiler figure it out. Any constant value can be defined in a <code>const</code>, which in practice happens to be most things that would be reasonable to have in a constant (barring <code>const fn</code>s). For example, you can’t have a <a href="fs/struct.file.html" title="struct std::fs::File"><code>File</code></a> as a <code>const</code>.</p> <p>The only lifetime allowed in a constant is <code>'static</code>, which is the lifetime that encompasses all others in a Rust program. For example, if you wanted to define a constant string, it would look like this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">const WORDS: &amp;'static str = "hello rust!";</pre></div> <p>Thanks to static lifetime elision, you usually don’t have to explicitly use <code>'static</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">const WORDS: &amp;str = "hello convenience!";</pre></div> <p><code>const</code> items look remarkably similar to <code>static</code> items, which introduces some confusion as to which one should be used at which times. To put it simply, constants are inlined wherever they’re used, making using them identical to simply replacing the name of the <code>const</code> with its value. Static variables, on the other hand, point to a single location in memory, which all accesses share. This means that, unlike with constants, they can’t have destructors, and act as a single value across the entire codebase.</p> <p>Constants, like statics, should always be in <code>SCREAMING_SNAKE_CASE</code>.</p> <p>For more detail on <code>const</code>, see the <a href="../book/ch03-01-variables-and-mutability.html#constants">Rust Book</a> or the <a href="../reference/items/constant-items.html">Reference</a>.</p> <h3 id="compile-time-evaluable-functions">Compile-time evaluable functions</h3> <p>The other main use of the <code>const</code> keyword is in <code>const fn</code>. This marks a function as being callable in the body of a <code>const</code> or <code>static</code> item and in array initializers (commonly called “const contexts”). <code>const fn</code> are restricted in the set of operations they can perform, to ensure that they can be evaluated at compile-time. See the <a href="../reference/const_eval.html">Reference</a> for more detail.</p> <p>Turning a <code>fn</code> into a <code>const fn</code> has no effect on run-time uses of that function.</p> <h3 id="other-uses-of-const">Other uses of <code>const</code>
</h3> <p>The <code>const</code> keyword is also used in raw pointers in combination with <code>mut</code>, as seen in <code>*const T</code> and <code>*mut T</code>. More about <code>const</code> as used in raw pointers can be read at the Rust docs for the <a href="primitive.pointer.html" title="primitive pointer">pointer primitive</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/keyword.const.html" class="_attribution-link">https://doc.rust-lang.org/std/keyword.const.html</a>
  </p>
</div>
