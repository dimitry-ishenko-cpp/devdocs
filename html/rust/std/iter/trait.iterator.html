<h1 class="main-heading">Trait Iterator</h1>
<pre class="rust item-decl" data-language="rust">pub trait Iterator {
    type Item;

Show 76 methods    // Required method
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // Provided methods
    fn next_chunk&lt;const N: usize&gt;(
        &amp;mut self,
    ) -&gt; Result&lt;[Self::Item; N], IntoIter&lt;Self::Item, N&gt;&gt;
       where Self: Sized { ... }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { ... }
    fn count(self) -&gt; usize
       where Self: Sized { ... }
    fn last(self) -&gt; Option&lt;Self::Item&gt;
       where Self: Sized { ... }
    fn advance_by(&amp;mut self, n: usize) -&gt; Result&lt;(), NonZero&lt;usize&gt;&gt; { ... }
    fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt; { ... }
    fn step_by(self, step: usize) -&gt; StepBy&lt;Self&gt; ⓘ
       where Self: Sized { ... }
    fn chain&lt;U&gt;(self, other: U) -&gt; Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt; ⓘ
       where Self: Sized,
             U: IntoIterator&lt;Item = Self::Item&gt; { ... }
    fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt; ⓘ
       where Self: Sized,
             U: IntoIterator { ... }
    fn intersperse(self, separator: Self::Item) -&gt; Intersperse&lt;Self&gt; ⓘ
       where Self: Sized,
             Self::Item: Clone { ... }
    fn intersperse_with&lt;G&gt;(self, separator: G) -&gt; IntersperseWith&lt;Self, G&gt; ⓘ
       where Self: Sized,
             G: FnMut() -&gt; Self::Item { ... }
    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; ⓘ
       where Self: Sized,
             F: FnMut(Self::Item) -&gt; B { ... }
    fn for_each&lt;F&gt;(self, f: F)
       where Self: Sized,
             F: FnMut(Self::Item) { ... }
    fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt; ⓘ
       where Self: Sized,
             P: FnMut(&amp;Self::Item) -&gt; bool { ... }
    fn filter_map&lt;B, F&gt;(self, f: F) -&gt; FilterMap&lt;Self, F&gt; ⓘ
       where Self: Sized,
             F: FnMut(Self::Item) -&gt; Option&lt;B&gt; { ... }
    fn enumerate(self) -&gt; Enumerate&lt;Self&gt; ⓘ
       where Self: Sized { ... }
    fn peekable(self) -&gt; Peekable&lt;Self&gt; ⓘ
       where Self: Sized { ... }
    fn skip_while&lt;P&gt;(self, predicate: P) -&gt; SkipWhile&lt;Self, P&gt; ⓘ
       where Self: Sized,
             P: FnMut(&amp;Self::Item) -&gt; bool { ... }
    fn take_while&lt;P&gt;(self, predicate: P) -&gt; TakeWhile&lt;Self, P&gt; ⓘ
       where Self: Sized,
             P: FnMut(&amp;Self::Item) -&gt; bool { ... }
    fn map_while&lt;B, P&gt;(self, predicate: P) -&gt; MapWhile&lt;Self, P&gt; ⓘ
       where Self: Sized,
             P: FnMut(Self::Item) -&gt; Option&lt;B&gt; { ... }
    fn skip(self, n: usize) -&gt; Skip&lt;Self&gt; ⓘ
       where Self: Sized { ... }
    fn take(self, n: usize) -&gt; Take&lt;Self&gt; ⓘ
       where Self: Sized { ... }
    fn scan&lt;St, B, F&gt;(self, initial_state: St, f: F) -&gt; Scan&lt;Self, St, F&gt; ⓘ
       where Self: Sized,
             F: FnMut(&amp;mut St, Self::Item) -&gt; Option&lt;B&gt; { ... }
    fn flat_map&lt;U, F&gt;(self, f: F) -&gt; FlatMap&lt;Self, U, F&gt; ⓘ
       where Self: Sized,
             U: IntoIterator,
             F: FnMut(Self::Item) -&gt; U { ... }
    fn flatten(self) -&gt; Flatten&lt;Self&gt; ⓘ
       where Self: Sized,
             Self::Item: IntoIterator { ... }
    fn map_windows&lt;F, R, const N: usize&gt;(self, f: F) -&gt; MapWindows&lt;Self, F, N&gt; ⓘ
       where Self: Sized,
             F: FnMut(&amp;[Self::Item; N]) -&gt; R { ... }
    fn fuse(self) -&gt; Fuse&lt;Self&gt; ⓘ
       where Self: Sized { ... }
    fn inspect&lt;F&gt;(self, f: F) -&gt; Inspect&lt;Self, F&gt; ⓘ
       where Self: Sized,
             F: FnMut(&amp;Self::Item) { ... }
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
       where Self: Sized { ... }
    fn collect&lt;B&gt;(self) -&gt; B
       where B: FromIterator&lt;Self::Item&gt;,
             Self: Sized { ... }
    fn try_collect&lt;B&gt;(
        &amp;mut self,
    ) -&gt; &lt;&lt;Self::Item as Try&gt;::Residual as Residual&lt;B&gt;&gt;::TryType
       where Self: Sized,
             Self::Item: Try,
             &lt;Self::Item as Try&gt;::Residual: Residual&lt;B&gt;,
             B: FromIterator&lt;&lt;Self::Item as Try&gt;::Output&gt; { ... }
    fn collect_into&lt;E&gt;(self, collection: &amp;mut E) -&gt; &amp;mut E
       where E: Extend&lt;Self::Item&gt;,
             Self: Sized { ... }
    fn partition&lt;B, F&gt;(self, f: F) -&gt; (B, B)
       where Self: Sized,
             B: Default + Extend&lt;Self::Item&gt;,
             F: FnMut(&amp;Self::Item) -&gt; bool { ... }
    fn partition_in_place&lt;'a, T, P&gt;(self, predicate: P) -&gt; usize
       where T: 'a,
             Self: Sized + DoubleEndedIterator&lt;Item = &amp;'a mut T&gt;,
             P: FnMut(&amp;T) -&gt; bool { ... }
    fn is_partitioned&lt;P&gt;(self, predicate: P) -&gt; bool
       where Self: Sized,
             P: FnMut(Self::Item) -&gt; bool { ... }
    fn try_fold&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; R
       where Self: Sized,
             F: FnMut(B, Self::Item) -&gt; R,
             R: Try&lt;Output = B&gt; { ... }
    fn try_for_each&lt;F, R&gt;(&amp;mut self, f: F) -&gt; R
       where Self: Sized,
             F: FnMut(Self::Item) -&gt; R,
             R: Try&lt;Output = ()&gt; { ... }
    fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B
       where Self: Sized,
             F: FnMut(B, Self::Item) -&gt; B { ... }
    fn reduce&lt;F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
       where Self: Sized,
             F: FnMut(Self::Item, Self::Item) -&gt; Self::Item { ... }
    fn try_reduce&lt;R&gt;(
        &amp;mut self,
        f: impl FnMut(Self::Item, Self::Item) -&gt; R,
    ) -&gt; &lt;&lt;R as Try&gt;::Residual as Residual&lt;Option&lt;&lt;R as Try&gt;::Output&gt;&gt;&gt;::TryType
       where Self: Sized,
             R: Try&lt;Output = Self::Item&gt;,
             &lt;R as Try&gt;::Residual: Residual&lt;Option&lt;Self::Item&gt;&gt; { ... }
    fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
       where Self: Sized,
             F: FnMut(Self::Item) -&gt; bool { ... }
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
       where Self: Sized,
             F: FnMut(Self::Item) -&gt; bool { ... }
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt;
       where Self: Sized,
             P: FnMut(&amp;Self::Item) -&gt; bool { ... }
    fn find_map&lt;B, F&gt;(&amp;mut self, f: F) -&gt; Option&lt;B&gt;
       where Self: Sized,
             F: FnMut(Self::Item) -&gt; Option&lt;B&gt; { ... }
    fn try_find&lt;R&gt;(
        &amp;mut self,
        f: impl FnMut(&amp;Self::Item) -&gt; R,
    ) -&gt; &lt;&lt;R as Try&gt;::Residual as Residual&lt;Option&lt;Self::Item&gt;&gt;&gt;::TryType
       where Self: Sized,
             R: Try&lt;Output = bool&gt;,
             &lt;R as Try&gt;::Residual: Residual&lt;Option&lt;Self::Item&gt;&gt; { ... }
    fn position&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;
       where Self: Sized,
             P: FnMut(Self::Item) -&gt; bool { ... }
    fn rposition&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;
       where P: FnMut(Self::Item) -&gt; bool,
             Self: Sized + ExactSizeIterator + DoubleEndedIterator { ... }
    fn max(self) -&gt; Option&lt;Self::Item&gt;
       where Self: Sized,
             Self::Item: Ord { ... }
    fn min(self) -&gt; Option&lt;Self::Item&gt;
       where Self: Sized,
             Self::Item: Ord { ... }
    fn max_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
       where B: Ord,
             Self: Sized,
             F: FnMut(&amp;Self::Item) -&gt; B { ... }
    fn max_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;
       where Self: Sized,
             F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering { ... }
    fn min_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
       where B: Ord,
             Self: Sized,
             F: FnMut(&amp;Self::Item) -&gt; B { ... }
    fn min_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;
       where Self: Sized,
             F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering { ... }
    fn rev(self) -&gt; Rev&lt;Self&gt; ⓘ
       where Self: Sized + DoubleEndedIterator { ... }
    fn unzip&lt;A, B, FromA, FromB&gt;(self) -&gt; (FromA, FromB)
       where FromA: Default + Extend&lt;A&gt;,
             FromB: Default + Extend&lt;B&gt;,
             Self: Sized + Iterator&lt;Item = (A, B)&gt; { ... }
    fn copied&lt;'a, T&gt;(self) -&gt; Copied&lt;Self&gt; ⓘ
       where T: 'a + Copy,
             Self: Sized + Iterator&lt;Item = &amp;'a T&gt; { ... }
    fn cloned&lt;'a, T&gt;(self) -&gt; Cloned&lt;Self&gt; ⓘ
       where T: 'a + Clone,
             Self: Sized + Iterator&lt;Item = &amp;'a T&gt; { ... }
    fn cycle(self) -&gt; Cycle&lt;Self&gt; ⓘ
       where Self: Sized + Clone { ... }
    fn array_chunks&lt;const N: usize&gt;(self) -&gt; ArrayChunks&lt;Self, N&gt; ⓘ
       where Self: Sized { ... }
    fn sum&lt;S&gt;(self) -&gt; S
       where Self: Sized,
             S: Sum&lt;Self::Item&gt; { ... }
    fn product&lt;P&gt;(self) -&gt; P
       where Self: Sized,
             P: Product&lt;Self::Item&gt; { ... }
    fn cmp&lt;I&gt;(self, other: I) -&gt; Ordering
       where I: IntoIterator&lt;Item = Self::Item&gt;,
             Self::Item: Ord,
             Self: Sized { ... }
    fn cmp_by&lt;I, F&gt;(self, other: I, cmp: F) -&gt; Ordering
       where Self: Sized,
             I: IntoIterator,
             F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Ordering { ... }
    fn partial_cmp&lt;I&gt;(self, other: I) -&gt; Option&lt;Ordering&gt;
       where I: IntoIterator,
             Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,
             Self: Sized { ... }
    fn partial_cmp_by&lt;I, F&gt;(self, other: I, partial_cmp: F) -&gt; Option&lt;Ordering&gt;
       where Self: Sized,
             I: IntoIterator,
             F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Option&lt;Ordering&gt; { ... }
    fn eq&lt;I&gt;(self, other: I) -&gt; bool
       where I: IntoIterator,
             Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;,
             Self: Sized { ... }
    fn eq_by&lt;I, F&gt;(self, other: I, eq: F) -&gt; bool
       where Self: Sized,
             I: IntoIterator,
             F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; bool { ... }
    fn ne&lt;I&gt;(self, other: I) -&gt; bool
       where I: IntoIterator,
             Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;,
             Self: Sized { ... }
    fn lt&lt;I&gt;(self, other: I) -&gt; bool
       where I: IntoIterator,
             Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,
             Self: Sized { ... }
    fn le&lt;I&gt;(self, other: I) -&gt; bool
       where I: IntoIterator,
             Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,
             Self: Sized { ... }
    fn gt&lt;I&gt;(self, other: I) -&gt; bool
       where I: IntoIterator,
             Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,
             Self: Sized { ... }
    fn ge&lt;I&gt;(self, other: I) -&gt; bool
       where I: IntoIterator,
             Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,
             Self: Sized { ... }
    fn is_sorted(self) -&gt; bool
       where Self: Sized,
             Self::Item: PartialOrd { ... }
    fn is_sorted_by&lt;F&gt;(self, compare: F) -&gt; bool
       where Self: Sized,
             F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; bool { ... }
    fn is_sorted_by_key&lt;F, K&gt;(self, f: F) -&gt; bool
       where Self: Sized,
             F: FnMut(Self::Item) -&gt; K,
             K: PartialOrd { ... }
}</pre>
<p>A trait for dealing with iterators.</p> <p>This is the main iterator trait. For more about the concept of iterators generally, please see the <a href="index.html" title="mod std::iter">module-level documentation</a>. In particular, you may want to know how to <a href="index.html#implementing-iterator" title="mod std::iter">implement <code>Iterator</code></a>.</p> <h3 id="required-associated-types" class="section-header">Required Associated Types</h3>
<div class="methods">
<summary><section id="associatedtype.Item" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#43">Source</a></span><pre class="code-header" data-language="rust">type Item</pre></section></summary><div class="docblock">
<p>The type of the elements being iterated over.</p> </div>
</div>
<h3 id="required-methods" class="section-header">Required Methods</h3>
<div class="methods">
<summary><section id="tymethod.next" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#75">Source</a></span><pre class="code-header" data-language="rust">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;</pre></section></summary><div class="docblock">
<p>Advances the iterator and returns the next value.</p> <p>Returns <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> when iteration is finished. Individual iterator implementations may choose to resume iteration, and so calling <code>next()</code> again may or may not eventually start returning <a href="../option/enum.option.html#variant.Some" title="variant std::option::Option::Some"><code>Some(Item)</code></a> again at some point.</p> <h5 id="examples">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let mut iter = a.iter();

// A call to next() returns the next value...
assert_eq!(Some(&amp;1), iter.next());
assert_eq!(Some(&amp;2), iter.next());
assert_eq!(Some(&amp;3), iter.next());

// ... and then None once it's over.
assert_eq!(None, iter.next());

// More calls may or may not return `None`. Here, they always will.
assert_eq!(None, iter.next());
assert_eq!(None, iter.next());</pre></div> </div>
</div>
<h3 id="provided-methods" class="section-header">Provided Methods</h3>
<div class="methods">
<summary><section id="method.next_chunk" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#109-113">Source</a><pre class="code-header" data-language="rust">fn next_chunk&lt;const N: usize&gt;(
    &amp;mut self,
) -&gt; Result&lt;[Self::Item; N], IntoIter&lt;Self::Item, N&gt;&gt;where
    Self: Sized,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_next_chunk</code> <a href="https://github.com/rust-lang/rust/issues/98326">#98326</a>)</span>
</div></span></summary><div class="docblock">
<p>Advances the iterator and returns an array containing the next <code>N</code> values.</p> <p>If there are not enough elements to fill the array then <code>Err</code> is returned containing an iterator over the remaining elements.</p> <h5 id="examples-1">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_next_chunk)]

let mut iter = "lorem".chars();

assert_eq!(iter.next_chunk().unwrap(), ['l', 'o']);              // N is inferred as 2
assert_eq!(iter.next_chunk().unwrap(), ['r', 'e', 'm']);         // N is inferred as 3
assert_eq!(iter.next_chunk::&lt;4&gt;().unwrap_err().as_slice(), &amp;[]); // N is explicitly 4</pre></div> <p>Split a string and get the first three items.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_next_chunk)]

let quote = "not all those who wander are lost";
let [first, second, third] = quote.split_whitespace().next_chunk().unwrap();
assert_eq!(first, "not");
assert_eq!(second, "all");
assert_eq!(third, "those");</pre></div> </div>
<summary><section id="method.size_hint" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#186">Source</a></span><pre class="code-header" data-language="rust">fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;)</pre></section></summary><div class="docblock">
<p>Returns the bounds on the remaining length of the iterator.</p> <p>Specifically, <code>size_hint()</code> returns a tuple where the first element is the lower bound, and the second element is the upper bound.</p> <p>The second half of the tuple that is returned is an <code><a href="../option/enum.option.html" title="enum std::option::Option">Option</a>&lt;<a href="../primitive.usize.html" title="primitive usize">usize</a>&gt;</code>. A <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> here means that either there is no known upper bound, or the upper bound is larger than <a href="../primitive.usize.html" title="primitive usize"><code>usize</code></a>.</p> <h5 id="implementation-notes">Implementation notes</h5> <p>It is not enforced that an iterator implementation yields the declared number of elements. A buggy iterator may yield less than the lower bound or more than the upper bound of elements.</p> <p><code>size_hint()</code> is primarily intended to be used for optimizations such as reserving space for the elements of the iterator, but must not be trusted to e.g., omit bounds checks in unsafe code. An incorrect implementation of <code>size_hint()</code> should not lead to memory safety violations.</p> <p>That said, the implementation should provide a correct estimation, because otherwise it would be a violation of the trait’s protocol.</p> <p>The default implementation returns <code>(0, <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None">None</a>)</code> which is correct for any iterator.</p> <h5 id="examples-2">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];
let mut iter = a.iter();

assert_eq!((3, Some(3)), iter.size_hint());
let _ = iter.next();
assert_eq!((2, Some(2)), iter.size_hint());</pre></div> <p>A more complex example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">// The even numbers in the range of zero to nine.
let iter = (0..10).filter(|x| x % 2 == 0);

// We might iterate from zero to ten times. Knowing that it's five
// exactly wouldn't be possible without executing filter().
assert_eq!((0, Some(10)), iter.size_hint());

// Let's add five more numbers with chain()
let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);

// now both bounds are increased by five
assert_eq!((5, Some(15)), iter.size_hint());</pre></div> <p>Returning <code>None</code> for an upper bound:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">// an infinite iterator has no upper bound
// and the maximum possible lower bound
let iter = 0..;

assert_eq!((usize::MAX, None), iter.size_hint());</pre></div> </div>
<summary><section id="method.count" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#221-223">Source</a></span><pre class="code-header" data-language="rust">fn count(self) -&gt; usizewhere
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Consumes the iterator, counting the number of iterations and returning it.</p> <p>This method will call <a href="trait.iterator.html#tymethod.next" title="method std::iter::Iterator::next"><code>next</code></a> repeatedly until <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is encountered, returning the number of times it saw <a href="../option/enum.option.html#variant.Some" title="variant std::option::Option::Some"><code>Some</code></a>. Note that <a href="trait.iterator.html#tymethod.next" title="method std::iter::Iterator::next"><code>next</code></a> has to be called at least once even if the iterator does not have any elements.</p> <h5 id="overflow-behavior">Overflow Behavior</h5> <p>The method does no guarding against overflows, so counting elements of an iterator with more than <a href="../primitive.usize.html#associatedconstant.MAX" title="associated constant usize::MAX"><code>usize::MAX</code></a> elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</p> <h5 id="panics">Panics</h5> <p>This function might panic if the iterator has more than <a href="../primitive.usize.html#associatedconstant.MAX" title="associated constant usize::MAX"><code>usize::MAX</code></a> elements.</p> <h5 id="examples-3">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];
assert_eq!(a.iter().count(), 3);

let a = [1, 2, 3, 4, 5];
assert_eq!(a.iter().count(), 5);</pre></div> </div>
<summary><section id="method.last" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#249-251">Source</a></span><pre class="code-header" data-language="rust">fn last(self) -&gt; Option&lt;Self::Item&gt;where
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Consumes the iterator, returning the last element.</p> <p>This method will evaluate the iterator until it returns <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>. While doing so, it keeps track of the current element. After <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is returned, <code>last()</code> will then return the last element it saw.</p> <h5 id="examples-4">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];
assert_eq!(a.iter().last(), Some(&amp;3));

let a = [1, 2, 3, 4, 5];
assert_eq!(a.iter().last(), Some(&amp;5));</pre></div> </div>
<summary><section id="method.advance_by" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#296">Source</a><pre class="code-header" data-language="rust">fn advance_by(&amp;mut self, n: usize) -&gt; Result&lt;(), NonZero&lt;usize&gt;&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_advance_by</code> <a href="https://github.com/rust-lang/rust/issues/77404">#77404</a>)</span>
</div></span></summary><div class="docblock">
<p>Advances the iterator by <code>n</code> elements.</p> <p>This method will eagerly skip <code>n</code> elements by calling <a href="trait.iterator.html#tymethod.next" title="method std::iter::Iterator::next"><code>next</code></a> up to <code>n</code> times until <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is encountered.</p> <p><code>advance_by(n)</code> will return <code>Ok(())</code> if the iterator successfully advances by <code>n</code> elements, or a <code>Err(NonZero&lt;usize&gt;)</code> with value <code>k</code> if <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is encountered, where <code>k</code> is remaining number of steps that could not be advanced because the iterator ran out. If <code>self</code> is empty and <code>n</code> is non-zero, then this returns <code>Err(n)</code>. Otherwise, <code>k</code> is always less than <code>n</code>.</p> <p>Calling <code>advance_by(0)</code> can do meaningful work, for example <a href="struct.flatten.html" title="struct std::iter::Flatten"><code>Flatten</code></a> can advance its outer iterator until it finds an inner iterator that is not empty, which then often allows it to return a more accurate <code>size_hint()</code> than in its initial state.</p> <h5 id="examples-5">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_advance_by)]

use std::num::NonZero;

let a = [1, 2, 3, 4];
let mut iter = a.iter();

assert_eq!(iter.advance_by(2), Ok(()));
assert_eq!(iter.next(), Some(&amp;3));
assert_eq!(iter.advance_by(0), Ok(()));
assert_eq!(iter.advance_by(100), Err(NonZero::new(99).unwrap())); // only `&amp;4` was skipped</pre></div> </div>
<summary><section id="method.nth" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#347">Source</a></span><pre class="code-header" data-language="rust">fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt;</pre></section></summary><div class="docblock">
<p>Returns the <code>n</code>th element of the iterator.</p> <p>Like most indexing operations, the count starts from zero, so <code>nth(0)</code> returns the first value, <code>nth(1)</code> the second, and so on.</p> <p>Note that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling <code>nth(0)</code> multiple times on the same iterator will return different elements.</p> <p><code>nth()</code> will return <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> if <code>n</code> is greater than or equal to the length of the iterator.</p> <h5 id="examples-6">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];
assert_eq!(a.iter().nth(1), Some(&amp;2));</pre></div> <p>Calling <code>nth()</code> multiple times doesn’t rewind the iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let mut iter = a.iter();

assert_eq!(iter.nth(1), Some(&amp;2));
assert_eq!(iter.nth(1), None);</pre></div> <p>Returning <code>None</code> if there are less than <code>n + 1</code> elements:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];
assert_eq!(a.iter().nth(10), None);</pre></div> </div>
<summary><section id="method.step_by" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#397-399">Source</a></span><pre class="code-header" data-language="rust">fn step_by(self, step: usize) -&gt; StepBy&lt;Self&gt; ⓘwhere
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Creates an iterator starting at the same point, but stepping by the given amount at each iteration.</p> <p>Note 1: The first element of the iterator will always be returned, regardless of the step given.</p> <p>Note 2: The time at which ignored elements are pulled is not fixed. <code>StepBy</code> behaves like the sequence <code>self.next()</code>, <code>self.nth(step-1)</code>, <code>self.nth(step-1)</code>, …, but is also free to behave like the sequence <code>advance_n_and_return_first(&amp;mut self, step)</code>, <code>advance_n_and_return_first(&amp;mut self, step)</code>, … Which way is used may change for some iterators for performance reasons. The second way will advance the iterator earlier and may consume more items.</p> <p><code>advance_n_and_return_first</code> is the equivalent of:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">fn advance_n_and_return_first&lt;I&gt;(iter: &amp;mut I, n: usize) -&gt; Option&lt;I::Item&gt;
where
    I: Iterator,
{
    let next = iter.next();
    if n &gt; 1 {
        iter.nth(n - 2);
    }
    next
}</pre></div> <h5 id="panics-1">Panics</h5> <p>The method will panic if the given step is <code>0</code>.</p> <h5 id="examples-7">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [0, 1, 2, 3, 4, 5];
let mut iter = a.iter().step_by(2);

assert_eq!(iter.next(), Some(&amp;0));
assert_eq!(iter.next(), Some(&amp;2));
assert_eq!(iter.next(), Some(&amp;4));
assert_eq!(iter.next(), None);</pre></div> </div>
<summary><section id="method.chain" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#468-471">Source</a></span><pre class="code-header" data-language="rust">fn chain&lt;U&gt;(self, other: U) -&gt; Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt; ⓘwhere
    Self: Sized,
    U: IntoIterator&lt;Item = Self::Item&gt;,</pre></section></summary><div class="docblock">
<p>Takes two iterators and creates a new iterator over both in sequence.</p> <p><code>chain()</code> will return a new iterator which will first iterate over values from the first iterator and then over values from the second iterator.</p> <p>In other words, it links two iterators together, in a chain. 🔗</p> <p><a href="fn.once.html" title="fn std::iter::once"><code>once</code></a> is commonly used to adapt a single value into a chain of other kinds of iteration.</p> <h5 id="examples-8">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a1 = [1, 2, 3];
let a2 = [4, 5, 6];

let mut iter = a1.iter().chain(a2.iter());

assert_eq!(iter.next(), Some(&amp;1));
assert_eq!(iter.next(), Some(&amp;2));
assert_eq!(iter.next(), Some(&amp;3));
assert_eq!(iter.next(), Some(&amp;4));
assert_eq!(iter.next(), Some(&amp;5));
assert_eq!(iter.next(), Some(&amp;6));
assert_eq!(iter.next(), None);</pre></div> <p>Since the argument to <code>chain()</code> uses <a href="trait.intoiterator.html" title="trait std::iter::IntoIterator"><code>IntoIterator</code></a>, we can pass anything that can be converted into an <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a>, not just an <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> itself. For example, slices (<code>&amp;[T]</code>) implement <a href="trait.intoiterator.html" title="trait std::iter::IntoIterator"><code>IntoIterator</code></a>, and so can be passed to <code>chain()</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s1 = &amp;[1, 2, 3];
let s2 = &amp;[4, 5, 6];

let mut iter = s1.iter().chain(s2);

assert_eq!(iter.next(), Some(&amp;1));
assert_eq!(iter.next(), Some(&amp;2));
assert_eq!(iter.next(), Some(&amp;3));
assert_eq!(iter.next(), Some(&amp;4));
assert_eq!(iter.next(), Some(&amp;5));
assert_eq!(iter.next(), Some(&amp;6));
assert_eq!(iter.next(), None);</pre></div> <p>If you work with Windows API, you may wish to convert <a href="../ffi/struct.osstr.html"><code>OsStr</code></a> to <code>Vec&lt;u16&gt;</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#[cfg(windows)]
fn os_str_to_utf16(s: &amp;std::ffi::OsStr) -&gt; Vec&lt;u16&gt; {
    use std::os::windows::ffi::OsStrExt;
    s.encode_wide().chain(std::iter::once(0)).collect()
}</pre></div> </div>
<summary><section id="method.zip" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#586-589">Source</a></span><pre class="code-header" data-language="rust">fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt; ⓘwhere
    Self: Sized,
    U: IntoIterator,</pre></section></summary><div class="docblock">
<p>‘Zips up’ two iterators into a single iterator of pairs.</p> <p><code>zip()</code> returns a new iterator that will iterate over two other iterators, returning a tuple where the first element comes from the first iterator, and the second element comes from the second iterator.</p> <p>In other words, it zips two iterators together, into a single one.</p> <p>If either iterator returns <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>, <a href="trait.iterator.html#tymethod.next" title="method std::iter::Iterator::next"><code>next</code></a> from the zipped iterator will return <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>. If the zipped iterator has no more elements to return then each further attempt to advance it will first try to advance the first iterator at most one time and if it still yielded an item try to advance the second iterator at most one time.</p> <p>To ‘undo’ the result of zipping up two iterators, see <a href="trait.iterator.html#method.unzip" title="method std::iter::Iterator::unzip"><code>unzip</code></a>.</p> <h5 id="examples-9">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a1 = [1, 2, 3];
let a2 = [4, 5, 6];

let mut iter = a1.iter().zip(a2.iter());

assert_eq!(iter.next(), Some((&amp;1, &amp;4)));
assert_eq!(iter.next(), Some((&amp;2, &amp;5)));
assert_eq!(iter.next(), Some((&amp;3, &amp;6)));
assert_eq!(iter.next(), None);</pre></div> <p>Since the argument to <code>zip()</code> uses <a href="trait.intoiterator.html" title="trait std::iter::IntoIterator"><code>IntoIterator</code></a>, we can pass anything that can be converted into an <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a>, not just an <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> itself. For example, slices (<code>&amp;[T]</code>) implement <a href="trait.intoiterator.html" title="trait std::iter::IntoIterator"><code>IntoIterator</code></a>, and so can be passed to <code>zip()</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s1 = &amp;[1, 2, 3];
let s2 = &amp;[4, 5, 6];

let mut iter = s1.iter().zip(s2);

assert_eq!(iter.next(), Some((&amp;1, &amp;4)));
assert_eq!(iter.next(), Some((&amp;2, &amp;5)));
assert_eq!(iter.next(), Some((&amp;3, &amp;6)));
assert_eq!(iter.next(), None);</pre></div> <p><code>zip()</code> is often used to zip an infinite iterator to a finite one. This works because the finite iterator will eventually return <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>, ending the zipper. Zipping with <code>(0..)</code> can look a lot like <a href="trait.iterator.html#method.enumerate" title="method std::iter::Iterator::enumerate"><code>enumerate</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let enumerate: Vec&lt;_&gt; = "foo".chars().enumerate().collect();

let zipper: Vec&lt;_&gt; = (0..).zip("foo".chars()).collect();

assert_eq!((0, 'f'), enumerate[0]);
assert_eq!((0, 'f'), zipper[0]);

assert_eq!((1, 'o'), enumerate[1]);
assert_eq!((1, 'o'), zipper[1]);

assert_eq!((2, 'o'), enumerate[2]);
assert_eq!((2, 'o'), zipper[2]);</pre></div> <p>If both iterators have roughly equivalent syntax, it may be more readable to use <a href="fn.zip.html" title="fn std::iter::zip"><code>zip</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::iter::zip;

let a = [1, 2, 3];
let b = [2, 3, 4];

let mut zipped = zip(
    a.into_iter().map(|x| x * 2).skip(1),
    b.into_iter().map(|x| x * 2).skip(1),
);

assert_eq!(zipped.next(), Some((4, 6)));
assert_eq!(zipped.next(), Some((6, 8)));
assert_eq!(zipped.next(), None);</pre></div> <p>compared to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut zipped = a
    .into_iter()
    .map(|x| x * 2)
    .skip(1)
    .zip(b.into_iter().map(|x| x * 2).skip(1));</pre></div> </div>
<summary><section id="method.intersperse" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#628-631">Source</a><pre class="code-header" data-language="rust">fn intersperse(self, separator: Self::Item) -&gt; Intersperse&lt;Self&gt; ⓘwhere
    Self: Sized,
    Self::Item: Clone,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_intersperse</code> <a href="https://github.com/rust-lang/rust/issues/79524">#79524</a>)</span>
</div></span></summary><div class="docblock">
<p>Creates a new iterator which places a copy of <code>separator</code> between adjacent items of the original iterator.</p> <p>In case <code>separator</code> does not implement <a href="../clone/trait.clone.html" title="trait std::clone::Clone"><code>Clone</code></a> or needs to be computed every time, use <a href="trait.iterator.html#method.intersperse_with" title="method std::iter::Iterator::intersperse_with"><code>intersperse_with</code></a>.</p> <h5 id="examples-10">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_intersperse)]

let mut a = [0, 1, 2].iter().intersperse(&amp;100);
assert_eq!(a.next(), Some(&amp;0));   // The first element from `a`.
assert_eq!(a.next(), Some(&amp;100)); // The separator.
assert_eq!(a.next(), Some(&amp;1));   // The next element from `a`.
assert_eq!(a.next(), Some(&amp;100)); // The separator.
assert_eq!(a.next(), Some(&amp;2));   // The last element from `a`.
assert_eq!(a.next(), None);       // The iterator is finished.</pre></div> <p><code>intersperse</code> can be very useful to join an iterator’s items using a common element:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_intersperse)]

let hello = ["Hello", "World", "!"].iter().copied().intersperse(" ").collect::&lt;String&gt;();
assert_eq!(hello, "Hello World !");</pre></div> </div>
<summary><section id="method.intersperse_with" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#686-689">Source</a><pre class="code-header" data-language="rust">fn intersperse_with&lt;G&gt;(self, separator: G) -&gt; IntersperseWith&lt;Self, G&gt; ⓘwhere
    Self: Sized,
    G: FnMut() -&gt; Self::Item,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_intersperse</code> <a href="https://github.com/rust-lang/rust/issues/79524">#79524</a>)</span>
</div></span></summary><div class="docblock">
<p>Creates a new iterator which places an item generated by <code>separator</code> between adjacent items of the original iterator.</p> <p>The closure will be called exactly once each time an item is placed between two adjacent items from the underlying iterator; specifically, the closure is not called if the underlying iterator yields less than two items and after the last item is yielded.</p> <p>If the iterator’s item implements <a href="../clone/trait.clone.html" title="trait std::clone::Clone"><code>Clone</code></a>, it may be easier to use <a href="trait.iterator.html#method.intersperse" title="method std::iter::Iterator::intersperse"><code>intersperse</code></a>.</p> <h5 id="examples-11">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_intersperse)]

#[derive(PartialEq, Debug)]
struct NotClone(usize);

let v = [NotClone(0), NotClone(1), NotClone(2)];
let mut it = v.into_iter().intersperse_with(|| NotClone(99));

assert_eq!(it.next(), Some(NotClone(0)));  // The first element from `v`.
assert_eq!(it.next(), Some(NotClone(99))); // The separator.
assert_eq!(it.next(), Some(NotClone(1)));  // The next element from `v`.
assert_eq!(it.next(), Some(NotClone(99))); // The separator.
assert_eq!(it.next(), Some(NotClone(2)));  // The last element from `v`.
assert_eq!(it.next(), None);               // The iterator is finished.</pre></div> <p><code>intersperse_with</code> can be used in situations where the separator needs to be computed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_intersperse)]

let src = ["Hello", "to", "all", "people", "!!"].iter().copied();

// The closure mutably borrows its context to generate an item.
let mut happy_emojis = [" ❤️ ", " 😀 "].iter().copied();
let separator = || happy_emojis.next().unwrap_or(" 🦀 ");

let result = src.intersperse_with(separator).collect::&lt;String&gt;();
assert_eq!(result, "Hello ❤️ to 😀 all 🦀 people 🦀 !!");</pre></div> </div>
<summary><section id="method.map" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#745-748">Source</a></span><pre class="code-header" data-language="rust">fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; ⓘwhere
    Self: Sized,
    F: FnMut(Self::Item) -&gt; B,</pre></section></summary><div class="docblock">
<p>Takes a closure and creates an iterator which calls that closure on each element.</p> <p><code>map()</code> transforms one iterator into another, by means of its argument: something that implements <a href="../ops/trait.fnmut.html" title="trait std::ops::FnMut"><code>FnMut</code></a>. It produces a new iterator which calls this closure on each element of the original iterator.</p> <p>If you are good at thinking in types, you can think of <code>map()</code> like this: If you have an iterator that gives you elements of some type <code>A</code>, and you want an iterator of some other type <code>B</code>, you can use <code>map()</code>, passing a closure that takes an <code>A</code> and returns a <code>B</code>.</p> <p><code>map()</code> is conceptually similar to a <a href="../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><code>for</code></a> loop. However, as <code>map()</code> is lazy, it is best used when you’re already working with other iterators. If you’re doing some sort of looping for a side effect, it’s considered more idiomatic to use <a href="../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><code>for</code></a> than <code>map()</code>.</p> <h5 id="examples-12">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let mut iter = a.iter().map(|x| 2 * x);

assert_eq!(iter.next(), Some(2));
assert_eq!(iter.next(), Some(4));
assert_eq!(iter.next(), Some(6));
assert_eq!(iter.next(), None);</pre></div> <p>If you’re doing some sort of side effect, prefer <a href="../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><code>for</code></a> to <code>map()</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">// don't do this:
(0..5).map(|x| println!("{x}"));

// it won't even execute, as it is lazy. Rust will warn you about this.

// Instead, use for:
for x in 0..5 {
    println!("{x}");
}</pre></div> </div>
<summary><section id="method.for_each" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#790-793">Source</a></span><pre class="code-header" data-language="rust">fn for_each&lt;F&gt;(self, f: F)where
    Self: Sized,
    F: FnMut(Self::Item),</pre></section></summary><div class="docblock">
<p>Calls a closure on each element of an iterator.</p> <p>This is equivalent to using a <a href="../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><code>for</code></a> loop on the iterator, although <code>break</code> and <code>continue</code> are not possible from a closure. It’s generally more idiomatic to use a <code>for</code> loop, but <code>for_each</code> may be more legible when processing items at the end of longer iterator chains. In some cases <code>for_each</code> may also be faster than a loop, because it will use internal iteration on adapters like <code>Chain</code>.</p> <h5 id="examples-13">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::mpsc::channel;

let (tx, rx) = channel();
(0..5).map(|x| x * 2 + 1)
      .for_each(move |x| tx.send(x).unwrap());

let v: Vec&lt;_&gt; = rx.iter().collect();
assert_eq!(v, vec![1, 3, 5, 7, 9]);</pre></div> <p>For such a small example, a <code>for</code> loop may be cleaner, but <code>for_each</code> might be preferable to keep a functional style with longer iterators:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">(0..5).flat_map(|x| x * 100 .. x * 110)
      .enumerate()
      .filter(|&amp;(i, x)| (i + x) % 3 == 0)
      .for_each(|(i, x)| println!("{i}:{x}"));</pre></div> </div>
<summary><section id="method.filter" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#866-869">Source</a></span><pre class="code-header" data-language="rust">fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt; ⓘwhere
    Self: Sized,
    P: FnMut(&amp;Self::Item) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Creates an iterator which uses a closure to determine if an element should be yielded.</p> <p>Given an element the closure must return <code>true</code> or <code>false</code>. The returned iterator will yield only the elements for which the closure returns <code>true</code>.</p> <h5 id="examples-14">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [0i32, 1, 2];

let mut iter = a.iter().filter(|x| x.is_positive());

assert_eq!(iter.next(), Some(&amp;1));
assert_eq!(iter.next(), Some(&amp;2));
assert_eq!(iter.next(), None);</pre></div> <p>Because the closure passed to <code>filter()</code> takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [0, 1, 2];

let mut iter = a.iter().filter(|x| **x &gt; 1); // need two *s!

assert_eq!(iter.next(), Some(&amp;2));
assert_eq!(iter.next(), None);</pre></div> <p>It’s common to instead use destructuring on the argument to strip away one:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [0, 1, 2];

let mut iter = a.iter().filter(|&amp;x| *x &gt; 1); // both &amp; and *

assert_eq!(iter.next(), Some(&amp;2));
assert_eq!(iter.next(), None);</pre></div> <p>or both:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [0, 1, 2];

let mut iter = a.iter().filter(|&amp;&amp;x| x &gt; 1); // two &amp;s

assert_eq!(iter.next(), Some(&amp;2));
assert_eq!(iter.next(), None);</pre></div> <p>of these layers.</p> <p>Note that <code>iter.filter(f).next()</code> is equivalent to <code>iter.find(f)</code>.</p> </div>
<summary><section id="method.filter_map" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#911-914">Source</a></span><pre class="code-header" data-language="rust">fn filter_map&lt;B, F&gt;(self, f: F) -&gt; FilterMap&lt;Self, F&gt; ⓘwhere
    Self: Sized,
    F: FnMut(Self::Item) -&gt; Option&lt;B&gt;,</pre></section></summary><div class="docblock">
<p>Creates an iterator that both filters and maps.</p> <p>The returned iterator yields only the <code>value</code>s for which the supplied closure returns <code>Some(value)</code>.</p> <p><code>filter_map</code> can be used to make chains of <a href="trait.iterator.html#method.filter" title="method std::iter::Iterator::filter"><code>filter</code></a> and <a href="trait.iterator.html#method.map" title="method std::iter::Iterator::map"><code>map</code></a> more concise. The example below shows how a <code>map().filter().map()</code> can be shortened to a single call to <code>filter_map</code>.</p> <h5 id="examples-15">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = ["1", "two", "NaN", "four", "5"];

let mut iter = a.iter().filter_map(|s| s.parse().ok());

assert_eq!(iter.next(), Some(1));
assert_eq!(iter.next(), Some(5));
assert_eq!(iter.next(), None);</pre></div> <p>Here’s the same example, but with <a href="trait.iterator.html#method.filter" title="method std::iter::Iterator::filter"><code>filter</code></a> and <a href="trait.iterator.html#method.map" title="method std::iter::Iterator::map"><code>map</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = ["1", "two", "NaN", "four", "5"];
let mut iter = a.iter().map(|s| s.parse()).filter(|s| s.is_ok()).map(|s| s.unwrap());
assert_eq!(iter.next(), Some(1));
assert_eq!(iter.next(), Some(5));
assert_eq!(iter.next(), None);</pre></div> </div>
<summary><section id="method.enumerate" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#958-960">Source</a></span><pre class="code-header" data-language="rust">fn enumerate(self) -&gt; Enumerate&lt;Self&gt; ⓘwhere
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Creates an iterator which gives the current iteration count as well as the next value.</p> <p>The iterator returned yields pairs <code>(i, val)</code>, where <code>i</code> is the current index of iteration and <code>val</code> is the value returned by the iterator.</p> <p><code>enumerate()</code> keeps its count as a <a href="../primitive.usize.html" title="primitive usize"><code>usize</code></a>. If you want to count by a different sized integer, the <a href="trait.iterator.html#method.zip" title="method std::iter::Iterator::zip"><code>zip</code></a> function provides similar functionality.</p> <h5 id="overflow-behavior-1">Overflow Behavior</h5> <p>The method does no guarding against overflows, so enumerating more than <a href="../primitive.usize.html#associatedconstant.MAX" title="associated constant usize::MAX"><code>usize::MAX</code></a> elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</p> <h5 id="panics-2">Panics</h5> <p>The returned iterator might panic if the to-be-returned index would overflow a <a href="../primitive.usize.html" title="primitive usize"><code>usize</code></a>.</p> <h5 id="examples-16">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = ['a', 'b', 'c'];

let mut iter = a.iter().enumerate();

assert_eq!(iter.next(), Some((0, &amp;'a')));
assert_eq!(iter.next(), Some((1, &amp;'b')));
assert_eq!(iter.next(), Some((2, &amp;'c')));
assert_eq!(iter.next(), None);</pre></div> </div>
<summary><section id="method.peekable" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1029-1031">Source</a></span><pre class="code-header" data-language="rust">fn peekable(self) -&gt; Peekable&lt;Self&gt; ⓘwhere
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Creates an iterator which can use the <a href="struct.peekable.html#method.peek" title="method std::iter::Peekable::peek"><code>peek</code></a> and <a href="struct.peekable.html#method.peek_mut" title="method std::iter::Peekable::peek_mut"><code>peek_mut</code></a> methods to look at the next element of the iterator without consuming it. See their documentation for more information.</p> <p>Note that the underlying iterator is still advanced when <a href="struct.peekable.html#method.peek" title="method std::iter::Peekable::peek"><code>peek</code></a> or <a href="struct.peekable.html#method.peek_mut" title="method std::iter::Peekable::peek_mut"><code>peek_mut</code></a> are called for the first time: In order to retrieve the next element, <a href="trait.iterator.html#tymethod.next" title="method std::iter::Iterator::next"><code>next</code></a> is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the <a href="trait.iterator.html#tymethod.next" title="method std::iter::Iterator::next"><code>next</code></a> method will occur.</p> <h5 id="examples-17">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let xs = [1, 2, 3];

let mut iter = xs.iter().peekable();

// peek() lets us see into the future
assert_eq!(iter.peek(), Some(&amp;&amp;1));
assert_eq!(iter.next(), Some(&amp;1));

assert_eq!(iter.next(), Some(&amp;2));

// we can peek() multiple times, the iterator won't advance
assert_eq!(iter.peek(), Some(&amp;&amp;3));
assert_eq!(iter.peek(), Some(&amp;&amp;3));

assert_eq!(iter.next(), Some(&amp;3));

// after the iterator is finished, so is peek()
assert_eq!(iter.peek(), None);
assert_eq!(iter.next(), None);</pre></div> <p>Using <a href="struct.peekable.html#method.peek_mut" title="method std::iter::Peekable::peek_mut"><code>peek_mut</code></a> to mutate the next item without advancing the iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let xs = [1, 2, 3];

let mut iter = xs.iter().peekable();

// `peek_mut()` lets us see into the future
assert_eq!(iter.peek_mut(), Some(&amp;mut &amp;1));
assert_eq!(iter.peek_mut(), Some(&amp;mut &amp;1));
assert_eq!(iter.next(), Some(&amp;1));

if let Some(mut p) = iter.peek_mut() {
    assert_eq!(*p, &amp;2);
    // put a value into the iterator
    *p = &amp;1000;
}

// The value reappears as the iterator continues
assert_eq!(iter.collect::&lt;Vec&lt;_&gt;&gt;(), vec![&amp;1000, &amp;3]);</pre></div> </div>
<summary><section id="method.skip_while" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1094-1097">Source</a></span><pre class="code-header" data-language="rust">fn skip_while&lt;P&gt;(self, predicate: P) -&gt; SkipWhile&lt;Self, P&gt; ⓘwhere
    Self: Sized,
    P: FnMut(&amp;Self::Item) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Creates an iterator that <a href="trait.iterator.html#method.skip" title="method std::iter::Iterator::skip"><code>skip</code></a>s elements based on a predicate.</p> <p><code>skip_while()</code> takes a closure as an argument. It will call this closure on each element of the iterator, and ignore elements until it returns <code>false</code>.</p> <p>After <code>false</code> is returned, <code>skip_while()</code>’s job is over, and the rest of the elements are yielded.</p> <h5 id="examples-18">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-1i32, 0, 1];

let mut iter = a.iter().skip_while(|x| x.is_negative());

assert_eq!(iter.next(), Some(&amp;0));
assert_eq!(iter.next(), Some(&amp;1));
assert_eq!(iter.next(), None);</pre></div> <p>Because the closure passed to <code>skip_while()</code> takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure argument is a double reference:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-1, 0, 1];

let mut iter = a.iter().skip_while(|x| **x &lt; 0); // need two *s!

assert_eq!(iter.next(), Some(&amp;0));
assert_eq!(iter.next(), Some(&amp;1));
assert_eq!(iter.next(), None);</pre></div> <p>Stopping after an initial <code>false</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-1, 0, 1, -2];

let mut iter = a.iter().skip_while(|x| **x &lt; 0);

assert_eq!(iter.next(), Some(&amp;0));
assert_eq!(iter.next(), Some(&amp;1));

// while this would have been false, since we already got a false,
// skip_while() isn't used any more
assert_eq!(iter.next(), Some(&amp;-2));

assert_eq!(iter.next(), None);</pre></div> </div>
<summary><section id="method.take_while" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1175-1178">Source</a></span><pre class="code-header" data-language="rust">fn take_while&lt;P&gt;(self, predicate: P) -&gt; TakeWhile&lt;Self, P&gt; ⓘwhere
    Self: Sized,
    P: FnMut(&amp;Self::Item) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Creates an iterator that yields elements based on a predicate.</p> <p><code>take_while()</code> takes a closure as an argument. It will call this closure on each element of the iterator, and yield elements while it returns <code>true</code>.</p> <p>After <code>false</code> is returned, <code>take_while()</code>’s job is over, and the rest of the elements are ignored.</p> <h5 id="examples-19">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-1i32, 0, 1];

let mut iter = a.iter().take_while(|x| x.is_negative());

assert_eq!(iter.next(), Some(&amp;-1));
assert_eq!(iter.next(), None);</pre></div> <p>Because the closure passed to <code>take_while()</code> takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-1, 0, 1];

let mut iter = a.iter().take_while(|x| **x &lt; 0); // need two *s!

assert_eq!(iter.next(), Some(&amp;-1));
assert_eq!(iter.next(), None);</pre></div> <p>Stopping after an initial <code>false</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-1, 0, 1, -2];

let mut iter = a.iter().take_while(|x| **x &lt; 0);

assert_eq!(iter.next(), Some(&amp;-1));

// We have more elements that are less than zero, but since we already
// got a false, take_while() isn't used any more
assert_eq!(iter.next(), None);</pre></div> <p>Because <code>take_while()</code> needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3, 4];
let mut iter = a.iter();

let result: Vec&lt;i32&gt; = iter.by_ref()
                           .take_while(|n| **n != 3)
                           .cloned()
                           .collect();

assert_eq!(result, &amp;[1, 2]);

let result: Vec&lt;i32&gt; = iter.cloned().collect();

assert_eq!(result, &amp;[4]);</pre></div> <p>The <code>3</code> is no longer there, because it was consumed in order to see if the iteration should stop, but wasn’t placed back into the iterator.</p> </div>
<summary><section id="method.map_while" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.57.0">1.57.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1263-1266">Source</a></span><pre class="code-header" data-language="rust">fn map_while&lt;B, P&gt;(self, predicate: P) -&gt; MapWhile&lt;Self, P&gt; ⓘwhere
    Self: Sized,
    P: FnMut(Self::Item) -&gt; Option&lt;B&gt;,</pre></section></summary><div class="docblock">
<p>Creates an iterator that both yields elements based on a predicate and maps.</p> <p><code>map_while()</code> takes a closure as an argument. It will call this closure on each element of the iterator, and yield elements while it returns <a href="../option/enum.option.html#variant.Some" title="variant std::option::Option::Some"><code>Some(_)</code></a>.</p> <h5 id="examples-20">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-1i32, 4, 0, 1];

let mut iter = a.iter().map_while(|x| 16i32.checked_div(*x));

assert_eq!(iter.next(), Some(-16));
assert_eq!(iter.next(), Some(4));
assert_eq!(iter.next(), None);</pre></div> <p>Here’s the same example, but with <a href="trait.iterator.html#method.take_while" title="method std::iter::Iterator::take_while"><code>take_while</code></a> and <a href="trait.iterator.html#method.map" title="method std::iter::Iterator::map"><code>map</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-1i32, 4, 0, 1];

let mut iter = a.iter()
                .map(|x| 16i32.checked_div(*x))
                .take_while(|x| x.is_some())
                .map(|x| x.unwrap());

assert_eq!(iter.next(), Some(-16));
assert_eq!(iter.next(), Some(4));
assert_eq!(iter.next(), None);</pre></div> <p>Stopping after an initial <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [0, 1, 2, -3, 4, 5, -6];

let iter = a.iter().map_while(|x| u32::try_from(*x).ok());
let vec = iter.collect::&lt;Vec&lt;_&gt;&gt;();

// We have more elements which could fit in u32 (4, 5), but `map_while` returned `None` for `-3`
// (as the `predicate` returned `None`) and `collect` stops at the first `None` encountered.
assert_eq!(vec, vec![0, 1, 2]);</pre></div> <p>Because <code>map_while()</code> needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, -3, 4];
let mut iter = a.iter();

let result: Vec&lt;u32&gt; = iter.by_ref()
                           .map_while(|n| u32::try_from(*n).ok())
                           .collect();

assert_eq!(result, &amp;[1, 2]);

let result: Vec&lt;i32&gt; = iter.cloned().collect();

assert_eq!(result, &amp;[4]);</pre></div> <p>The <code>-3</code> is no longer there, because it was consumed in order to see if the iteration should stop, but wasn’t placed back into the iterator.</p> <p>Note that unlike <a href="trait.iterator.html#method.take_while" title="method std::iter::Iterator::take_while"><code>take_while</code></a> this iterator is <strong>not</strong> fused. It is also not specified what this iterator returns after the first <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is returned. If you need fused iterator, use <a href="trait.iterator.html#method.fuse" title="method std::iter::Iterator::fuse"><code>fuse</code></a>.</p> </div>
<summary><section id="method.skip" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1292-1294">Source</a></span><pre class="code-header" data-language="rust">fn skip(self, n: usize) -&gt; Skip&lt;Self&gt; ⓘwhere
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Creates an iterator that skips the first <code>n</code> elements.</p> <p><code>skip(n)</code> skips elements until <code>n</code> elements are skipped or the end of the iterator is reached (whichever happens first). After that, all the remaining elements are yielded. In particular, if the original iterator is too short, then the returned iterator is empty.</p> <p>Rather than overriding this method directly, instead override the <code>nth</code> method.</p> <h5 id="examples-21">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let mut iter = a.iter().skip(2);

assert_eq!(iter.next(), Some(&amp;3));
assert_eq!(iter.next(), None);</pre></div> </div>
<summary><section id="method.take" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1345-1347">Source</a></span><pre class="code-header" data-language="rust">fn take(self, n: usize) -&gt; Take&lt;Self&gt; ⓘwhere
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Creates an iterator that yields the first <code>n</code> elements, or fewer if the underlying iterator ends sooner.</p> <p><code>take(n)</code> yields elements until <code>n</code> elements are yielded or the end of the iterator is reached (whichever happens first). The returned iterator is a prefix of length <code>n</code> if the original iterator contains at least <code>n</code> elements, otherwise it contains all of the (fewer than <code>n</code>) elements of the original iterator.</p> <h5 id="examples-22">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let mut iter = a.iter().take(2);

assert_eq!(iter.next(), Some(&amp;1));
assert_eq!(iter.next(), Some(&amp;2));
assert_eq!(iter.next(), None);</pre></div> <p><code>take()</code> is often used with an infinite iterator, to make it finite:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = (0..).take(3);

assert_eq!(iter.next(), Some(0));
assert_eq!(iter.next(), Some(1));
assert_eq!(iter.next(), Some(2));
assert_eq!(iter.next(), None);</pre></div> <p>If less than <code>n</code> elements are available, <code>take</code> will limit itself to the size of the underlying iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v = [1, 2];
let mut iter = v.into_iter().take(5);
assert_eq!(iter.next(), Some(1));
assert_eq!(iter.next(), Some(2));
assert_eq!(iter.next(), None);</pre></div> </div>
<summary><section id="method.scan" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1392-1395">Source</a></span><pre class="code-header" data-language="rust">fn scan&lt;St, B, F&gt;(self, initial_state: St, f: F) -&gt; Scan&lt;Self, St, F&gt; ⓘwhere
    Self: Sized,
    F: FnMut(&amp;mut St, Self::Item) -&gt; Option&lt;B&gt;,</pre></section></summary><div class="docblock">
<p>An iterator adapter which, like <a href="trait.iterator.html#method.fold" title="method std::iter::Iterator::fold"><code>fold</code></a>, holds internal state, but unlike <a href="trait.iterator.html#method.fold" title="method std::iter::Iterator::fold"><code>fold</code></a>, produces a new iterator.</p> <p><code>scan()</code> takes two arguments: an initial value which seeds the internal state, and a closure with two arguments, the first being a mutable reference to the internal state and the second an iterator element. The closure can assign to the internal state to share state between iterations.</p> <p>On iteration, the closure will be applied to each element of the iterator and the return value from the closure, an <a href="../option/enum.option.html" title="enum std::option::Option"><code>Option</code></a>, is returned by the <code>next</code> method. Thus the closure can return <code>Some(value)</code> to yield <code>value</code>, or <code>None</code> to end the iteration.</p> <h5 id="examples-23">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3, 4];

let mut iter = a.iter().scan(1, |state, &amp;x| {
    // each iteration, we'll multiply the state by the element ...
    *state = *state * x;

    // ... and terminate if the state exceeds 6
    if *state &gt; 6 {
        return None;
    }
    // ... else yield the negation of the state
    Some(-*state)
});

assert_eq!(iter.next(), Some(-1));
assert_eq!(iter.next(), Some(-2));
assert_eq!(iter.next(), Some(-6));
assert_eq!(iter.next(), None);</pre></div> </div>
<summary><section id="method.flat_map" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1430-1434">Source</a></span><pre class="code-header" data-language="rust">fn flat_map&lt;U, F&gt;(self, f: F) -&gt; FlatMap&lt;Self, U, F&gt; ⓘwhere
    Self: Sized,
    U: IntoIterator,
    F: FnMut(Self::Item) -&gt; U,</pre></section></summary><div class="docblock">
<p>Creates an iterator that works like map, but flattens nested structure.</p> <p>The <a href="trait.iterator.html#method.map" title="method std::iter::Iterator::map"><code>map</code></a> adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there’s an extra layer of indirection. <code>flat_map()</code> will remove this extra layer on its own.</p> <p>You can think of <code>flat_map(f)</code> as the semantic equivalent of <a href="trait.iterator.html#method.map" title="method std::iter::Iterator::map"><code>map</code></a>ping, and then <a href="trait.iterator.html#method.flatten" title="method std::iter::Iterator::flatten"><code>flatten</code></a>ing as in <code>map(f).flatten()</code>.</p> <p>Another way of thinking about <code>flat_map()</code>: <a href="trait.iterator.html#method.map" title="method std::iter::Iterator::map"><code>map</code></a>’s closure returns one item for each element, and <code>flat_map()</code>’s closure returns an iterator for each element.</p> <h5 id="examples-24">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let words = ["alpha", "beta", "gamma"];

// chars() returns an iterator
let merged: String = words.iter()
                          .flat_map(|s| s.chars())
                          .collect();
assert_eq!(merged, "alphabetagamma");</pre></div> </div>
<summary><section id="method.flatten" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1514-1517">Source</a></span><pre class="code-header" data-language="rust">fn flatten(self) -&gt; Flatten&lt;Self&gt; ⓘwhere
    Self: Sized,
    Self::Item: IntoIterator,</pre></section></summary><div class="docblock">
<p>Creates an iterator that flattens nested structure.</p> <p>This is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of indirection.</p> <h5 id="examples-25">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let data = vec![vec![1, 2, 3, 4], vec![5, 6]];
let flattened = data.into_iter().flatten().collect::&lt;Vec&lt;u8&gt;&gt;();
assert_eq!(flattened, &amp;[1, 2, 3, 4, 5, 6]);</pre></div> <p>Mapping and then flattening:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let words = ["alpha", "beta", "gamma"];

// chars() returns an iterator
let merged: String = words.iter()
                          .map(|s| s.chars())
                          .flatten()
                          .collect();
assert_eq!(merged, "alphabetagamma");</pre></div> <p>You can also rewrite this in terms of <a href="trait.iterator.html#method.flat_map" title="method std::iter::Iterator::flat_map"><code>flat_map()</code></a>, which is preferable in this case since it conveys intent more clearly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let words = ["alpha", "beta", "gamma"];

// chars() returns an iterator
let merged: String = words.iter()
                          .flat_map(|s| s.chars())
                          .collect();
assert_eq!(merged, "alphabetagamma");</pre></div> <p>Flattening works on any <code>IntoIterator</code> type, including <code>Option</code> and <code>Result</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let options = vec![Some(123), Some(321), None, Some(231)];
let flattened_options: Vec&lt;_&gt; = options.into_iter().flatten().collect();
assert_eq!(flattened_options, vec![123, 321, 231]);

let results = vec![Ok(123), Ok(321), Err(456), Ok(231)];
let flattened_results: Vec&lt;_&gt; = results.into_iter().flatten().collect();
assert_eq!(flattened_results, vec![123, 321, 231]);</pre></div> <p>Flattening only removes one level of nesting at a time:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]];

let d2 = d3.iter().flatten().collect::&lt;Vec&lt;_&gt;&gt;();
assert_eq!(d2, [&amp;[1, 2], &amp;[3, 4], &amp;[5, 6], &amp;[7, 8]]);

let d1 = d3.iter().flatten().flatten().collect::&lt;Vec&lt;_&gt;&gt;();
assert_eq!(d1, [&amp;1, &amp;2, &amp;3, &amp;4, &amp;5, &amp;6, &amp;7, &amp;8]);</pre></div> <p>Here we see that <code>flatten()</code> does not perform a “deep” flatten. Instead, only one level of nesting is removed. That is, if you <code>flatten()</code> a three-dimensional array, the result will be two-dimensional and not one-dimensional. To get a one-dimensional structure, you have to <code>flatten()</code> again.</p> </div>
<summary><section id="method.map_windows" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1670-1673">Source</a><pre class="code-header" data-language="rust">fn map_windows&lt;F, R, const N: usize&gt;(self, f: F) -&gt; MapWindows&lt;Self, F, N&gt; ⓘwhere
    Self: Sized,
    F: FnMut(&amp;[Self::Item; N]) -&gt; R,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_map_windows</code> <a href="https://github.com/rust-lang/rust/issues/87155">#87155</a>)</span>
</div></span></summary><div class="docblock">
<p>Calls the given function <code>f</code> for each contiguous window of size <code>N</code> over <code>self</code> and returns an iterator over the outputs of <code>f</code>. Like <a href="../primitive.slice.html#method.windows" title="method slice::windows"><code>slice::windows()</code></a>, the windows during mapping overlap as well.</p> <p>In the following example, the closure is called three times with the arguments <code>&amp;['a', 'b']</code>, <code>&amp;['b', 'c']</code> and <code>&amp;['c', 'd']</code> respectively.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_map_windows)]

let strings = "abcd".chars()
    .map_windows(|[x, y]| format!("{}+{}", x, y))
    .collect::&lt;Vec&lt;String&gt;&gt;();

assert_eq!(strings, vec!["a+b", "b+c", "c+d"]);</pre></div> <p>Note that the const parameter <code>N</code> is usually inferred by the destructured argument in the closure.</p> <p>The returned iterator yields 𝑘 − <code>N</code> + 1 items (where 𝑘 is the number of items yielded by <code>self</code>). If 𝑘 is less than <code>N</code>, this method yields an empty iterator.</p> <p>The returned iterator implements <a href="trait.fusediterator.html" title="trait std::iter::FusedIterator"><code>FusedIterator</code></a>, because once <code>self</code> returns <code>None</code>, even if it returns a <code>Some(T)</code> again in the next iterations, we cannot put it into a contiguous array buffer, and thus the returned iterator should be fused.</p> <h5 id="panics-3">Panics</h5> <p>Panics if <code>N</code> is zero. This check will most probably get changed to a compile time error before this method gets stabilized.</p> <div class="example-wrap should_panic">ⓘ<pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_map_windows)]

let iter = std::iter::repeat(0).map_windows(|&amp;[]| ());</pre>
</div> <h5 id="examples-26">Examples</h5> <p>Building the sums of neighboring numbers.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_map_windows)]

let mut it = [1, 3, 8, 1].iter().map_windows(|&amp;[a, b]| a + b);
assert_eq!(it.next(), Some(4));  // 1 + 3
assert_eq!(it.next(), Some(11)); // 3 + 8
assert_eq!(it.next(), Some(9));  // 8 + 1
assert_eq!(it.next(), None);</pre></div> <p>Since the elements in the following example implement <code>Copy</code>, we can just copy the array and get an iterator over the windows.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_map_windows)]

let mut it = "ferris".chars().map_windows(|w: &amp;[_; 3]| *w);
assert_eq!(it.next(), Some(['f', 'e', 'r']));
assert_eq!(it.next(), Some(['e', 'r', 'r']));
assert_eq!(it.next(), Some(['r', 'r', 'i']));
assert_eq!(it.next(), Some(['r', 'i', 's']));
assert_eq!(it.next(), None);</pre></div> <p>You can also use this function to check the sortedness of an iterator. For the simple case, rather use <a href="trait.iterator.html#method.is_sorted" title="method std::iter::Iterator::is_sorted"><code>Iterator::is_sorted</code></a>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_map_windows)]

let mut it = [0.5, 1.0, 3.5, 3.0, 8.5, 8.5, f32::NAN].iter()
    .map_windows(|[a, b]| a &lt;= b);

assert_eq!(it.next(), Some(true));  // 0.5 &lt;= 1.0
assert_eq!(it.next(), Some(true));  // 1.0 &lt;= 3.5
assert_eq!(it.next(), Some(false)); // 3.5 &lt;= 3.0
assert_eq!(it.next(), Some(true));  // 3.0 &lt;= 8.5
assert_eq!(it.next(), Some(true));  // 8.5 &lt;= 8.5
assert_eq!(it.next(), Some(false)); // 8.5 &lt;= NAN
assert_eq!(it.next(), None);</pre></div> <p>For non-fused iterators, they are fused after <code>map_windows</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_map_windows)]

#[derive(Default)]
struct NonFusedIterator {
    state: i32,
}

impl Iterator for NonFusedIterator {
    type Item = i32;

    fn next(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let val = self.state;
        self.state = self.state + 1;

        // yields `0..5` first, then only even numbers since `6..`.
        if val &lt; 5 || val % 2 == 0 {
            Some(val)
        } else {
            None
        }
    }
}


let mut iter = NonFusedIterator::default();

// yields 0..5 first.
assert_eq!(iter.next(), Some(0));
assert_eq!(iter.next(), Some(1));
assert_eq!(iter.next(), Some(2));
assert_eq!(iter.next(), Some(3));
assert_eq!(iter.next(), Some(4));
// then we can see our iterator going back and forth
assert_eq!(iter.next(), None);
assert_eq!(iter.next(), Some(6));
assert_eq!(iter.next(), None);
assert_eq!(iter.next(), Some(8));
assert_eq!(iter.next(), None);

// however, with `.map_windows()`, it is fused.
let mut iter = NonFusedIterator::default()
    .map_windows(|arr: &amp;[_; 2]| *arr);

assert_eq!(iter.next(), Some([0, 1]));
assert_eq!(iter.next(), Some([1, 2]));
assert_eq!(iter.next(), Some([2, 3]));
assert_eq!(iter.next(), Some([3, 4]));
assert_eq!(iter.next(), None);

// it will always return `None` after the first time.
assert_eq!(iter.next(), None);
assert_eq!(iter.next(), None);
assert_eq!(iter.next(), None);</pre></div> </div>
<summary><section id="method.fuse" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1736-1738">Source</a></span><pre class="code-header" data-language="rust">fn fuse(self) -&gt; Fuse&lt;Self&gt; ⓘwhere
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Creates an iterator which ends after the first <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>.</p> <p>After an iterator returns <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>, future calls may or may not yield <a href="../option/enum.option.html#variant.Some" title="variant std::option::Option::Some"><code>Some(T)</code></a> again. <code>fuse()</code> adapts an iterator, ensuring that after a <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is given, it will always return <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> forever.</p> <p>Note that the <a href="struct.fuse.html" title="struct std::iter::Fuse"><code>Fuse</code></a> wrapper is a no-op on iterators that implement the <a href="trait.fusediterator.html" title="trait std::iter::FusedIterator"><code>FusedIterator</code></a> trait. <code>fuse()</code> may therefore behave incorrectly if the <a href="trait.fusediterator.html" title="trait std::iter::FusedIterator"><code>FusedIterator</code></a> trait is improperly implemented.</p> <h5 id="examples-27">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">// an iterator which alternates between Some and None
struct Alternate {
    state: i32,
}

impl Iterator for Alternate {
    type Item = i32;

    fn next(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let val = self.state;
        self.state = self.state + 1;

        // if it's even, Some(i32), else None
        if val % 2 == 0 {
            Some(val)
        } else {
            None
        }
    }
}

let mut iter = Alternate { state: 0 };

// we can see our iterator going back and forth
assert_eq!(iter.next(), Some(0));
assert_eq!(iter.next(), None);
assert_eq!(iter.next(), Some(2));
assert_eq!(iter.next(), None);

// however, once we fuse it...
let mut iter = iter.fuse();

assert_eq!(iter.next(), Some(4));
assert_eq!(iter.next(), None);

// it will always return `None` after the first time.
assert_eq!(iter.next(), None);
assert_eq!(iter.next(), None);
assert_eq!(iter.next(), None);</pre></div> </div>
<summary><section id="method.inspect" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1820-1823">Source</a></span><pre class="code-header" data-language="rust">fn inspect&lt;F&gt;(self, f: F) -&gt; Inspect&lt;Self, F&gt; ⓘwhere
    Self: Sized,
    F: FnMut(&amp;Self::Item),</pre></section></summary><div class="docblock">
<p>Does something with each element of an iterator, passing the value on.</p> <p>When using iterators, you’ll often chain several of them together. While working on such code, you might want to check out what’s happening at various parts in the pipeline. To do that, insert a call to <code>inspect()</code>.</p> <p>It’s more common for <code>inspect()</code> to be used as a debugging tool than to exist in your final code, but applications may find it useful in certain situations when errors need to be logged before being discarded.</p> <h5 id="examples-28">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 4, 2, 3];

// this iterator sequence is complex.
let sum = a.iter()
    .cloned()
    .filter(|x| x % 2 == 0)
    .fold(0, |sum, i| sum + i);

println!("{sum}");

// let's add some inspect() calls to investigate what's happening
let sum = a.iter()
    .cloned()
    .inspect(|x| println!("about to filter: {x}"))
    .filter(|x| x % 2 == 0)
    .inspect(|x| println!("made it through filter: {x}"))
    .fold(0, |sum, i| sum + i);

println!("{sum}");</pre></div> <p>This will print:</p> <div class="example-wrap"><pre class="language-text">6
about to filter: 1
about to filter: 4
made it through filter: 4
about to filter: 2
made it through filter: 2
about to filter: 3
6</pre></div> <p>Logging errors before discarding them:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let lines = ["1", "2", "a"];

let sum: i32 = lines
    .iter()
    .map(|line| line.parse::&lt;i32&gt;())
    .inspect(|num| {
        if let Err(ref e) = *num {
            println!("Parsing error: {e}");
        }
    })
    .filter_map(Result::ok)
    .sum();

println!("Sum: {sum}");</pre></div> <p>This will print:</p> <div class="example-wrap"><pre class="language-text">Parsing error: invalid digit found in string
Sum: 3</pre></div>
</div>
<summary><section id="method.by_ref" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1848-1850">Source</a></span><pre class="code-header" data-language="rust">fn by_ref(&amp;mut self) -&gt; &amp;mut Selfwhere
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Borrows an iterator, rather than consuming it.</p> <p>This is useful to allow applying iterator adapters while still retaining ownership of the original iterator.</p> <h5 id="examples-29">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut words = ["hello", "world", "of", "Rust"].into_iter();

// Take the first two words.
let hello_world: Vec&lt;_&gt; = words.by_ref().take(2).collect();
assert_eq!(hello_world, vec!["hello", "world"]);

// Collect the rest of the words.
// We can only do this because we used `by_ref` earlier.
let of_rust: Vec&lt;_&gt; = words.collect();
assert_eq!(of_rust, vec!["of", "Rust"]);</pre></div> </div>
<summary><section id="method.collect" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1967-1969">Source</a></span><pre class="code-header" data-language="rust">fn collect&lt;B&gt;(self) -&gt; Bwhere
    B: FromIterator&lt;Self::Item&gt;,
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Transforms an iterator into a collection.</p> <p><code>collect()</code> can take anything iterable, and turn it into a relevant collection. This is one of the more powerful methods in the standard library, used in a variety of contexts.</p> <p>The most basic pattern in which <code>collect()</code> is used is to turn one collection into another. You take a collection, call <a href="trait.iterator.html#tymethod.next" title="method std::iter::Iterator::next"><code>iter</code></a> on it, do a bunch of transformations, and then <code>collect()</code> at the end.</p> <p><code>collect()</code> can also create instances of types that are not typical collections. For example, a <a href="../string/struct.string.html"><code>String</code></a> can be built from <a href="../primitive.char.html" title="primitive char"><code>char</code></a>s, and an iterator of <a href="../result/enum.result.html" title="enum std::result::Result"><code>Result&lt;T, E&gt;</code></a> items can be collected into <code>Result&lt;Collection&lt;T&gt;, E&gt;</code>. See the examples below for more.</p> <p>Because <code>collect()</code> is so general, it can cause problems with type inference. As such, <code>collect()</code> is one of the few times you’ll see the syntax affectionately known as the ‘turbofish’: <code>::&lt;&gt;</code>. This helps the inference algorithm understand specifically which collection you’re trying to collect into.</p> <h5 id="examples-30">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let doubled: Vec&lt;i32&gt; = a.iter()
                         .map(|&amp;x| x * 2)
                         .collect();

assert_eq!(vec![2, 4, 6], doubled);</pre></div> <p>Note that we needed the <code>: Vec&lt;i32&gt;</code> on the left-hand side. This is because we could collect into, for example, a <a href="../collections/struct.vecdeque.html"><code>VecDeque&lt;T&gt;</code></a> instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::collections::VecDeque;

let a = [1, 2, 3];

let doubled: VecDeque&lt;i32&gt; = a.iter().map(|&amp;x| x * 2).collect();

assert_eq!(2, doubled[0]);
assert_eq!(4, doubled[1]);
assert_eq!(6, doubled[2]);</pre></div> <p>Using the ‘turbofish’ instead of annotating <code>doubled</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let doubled = a.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;();

assert_eq!(vec![2, 4, 6], doubled);</pre></div> <p>Because <code>collect()</code> only cares about what you’re collecting into, you can still use a partial type hint, <code>_</code>, with the turbofish:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let doubled = a.iter().map(|x| x * 2).collect::&lt;Vec&lt;_&gt;&gt;();

assert_eq!(vec![2, 4, 6], doubled);</pre></div> <p>Using <code>collect()</code> to make a <a href="../string/struct.string.html"><code>String</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let chars = ['g', 'd', 'k', 'k', 'n'];

let hello: String = chars.iter()
    .map(|&amp;x| x as u8)
    .map(|x| (x + 1) as char)
    .collect();

assert_eq!("hello", hello);</pre></div> <p>If you have a list of <a href="../result/enum.result.html" title="enum std::result::Result"><code>Result&lt;T, E&gt;</code></a>s, you can use <code>collect()</code> to see if any of them failed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let results = [Ok(1), Err("nope"), Ok(3), Err("bad")];

let result: Result&lt;Vec&lt;_&gt;, &amp;str&gt; = results.iter().cloned().collect();

// gives us the first error
assert_eq!(Err("nope"), result);

let results = [Ok(1), Ok(3)];

let result: Result&lt;Vec&lt;_&gt;, &amp;str&gt; = results.iter().cloned().collect();

// gives us the list of answers
assert_eq!(Ok(vec![1, 3]), result);</pre></div> </div>
<summary><section id="method.try_collect" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2045-2049">Source</a><pre class="code-header" data-language="rust">fn try_collect&lt;B&gt;(
    &amp;mut self,
) -&gt; &lt;&lt;Self::Item as Try&gt;::Residual as Residual&lt;B&gt;&gt;::TryTypewhere
    Self: Sized,
    Self::Item: Try,
    &lt;Self::Item as Try&gt;::Residual: Residual&lt;B&gt;,
    B: FromIterator&lt;&lt;Self::Item as Try&gt;::Output&gt;,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iterator_try_collect</code> <a href="https://github.com/rust-lang/rust/issues/94047">#94047</a>)</span>
</div></span></summary><div class="docblock">
<p>Fallibly transforms an iterator into a collection, short circuiting if a failure is encountered.</p> <p><code>try_collect()</code> is a variation of <a href="trait.iterator.html#method.collect" title="method std::iter::Iterator::collect"><code>collect()</code></a> that allows fallible conversions during collection. Its main use case is simplifying conversions from iterators yielding <a href="../option/enum.option.html" title="enum std::option::Option"><code>Option&lt;T&gt;</code></a> into <code>Option&lt;Collection&lt;T&gt;&gt;</code>, or similarly for other <a href="../ops/trait.try.html" title="trait std::ops::Try"><code>Try</code></a> types (e.g. <a href="../result/enum.result.html" title="enum std::result::Result"><code>Result</code></a>).</p> <p>Importantly, <code>try_collect()</code> doesn’t require that the outer <a href="../ops/trait.try.html" title="trait std::ops::Try"><code>Try</code></a> type also implements <a href="trait.fromiterator.html" title="trait std::iter::FromIterator"><code>FromIterator</code></a>; only the inner type produced on <code>Try::Output</code> must implement it. Concretely, this means that collecting into <code>ControlFlow&lt;_, Vec&lt;i32&gt;&gt;</code> is valid because <code>Vec&lt;i32&gt;</code> implements <a href="trait.fromiterator.html" title="trait std::iter::FromIterator"><code>FromIterator</code></a>, even though <a href="../ops/enum.controlflow.html" title="enum std::ops::ControlFlow"><code>ControlFlow</code></a> doesn’t.</p> <p>Also, if a failure is encountered during <code>try_collect()</code>, the iterator is still valid and may continue to be used, in which case it will continue iterating starting after the element that triggered the failure. See the last example below for an example of how this works.</p> <h5 id="examples-31">Examples</h5> <p>Successfully collecting an iterator of <code>Option&lt;i32&gt;</code> into <code>Option&lt;Vec&lt;i32&gt;&gt;</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iterator_try_collect)]

let u = vec![Some(1), Some(2), Some(3)];
let v = u.into_iter().try_collect::&lt;Vec&lt;i32&gt;&gt;();
assert_eq!(v, Some(vec![1, 2, 3]));</pre></div> <p>Failing to collect in the same way:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iterator_try_collect)]

let u = vec![Some(1), Some(2), None, Some(3)];
let v = u.into_iter().try_collect::&lt;Vec&lt;i32&gt;&gt;();
assert_eq!(v, None);</pre></div> <p>A similar example, but with <code>Result</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iterator_try_collect)]

let u: Vec&lt;Result&lt;i32, ()&gt;&gt; = vec![Ok(1), Ok(2), Ok(3)];
let v = u.into_iter().try_collect::&lt;Vec&lt;i32&gt;&gt;();
assert_eq!(v, Ok(vec![1, 2, 3]));

let u = vec![Ok(1), Ok(2), Err(()), Ok(3)];
let v = u.into_iter().try_collect::&lt;Vec&lt;i32&gt;&gt;();
assert_eq!(v, Err(()));</pre></div> <p>Finally, even <a href="../ops/enum.controlflow.html" title="enum std::ops::ControlFlow"><code>ControlFlow</code></a> works, despite the fact that it doesn’t implement <a href="trait.fromiterator.html" title="trait std::iter::FromIterator"><code>FromIterator</code></a>. Note also that the iterator can continue to be used, even if a failure is encountered:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iterator_try_collect)]

use core::ops::ControlFlow::{Break, Continue};

let u = [Continue(1), Continue(2), Break(3), Continue(4), Continue(5)];
let mut it = u.into_iter();

let v = it.try_collect::&lt;Vec&lt;_&gt;&gt;();
assert_eq!(v, Break(3));

let v = it.try_collect::&lt;Vec&lt;_&gt;&gt;();
assert_eq!(v, Continue(vec![4, 5]));</pre></div> </div>
<summary><section id="method.collect_into" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2117-2119">Source</a><pre class="code-header" data-language="rust">fn collect_into&lt;E&gt;(self, collection: &amp;mut E) -&gt; &amp;mut Ewhere
    E: Extend&lt;Self::Item&gt;,
    Self: Sized,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_collect_into</code> <a href="https://github.com/rust-lang/rust/issues/94780">#94780</a>)</span>
</div></span></summary><div class="docblock">
<p>Collects all the items from an iterator into a collection.</p> <p>This method consumes the iterator and adds all its items to the passed collection. The collection is then returned, so the call chain can be continued.</p> <p>This is useful when you already have a collection and want to add the iterator items to it.</p> <p>This method is a convenience method to call <a href="trait.extend.html">Extend::extend</a>, but instead of being called on a collection, it’s called on an iterator.</p> <h5 id="examples-32">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_collect_into)]

let a = [1, 2, 3];
let mut vec: Vec::&lt;i32&gt; = vec![0, 1];

a.iter().map(|&amp;x| x * 2).collect_into(&amp;mut vec);
a.iter().map(|&amp;x| x * 10).collect_into(&amp;mut vec);

assert_eq!(vec, vec![0, 1, 2, 4, 6, 10, 20, 30]);</pre></div> <p><code>Vec</code> can have a manual set capacity to avoid reallocating it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_collect_into)]

let a = [1, 2, 3];
let mut vec: Vec::&lt;i32&gt; = Vec::with_capacity(6);

a.iter().map(|&amp;x| x * 2).collect_into(&amp;mut vec);
a.iter().map(|&amp;x| x * 10).collect_into(&amp;mut vec);

assert_eq!(6, vec.capacity());
assert_eq!(vec, vec![2, 4, 6, 10, 20, 30]);</pre></div> <p>The returned mutable reference can be used to continue the call chain:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_collect_into)]

let a = [1, 2, 3];
let mut vec: Vec::&lt;i32&gt; = Vec::with_capacity(6);

let count = a.iter().collect_into(&amp;mut vec).iter().count();

assert_eq!(count, vec.len());
assert_eq!(vec, vec![1, 2, 3]);

let count = a.iter().collect_into(&amp;mut vec).iter().count();

assert_eq!(count, vec.len());
assert_eq!(vec, vec![1, 2, 3, 1, 2, 3]);</pre></div> </div>
<summary><section id="method.partition" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2149-2153">Source</a></span><pre class="code-header" data-language="rust">fn partition&lt;B, F&gt;(self, f: F) -&gt; (B, B)where
    Self: Sized,
    B: Default + Extend&lt;Self::Item&gt;,
    F: FnMut(&amp;Self::Item) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Consumes an iterator, creating two collections from it.</p> <p>The predicate passed to <code>partition()</code> can return <code>true</code>, or <code>false</code>. <code>partition()</code> returns a pair, all of the elements for which it returned <code>true</code>, and all of the elements for which it returned <code>false</code>.</p> <p>See also <a href="trait.iterator.html#method.is_partitioned" title="method std::iter::Iterator::is_partitioned"><code>is_partitioned()</code></a> and <a href="trait.iterator.html#method.partition_in_place" title="method std::iter::Iterator::partition_in_place"><code>partition_in_place()</code></a>.</p> <h5 id="examples-33">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let (even, odd): (Vec&lt;_&gt;, Vec&lt;_&gt;) = a
    .into_iter()
    .partition(|n| n % 2 == 0);

assert_eq!(even, vec![2]);
assert_eq!(odd, vec![1, 3]);</pre></div> </div>
<summary><section id="method.partition_in_place" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2211-2214">Source</a><pre class="code-header" data-language="rust">fn partition_in_place&lt;'a, T, P&gt;(self, predicate: P) -&gt; usizewhere
    T: 'a,
    Self: Sized + DoubleEndedIterator&lt;Item = &amp;'a mut T&gt;,
    P: FnMut(&amp;T) -&gt; bool,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_partition_in_place</code> <a href="https://github.com/rust-lang/rust/issues/62543">#62543</a>)</span>
</div></span></summary><div class="docblock">
<p>Reorders the elements of this iterator <em>in-place</em> according to the given predicate, such that all those that return <code>true</code> precede all those that return <code>false</code>. Returns the number of <code>true</code> elements found.</p> <p>The relative order of partitioned items is not maintained.</p> <h5 id="current-implementation">Current implementation</h5> <p>The current algorithm tries to find the first element for which the predicate evaluates to false and the last element for which it evaluates to true, and repeatedly swaps them.</p> <p>Time complexity: <em>O</em>(<em>n</em>)</p> <p>See also <a href="trait.iterator.html#method.is_partitioned" title="method std::iter::Iterator::is_partitioned"><code>is_partitioned()</code></a> and <a href="trait.iterator.html#method.partition" title="method std::iter::Iterator::partition"><code>partition()</code></a>.</p> <h5 id="examples-34">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_partition_in_place)]

let mut a = [1, 2, 3, 4, 5, 6, 7];

// Partition in-place between evens and odds
let i = a.iter_mut().partition_in_place(|&amp;n| n % 2 == 0);

assert_eq!(i, 3);
assert!(a[..i].iter().all(|&amp;n| n % 2 == 0)); // evens
assert!(a[i..].iter().all(|&amp;n| n % 2 == 1)); // odds</pre></div> </div>
<summary><section id="method.is_partitioned" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2268-2271">Source</a><pre class="code-header" data-language="rust">fn is_partitioned&lt;P&gt;(self, predicate: P) -&gt; boolwhere
    Self: Sized,
    P: FnMut(Self::Item) -&gt; bool,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_is_partitioned</code> <a href="https://github.com/rust-lang/rust/issues/62544">#62544</a>)</span>
</div></span></summary><div class="docblock">
<p>Checks if the elements of this iterator are partitioned according to the given predicate, such that all those that return <code>true</code> precede all those that return <code>false</code>.</p> <p>See also <a href="trait.iterator.html#method.partition" title="method std::iter::Iterator::partition"><code>partition()</code></a> and <a href="trait.iterator.html#method.partition_in_place" title="method std::iter::Iterator::partition_in_place"><code>partition_in_place()</code></a>.</p> <h5 id="examples-35">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_is_partitioned)]

assert!("Iterator".chars().is_partitioned(char::is_uppercase));
assert!(!"IntoIterator".chars().is_partitioned(char::is_uppercase));</pre></div> </div>
<summary><section id="method.try_fold" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2362-2366">Source</a></span><pre class="code-header" data-language="rust">fn try_fold&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; Rwhere
    Self: Sized,
    F: FnMut(B, Self::Item) -&gt; R,
    R: Try&lt;Output = B&gt;,</pre></section></summary><div class="docblock">
<p>An iterator method that applies a function as long as it returns successfully, producing a single, final value.</p> <p><code>try_fold()</code> takes two arguments: an initial value, and a closure with two arguments: an ‘accumulator’, and an element. The closure either returns successfully, with the value that the accumulator should have for the next iteration, or it returns failure, with an error value that is propagated back to the caller immediately (short-circuiting).</p> <p>The initial value is the value the accumulator will have on the first call. If applying the closure succeeded against every element of the iterator, <code>try_fold()</code> returns the final accumulator as success.</p> <p>Folding is useful whenever you have a collection of something, and want to produce a single value from it.</p> <h5 id="note-to-implementors">Note to Implementors</h5> <p>Several of the other (forward) methods have default implementations in terms of this one, so try to implement this explicitly if it can do something better than the default <code>for</code> loop implementation.</p> <p>In particular, try to have this call <code>try_fold()</code> on the internal parts from which this iterator is composed. If multiple calls are needed, the <code>?</code> operator may be convenient for chaining the accumulator value along, but beware any invariants that need to be upheld before those early returns. This is a <code>&amp;mut self</code> method, so iteration needs to be resumable after hitting an error here.</p> <h5 id="examples-36">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

// the checked sum of all of the elements of the array
let sum = a.iter().try_fold(0i8, |acc, &amp;x| acc.checked_add(x));

assert_eq!(sum, Some(6));</pre></div> <p>Short-circuiting:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [10, 20, 30, 100, 40, 50];
let mut it = a.iter();

// This sum overflows when adding the 100 element
let sum = it.try_fold(0i8, |acc, &amp;x| acc.checked_add(x));
assert_eq!(sum, None);

// Because it short-circuited, the remaining elements are still
// available through the iterator.
assert_eq!(it.len(), 2);
assert_eq!(it.next(), Some(&amp;40));</pre></div> <p>While you cannot <code>break</code> from a closure, the <a href="../ops/enum.controlflow.html" title="enum std::ops::ControlFlow"><code>ControlFlow</code></a> type allows a similar idea:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::ops::ControlFlow;

let triangular = (1..30).try_fold(0_i8, |prev, x| {
    if let Some(next) = prev.checked_add(x) {
        ControlFlow::Continue(next)
    } else {
        ControlFlow::Break(prev)
    }
});
assert_eq!(triangular, ControlFlow::Break(120));

let triangular = (1..30).try_fold(0_u64, |prev, x| {
    if let Some(next) = prev.checked_add(x) {
        ControlFlow::Continue(next)
    } else {
        ControlFlow::Break(prev)
    }
});
assert_eq!(triangular, ControlFlow::Continue(435));</pre></div> </div>
<summary><section id="method.try_for_each" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2420-2424">Source</a></span><pre class="code-header" data-language="rust">fn try_for_each&lt;F, R&gt;(&amp;mut self, f: F) -&gt; Rwhere
    Self: Sized,
    F: FnMut(Self::Item) -&gt; R,
    R: Try&lt;Output = ()&gt;,</pre></section></summary><div class="docblock">
<p>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error.</p> <p>This can also be thought of as the fallible form of <a href="trait.iterator.html#method.for_each" title="method std::iter::Iterator::for_each"><code>for_each()</code></a> or as the stateless version of <a href="trait.iterator.html#method.try_fold" title="method std::iter::Iterator::try_fold"><code>try_fold()</code></a>.</p> <h5 id="examples-37">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::fs::rename;
use std::io::{stdout, Write};
use std::path::Path;

let data = ["no_tea.txt", "stale_bread.json", "torrential_rain.png"];

let res = data.iter().try_for_each(|x| writeln!(stdout(), "{x}"));
assert!(res.is_ok());

let mut it = data.iter().cloned();
let res = it.try_for_each(|x| rename(x, Path::new(x).with_extension("old")));
assert!(res.is_err());
// It short-circuited, so the remaining items are still in the iterator:
assert_eq!(it.next(), Some("stale_bread.json"));</pre></div> <p>The <a href="../ops/enum.controlflow.html" title="enum std::ops::ControlFlow"><code>ControlFlow</code></a> type can be used with this method for the situations in which you’d use <code>break</code> and <code>continue</code> in a normal loop:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::ops::ControlFlow;

let r = (2..100).try_for_each(|x| {
    if 323 % x == 0 {
        return ControlFlow::Break(x)
    }

    ControlFlow::Continue(())
});
assert_eq!(r, ControlFlow::Break(17));</pre></div> </div>
<summary><section id="method.fold" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2539-2542">Source</a></span><pre class="code-header" data-language="rust">fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; Bwhere
    Self: Sized,
    F: FnMut(B, Self::Item) -&gt; B,</pre></section></summary><div class="docblock">
<p>Folds every element into an accumulator by applying an operation, returning the final result.</p> <p><code>fold()</code> takes two arguments: an initial value, and a closure with two arguments: an ‘accumulator’, and an element. The closure returns the value that the accumulator should have for the next iteration.</p> <p>The initial value is the value the accumulator will have on the first call.</p> <p>After applying this closure to every element of the iterator, <code>fold()</code> returns the accumulator.</p> <p>This operation is sometimes called ‘reduce’ or ‘inject’.</p> <p>Folding is useful whenever you have a collection of something, and want to produce a single value from it.</p> <p>Note: <code>fold()</code>, and similar methods that traverse the entire iterator, might not terminate for infinite iterators, even on traits for which a result is determinable in finite time.</p> <p>Note: <a href="trait.iterator.html#method.reduce" title="method std::iter::Iterator::reduce"><code>reduce()</code></a> can be used to use the first element as the initial value, if the accumulator type and item type is the same.</p> <p>Note: <code>fold()</code> combines elements in a <em>left-associative</em> fashion. For associative operators like <code>+</code>, the order the elements are combined in is not important, but for non-associative operators like <code>-</code> the order will affect the final result. For a <em>right-associative</em> version of <code>fold()</code>, see <a href="trait.doubleendediterator.html#method.rfold" title="method std::iter::DoubleEndedIterator::rfold"><code>DoubleEndedIterator::rfold()</code></a>.</p> <h5 id="note-to-implementors-1">Note to Implementors</h5> <p>Several of the other (forward) methods have default implementations in terms of this one, so try to implement this explicitly if it can do something better than the default <code>for</code> loop implementation.</p> <p>In particular, try to have this call <code>fold()</code> on the internal parts from which this iterator is composed.</p> <h5 id="examples-38">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

// the sum of all of the elements of the array
let sum = a.iter().fold(0, |acc, x| acc + x);

assert_eq!(sum, 6);</pre></div> <p>Let’s walk through each step of the iteration here:</p> <div>
<table>
<thead><tr>
<th>element</th>
<th>acc</th>
<th>x</th>
<th>result</th>
</tr></thead>
<tbody> <tr>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr> <tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr> <tr>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr> <tr>
<td>3</td>
<td>3</td>
<td>3</td>
<td>6</td>
</tr> </tbody>
</table> </div> <p>And so, our final result, <code>6</code>.</p> <p>This example demonstrates the left-associative nature of <code>fold()</code>: it builds a string, starting with an initial value and continuing with each element from the front until the back:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let numbers = [1, 2, 3, 4, 5];

let zero = "0".to_string();

let result = numbers.iter().fold(zero, |acc, &amp;x| {
    format!("({acc} + {x})")
});

assert_eq!(result, "(((((0 + 1) + 2) + 3) + 4) + 5)");</pre></div> <p>It’s common for people who haven’t used iterators a lot to use a <code>for</code> loop with a list of things to build up a result. Those can be turned into <code>fold()</code>s:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let numbers = [1, 2, 3, 4, 5];

let mut result = 0;

// for loop:
for i in &amp;numbers {
    result = result + i;
}

// fold:
let result2 = numbers.iter().fold(0, |acc, &amp;x| acc + x);

// they're the same
assert_eq!(result, result2);</pre></div> </div>
<summary><section id="method.reduce" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2576-2579">Source</a></span><pre class="code-header" data-language="rust">fn reduce&lt;F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;where
    Self: Sized,
    F: FnMut(Self::Item, Self::Item) -&gt; Self::Item,</pre></section></summary><div class="docblock">
<p>Reduces the elements to a single one, by repeatedly applying a reducing operation.</p> <p>If the iterator is empty, returns <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>; otherwise, returns the result of the reduction.</p> <p>The reducing function is a closure with two arguments: an ‘accumulator’, and an element. For iterators with at least one element, this is the same as <a href="trait.iterator.html#method.fold" title="method std::iter::Iterator::fold"><code>fold()</code></a> with the first element of the iterator as the initial accumulator value, folding every subsequent element into it.</p> <h5 id="example">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let reduced: i32 = (1..10).reduce(|acc, e| acc + e).unwrap_or(0);
assert_eq!(reduced, 45);

// Which is equivalent to doing it with `fold`:
let folded: i32 = (1..10).fold(0, |acc, e| acc + e);
assert_eq!(reduced, folded);</pre></div> </div>
<summary><section id="method.try_reduce" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2647-2653">Source</a><pre class="code-header" data-language="rust">fn try_reduce&lt;R&gt;(
    &amp;mut self,
    f: impl FnMut(Self::Item, Self::Item) -&gt; R,
) -&gt; &lt;&lt;R as Try&gt;::Residual as Residual&lt;Option&lt;&lt;R as Try&gt;::Output&gt;&gt;&gt;::TryTypewhere
    Self: Sized,
    R: Try&lt;Output = Self::Item&gt;,
    &lt;R as Try&gt;::Residual: Residual&lt;Option&lt;Self::Item&gt;&gt;,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iterator_try_reduce</code> <a href="https://github.com/rust-lang/rust/issues/87053">#87053</a>)</span>
</div></span></summary><div class="docblock">
<p>Reduces the elements to a single one by repeatedly applying a reducing operation. If the closure returns a failure, the failure is propagated back to the caller immediately.</p> <p>The return type of this method depends on the return type of the closure. If the closure returns <code>Result&lt;Self::Item, E&gt;</code>, then this function will return <code>Result&lt;Option&lt;Self::Item&gt;, E&gt;</code>. If the closure returns <code>Option&lt;Self::Item&gt;</code>, then this function will return <code>Option&lt;Option&lt;Self::Item&gt;&gt;</code>.</p> <p>When called on an empty iterator, this function will return either <code>Some(None)</code> or <code>Ok(None)</code> depending on the type of the provided closure.</p> <p>For iterators with at least one element, this is essentially the same as calling <a href="trait.iterator.html#method.try_fold" title="method std::iter::Iterator::try_fold"><code>try_fold()</code></a> with the first element of the iterator as the initial accumulator value.</p> <h5 id="examples-39">Examples</h5> <p>Safely calculate the sum of a series of numbers:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iterator_try_reduce)]

let numbers: Vec&lt;usize&gt; = vec![10, 20, 5, 23, 0];
let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));
assert_eq!(sum, Some(Some(58)));</pre></div> <p>Determine when a reduction short circuited:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iterator_try_reduce)]

let numbers = vec![1, 2, 3, usize::MAX, 4, 5];
let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));
assert_eq!(sum, None);</pre></div> <p>Determine when a reduction was not performed because there are no elements:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iterator_try_reduce)]

let numbers: Vec&lt;usize&gt; = Vec::new();
let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));
assert_eq!(sum, Some(None));</pre></div> <p>Use a <a href="../result/enum.result.html" title="enum std::result::Result"><code>Result</code></a> instead of an <a href="../option/enum.option.html" title="enum std::option::Option"><code>Option</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iterator_try_reduce)]

let numbers = vec!["1", "2", "3", "4", "5"];
let max: Result&lt;Option&lt;_&gt;, &lt;usize as std::str::FromStr&gt;::Err&gt; =
    numbers.into_iter().try_reduce(|x, y| {
        if x.parse::&lt;usize&gt;()? &gt; y.parse::&lt;usize&gt;()? { Ok(x) } else { Ok(y) }
    });
assert_eq!(max, Ok(Some("5")));</pre></div> </div>
<summary><section id="method.all" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2705-2708">Source</a></span><pre class="code-header" data-language="rust">fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; boolwhere
    Self: Sized,
    F: FnMut(Self::Item) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Tests if every element of the iterator matches a predicate.</p> <p><code>all()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies this closure to each element of the iterator, and if they all return <code>true</code>, then so does <code>all()</code>. If any of them return <code>false</code>, it returns <code>false</code>.</p> <p><code>all()</code> is short-circuiting; in other words, it will stop processing as soon as it finds a <code>false</code>, given that no matter what else happens, the result will also be <code>false</code>.</p> <p>An empty iterator returns <code>true</code>.</p> <h5 id="examples-40">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

assert!(a.iter().all(|&amp;x| x &gt; 0));

assert!(!a.iter().all(|&amp;x| x &gt; 2));</pre></div> <p>Stopping at the first <code>false</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let mut iter = a.iter();

assert!(!iter.all(|&amp;x| x != 2));

// we can still use `iter`, as there are more elements.
assert_eq!(iter.next(), Some(&amp;3));</pre></div> </div>
<summary><section id="method.any" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2758-2761">Source</a></span><pre class="code-header" data-language="rust">fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; boolwhere
    Self: Sized,
    F: FnMut(Self::Item) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Tests if any element of the iterator matches a predicate.</p> <p><code>any()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies this closure to each element of the iterator, and if any of them return <code>true</code>, then so does <code>any()</code>. If they all return <code>false</code>, it returns <code>false</code>.</p> <p><code>any()</code> is short-circuiting; in other words, it will stop processing as soon as it finds a <code>true</code>, given that no matter what else happens, the result will also be <code>true</code>.</p> <p>An empty iterator returns <code>false</code>.</p> <h5 id="examples-41">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

assert!(a.iter().any(|&amp;x| x &gt; 0));

assert!(!a.iter().any(|&amp;x| x &gt; 5));</pre></div> <p>Stopping at the first <code>true</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let mut iter = a.iter();

assert!(iter.any(|&amp;x| x != 2));

// we can still use `iter`, as there are more elements.
assert_eq!(iter.next(), Some(&amp;2));</pre></div> </div>
<summary><section id="method.find" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2821-2824">Source</a></span><pre class="code-header" data-language="rust">fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt;where
    Self: Sized,
    P: FnMut(&amp;Self::Item) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Searches for an element of an iterator that satisfies a predicate.</p> <p><code>find()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies this closure to each element of the iterator, and if any of them return <code>true</code>, then <code>find()</code> returns <a href="../option/enum.option.html#variant.Some" title="variant std::option::Option::Some"><code>Some(element)</code></a>. If they all return <code>false</code>, it returns <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>.</p> <p><code>find()</code> is short-circuiting; in other words, it will stop processing as soon as the closure returns <code>true</code>.</p> <p>Because <code>find()</code> takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with <code>&amp;&amp;x</code>.</p> <p>If you need the index of the element, see <a href="trait.iterator.html#method.position" title="method std::iter::Iterator::position"><code>position()</code></a>.</p> <h5 id="examples-42">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

assert_eq!(a.iter().find(|&amp;&amp;x| x == 2), Some(&amp;2));

assert_eq!(a.iter().find(|&amp;&amp;x| x == 5), None);</pre></div> <p>Stopping at the first <code>true</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let mut iter = a.iter();

assert_eq!(iter.find(|&amp;&amp;x| x == 2), Some(&amp;2));

// we can still use `iter`, as there are more elements.
assert_eq!(iter.next(), Some(&amp;3));</pre></div> <p>Note that <code>iter.find(f)</code> is equivalent to <code>iter.filter(f).next()</code>.</p> </div>
<summary><section id="method.find_map" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2852-2855">Source</a></span><pre class="code-header" data-language="rust">fn find_map&lt;B, F&gt;(&amp;mut self, f: F) -&gt; Option&lt;B&gt;where
    Self: Sized,
    F: FnMut(Self::Item) -&gt; Option&lt;B&gt;,</pre></section></summary><div class="docblock">
<p>Applies function to the elements of iterator and returns the first non-none result.</p> <p><code>iter.find_map(f)</code> is equivalent to <code>iter.filter_map(f).next()</code>.</p> <h5 id="examples-43">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = ["lol", "NaN", "2", "5"];

let first_number = a.iter().find_map(|s| s.parse().ok());

assert_eq!(first_number, Some(2));</pre></div> </div>
<summary><section id="method.try_find" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2910-2916">Source</a><pre class="code-header" data-language="rust">fn try_find&lt;R&gt;(
    &amp;mut self,
    f: impl FnMut(&amp;Self::Item) -&gt; R,
) -&gt; &lt;&lt;R as Try&gt;::Residual as Residual&lt;Option&lt;Self::Item&gt;&gt;&gt;::TryTypewhere
    Self: Sized,
    R: Try&lt;Output = bool&gt;,
    &lt;R as Try&gt;::Residual: Residual&lt;Option&lt;Self::Item&gt;&gt;,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>try_find</code> <a href="https://github.com/rust-lang/rust/issues/63178">#63178</a>)</span>
</div></span></summary><div class="docblock">
<p>Applies function to the elements of iterator and returns the first true result or the first error.</p> <p>The return type of this method depends on the return type of the closure. If you return <code>Result&lt;bool, E&gt;</code> from the closure, you’ll get a <code>Result&lt;Option&lt;Self::Item&gt;, E&gt;</code>. If you return <code>Option&lt;bool&gt;</code> from the closure, you’ll get an <code>Option&lt;Option&lt;Self::Item&gt;&gt;</code>.</p> <h5 id="examples-44">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(try_find)]

let a = ["1", "2", "lol", "NaN", "5"];

let is_my_num = |s: &amp;str, search: i32| -&gt; Result&lt;bool, std::num::ParseIntError&gt; {
    Ok(s.parse::&lt;i32&gt;()?  == search)
};

let result = a.iter().try_find(|&amp;&amp;s| is_my_num(s, 2));
assert_eq!(result, Ok(Some(&amp;"2")));

let result = a.iter().try_find(|&amp;&amp;s| is_my_num(s, 5));
assert!(result.is_err());</pre></div> <p>This also supports other types which implement <a href="../ops/trait.try.html" title="trait std::ops::Try"><code>Try</code></a>, not just <a href="../result/enum.result.html" title="enum std::result::Result"><code>Result</code></a>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(try_find)]

use std::num::NonZero;

let a = [3, 5, 7, 4, 9, 0, 11u32];
let result = a.iter().try_find(|&amp;&amp;x| NonZero::new(x).map(|y| y.is_power_of_two()));
assert_eq!(result, Some(Some(&amp;4)));
let result = a.iter().take(3).try_find(|&amp;&amp;x| NonZero::new(x).map(|y| y.is_power_of_two()));
assert_eq!(result, Some(None));
let result = a.iter().rev().try_find(|&amp;&amp;x| NonZero::new(x).map(|y| y.is_power_of_two()));
assert_eq!(result, None);</pre></div> </div>
<summary><section id="method.position" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2993-2996">Source</a></span><pre class="code-header" data-language="rust">fn position&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;where
    Self: Sized,
    P: FnMut(Self::Item) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Searches for an element in an iterator, returning its index.</p> <p><code>position()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies this closure to each element of the iterator, and if one of them returns <code>true</code>, then <code>position()</code> returns <a href="../option/enum.option.html#variant.Some" title="variant std::option::Option::Some"><code>Some(index)</code></a>. If all of them return <code>false</code>, it returns <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>.</p> <p><code>position()</code> is short-circuiting; in other words, it will stop processing as soon as it finds a <code>true</code>.</p> <h5 id="overflow-behavior-2">Overflow Behavior</h5> <p>The method does no guarding against overflows, so if there are more than <a href="../primitive.usize.html#associatedconstant.MAX" title="associated constant usize::MAX"><code>usize::MAX</code></a> non-matching elements, it either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</p> <h5 id="panics-4">Panics</h5> <p>This function might panic if the iterator has more than <code>usize::MAX</code> non-matching elements.</p> <h5 id="examples-45">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

assert_eq!(a.iter().position(|&amp;x| x == 2), Some(1));

assert_eq!(a.iter().position(|&amp;x| x == 5), None);</pre></div> <p>Stopping at the first <code>true</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3, 4];

let mut iter = a.iter();

assert_eq!(iter.position(|&amp;x| x &gt;= 2), Some(1));

// we can still use `iter`, as there are more elements.
assert_eq!(iter.next(), Some(&amp;3));

// The returned index depends on iterator state
assert_eq!(iter.position(|&amp;x| x == 4), Some(0));
</pre></div> </div>
<summary><section id="method.rposition" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3058-3061">Source</a></span><pre class="code-header" data-language="rust">fn rposition&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;where
    P: FnMut(Self::Item) -&gt; bool,
    Self: Sized + ExactSizeIterator + DoubleEndedIterator,</pre></section></summary><div class="docblock">
<p>Searches for an element in an iterator from the right, returning its index.</p> <p><code>rposition()</code> takes a closure that returns <code>true</code> or <code>false</code>. It applies this closure to each element of the iterator, starting from the end, and if one of them returns <code>true</code>, then <code>rposition()</code> returns <a href="../option/enum.option.html#variant.Some" title="variant std::option::Option::Some"><code>Some(index)</code></a>. If all of them return <code>false</code>, it returns <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>.</p> <p><code>rposition()</code> is short-circuiting; in other words, it will stop processing as soon as it finds a <code>true</code>.</p> <h5 id="examples-46">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

assert_eq!(a.iter().rposition(|&amp;x| x == 3), Some(2));

assert_eq!(a.iter().rposition(|&amp;x| x == 5), None);</pre></div> <p>Stopping at the first <code>true</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-1, 2, 3, 4];

let mut iter = a.iter();

assert_eq!(iter.rposition(|&amp;x| x &gt;= 2), Some(3));

// we can still use `iter`, as there are more elements.
assert_eq!(iter.next(), Some(&amp;-1));
assert_eq!(iter.next_back(), Some(&amp;3));</pre></div> </div>
<summary><section id="method.max" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3107-3110">Source</a></span><pre class="code-header" data-language="rust">fn max(self) -&gt; Option&lt;Self::Item&gt;where
    Self: Sized,
    Self::Item: Ord,</pre></section></summary><div class="docblock">
<p>Returns the maximum element of an iterator.</p> <p>If several elements are equally maximum, the last element is returned. If the iterator is empty, <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is returned.</p> <p>Note that <a href="../primitive.f32.html" title="primitive f32"><code>f32</code></a>/<a href="../primitive.f64.html" title="primitive f64"><code>f64</code></a> doesn’t implement <a href="../cmp/trait.ord.html" title="trait std::cmp::Ord"><code>Ord</code></a> due to NaN being incomparable. You can work around this by using <a href="trait.iterator.html#method.reduce" title="method std::iter::Iterator::reduce"><code>Iterator::reduce</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!(
    [2.4, f32::NAN, 1.3]
        .into_iter()
        .reduce(f32::max)
        .unwrap_or(0.),
    2.4
);</pre></div> <h5 id="examples-47">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];
let b: Vec&lt;u32&gt; = Vec::new();

assert_eq!(a.iter().max(), Some(&amp;3));
assert_eq!(b.iter().max(), None);</pre></div> </div>
<summary><section id="method.min" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3143-3146">Source</a></span><pre class="code-header" data-language="rust">fn min(self) -&gt; Option&lt;Self::Item&gt;where
    Self: Sized,
    Self::Item: Ord,</pre></section></summary><div class="docblock">
<p>Returns the minimum element of an iterator.</p> <p>If several elements are equally minimum, the first element is returned. If the iterator is empty, <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is returned.</p> <p>Note that <a href="../primitive.f32.html" title="primitive f32"><code>f32</code></a>/<a href="../primitive.f64.html" title="primitive f64"><code>f64</code></a> doesn’t implement <a href="../cmp/trait.ord.html" title="trait std::cmp::Ord"><code>Ord</code></a> due to NaN being incomparable. You can work around this by using <a href="trait.iterator.html#method.reduce" title="method std::iter::Iterator::reduce"><code>Iterator::reduce</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!(
    [2.4, f32::NAN, 1.3]
        .into_iter()
        .reduce(f32::min)
        .unwrap_or(0.),
    1.3
);</pre></div> <h5 id="examples-48">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];
let b: Vec&lt;u32&gt; = Vec::new();

assert_eq!(a.iter().min(), Some(&amp;1));
assert_eq!(b.iter().min(), None);</pre></div> </div>
<summary><section id="method.max_by_key" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3165-3168">Source</a></span><pre class="code-header" data-language="rust">fn max_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;where
    B: Ord,
    Self: Sized,
    F: FnMut(&amp;Self::Item) -&gt; B,</pre></section></summary><div class="docblock">
<p>Returns the element that gives the maximum value from the specified function.</p> <p>If several elements are equally maximum, the last element is returned. If the iterator is empty, <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is returned.</p> <h5 id="examples-49">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-3_i32, 0, 1, 5, -10];
assert_eq!(*a.iter().max_by_key(|x| x.abs()).unwrap(), -10);</pre></div> </div>
<summary><section id="method.max_by" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.15.0">1.15.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3198-3201">Source</a></span><pre class="code-header" data-language="rust">fn max_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;where
    Self: Sized,
    F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering,</pre></section></summary><div class="docblock">
<p>Returns the element that gives the maximum value with respect to the specified comparison function.</p> <p>If several elements are equally maximum, the last element is returned. If the iterator is empty, <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is returned.</p> <h5 id="examples-50">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-3_i32, 0, 1, 5, -10];
assert_eq!(*a.iter().max_by(|x, y| x.cmp(y)).unwrap(), 5);</pre></div> </div>
<summary><section id="method.min_by_key" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3225-3228">Source</a></span><pre class="code-header" data-language="rust">fn min_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;where
    B: Ord,
    Self: Sized,
    F: FnMut(&amp;Self::Item) -&gt; B,</pre></section></summary><div class="docblock">
<p>Returns the element that gives the minimum value from the specified function.</p> <p>If several elements are equally minimum, the first element is returned. If the iterator is empty, <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is returned.</p> <h5 id="examples-51">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-3_i32, 0, 1, 5, -10];
assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);</pre></div> </div>
<summary><section id="method.min_by" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.15.0">1.15.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3258-3261">Source</a></span><pre class="code-header" data-language="rust">fn min_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;where
    Self: Sized,
    F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering,</pre></section></summary><div class="docblock">
<p>Returns the element that gives the minimum value with respect to the specified comparison function.</p> <p>If several elements are equally minimum, the first element is returned. If the iterator is empty, <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> is returned.</p> <h5 id="examples-52">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [-3_i32, 0, 1, 5, -10];
assert_eq!(*a.iter().min_by(|x, y| x.cmp(y)).unwrap(), -10);</pre></div> </div>
<summary><section id="method.rev" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3295-3297">Source</a></span><pre class="code-header" data-language="rust">fn rev(self) -&gt; Rev&lt;Self&gt; ⓘwhere
    Self: Sized + DoubleEndedIterator,</pre></section></summary><div class="docblock">
<p>Reverses an iterator’s direction.</p> <p>Usually, iterators iterate from left to right. After using <code>rev()</code>, an iterator will instead iterate from right to left.</p> <p>This is only possible if the iterator has an end, so <code>rev()</code> only works on <a href="trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a>s.</p> <h5 id="examples-53">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let mut iter = a.iter().rev();

assert_eq!(iter.next(), Some(&amp;3));
assert_eq!(iter.next(), Some(&amp;2));
assert_eq!(iter.next(), Some(&amp;1));

assert_eq!(iter.next(), None);</pre></div> </div>
<summary><section id="method.unzip" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3331-3335">Source</a></span><pre class="code-header" data-language="rust">fn unzip&lt;A, B, FromA, FromB&gt;(self) -&gt; (FromA, FromB)where
    FromA: Default + Extend&lt;A&gt;,
    FromB: Default + Extend&lt;B&gt;,
    Self: Sized + Iterator&lt;Item = (A, B)&gt;,</pre></section></summary><div class="docblock">
<p>Converts an iterator of pairs into a pair of containers.</p> <p><code>unzip()</code> consumes an entire iterator of pairs, producing two collections: one from the left elements of the pairs, and one from the right elements.</p> <p>This function is, in some sense, the opposite of <a href="trait.iterator.html#method.zip" title="method std::iter::Iterator::zip"><code>zip</code></a>.</p> <h5 id="examples-54">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [(1, 2), (3, 4), (5, 6)];

let (left, right): (Vec&lt;_&gt;, Vec&lt;_&gt;) = a.iter().cloned().unzip();

assert_eq!(left, [1, 3, 5]);
assert_eq!(right, [2, 4, 6]);

// you can also unzip multiple nested tuples at once
let a = [(1, (2, 3)), (4, (5, 6))];

let (x, (y, z)): (Vec&lt;_&gt;, (Vec&lt;_&gt;, Vec&lt;_&gt;)) = a.iter().cloned().unzip();
assert_eq!(x, [1, 4]);
assert_eq!(y, [2, 5]);
assert_eq!(z, [3, 6]);</pre></div> </div>
<summary><section id="method.copied" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3362-3365">Source</a></span><pre class="code-header" data-language="rust">fn copied&lt;'a, T&gt;(self) -&gt; Copied&lt;Self&gt; ⓘwhere
    T: 'a + Copy,
    Self: Sized + Iterator&lt;Item = &amp;'a T&gt;,</pre></section></summary><div class="docblock">
<p>Creates an iterator which copies all of its elements.</p> <p>This is useful when you have an iterator over <code>&amp;T</code>, but you need an iterator over <code>T</code>.</p> <h5 id="examples-55">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let v_copied: Vec&lt;_&gt; = a.iter().copied().collect();

// copied is the same as .map(|&amp;x| x)
let v_map: Vec&lt;_&gt; = a.iter().map(|&amp;x| x).collect();

assert_eq!(v_copied, vec![1, 2, 3]);
assert_eq!(v_map, vec![1, 2, 3]);</pre></div> </div>
<summary><section id="method.cloned" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3410-3413">Source</a></span><pre class="code-header" data-language="rust">fn cloned&lt;'a, T&gt;(self) -&gt; Cloned&lt;Self&gt; ⓘwhere
    T: 'a + Clone,
    Self: Sized + Iterator&lt;Item = &amp;'a T&gt;,</pre></section></summary><div class="docblock">
<p>Creates an iterator which <a href="../clone/trait.clone.html#tymethod.clone" title="method std::clone::Clone::clone"><code>clone</code></a>s all of its elements.</p> <p>This is useful when you have an iterator over <code>&amp;T</code>, but you need an iterator over <code>T</code>.</p> <p>There is no guarantee whatsoever about the <code>clone</code> method actually being called <em>or</em> optimized away. So code should not depend on either.</p> <h5 id="examples-56">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let v_cloned: Vec&lt;_&gt; = a.iter().cloned().collect();

// cloned is the same as .map(|&amp;x| x), for integers
let v_map: Vec&lt;_&gt; = a.iter().map(|&amp;x| x).collect();

assert_eq!(v_cloned, vec![1, 2, 3]);
assert_eq!(v_map, vec![1, 2, 3]);</pre></div> <p>To get the best performance, try to clone late:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [vec![0_u8, 1, 2], vec![3, 4], vec![23]];
// don't do this:
let slower: Vec&lt;_&gt; = a.iter().cloned().filter(|s| s.len() == 1).collect();
assert_eq!(&amp;[vec![23]], &amp;slower[..]);
// instead call `cloned` late
let faster: Vec&lt;_&gt; = a.iter().filter(|s| s.len() == 1).cloned().collect();
assert_eq!(&amp;[vec![23]], &amp;faster[..]);</pre></div> </div>
<summary><section id="method.cycle" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3442-3444">Source</a></span><pre class="code-header" data-language="rust">fn cycle(self) -&gt; Cycle&lt;Self&gt; ⓘwhere
    Self: Sized + Clone,</pre></section></summary><div class="docblock">
<p>Repeats an iterator endlessly.</p> <p>Instead of stopping at <a href="../option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a>, the iterator will instead start again, from the beginning. After iterating again, it will start at the beginning again. And again. And again. Forever. Note that in case the original iterator is empty, the resulting iterator will also be empty.</p> <h5 id="examples-57">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];

let mut it = a.iter().cycle();

assert_eq!(it.next(), Some(&amp;1));
assert_eq!(it.next(), Some(&amp;2));
assert_eq!(it.next(), Some(&amp;3));
assert_eq!(it.next(), Some(&amp;1));
assert_eq!(it.next(), Some(&amp;2));
assert_eq!(it.next(), Some(&amp;3));
assert_eq!(it.next(), Some(&amp;1));</pre></div> </div>
<summary><section id="method.array_chunks" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3485-3487">Source</a><pre class="code-header" data-language="rust">fn array_chunks&lt;const N: usize&gt;(self) -&gt; ArrayChunks&lt;Self, N&gt; ⓘwhere
    Self: Sized,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_array_chunks</code> <a href="https://github.com/rust-lang/rust/issues/100450">#100450</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns an iterator over <code>N</code> elements of the iterator at a time.</p> <p>The chunks do not overlap. If <code>N</code> does not divide the length of the iterator, then the last up to <code>N-1</code> elements will be omitted and can be retrieved from the <a href="struct.arraychunks.html#method.into_remainder" title="method std::iter::ArrayChunks::into_remainder"><code>.into_remainder()</code></a> function of the iterator.</p> <h5 id="panics-5">Panics</h5> <p>Panics if <code>N</code> is zero.</p> <h5 id="examples-58">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_array_chunks)]

let mut iter = "lorem".chars().array_chunks();
assert_eq!(iter.next(), Some(['l', 'o']));
assert_eq!(iter.next(), Some(['r', 'e']));
assert_eq!(iter.next(), None);
assert_eq!(iter.into_remainder().unwrap().as_slice(), &amp;['m']);</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_array_chunks)]

let data = [1, 1, 2, -2, 6, 0, 3, 1];
//          ^-----^  ^------^
for [x, y, z] in data.iter().array_chunks() {
    assert_eq!(x + y + z, 4);
}</pre></div> </div>
<summary><section id="method.sum" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.11.0">1.11.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3516-3519">Source</a></span><pre class="code-header" data-language="rust">fn sum&lt;S&gt;(self) -&gt; Swhere
    Self: Sized,
    S: Sum&lt;Self::Item&gt;,</pre></section></summary><div class="docblock">
<p>Sums the elements of an iterator.</p> <p>Takes each element, adds them together, and returns the result.</p> <p>An empty iterator returns the zero value of the type.</p> <p><code>sum()</code> can be used to sum any type implementing <a href="trait.sum.html" title="trait std::iter::Sum"><code>Sum</code></a>, including <a href="../option/enum.option.html#method.sum" title="associated function std::option::Option::sum"><code>Option</code></a> and <a href="../result/enum.result.html#method.sum" title="associated function std::result::Result::sum"><code>Result</code></a>.</p> <h5 id="panics-6">Panics</h5> <p>When calling <code>sum()</code> and a primitive integer type is being returned, this method will panic if the computation overflows and debug assertions are enabled.</p> <h5 id="examples-59">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = [1, 2, 3];
let sum: i32 = a.iter().sum();

assert_eq!(sum, 6);</pre></div> </div>
<summary><section id="method.product" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.11.0">1.11.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3548-3551">Source</a></span><pre class="code-header" data-language="rust">fn product&lt;P&gt;(self) -&gt; Pwhere
    Self: Sized,
    P: Product&lt;Self::Item&gt;,</pre></section></summary><div class="docblock">
<p>Iterates over the entire iterator, multiplying all the elements</p> <p>An empty iterator returns the one value of the type.</p> <p><code>product()</code> can be used to multiply any type implementing <a href="trait.product.html" title="trait std::iter::Product"><code>Product</code></a>, including <a href="../option/enum.option.html#method.product" title="associated function std::option::Option::product"><code>Option</code></a> and <a href="../result/enum.result.html#method.product" title="associated function std::result::Result::product"><code>Result</code></a>.</p> <h5 id="panics-7">Panics</h5> <p>When calling <code>product()</code> and a primitive integer type is being returned, method will panic if the computation overflows and debug assertions are enabled.</p> <h5 id="examples-60">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">fn factorial(n: u32) -&gt; u32 {
    (1..=n).product()
}
assert_eq!(factorial(0), 1);
assert_eq!(factorial(1), 1);
assert_eq!(factorial(5), 120);</pre></div> </div>
<summary><section id="method.cmp" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3569-3573">Source</a></span><pre class="code-header" data-language="rust">fn cmp&lt;I&gt;(self, other: I) -&gt; Orderingwhere
    I: IntoIterator&lt;Item = Self::Item&gt;,
    Self::Item: Ord,
    Self: Sized,</pre></section></summary><div class="docblock">
<p><a href="../cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">Lexicographically</a> compares the elements of this <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> with those of another.</p> <h5 id="examples-61">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::cmp::Ordering;

assert_eq!([1].iter().cmp([1].iter()), Ordering::Equal);
assert_eq!([1].iter().cmp([1, 2].iter()), Ordering::Less);
assert_eq!([1, 2].iter().cmp([1].iter()), Ordering::Greater);</pre></div> </div>
<summary><section id="method.cmp_by" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3596-3600">Source</a><pre class="code-header" data-language="rust">fn cmp_by&lt;I, F&gt;(self, other: I, cmp: F) -&gt; Orderingwhere
    Self: Sized,
    I: IntoIterator,
    F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Ordering,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code> <a href="https://github.com/rust-lang/rust/issues/64295">#64295</a>)</span>
</div></span></summary><div class="docblock">
<p><a href="../cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">Lexicographically</a> compares the elements of this <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> with those of another with respect to the specified comparison function.</p> <h5 id="examples-62">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_order_by)]

use std::cmp::Ordering;

let xs = [1, 2, 3, 4];
let ys = [1, 4, 9, 16];

assert_eq!(xs.iter().cmp_by(&amp;ys, |&amp;x, &amp;y| x.cmp(&amp;y)), Ordering::Less);
assert_eq!(xs.iter().cmp_by(&amp;ys, |&amp;x, &amp;y| (x * x).cmp(&amp;y)), Ordering::Equal);
assert_eq!(xs.iter().cmp_by(&amp;ys, |&amp;x, &amp;y| (2 * x).cmp(&amp;y)), Ordering::Greater);</pre></div> </div>
<summary><section id="method.partial_cmp" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3652-3656">Source</a></span><pre class="code-header" data-language="rust">fn partial_cmp&lt;I&gt;(self, other: I) -&gt; Option&lt;Ordering&gt;where
    I: IntoIterator,
    Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,
    Self: Sized,</pre></section></summary><div class="docblock">
<p><a href="../cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">Lexicographically</a> compares the <a href="../cmp/trait.partialord.html" title="trait std::cmp::PartialOrd"><code>PartialOrd</code></a> elements of this <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> with those of another. The comparison works like short-circuit evaluation, returning a result without comparing the remaining elements. As soon as an order can be determined, the evaluation stops and a result is returned.</p> <h5 id="examples-63">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::cmp::Ordering;

assert_eq!([1.].iter().partial_cmp([1.].iter()), Some(Ordering::Equal));
assert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));
assert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));</pre></div> <p>For floating-point numbers, NaN does not have a total order and will result in <code>None</code> when compared:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!([f64::NAN].iter().partial_cmp([1.].iter()), None);</pre></div> <p>The results are determined by the order of evaluation.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::cmp::Ordering;

assert_eq!([1.0, f64::NAN].iter().partial_cmp([2.0, f64::NAN].iter()), Some(Ordering::Less));
assert_eq!([2.0, f64::NAN].iter().partial_cmp([1.0, f64::NAN].iter()), Some(Ordering::Greater));
assert_eq!([f64::NAN, 1.0].iter().partial_cmp([f64::NAN, 2.0].iter()), None);</pre></div> </div>
<summary><section id="method.partial_cmp_by" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3688-3692">Source</a><pre class="code-header" data-language="rust">fn partial_cmp_by&lt;I, F&gt;(self, other: I, partial_cmp: F) -&gt; Option&lt;Ordering&gt;where
    Self: Sized,
    I: IntoIterator,
    F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Option&lt;Ordering&gt;,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code> <a href="https://github.com/rust-lang/rust/issues/64295">#64295</a>)</span>
</div></span></summary><div class="docblock">
<p><a href="../cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">Lexicographically</a> compares the elements of this <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> with those of another with respect to the specified comparison function.</p> <h5 id="examples-64">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_order_by)]

use std::cmp::Ordering;

let xs = [1.0, 2.0, 3.0, 4.0];
let ys = [1.0, 4.0, 9.0, 16.0];

assert_eq!(
    xs.iter().partial_cmp_by(&amp;ys, |&amp;x, &amp;y| x.partial_cmp(&amp;y)),
    Some(Ordering::Less)
);
assert_eq!(
    xs.iter().partial_cmp_by(&amp;ys, |&amp;x, &amp;y| (x * x).partial_cmp(&amp;y)),
    Some(Ordering::Equal)
);
assert_eq!(
    xs.iter().partial_cmp_by(&amp;ys, |&amp;x, &amp;y| (2.0 * x).partial_cmp(&amp;y)),
    Some(Ordering::Greater)
);</pre></div> </div>
<summary><section id="method.eq" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3721-3725">Source</a></span><pre class="code-header" data-language="rust">fn eq&lt;I&gt;(self, other: I) -&gt; boolwhere
    I: IntoIterator,
    Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;,
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Determines if the elements of this <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> are equal to those of another.</p> <h5 id="examples-65">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!([1].iter().eq([1].iter()), true);
assert_eq!([1].iter().eq([1, 2].iter()), false);</pre></div> </div>
<summary><section id="method.eq_by" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3744-3748">Source</a><pre class="code-header" data-language="rust">fn eq_by&lt;I, F&gt;(self, other: I, eq: F) -&gt; boolwhere
    Self: Sized,
    I: IntoIterator,
    F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; bool,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code> <a href="https://github.com/rust-lang/rust/issues/64295">#64295</a>)</span>
</div></span></summary><div class="docblock">
<p>Determines if the elements of this <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> are equal to those of another with respect to the specified equality function.</p> <h5 id="examples-66">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(iter_order_by)]

let xs = [1, 2, 3, 4];
let ys = [1, 4, 9, 16];

assert!(xs.iter().eq_by(&amp;ys, |&amp;x, &amp;y| x * x == y));</pre></div> </div>
<summary><section id="method.ne" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3776-3780">Source</a></span><pre class="code-header" data-language="rust">fn ne&lt;I&gt;(self, other: I) -&gt; boolwhere
    I: IntoIterator,
    Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;,
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Determines if the elements of this <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> are not equal to those of another.</p> <h5 id="examples-67">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!([1].iter().ne([1].iter()), false);
assert_eq!([1].iter().ne([1, 2].iter()), true);</pre></div> </div>
<summary><section id="method.lt" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3797-3801">Source</a></span><pre class="code-header" data-language="rust">fn lt&lt;I&gt;(self, other: I) -&gt; boolwhere
    I: IntoIterator,
    Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Determines if the elements of this <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> are <a href="../cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">lexicographically</a> less than those of another.</p> <h5 id="examples-68">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!([1].iter().lt([1].iter()), false);
assert_eq!([1].iter().lt([1, 2].iter()), true);
assert_eq!([1, 2].iter().lt([1].iter()), false);
assert_eq!([1, 2].iter().lt([1, 2].iter()), false);</pre></div> </div>
<summary><section id="method.le" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3818-3822">Source</a></span><pre class="code-header" data-language="rust">fn le&lt;I&gt;(self, other: I) -&gt; boolwhere
    I: IntoIterator,
    Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Determines if the elements of this <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> are <a href="../cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">lexicographically</a> less or equal to those of another.</p> <h5 id="examples-69">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!([1].iter().le([1].iter()), true);
assert_eq!([1].iter().le([1, 2].iter()), true);
assert_eq!([1, 2].iter().le([1].iter()), false);
assert_eq!([1, 2].iter().le([1, 2].iter()), true);</pre></div> </div>
<summary><section id="method.gt" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3839-3843">Source</a></span><pre class="code-header" data-language="rust">fn gt&lt;I&gt;(self, other: I) -&gt; boolwhere
    I: IntoIterator,
    Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Determines if the elements of this <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> are <a href="../cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">lexicographically</a> greater than those of another.</p> <h5 id="examples-70">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!([1].iter().gt([1].iter()), false);
assert_eq!([1].iter().gt([1, 2].iter()), false);
assert_eq!([1, 2].iter().gt([1].iter()), true);
assert_eq!([1, 2].iter().gt([1, 2].iter()), false);</pre></div> </div>
<summary><section id="method.ge" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3860-3864">Source</a></span><pre class="code-header" data-language="rust">fn ge&lt;I&gt;(self, other: I) -&gt; boolwhere
    I: IntoIterator,
    Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,
    Self: Sized,</pre></section></summary><div class="docblock">
<p>Determines if the elements of this <a href="trait.iterator.html" title="trait std::iter::Iterator"><code>Iterator</code></a> are <a href="../cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">lexicographically</a> greater than or equal to those of another.</p> <h5 id="examples-71">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!([1].iter().ge([1].iter()), true);
assert_eq!([1].iter().ge([1, 2].iter()), false);
assert_eq!([1, 2].iter().ge([1].iter()), true);
assert_eq!([1, 2].iter().ge([1, 2].iter()), true);</pre></div> </div>
<summary><section id="method.is_sorted" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.82.0">1.82.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3889-3892">Source</a></span><pre class="code-header" data-language="rust">fn is_sorted(self) -&gt; boolwhere
    Self: Sized,
    Self::Item: PartialOrd,</pre></section></summary><div class="docblock">
<p>Checks if the elements of this iterator are sorted.</p> <p>That is, for each element <code>a</code> and its following element <code>b</code>, <code>a &lt;= b</code> must hold. If the iterator yields exactly zero or one element, <code>true</code> is returned.</p> <p>Note that if <code>Self::Item</code> is only <code>PartialOrd</code>, but not <code>Ord</code>, the above definition implies that this function returns <code>false</code> if any two consecutive items are not comparable.</p> <h5 id="examples-72">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert!([1, 2, 2, 9].iter().is_sorted());
assert!(![1, 3, 2, 4].iter().is_sorted());
assert!([0].iter().is_sorted());
assert!(std::iter::empty::&lt;i32&gt;().is_sorted());
assert!(![0.0, 1.0, f32::NAN].iter().is_sorted());</pre></div> </div>
<summary><section id="method.is_sorted_by" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.82.0">1.82.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3915-3918">Source</a></span><pre class="code-header" data-language="rust">fn is_sorted_by&lt;F&gt;(self, compare: F) -&gt; boolwhere
    Self: Sized,
    F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; bool,</pre></section></summary><div class="docblock">
<p>Checks if the elements of this iterator are sorted using the given comparator function.</p> <p>Instead of using <code>PartialOrd::partial_cmp</code>, this function uses the given <code>compare</code> function to determine whether two elements are to be considered in sorted order.</p> <h5 id="examples-73">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert!([1, 2, 2, 9].iter().is_sorted_by(|a, b| a &lt;= b));
assert!(![1, 2, 2, 9].iter().is_sorted_by(|a, b| a &lt; b));

assert!([0].iter().is_sorted_by(|a, b| true));
assert!([0].iter().is_sorted_by(|a, b| false));

assert!(std::iter::empty::&lt;i32&gt;().is_sorted_by(|a, b| false));
assert!(std::iter::empty::&lt;i32&gt;().is_sorted_by(|a, b| true));</pre></div> </div>
<summary><section id="method.is_sorted_by_key" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.82.0">1.82.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#3959-3963">Source</a></span><pre class="code-header" data-language="rust">fn is_sorted_by_key&lt;F, K&gt;(self, f: F) -&gt; boolwhere
    Self: Sized,
    F: FnMut(Self::Item) -&gt; K,
    K: PartialOrd,</pre></section></summary><div class="docblock">
<p>Checks if the elements of this iterator are sorted using the given key extraction function.</p> <p>Instead of comparing the iterator’s elements directly, this function compares the keys of the elements, as determined by <code>f</code>. Apart from that, it’s equivalent to <a href="trait.iterator.html#method.is_sorted" title="method std::iter::Iterator::is_sorted"><code>is_sorted</code></a>; see its documentation for more information.</p> <h5 id="examples-74">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert!(["c", "bb", "aaa"].iter().is_sorted_by_key(|s| s.len()));
assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));</pre></div> </div>
</div>
<h3 id="implementors" class="section-header">Implementors</h3>
<div id="implementors-list">
<summary><section id="impl-Iterator-for-Bytes%3C'_%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/ffi/c_str.rs.html#794">Source</a><pre class="code-header" data-language="rust">impl Iterator for core::ffi::c_str::Bytes&lt;'_&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/ffi/c_str.rs.html#795">Source</a><pre class="code-header" data-language="rust">type Item = u8</pre></section></div>
<summary><section id="impl-Iterator-for-EscapeDefault" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/ascii.rs.html#114">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for std::ascii::EscapeDefault</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-2" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/ascii.rs.html#115">Source</a><pre class="code-header" data-language="rust">type Item = u8</pre></section></div>
<summary><section id="impl-Iterator-for-EscapeDebug" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/char/mod.rs.html#331">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for std::char::EscapeDebug</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-3" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/char/mod.rs.html#332">Source</a><pre class="code-header" data-language="rust">type Item = char</pre></section></div>
<summary><section id="impl-Iterator-for-EscapeDefault-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/char/mod.rs.html#240">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for std::char::EscapeDefault</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-4" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/char/mod.rs.html#241">Source</a><pre class="code-header" data-language="rust">type Item = char</pre></section></div>
<summary><section id="impl-Iterator-for-EscapeUnicode" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/char/mod.rs.html#164">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for std::char::EscapeUnicode</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-5" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/char/mod.rs.html#165">Source</a><pre class="code-header" data-language="rust">type Item = char</pre></section></div>
<summary><section id="impl-Iterator-for-ToLowercase" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/char/mod.rs.html#480-488">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for ToLowercase</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-6" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/char/mod.rs.html#480-488">Source</a><pre class="code-header" data-language="rust">type Item = char</pre></section></div>
<summary><section id="impl-Iterator-for-ToUppercase" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/char/mod.rs.html#490-498">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for ToUppercase</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-7" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/char/mod.rs.html#490-498">Source</a><pre class="code-header" data-language="rust">type Item = char</pre></section></div>
<summary><section id="impl-Iterator-for-Args" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/env.rs.html#868-876">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for Args</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-8" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/env.rs.html#869">Source</a><pre class="code-header" data-language="rust">type Item = String</pre></section></div>
<summary><section id="impl-Iterator-for-ArgsOs" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/env.rs.html#910-918">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for ArgsOs</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-9" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/env.rs.html#911">Source</a><pre class="code-header" data-language="rust">type Item = OsString</pre></section></div>
<summary><section id="impl-Iterator-for-Vars" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/env.rs.html#160-168">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for Vars</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-10" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/env.rs.html#161">Source</a><pre class="code-header" data-language="rust">type Item = (String, String)</pre></section></div>
<summary><section id="impl-Iterator-for-VarsOs" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/env.rs.html#179-187">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for VarsOs</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-11" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/env.rs.html#180">Source</a><pre class="code-header" data-language="rust">type Item = (OsString, OsString)</pre></section></div>
<summary><section id="impl-Iterator-for-ReadDir" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/fs.rs.html#2119-2125">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for ReadDir</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-12" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/fs.rs.html#2120">Source</a><pre class="code-header" data-language="rust">type Item = Result&lt;DirEntry, Error&gt;</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIncoming" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#1042-1047">Source</a><pre class="code-header" data-language="rust">impl Iterator for IntoIncoming</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-13" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#1043">Source</a><pre class="code-header" data-language="rust">type Item = Result&lt;TcpStream, Error&gt;</pre></section></div>
<summary><section id="impl-Iterator-for-Bytes%3C'_%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#290">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for std::str::Bytes&lt;'_&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-14" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#291">Source</a><pre class="code-header" data-language="rust">type Item = u8</pre></section></div>
<summary><section id="impl-Iterator-for-Drain%3C'_%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#3171">Source</a></span><pre class="code-header" data-language="rust">impl Iterator for std::string::Drain&lt;'_&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-15" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#3172">Source</a><pre class="code-header" data-language="rust">type Item = char</pre></section></div>
<summary><section id="impl-Iterator-for-Source%3C'a%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/error.rs.html#1002">Source</a><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for Source&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-16" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/error.rs.html#1003">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a (dyn Error + 'static)</pre></section></div>
<summary><section id="impl-Iterator-for-SplitPaths%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/env.rs.html#485-493">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for SplitPaths&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-17" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/env.rs.html#486">Source</a><pre class="code-header" data-language="rust">type Item = PathBuf</pre></section></div>
<summary><section id="impl-Iterator-for-Incoming%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#1031-1036">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for std::net::Incoming&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-18" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#1032">Source</a><pre class="code-header" data-language="rust">type Item = Result&lt;TcpStream, Error&gt;</pre></section></div>
<summary><section id="impl-Iterator-for-Incoming%3C'a%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span><a class="src" href="https://doc.rust-lang.org/src/std/os/unix/net/listener.rs.html#408-418">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for std::os::unix::net::Incoming&lt;'a&gt;Available on Unix only.</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-19" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/unix/net/listener.rs.html#409">Source</a><pre class="code-header" data-language="rust">type Item = Result&lt;UnixStream, Error&gt;</pre></section></div>
<summary><section id="impl-Iterator-for-Messages%3C'a%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/unix/net/ancillary.rs.html#537-568">Source</a><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for Messages&lt;'a&gt;Available on (Android or Linux) and Unix only.</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-20" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/unix/net/ancillary.rs.html#538">Source</a><pre class="code-header" data-language="rust">type Item = Result&lt;AncillaryData&lt;'a&gt;, AncillaryError&gt;</pre></section></div>
<summary><section id="impl-Iterator-for-ScmCredentials%3C'a%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/unix/net/ancillary.rs.html#438-444">Source</a><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for ScmCredentials&lt;'a&gt;Available on (Android or Linux) and Unix only.</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-21" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/unix/net/ancillary.rs.html#439">Source</a><pre class="code-header" data-language="rust">type Item = SocketCred</pre></section></div>
<summary><section id="impl-Iterator-for-ScmRights%3C'a%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/unix/net/ancillary.rs.html#397-403">Source</a><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for ScmRights&lt;'a&gt;Available on (Android or Linux) and Unix only.</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-22" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/os/unix/net/ancillary.rs.html#398">Source</a><pre class="code-header" data-language="rust">type Item = i32</pre></section></div>
<summary><section id="impl-Iterator-for-EncodeWide%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/sys_common/wtf8.rs.html#993-1023">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for EncodeWide&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-23" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sys_common/wtf8.rs.html#994">Source</a><pre class="code-header" data-language="rust">type Item = u16</pre></section></div>
<summary><section id="impl-Iterator-for-Ancestors%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1091-1100">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for Ancestors&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-24" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1092">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a Path</pre></section></div>
<summary><section id="impl-Iterator-for-Components%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#885-935">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for Components&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-25" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#886">Source</a><pre class="code-header" data-language="rust">type Item = Component&lt;'a&gt;</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#864-871">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for std::path::Iter&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-26" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#865">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a OsStr</pre></section></div>
<summary><section id="impl-Iterator-for-CommandArgs%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.57.0">1.57.0</span><a class="src" href="https://doc.rust-lang.org/src/std/process.rs.html#1237-1245">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for CommandArgs&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-27" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/process.rs.html#1238">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a OsStr</pre></section></div>
<summary><section id="impl-Iterator-for-CommandEnvs%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.57.0">1.57.0</span><a class="src" href="https://doc.rust-lang.org/src/std/sys_common/process.rs.html#108-116">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for CommandEnvs&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-28" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sys_common/process.rs.html#109">Source</a><pre class="code-header" data-language="rust">type Item = (&amp;'a OsStr, Option&lt;&amp;'a OsStr&gt;)</pre></section></div>
<summary><section id="impl-Iterator-for-EscapeAscii%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.60.0">1.60.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/ascii.rs.html#242">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for EscapeAscii&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-29" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/ascii.rs.html#243">Source</a><pre class="code-header" data-language="rust">type Item = u8</pre></section></div>
<summary><section id="impl-Iterator-for-CharIndices%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#181">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for CharIndices&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-30" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#182">Source</a><pre class="code-header" data-language="rust">type Item = (usize, char)</pre></section></div>
<summary><section id="impl-Iterator-for-Chars%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#35">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for Chars&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-31" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#36">Source</a><pre class="code-header" data-language="rust">type Item = char</pre></section></div>
<summary><section id="impl-Iterator-for-EncodeUtf16%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1502">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for EncodeUtf16&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-32" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1503">Source</a><pre class="code-header" data-language="rust">type Item = u16</pre></section></div>
<summary><section id="impl-Iterator-for-EscapeDebug%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1610">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for std::str::EscapeDebug&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-33" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1610">Source</a><pre class="code-header" data-language="rust">type Item = char</pre></section></div>
<summary><section id="impl-Iterator-for-EscapeDefault%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1610">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for std::str::EscapeDefault&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-34" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1610">Source</a><pre class="code-header" data-language="rust">type Item = char</pre></section></div>
<summary><section id="impl-Iterator-for-EscapeUnicode%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1610">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for std::str::EscapeUnicode&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-35" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1610">Source</a><pre class="code-header" data-language="rust">type Item = char</pre></section></div>
<summary><section id="impl-Iterator-for-Lines%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1168">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for std::str::Lines&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-36" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1169">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-LinesAny%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1235">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for LinesAny&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-37" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1236">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-SplitAsciiWhitespace%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1358">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for SplitAsciiWhitespace&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-38" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1359">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-SplitWhitespace%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1302">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for SplitWhitespace&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-39" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1303">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-Utf8Chunks%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.79.0">1.79.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/lossy.rs.html#192">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Iterator for Utf8Chunks&lt;'a&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-40" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/lossy.rs.html#193">Source</a><pre class="code-header" data-language="rust">type Item = Utf8Chunk&lt;'a&gt;</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/option.rs.html#2279">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, A&gt; Iterator for std::option::Iter&lt;'a, A&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-41" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/option.rs.html#2280">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a A</pre></section></div>
<summary><section id="impl-Iterator-for-IterMut%3C'a,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/option.rs.html#2329">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, A&gt; Iterator for std::option::IterMut&lt;'a, A&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-42" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/option.rs.html#2330">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut A</pre></section></div>
<section id="impl-Iterator-for-%26Box%3C%5BI%5D,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#103">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, I, A&gt; !Iterator for &amp;'a Box&lt;[I], A&gt;where
    A: Allocator,This implementation is required to make sure that the &amp;Box&lt;[I]&gt;: IntoIterator
implementation doesn’t overlap with IntoIterator for T where T: Iterator blanket.
</pre></section><section id="impl-Iterator-for-%26mut+Box%3C%5BI%5D,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#108">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, I, A&gt; !Iterator for &amp;'a mut Box&lt;[I], A&gt;where
    A: Allocator,This implementation is required to make sure that the &amp;mut Box&lt;[I]&gt;: IntoIterator
implementation doesn’t overlap with IntoIterator for T where T: Iterator blanket.
</pre></section><summary><section id="impl-Iterator-for-Cloned%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/cloned.rs.html#33-36">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, I, T&gt; Iterator for Cloned&lt;I&gt;where
    T: 'a + Clone,
    I: Iterator&lt;Item = &amp;'a T&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-43" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/cloned.rs.html#38">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-Copied%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/copied.rs.html#38-41">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, I, T&gt; Iterator for Copied&lt;I&gt;where
    T: 'a + Copy,
    I: Iterator&lt;Item = &amp;'a T&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-44" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/copied.rs.html#43">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-Drain%3C'a,+K%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1645-1664">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K&gt; Iterator for std::collections::hash_set::Drain&lt;'a, K&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-45" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1646">Source</a><pre class="code-header" data-language="rust">type Item = K</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+K%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1561-1584">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K&gt; Iterator for std::collections::hash_set::Iter&lt;'a, K&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-46" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1562">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a K</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+K,+V%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1534">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::btree_map::Iter&lt;'a, K, V&gt;where
    K: 'a,
    V: 'a,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-47" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1535">Source</a><pre class="code-header" data-language="rust">type Item = (&amp;'a K, &amp;'a V)</pre></section></div>
<summary><section id="impl-Iterator-for-IterMut%3C'a,+K,+V%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1609">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::btree_map::IterMut&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-48" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1610">Source</a><pre class="code-header" data-language="rust">type Item = (&amp;'a K, &amp;'a mut V)</pre></section></div>
<summary><section id="impl-Iterator-for-Keys%3C'a,+K,+V%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1788">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::btree_map::Keys&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-49" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1789">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a K</pre></section></div>
<summary><section id="impl-Iterator-for-Range%3C'a,+K,+V%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#2018">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::btree_map::Range&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-50" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#2019">Source</a><pre class="code-header" data-language="rust">type Item = (&amp;'a K, &amp;'a V)</pre></section></div>
<summary><section id="impl-Iterator-for-RangeMut%3C'a,+K,+V%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#2254">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for RangeMut&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-51" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#2255">Source</a><pre class="code-header" data-language="rust">type Item = (&amp;'a K, &amp;'a mut V)</pre></section></div>
<summary><section id="impl-Iterator-for-Values%3C'a,+K,+V%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1857">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::btree_map::Values&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-52" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1858">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a V</pre></section></div>
<summary><section id="impl-Iterator-for-ValuesMut%3C'a,+K,+V%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#2073">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::btree_map::ValuesMut&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-53" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#2074">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut V</pre></section></div>
<summary><section id="impl-Iterator-for-Drain%3C'a,+K,+V%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2709-2728">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::hash_map::Drain&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-54" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2710">Source</a><pre class="code-header" data-language="rust">type Item = (K, V)</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+K,+V%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2389-2412">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::hash_map::Iter&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-55" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2390">Source</a><pre class="code-header" data-language="rust">type Item = (&amp;'a K, &amp;'a V)</pre></section></div>
<summary><section id="impl-Iterator-for-IterMut%3C'a,+K,+V%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2425-2448">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::hash_map::IterMut&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-56" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2426">Source</a><pre class="code-header" data-language="rust">type Item = (&amp;'a K, &amp;'a mut V)</pre></section></div>
<summary><section id="impl-Iterator-for-Keys%3C'a,+K,+V%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2513-2536">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::hash_map::Keys&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-57" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2514">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a K</pre></section></div>
<summary><section id="impl-Iterator-for-Values%3C'a,+K,+V%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2548-2571">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::hash_map::Values&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-58" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2549">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a V</pre></section></div>
<summary><section id="impl-Iterator-for-ValuesMut%3C'a,+K,+V%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2583-2606">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, K, V&gt; Iterator for std::collections::hash_map::ValuesMut&lt;'a, K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-59" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2584">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut V</pre></section></div>
<summary><section id="impl-Iterator-for-MatchIndices%3C'a,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1081-1097">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, P&gt; Iterator for MatchIndices&lt;'a, P&gt;where
    P: Pattern,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-60" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1081-1097">Source</a><pre class="code-header" data-language="rust">type Item = (usize, &amp;'a str)</pre></section></div>
<summary><section id="impl-Iterator-for-Matches%3C'a,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1138-1154">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, P&gt; Iterator for Matches&lt;'a, P&gt;where
    P: Pattern,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-61" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1138-1154">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-RMatchIndices%3C'a,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1081-1097">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, P&gt; Iterator for RMatchIndices&lt;'a, P&gt;where
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-62" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1081-1097">Source</a><pre class="code-header" data-language="rust">type Item = (usize, &amp;'a str)</pre></section></div>
<summary><section id="impl-Iterator-for-RMatches%3C'a,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1138-1154">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, P&gt; Iterator for RMatches&lt;'a, P&gt;where
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-63" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1138-1154">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-RSplit%3C'a,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#789-805">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, P&gt; Iterator for std::str::RSplit&lt;'a, P&gt;where
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-64" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#789-805">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-RSplitN%3C'a,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#980-996">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, P&gt; Iterator for std::str::RSplitN&lt;'a, P&gt;where
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-65" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#980-996">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-RSplitTerminator%3C'a,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#853-869">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, P&gt; Iterator for RSplitTerminator&lt;'a, P&gt;where
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-66" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#853-869">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-Split%3C'a,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#789-805">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, P&gt; Iterator for std::str::Split&lt;'a, P&gt;where
    P: Pattern,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-67" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#789-805">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-SplitInclusive%3C'a,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1421">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, P&gt; Iterator for std::str::SplitInclusive&lt;'a, P&gt;where
    P: Pattern,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-68" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#1422">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-SplitN%3C'a,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#980-996">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, P&gt; Iterator for std::str::SplitN&lt;'a, P&gt;where
    P: Pattern,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-69" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#980-996">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-SplitTerminator%3C'a,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#853-869">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, P&gt; Iterator for SplitTerminator&lt;'a, P&gt;where
    P: Pattern,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-70" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/iter.rs.html#853-869">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a str</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1465">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::collections::binary_heap::Iter&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-71" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1466">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+T%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1750">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::collections::btree_set::Iter&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-72" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1751">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-Range%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1863">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::collections::btree_set::Range&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-73" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1864">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-SymmetricDifference%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1987">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::collections::btree_set::SymmetricDifference&lt;'a, T&gt;where
    T: Ord,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-74" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1988">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-Union%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#2082">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::collections::btree_set::Union&lt;'a, T&gt;where
    T: Ord,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-75" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#2083">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+T%3E-2" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/linked_list.rs.html#1189">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::collections::linked_list::Iter&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-76" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/linked_list.rs.html#1190">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-IterMut%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/linked_list.rs.html#1257">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::collections::linked_list::IterMut&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-77" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/linked_list.rs.html#1258">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut T</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+T%3E-3" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/iter.rs.html#88">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::collections::vec_deque::Iter&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-78" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/iter.rs.html#89">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-IterMut%3C'a,+T%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/iter_mut.rs.html#153">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::collections::vec_deque::IterMut&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-79" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/iter_mut.rs.html#154">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut T</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+T%3E-4" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/result.rs.html#1809">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::result::Iter&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-80" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/result.rs.html#1810">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-IterMut%3C'a,+T%3E-2" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/result.rs.html#1858">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::result::IterMut&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-81" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/result.rs.html#1859">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut T</pre></section></div>
<summary><section id="impl-Iterator-for-Chunks%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1506">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for Chunks&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-82" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1507">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T]</pre></section></div>
<summary><section id="impl-Iterator-for-ChunksExact%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1909">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for ChunksExact&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-83" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1910">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T]</pre></section></div>
<summary><section id="impl-Iterator-for-ChunksExactMut%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2067">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for ChunksExactMut&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-84" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2068">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut [T]</pre></section></div>
<summary><section id="impl-Iterator-for-ChunksMut%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1688">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for ChunksMut&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-85" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1689">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut [T]</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+T%3E-5" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#146-154">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::slice::Iter&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-86" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#146-154">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-IterMut%3C'a,+T%3E-3" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#373">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::slice::IterMut&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-87" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#373">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut T</pre></section></div>
<summary><section id="impl-Iterator-for-RChunks%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2598">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for RChunks&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-88" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2599">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T]</pre></section></div>
<summary><section id="impl-Iterator-for-RChunksExact%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2995">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for RChunksExact&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-89" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2996">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T]</pre></section></div>
<summary><section id="impl-Iterator-for-RChunksExactMut%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#3155">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for RChunksExactMut&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-90" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#3156">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut [T]</pre></section></div>
<summary><section id="impl-Iterator-for-RChunksMut%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2770">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for RChunksMut&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-91" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2771">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut [T]</pre></section></div>
<summary><section id="impl-Iterator-for-Windows%3C'a,+T%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1354">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for Windows&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-92" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1355">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T]</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+T%3E-6" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/mpmc/mod.rs.html#810-816">Source</a><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::sync::mpmc::Iter&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-93" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/mpmc/mod.rs.html#811">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-TryIter%3C'a,+T%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/mpmc/mod.rs.html#819-825">Source</a><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::sync::mpmc::TryIter&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-94" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/mpmc/mod.rs.html#820">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-Iter%3C'a,+T%3E-7" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/sync/mpsc/mod.rs.html#1045-1051">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::sync::mpsc::Iter&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-95" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/mpsc/mod.rs.html#1046">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-TryIter%3C'a,+T%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.15.0">1.15.0</span><a class="src" href="https://doc.rust-lang.org/src/std/sync/mpsc/mod.rs.html#1054-1060">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T&gt; Iterator for std::sync::mpsc::TryIter&lt;'a, T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-96" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/mpsc/mod.rs.html#1055">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-Difference%3C'a,+T,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1931">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, A&gt; Iterator for std::collections::btree_set::Difference&lt;'a, T, A&gt;where
    T: Ord,
    A: Allocator + Clone,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-97" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1932">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-Intersection%3C'a,+T,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#2032">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, A&gt; Iterator for std::collections::btree_set::Intersection&lt;'a, T, A&gt;where
    T: Ord,
    A: Allocator + Clone,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-98" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#2033">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-ExtractIf%3C'_,+T,+F,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1581-1583">Source</a><pre class="code-header" data-language="rust">impl&lt;'a, T, F, A&gt; Iterator for std::collections::btree_set::ExtractIf&lt;'_, T, F, A&gt;where
    A: Allocator + Clone,
    F: 'a + FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-99" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1585">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-ChunkBy%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.77.0">1.77.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#3319-3321">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for ChunkBy&lt;'a, T, P&gt;where
    T: 'a,
    P: FnMut(&amp;T, &amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-100" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#3323">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T]</pre></section></div>
<summary><section id="impl-Iterator-for-ChunkByMut%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.77.0">1.77.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#3406-3408">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for ChunkByMut&lt;'a, T, P&gt;where
    T: 'a,
    P: FnMut(&amp;T, &amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-101" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#3410">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut [T]</pre></section></div>
<summary><section id="impl-Iterator-for-RSplit%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#975-977">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for std::slice::RSplit&lt;'a, T, P&gt;where
    P: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-102" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#979">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T]</pre></section></div>
<summary><section id="impl-Iterator-for-RSplitMut%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1072-1074">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for RSplitMut&lt;'a, T, P&gt;where
    P: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-103" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1076">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut [T]</pre></section></div>
<summary><section id="impl-Iterator-for-RSplitN%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1309">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for std::slice::RSplitN&lt;'a, T, P&gt;where
    P: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-104" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1309">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T]</pre></section></div>
<summary><section id="impl-Iterator-for-RSplitNMut%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1311">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for RSplitNMut&lt;'a, T, P&gt;where
    P: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-105" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1311">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut [T]</pre></section></div>
<summary><section id="impl-Iterator-for-Split%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#457-459">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for std::slice::Split&lt;'a, T, P&gt;where
    P: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-106" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#461">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T]</pre></section></div>
<summary><section id="impl-Iterator-for-SplitInclusive%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#601-603">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for std::slice::SplitInclusive&lt;'a, T, P&gt;where
    P: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-107" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#605">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T]</pre></section></div>
<summary><section id="impl-Iterator-for-SplitInclusiveMut%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#840-842">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for SplitInclusiveMut&lt;'a, T, P&gt;where
    P: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-108" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#844">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut [T]</pre></section></div>
<summary><section id="impl-Iterator-for-SplitMut%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#722-724">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for SplitMut&lt;'a, T, P&gt;where
    P: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-109" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#726">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut [T]</pre></section></div>
<summary><section id="impl-Iterator-for-SplitN%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1308">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for std::slice::SplitN&lt;'a, T, P&gt;where
    P: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-110" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1308">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T]</pre></section></div>
<summary><section id="impl-Iterator-for-SplitNMut%3C'a,+T,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1310">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, P&gt; Iterator for SplitNMut&lt;'a, T, P&gt;where
    P: FnMut(&amp;T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-111" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#1310">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut [T]</pre></section></div>
<summary><section id="impl-Iterator-for-Difference%3C'a,+T,+S%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1782-1813">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, S&gt; Iterator for std::collections::hash_set::Difference&lt;'a, T, S&gt;where
    T: Eq + Hash,
    S: BuildHasher,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-112" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1787">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-Intersection%3C'a,+T,+S%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1721-1752">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, S&gt; Iterator for std::collections::hash_set::Intersection&lt;'a, T, S&gt;where
    T: Eq + Hash,
    S: BuildHasher,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-113" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1726">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-SymmetricDifference%3C'a,+T,+S%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1843-1866">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, S&gt; Iterator for std::collections::hash_set::SymmetricDifference&lt;'a, T, S&gt;where
    T: Eq + Hash,
    S: BuildHasher,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-114" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1848">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-Union%3C'a,+T,+S%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1915-1942">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, T, S&gt; Iterator for std::collections::hash_set::Union&lt;'a, T, S&gt;where
    T: Eq + Hash,
    S: BuildHasher,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-115" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1920">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a T</pre></section></div>
<summary><section id="impl-Iterator-for-ArrayChunks%3C'a,+T,+N%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2364">Source</a><pre class="code-header" data-language="rust">impl&lt;'a, T, const N: usize&gt; Iterator for std::slice::ArrayChunks&lt;'a, T, N&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-116" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2365">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T; N]</pre></section></div>
<summary><section id="impl-Iterator-for-ArrayChunksMut%3C'a,+T,+N%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2482">Source</a><pre class="code-header" data-language="rust">impl&lt;'a, T, const N: usize&gt; Iterator for ArrayChunksMut&lt;'a, T, N&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-117" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2483">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a mut [T; N]</pre></section></div>
<summary><section id="impl-Iterator-for-ArrayWindows%3C'a,+T,+N%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2222">Source</a><pre class="code-header" data-language="rust">impl&lt;'a, T, const N: usize&gt; Iterator for ArrayWindows&lt;'a, T, N&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-118" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#2223">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a [T; N]</pre></section></div>
<summary><section id="impl-Iterator-for-IterRange%3CA%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/range/iter.rs.html#52">Source</a><pre class="code-header" data-language="rust">impl&lt;A&gt; Iterator for IterRange&lt;A&gt;where
    A: Step,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-119" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/range/iter.rs.html#53">Source</a><pre class="code-header" data-language="rust">type Item = A</pre></section></div>
<summary><section id="impl-Iterator-for-IterRangeFrom%3CA%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/range/iter.rs.html#306">Source</a><pre class="code-header" data-language="rust">impl&lt;A&gt; Iterator for IterRangeFrom&lt;A&gt;where
    A: Step,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-120" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/range/iter.rs.html#307">Source</a><pre class="code-header" data-language="rust">type Item = A</pre></section></div>
<summary><section id="impl-Iterator-for-IterRangeInclusive%3CA%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/range/iter.rs.html#172">Source</a><pre class="code-header" data-language="rust">impl&lt;A&gt; Iterator for IterRangeInclusive&lt;A&gt;where
    A: Step,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-121" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/range/iter.rs.html#173">Source</a><pre class="code-header" data-language="rust">type Item = A</pre></section></div>
<summary><section id="impl-Iterator-for-Range%3CA%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/range.rs.html#844">Source</a></span><pre class="code-header" data-language="rust">impl&lt;A&gt; Iterator for std::ops::Range&lt;A&gt;where
    A: Step,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-122" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/range.rs.html#845">Source</a><pre class="code-header" data-language="rust">type Item = A</pre></section></div>
<summary><section id="impl-Iterator-for-RangeFrom%3CA%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/range.rs.html#1011">Source</a></span><pre class="code-header" data-language="rust">impl&lt;A&gt; Iterator for RangeFrom&lt;A&gt;where
    A: Step,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-123" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/range.rs.html#1012">Source</a><pre class="code-header" data-language="rust">type Item = A</pre></section></div>
<summary><section id="impl-Iterator-for-RangeInclusive%3CA%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/range.rs.html#1247">Source</a></span><pre class="code-header" data-language="rust">impl&lt;A&gt; Iterator for RangeInclusive&lt;A&gt;where
    A: Step,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-124" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/range.rs.html#1248">Source</a><pre class="code-header" data-language="rust">type Item = A</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CA%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/option.rs.html#2370">Source</a></span><pre class="code-header" data-language="rust">impl&lt;A&gt; Iterator for std::option::IntoIter&lt;A&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-125" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/option.rs.html#2371">Source</a><pre class="code-header" data-language="rust">type Item = A</pre></section></div>
<summary><section id="impl-Iterator-for-Repeat%3CA%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/sources/repeat.rs.html#74">Source</a></span><pre class="code-header" data-language="rust">impl&lt;A&gt; Iterator for Repeat&lt;A&gt;where
    A: Clone,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-126" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/sources/repeat.rs.html#75">Source</a><pre class="code-header" data-language="rust">type Item = A</pre></section></div>
<summary><section id="impl-Iterator-for-RepeatN%3CA%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.82.0">1.82.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/sources/repeat_n.rs.html#136">Source</a></span><pre class="code-header" data-language="rust">impl&lt;A&gt; Iterator for RepeatN&lt;A&gt;where
    A: Clone,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-127" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/sources/repeat_n.rs.html#137">Source</a><pre class="code-header" data-language="rust">type Item = A</pre></section></div>
<summary><section id="impl-Iterator-for-Chain%3CA,+B%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/chain.rs.html#75-78">Source</a></span><pre class="code-header" data-language="rust">impl&lt;A, B&gt; Iterator for Chain&lt;A, B&gt;where
    A: Iterator,
    B: Iterator&lt;Item = &lt;A as Iterator&gt;::Item&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-128" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/chain.rs.html#80">Source</a><pre class="code-header" data-language="rust">type Item = &lt;A as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Zip%3CA,+B%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/zip.rs.html#77-80">Source</a></span><pre class="code-header" data-language="rust">impl&lt;A, B&gt; Iterator for Zip&lt;A, B&gt;where
    A: Iterator,
    B: Iterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-129" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/zip.rs.html#82">Source</a><pre class="code-header" data-language="rust">type Item = (&lt;A as Iterator&gt;::Item, &lt;B as Iterator&gt;::Item)</pre></section></div>
<summary><section id="impl-Iterator-for-OnceWith%3CF%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/sources/once_with.rs.html#88">Source</a></span><pre class="code-header" data-language="rust">impl&lt;A, F&gt; Iterator for OnceWith&lt;F&gt;where
    F: FnOnce() -&gt; A,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-130" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/sources/once_with.rs.html#89">Source</a><pre class="code-header" data-language="rust">type Item = A</pre></section></div>
<summary><section id="impl-Iterator-for-RepeatWith%3CF%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/sources/repeat_with.rs.html#88">Source</a></span><pre class="code-header" data-language="rust">impl&lt;A, F&gt; Iterator for RepeatWith&lt;F&gt;where
    F: FnMut() -&gt; A,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-131" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/sources/repeat_with.rs.html#89">Source</a><pre class="code-header" data-language="rust">type Item = A</pre></section></div>
<summary><section id="impl-Iterator-for-FilterMap%3CI,+F%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/filter_map.rs.html#56-58">Source</a></span><pre class="code-header" data-language="rust">impl&lt;B, I, F&gt; Iterator for FilterMap&lt;I, F&gt;where
    I: Iterator,
    F: FnMut(&lt;I as Iterator&gt;::Item) -&gt; Option&lt;B&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-132" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/filter_map.rs.html#60">Source</a><pre class="code-header" data-language="rust">type Item = B</pre></section></div>
<summary><section id="impl-Iterator-for-Map%3CI,+F%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/map.rs.html#99-101">Source</a></span><pre class="code-header" data-language="rust">impl&lt;B, I, F&gt; Iterator for Map&lt;I, F&gt;where
    I: Iterator,
    F: FnMut(&lt;I as Iterator&gt;::Item) -&gt; B,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-133" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/map.rs.html#103">Source</a><pre class="code-header" data-language="rust">type Item = B</pre></section></div>
<summary><section id="impl-Iterator-for-MapWhile%3CI,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.57.0">1.57.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/map_while.rs.html#36-38">Source</a></span><pre class="code-header" data-language="rust">impl&lt;B, I, P&gt; Iterator for MapWhile&lt;I, P&gt;where
    I: Iterator,
    P: FnMut(&lt;I as Iterator&gt;::Item) -&gt; Option&lt;B&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-134" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/map_while.rs.html#40">Source</a><pre class="code-header" data-language="rust">type Item = B</pre></section></div>
<summary><section id="impl-Iterator-for-Scan%3CI,+St,+F%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/scan.rs.html#37-40">Source</a></span><pre class="code-header" data-language="rust">impl&lt;B, I, St, F&gt; Iterator for Scan&lt;I, St, F&gt;where
    I: Iterator,
    F: FnMut(&amp;mut St, &lt;I as Iterator&gt;::Item) -&gt; Option&lt;B&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-135" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/scan.rs.html#42">Source</a><pre class="code-header" data-language="rust">type Item = B</pre></section></div>
<summary><section id="impl-Iterator-for-Lines%3CB%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#3233-3252">Source</a></span><pre class="code-header" data-language="rust">impl&lt;B: BufRead&gt; Iterator for std::io::Lines&lt;B&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-136" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#3234">Source</a><pre class="code-header" data-language="rust">type Item = Result&lt;String, Error&gt;</pre></section></div>
<summary><section id="impl-Iterator-for-Split%3CB%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#3201-3217">Source</a></span><pre class="code-header" data-language="rust">impl&lt;B: BufRead&gt; Iterator for std::io::Split&lt;B&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-137" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#3202">Source</a><pre class="code-header" data-language="rust">type Item = Result&lt;Vec&lt;u8&gt;, Error&gt;</pre></section></div>
<summary><section id="impl-Iterator-for-%26mut+I" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#4023">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for &amp;mut Iwhere
    I: Iterator + ?Sized,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-138" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#4024">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-DecodeUtf16%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a class="src" href="https://doc.rust-lang.org/src/core/char/decode.rs.html#40">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for DecodeUtf16&lt;I&gt;where
    I: Iterator&lt;Item = u16&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-139" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/char/decode.rs.html#41">Source</a><pre class="code-header" data-language="rust">type Item = Result&lt;char, DecodeUtf16Error&gt;</pre></section></div>
<summary><section id="impl-Iterator-for-ByRefSized%3C'_,+I%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/by_ref_sized.rs.html#16">Source</a><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for ByRefSized&lt;'_, I&gt;where
    I: Iterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-140" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/by_ref_sized.rs.html#17">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Cycle%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/cycle.rs.html#27-29">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for Cycle&lt;I&gt;where
    I: Clone + Iterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-141" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/cycle.rs.html#31">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Enumerate%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/enumerate.rs.html#29-31">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for Enumerate&lt;I&gt;where
    I: Iterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-142" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/enumerate.rs.html#33">Source</a><pre class="code-header" data-language="rust">type Item = (usize, &lt;I as Iterator&gt;::Item)</pre></section></div>
<summary><section id="impl-Iterator-for-Fuse%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/fuse.rs.html#42-44">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for Fuse&lt;I&gt;where
    I: Iterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-143" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/fuse.rs.html#46">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Intersperse%3CI%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/intersperse.rs.html#38-41">Source</a><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for Intersperse&lt;I&gt;where
    I: Iterator,
    &lt;I as Iterator&gt;::Item: Clone,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-144" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/intersperse.rs.html#43">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Peekable%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/peekable.rs.html#34">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for Peekable&lt;I&gt;where
    I: Iterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-145" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/peekable.rs.html#35">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Rev%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/rev.rs.html#26-28">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for Rev&lt;I&gt;where
    I: DoubleEndedIterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-146" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/rev.rs.html#30">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Skip%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/skip.rs.html#33-35">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for Skip&lt;I&gt;where
    I: Iterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-147" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/skip.rs.html#37">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-StepBy%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/step_by.rs.html#51-53">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for StepBy&lt;I&gt;where
    I: Iterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-148" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/step_by.rs.html#55">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Take%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/take.rs.html#29-31">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; Iterator for Take&lt;I&gt;where
    I: Iterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-149" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/take.rs.html#33">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<section id="impl-Iterator-for-Box%3C%5BI%5D,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#98">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I, A&gt; !Iterator for Box&lt;[I], A&gt;where
    A: Allocator,This implementation is required to make sure that the Box&lt;[I]&gt;: IntoIterator
implementation doesn’t overlap with IntoIterator for T where T: Iterator blanket.
</pre></section><summary><section id="impl-Iterator-for-Box%3CI,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#18">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I, A&gt; Iterator for Box&lt;I, A&gt;where
    I: Iterator + ?Sized,
    A: Allocator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-150" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#19">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Splice%3C'_,+I,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/vec/splice.rs.html#31">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I, A&gt; Iterator for Splice&lt;'_, I, A&gt;where
    I: Iterator,
    A: Allocator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-151" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/vec/splice.rs.html#32">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Inspect%3CI,+F%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/inspect.rs.html#70-72">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I, F&gt; Iterator for Inspect&lt;I, F&gt;where
    I: Iterator,
    F: FnMut(&amp;&lt;I as Iterator&gt;::Item),</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-152" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/inspect.rs.html#74">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-MapWindows%3CI,+F,+N%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/map_windows.rs.html#238-241">Source</a><pre class="code-header" data-language="rust">impl&lt;I, F, R, const N: usize&gt; Iterator for MapWindows&lt;I, F, N&gt;where
    I: Iterator,
    F: FnMut(&amp;[&lt;I as Iterator&gt;::Item; N]) -&gt; R,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-153" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/map_windows.rs.html#243">Source</a><pre class="code-header" data-language="rust">type Item = R</pre></section></div>
<summary><section id="impl-Iterator-for-IntersperseWith%3CI,+G%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/intersperse.rs.html#154-157">Source</a><pre class="code-header" data-language="rust">impl&lt;I, G&gt; Iterator for IntersperseWith&lt;I, G&gt;where
    I: Iterator,
    G: FnMut() -&gt; &lt;I as Iterator&gt;::Item,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-154" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/intersperse.rs.html#159">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Filter%3CI,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/filter.rs.html#90-92">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I, P&gt; Iterator for Filter&lt;I, P&gt;where
    I: Iterator,
    P: FnMut(&amp;&lt;I as Iterator&gt;::Item) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-155" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/filter.rs.html#94">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-SkipWhile%3CI,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/skip_while.rs.html#37-39">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I, P&gt; Iterator for SkipWhile&lt;I, P&gt;where
    I: Iterator,
    P: FnMut(&amp;&lt;I as Iterator&gt;::Item) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-156" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/skip_while.rs.html#41">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-TakeWhile%3CI,+P%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/take_while.rs.html#37-39">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I, P&gt; Iterator for TakeWhile&lt;I, P&gt;where
    I: Iterator,
    P: FnMut(&amp;&lt;I as Iterator&gt;::Item) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-157" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/take_while.rs.html#41">Source</a><pre class="code-header" data-language="rust">type Item = &lt;I as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-Flatten%3CI%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/flatten.rs.html#272-275">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I, U&gt; Iterator for Flatten&lt;I&gt;where
    I: Iterator,
    &lt;I as Iterator&gt;::Item: IntoIterator&lt;IntoIter = U, Item = &lt;U as Iterator&gt;::Item&gt;,
    U: Iterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-158" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/flatten.rs.html#277">Source</a><pre class="code-header" data-language="rust">type Item = &lt;U as Iterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-FlatMap%3CI,+U,+F%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/adapters/flatten.rs.html#56-58">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I, U, F&gt; Iterator for FlatMap&lt;I, U, F&gt;where
    I: Iterator,
    U: IntoIterator,
    F: FnMut(&lt;I as Iterator&gt;::Item) -&gt; U,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-159" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/flatten.rs.html#60">Source</a><pre class="code-header" data-language="rust">type Item = &lt;U as IntoIterator&gt;::Item</pre></section></div>
<summary><section id="impl-Iterator-for-ArrayChunks%3CI,+N%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/array_chunks.rs.html#58-60">Source</a><pre class="code-header" data-language="rust">impl&lt;I, const N: usize&gt; Iterator for std::iter::ArrayChunks&lt;I, N&gt;where
    I: Iterator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-160" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/adapters/array_chunks.rs.html#62">Source</a><pre class="code-header" data-language="rust">type Item = [&lt;I as Iterator&gt;::Item; N]</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CK%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1603-1626">Source</a></span><pre class="code-header" data-language="rust">impl&lt;K&gt; Iterator for std::collections::hash_set::IntoIter&lt;K&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-161" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1604">Source</a><pre class="code-header" data-language="rust">type Item = K</pre></section></div>
<summary><section id="impl-Iterator-for-ExtractIf%3C'_,+K,+F%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1683-1697">Source</a><pre class="code-header" data-language="rust">impl&lt;K, F&gt; Iterator for std::collections::hash_set::ExtractIf&lt;'_, K, F&gt;where
    F: FnMut(&amp;K) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-162" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/set.rs.html#1687">Source</a><pre class="code-header" data-language="rust">type Item = K</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CK,+V%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2471-2494">Source</a></span><pre class="code-header" data-language="rust">impl&lt;K, V&gt; Iterator for std::collections::hash_map::IntoIter&lt;K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-163" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2472">Source</a><pre class="code-header" data-language="rust">type Item = (K, V)</pre></section></div>
<summary><section id="impl-Iterator-for-IntoKeys%3CK,+V%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.54.0">1.54.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2625-2648">Source</a></span><pre class="code-header" data-language="rust">impl&lt;K, V&gt; Iterator for std::collections::hash_map::IntoKeys&lt;K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-164" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2626">Source</a><pre class="code-header" data-language="rust">type Item = K</pre></section></div>
<summary><section id="impl-Iterator-for-IntoValues%3CK,+V%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.54.0">1.54.0</span><a class="src" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2667-2690">Source</a></span><pre class="code-header" data-language="rust">impl&lt;K, V&gt; Iterator for std::collections::hash_map::IntoValues&lt;K, V&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-165" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2668">Source</a><pre class="code-header" data-language="rust">type Item = V</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CK,+V,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1756">Source</a></span><pre class="code-header" data-language="rust">impl&lt;K, V, A&gt; Iterator for std::collections::btree_map::IntoIter&lt;K, V, A&gt;where
    A: Allocator + Clone,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-166" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1757">Source</a><pre class="code-header" data-language="rust">type Item = (K, V)</pre></section></div>
<summary><section id="impl-Iterator-for-IntoKeys%3CK,+V,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.54.0">1.54.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#2121">Source</a></span><pre class="code-header" data-language="rust">impl&lt;K, V, A&gt; Iterator for std::collections::btree_map::IntoKeys&lt;K, V, A&gt;where
    A: Allocator + Clone,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-167" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#2122">Source</a><pre class="code-header" data-language="rust">type Item = K</pre></section></div>
<summary><section id="impl-Iterator-for-IntoValues%3CK,+V,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.54.0">1.54.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#2186">Source</a></span><pre class="code-header" data-language="rust">impl&lt;K, V, A&gt; Iterator for std::collections::btree_map::IntoValues&lt;K, V, A&gt;where
    A: Allocator + Clone,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-168" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#2187">Source</a><pre class="code-header" data-language="rust">type Item = V</pre></section></div>
<summary><section id="impl-Iterator-for-ExtractIf%3C'_,+K,+V,+F%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2751-2765">Source</a><pre class="code-header" data-language="rust">impl&lt;K, V, F&gt; Iterator for std::collections::hash_map::ExtractIf&lt;'_, K, V, F&gt;where
    F: FnMut(&amp;K, &amp;mut V) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-169" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#2755">Source</a><pre class="code-header" data-language="rust">type Item = (K, V)</pre></section></div>
<summary><section id="impl-Iterator-for-ExtractIf%3C'_,+K,+V,+F,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1955-1957">Source</a><pre class="code-header" data-language="rust">impl&lt;K, V, F, A&gt; Iterator for std::collections::btree_map::ExtractIf&lt;'_, K, V, F, A&gt;where
    A: Allocator + Clone,
    F: FnMut(&amp;K, &amp;mut V) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-170" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/map.rs.html#1959">Source</a><pre class="code-header" data-language="rust">type Item = (K, V)</pre></section></div>
<summary><section id="impl-Iterator-for-Bytes%3CR%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#3076-3089">Source</a></span><pre class="code-header" data-language="rust">impl&lt;R: Read&gt; Iterator for std::io::Bytes&lt;R&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-171" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#3077">Source</a><pre class="code-header" data-language="rust">type Item = Result&lt;u8, Error&gt;</pre></section></div>
<section id="impl-Iterator-for-%5BT%5D" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#18">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; !Iterator for [T]</pre></section><summary><section id="impl-Iterator-for-IntoIter%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/result.rs.html#1904">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; Iterator for std::result::IntoIter&lt;T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-172" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/result.rs.html#1905">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CT%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/mpmc/mod.rs.html#838-843">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Iterator for std::sync::mpmc::IntoIter&lt;T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-173" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/mpmc/mod.rs.html#839">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CT%3E-2" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span><a class="src" href="https://doc.rust-lang.org/src/std/sync/mpsc/mod.rs.html#1073-1078">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; Iterator for std::sync::mpsc::IntoIter&lt;T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-174" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/mpsc/mod.rs.html#1074">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-Empty%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/sources/empty.rs.html#40">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; Iterator for Empty&lt;T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-175" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/sources/empty.rs.html#41">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-Once%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/sources/once.rs.html#71">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T&gt; Iterator for Once&lt;T&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-176" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/sources/once.rs.html#72">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-Drain%3C'_,+T,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1679">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Iterator for std::collections::binary_heap::Drain&lt;'_, T, A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-177" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1680">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-DrainSorted%3C'_,+T,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1756">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Iterator for DrainSorted&lt;'_, T, A&gt;where
    T: Ord,
    A: Allocator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-178" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1757">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1533">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Iterator for std::collections::binary_heap::IntoIter&lt;T, A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-179" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1534">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIterSorted%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1630">Source</a><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Iterator for IntoIterSorted&lt;T, A&gt;where
    T: Ord,
    A: Allocator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-180" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1631">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CT,+A%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1796">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Iterator for std::collections::btree_set::IntoIter&lt;T, A&gt;where
    A: Allocator + Clone,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-181" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/btree/set.rs.html#1797">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CT,+A%3E-2" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/linked_list.rs.html#1987">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Iterator for std::collections::linked_list::IntoIter&lt;T, A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-182" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/linked_list.rs.html#1988">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-Drain%3C'_,+T,+A%3E-1" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/drain.rs.html#236">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Iterator for std::collections::vec_deque::Drain&lt;'_, T, A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-183" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/drain.rs.html#237">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CT,+A%3E-3" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/into_iter.rs.html#43">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Iterator for std::collections::vec_deque::IntoIter&lt;T, A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-184" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/vec_deque/into_iter.rs.html#44">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-Drain%3C'_,+T,+A%3E-2" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/vec/drain.rs.html#152">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Iterator for std::vec::Drain&lt;'_, T, A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-185" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/vec/drain.rs.html#153">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CT,+A%3E-4" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/vec/into_iter.rs.html#204">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, A&gt; Iterator for std::vec::IntoIter&lt;T, A&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-186" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/vec/into_iter.rs.html#205">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-FromFn%3CF%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/sources/from_fn.rs.html#61-63">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, F&gt; Iterator for FromFn&lt;F&gt;where
    F: FnMut() -&gt; Option&lt;T&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-187" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/sources/from_fn.rs.html#65">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-Successors%3CT,+F%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/iter/sources/successors.rs.html#40-42">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, F&gt; Iterator for Successors&lt;T, F&gt;where
    F: FnMut(&amp;T) -&gt; Option&lt;T&gt;,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-188" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/sources/successors.rs.html#44">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-ExtractIf%3C'_,+T,+F,+A%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/linked_list.rs.html#1951-1953">Source</a><pre class="code-header" data-language="rust">impl&lt;T, F, A&gt; Iterator for std::collections::linked_list::ExtractIf&lt;'_, T, F, A&gt;where
    A: Allocator,
    F: FnMut(&amp;mut T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-189" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/linked_list.rs.html#1955">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-ExtractIf%3C'_,+T,+F,+A%3E-2" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/vec/extract_if.rs.html#63-65">Source</a><pre class="code-header" data-language="rust">impl&lt;T, F, A&gt; Iterator for std::vec::ExtractIf&lt;'_, T, F, A&gt;where
    A: Allocator,
    F: FnMut(&amp;mut T) -&gt; bool,</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-190" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/vec/extract_if.rs.html#67">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
<summary><section id="impl-Iterator-for-IntoIter%3CT,+N%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0">1.40.0</span><a class="src" href="https://doc.rust-lang.org/src/core/array/iter.rs.html#233">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T, const N: usize&gt; Iterator for std::array::IntoIter&lt;T, N&gt;</pre></section></summary><div class="impl-items"><section id="associatedtype.Item-191" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/array/iter.rs.html#234">Source</a><pre class="code-header" data-language="rust">type Item = T</pre></section></div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html" class="_attribution-link">https://doc.rust-lang.org/std/iter/trait.Iterator.html</a>
  </p>
</div>
