<h1 class="main-heading">Primitive Type str</h1>
<p>String slices.</p> <p><em><a href="str/index.html" title="mod std::str">See also the <code>std::str</code> module</a>.</em></p> <p>The <code>str</code> type, also called a â€˜string sliceâ€™, is the most primitive string type. It is usually seen in its borrowed form, <code>&amp;str</code>. It is also the type of string literals, <code>&amp;'static str</code>.</p> <h2 id="basic-usage">Basic Usage</h2> <p>String literals are string slices:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let hello_world = "Hello, World!";</pre></div> <p>Here we have declared a string slice initialized with a string literal. String literals have a static lifetime, which means the string <code>hello_world</code> is guaranteed to be valid for the duration of the entire program. We can explicitly specify <code>hello_world</code>â€™s lifetime as well:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let hello_world: &amp;'static str = "Hello, world!";</pre></div> <h2 id="representation">Representation</h2> <p>A <code>&amp;str</code> is made up of two components: a pointer to some bytes, and a length. You can look at these with the <a href="primitive.str.html#method.as_ptr" title="method str::as_ptr"><code>as_ptr</code></a> and <a href="primitive.str.html#method.len" title="method str::len"><code>len</code></a> methods:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::slice;
use std::str;

let story = "Once upon a time...";

let ptr = story.as_ptr();
let len = story.len();

// story has nineteen bytes
assert_eq!(19, len);

// We can re-build a str out of ptr and len. This is all unsafe because
// we are responsible for making sure the two components are valid:
let s = unsafe {
    // First, we build a &amp;[u8]...
    let slice = slice::from_raw_parts(ptr, len);

    // ... and then convert that slice into a string slice
    str::from_utf8(slice)
};

assert_eq!(s, Ok(story));</pre></div> <p>Note: This example shows the internals of <code>&amp;str</code>. <code>unsafe</code> should not be used to get a string slice under normal circumstances. Use <code>as_str</code> instead.</p> <h2 id="invariant">Invariant</h2> <p>Rust libraries may assume that string slices are always valid UTF-8.</p> <p>Constructing a non-UTF-8 string slice is not immediate undefined behavior, but any function called on a string slice may assume that it is valid UTF-8, which means that a non-UTF-8 string slice can lead to undefined behavior down the road.</p> <h2 id="implementations" class="small-section-header">Implementations</h2>
<div id="implementations-list">
<summary><section id="impl-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#143">source</a><pre class="code-header" data-language="rust">impl str</pre></section></summary><div class="impl-items">
<summary><section id="method.len" class="method"><span class="rightside"><span class="since" title="const since 1.39.0">const: 1.39.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#164">source</a></span><pre class="code-header" data-language="rust">pub const fn len(&amp;self) -&gt; usize</pre></section></summary><div class="docblock">
<p>Returns the length of <code>self</code>.</p> <p>This length is in bytes, not <a href="primitive.char.html" title="primitive char"><code>char</code></a>s or graphemes. In other words, it might not be what a human considers the length of the string.</p> <h5 id="examples">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let len = "foo".len();
assert_eq!(3, len);

assert_eq!("Æ’oo".len(), 4); // fancy f!
assert_eq!("Æ’oo".chars().count(), 3);</pre></div> </div>
<summary><section id="method.is_empty" class="method"><span class="rightside"><span class="since" title="const since 1.39.0">const: 1.39.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#183">source</a></span><pre class="code-header" data-language="rust">pub const fn is_empty(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p> <h5 id="examples-1">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "";
assert!(s.is_empty());

let s = "not empty";
assert!(!s.is_empty());</pre></div> </div>
<summary><section id="method.is_char_boundary" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#213">source</a></span><pre class="code-header" data-language="rust">pub fn is_char_boundary(&amp;self, index: usize) -&gt; bool</pre></section></summary><div class="docblock">
<p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point sequence or the end of the string.</p> <p>The start and end of the string (when <code>index == self.len()</code>) are considered to be boundaries.</p> <p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p> <h5 id="examples-2">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";
assert!(s.is_char_boundary(0));
// start of `è€`
assert!(s.is_char_boundary(6));
assert!(s.is_char_boundary(s.len()));

// second byte of `Ã¶`
assert!(!s.is_char_boundary(2));

// third byte of `è€`
assert!(!s.is_char_boundary(8));</pre></div> </div>
<summary><section id="method.floor_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#260">source</a><pre class="code-header" data-language="rust">pub fn floor_char_boundary(&amp;self, index: usize) -&gt; usize</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code> <a href="https://github.com/rust-lang/rust/issues/93743">#93743</a>)</span>
</div></span></summary><div class="docblock">
<p>Finds the closest <code>x</code> not exceeding <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p> <p>This method can help you truncate a string so that itâ€™s still valid UTF-8, but doesnâ€™t exceed a given number of bytes. Note that this is done purely at the character level and can still visually split graphemes, even though the underlying characters arenâ€™t split. For example, the emoji ğŸ§‘â€ğŸ”¬ (scientist) could be split so that the string only includes ğŸ§‘ (person) instead.</p> <h5 id="examples-3">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(round_char_boundary)]
let s = "â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ";
assert_eq!(s.len(), 26);
assert!(!s.is_char_boundary(13));

let closest = s.floor_char_boundary(13);
assert_eq!(closest, 10);
assert_eq!(&amp;s[..closest], "â¤ï¸ğŸ§¡");</pre></div> </div>
<summary><section id="method.ceil_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#298">source</a><pre class="code-header" data-language="rust">pub fn ceil_char_boundary(&amp;self, index: usize) -&gt; usize</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code> <a href="https://github.com/rust-lang/rust/issues/93743">#93743</a>)</span>
</div></span></summary><div class="docblock">
<p>Finds the closest <code>x</code> not below <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p> <p>If <code>index</code> is greater than the length of the string, this returns the length of the string.</p> <p>This method is the natural complement to <a href="primitive.str.html#method.floor_char_boundary" title="method str::floor_char_boundary"><code>floor_char_boundary</code></a>. See that method for more details.</p> <h5 id="examples-4">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(round_char_boundary)]
let s = "â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ";
assert_eq!(s.len(), 26);
assert!(!s.is_char_boundary(13));

let closest = s.ceil_char_boundary(13);
assert_eq!(closest, 14);
assert_eq!(&amp;s[..closest], "â¤ï¸ğŸ§¡ğŸ’›");</pre></div> </div>
<summary><section id="method.as_bytes" class="method"><span class="rightside"><span class="since" title="const since 1.39.0">const: 1.39.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#324">source</a></span><pre class="code-header" data-language="rust">pub const fn as_bytes(&amp;self) -&gt; &amp;[u8] â“˜</pre></section></summary><div class="docblock">
<p>Converts a string slice to a byte slice. To convert the byte slice back into a string slice, use the <a href="str/fn.from_utf8.html" title="fn std::str::from_utf8"><code>from_utf8</code></a> function.</p> <h5 id="examples-5">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bytes = "bors".as_bytes();
assert_eq!(b"bors", bytes);</pre></div> </div>
<summary><section id="method.as_bytes_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#368">source</a></span><pre class="code-header" data-language="rust">pub unsafe fn as_bytes_mut(&amp;mut self) -&gt; &amp;mut [u8] â“˜</pre></section></summary><div class="docblock">
<p>Converts a mutable string slice to a mutable byte slice.</p> <h5 id="safety">Safety</h5> <p>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying <code>str</code> is used.</p> <p>Use of a <code>str</code> whose contents are not valid UTF-8 is undefined behavior.</p> <h5 id="examples-6">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("Hello");
let bytes = unsafe { s.as_bytes_mut() };

assert_eq!(b"Hello", bytes);</pre></div> <p>Mutability:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("ğŸ—»âˆˆğŸŒ");

unsafe {
    let bytes = s.as_bytes_mut();

    bytes[0] = 0xF0;
    bytes[1] = 0x9F;
    bytes[2] = 0x8D;
    bytes[3] = 0x94;
}

assert_eq!("ğŸ”âˆˆğŸŒ", s);</pre></div> </div>
<summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="const since 1.32.0">const: 1.32.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#398">source</a></span><pre class="code-header" data-language="rust">pub const fn as_ptr(&amp;self) -&gt; *const u8</pre></section></summary><div class="docblock">
<p>Converts a string slice to a raw pointer.</p> <p>As string slices are a slice of bytes, the raw pointer points to a <a href="primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string slice.</p> <p>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use <a href="primitive.str.html#method.as_mut_ptr" title="method str::as_mut_ptr"><code>as_mut_ptr</code></a>.</p> <h5 id="examples-7">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Hello";
let ptr = s.as_ptr();</pre></div> </div>
<summary><section id="method.as_mut_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#414">source</a></span><pre class="code-header" data-language="rust">pub fn as_mut_ptr(&amp;mut self) -&gt; *mut u8</pre></section></summary><div class="docblock">
<p>Converts a mutable string slice to a raw pointer.</p> <p>As string slices are a slice of bytes, the raw pointer points to a <a href="primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string slice.</p> <p>It is your responsibility to make sure that the string slice only gets modified in a way that it remains valid UTF-8.</p> </div>
<summary><section id="method.get" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#439">source</a></span><pre class="code-header" data-language="rust">pub fn get&lt;I&gt;(&amp;self, i: I) -&gt; Option&lt;&amp;&lt;I as SliceIndex&lt;str&gt;&gt;::Output&gt;
where
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="docblock">
<p>Returns a subslice of <code>str</code>.</p> <p>This is the non-panicking alternative to indexing the <code>str</code>. Returns <a href="option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p> <h5 id="examples-8">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v = String::from("ğŸ—»âˆˆğŸŒ");

assert_eq!(Some("ğŸ—»"), v.get(0..4));

// indices not on UTF-8 sequence boundaries
assert!(v.get(1..).is_none());
assert!(v.get(..8).is_none());

// out of bounds
assert!(v.get(..42).is_none());</pre></div> </div>
<summary><section id="method.get_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#471">source</a></span><pre class="code-header" data-language="rust">pub fn get_mut&lt;I&gt;(
    &amp;mut self,
    i: I
) -&gt; Option&lt;&amp;mut &lt;I as SliceIndex&lt;str&gt;&gt;::Output&gt;
where
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="docblock">
<p>Returns a mutable subslice of <code>str</code>.</p> <p>This is the non-panicking alternative to indexing the <code>str</code>. Returns <a href="option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p> <h5 id="examples-9">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut v = String::from("hello");
// correct length
assert!(v.get_mut(0..5).is_some());
// out of bounds
assert!(v.get_mut(..42).is_none());
assert_eq!(Some("he"), v.get_mut(0..2).map(|v| &amp;*v));

assert_eq!("hello", v);
{
    let s = v.get_mut(0..2);
    let s = s.map(|s| {
        s.make_ascii_uppercase();
        &amp;*s
    });
    assert_eq!(Some("HE"), s);
}
assert_eq!("HEllo", v);</pre></div> </div>
<summary><section id="method.get_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#503">source</a></span><pre class="code-header" data-language="rust">pub unsafe fn get_unchecked&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as SliceIndex&lt;str&gt;&gt;::Output
where
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="docblock">
<p>Returns an unchecked subslice of <code>str</code>.</p> <p>This is the unchecked alternative to indexing the <code>str</code>.</p> <h5 id="safety-1">Safety</h5> <p>Callers of this function are responsible that these preconditions are satisfied:</p> <ul> <li>The starting index must not exceed the ending index;</li> <li>Indexes must be within bounds of the original slice;</li> <li>Indexes must lie on UTF-8 sequence boundaries.</li> </ul> <p>Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the <code>str</code> type.</p> <h5 id="examples-10">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v = "ğŸ—»âˆˆğŸŒ";
unsafe {
    assert_eq!("ğŸ—»", v.get_unchecked(0..4));
    assert_eq!("âˆˆ", v.get_unchecked(4..7));
    assert_eq!("ğŸŒ", v.get_unchecked(7..11));
}</pre></div> </div>
<summary><section id="method.get_unchecked_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#538">source</a></span><pre class="code-header" data-language="rust">pub unsafe fn get_unchecked_mut&lt;I&gt;(
    &amp;mut self,
    i: I
) -&gt; &amp;mut &lt;I as SliceIndex&lt;str&gt;&gt;::Output
where
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="docblock">
<p>Returns a mutable, unchecked subslice of <code>str</code>.</p> <p>This is the unchecked alternative to indexing the <code>str</code>.</p> <h5 id="safety-2">Safety</h5> <p>Callers of this function are responsible that these preconditions are satisfied:</p> <ul> <li>The starting index must not exceed the ending index;</li> <li>Indexes must be within bounds of the original slice;</li> <li>Indexes must lie on UTF-8 sequence boundaries.</li> </ul> <p>Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the <code>str</code> type.</p> <h5 id="examples-11">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut v = String::from("ğŸ—»âˆˆğŸŒ");
unsafe {
    assert_eq!("ğŸ—»", v.get_unchecked_mut(0..4));
    assert_eq!("âˆˆ", v.get_unchecked_mut(4..7));
    assert_eq!("ğŸŒ", v.get_unchecked_mut(7..11));
}</pre></div> </div>
<summary><section id="method.slice_unchecked" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#589">source</a><pre class="code-header" data-language="rust">pub unsafe fn slice_unchecked(&amp;self, begin: usize, end: usize) -&gt; &amp;str</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.29.0: use <code>get_unchecked(begin..end)</code> instead</span>
</div></span></summary><div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks.</p> <p>This is generally not recommended, use with caution! For a safe alternative see <a href="primitive.str.html" title="primitive str"><code>str</code></a> and <a href="ops/trait.index.html" title="trait std::ops::Index"><code>Index</code></a>.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get a mutable string slice instead, see the <a href="primitive.str.html#method.slice_mut_unchecked" title="method str::slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p> <h5 id="safety-3">Safety</h5> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must not exceed <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> <h5 id="examples-12">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";

unsafe {
    assert_eq!("LÃ¶we è€è™ LÃ©opard", s.slice_unchecked(0, 21));
}

let s = "Hello, world!";

unsafe {
    assert_eq!("world", s.slice_unchecked(7, 12));
}</pre></div> </div>
<summary><section id="method.slice_mut_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#622">source</a></span><pre class="code-header" data-language="rust">pub unsafe fn slice_mut_unchecked(
    &amp;mut self,
    begin: usize,
    end: usize
) -&gt; &amp;mut str</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.29.0: use <code>get_unchecked_mut(begin..end)</code> instead</span>
</div></span></summary><div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks. This is generally not recommended, use with caution! For a safe alternative see <a href="primitive.str.html" title="primitive str"><code>str</code></a> and <a href="ops/trait.indexmut.html" title="trait std::ops::IndexMut"><code>IndexMut</code></a>.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get an immutable string slice instead, see the <a href="primitive.str.html#method.slice_unchecked" title="method str::slice_unchecked"><code>slice_unchecked</code></a> method.</p> <h5 id="safety-4">Safety</h5> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must not exceed <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> </div>
<summary><section id="method.split_at" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#660">source</a></span><pre class="code-header" data-language="rust">pub fn split_at(&amp;self, mid: usize) -&gt; (&amp;str, &amp;str)</pre></section></summary><div class="docblock">
<p>Divide one string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get mutable string slices instead, see the <a href="primitive.str.html#method.split_at_mut" title="method str::split_at_mut"><code>split_at_mut</code></a> method.</p> <h5 id="panics">Panics</h5> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice.</p> <h5 id="examples-13">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Per Martin-LÃ¶f";

let (first, last) = s.split_at(3);

assert_eq!("Per", first);
assert_eq!(" Martin-LÃ¶f", last);</pre></div> </div>
<summary><section id="method.split_at_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#702">source</a></span><pre class="code-header" data-language="rust">pub fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut str, &amp;mut str)</pre></section></summary><div class="docblock">
<p>Divide one mutable string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get immutable string slices instead, see the <a href="primitive.str.html#method.split_at" title="method str::split_at"><code>split_at</code></a> method.</p> <h5 id="panics-1">Panics</h5> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice.</p> <h5 id="examples-14">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = "Per Martin-LÃ¶f".to_string();
{
    let (first, last) = s.split_at_mut(3);
    first.make_ascii_uppercase();
    assert_eq!("PER", first);
    assert_eq!(" Martin-LÃ¶f", last);
}
assert_eq!("PER Martin-LÃ¶f", s);</pre></div> </div>
<summary><section id="method.chars" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#768">source</a><pre class="code-header" data-language="rust">pub fn chars(&amp;self) -&gt; Chars&lt;'_&gt; â“˜</pre></section></summary><div class="docblock">
<p>Returns an iterator over the <a href="primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="primitive.char.html" title="primitive char"><code>char</code></a>. This method returns such an iterator.</p> <p>Itâ€™s important to remember that <a href="primitive.char.html" title="primitive char"><code>char</code></a> represents a Unicode Scalar Value, and might not match your idea of what a â€˜characterâ€™ is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rustâ€™s standard library, check crates.io instead.</p> <h5 id="examples-15">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let word = "goodbye";

let count = word.chars().count();
assert_eq!(7, count);

let mut chars = word.chars();

assert_eq!(Some('g'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('d'), chars.next());
assert_eq!(Some('b'), chars.next());
assert_eq!(Some('y'), chars.next());
assert_eq!(Some('e'), chars.next());

assert_eq!(None, chars.next());</pre></div> <p>Remember, <a href="primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let y = "yÌ†";

let mut chars = y.chars();

assert_eq!(Some('y'), chars.next()); // not 'yÌ†'
assert_eq!(Some('\u{0306}'), chars.next());

assert_eq!(None, chars.next());</pre></div> </div>
<summary><section id="method.char_indices" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#825">source</a><pre class="code-header" data-language="rust">pub fn char_indices(&amp;self) -&gt; CharIndices&lt;'_&gt; â“˜</pre></section></summary><div class="docblock">
<p>Returns an iterator over the <a href="primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice, and their positions.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="primitive.char.html" title="primitive char"><code>char</code></a>. This method returns an iterator of both these <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, as well as their byte positions.</p> <p>The iterator yields tuples. The position is first, the <a href="primitive.char.html" title="primitive char"><code>char</code></a> is second.</p> <h5 id="examples-16">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let word = "goodbye";

let count = word.char_indices().count();
assert_eq!(7, count);

let mut char_indices = word.char_indices();

assert_eq!(Some((0, 'g')), char_indices.next());
assert_eq!(Some((1, 'o')), char_indices.next());
assert_eq!(Some((2, 'o')), char_indices.next());
assert_eq!(Some((3, 'd')), char_indices.next());
assert_eq!(Some((4, 'b')), char_indices.next());
assert_eq!(Some((5, 'y')), char_indices.next());
assert_eq!(Some((6, 'e')), char_indices.next());

assert_eq!(None, char_indices.next());</pre></div> <p>Remember, <a href="primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let yes = "yÌ†es";

let mut char_indices = yes.char_indices();

assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'yÌ†')
assert_eq!(Some((1, '\u{0306}')), char_indices.next());

// note the 3 here - the previous character took up two bytes
assert_eq!(Some((3, 'e')), char_indices.next());
assert_eq!(Some((4, 's')), char_indices.next());

assert_eq!(None, char_indices.next());</pre></div> </div>
<summary><section id="method.bytes" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#848">source</a><pre class="code-header" data-language="rust">pub fn bytes(&amp;self) -&gt; Bytes&lt;'_&gt; â“˜</pre></section></summary><div class="docblock">
<p>An iterator over the bytes of a string slice.</p> <p>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</p> <h5 id="examples-17">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut bytes = "bors".bytes();

assert_eq!(Some(b'b'), bytes.next());
assert_eq!(Some(b'o'), bytes.next());
assert_eq!(Some(b'r'), bytes.next());
assert_eq!(Some(b's'), bytes.next());

assert_eq!(None, bytes.next());</pre></div> </div>
<summary><section id="method.split_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#900">source</a></span><pre class="code-header" data-language="rust">pub fn split_whitespace(&amp;self) -&gt; SplitWhitespace&lt;'_&gt; â“˜</pre></section></summary><div class="docblock">
<p>Splits a string slice by whitespace.</p> <p>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace instead, use <a href="primitive.str.html#method.split_ascii_whitespace" title="method str::split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p> <h5 id="examples-18">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = "A few words".split_whitespace();

assert_eq!(Some("A"), iter.next());
assert_eq!(Some("few"), iter.next());
assert_eq!(Some("words"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>All kinds of whitespace are considered:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = " Mary   had\ta\u{2009}little  \n\t lamb".split_whitespace();
assert_eq!(Some("Mary"), iter.next());
assert_eq!(Some("had"), iter.next());
assert_eq!(Some("a"), iter.next());
assert_eq!(Some("little"), iter.next());
assert_eq!(Some("lamb"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>If the string is empty or all whitespace, the iterator yields no string slices:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("".split_whitespace().next(), None);
assert_eq!("   ".split_whitespace().next(), None);</pre></div> </div>
<summary><section id="method.split_ascii_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#949">source</a></span><pre class="code-header" data-language="rust">pub fn split_ascii_whitespace(&amp;self) -&gt; SplitAsciiWhitespace&lt;'_&gt; â“˜</pre></section></summary><div class="docblock">
<p>Splits a string slice by ASCII whitespace.</p> <p>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</p> <p>To split by Unicode <code>Whitespace</code> instead, use <a href="primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a>.</p> <h5 id="examples-19">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = "A few words".split_ascii_whitespace();

assert_eq!(Some("A"), iter.next());
assert_eq!(Some("few"), iter.next());
assert_eq!(Some("words"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>All kinds of ASCII whitespace are considered:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = " Mary   had\ta little  \n\t lamb".split_ascii_whitespace();
assert_eq!(Some("Mary"), iter.next());
assert_eq!(Some("had"), iter.next());
assert_eq!(Some("a"), iter.next());
assert_eq!(Some("little"), iter.next());
assert_eq!(Some("lamb"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>If the string is empty or all ASCII whitespace, the iterator yields no string slices:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("".split_ascii_whitespace().next(), None);
assert_eq!("   ".split_ascii_whitespace().next(), None);</pre></div> </div>
<summary><section id="method.lines" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1002">source</a><pre class="code-header" data-language="rust">pub fn lines(&amp;self) -&gt; Lines&lt;'_&gt; â“˜</pre></section></summary><div class="docblock">
<p>An iterator over the lines of a string, as string slices.</p> <p>Lines are split at line endings that are either newlines (<code>\n</code>) or sequences of a carriage return followed by a line feed (<code>\r\n</code>).</p> <p>Line terminators are not included in the lines returned by the iterator.</p> <p>Note that any carriage return (<code>\r</code>) not immediately followed by a line feed (<code>\n</code>) does not split a line. These carriage returns are thereby included in the produced lines.</p> <p>The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.</p> <h5 id="examples-20">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let text = "foo\r\nbar\n\nbaz\r";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
// Trailing carriage return is included in the last line
assert_eq!(Some("baz\r"), lines.next());

assert_eq!(None, lines.next());</pre></div> <p>The final line does not require any ending:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let text = "foo\nbar\n\r\nbaz";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
assert_eq!(Some("baz"), lines.next());

assert_eq!(None, lines.next());</pre></div> </div>
<summary><section id="method.lines_any" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1011">source</a><pre class="code-header" data-language="rust">pub fn lines_any(&amp;self) -&gt; LinesAny&lt;'_&gt; â“˜</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.4.0: use lines() instead now</span>
</div></span></summary><div class="docblock">
<p>An iterator over the lines of a string.</p> </div>
<summary><section id="method.encode_utf16" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1030">source</a></span><pre class="code-header" data-language="rust">pub fn encode_utf16(&amp;self) -&gt; EncodeUtf16&lt;'_&gt; â“˜</pre></section></summary><div class="docblock">
<p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p> <h5 id="examples-21">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let text = "ZaÅ¼Ã³Å‚Ä‡ gÄ™Å›lÄ… jaÅºÅ„";

let utf8_len = text.len();
let utf16_len = text.encode_utf16().count();

assert!(utf16_len &lt;= utf8_len);</pre></div> </div>
<summary><section id="method.contains" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1055">source</a><pre class="code-header" data-language="rust">pub fn contains&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; bool
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a sub-slice of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-22">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bananas = "bananas";

assert!(bananas.contains("nana"));
assert!(!bananas.contains("apples"));</pre></div> </div>
<summary><section id="method.starts_with" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1079">source</a><pre class="code-header" data-language="rust">pub fn starts_with&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; bool
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a prefix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-23">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bananas = "bananas";

assert!(bananas.starts_with("bana"));
assert!(!bananas.starts_with("nana"));</pre></div> </div>
<summary><section id="method.ends_with" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1103-1105">source</a><pre class="code-header" data-language="rust">pub fn ends_with&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; bool
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a suffix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-24">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bananas = "bananas";

assert!(bananas.ends_with("anas"));
assert!(!bananas.ends_with("nana"));</pre></div> </div>
<summary><section id="method.find" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1154">source</a><pre class="code-header" data-language="rust">pub fn find&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; Option&lt;usize&gt;
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns the byte index of the first character of this string slice that matches the pattern.</p> <p>Returns <a href="option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> if the pattern doesnâ€™t match.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-25">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard Gepardi";

assert_eq!(s.find('L'), Some(0));
assert_eq!(s.find('Ã©'), Some(14));
assert_eq!(s.find("pard"), Some(17));</pre></div> <p>More complex patterns using point-free style and closures:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";

assert_eq!(s.find(char::is_whitespace), Some(5));
assert_eq!(s.find(char::is_lowercase), Some(1));
assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));
assert_eq!(s.find(|c: char| (c &lt; 'o') &amp;&amp; (c &gt; 'a')), Some(4));</pre></div> <p>Not finding the pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.find(x), None);</pre></div> </div>
<summary><section id="method.rfind" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1200-1202">source</a><pre class="code-header" data-language="rust">pub fn rfind&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; Option&lt;usize&gt;
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns the byte index for the first character of the last match of the pattern in this string slice.</p> <p>Returns <a href="option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> if the pattern doesnâ€™t match.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-26">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard Gepardi";

assert_eq!(s.rfind('L'), Some(13));
assert_eq!(s.rfind('Ã©'), Some(14));
assert_eq!(s.rfind("pard"), Some(24));</pre></div> <p>More complex patterns with closures:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";

assert_eq!(s.rfind(char::is_whitespace), Some(12));
assert_eq!(s.rfind(char::is_lowercase), Some(20));</pre></div> <p>Not finding the pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.rfind(x), None);</pre></div> </div>
<summary><section id="method.split" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1322">source</a><pre class="code-header" data-language="rust">pub fn split&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; Split&lt;'a, P&gt; â“˜
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>An iterator over substrings of this string slice, separated by characters matched by a pattern.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str.html#method.rsplit" title="method str::rsplit"><code>rsplit</code></a> method can be used.</p> <h5 id="examples-27">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".split(' ').collect();
assert_eq!(v, ["Mary", "had", "a", "little", "lamb"]);

let v: Vec&lt;&amp;str&gt; = "".split('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".split('X').collect();
assert_eq!(v, ["lion", "", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".split("::").collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "abc1def2ghi".split(char::is_numeric).collect();
assert_eq!(v, ["abc", "def", "ghi"]);

let v: Vec&lt;&amp;str&gt; = "lionXtigerXleopard".split(char::is_uppercase).collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);</pre></div> <p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "2020-11-03 23:59".split(&amp;['-', ' ', ':', '@'][..]).collect();
assert_eq!(v, ["2020", "11", "03", "23", "59"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".split(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "def", "ghi"]);</pre></div> <p>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = "||||a||b|c".to_string();
let d: Vec&lt;_&gt; = x.split('|').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre></div> <p>Contiguous separators are separated by the empty string.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = "(///)".to_string();
let d: Vec&lt;_&gt; = x.split('/').collect();

assert_eq!(d, &amp;["(", "", "", ")"]);</pre></div> <p>Separators at the start or end of a string are neighbored by empty strings.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let d: Vec&lt;_&gt; = "010".split("0").collect();
assert_eq!(d, &amp;["", "1", ""]);</pre></div> <p>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f: Vec&lt;_&gt; = "rust".split("").collect();
assert_eq!(f, &amp;["", "r", "u", "s", "t", ""]);</pre></div> <p>Contiguous separators can lead to possibly surprising behavior when whitespace is used as the separator. This code is correct:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = "    a  b c".to_string();
let d: Vec&lt;_&gt; = x.split(' ').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre></div> <p>It does <em>not</em> give you:</p> <div class="example-wrap ignore">â“˜<pre class="rust rust-example-rendered" data-language="rust">assert_eq!(d, &amp;["a", "b", "c"]);</pre>
</div> <p>Use <a href="primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a> for this behavior.</p> </div>
<summary><section id="method.split_inclusive" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1362">source</a></span><pre class="code-header" data-language="rust">pub fn split_inclusive&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; SplitInclusive&lt;'a, P&gt; â“˜
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>An iterator over substrings of this string slice, separated by characters matched by a pattern. Differs from the iterator produced by <code>split</code> in that <code>split_inclusive</code> leaves the matched part as the terminator of the substring.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-28">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb\nlittle lamb\nlittle lamb."
    .split_inclusive('\n').collect();
assert_eq!(v, ["Mary had a little lamb\n", "little lamb\n", "little lamb."]);</pre></div> <p>If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb\nlittle lamb\nlittle lamb.\n"
    .split_inclusive('\n').collect();
assert_eq!(v, ["Mary had a little lamb\n", "little lamb\n", "little lamb.\n"]);</pre></div> </div>
<summary><section id="method.rsplit" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1417-1419">source</a><pre class="code-header" data-language="rust">pub fn rsplit&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; RSplit&lt;'a, P&gt; â“˜
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>An iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-1">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a> method can be used.</p> <h5 id="examples-29">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplit(' ').collect();
assert_eq!(v, ["lamb", "little", "a", "had", "Mary"]);

let v: Vec&lt;&amp;str&gt; = "".rsplit('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplit('X').collect();
assert_eq!(v, ["leopard", "tiger", "", "lion"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplit("::").collect();
assert_eq!(v, ["leopard", "tiger", "lion"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplit(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "def", "abc"]);</pre></div> </div>
<summary><section id="method.split_terminator" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1466">source</a><pre class="code-header" data-language="rust">pub fn split_terminator&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; SplitTerminator&lt;'a, P&gt; â“˜
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>An iterator over substrings of the given string slice, separated by characters matched by a pattern.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <p>Equivalent to <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h5 id="iterator-behavior-2">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str.html#method.rsplit_terminator" title="method str::rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p> <h5 id="examples-30">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "A.B.".split_terminator('.').collect();
assert_eq!(v, ["A", "B"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".split_terminator(".").collect();
assert_eq!(v, ["A", "", "B", ""]);

let v: Vec&lt;&amp;str&gt; = "A.B:C.D".split_terminator(&amp;['.', ':'][..]).collect();
assert_eq!(v, ["A", "B", "C", "D"]);</pre></div> </div>
<summary><section id="method.rsplit_terminator" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1512-1514">source</a><pre class="code-header" data-language="rust">pub fn rsplit_terminator&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; RSplitTerminator&lt;'a, P&gt; â“˜
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>An iterator over substrings of <code>self</code>, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <p>Equivalent to <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h5 id="iterator-behavior-3">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str.html#method.split_terminator" title="method str::split_terminator"><code>split_terminator</code></a> method can be used.</p> <h5 id="examples-31">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "A.B.".rsplit_terminator('.').collect();
assert_eq!(v, ["B", "A"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".rsplit_terminator(".").collect();
assert_eq!(v, ["", "B", "", "A"]);

let v: Vec&lt;&amp;str&gt; = "A.B:C.D".rsplit_terminator(&amp;['.', ':'][..]).collect();
assert_eq!(v, ["D", "C", "B", "A"]);</pre></div> </div>
<summary><section id="method.splitn" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1567">source</a><pre class="code-header" data-language="rust">pub fn splitn&lt;'a, P&gt;(&amp;'a self, n: usize, pat: P) -&gt; SplitN&lt;'a, P&gt; â“˜
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>An iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-4">Iterator behavior</h5> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>If the pattern allows a reverse search, the <a href="primitive.str.html#method.rsplitn" title="method str::rsplitn"><code>rsplitn</code></a> method can be used.</p> <h5 id="examples-32">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lambda".splitn(3, ' ').collect();
assert_eq!(v, ["Mary", "had", "a little lambda"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".splitn(3, "X").collect();
assert_eq!(v, ["lion", "", "tigerXleopard"]);

let v: Vec&lt;&amp;str&gt; = "abcXdef".splitn(1, 'X').collect();
assert_eq!(v, ["abcXdef"]);

let v: Vec&lt;&amp;str&gt; = "".splitn(1, 'X').collect();
assert_eq!(v, [""]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".splitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "defXghi"]);</pre></div> </div>
<summary><section id="method.rsplitn" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1616-1618">source</a><pre class="code-header" data-language="rust">pub fn rsplitn&lt;'a, P&gt;(&amp;'a self, n: usize, pat: P) -&gt; RSplitN&lt;'a, P&gt; â“˜
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>An iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-5">Iterator behavior</h5> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>For splitting from the front, the <a href="primitive.str.html#method.splitn" title="method str::splitn"><code>splitn</code></a> method can be used.</p> <h5 id="examples-33">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplitn(3, ' ').collect();
assert_eq!(v, ["lamb", "little", "Mary had a"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplitn(3, 'X').collect();
assert_eq!(v, ["leopard", "tiger", "lionX"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplitn(2, "::").collect();
assert_eq!(v, ["leopard", "lion::tiger"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "abc1def"]);</pre></div> </div>
<summary><section id="method.split_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1636">source</a></span><pre class="code-header" data-language="rust">pub fn split_once&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; Option&lt;(&amp;'a str, &amp;'a str)&gt;
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Splits the string on the first occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter.</p> <h5 id="examples-34">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("cfg".split_once('='), None);
assert_eq!("cfg=".split_once('='), Some(("cfg", "")));
assert_eq!("cfg=foo".split_once('='), Some(("cfg", "foo")));
assert_eq!("cfg=foo=bar".split_once('='), Some(("cfg", "foo=bar")));</pre></div> </div>
<summary><section id="method.rsplit_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1654-1656">source</a></span><pre class="code-header" data-language="rust">pub fn rsplit_once&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; Option&lt;(&amp;'a str, &amp;'a str)&gt;
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Splits the string on the last occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter.</p> <h5 id="examples-35">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("cfg".rsplit_once('='), None);
assert_eq!("cfg=foo".rsplit_once('='), Some(("cfg", "foo")));
assert_eq!("cfg=foo=bar".rsplit_once('='), Some(("cfg=foo", "bar")));</pre></div> </div>
<summary><section id="method.matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1694">source</a></span><pre class="code-header" data-language="rust">pub fn matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; Matches&lt;'a, P&gt; â“˜
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>An iterator over the disjoint matches of a pattern within the given string slice.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-6">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str.html#method.rmatches" title="method str::rmatches"><code>rmatches</code></a> method can be used.</p> <h5 id="examples-36">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".matches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".matches(char::is_numeric).collect();
assert_eq!(v, ["1", "2", "3"]);</pre></div> </div>
<summary><section id="method.rmatches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1728-1730">source</a></span><pre class="code-header" data-language="rust">pub fn rmatches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; RMatches&lt;'a, P&gt; â“˜
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>An iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-7">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str.html#method.matches" title="method str::matches"><code>matches</code></a> method can be used.</p> <h5 id="examples-37">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".rmatches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".rmatches(char::is_numeric).collect();
assert_eq!(v, ["3", "2", "1"]);</pre></div> </div>
<summary><section id="method.match_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1772">source</a></span><pre class="code-header" data-language="rust">pub fn match_indices&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; MatchIndices&lt;'a, P&gt; â“˜
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>An iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the first match are returned.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-8">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str.html#method.rmatch_indices" title="method str::rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p> <h5 id="examples-38">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".match_indices("abc").collect();
assert_eq!(v, [(0, "abc"), (6, "abc"), (12, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".match_indices("abc").collect();
assert_eq!(v, [(1, "abc"), (4, "abc")]);

let v: Vec&lt;_&gt; = "ababa".match_indices("aba").collect();
assert_eq!(v, [(0, "aba")]); // only the first `aba`</pre></div> </div>
<summary><section id="method.rmatch_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1812-1814">source</a></span><pre class="code-header" data-language="rust">pub fn rmatch_indices&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; RMatchIndices&lt;'a, P&gt; â“˜
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>An iterator over the disjoint matches of a pattern within <code>self</code>, yielded in reverse order along with the index of the match.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the last match are returned.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-9">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str.html#method.match_indices" title="method str::match_indices"><code>match_indices</code></a> method can be used.</p> <h5 id="examples-39">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".rmatch_indices("abc").collect();
assert_eq!(v, [(12, "abc"), (6, "abc"), (0, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".rmatch_indices("abc").collect();
assert_eq!(v, [(4, "abc"), (1, "abc")]);

let v: Vec&lt;_&gt; = "ababa".rmatch_indices("aba").collect();
assert_eq!(v, [(2, "aba")]); // only the last `aba`</pre></div> </div>
<summary><section id="method.trim" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1836">source</a><pre class="code-header" data-language="rust">pub fn trim(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">
<p>Returns a string slice with leading and trailing whitespace removed.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <h5 id="examples-40">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "\n Hello\tworld\t\n";

assert_eq!("Hello\tworld", s.trim());</pre></div> </div>
<summary><section id="method.trim_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1875">source</a></span><pre class="code-header" data-language="rust">pub fn trim_start(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">
<p>Returns a string slice with leading whitespace removed.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <h5 id="text-directionality">Text directionality</h5> <p>A string is a sequence of bytes. <code>start</code> in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</p> <h5 id="examples-41">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "\n Hello\tworld\t\n";
assert_eq!("Hello\tworld\t\n", s.trim_start());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "  English  ";
assert!(Some('E') == s.trim_start().chars().next());

let s = "  ×¢×‘×¨×™×ª  ";
assert!(Some('×¢') == s.trim_start().chars().next());</pre></div> </div>
<summary><section id="method.trim_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1914">source</a></span><pre class="code-header" data-language="rust">pub fn trim_end(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">
<p>Returns a string slice with trailing whitespace removed.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <h5 id="text-directionality-1">Text directionality</h5> <p>A string is a sequence of bytes. <code>end</code> in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</p> <h5 id="examples-42">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "\n Hello\tworld\t\n";
assert_eq!("\n Hello\tworld", s.trim_end());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "  English  ";
assert!(Some('h') == s.trim_end().chars().rev().next());

let s = "  ×¢×‘×¨×™×ª  ";
assert!(Some('×ª') == s.trim_end().chars().rev().next());</pre></div> </div>
<summary><section id="method.trim_left" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1954">source</a><pre class="code-header" data-language="rust">pub fn trim_left(&amp;self) -&gt; &amp;str</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_start</code></span>
</div></span></summary><div class="docblock">
<p>Returns a string slice with leading whitespace removed.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h5 id="text-directionality-2">Text directionality</h5> <p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first position of that byte string; for a language like Arabic or Hebrew which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be the <em>right</em> side, not the left.</p> <h5 id="examples-43">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = " Hello\tworld\t";

assert_eq!("Hello\tworld\t", s.trim_left());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "  English";
assert!(Some('E') == s.trim_left().chars().next());

let s = "  ×¢×‘×¨×™×ª";
assert!(Some('×¢') == s.trim_left().chars().next());</pre></div> </div>
<summary><section id="method.trim_right" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1994">source</a><pre class="code-header" data-language="rust">pub fn trim_right(&amp;self) -&gt; &amp;str</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_end</code></span>
</div></span></summary><div class="docblock">
<p>Returns a string slice with trailing whitespace removed.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h5 id="text-directionality-3">Text directionality</h5> <p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last position of that byte string; for a language like Arabic or Hebrew which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be the <em>left</em> side, not the right.</p> <h5 id="examples-44">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = " Hello\tworld\t";

assert_eq!(" Hello\tworld", s.trim_right());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "English  ";
assert!(Some('h') == s.trim_right().chars().rev().next());

let s = "×¢×‘×¨×™×ª  ";
assert!(Some('×ª') == s.trim_right().chars().rev().next());</pre></div> </div>
<summary><section id="method.trim_matches" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2027-2029">source</a><pre class="code-header" data-language="rust">pub fn trim_matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a str
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: DoubleEndedSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns a string slice with all prefixes and suffixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-45">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_matches('1'), "foo1bar");
assert_eq!("123foo1bar123".trim_matches(char::is_numeric), "foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_matches(x), "foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("1foo1barXX".trim_matches(|c| c == '1' || c == 'X'), "foo1bar");</pre></div> </div>
<summary><section id="method.trim_start_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2074">source</a></span><pre class="code-header" data-language="rust">pub fn trim_start_matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a str
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns a string slice with all prefixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-4">Text directionality</h5> <p>A string is a sequence of bytes. <code>start</code> in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</p> <h5 id="examples-46">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_start_matches('1'), "foo1bar11");
assert_eq!("123foo1bar123".trim_start_matches(char::is_numeric), "foo1bar123");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_start_matches(x), "foo1bar12");</pre></div> </div>
<summary><section id="method.strip_prefix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2107">source</a></span><pre class="code-header" data-language="rust">pub fn strip_prefix&lt;'a, P&gt;(&amp;'a self, prefix: P) -&gt; Option&lt;&amp;'a str&gt;
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns a string slice with the prefix removed.</p> <p>If the string starts with the pattern <code>prefix</code>, returns substring after the prefix, wrapped in <code>Some</code>. Unlike <code>trim_start_matches</code>, this method removes the prefix exactly once.</p> <p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-47">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("foo:bar".strip_prefix("foo:"), Some("bar"));
assert_eq!("foo:bar".strip_prefix("bar"), None);
assert_eq!("foofoo".strip_prefix("foo"), Some("foo"));</pre></div> </div>
<summary><section id="method.strip_suffix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2134-2137">source</a></span><pre class="code-header" data-language="rust">pub fn strip_suffix&lt;'a, P&gt;(&amp;'a self, suffix: P) -&gt; Option&lt;&amp;'a str&gt;
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns a string slice with the suffix removed.</p> <p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix, wrapped in <code>Some</code>. Unlike <code>trim_end_matches</code>, this method removes the suffix exactly once.</p> <p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-48">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("bar:foo".strip_suffix(":foo"), Some("bar"));
assert_eq!("bar:foo".strip_suffix("bar"), None);
assert_eq!("foofoo".strip_suffix("foo"), Some("foo"));</pre></div> </div>
<summary><section id="method.trim_end_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2178-2180">source</a></span><pre class="code-header" data-language="rust">pub fn trim_end_matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a str
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns a string slice with all suffixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-5">Text directionality</h5> <p>A string is a sequence of bytes. <code>end</code> in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</p> <h5 id="examples-49">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_end_matches('1'), "11foo1bar");
assert_eq!("123foo1bar123".trim_end_matches(char::is_numeric), "123foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_end_matches(x), "12foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("1fooX".trim_end_matches(|c| c == '1' || c == 'X'), "1foo");</pre></div> </div>
<summary><section id="method.trim_left_matches" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2222">source</a><pre class="code-header" data-language="rust">pub fn trim_left_matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a str
where
    P: Pattern&lt;'a&gt;,</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_start_matches</code></span>
</div></span></summary><div class="docblock">
<p>Returns a string slice with all prefixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-6">Text directionality</h5> <p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first position of that byte string; for a language like Arabic or Hebrew which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be the <em>right</em> side, not the left.</p> <h5 id="examples-50">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_left_matches('1'), "foo1bar11");
assert_eq!("123foo1bar123".trim_left_matches(char::is_numeric), "foo1bar123");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_left_matches(x), "foo1bar12");</pre></div> </div>
<summary><section id="method.trim_right_matches" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2265-2267">source</a><pre class="code-header" data-language="rust">pub fn trim_right_matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a str
where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_end_matches</code></span>
</div></span></summary><div class="docblock">
<p>Returns a string slice with all suffixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-7">Text directionality</h5> <p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last position of that byte string; for a language like Arabic or Hebrew which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be the <em>left</em> side, not the right.</p> <h5 id="examples-51">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_right_matches('1'), "11foo1bar");
assert_eq!("123foo1bar123".trim_right_matches(char::is_numeric), "123foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_right_matches(x), "12foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("1fooX".trim_right_matches(|c| c == '1' || c == 'X'), "1foo");</pre></div> </div>
<summary><section id="method.parse" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2317">source</a><pre class="code-header" data-language="rust">pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt;
where
    F: FromStr,</pre></section></summary><div class="docblock">
<p>Parses this string slice into another type.</p> <p>Because <code>parse</code> is so general, it can cause problems with type inference. As such, <code>parse</code> is one of the few times youâ€™ll see the syntax affectionately known as the â€˜turbofishâ€™: <code>::&lt;&gt;</code>. This helps the inference algorithm understand specifically which type youâ€™re trying to parse into.</p> <p><code>parse</code> can parse into any type that implements the <a href="str/trait.fromstr.html" title="trait std::str::FromStr"><code>FromStr</code></a> trait.</p> <h5 id="errors">Errors</h5> <p>Will return <a href="str/trait.fromstr.html#associatedtype.Err" title="associated type std::str::FromStr::Err"><code>Err</code></a> if itâ€™s not possible to parse this string slice into the desired type.</p> <h5 id="examples-52">Examples</h5> <p>Basic usage</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let four: u32 = "4".parse().unwrap();

assert_eq!(4, four);</pre></div> <p>Using the â€˜turbofishâ€™ instead of annotating <code>four</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let four = "4".parse::&lt;u32&gt;();

assert_eq!(Ok(4), four);</pre></div> <p>Failing to parse:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let nope = "j".parse::&lt;u32&gt;();

assert!(nope.is_err());</pre></div> </div>
<summary><section id="method.is_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const since 1.74.0">1.23.0 (const: 1.74.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2336">source</a></span><pre class="code-header" data-language="rust">pub const fn is_ascii(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Checks if all characters in this string are within the ASCII range.</p> <h5 id="examples-53">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let ascii = "hello!\n";
let non_ascii = "GrÃ¼ÃŸe, JÃ¼rgen â¤";

assert!(ascii.is_ascii());
assert!(!non_ascii.is_ascii());</pre></div> </div>
<summary><section id="method.as_ascii" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2348">source</a><pre class="code-header" data-language="rust">pub const fn as_ascii(&amp;self) -&gt; Option&lt;&amp;[AsciiChar]&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code> <a href="https://github.com/rust-lang/rust/issues/110998">#110998</a>)</span>
</div></span></summary><div class="docblock">
<p>If this string slice <a href="primitive.str.html#method.is_ascii" title="method str::is_ascii"><code>is_ascii</code></a>, returns it as a slice of <a href="ascii/enum.char.html" title="enum std::ascii::Char">ASCII characters</a>, otherwise returns <code>None</code>.</p> </div>
<summary><section id="method.eq_ignore_ascii_case" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2368">source</a></span><pre class="code-header" data-language="rust">pub fn eq_ignore_ascii_case(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">
<p>Checks that two strings are an ASCII case-insensitive match.</p> <p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>, but without allocating and copying temporaries.</p> <h5 id="examples-54">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert!("Ferris".eq_ignore_ascii_case("FERRIS"));
assert!("FerrÃ¶s".eq_ignore_ascii_case("FERRÃ¶S"));
assert!(!"FerrÃ¶s".eq_ignore_ascii_case("FERRÃ–S"));</pre></div> </div>
<summary><section id="method.make_ascii_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2393">source</a></span><pre class="code-header" data-language="rust">pub fn make_ascii_uppercase(&amp;mut self)</pre></section></summary><div class="docblock">
<p>Converts this string to its ASCII upper case equivalent in-place.</p> <p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™, but non-ASCII letters are unchanged.</p> <p>To return a new uppercased value without modifying the existing one, use <a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase()</code></a>.</p> <h5 id="examples-55">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("GrÃ¼ÃŸe, JÃ¼rgen â¤");

s.make_ascii_uppercase();

assert_eq!("GRÃ¼ÃŸE, JÃ¼RGEN â¤", s);</pre></div> </div>
<summary><section id="method.make_ascii_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2420">source</a></span><pre class="code-header" data-language="rust">pub fn make_ascii_lowercase(&amp;mut self)</pre></section></summary><div class="docblock">
<p>Converts this string to its ASCII lower case equivalent in-place.</p> <p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™, but non-ASCII letters are unchanged.</p> <p>To return a new lowercased value without modifying the existing one, use <a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase()</code></a>.</p> <h5 id="examples-56">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("GRÃœÃŸE, JÃœRGEN â¤");

s.make_ascii_lowercase();

assert_eq!("grÃœÃŸe, jÃœrgen â¤", s);</pre></div> </div>
<summary><section id="method.escape_debug" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2463">source</a></span><pre class="code-header" data-language="rust">pub fn escape_debug(&amp;self) -&gt; EscapeDebug&lt;'_&gt; â“˜</pre></section></summary><div class="docblock">
<p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_debug" title="method char::escape_debug"><code>char::escape_debug</code></a>.</p> <p>Note: only extended grapheme codepoints that begin the string will be escaped.</p> <h5 id="examples-57">Examples</h5> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">for c in "â¤\n!".escape_debug() {
    print!("{c}");
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("{}", "â¤\n!".escape_debug());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("â¤\\n!");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("â¤\n!".escape_debug().to_string(), "â¤\\n!");</pre></div> </div>
<summary><section id="method.escape_default" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2509">source</a></span><pre class="code-header" data-language="rust">pub fn escape_default(&amp;self) -&gt; EscapeDefault&lt;'_&gt; â“˜</pre></section></summary><div class="docblock">
<p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_default" title="method char::escape_default"><code>char::escape_default</code></a>.</p> <h5 id="examples-58">Examples</h5> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">for c in "â¤\n!".escape_default() {
    print!("{c}");
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("{}", "â¤\n!".escape_default());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("\\u{{2764}}\\n!");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("â¤\n!".escape_default().to_string(), "\\u{2764}\\n!");</pre></div> </div>
<summary><section id="method.escape_unicode" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2547">source</a></span><pre class="code-header" data-language="rust">pub fn escape_unicode(&amp;self) -&gt; EscapeUnicode&lt;'_&gt; â“˜</pre></section></summary><div class="docblock">
<p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_unicode" title="method char::escape_unicode"><code>char::escape_unicode</code></a>.</p> <h5 id="examples-59">Examples</h5> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">for c in "â¤\n!".escape_unicode() {
    print!("{c}");
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("{}", "â¤\n!".escape_unicode());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("\\u{{2764}}\\u{{a}}\\u{{21}}");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("â¤\n!".escape_unicode().to_string(), "\\u{2764}\\u{a}\\u{21}");</pre></div> </div>
</div>
<summary><section id="impl-str-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#221">source</a><pre class="code-header" data-language="rust">impl str</pre></section></summary><div class="docblock">
<p>Methods for string slices.</p> </div>
<div class="impl-items">
<summary><section id="method.into_boxed_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#236">source</a></span><pre class="code-header" data-language="rust">pub fn into_boxed_bytes(self: Box&lt;str&gt;) -&gt; Box&lt;[u8]&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>Box&lt;str&gt;</code> into a <code>Box&lt;[u8]&gt;</code> without copying or allocating.</p> <h5 id="examples-60">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is a string";
let boxed_str = s.to_owned().into_boxed_str();
let boxed_bytes = boxed_str.into_boxed_bytes();
assert_eq!(*boxed_bytes, *s.as_bytes());</pre></div> </div>
<summary><section id="method.replace" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#269">source</a><pre class="code-header" data-language="rust">pub fn replace&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;str) -&gt; String
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Replaces all matches of a pattern with another string.</p> <p><code>replace</code> creates a new <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice.</p> <h5 id="examples-61">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is old";

assert_eq!("this is new", s.replace("old", "new"));
assert_eq!("than an old", s.replace("is", "an"));</pre></div> <p>When the pattern doesnâ€™t match, it returns this string slice as <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is old";
assert_eq!(s, s.replace("cookie monster", "little lamb"));</pre></div> </div>
<summary><section id="method.replacen" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#309">source</a></span><pre class="code-header" data-language="rust">pub fn replacen&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;str, count: usize) -&gt; String
where
    P: Pattern&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Replaces first N matches of a pattern with another string.</p> <p><code>replacen</code> creates a new <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice at most <code>count</code> times.</p> <h5 id="examples-62">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "foo foo 123 foo";
assert_eq!("new new 123 foo", s.replacen("foo", "new", 2));
assert_eq!("faa fao 123 foo", s.replacen('o', "a", 3));
assert_eq!("foo foo new23 foo", s.replacen(char::is_numeric, "new", 1));</pre></div> <p>When the pattern doesnâ€™t match, it returns this string slice as <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is old";
assert_eq!(s, s.replacen("cookie monster", "little lamb", 10));</pre></div> </div>
<summary><section id="method.to_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#366">source</a></span><pre class="code-header" data-language="rust">pub fn to_lowercase(&amp;self) -&gt; String</pre></section></summary><div class="docblock">
<p>Returns the lowercase equivalent of this string slice, as a new <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>.</p> <p>â€˜Lowercaseâ€™ is defined according to the terms of the Unicode Derived Core Property <code>Lowercase</code>.</p> <p>Since some characters can expand into multiple characters when changing the case, this function returns a <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a> instead of modifying the parameter in-place.</p> <h5 id="examples-63">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "HELLO";

assert_eq!("hello", s.to_lowercase());</pre></div> <p>A tricky example, with sigma:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let sigma = "Î£";

assert_eq!("Ïƒ", sigma.to_lowercase());

// but at the end of a word, it's Ï‚, not Ïƒ:
let odysseus = "á½ˆÎ”Î¥Î£Î£Î•ÎÎ£";

assert_eq!("á½€Î´Ï…ÏƒÏƒÎµÏÏ‚", odysseus.to_lowercase());</pre></div> <p>Languages without case are not changed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let new_year = "å†œå†æ–°å¹´";

assert_eq!(new_year, new_year.to_lowercase());</pre></div> </div>
<summary><section id="method.to_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#457">source</a></span><pre class="code-header" data-language="rust">pub fn to_uppercase(&amp;self) -&gt; String</pre></section></summary><div class="docblock">
<p>Returns the uppercase equivalent of this string slice, as a new <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>.</p> <p>â€˜Uppercaseâ€™ is defined according to the terms of the Unicode Derived Core Property <code>Uppercase</code>.</p> <p>Since some characters can expand into multiple characters when changing the case, this function returns a <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a> instead of modifying the parameter in-place.</p> <h5 id="examples-64">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "hello";

assert_eq!("HELLO", s.to_uppercase());</pre></div> <p>Scripts without case are not changed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let new_year = "å†œå†æ–°å¹´";

assert_eq!(new_year, new_year.to_uppercase());</pre></div> <p>One character can become multiple:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "tschÃ¼ÃŸ";

assert_eq!("TSCHÃœSS", s.to_uppercase());</pre></div> </div>
<summary><section id="method.into_string" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#498">source</a></span><pre class="code-header" data-language="rust">pub fn into_string(self: Box&lt;str&gt;) -&gt; String</pre></section></summary><div class="docblock">
<p>Converts a <a href="boxed/struct.box.html" title="struct std::boxed::Box"><code>Box&lt;str&gt;</code></a> into a <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a> without copying or allocating.</p> <h5 id="examples-65">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let string = String::from("birthday gift");
let boxed_str = string.clone().into_boxed_str();

assert_eq!(boxed_str.into_string(), string);</pre></div> </div>
<summary><section id="method.repeat" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#527">source</a></span><pre class="code-header" data-language="rust">pub fn repeat(&amp;self, n: usize) -&gt; String</pre></section></summary><div class="docblock">
<p>Creates a new <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a> by repeating a string <code>n</code> times.</p> <h5 id="panics-2">Panics</h5> <p>This function will panic if the capacity would overflow.</p> <h5 id="examples-66">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("abc".repeat(4), String::from("abcabcabcabc"));</pre></div> <p>A panic upon overflow:</p> <div class="example-wrap should_panic">â“˜<pre class="rust rust-example-rendered" data-language="rust">// this will panic at runtime
let huge = "0123456789abcdef".repeat(usize::MAX);</pre>
</div> </div>
<summary><section id="method.to_ascii_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#557">source</a></span><pre class="code-header" data-language="rust">pub fn to_ascii_uppercase(&amp;self) -&gt; String</pre></section></summary><div class="docblock">
<p>Returns a copy of this string where each character is mapped to its ASCII upper case equivalent.</p> <p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™, but non-ASCII letters are unchanged.</p> <p>To uppercase the value in-place, use <a href="primitive.str.html#method.make_ascii_uppercase" title="method str::make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p> <p>To uppercase ASCII characters in addition to non-ASCII characters, use <a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p> <h5 id="examples-67">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "GrÃ¼ÃŸe, JÃ¼rgen â¤";

assert_eq!("GRÃ¼ÃŸE, JÃ¼RGEN â¤", s.to_ascii_uppercase());</pre></div> </div>
<summary><section id="method.to_ascii_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#589">source</a></span><pre class="code-header" data-language="rust">pub fn to_ascii_lowercase(&amp;self) -&gt; String</pre></section></summary><div class="docblock">
<p>Returns a copy of this string where each character is mapped to its ASCII lower case equivalent.</p> <p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™, but non-ASCII letters are unchanged.</p> <p>To lowercase the value in-place, use <a href="primitive.str.html#method.make_ascii_lowercase" title="method str::make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p> <p>To lowercase ASCII characters in addition to non-ASCII characters, use <a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p> <h5 id="examples-68">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "GrÃ¼ÃŸe, JÃ¼rgen â¤";

assert_eq!("grÃ¼ÃŸe, jÃ¼rgen â¤", s.to_ascii_lowercase());</pre></div> </div>
</div>
</div>
<h2 id="trait-implementations" class="small-section-header">Trait Implementations</h2>
<div id="trait-implementations-list">
<summary><section id="impl-Add%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#440">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Add&lt;&amp;'a str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-10" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = Cow&lt;'a, str&gt;</pre></section></summary><div class="docblock">The resulting type after applying the <code>+</code> operator.</div>
<summary><section id="method.add-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#444">source</a><pre class="code-header" data-language="rust">fn add(self, rhs: &amp;'a str) -&gt; &lt;Cow&lt;'a, str&gt; as Add&lt;&amp;'a str&gt;&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>+</code> operation. <a href="ops/trait.add.html#tymethod.add">Read more</a>
</div>
</div>
<summary><section id="impl-Add%3C%26str%3E-for-String" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2409">source</a><pre class="code-header" data-language="rust">impl Add&lt;&amp;str&gt; for String</pre></section></summary><div class="docblock">
<p>Implements the <code>+</code> operator for concatenating two strings.</p> <p>This consumes the <code>String</code> on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new <code>String</code> and copying the entire contents on every operation, which would lead to <em>O</em>(<em>n</em>^2) running time when building an <em>n</em>-byte string by repeated concatenation.</p> <p>The string on the right-hand side is only borrowed; its contents are copied into the returned <code>String</code>.</p> <h4 id="examples-71">Examples</h4> <p>Concatenating two <code>String</code>s takes the first by value and borrows the second:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = String::from("hello");
let b = String::from(" world");
let c = a + &amp;b;
// `a` is moved and can no longer be used here.</pre></div> <p>If you want to keep using the first <code>String</code>, you can clone it and append to the clone instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = String::from("hello");
let b = String::from(" world");
let c = a.clone() + &amp;b;
// `a` is still valid here.</pre></div> <p>Concatenating <code>&amp;str</code> slices can be done by converting the first to a <code>String</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = "hello";
let b = " world";
let c = a.to_string() + b;</pre></div> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-9" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = String</pre></section></summary><div class="docblock">The resulting type after applying the <code>+</code> operator.</div>
<summary><section id="method.add" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2413">source</a><pre class="code-header" data-language="rust">fn add(self, other: &amp;str) -&gt; String</pre></section></summary><div class="docblock">Performs the <code>+</code> operation. <a href="ops/trait.add.html#tymethod.add">Read more</a>
</div>
</div>
<summary><section id="impl-AddAssign%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#464">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; AddAssign&lt;&amp;'a str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.add_assign-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#465">source</a><pre class="code-header" data-language="rust">fn add_assign(&amp;mut self, rhs: &amp;'a str)</pre></section></summary><div class="docblock">Performs the <code>+=</code> operation. <a href="ops/trait.addassign.html#tymethod.add_assign">Read more</a>
</div>
</div>
<summary><section id="impl-AddAssign%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2424">source</a></span><pre class="code-header" data-language="rust">impl AddAssign&lt;&amp;str&gt; for String</pre></section></summary><div class="docblock">
<p>Implements the <code>+=</code> operator for appending to a <code>String</code>.</p> <p>This has the same behavior as the <a href="string/struct.string.html#method.push_str" title="method std::string::String::push_str"><code>push_str</code></a> method.</p> </div>
<div class="impl-items">
<summary><section id="method.add_assign" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2426">source</a><pre class="code-header" data-language="rust">fn add_assign(&amp;mut self, other: &amp;str)</pre></section></summary><div class="docblock">Performs the <code>+=</code> operation. <a href="ops/trait.addassign.html#tymethod.add_assign">Read more</a>
</div>
</div>
<summary><section id="impl-AsMut%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2740">source</a></span><pre class="code-header" data-language="rust">impl AsMut&lt;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.as_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2742">source</a><pre class="code-header" data-language="rust">fn as_mut(&amp;mut self) -&gt; &amp;mut str</pre></section></summary><div class="docblock">Converts this type into a mutable reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsMut%3Cstr%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#844">source</a></span><pre class="code-header" data-language="rust">impl AsMut&lt;str&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.as_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#846">source</a><pre class="code-header" data-language="rust">fn as_mut(&amp;mut self) -&gt; &amp;mut str</pre></section></summary><div class="docblock">Converts this type into a mutable reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3C%5Bu8%5D%3E-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2553">source</a><pre class="code-header" data-language="rust">impl AsRef&lt;[u8]&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2555">source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;[u8] â“˜</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3COsStr%3E-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1453-1458">source</a><pre class="code-header" data-language="rust">impl AsRef&lt;OsStr&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1455-1457">source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;OsStr</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3CPath%3E-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3163-3168">source</a><pre class="code-header" data-language="rust">impl AsRef&lt;Path&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3165-3167">source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;Path</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3Cstr%3E-for-Drain%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#3044">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; AsRef&lt;str&gt; for Drain&lt;'a&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#3045">source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3Cstr%3E-for-String" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2732">source</a><pre class="code-header" data-language="rust">impl AsRef&lt;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2734">source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3Cstr%3E-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#836">source</a><pre class="code-header" data-language="rust">impl AsRef&lt;str&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#838">source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsciiExt-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#207-211">source</a><pre class="code-header" data-language="rust">impl AsciiExt for str</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned-1" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Owned = String</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Container type for copied ASCII characters.</div>
<summary><section id="method.is_ascii-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#210">source</a><pre class="code-header" data-language="rust">fn is_ascii(&amp;self) -&gt; bool</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Checks if the value is within the ASCII range. <a href="ascii/trait.asciiext.html#tymethod.is_ascii">Read more</a>
</div>
<summary><section id="method.to_ascii_uppercase-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#210">source</a><pre class="code-header" data-language="rust">fn to_ascii_uppercase(&amp;self) -&gt; Self::Owned</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Makes a copy of the value in its ASCII upper case equivalent. <a href="ascii/trait.asciiext.html#tymethod.to_ascii_uppercase">Read more</a>
</div>
<summary><section id="method.to_ascii_lowercase-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#210">source</a><pre class="code-header" data-language="rust">fn to_ascii_lowercase(&amp;self) -&gt; Self::Owned</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Makes a copy of the value in its ASCII lower case equivalent. <a href="ascii/trait.asciiext.html#tymethod.to_ascii_lowercase">Read more</a>
</div>
<summary><section id="method.eq_ignore_ascii_case-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#210">source</a><pre class="code-header" data-language="rust">fn eq_ignore_ascii_case(&amp;self, o: &amp;Self) -&gt; bool</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Checks that two values are an ASCII case-insensitive match. <a href="ascii/trait.asciiext.html#tymethod.eq_ignore_ascii_case">Read more</a>
</div>
<summary><section id="method.make_ascii_uppercase-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#210">source</a><pre class="code-header" data-language="rust">fn make_ascii_uppercase(&amp;mut self)</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Converts this type to its ASCII upper case equivalent in-place. <a href="ascii/trait.asciiext.html#tymethod.make_ascii_uppercase">Read more</a>
</div>
<summary><section id="method.make_ascii_lowercase-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#210">source</a><pre class="code-header" data-language="rust">fn make_ascii_lowercase(&amp;mut self)</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Converts this type to its ASCII lower case equivalent in-place. <a href="ascii/trait.asciiext.html#tymethod.make_ascii_lowercase">Read more</a>
</div>
</div>
<summary><section id="impl-Borrow%3Cstr%3E-for-String" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#188">source</a><pre class="code-header" data-language="rust">impl Borrow&lt;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#190">source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="borrow/trait.borrow.html#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-BorrowMut%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#196">source</a></span><pre class="code-header" data-language="rust">impl BorrowMut&lt;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#198">source</a><pre class="code-header" data-language="rust">fn borrow_mut(&amp;mut self) -&gt; &amp;mut str</pre></section></summary><div class="docblock">Mutably borrows from an owned value. <a href="borrow/trait.borrowmut.html#tymethod.borrow_mut">Read more</a>
</div>
</div>
<summary><section id="impl-Clone-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1327">source</a></span><pre class="code-header" data-language="rust">impl Clone for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1328">source</a><pre class="code-header" data-language="rust">fn clone(&amp;self) -&gt; Box&lt;str&gt;</pre></section></summary><div class="docblock">Returns a copy of the value. <a href="clone/trait.clone.html#tymethod.clone">Read more</a>
</div>
<summary><section id="method.clone_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/clone.rs.html#169">source</a><pre class="code-header" data-language="rust">fn clone_from(&amp;mut self, source: &amp;Self)</pre></section></summary><div class="docblock">Performs copy-assignment from <code>source</code>. <a href="clone/trait.clone.html#method.clone_from">Read more</a>
</div>
</div>
<summary><section id="impl-Concat%3Cstr%3E-for-%5BS%5D" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#61">source</a><pre class="code-header" data-language="rust">impl&lt;S&gt; Concat&lt;str&gt; for [S]
where
    S: Borrow&lt;str&gt;,</pre></section></summary><div class="docblock">
<p>Note: <code>str</code> in <code>Concat&lt;str&gt;</code> is not meaningful here. This type parameter of the trait only exists to enable another impl.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-11" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = String</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span>
</div></span><div class="docblock">The resulting type after concatenation</div>
<summary><section id="method.concat" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#64">source</a><pre class="code-header" data-language="rust">fn concat(slice: &amp;[S]) -&gt; String</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span>
</div></span><div class="docblock">Implementation of <a href="primitive.slice.html#method.concat" title="method slice::concat"><code>[T]::concat</code></a>
</div>
</div>
<summary><section id="impl-Debug-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2338">source</a><pre class="code-header" data-language="rust">impl Debug for str</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2339">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="fmt/trait.debug.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Default-for-%26mut+str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2570">source</a></span><pre class="code-header" data-language="rust">impl Default for &amp;mut str</pre></section></summary><div class="impl-items">
<summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2573">source</a><pre class="code-header" data-language="rust">fn default() -&gt; &amp;mut str</pre></section></summary><div class="docblock">
<p>Creates an empty mutable str</p> </div>
</div>
<summary><section id="impl-Default-for-%26str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2561">source</a><pre class="code-header" data-language="rust">impl Default for &amp;str</pre></section></summary><div class="impl-items">
<summary><section id="method.default-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2564">source</a><pre class="code-header" data-language="rust">fn default() -&gt; &amp;str</pre></section></summary><div class="docblock">
<p>Creates an empty str</p> </div>
</div>
<summary><section id="impl-Default-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1263">source</a></span><pre class="code-header" data-language="rust">impl Default for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.default-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1265">source</a><pre class="code-header" data-language="rust">fn default() -&gt; Box&lt;str&gt;</pre></section></summary><div class="docblock">Returns the â€œdefault valueâ€ for a type. <a href="default/trait.default.html#tymethod.default">Read more</a>
</div>
</div>
<summary><section id="impl-Display-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2363">source</a><pre class="code-header" data-language="rust">impl Display for str</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2364">source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="fmt/trait.display.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Error-for-%26str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2635">source</a><pre class="code-header" data-language="rust">impl !Error for &amp;str</pre></section></summary><div class="impl-items">
<summary><section id="method.source" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span><a class="src" href="https://doc.rust-lang.org/src/core/error.rs.html#84">source</a></span><pre class="code-header" data-language="rust">fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt;</pre></section></summary><div class="docblock">The lower-level source of this error, if any. <a href="error/trait.error.html#method.source">Read more</a>
</div>
<summary><section id="method.description" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/error.rs.html#110">source</a><pre class="code-header" data-language="rust">fn description(&amp;self) -&gt; &amp;str</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.42.0: use the Display impl or to_string()</span>
</div></span><div class="docblock"> <a href="error/trait.error.html#method.description">Read more</a>
</div>
<summary><section id="method.cause" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/error.rs.html#120">source</a><pre class="code-header" data-language="rust">fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt;</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: replaced by Error::source, which can support downcasting</span>
</div></span><summary><section id="method.provide" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/error.rs.html#184">source</a><pre class="code-header" data-language="rust">fn provide&lt;'a&gt;(&amp;'a self, request: &amp;mut Request&lt;'a&gt;)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>error_generic_member_access</code> <a href="https://github.com/rust-lang/rust/issues/99301">#99301</a>)</span>
</div></span><div class="docblock">Provides type based access to context intended for error reports. <a href="error/trait.error.html#method.provide">Read more</a>
</div>
</div>
<summary><section id="impl-Extend%3C%26str%3E-for-String" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2208">source</a><pre class="code-header" data-language="rust">impl&lt;'a&gt; Extend&lt;&amp;'a str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.extend" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2209">source</a><pre class="code-header" data-language="rust">fn extend&lt;I&gt;(&amp;mut self, iter: I)
where
    I: IntoIterator&lt;Item = &amp;'a str&gt;,</pre></section></summary><div class="docblock">Extends a collection with the contents of an iterator. <a href="iter/trait.extend.html#tymethod.extend">Read more</a>
</div>
<summary><section id="method.extend_one" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2214">source</a><pre class="code-header" data-language="rust">fn extend_one(&amp;mut self, s: &amp;'a str)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span>
</div></span><div class="docblock">Extends a collection with exactly one element.</div>
<summary><section id="method.extend_reserve" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/collect.rs.html#384">source</a><pre class="code-header" data-language="rust">fn extend_reserve(&amp;mut self, additional: usize)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span>
</div></span><div class="docblock">Reserves capacity in a collection for the given number of additional elements. <a href="iter/trait.extend.html#method.extend_reserve">Read more</a>
</div>
</div>
<summary><section id="impl-From%3C%26mut+str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2769">source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;mut str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2774">source</a><pre class="code-header" data-language="rust">fn from(s: &amp;mut str) -&gt; String</pre></section></summary><div class="docblock">
<p>Converts a <code>&amp;mut str</code> into a <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>.</p> <p>The result is allocated on the heap.</p> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Arc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3315">source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for Arc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3326">source</a><pre class="code-header" data-language="rust">fn from(v: &amp;str) -&gt; Arc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Allocate a reference-counted <code>str</code> and copy <code>v</code> into it.</p> <h5 id="example-1">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let shared: Arc&lt;str&gt; = Arc::from("eggplant");
assert_eq!("eggplant", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Box%3Cdyn+Error%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#2369">source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for Box&lt;dyn Error&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#2384">source</a><pre class="code-header" data-language="rust">fn from(err: &amp;str) -&gt; Box&lt;dyn Error&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="primitive.str.html" title="primitive str"><code>str</code></a> into a box of dyn <a href="error/trait.error.html" title="trait std::error::Error"><code>Error</code></a>.</p> <h5 id="examples-73">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::error::Error;
use std::mem;

let a_str_error = "a str error";
let a_boxed_error = Box::&lt;dyn Error&gt;::from(a_str_error);
assert!(mem::size_of::&lt;Box&lt;dyn Error&gt;&gt;() == mem::size_of_val(&amp;a_boxed_error))</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Box%3Cdyn+Error+%2B+Send+%2B+Sync%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#2345">source</a><pre class="code-header" data-language="rust">impl&lt;'a&gt; From&lt;&amp;str&gt; for Box&lt;dyn Error + Send + Sync + 'a&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#2362">source</a><pre class="code-header" data-language="rust">fn from(err: &amp;str) -&gt; Box&lt;dyn Error + Send + Sync + 'a&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="primitive.str.html" title="primitive str"><code>str</code></a> into a box of dyn <a href="error/trait.error.html" title="trait std::error::Error"><code>Error</code></a> + <a href="marker/trait.send.html" title="trait std::marker::Send"><code>Send</code></a> + <a href="marker/trait.sync.html" title="trait std::marker::Sync"><code>Sync</code></a>.</p> <h5 id="examples-72">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::error::Error;
use std::mem;

let a_str_error = "a str error";
let a_boxed_error = Box::&lt;dyn Error + Send + Sync&gt;::from(a_str_error);
assert!(
    mem::size_of::&lt;Box&lt;dyn Error + Send + Sync&gt;&gt;() == mem::size_of_val(&amp;a_boxed_error))</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1549">source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1562">source</a><pre class="code-header" data-language="rust">fn from(s: &amp;str) -&gt; Box&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>&amp;str</code> into a <code>Box&lt;str&gt;</code></p> <p>This conversion allocates on the heap and performs a copy of <code>s</code>.</p> <h5 id="examples-77">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let boxed: Box&lt;str&gt; = Box::from("hello");
println!("{boxed}");</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2857">source</a><pre class="code-header" data-language="rust">impl&lt;'a&gt; From&lt;&amp;'a str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2871">source</a><pre class="code-header" data-language="rust">fn from(s: &amp;'a str) -&gt; Cow&lt;'a, str&gt;</pre></section></summary><div class="docblock">
<p>Converts a string slice into a <a href="borrow/enum.cow.html#variant.Borrowed" title="borrow::Cow::Borrowed"><code>Borrowed</code></a> variant. No heap allocation is performed, and the string is not copied.</p> <h5 id="example-2">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!(Cow::from("eggplant"), Cow::Borrowed("eggplant"));</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Rc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2453">source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for Rc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2464">source</a><pre class="code-header" data-language="rust">fn from(v: &amp;str) -&gt; Rc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Allocate a reference-counted string slice and copy <code>v</code> into it.</p> <h5 id="example">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let shared: Rc&lt;str&gt; = Rc::from("statue");
assert_eq!("statue", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-String" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2757">source</a><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.from-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2762">source</a><pre class="code-header" data-language="rust">fn from(s: &amp;str) -&gt; String</pre></section></summary><div class="docblock">
<p>Converts a <code>&amp;str</code> into a <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>.</p> <p>The result is allocated on the heap.</p> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Vec%3Cu8%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#3284">source</a><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for Vec&lt;u8&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#3292">source</a><pre class="code-header" data-language="rust">fn from(s: &amp;str) -&gt; Vec&lt;u8&gt; â“˜</pre></section></summary><div class="docblock">
<p>Allocate a <code>Vec&lt;u8&gt;</code> and fill it with a UTF-8 string.</p> <h5 id="examples-74">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!(Vec::from("123"), vec![b'1', b'2', b'3']);</pre></div> </div>
</div>
<summary><section id="impl-From%3CCow%3C'_,+str%3E%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1569">source</a></span><pre class="code-header" data-language="rust">impl From&lt;Cow&lt;'_, str&gt;&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1594">source</a><pre class="code-header" data-language="rust">fn from(cow: Cow&lt;'_, str&gt;) -&gt; Box&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>Cow&lt;'_, str&gt;</code> into a <code>Box&lt;str&gt;</code></p> <p>When <code>cow</code> is the <code>Cow::Borrowed</code> variant, this conversion allocates on the heap and copies the underlying <code>str</code>. Otherwise, it will try to reuse the owned <code>String</code>â€™s allocation.</p> <h5 id="examples-76">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::borrow::Cow;

let unboxed = Cow::Borrowed("hello");
let boxed: Box&lt;str&gt; = Box::from(unboxed);
println!("{boxed}");</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let unboxed = Cow::Owned("hello".to_string());
let boxed: Box&lt;str&gt; = Box::from(unboxed);
println!("{boxed}");</pre></div> </div>
</div>
<summary><section id="impl-From%3CString%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2814">source</a></span><pre class="code-header" data-language="rust">impl From&lt;String&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2826">source</a><pre class="code-header" data-language="rust">fn from(s: String) -&gt; Box&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Converts the given <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a> to a boxed <code>str</code> slice that is owned.</p> <h5 id="examples-75">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s1: String = String::from("hello world");
let s2: Box&lt;str&gt; = Box::from(s1);
let s3: String = String::from(s2);

assert_eq!("hello world", s3)</pre></div> </div>
</div>
<summary><section id="impl-FromIterator%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2931">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; FromIterator&lt;&amp;'b str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2932">source</a><pre class="code-header" data-language="rust">fn from_iter&lt;I&gt;(it: I) -&gt; Cow&lt;'a, str&gt;
where
    I: IntoIterator&lt;Item = &amp;'b str&gt;,</pre></section></summary><div class="docblock">Creates a value from an iterator. <a href="iter/trait.fromiterator.html#tymethod.from_iter">Read more</a>
</div>
</div>
<summary><section id="impl-FromIterator%3C%26str%3E-for-String" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2110">source</a><pre class="code-header" data-language="rust">impl&lt;'a&gt; FromIterator&lt;&amp;'a str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2111">source</a><pre class="code-header" data-language="rust">fn from_iter&lt;I&gt;(iter: I) -&gt; String
where
    I: IntoIterator&lt;Item = &amp;'a str&gt;,</pre></section></summary><div class="docblock">Creates a value from an iterator. <a href="iter/trait.fromiterator.html#tymethod.from_iter">Read more</a>
</div>
</div>
<summary><section id="impl-Hash-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#864">source</a><pre class="code-header" data-language="rust">impl Hash for str</pre></section></summary><div class="impl-items">
<summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#866">source</a><pre class="code-header" data-language="rust">fn hash&lt;H&gt;(&amp;self, state: &amp;mut H)
where
    H: Hasher,</pre></section></summary><div class="docblock">Feeds this value into the given <a href="hash/trait.hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.hash.html#tymethod.hash">Read more</a>
</div>
</div>
<summary><section id="impl-Index%3CI%3E-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#53-55">source</a><pre class="code-header" data-language="rust">impl&lt;I&gt; Index&lt;I&gt; for str
where
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = &lt;I as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><div class="docblock">The returned type after indexing.</div>
<summary><section id="method.index" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#60">source</a><pre class="code-header" data-language="rust">fn index(&amp;self, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><div class="docblock">Performs the indexing (<code>container[index]</code>) operation. <a href="ops/trait.index.html#tymethod.index">Read more</a>
</div>
</div>
<summary><section id="impl-IndexMut%3CI%3E-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#66-68">source</a><pre class="code-header" data-language="rust">impl&lt;I&gt; IndexMut&lt;I&gt; for str
where
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.index_mut-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#71">source</a><pre class="code-header" data-language="rust">fn index_mut(&amp;mut self, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><div class="docblock">Performs the mutable indexing (<code>container[index]</code>) operation. <a href="ops/trait.indexmut.html#tymethod.index_mut">Read more</a>
</div>
</div>
<summary><section id="impl-Join%3C%26str%3E-for-%5BS%5D" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#71">source</a><pre class="code-header" data-language="rust">impl&lt;S&gt; Join&lt;&amp;str&gt; for [S]
where
    S: Borrow&lt;str&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-8" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = String</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span>
</div></span><div class="docblock">The resulting type after concatenation</div>
<summary><section id="method.join" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#74">source</a><pre class="code-header" data-language="rust">fn join(slice: &amp;[S], sep: &amp;str) -&gt; String</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span>
</div></span><div class="docblock">Implementation of <a href="primitive.slice.html#method.join" title="method slice::join"><code>[T]::join</code></a>
</div>
</div>
<summary><section id="impl-Ord-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#19">source</a><pre class="code-header" data-language="rust">impl Ord for str</pre></section></summary><div class="docblock">
<p>Implements ordering of strings.</p> <p>Strings are ordered <a href="cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">lexicographically</a> by their byte values. This orders Unicode code points based on their positions in the code charts. This is not necessarily the same as â€œalphabeticalâ€ order, which varies by language and locale. Sorting strings according to culturally-accepted standards requires locale-specific data that is outside the scope of the <code>str</code> type.</p> </div>
<div class="impl-items">
<summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#21">source</a><pre class="code-header" data-language="rust">fn cmp(&amp;self, other: &amp;str) -&gt; Ordering</pre></section></summary><div class="docblock">This method returns an <a href="cmp/enum.ordering.html" title="enum std::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.ord.html#tymethod.cmp">Read more</a>
</div>
</div>
<summary><section id="impl-PartialEq%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2333">source</a><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'b str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2333">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;'b str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2333">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;&amp;'b str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3C%26str%3E-for-OsString" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#643-648">source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;&amp;str&gt; for OsString</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#645-647">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3C%26str%3E-for-String" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2329">source</a><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2329">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;'a str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2329">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;&amp;'a str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-%26str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2333">source</a><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;Cow&lt;'a, str&gt;&gt; for &amp;'b str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2333">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2333">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2331">source</a><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;Cow&lt;'a, str&gt;&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2331">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2331">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3COsStr%3E-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1282-1287">source</a><pre class="code-header" data-language="rust">impl PartialEq&lt;OsStr&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-13" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1284-1286">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;OsStr) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-13" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3COsString%3E-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#651-656">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialEq&lt;OsString&gt; for &amp;'a str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-14" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#653-655">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;OsString) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-14" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3COsString%3E-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#635-640">source</a><pre class="code-header" data-language="rust">impl PartialEq&lt;OsString&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#637-639">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;OsString) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CString%3E-for-%26str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2329">source</a><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;String&gt; for &amp;'a str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2329">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;String) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2329">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;String) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CString%3E-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2328">source</a><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;String&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2328">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;String) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2328">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;String) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-for-Cow%3C'a,+str%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2331">source</a><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2331">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2331">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-for-OsStr" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1274-1279">source</a><pre class="code-header" data-language="rust">impl PartialEq&lt;str&gt; for OsStr</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-11" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1276-1278">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-11" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-for-OsString" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#627-632">source</a><pre class="code-header" data-language="rust">impl PartialEq&lt;str&gt; for OsString</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-12" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#629-631">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-12" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-for-String" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2328">source</a><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2328">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2328">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#27">source</a><pre class="code-header" data-language="rust">impl PartialEq for str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#29">source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#239">source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialOrd%3Cstr%3E-for-OsStr" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1317-1322">source</a><pre class="code-header" data-language="rust">impl PartialOrd&lt;str&gt; for OsStr</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1319-1321">source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;str) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord.html#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1122">source</a><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord.html#method.lt">Read more</a>
</div>
<summary><section id="method.le-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1139">source</a><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord.html#method.le">Read more</a>
</div>
<summary><section id="method.gt-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1155">source</a><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord.html#method.gt">Read more</a>
</div>
<summary><section id="method.ge-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1172">source</a><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord.html#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3Cstr%3E-for-OsString" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#686-691">source</a><pre class="code-header" data-language="rust">impl PartialOrd&lt;str&gt; for OsString</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#688-690">source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;str) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord.html#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1122">source</a><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord.html#method.lt">Read more</a>
</div>
<summary><section id="method.le-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1139">source</a><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord.html#method.le">Read more</a>
</div>
<summary><section id="method.gt-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1155">source</a><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord.html#method.gt">Read more</a>
</div>
<summary><section id="method.ge-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1172">source</a><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord.html#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#45">source</a><pre class="code-header" data-language="rust">impl PartialOrd for str</pre></section></summary><div class="docblock">
<p>Implements comparison operations on strings.</p> <p>Strings are compared <a href="cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">lexicographically</a> by their byte values. This compares Unicode code points based on their positions in the code charts. This is not necessarily the same as â€œalphabeticalâ€ order, which varies by language and locale. Comparing strings according to culturally-accepted standards requires locale-specific data that is outside the scope of the <code>str</code> type.</p> </div>
<div class="impl-items">
<summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#47">source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;str) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord.html#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1122">source</a><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord.html#method.lt">Read more</a>
</div>
<summary><section id="method.le" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1139">source</a><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord.html#method.le">Read more</a>
</div>
<summary><section id="method.gt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1155">source</a><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord.html#method.gt">Read more</a>
</div>
<summary><section id="method.ge" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1172">source</a><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord.html#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-Pattern%3C'a%3E-for-%26str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#940">source</a><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; Pattern&lt;'a&gt; for &amp;'b str</pre></section></summary><div class="docblock">
<p>Non-allocating substring search.</p> <p>Will handle the pattern <code>""</code> as returning empty matches at each character boundary.</p> <h4 id="examples-69">Examples</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("Hello world".find("world"), Some(6));</pre></div> </div>
<div class="impl-items">
<summary><section id="method.is_prefix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#950">source</a><pre class="code-header" data-language="rust">fn is_prefix_of(self, haystack: &amp;'a str) -&gt; bool</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span></summary><div class="docblock">
<p>Checks whether the pattern matches at the front of the haystack.</p> </div>
<summary><section id="method.is_contained_in" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#956">source</a><pre class="code-header" data-language="rust">fn is_contained_in(self, haystack: &amp;'a str) -&gt; bool</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span></summary><div class="docblock">
<p>Checks whether the pattern matches anywhere in the haystack</p> </div>
<summary><section id="method.strip_prefix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#982">source</a><pre class="code-header" data-language="rust">fn strip_prefix_of(self, haystack: &amp;'a str) -&gt; Option&lt;&amp;'a str&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span></summary><div class="docblock">
<p>Removes the pattern from the front of haystack, if it matches.</p> </div>
<summary><section id="method.is_suffix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#993">source</a><pre class="code-header" data-language="rust">fn is_suffix_of(self, haystack: &amp;'a str) -&gt; bool</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span></summary><div class="docblock">
<p>Checks whether the pattern matches at the back of the haystack.</p> </div>
<summary><section id="method.strip_suffix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#999">source</a><pre class="code-header" data-language="rust">fn strip_suffix_of(self, haystack: &amp;'a str) -&gt; Option&lt;&amp;'a str&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span></summary><div class="docblock">
<p>Removes the pattern from the back of haystack, if it matches.</p> </div>
<summary><section id="associatedtype.Searcher" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Searcher = StrSearcher&lt;'a, 'b&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Associated searcher for this pattern</div>
<summary><section id="method.into_searcher" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#944">source</a><pre class="code-header" data-language="rust">fn into_searcher(self, haystack: &amp;'a str) -&gt; StrSearcher&lt;'a, 'b&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Constructs the associated searcher from <code>self</code> and the <code>haystack</code> to search in.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-(Bound%3Cusize%3E,+Bound%3Cusize%3E)" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#269">source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for (Bound&lt;usize&gt;, Bound&lt;usize&gt;)</pre></section></summary><div class="docblock">
<p>Implements substring slicing for arbitrary bounds.</p> <p>Returns a slice of the given string bounded by the byte indices provided by each bound.</p> <p>This operation is <em>O</em>(1).</p> <h4 id="panics-4">Panics</h4> <p>Panics if <code>begin</code> or <code>end</code> (if it exists and once adjusted for inclusion/exclusion) does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), if <code>begin &gt; end</code>, or if <code>end &gt; len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#273">source</a><pre class="code-header" data-language="rust">fn get(self, slice: &amp;str) -&gt; Option&lt;&amp;str&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#278">source</a><pre class="code-header" data-language="rust">fn get_mut(self, slice: &amp;mut str) -&gt; Option&lt;&amp;mut str&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#283">source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked(self, slice: *const str) -&gt; *const str</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.get_unchecked_mut-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#290">source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(self, slice: *mut str) -&gt; *mut str</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.index-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#297">source</a><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;str</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#302">source</a><pre class="code-header" data-language="rust">fn index_mut(self, slice: &amp;mut str) -&gt; &amp;mut str</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#162">source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for Range&lt;usize&gt;</pre></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[begin .. end]</code> or <code>&amp;mut self[begin .. end]</code>.</p> <p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>end</code>).</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <h4 id="panics-5">Panics</h4> <p>Panics if <code>begin</code> or <code>end</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), if <code>begin &gt; end</code>, or if <code>end &gt; len</code>.</p> <h4 id="examples-70">Examples</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";
assert_eq!(&amp;s[0 .. 1], "L");

assert_eq!(&amp;s[1 .. 9], "Ã¶we è€");

// these will panic:
// byte 2 lies within `Ã¶`:
// &amp;s[2 ..3];

// byte 8 lies within `è€`
// &amp;s[1 .. 8];

// byte 100 is outside the string
// &amp;s[3 .. 100];</pre></div> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-3" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#165">source</a></span><pre class="code-header" data-language="rust">fn get(self, slice: &amp;str) -&gt; Option&lt;&amp;&lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-3" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#179">source</a></span><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str
) -&gt; Option&lt;&amp;mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-3" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#192">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str
) -&gt; *const &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.get_unchecked_mut-3" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#215">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str
) -&gt; *mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.index-3" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#231">source</a></span><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;&lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output â“˜</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-2" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#239">source</a></span><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str
) -&gt; &amp;mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output â“˜</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#393">source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeFrom&lt;usize&gt;</pre></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[begin ..]</code> or <code>&amp;mut self[begin ..]</code>.</p> <p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>len</code>). Equivalent to <code>&amp;self[begin .. len]</code> or <code>&amp;mut self[begin .. len]</code>.</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <h4 id="panics-8">Panics</h4> <p>Panics if <code>begin</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), or if <code>begin &gt; len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-7" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#396">source</a></span><pre class="code-header" data-language="rust">fn get(
    self,
    slice: &amp;str
) -&gt; Option&lt;&amp;&lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-7" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#406">source</a></span><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str
) -&gt; Option&lt;&amp;mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-7" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#416">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str
) -&gt; *const &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.get_unchecked_mut-7" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#422">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str
) -&gt; *mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.index-7" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#428">source</a></span><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;&lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output â“˜</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-6" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#436">source</a></span><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str
) -&gt; &amp;mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output â“˜</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeFull" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#97">source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeFull</pre></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[..]</code> or <code>&amp;mut self[..]</code>.</p> <p>Returns a slice of the whole string, i.e., returns <code>&amp;self</code> or <code>&amp;mut self</code>. Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>. Unlike other indexing operations, this can never panic.</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <p>Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-4" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#100">source</a></span><pre class="code-header" data-language="rust">fn get(self, slice: &amp;str) -&gt; Option&lt;&amp;&lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-4" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#104">source</a></span><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str
) -&gt; Option&lt;&amp;mut &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-4" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#108">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str
) -&gt; *const &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.get_unchecked_mut-4" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#112">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str
) -&gt; *mut &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.index-4" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#116">source</a></span><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;&lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-3" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#120">source</a></span><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str
) -&gt; &amp;mut &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: unstable)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#465">source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeInclusive&lt;usize&gt;</pre></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[begin ..= end]</code> or <code>&amp;mut self[begin ..= end]</code>.</p> <p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>end</code>]. Equivalent to <code>&amp;self [begin .. end + 1]</code> or <code>&amp;mut self[begin .. end + 1]</code>, except if <code>end</code> has the maximum value for <code>usize</code>.</p> <p>This operation is <em>O</em>(1).</p> <h4 id="panics-7">Panics</h4> <p>Panics if <code>begin</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), if <code>end</code> does not point to the ending byte offset of a character (<code>end + 1</code> is either a starting byte offset or equal to <code>len</code>), if <code>begin &gt; end</code>, or if <code>end &gt;= len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-6" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#468">source</a></span><pre class="code-header" data-language="rust">fn get(
    self,
    slice: &amp;str
) -&gt; Option&lt;&amp;&lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-6" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#472">source</a></span><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str
) -&gt; Option&lt;&amp;mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-6" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#476">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str
) -&gt; *const &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.get_unchecked_mut-6" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#481">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str
) -&gt; *mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.index-6" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#486">source</a></span><pre class="code-header" data-language="rust">fn index(
    self,
    slice: &amp;str
) -&gt; &amp;&lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output â“˜</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-5" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#493">source</a></span><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str
) -&gt; &amp;mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output â“˜</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeTo%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#324">source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeTo&lt;usize&gt;</pre></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[.. end]</code> or <code>&amp;mut self[.. end]</code>.</p> <p>Returns a slice of the given string from the byte range [0, <code>end</code>). Equivalent to <code>&amp;self[0 .. end]</code> or <code>&amp;mut self[0 .. end]</code>.</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <h4 id="panics-6">Panics</h4> <p>Panics if <code>end</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), or if <code>end &gt; len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-5" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#327">source</a></span><pre class="code-header" data-language="rust">fn get(
    self,
    slice: &amp;str
) -&gt; Option&lt;&amp;&lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-5" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#337">source</a></span><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str
) -&gt; Option&lt;&amp;mut &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-5" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#347">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str
) -&gt; *const &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.get_unchecked_mut-5" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#352">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str
) -&gt; *mut &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.index-5" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#357">source</a></span><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;&lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-4" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#365">source</a></span><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str
) -&gt; &amp;mut &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeToInclusive%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: unstable)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#517">source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeToInclusive&lt;usize&gt;</pre></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[..= end]</code> or <code>&amp;mut self[..= end]</code>.</p> <p>Returns a slice of the given string from the byte range [0, <code>end</code>]. Equivalent to <code>&amp;self [0 .. end + 1]</code>, except if <code>end</code> has the maximum value for <code>usize</code>.</p> <p>This operation is <em>O</em>(1).</p> <h4 id="panics-3">Panics</h4> <p>Panics if <code>end</code> does not point to the ending byte offset of a character (<code>end + 1</code> is either a starting byte offset as defined by <code>is_char_boundary</code>, or equal to <code>len</code>), or if <code>end &gt;= len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-1" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#520">source</a></span><pre class="code-header" data-language="rust">fn get(
    self,
    slice: &amp;str
) -&gt; Option&lt;&amp;&lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-1" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#524">source</a></span><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str
) -&gt; Option&lt;&amp;mut &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-1" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#528">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str
) -&gt; *const &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.get_unchecked_mut-1" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#533">source</a></span><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str
) -&gt; *mut &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used.</div>
<summary><section id="method.index-1" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#538">source</a></span><pre class="code-header" data-language="rust">fn index(
    self,
    slice: &amp;str
) -&gt; &amp;&lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: unstable</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#542">source</a></span><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str
) -&gt; &amp;mut &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-ToOwned-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#205">source</a><pre class="code-header" data-language="rust">impl ToOwned for str</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Owned = String</pre></section></summary><div class="docblock">The resulting type after obtaining ownership.</div>
<summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#208">source</a><pre class="code-header" data-language="rust">fn to_owned(&amp;self) -&gt; String</pre></section></summary><div class="docblock">Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.toowned.html#tymethod.to_owned">Read more</a>
</div>
<summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#212">source</a><pre class="code-header" data-language="rust">fn clone_into(&amp;self, target: &amp;mut String)</pre></section></summary><div class="docblock">Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.toowned.html#method.clone_into">Read more</a>
</div>
</div>
<summary><section id="impl-ToSocketAddrs-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/net/socket_addr.rs.html#280-290">source</a><pre class="code-header" data-language="rust">impl ToSocketAddrs for str</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Iter" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Iter = IntoIter&lt;SocketAddr&gt;</pre></section></summary><div class="docblock">Returned iterator over socket addresses which this type may correspond to.</div>
<summary><section id="method.to_socket_addrs" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/net/socket_addr.rs.html#282-289">source</a><pre class="code-header" data-language="rust">fn to_socket_addrs(&amp;self) -&gt; Result&lt;IntoIter&lt;SocketAddr&gt;&gt;</pre></section></summary><div class="docblock">Converts this object to an iterator of resolved <a href="net/enum.socketaddr.html" title="enum std::net::SocketAddr"><code>SocketAddr</code></a>s. <a href="net/trait.tosocketaddrs.html#tymethod.to_socket_addrs">Read more</a>
</div>
</div>
<summary><section id="impl-TryFrom%3C%26OsStr%3E-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.72.0">1.72.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1230-1245">source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; TryFrom&lt;&amp;'a OsStr&gt; for &amp;'a str</pre></section></summary><div class="impl-items">
<summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1242-1244">source</a><pre class="code-header" data-language="rust">fn try_from(value: &amp;'a OsStr) -&gt; Result&lt;Self, Self::Error&gt;</pre></section></summary><div class="docblock">
<p>Tries to convert an <code>&amp;OsStr</code> to a <code>&amp;str</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::ffi::OsStr;

let os_str = OsStr::new("foo");
let as_str = &lt;&amp;str&gt;::try_from(os_str).unwrap();
assert_eq!(as_str, "foo");</pre></div> </div>
<summary><section id="associatedtype.Error" class="associatedtype trait-impl"><pre class="code-header" data-language="rust">type Error = Utf8Error</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
</div>
<section id="impl-ConstParamTy-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/marker.rs.html#1028-1039">source</a><pre class="code-header" data-language="rust">impl ConstParamTy for str</pre></section><section id="impl-Eq-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#35">source</a><pre class="code-header" data-language="rust">impl Eq for str</pre></section><section id="impl-StructuralEq-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/marker.rs.html#283-295">source</a><pre class="code-header" data-language="rust">impl StructuralEq for str</pre></section><section id="impl-StructuralPartialEq-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/marker.rs.html#214-226">source</a><pre class="code-header" data-language="rust">impl StructuralPartialEq for str</pre></section>
</div>
<h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations</h2>
<div id="synthetic-implementations-list">
<section id="impl-RefUnwindSafe-for-str" class="impl"><pre class="code-header" data-language="rust">impl RefUnwindSafe for str</pre></section><section id="impl-Send-for-str" class="impl"><pre class="code-header" data-language="rust">impl Send for str</pre></section><section id="impl-Sized-for-str" class="impl"><pre class="code-header" data-language="rust">impl !Sized for str</pre></section><section id="impl-Sync-for-str" class="impl"><pre class="code-header" data-language="rust">impl Sync for str</pre></section><section id="impl-Unpin-for-str" class="impl"><pre class="code-header" data-language="rust">impl Unpin for str</pre></section><section id="impl-UnwindSafe-for-str" class="impl"><pre class="code-header" data-language="rust">impl UnwindSafe for str</pre></section>
</div>
<h2 id="blanket-implementations" class="small-section-header">Blanket Implementations</h2>
<div id="blanket-implementations-list">
<summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#135">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Any for T
where
    T: 'static + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#136">source</a><pre class="code-header" data-language="rust">fn type_id(&amp;self) -&gt; TypeId</pre></section></summary><div class="docblock">Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.any.html#tymethod.type_id">Read more</a>
</div>
</div>
<summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#208">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Borrow&lt;T&gt; for T
where
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#210">source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="borrow/trait.borrow.html#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#216">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; BorrowMut&lt;T&gt; for T
where
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217">source</a><pre class="code-header" data-language="rust">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</pre></section></summary><div class="docblock">Mutably borrows from an owned value. <a href="borrow/trait.borrowmut.html#tymethod.borrow_mut">Read more</a>
</div>
</div>
<summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2600">source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; ToString for T
where
    T: Display + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2606">source</a><pre class="code-header" data-language="rust">default fn to_string(&amp;self) -&gt; String</pre></section></summary><div class="docblock">Converts the given value to a <code>String</code>. <a href="string/trait.tostring.html#tymethod.to_string">Read more</a>
</div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/primitive.str.html" class="_attribution-link">https://doc.rust-lang.org/std/primitive.str.html</a>
  </p>
</div>
