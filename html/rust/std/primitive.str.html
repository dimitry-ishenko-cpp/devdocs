<h1 class="main-heading">Primitive Type str</h1>
<p>String slices.</p> <p><em><a href="str/index.html" title="mod std::str">See also the <code>std::str</code> module</a>.</em></p> <p>The <code>str</code> type, also called a ‘string slice’, is the most primitive string type. It is usually seen in its borrowed form, <code>&amp;str</code>. It is also the type of string literals, <code>&amp;'static str</code>.</p> <h2 id="basic-usage">Basic Usage</h2> <p>String literals are string slices:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let hello_world = "Hello, World!";</pre></div> <p>Here we have declared a string slice initialized with a string literal. String literals have a static lifetime, which means the string <code>hello_world</code> is guaranteed to be valid for the duration of the entire program. We can explicitly specify <code>hello_world</code>’s lifetime as well:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let hello_world: &amp;'static str = "Hello, world!";</pre></div> <h2 id="representation">Representation</h2> <p>A <code>&amp;str</code> is made up of two components: a pointer to some bytes, and a length. You can look at these with the <a href="primitive.str.html#method.as_ptr" title="method str::as_ptr"><code>as_ptr</code></a> and <a href="primitive.str.html#method.len" title="method str::len"><code>len</code></a> methods:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::slice;
use std::str;

let story = "Once upon a time...";

let ptr = story.as_ptr();
let len = story.len();

// story has nineteen bytes
assert_eq!(19, len);

// We can re-build a str out of ptr and len. This is all unsafe because
// we are responsible for making sure the two components are valid:
let s = unsafe {
    // First, we build a &amp;[u8]...
    let slice = slice::from_raw_parts(ptr, len);

    // ... and then convert that slice into a string slice
    str::from_utf8(slice)
};

assert_eq!(s, Ok(story));</pre></div> <p>Note: This example shows the internals of <code>&amp;str</code>. <code>unsafe</code> should not be used to get a string slice under normal circumstances. Use <code>as_str</code> instead.</p> <h2 id="invariant">Invariant</h2> <p>Rust libraries may assume that string slices are always valid UTF-8.</p> <p>Constructing a non-UTF-8 string slice is not immediate undefined behavior, but any function called on a string slice may assume that it is valid UTF-8, which means that a non-UTF-8 string slice can lead to undefined behavior down the road.</p> <h3 id="implementations" class="section-header">Implementations</h3>
<div id="implementations-list">
<summary><section id="impl-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#118">Source</a><pre class="code-header" data-language="rust">impl str</pre></section></summary><div class="impl-items">
<summary><section id="method.len" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#140">Source</a></span><pre class="code-header" data-language="rust">pub const fn len(&amp;self) -&gt; usize</pre></section></summary><div class="docblock">
<p>Returns the length of <code>self</code>.</p> <p>This length is in bytes, not <a href="primitive.char.html" title="primitive char"><code>char</code></a>s or graphemes. In other words, it might not be what a human considers the length of the string.</p> <h5 id="examples">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let len = "foo".len();
assert_eq!(3, len);

assert_eq!("ƒoo".len(), 4); // fancy f!
assert_eq!("ƒoo".chars().count(), 3);</pre></div> </div>
<summary><section id="method.is_empty" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#159">Source</a></span><pre class="code-header" data-language="rust">pub const fn is_empty(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p> <h5 id="examples-1">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "";
assert!(s.is_empty());

let s = "not empty";
assert!(!s.is_empty());</pre></div> </div>
<summary><section id="method.is_char_boundary" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0, const unstable">1.9.0 (const: <a href="https://github.com/rust-lang/rust/issues/131516" title="Tracking issue for const_is_char_boundary">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#190">Source</a></span><pre class="code-header" data-language="rust">pub fn is_char_boundary(&amp;self, index: usize) -&gt; bool</pre></section></summary><div class="docblock">
<p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point sequence or the end of the string.</p> <p>The start and end of the string (when <code>index == self.len()</code>) are considered to be boundaries.</p> <p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p> <h5 id="examples-2">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Löwe 老虎 Léopard";
assert!(s.is_char_boundary(0));
// start of `老`
assert!(s.is_char_boundary(6));
assert!(s.is_char_boundary(s.len()));

// second byte of `ö`
assert!(!s.is_char_boundary(2));

// third byte of `老`
assert!(!s.is_char_boundary(8));</pre></div> </div>
<summary><section id="method.floor_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#239">Source</a><pre class="code-header" data-language="rust">pub fn floor_char_boundary(&amp;self, index: usize) -&gt; usize</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code> <a href="https://github.com/rust-lang/rust/issues/93743">#93743</a>)</span>
</div></span></summary><div class="docblock">
<p>Finds the closest <code>x</code> not exceeding <code>index</code> where <a href="primitive.str.html#method.is_char_boundary" title="method str::is_char_boundary"><code>is_char_boundary(x)</code></a> is <code>true</code>.</p> <p>This method can help you truncate a string so that it’s still valid UTF-8, but doesn’t exceed a given number of bytes. Note that this is done purely at the character level and can still visually split graphemes, even though the underlying characters aren’t split. For example, the emoji 🧑‍🔬 (scientist) could be split so that the string only includes 🧑 (person) instead.</p> <h5 id="examples-3">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(round_char_boundary)]
let s = "❤️🧡💛💚💙💜";
assert_eq!(s.len(), 26);
assert!(!s.is_char_boundary(13));

let closest = s.floor_char_boundary(13);
assert_eq!(closest, 10);
assert_eq!(&amp;s[..closest], "❤️🧡");</pre></div> </div>
<summary><section id="method.ceil_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#277">Source</a><pre class="code-header" data-language="rust">pub fn ceil_char_boundary(&amp;self, index: usize) -&gt; usize</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code> <a href="https://github.com/rust-lang/rust/issues/93743">#93743</a>)</span>
</div></span></summary><div class="docblock">
<p>Finds the closest <code>x</code> not below <code>index</code> where <a href="primitive.str.html#method.is_char_boundary" title="method str::is_char_boundary"><code>is_char_boundary(x)</code></a> is <code>true</code>.</p> <p>If <code>index</code> is greater than the length of the string, this returns the length of the string.</p> <p>This method is the natural complement to <a href="primitive.str.html#method.floor_char_boundary" title="method str::floor_char_boundary"><code>floor_char_boundary</code></a>. See that method for more details.</p> <h5 id="examples-4">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(round_char_boundary)]
let s = "❤️🧡💛💚💙💜";
assert_eq!(s.len(), 26);
assert!(!s.is_char_boundary(13));

let closest = s.ceil_char_boundary(13);
assert_eq!(closest, 14);
assert_eq!(&amp;s[..closest], "❤️🧡💛");</pre></div> </div>
<summary><section id="method.as_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#303">Source</a></span><pre class="code-header" data-language="rust">pub const fn as_bytes(&amp;self) -&gt; &amp;[u8] ⓘ</pre></section></summary><div class="docblock">
<p>Converts a string slice to a byte slice. To convert the byte slice back into a string slice, use the <a href="str/fn.from_utf8.html" title="fn std::str::from_utf8"><code>from_utf8</code></a> function.</p> <h5 id="examples-5">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bytes = "bors".as_bytes();
assert_eq!(b"bors", bytes);</pre></div> </div>
<summary><section id="method.as_bytes_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const since 1.83.0">1.20.0 (const: 1.83.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#348">Source</a></span><pre class="code-header" data-language="rust">pub const unsafe fn as_bytes_mut(&amp;mut self) -&gt; &amp;mut [u8] ⓘ</pre></section></summary><div class="docblock">
<p>Converts a mutable string slice to a mutable byte slice.</p> <h5 id="safety">Safety</h5> <p>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying <code>str</code> is used.</p> <p>Use of a <code>str</code> whose contents are not valid UTF-8 is undefined behavior.</p> <h5 id="examples-6">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("Hello");
let bytes = unsafe { s.as_bytes_mut() };

assert_eq!(b"Hello", bytes);</pre></div> <p>Mutability:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("🗻∈🌏");

unsafe {
    let bytes = s.as_bytes_mut();

    bytes[0] = 0xF0;
    bytes[1] = 0x9F;
    bytes[2] = 0x8D;
    bytes[3] = 0x94;
}

assert_eq!("🍔∈🌏", s);</pre></div> </div>
<summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.32.0">1.0.0 (const: 1.32.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#379">Source</a></span><pre class="code-header" data-language="rust">pub const fn as_ptr(&amp;self) -&gt; *const u8</pre></section></summary><div class="docblock">
<p>Converts a string slice to a raw pointer.</p> <p>As string slices are a slice of bytes, the raw pointer points to a <a href="primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string slice.</p> <p>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use <a href="primitive.str.html#method.as_mut_ptr" title="method str::as_mut_ptr"><code>as_mut_ptr</code></a>.</p> <h5 id="examples-7">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Hello";
let ptr = s.as_ptr();</pre></div> </div>
<summary><section id="method.as_mut_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0, const since 1.83.0">1.36.0 (const: 1.83.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#397">Source</a></span><pre class="code-header" data-language="rust">pub const fn as_mut_ptr(&amp;mut self) -&gt; *mut u8</pre></section></summary><div class="docblock">
<p>Converts a mutable string slice to a raw pointer.</p> <p>As string slices are a slice of bytes, the raw pointer points to a <a href="primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string slice.</p> <p>It is your responsibility to make sure that the string slice only gets modified in a way that it remains valid UTF-8.</p> </div>
<summary><section id="method.get" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#422">Source</a></span><pre class="code-header" data-language="rust">pub fn get&lt;I&gt;(&amp;self, i: I) -&gt; Option&lt;&amp;&lt;I as SliceIndex&lt;str&gt;&gt;::Output&gt;where
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="docblock">
<p>Returns a subslice of <code>str</code>.</p> <p>This is the non-panicking alternative to indexing the <code>str</code>. Returns <a href="option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p> <h5 id="examples-8">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v = String::from("🗻∈🌏");

assert_eq!(Some("🗻"), v.get(0..4));

// indices not on UTF-8 sequence boundaries
assert!(v.get(1..).is_none());
assert!(v.get(..8).is_none());

// out of bounds
assert!(v.get(..42).is_none());</pre></div> </div>
<summary><section id="method.get_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#454">Source</a></span><pre class="code-header" data-language="rust">pub fn get_mut&lt;I&gt;(
    &amp;mut self,
    i: I,
) -&gt; Option&lt;&amp;mut &lt;I as SliceIndex&lt;str&gt;&gt;::Output&gt;where
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="docblock">
<p>Returns a mutable subslice of <code>str</code>.</p> <p>This is the non-panicking alternative to indexing the <code>str</code>. Returns <a href="option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p> <h5 id="examples-9">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut v = String::from("hello");
// correct length
assert!(v.get_mut(0..5).is_some());
// out of bounds
assert!(v.get_mut(..42).is_none());
assert_eq!(Some("he"), v.get_mut(0..2).map(|v| &amp;*v));

assert_eq!("hello", v);
{
    let s = v.get_mut(0..2);
    let s = s.map(|s| {
        s.make_ascii_uppercase();
        &amp;*s
    });
    assert_eq!(Some("HE"), s);
}
assert_eq!("HEllo", v);</pre></div> </div>
<summary><section id="method.get_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#486">Source</a></span><pre class="code-header" data-language="rust">pub unsafe fn get_unchecked&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as SliceIndex&lt;str&gt;&gt;::Outputwhere
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="docblock">
<p>Returns an unchecked subslice of <code>str</code>.</p> <p>This is the unchecked alternative to indexing the <code>str</code>.</p> <h5 id="safety-1">Safety</h5> <p>Callers of this function are responsible that these preconditions are satisfied:</p> <ul> <li>The starting index must not exceed the ending index;</li> <li>Indexes must be within bounds of the original slice;</li> <li>Indexes must lie on UTF-8 sequence boundaries.</li> </ul> <p>Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the <code>str</code> type.</p> <h5 id="examples-10">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v = "🗻∈🌏";
unsafe {
    assert_eq!("🗻", v.get_unchecked(0..4));
    assert_eq!("∈", v.get_unchecked(4..7));
    assert_eq!("🌏", v.get_unchecked(7..11));
}</pre></div> </div>
<summary><section id="method.get_unchecked_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#521">Source</a></span><pre class="code-header" data-language="rust">pub unsafe fn get_unchecked_mut&lt;I&gt;(
    &amp;mut self,
    i: I,
) -&gt; &amp;mut &lt;I as SliceIndex&lt;str&gt;&gt;::Outputwhere
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="docblock">
<p>Returns a mutable, unchecked subslice of <code>str</code>.</p> <p>This is the unchecked alternative to indexing the <code>str</code>.</p> <h5 id="safety-2">Safety</h5> <p>Callers of this function are responsible that these preconditions are satisfied:</p> <ul> <li>The starting index must not exceed the ending index;</li> <li>Indexes must be within bounds of the original slice;</li> <li>Indexes must lie on UTF-8 sequence boundaries.</li> </ul> <p>Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the <code>str</code> type.</p> <h5 id="examples-11">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut v = String::from("🗻∈🌏");
unsafe {
    assert_eq!("🗻", v.get_unchecked_mut(0..4));
    assert_eq!("∈", v.get_unchecked_mut(4..7));
    assert_eq!("🌏", v.get_unchecked_mut(7..11));
}</pre></div> </div>
<summary><section id="method.slice_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#572">Source</a></span><pre class="code-header" data-language="rust">pub unsafe fn slice_unchecked(&amp;self, begin: usize, end: usize) -&gt; &amp;str</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.29.0: use <code>get_unchecked(begin..end)</code> instead</span>
</div></span></summary><div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks.</p> <p>This is generally not recommended, use with caution! For a safe alternative see <a href="primitive.str.html" title="primitive str"><code>str</code></a> and <a href="ops/trait.index.html" title="trait std::ops::Index"><code>Index</code></a>.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get a mutable string slice instead, see the <a href="primitive.str.html#method.slice_mut_unchecked" title="method str::slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p> <h5 id="safety-3">Safety</h5> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must not exceed <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> <h5 id="examples-12">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Löwe 老虎 Léopard";

unsafe {
    assert_eq!("Löwe 老虎 Léopard", s.slice_unchecked(0, 21));
}

let s = "Hello, world!";

unsafe {
    assert_eq!("world", s.slice_unchecked(7, 12));
}</pre></div> </div>
<summary><section id="method.slice_mut_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#606">Source</a></span><pre class="code-header" data-language="rust">pub unsafe fn slice_mut_unchecked(
    &amp;mut self,
    begin: usize,
    end: usize,
) -&gt; &amp;mut str</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.29.0: use <code>get_unchecked_mut(begin..end)</code> instead</span>
</div></span></summary><div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks.</p> <p>This is generally not recommended, use with caution! For a safe alternative see <a href="primitive.str.html" title="primitive str"><code>str</code></a> and <a href="ops/trait.indexmut.html" title="trait std::ops::IndexMut"><code>IndexMut</code></a>.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get an immutable string slice instead, see the <a href="primitive.str.html#method.slice_unchecked" title="method str::slice_unchecked"><code>slice_unchecked</code></a> method.</p> <h5 id="safety-4">Safety</h5> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must not exceed <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> </div>
<summary><section id="method.split_at" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0, const unstable">1.4.0 (const: <a href="https://github.com/rust-lang/rust/issues/131518" title="Tracking issue for const_str_split_at">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#646">Source</a></span><pre class="code-header" data-language="rust">pub fn split_at(&amp;self, mid: usize) -&gt; (&amp;str, &amp;str)</pre></section></summary><div class="docblock">
<p>Divides one string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get mutable string slices instead, see the <a href="primitive.str.html#method.split_at_mut" title="method str::split_at_mut"><code>split_at_mut</code></a> method.</p> <h5 id="panics">Panics</h5> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice. For a non-panicking alternative see <a href="primitive.str.html#method.split_at_checked" title="method str::split_at_checked"><code>split_at_checked</code></a>.</p> <h5 id="examples-13">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Per Martin-Löf";

let (first, last) = s.split_at(3);

assert_eq!("Per", first);
assert_eq!(" Martin-Löf", last);</pre></div> </div>
<summary><section id="method.split_at_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0, const unstable">1.4.0 (const: <a href="https://github.com/rust-lang/rust/issues/131518" title="Tracking issue for const_str_split_at">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#687">Source</a></span><pre class="code-header" data-language="rust">pub fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut str, &amp;mut str)</pre></section></summary><div class="docblock">
<p>Divides one mutable string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get immutable string slices instead, see the <a href="primitive.str.html#method.split_at" title="method str::split_at"><code>split_at</code></a> method.</p> <h5 id="panics-1">Panics</h5> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice. For a non-panicking alternative see <a href="primitive.str.html#method.split_at_mut_checked" title="method str::split_at_mut_checked"><code>split_at_mut_checked</code></a>.</p> <h5 id="examples-14">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = "Per Martin-Löf".to_string();
{
    let (first, last) = s.split_at_mut(3);
    first.make_ascii_uppercase();
    assert_eq!("PER", first);
    assert_eq!(" Martin-Löf", last);
}
assert_eq!("PER Martin-Löf", s);</pre></div> </div>
<summary><section id="method.split_at_checked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const unstable">1.80.0 (const: <a href="https://github.com/rust-lang/rust/issues/131518" title="Tracking issue for const_str_split_at">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#727">Source</a></span><pre class="code-header" data-language="rust">pub fn split_at_checked(&amp;self, mid: usize) -&gt; Option&lt;(&amp;str, &amp;str)&gt;</pre></section></summary><div class="docblock">
<p>Divides one string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a valid byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The method returns <code>None</code> if that’s not the case.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get mutable string slices instead, see the <a href="primitive.str.html#method.split_at_mut_checked" title="method str::split_at_mut_checked"><code>split_at_mut_checked</code></a> method.</p> <h5 id="examples-15">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Per Martin-Löf";

let (first, last) = s.split_at_checked(3).unwrap();
assert_eq!("Per", first);
assert_eq!(" Martin-Löf", last);

assert_eq!(None, s.split_at_checked(13));  // Inside “ö”
assert_eq!(None, s.split_at_checked(16));  // Beyond the string length</pre></div> </div>
<summary><section id="method.split_at_mut_checked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const unstable">1.80.0 (const: <a href="https://github.com/rust-lang/rust/issues/131518" title="Tracking issue for const_str_split_at">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#768">Source</a></span><pre class="code-header" data-language="rust">pub fn split_at_mut_checked(
    &amp;mut self,
    mid: usize,
) -&gt; Option&lt;(&amp;mut str, &amp;mut str)&gt;</pre></section></summary><div class="docblock">
<p>Divides one mutable string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a valid byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The method returns <code>None</code> if that’s not the case.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get immutable string slices instead, see the <a href="primitive.str.html#method.split_at_checked" title="method str::split_at_checked"><code>split_at_checked</code></a> method.</p> <h5 id="examples-16">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = "Per Martin-Löf".to_string();
if let Some((first, last)) = s.split_at_mut_checked(3) {
    first.make_ascii_uppercase();
    assert_eq!("PER", first);
    assert_eq!(" Martin-Löf", last);
}
assert_eq!("PER Martin-Löf", s);

assert_eq!(None, s.split_at_mut_checked(13));  // Inside “ö”
assert_eq!(None, s.split_at_mut_checked(16));  // Beyond the string length</pre></div> </div>
<summary><section id="method.chars" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#864">Source</a></span><pre class="code-header" data-language="rust">pub fn chars(&amp;self) -&gt; Chars&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Returns an iterator over the <a href="primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="primitive.char.html" title="primitive char"><code>char</code></a>. This method returns such an iterator.</p> <p>It’s important to remember that <a href="primitive.char.html" title="primitive char"><code>char</code></a> represents a Unicode Scalar Value, and might not match your idea of what a ‘character’ is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust’s standard library, check crates.io instead.</p> <h5 id="examples-17">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let word = "goodbye";

let count = word.chars().count();
assert_eq!(7, count);

let mut chars = word.chars();

assert_eq!(Some('g'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('d'), chars.next());
assert_eq!(Some('b'), chars.next());
assert_eq!(Some('y'), chars.next());
assert_eq!(Some('e'), chars.next());

assert_eq!(None, chars.next());</pre></div> <p>Remember, <a href="primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let y = "y̆";

let mut chars = y.chars();

assert_eq!(Some('y'), chars.next()); // not 'y̆'
assert_eq!(Some('\u{0306}'), chars.next());

assert_eq!(None, chars.next());</pre></div> </div>
<summary><section id="method.char_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#921">Source</a></span><pre class="code-header" data-language="rust">pub fn char_indices(&amp;self) -&gt; CharIndices&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Returns an iterator over the <a href="primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice, and their positions.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="primitive.char.html" title="primitive char"><code>char</code></a>. This method returns an iterator of both these <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, as well as their byte positions.</p> <p>The iterator yields tuples. The position is first, the <a href="primitive.char.html" title="primitive char"><code>char</code></a> is second.</p> <h5 id="examples-18">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let word = "goodbye";

let count = word.char_indices().count();
assert_eq!(7, count);

let mut char_indices = word.char_indices();

assert_eq!(Some((0, 'g')), char_indices.next());
assert_eq!(Some((1, 'o')), char_indices.next());
assert_eq!(Some((2, 'o')), char_indices.next());
assert_eq!(Some((3, 'd')), char_indices.next());
assert_eq!(Some((4, 'b')), char_indices.next());
assert_eq!(Some((5, 'y')), char_indices.next());
assert_eq!(Some((6, 'e')), char_indices.next());

assert_eq!(None, char_indices.next());</pre></div> <p>Remember, <a href="primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let yes = "y̆es";

let mut char_indices = yes.char_indices();

assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y̆')
assert_eq!(Some((1, '\u{0306}')), char_indices.next());

// note the 3 here - the previous character took up two bytes
assert_eq!(Some((3, 'e')), char_indices.next());
assert_eq!(Some((4, 's')), char_indices.next());

assert_eq!(None, char_indices.next());</pre></div> </div>
<summary><section id="method.bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#944">Source</a></span><pre class="code-header" data-language="rust">pub fn bytes(&amp;self) -&gt; Bytes&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Returns an iterator over the bytes of a string slice.</p> <p>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</p> <h5 id="examples-19">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut bytes = "bors".bytes();

assert_eq!(Some(b'b'), bytes.next());
assert_eq!(Some(b'o'), bytes.next());
assert_eq!(Some(b'r'), bytes.next());
assert_eq!(Some(b's'), bytes.next());

assert_eq!(None, bytes.next());</pre></div> </div>
<summary><section id="method.split_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#996">Source</a></span><pre class="code-header" data-language="rust">pub fn split_whitespace(&amp;self) -&gt; SplitWhitespace&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Splits a string slice by whitespace.</p> <p>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</p> <p>‘Whitespace’ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace instead, use <a href="primitive.str.html#method.split_ascii_whitespace" title="method str::split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p> <h5 id="examples-20">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = "A few words".split_whitespace();

assert_eq!(Some("A"), iter.next());
assert_eq!(Some("few"), iter.next());
assert_eq!(Some("words"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>All kinds of whitespace are considered:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = " Mary   had\ta\u{2009}little  \n\t lamb".split_whitespace();
assert_eq!(Some("Mary"), iter.next());
assert_eq!(Some("had"), iter.next());
assert_eq!(Some("a"), iter.next());
assert_eq!(Some("little"), iter.next());
assert_eq!(Some("lamb"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>If the string is empty or all whitespace, the iterator yields no string slices:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("".split_whitespace().next(), None);
assert_eq!("   ".split_whitespace().next(), None);</pre></div> </div>
<summary><section id="method.split_ascii_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1045">Source</a></span><pre class="code-header" data-language="rust">pub fn split_ascii_whitespace(&amp;self) -&gt; SplitAsciiWhitespace&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Splits a string slice by ASCII whitespace.</p> <p>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</p> <p>To split by Unicode <code>Whitespace</code> instead, use <a href="primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a>.</p> <h5 id="examples-21">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = "A few words".split_ascii_whitespace();

assert_eq!(Some("A"), iter.next());
assert_eq!(Some("few"), iter.next());
assert_eq!(Some("words"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>All kinds of ASCII whitespace are considered:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = " Mary   had\ta little  \n\t lamb".split_ascii_whitespace();
assert_eq!(Some("Mary"), iter.next());
assert_eq!(Some("had"), iter.next());
assert_eq!(Some("a"), iter.next());
assert_eq!(Some("little"), iter.next());
assert_eq!(Some("lamb"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>If the string is empty or all ASCII whitespace, the iterator yields no string slices:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("".split_ascii_whitespace().next(), None);
assert_eq!("   ".split_ascii_whitespace().next(), None);</pre></div> </div>
<summary><section id="method.lines" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1098">Source</a></span><pre class="code-header" data-language="rust">pub fn lines(&amp;self) -&gt; Lines&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Returns an iterator over the lines of a string, as string slices.</p> <p>Lines are split at line endings that are either newlines (<code>\n</code>) or sequences of a carriage return followed by a line feed (<code>\r\n</code>).</p> <p>Line terminators are not included in the lines returned by the iterator.</p> <p>Note that any carriage return (<code>\r</code>) not immediately followed by a line feed (<code>\n</code>) does not split a line. These carriage returns are thereby included in the produced lines.</p> <p>The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.</p> <h5 id="examples-22">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let text = "foo\r\nbar\n\nbaz\r";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
// Trailing carriage return is included in the last line
assert_eq!(Some("baz\r"), lines.next());

assert_eq!(None, lines.next());</pre></div> <p>The final line does not require any ending:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let text = "foo\nbar\n\r\nbaz";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
assert_eq!(Some("baz"), lines.next());

assert_eq!(None, lines.next());</pre></div> </div>
<summary><section id="method.lines_any" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1107">Source</a></span><pre class="code-header" data-language="rust">pub fn lines_any(&amp;self) -&gt; LinesAny&lt;'_&gt; ⓘ</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.4.0: use lines() instead now</span>
</div></span></summary><div class="docblock">
<p>Returns an iterator over the lines of a string.</p> </div>
<summary><section id="method.encode_utf16" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1126">Source</a></span><pre class="code-header" data-language="rust">pub fn encode_utf16(&amp;self) -&gt; EncodeUtf16&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p> <h5 id="examples-23">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let text = "Zażółć gęślą jaźń";

let utf8_len = text.len();
let utf16_len = text.encode_utf16().count();

assert!(utf16_len &lt;= utf8_len);</pre></div> </div>
<summary><section id="method.contains" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1151">Source</a></span><pre class="code-header" data-language="rust">pub fn contains&lt;P&gt;(&amp;self, pat: P) -&gt; boolwhere
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a sub-slice of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-24">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bananas = "bananas";

assert!(bananas.contains("nana"));
assert!(!bananas.contains("apples"));</pre></div> </div>
<summary><section id="method.starts_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1189">Source</a></span><pre class="code-header" data-language="rust">pub fn starts_with&lt;P&gt;(&amp;self, pat: P) -&gt; boolwhere
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a prefix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, in which case this function will return true if the <code>&amp;str</code> is a prefix of this string slice.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can also be a <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches. These will only be checked against the first character of this string slice. Look at the second example below regarding behavior for slices of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s.</p> <h5 id="examples-25">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bananas = "bananas";

assert!(bananas.starts_with("bana"));
assert!(!bananas.starts_with("nana"));</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bananas = "bananas";

// Note that both of these assert successfully.
assert!(bananas.starts_with(&amp;['b', 'a', 'n', 'a']));
assert!(bananas.starts_with(&amp;['a', 'b', 'c', 'd']));</pre></div> </div>
<summary><section id="method.ends_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1214-1216">Source</a></span><pre class="code-header" data-language="rust">pub fn ends_with&lt;P&gt;(&amp;self, pat: P) -&gt; boolwhere
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a suffix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-26">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bananas = "bananas";

assert!(bananas.ends_with("anas"));
assert!(!bananas.ends_with("nana"));</pre></div> </div>
<summary><section id="method.find" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1265">Source</a></span><pre class="code-header" data-language="rust">pub fn find&lt;P&gt;(&amp;self, pat: P) -&gt; Option&lt;usize&gt;where
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Returns the byte index of the first character of this string slice that matches the pattern.</p> <p>Returns <a href="option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> if the pattern doesn’t match.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-27">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Löwe 老虎 Léopard Gepardi";

assert_eq!(s.find('L'), Some(0));
assert_eq!(s.find('é'), Some(14));
assert_eq!(s.find("pard"), Some(17));</pre></div> <p>More complex patterns using point-free style and closures:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Löwe 老虎 Léopard";

assert_eq!(s.find(char::is_whitespace), Some(5));
assert_eq!(s.find(char::is_lowercase), Some(1));
assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));
assert_eq!(s.find(|c: char| (c &lt; 'o') &amp;&amp; (c &gt; 'a')), Some(4));</pre></div> <p>Not finding the pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Löwe 老虎 Léopard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.find(x), None);</pre></div> </div>
<summary><section id="method.rfind" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1311-1313">Source</a></span><pre class="code-header" data-language="rust">pub fn rfind&lt;P&gt;(&amp;self, pat: P) -&gt; Option&lt;usize&gt;where
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns the byte index for the first character of the last match of the pattern in this string slice.</p> <p>Returns <a href="option/enum.option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> if the pattern doesn’t match.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-28">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Löwe 老虎 Léopard Gepardi";

assert_eq!(s.rfind('L'), Some(13));
assert_eq!(s.rfind('é'), Some(14));
assert_eq!(s.rfind("pard"), Some(24));</pre></div> <p>More complex patterns with closures:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Löwe 老虎 Léopard";

assert_eq!(s.rfind(char::is_whitespace), Some(12));
assert_eq!(s.rfind(char::is_lowercase), Some(20));</pre></div> <p>Not finding the pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Löwe 老虎 Léopard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.rfind(x), None);</pre></div> </div>
<summary><section id="method.split" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1433">Source</a></span><pre class="code-header" data-language="rust">pub fn split&lt;P&gt;(&amp;self, pat: P) -&gt; Split&lt;'_, P&gt; ⓘwhere
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Returns an iterator over substrings of this string slice, separated by characters matched by a pattern.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str.html#method.rsplit" title="method str::rsplit"><code>rsplit</code></a> method can be used.</p> <h5 id="examples-29">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".split(' ').collect();
assert_eq!(v, ["Mary", "had", "a", "little", "lamb"]);

let v: Vec&lt;&amp;str&gt; = "".split('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".split('X').collect();
assert_eq!(v, ["lion", "", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".split("::").collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "abc1def2ghi".split(char::is_numeric).collect();
assert_eq!(v, ["abc", "def", "ghi"]);

let v: Vec&lt;&amp;str&gt; = "lionXtigerXleopard".split(char::is_uppercase).collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);</pre></div> <p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "2020-11-03 23:59".split(&amp;['-', ' ', ':', '@'][..]).collect();
assert_eq!(v, ["2020", "11", "03", "23", "59"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".split(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "def", "ghi"]);</pre></div> <p>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = "||||a||b|c".to_string();
let d: Vec&lt;_&gt; = x.split('|').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre></div> <p>Contiguous separators are separated by the empty string.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = "(///)".to_string();
let d: Vec&lt;_&gt; = x.split('/').collect();

assert_eq!(d, &amp;["(", "", "", ")"]);</pre></div> <p>Separators at the start or end of a string are neighbored by empty strings.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let d: Vec&lt;_&gt; = "010".split("0").collect();
assert_eq!(d, &amp;["", "1", ""]);</pre></div> <p>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f: Vec&lt;_&gt; = "rust".split("").collect();
assert_eq!(f, &amp;["", "r", "u", "s", "t", ""]);</pre></div> <p>Contiguous separators can lead to possibly surprising behavior when whitespace is used as the separator. This code is correct:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = "    a  b c".to_string();
let d: Vec&lt;_&gt; = x.split(' ').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre></div> <p>It does <em>not</em> give you:</p> <div class="example-wrap ignore">ⓘ<pre class="rust rust-example-rendered" data-language="rust">assert_eq!(d, &amp;["a", "b", "c"]);</pre>
</div> <p>Use <a href="primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a> for this behavior.</p> </div>
<summary><section id="method.split_inclusive" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1474">Source</a></span><pre class="code-header" data-language="rust">pub fn split_inclusive&lt;P&gt;(&amp;self, pat: P) -&gt; SplitInclusive&lt;'_, P&gt; ⓘwhere
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Returns an iterator over substrings of this string slice, separated by characters matched by a pattern.</p> <p>Differs from the iterator produced by <code>split</code> in that <code>split_inclusive</code> leaves the matched part as the terminator of the substring.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-30">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb\nlittle lamb\nlittle lamb."
    .split_inclusive('\n').collect();
assert_eq!(v, ["Mary had a little lamb\n", "little lamb\n", "little lamb."]);</pre></div> <p>If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb\nlittle lamb\nlittle lamb.\n"
    .split_inclusive('\n').collect();
assert_eq!(v, ["Mary had a little lamb\n", "little lamb\n", "little lamb.\n"]);</pre></div> </div>
<summary><section id="method.rsplit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1529-1531">Source</a></span><pre class="code-header" data-language="rust">pub fn rsplit&lt;P&gt;(&amp;self, pat: P) -&gt; RSplit&lt;'_, P&gt; ⓘwhere
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns an iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-1">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a> method can be used.</p> <h5 id="examples-31">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplit(' ').collect();
assert_eq!(v, ["lamb", "little", "a", "had", "Mary"]);

let v: Vec&lt;&amp;str&gt; = "".rsplit('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplit('X').collect();
assert_eq!(v, ["leopard", "tiger", "", "lion"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplit("::").collect();
assert_eq!(v, ["leopard", "tiger", "lion"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplit(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "def", "abc"]);</pre></div> </div>
<summary><section id="method.split_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1578">Source</a></span><pre class="code-header" data-language="rust">pub fn split_terminator&lt;P&gt;(&amp;self, pat: P) -&gt; SplitTerminator&lt;'_, P&gt; ⓘwhere
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Returns an iterator over substrings of the given string slice, separated by characters matched by a pattern.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <p>Equivalent to <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h5 id="iterator-behavior-2">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str.html#method.rsplit_terminator" title="method str::rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p> <h5 id="examples-32">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "A.B.".split_terminator('.').collect();
assert_eq!(v, ["A", "B"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".split_terminator(".").collect();
assert_eq!(v, ["A", "", "B", ""]);

let v: Vec&lt;&amp;str&gt; = "A.B:C.D".split_terminator(&amp;['.', ':'][..]).collect();
assert_eq!(v, ["A", "B", "C", "D"]);</pre></div> </div>
<summary><section id="method.rsplit_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1624-1626">Source</a></span><pre class="code-header" data-language="rust">pub fn rsplit_terminator&lt;P&gt;(&amp;self, pat: P) -&gt; RSplitTerminator&lt;'_, P&gt; ⓘwhere
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns an iterator over substrings of <code>self</code>, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <p>Equivalent to <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h5 id="iterator-behavior-3">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str.html#method.split_terminator" title="method str::split_terminator"><code>split_terminator</code></a> method can be used.</p> <h5 id="examples-33">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "A.B.".rsplit_terminator('.').collect();
assert_eq!(v, ["B", "A"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".rsplit_terminator(".").collect();
assert_eq!(v, ["", "B", "", "A"]);

let v: Vec&lt;&amp;str&gt; = "A.B:C.D".rsplit_terminator(&amp;['.', ':'][..]).collect();
assert_eq!(v, ["D", "C", "B", "A"]);</pre></div> </div>
<summary><section id="method.splitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1679">Source</a></span><pre class="code-header" data-language="rust">pub fn splitn&lt;P&gt;(&amp;self, n: usize, pat: P) -&gt; SplitN&lt;'_, P&gt; ⓘwhere
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Returns an iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-4">Iterator behavior</h5> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>If the pattern allows a reverse search, the <a href="primitive.str.html#method.rsplitn" title="method str::rsplitn"><code>rsplitn</code></a> method can be used.</p> <h5 id="examples-34">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lambda".splitn(3, ' ').collect();
assert_eq!(v, ["Mary", "had", "a little lambda"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".splitn(3, "X").collect();
assert_eq!(v, ["lion", "", "tigerXleopard"]);

let v: Vec&lt;&amp;str&gt; = "abcXdef".splitn(1, 'X').collect();
assert_eq!(v, ["abcXdef"]);

let v: Vec&lt;&amp;str&gt; = "".splitn(1, 'X').collect();
assert_eq!(v, [""]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".splitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "defXghi"]);</pre></div> </div>
<summary><section id="method.rsplitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1728-1730">Source</a></span><pre class="code-header" data-language="rust">pub fn rsplitn&lt;P&gt;(&amp;self, n: usize, pat: P) -&gt; RSplitN&lt;'_, P&gt; ⓘwhere
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns an iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-5">Iterator behavior</h5> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>For splitting from the front, the <a href="primitive.str.html#method.splitn" title="method str::splitn"><code>splitn</code></a> method can be used.</p> <h5 id="examples-35">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplitn(3, ' ').collect();
assert_eq!(v, ["lamb", "little", "Mary had a"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplitn(3, 'X').collect();
assert_eq!(v, ["leopard", "tiger", "lionX"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplitn(2, "::").collect();
assert_eq!(v, ["leopard", "lion::tiger"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "abc1def"]);</pre></div> </div>
<summary><section id="method.split_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1748">Source</a></span><pre class="code-header" data-language="rust">pub fn split_once&lt;P&gt;(&amp;self, delimiter: P) -&gt; Option&lt;(&amp;str, &amp;str)&gt;where
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Splits the string on the first occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter.</p> <h5 id="examples-36">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("cfg".split_once('='), None);
assert_eq!("cfg=".split_once('='), Some(("cfg", "")));
assert_eq!("cfg=foo".split_once('='), Some(("cfg", "foo")));
assert_eq!("cfg=foo=bar".split_once('='), Some(("cfg", "foo=bar")));</pre></div> </div>
<summary><section id="method.rsplit_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1766-1768">Source</a></span><pre class="code-header" data-language="rust">pub fn rsplit_once&lt;P&gt;(&amp;self, delimiter: P) -&gt; Option&lt;(&amp;str, &amp;str)&gt;where
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Splits the string on the last occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter.</p> <h5 id="examples-37">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("cfg".rsplit_once('='), None);
assert_eq!("cfg=foo".rsplit_once('='), Some(("cfg", "foo")));
assert_eq!("cfg=foo=bar".rsplit_once('='), Some(("cfg=foo", "bar")));</pre></div> </div>
<summary><section id="method.matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1806">Source</a></span><pre class="code-header" data-language="rust">pub fn matches&lt;P&gt;(&amp;self, pat: P) -&gt; Matches&lt;'_, P&gt; ⓘwhere
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Returns an iterator over the disjoint matches of a pattern within the given string slice.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-6">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str.html#method.rmatches" title="method str::rmatches"><code>rmatches</code></a> method can be used.</p> <h5 id="examples-38">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".matches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".matches(char::is_numeric).collect();
assert_eq!(v, ["1", "2", "3"]);</pre></div> </div>
<summary><section id="method.rmatches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1840-1842">Source</a></span><pre class="code-header" data-language="rust">pub fn rmatches&lt;P&gt;(&amp;self, pat: P) -&gt; RMatches&lt;'_, P&gt; ⓘwhere
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns an iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-7">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str.html#method.matches" title="method str::matches"><code>matches</code></a> method can be used.</p> <h5 id="examples-39">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".rmatches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".rmatches(char::is_numeric).collect();
assert_eq!(v, ["3", "2", "1"]);</pre></div> </div>
<summary><section id="method.match_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1884">Source</a></span><pre class="code-header" data-language="rust">pub fn match_indices&lt;P&gt;(&amp;self, pat: P) -&gt; MatchIndices&lt;'_, P&gt; ⓘwhere
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Returns an iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the first match are returned.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-8">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str.html#method.rmatch_indices" title="method str::rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p> <h5 id="examples-40">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".match_indices("abc").collect();
assert_eq!(v, [(0, "abc"), (6, "abc"), (12, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".match_indices("abc").collect();
assert_eq!(v, [(1, "abc"), (4, "abc")]);

let v: Vec&lt;_&gt; = "ababa".match_indices("aba").collect();
assert_eq!(v, [(0, "aba")]); // only the first `aba`</pre></div> </div>
<summary><section id="method.rmatch_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1924-1926">Source</a></span><pre class="code-header" data-language="rust">pub fn rmatch_indices&lt;P&gt;(&amp;self, pat: P) -&gt; RMatchIndices&lt;'_, P&gt; ⓘwhere
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns an iterator over the disjoint matches of a pattern within <code>self</code>, yielded in reverse order along with the index of the match.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the last match are returned.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-9">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="iter/trait.doubleendediterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str.html#method.match_indices" title="method str::match_indices"><code>match_indices</code></a> method can be used.</p> <h5 id="examples-41">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".rmatch_indices("abc").collect();
assert_eq!(v, [(12, "abc"), (6, "abc"), (0, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".rmatch_indices("abc").collect();
assert_eq!(v, [(4, "abc"), (1, "abc")]);

let v: Vec&lt;_&gt; = "ababa".rmatch_indices("aba").collect();
assert_eq!(v, [(2, "aba")]); // only the last `aba`</pre></div> </div>
<summary><section id="method.trim" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1948">Source</a></span><pre class="code-header" data-language="rust">pub fn trim(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">
<p>Returns a string slice with leading and trailing whitespace removed.</p> <p>‘Whitespace’ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <h5 id="examples-42">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "\n Hello\tworld\t\n";

assert_eq!("Hello\tworld", s.trim());</pre></div> </div>
<summary><section id="method.trim_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1987">Source</a></span><pre class="code-header" data-language="rust">pub fn trim_start(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">
<p>Returns a string slice with leading whitespace removed.</p> <p>‘Whitespace’ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <h5 id="text-directionality">Text directionality</h5> <p>A string is a sequence of bytes. <code>start</code> in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</p> <h5 id="examples-43">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "\n Hello\tworld\t\n";
assert_eq!("Hello\tworld\t\n", s.trim_start());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "  English  ";
assert!(Some('E') == s.trim_start().chars().next());

let s = "  עברית  ";
assert!(Some('ע') == s.trim_start().chars().next());</pre></div> </div>
<summary><section id="method.trim_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2026">Source</a></span><pre class="code-header" data-language="rust">pub fn trim_end(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">
<p>Returns a string slice with trailing whitespace removed.</p> <p>‘Whitespace’ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <h5 id="text-directionality-1">Text directionality</h5> <p>A string is a sequence of bytes. <code>end</code> in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</p> <h5 id="examples-44">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "\n Hello\tworld\t\n";
assert_eq!("\n Hello\tworld", s.trim_end());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "  English  ";
assert!(Some('h') == s.trim_end().chars().rev().next());

let s = "  עברית  ";
assert!(Some('ת') == s.trim_end().chars().rev().next());</pre></div> </div>
<summary><section id="method.trim_left" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2066">Source</a></span><pre class="code-header" data-language="rust">pub fn trim_left(&amp;self) -&gt; &amp;str</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_start</code></span>
</div></span></summary><div class="docblock">
<p>Returns a string slice with leading whitespace removed.</p> <p>‘Whitespace’ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h5 id="text-directionality-2">Text directionality</h5> <p>A string is a sequence of bytes. ‘Left’ in this context means the first position of that byte string; for a language like Arabic or Hebrew which are ‘right to left’ rather than ‘left to right’, this will be the <em>right</em> side, not the left.</p> <h5 id="examples-45">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = " Hello\tworld\t";

assert_eq!("Hello\tworld\t", s.trim_left());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "  English";
assert!(Some('E') == s.trim_left().chars().next());

let s = "  עברית";
assert!(Some('ע') == s.trim_left().chars().next());</pre></div> </div>
<summary><section id="method.trim_right" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2106">Source</a></span><pre class="code-header" data-language="rust">pub fn trim_right(&amp;self) -&gt; &amp;str</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_end</code></span>
</div></span></summary><div class="docblock">
<p>Returns a string slice with trailing whitespace removed.</p> <p>‘Whitespace’ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h5 id="text-directionality-3">Text directionality</h5> <p>A string is a sequence of bytes. ‘Right’ in this context means the last position of that byte string; for a language like Arabic or Hebrew which are ‘right to left’ rather than ‘left to right’, this will be the <em>left</em> side, not the right.</p> <h5 id="examples-46">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = " Hello\tworld\t";

assert_eq!(" Hello\tworld", s.trim_right());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "English  ";
assert!(Some('h') == s.trim_right().chars().rev().next());

let s = "עברית  ";
assert!(Some('ת') == s.trim_right().chars().rev().next());</pre></div> </div>
<summary><section id="method.trim_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2139-2141">Source</a></span><pre class="code-header" data-language="rust">pub fn trim_matches&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;strwhere
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; DoubleEndedSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns a string slice with all prefixes and suffixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-47">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_matches('1'), "foo1bar");
assert_eq!("123foo1bar123".trim_matches(char::is_numeric), "foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_matches(x), "foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("1foo1barXX".trim_matches(|c| c == '1' || c == 'X'), "foo1bar");</pre></div> </div>
<summary><section id="method.trim_start_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2186">Source</a></span><pre class="code-header" data-language="rust">pub fn trim_start_matches&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;strwhere
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Returns a string slice with all prefixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-4">Text directionality</h5> <p>A string is a sequence of bytes. <code>start</code> in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</p> <h5 id="examples-48">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_start_matches('1'), "foo1bar11");
assert_eq!("123foo1bar123".trim_start_matches(char::is_numeric), "foo1bar123");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_start_matches(x), "foo1bar12");</pre></div> </div>
<summary><section id="method.strip_prefix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2220">Source</a></span><pre class="code-header" data-language="rust">pub fn strip_prefix&lt;P&gt;(&amp;self, prefix: P) -&gt; Option&lt;&amp;str&gt;where
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Returns a string slice with the prefix removed.</p> <p>If the string starts with the pattern <code>prefix</code>, returns the substring after the prefix, wrapped in <code>Some</code>. Unlike <a href="primitive.str.html#method.trim_start_matches" title="method str::trim_start_matches"><code>trim_start_matches</code></a>, this method removes the prefix exactly once.</p> <p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-49">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("foo:bar".strip_prefix("foo:"), Some("bar"));
assert_eq!("foo:bar".strip_prefix("bar"), None);
assert_eq!("foofoo".strip_prefix("foo"), Some("foo"));</pre></div> </div>
<summary><section id="method.strip_suffix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2248-2250">Source</a></span><pre class="code-header" data-language="rust">pub fn strip_suffix&lt;P&gt;(&amp;self, suffix: P) -&gt; Option&lt;&amp;str&gt;where
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns a string slice with the suffix removed.</p> <p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix, wrapped in <code>Some</code>. Unlike <a href="primitive.str.html#method.trim_end_matches" title="method str::trim_end_matches"><code>trim_end_matches</code></a>, this method removes the suffix exactly once.</p> <p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-50">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("bar:foo".strip_suffix(":foo"), Some("bar"));
assert_eq!("bar:foo".strip_suffix("bar"), None);
assert_eq!("foofoo".strip_suffix("foo"), Some("foo"));</pre></div> </div>
<summary><section id="method.trim_end_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2291-2293">Source</a></span><pre class="code-header" data-language="rust">pub fn trim_end_matches&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;strwhere
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; ReverseSearcher&lt;'a&gt;,</pre></section></summary><div class="docblock">
<p>Returns a string slice with all suffixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-5">Text directionality</h5> <p>A string is a sequence of bytes. <code>end</code> in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</p> <h5 id="examples-51">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_end_matches('1'), "11foo1bar");
assert_eq!("123foo1bar123".trim_end_matches(char::is_numeric), "123foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_end_matches(x), "12foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("1fooX".trim_end_matches(|c| c == '1' || c == 'X'), "1foo");</pre></div> </div>
<summary><section id="method.trim_left_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2335">Source</a></span><pre class="code-header" data-language="rust">pub fn trim_left_matches&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;strwhere
    P: Pattern,</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_start_matches</code></span>
</div></span></summary><div class="docblock">
<p>Returns a string slice with all prefixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-6">Text directionality</h5> <p>A string is a sequence of bytes. ‘Left’ in this context means the first position of that byte string; for a language like Arabic or Hebrew which are ‘right to left’ rather than ‘left to right’, this will be the <em>right</em> side, not the left.</p> <h5 id="examples-52">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_left_matches('1'), "foo1bar11");
assert_eq!("123foo1bar123".trim_left_matches(char::is_numeric), "foo1bar123");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_left_matches(x), "foo1bar12");</pre></div> </div>
<summary><section id="method.trim_right_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2378-2380">Source</a></span><pre class="code-header" data-language="rust">pub fn trim_right_matches&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;strwhere
    P: Pattern,
    &lt;P as Pattern&gt;::Searcher&lt;'a&gt;: for&lt;'a&gt; ReverseSearcher&lt;'a&gt;,</pre></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_end_matches</code></span>
</div></span></summary><div class="docblock">
<p>Returns a string slice with all suffixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-7">Text directionality</h5> <p>A string is a sequence of bytes. ‘Right’ in this context means the last position of that byte string; for a language like Arabic or Hebrew which are ‘right to left’ rather than ‘left to right’, this will be the <em>left</em> side, not the right.</p> <h5 id="examples-53">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_right_matches('1'), "11foo1bar");
assert_eq!("123foo1bar123".trim_right_matches(char::is_numeric), "123foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_right_matches(x), "12foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("1fooX".trim_right_matches(|c| c == '1' || c == 'X'), "1foo");</pre></div> </div>
<summary><section id="method.parse" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2430">Source</a></span><pre class="code-header" data-language="rust">pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt;where
    F: FromStr,</pre></section></summary><div class="docblock">
<p>Parses this string slice into another type.</p> <p>Because <code>parse</code> is so general, it can cause problems with type inference. As such, <code>parse</code> is one of the few times you’ll see the syntax affectionately known as the ‘turbofish’: <code>::&lt;&gt;</code>. This helps the inference algorithm understand specifically which type you’re trying to parse into.</p> <p><code>parse</code> can parse into any type that implements the <a href="str/trait.fromstr.html" title="trait std::str::FromStr"><code>FromStr</code></a> trait.</p> <h5 id="errors">Errors</h5> <p>Will return <a href="str/trait.fromstr.html#associatedtype.Err" title="associated type std::str::FromStr::Err"><code>Err</code></a> if it’s not possible to parse this string slice into the desired type.</p> <h5 id="examples-54">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let four: u32 = "4".parse().unwrap();

assert_eq!(4, four);</pre></div> <p>Using the ‘turbofish’ instead of annotating <code>four</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let four = "4".parse::&lt;u32&gt;();

assert_eq!(Ok(4), four);</pre></div> <p>Failing to parse:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let nope = "j".parse::&lt;u32&gt;();

assert!(nope.is_err());</pre></div> </div>
<summary><section id="method.is_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const since 1.74.0">1.23.0 (const: 1.74.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2449">Source</a></span><pre class="code-header" data-language="rust">pub const fn is_ascii(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Checks if all characters in this string are within the ASCII range.</p> <h5 id="examples-55">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let ascii = "hello!\n";
let non_ascii = "Grüße, Jürgen ❤";

assert!(ascii.is_ascii());
assert!(!non_ascii.is_ascii());</pre></div> </div>
<summary><section id="method.as_ascii" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2461">Source</a><pre class="code-header" data-language="rust">pub const fn as_ascii(&amp;self) -&gt; Option&lt;&amp;[AsciiChar]&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code> <a href="https://github.com/rust-lang/rust/issues/110998">#110998</a>)</span>
</div></span></summary><div class="docblock">
<p>If this string slice <a href="primitive.str.html#method.is_ascii" title="method str::is_ascii"><code>is_ascii</code></a>, returns it as a slice of <a href="ascii/enum.char.html" title="enum std::ascii::Char">ASCII characters</a>, otherwise returns <code>None</code>.</p> </div>
<summary><section id="method.eq_ignore_ascii_case" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const unstable">1.23.0 (const: <a href="https://github.com/rust-lang/rust/issues/131719" title="Tracking issue for const_eq_ignore_ascii_case">unstable</a>)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2482">Source</a></span><pre class="code-header" data-language="rust">pub fn eq_ignore_ascii_case(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">
<p>Checks that two strings are an ASCII case-insensitive match.</p> <p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>, but without allocating and copying temporaries.</p> <h5 id="examples-56">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert!("Ferris".eq_ignore_ascii_case("FERRIS"));
assert!("Ferrös".eq_ignore_ascii_case("FERRöS"));
assert!(!"Ferrös".eq_ignore_ascii_case("FERRÖS"));</pre></div> </div>
<summary><section id="method.make_ascii_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const since 1.84.0">1.23.0 (const: 1.84.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2508">Source</a></span><pre class="code-header" data-language="rust">pub const fn make_ascii_uppercase(&amp;mut self)</pre></section></summary><div class="docblock">
<p>Converts this string to its ASCII upper case equivalent in-place.</p> <p>ASCII letters ‘a’ to ‘z’ are mapped to ‘A’ to ‘Z’, but non-ASCII letters are unchanged.</p> <p>To return a new uppercased value without modifying the existing one, use <a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase()</code></a>.</p> <h5 id="examples-57">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("Grüße, Jürgen ❤");

s.make_ascii_uppercase();

assert_eq!("GRüßE, JüRGEN ❤", s);</pre></div> </div>
<summary><section id="method.make_ascii_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const since 1.84.0">1.23.0 (const: 1.84.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2536">Source</a></span><pre class="code-header" data-language="rust">pub const fn make_ascii_lowercase(&amp;mut self)</pre></section></summary><div class="docblock">
<p>Converts this string to its ASCII lower case equivalent in-place.</p> <p>ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’, but non-ASCII letters are unchanged.</p> <p>To return a new lowercased value without modifying the existing one, use <a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase()</code></a>.</p> <h5 id="examples-58">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("GRÜßE, JÜRGEN ❤");

s.make_ascii_lowercase();

assert_eq!("grÜße, jÜrgen ❤", s);</pre></div> </div>
<summary><section id="method.trim_ascii_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const since 1.80.0">1.80.0 (const: 1.80.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2561">Source</a></span><pre class="code-header" data-language="rust">pub const fn trim_ascii_start(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">
<p>Returns a string slice with leading ASCII whitespace removed.</p> <p>‘Whitespace’ refers to the definition used by <a href="primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p> <h5 id="examples-59">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!(" \t \u{3000}hello world\n".trim_ascii_start(), "\u{3000}hello world\n");
assert_eq!("  ".trim_ascii_start(), "");
assert_eq!("".trim_ascii_start(), "");</pre></div> </div>
<summary><section id="method.trim_ascii_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const since 1.80.0">1.80.0 (const: 1.80.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2586">Source</a></span><pre class="code-header" data-language="rust">pub const fn trim_ascii_end(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">
<p>Returns a string slice with trailing ASCII whitespace removed.</p> <p>‘Whitespace’ refers to the definition used by <a href="primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p> <h5 id="examples-60">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("\r hello world\u{3000}\n ".trim_ascii_end(), "\r hello world\u{3000}");
assert_eq!("  ".trim_ascii_end(), "");
assert_eq!("".trim_ascii_end(), "");</pre></div> </div>
<summary><section id="method.trim_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const since 1.80.0">1.80.0 (const: 1.80.0)</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2612">Source</a></span><pre class="code-header" data-language="rust">pub const fn trim_ascii(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">
<p>Returns a string slice with leading and trailing ASCII whitespace removed.</p> <p>‘Whitespace’ refers to the definition used by <a href="primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p> <h5 id="examples-61">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("\r hello world\n ".trim_ascii(), "hello world");
assert_eq!("  ".trim_ascii(), "");
assert_eq!("".trim_ascii(), "");</pre></div> </div>
<summary><section id="method.escape_debug" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2655">Source</a></span><pre class="code-header" data-language="rust">pub fn escape_debug(&amp;self) -&gt; EscapeDebug&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Returns an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_debug" title="method char::escape_debug"><code>char::escape_debug</code></a>.</p> <p>Note: only extended grapheme codepoints that begin the string will be escaped.</p> <h5 id="examples-62">Examples</h5> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">for c in "❤\n!".escape_debug() {
    print!("{c}");
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("{}", "❤\n!".escape_debug());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("❤\\n!");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("❤\n!".escape_debug().to_string(), "❤\\n!");</pre></div> </div>
<summary><section id="method.escape_default" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2701">Source</a></span><pre class="code-header" data-language="rust">pub fn escape_default(&amp;self) -&gt; EscapeDefault&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Returns an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_default" title="method char::escape_default"><code>char::escape_default</code></a>.</p> <h5 id="examples-63">Examples</h5> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">for c in "❤\n!".escape_default() {
    print!("{c}");
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("{}", "❤\n!".escape_default());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("\\u{{2764}}\\n!");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("❤\n!".escape_default().to_string(), "\\u{2764}\\n!");</pre></div> </div>
<summary><section id="method.escape_unicode" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2739">Source</a></span><pre class="code-header" data-language="rust">pub fn escape_unicode(&amp;self) -&gt; EscapeUnicode&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Returns an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_unicode" title="method char::escape_unicode"><code>char::escape_unicode</code></a>.</p> <h5 id="examples-64">Examples</h5> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">for c in "❤\n!".escape_unicode() {
    print!("{c}");
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("{}", "❤\n!".escape_unicode());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("\\u{{2764}}\\u{{a}}\\u{{21}}");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("❤\n!".escape_unicode().to_string(), "\\u{2764}\\u{a}\\u{21}");</pre></div> </div>
<summary><section id="method.substr_range" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2772">Source</a><pre class="code-header" data-language="rust">pub fn substr_range(&amp;self, substr: &amp;str) -&gt; Option&lt;Range&lt;usize&gt;&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>substr_range</code> <a href="https://github.com/rust-lang/rust/issues/126769">#126769</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns the range that a substring points to.</p> <p>Returns <code>None</code> if <code>substr</code> does not point within <code>self</code>.</p> <p>Unlike <a href="primitive.str.html#method.find" title="method str::find"><code>str::find</code></a>, <strong>this does not search through the string</strong>. Instead, it uses pointer arithmetic to find where in the string <code>substr</code> is derived from.</p> <p>This is useful for extending <a href="primitive.str.html#method.split" title="method str::split"><code>str::split</code></a> and similar methods.</p> <p>Note that this method may return false positives (typically either <code>Some(0..0)</code> or <code>Some(self.len()..self.len())</code>) if <code>substr</code> is a zero-length <code>str</code> that points at the beginning or end of another, independent, <code>str</code>.</p> <h5 id="examples-65">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(substr_range)]

let data = "a, b, b, a";
let mut iter = data.split(", ").map(|s| data.substr_range(s).unwrap());

assert_eq!(iter.next(), Some(0..1));
assert_eq!(iter.next(), Some(3..4));
assert_eq!(iter.next(), Some(6..7));
assert_eq!(iter.next(), Some(9..10));</pre></div> </div>
<summary><section id="method.as_str" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2783">Source</a><pre class="code-header" data-language="rust">pub fn as_str(&amp;self) -&gt; &amp;str</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>str_as_str</code> <a href="https://github.com/rust-lang/rust/issues/130366">#130366</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns the same string as a string slice <code>&amp;str</code>.</p> <p>This method is redundant when used directly on <code>&amp;str</code>, but it helps dereferencing other string-like types to string slices, for example references to <code>Box&lt;str&gt;</code> or <code>Arc&lt;str&gt;</code>.</p> </div>
</div>
<summary><section id="impl-str-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#223">Source</a><pre class="code-header" data-language="rust">impl strMethods for string slices.
</pre></section></summary><div class="impl-items">
<summary><section id="method.into_boxed_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#238">Source</a></span><pre class="code-header" data-language="rust">pub fn into_boxed_bytes(self: Box&lt;str&gt;) -&gt; Box&lt;[u8]&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>Box&lt;str&gt;</code> into a <code>Box&lt;[u8]&gt;</code> without copying or allocating.</p> <h5 id="examples-66">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is a string";
let boxed_str = s.to_owned().into_boxed_str();
let boxed_bytes = boxed_str.into_boxed_bytes();
assert_eq!(*boxed_bytes, *s.as_bytes());</pre></div> </div>
<summary><section id="method.replace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#271">Source</a></span><pre class="code-header" data-language="rust">pub fn replace&lt;P&gt;(&amp;self, from: P, to: &amp;str) -&gt; Stringwhere
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Replaces all matches of a pattern with another string.</p> <p><code>replace</code> creates a new <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice.</p> <h5 id="examples-67">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is old";

assert_eq!("this is new", s.replace("old", "new"));
assert_eq!("than an old", s.replace("is", "an"));</pre></div> <p>When the pattern doesn’t match, it returns this string slice as <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is old";
assert_eq!(s, s.replace("cookie monster", "little lamb"));</pre></div> </div>
<summary><section id="method.replacen" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#327">Source</a></span><pre class="code-header" data-language="rust">pub fn replacen&lt;P&gt;(&amp;self, pat: P, to: &amp;str, count: usize) -&gt; Stringwhere
    P: Pattern,</pre></section></summary><div class="docblock">
<p>Replaces first N matches of a pattern with another string.</p> <p><code>replacen</code> creates a new <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice at most <code>count</code> times.</p> <h5 id="examples-68">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "foo foo 123 foo";
assert_eq!("new new 123 foo", s.replacen("foo", "new", 2));
assert_eq!("faa fao 123 foo", s.replacen('o', "a", 3));
assert_eq!("foo foo new23 foo", s.replacen(char::is_numeric, "new", 1));</pre></div> <p>When the pattern doesn’t match, it returns this string slice as <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is old";
assert_eq!(s, s.replacen("cookie monster", "little lamb", 10));</pre></div> </div>
<summary><section id="method.to_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#384">Source</a></span><pre class="code-header" data-language="rust">pub fn to_lowercase(&amp;self) -&gt; String</pre></section></summary><div class="docblock">
<p>Returns the lowercase equivalent of this string slice, as a new <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>.</p> <p>‘Lowercase’ is defined according to the terms of the Unicode Derived Core Property <code>Lowercase</code>.</p> <p>Since some characters can expand into multiple characters when changing the case, this function returns a <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a> instead of modifying the parameter in-place.</p> <h5 id="examples-69">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "HELLO";

assert_eq!("hello", s.to_lowercase());</pre></div> <p>A tricky example, with sigma:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let sigma = "Σ";

assert_eq!("σ", sigma.to_lowercase());

// but at the end of a word, it's ς, not σ:
let odysseus = "ὈΔΥΣΣΕΎΣ";

assert_eq!("ὀδυσσεύς", odysseus.to_lowercase());</pre></div> <p>Languages without case are not changed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let new_year = "农历新年";

assert_eq!(new_year, new_year.to_lowercase());</pre></div> </div>
<summary><section id="method.to_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#471">Source</a></span><pre class="code-header" data-language="rust">pub fn to_uppercase(&amp;self) -&gt; String</pre></section></summary><div class="docblock">
<p>Returns the uppercase equivalent of this string slice, as a new <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>.</p> <p>‘Uppercase’ is defined according to the terms of the Unicode Derived Core Property <code>Uppercase</code>.</p> <p>Since some characters can expand into multiple characters when changing the case, this function returns a <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a> instead of modifying the parameter in-place.</p> <h5 id="examples-70">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "hello";

assert_eq!("HELLO", s.to_uppercase());</pre></div> <p>Scripts without case are not changed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let new_year = "农历新年";

assert_eq!(new_year, new_year.to_uppercase());</pre></div> <p>One character can become multiple:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "tschüß";

assert_eq!("TSCHÜSS", s.to_uppercase());</pre></div> </div>
<summary><section id="method.into_string" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#505">Source</a></span><pre class="code-header" data-language="rust">pub fn into_string(self: Box&lt;str&gt;) -&gt; String</pre></section></summary><div class="docblock">
<p>Converts a <a href="boxed/struct.box.html" title="struct std::boxed::Box"><code>Box&lt;str&gt;</code></a> into a <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a> without copying or allocating.</p> <h5 id="examples-71">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let string = String::from("birthday gift");
let boxed_str = string.clone().into_boxed_str();

assert_eq!(boxed_str.into_string(), string);</pre></div> </div>
<summary><section id="method.repeat" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#535">Source</a></span><pre class="code-header" data-language="rust">pub fn repeat(&amp;self, n: usize) -&gt; String</pre></section></summary><div class="docblock">
<p>Creates a new <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a> by repeating a string <code>n</code> times.</p> <h5 id="panics-2">Panics</h5> <p>This function will panic if the capacity would overflow.</p> <h5 id="examples-72">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("abc".repeat(4), String::from("abcabcabcabc"));</pre></div> <p>A panic upon overflow:</p> <div class="example-wrap should_panic">ⓘ<pre class="rust rust-example-rendered" data-language="rust">// this will panic at runtime
let huge = "0123456789abcdef".repeat(usize::MAX);</pre>
</div> </div>
<summary><section id="method.to_ascii_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#565">Source</a></span><pre class="code-header" data-language="rust">pub fn to_ascii_uppercase(&amp;self) -&gt; String</pre></section></summary><div class="docblock">
<p>Returns a copy of this string where each character is mapped to its ASCII upper case equivalent.</p> <p>ASCII letters ‘a’ to ‘z’ are mapped to ‘A’ to ‘Z’, but non-ASCII letters are unchanged.</p> <p>To uppercase the value in-place, use <a href="primitive.str.html#method.make_ascii_uppercase" title="method str::make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p> <p>To uppercase ASCII characters in addition to non-ASCII characters, use <a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p> <h5 id="examples-73">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Grüße, Jürgen ❤";

assert_eq!("GRüßE, JüRGEN ❤", s.to_ascii_uppercase());</pre></div> </div>
<summary><section id="method.to_ascii_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#597">Source</a></span><pre class="code-header" data-language="rust">pub fn to_ascii_lowercase(&amp;self) -&gt; String</pre></section></summary><div class="docblock">
<p>Returns a copy of this string where each character is mapped to its ASCII lower case equivalent.</p> <p>ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’, but non-ASCII letters are unchanged.</p> <p>To lowercase the value in-place, use <a href="primitive.str.html#method.make_ascii_lowercase" title="method str::make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p> <p>To lowercase ASCII characters in addition to non-ASCII characters, use <a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p> <h5 id="examples-74">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Grüße, Jürgen ❤";

assert_eq!("grüße, jürgen ❤", s.to_ascii_lowercase());</pre></div> </div>
</div>
</div>
<h3 id="trait-implementations" class="section-header">Trait Implementations</h3>
<div id="trait-implementations-list">
<summary><section id="impl-Add%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#440">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Add&lt;&amp;'a str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-11" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#441">Source</a><pre class="code-header" data-language="rust">type Output = Cow&lt;'a, str&gt;</pre></section></summary><div class="docblock">The resulting type after applying the <code>+</code> operator.</div>
<summary><section id="method.add" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#444">Source</a><pre class="code-header" data-language="rust">fn add(self, rhs: &amp;'a str) -&gt; &lt;Cow&lt;'a, str&gt; as Add&lt;&amp;'a str&gt;&gt;::Output</pre></section></summary><div class="docblock">Performs the <code>+</code> operation. <a href="ops/trait.add.html#tymethod.add">Read more</a>
</div>
</div>
<summary><section id="impl-Add%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2557">Source</a></span><pre class="code-header" data-language="rust">impl Add&lt;&amp;str&gt; for StringImplements the + operator for concatenating two strings.
</pre></section></summary><div class="docblock">
<p>This consumes the <code>String</code> on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new <code>String</code> and copying the entire contents on every operation, which would lead to <em>O</em>(<em>n</em>^2) running time when building an <em>n</em>-byte string by repeated concatenation.</p> <p>The string on the right-hand side is only borrowed; its contents are copied into the returned <code>String</code>.</p> <h4 id="examples-84">Examples</h4> <p>Concatenating two <code>String</code>s takes the first by value and borrows the second:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = String::from("hello");
let b = String::from(" world");
let c = a + &amp;b;
// `a` is moved and can no longer be used here.</pre></div> <p>If you want to keep using the first <code>String</code>, you can clone it and append to the clone instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = String::from("hello");
let b = String::from(" world");
let c = a.clone() + &amp;b;
// `a` is still valid here.</pre></div> <p>Concatenating <code>&amp;str</code> slices can be done by converting the first to a <code>String</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = "hello";
let b = " world";
let c = a.to_string() + b;</pre></div> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-12" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2558">Source</a><pre class="code-header" data-language="rust">type Output = String</pre></section></summary><div class="docblock">The resulting type after applying the <code>+</code> operator.</div>
<summary><section id="method.add-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2561">Source</a><pre class="code-header" data-language="rust">fn add(self, other: &amp;str) -&gt; String</pre></section></summary><div class="docblock">Performs the <code>+</code> operation. <a href="ops/trait.add.html#tymethod.add">Read more</a>
</div>
</div>
<summary><section id="impl-AddAssign%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#464">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; AddAssign&lt;&amp;'a str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.add_assign" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#465">Source</a><pre class="code-header" data-language="rust">fn add_assign(&amp;mut self, rhs: &amp;'a str)</pre></section></summary><div class="docblock">Performs the <code>+=</code> operation. <a href="ops/trait.addassign.html#tymethod.add_assign">Read more</a>
</div>
</div>
<summary><section id="impl-AddAssign%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2572">Source</a></span><pre class="code-header" data-language="rust">impl AddAssign&lt;&amp;str&gt; for StringImplements the += operator for appending to a String.
</pre></section></summary><div class="docblock">
<p>This has the same behavior as the <a href="string/struct.string.html#method.push_str" title="method std::string::String::push_str"><code>push_str</code></a> method.</p> </div>
<div class="impl-items">
<summary><section id="method.add_assign-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2574">Source</a><pre class="code-header" data-language="rust">fn add_assign(&amp;mut self, other: &amp;str)</pre></section></summary><div class="docblock">Performs the <code>+=</code> operation. <a href="ops/trait.addassign.html#tymethod.add_assign">Read more</a>
</div>
</div>
<summary><section id="impl-AsMut%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2853">Source</a></span><pre class="code-header" data-language="rust">impl AsMut&lt;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.as_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2855">Source</a><pre class="code-header" data-language="rust">fn as_mut(&amp;mut self) -&gt; &amp;mut str</pre></section></summary><div class="docblock">Converts this type into a mutable reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsMut%3Cstr%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span><a class="src" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#848">Source</a></span><pre class="code-header" data-language="rust">impl AsMut&lt;str&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.as_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#850">Source</a><pre class="code-header" data-language="rust">fn as_mut(&amp;mut self) -&gt; &amp;mut str</pre></section></summary><div class="docblock">Converts this type into a mutable reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3C%5Bu8%5D%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2789">Source</a></span><pre class="code-header" data-language="rust">impl AsRef&lt;[u8]&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2791">Source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;[u8] ⓘ</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3COsStr%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1645-1650">Source</a></span><pre class="code-header" data-language="rust">impl AsRef&lt;OsStr&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1647-1649">Source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;OsStr</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3CPath%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3354-3359">Source</a></span><pre class="code-header" data-language="rust">impl AsRef&lt;Path&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3356-3358">Source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;Path</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3Cstr%3E-for-Drain%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#3157">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; AsRef&lt;str&gt; for Drain&lt;'a&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#3158">Source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2845">Source</a></span><pre class="code-header" data-language="rust">impl AsRef&lt;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2847">Source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3Cstr%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#840">Source</a></span><pre class="code-header" data-language="rust">impl AsRef&lt;str&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#842">Source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsciiExt-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ascii.rs.html#206-210">Source</a></span><pre class="code-header" data-language="rust">impl AsciiExt for str</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#207">Source</a><pre class="code-header" data-language="rust">type Owned = String</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Container type for copied ASCII characters.</div>
<summary><section id="method.is_ascii-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#209">Source</a><pre class="code-header" data-language="rust">fn is_ascii(&amp;self) -&gt; bool</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Checks if the value is within the ASCII range. <a href="ascii/trait.asciiext.html#tymethod.is_ascii">Read more</a>
</div>
<summary><section id="method.to_ascii_uppercase-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#209">Source</a><pre class="code-header" data-language="rust">fn to_ascii_uppercase(&amp;self) -&gt; Self::Owned</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Makes a copy of the value in its ASCII upper case equivalent. <a href="ascii/trait.asciiext.html#tymethod.to_ascii_uppercase">Read more</a>
</div>
<summary><section id="method.to_ascii_lowercase-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#209">Source</a><pre class="code-header" data-language="rust">fn to_ascii_lowercase(&amp;self) -&gt; Self::Owned</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Makes a copy of the value in its ASCII lower case equivalent. <a href="ascii/trait.asciiext.html#tymethod.to_ascii_lowercase">Read more</a>
</div>
<summary><section id="method.eq_ignore_ascii_case-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#209">Source</a><pre class="code-header" data-language="rust">fn eq_ignore_ascii_case(&amp;self, o: &amp;Self) -&gt; bool</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Checks that two values are an ASCII case-insensitive match. <a href="ascii/trait.asciiext.html#tymethod.eq_ignore_ascii_case">Read more</a>
</div>
<summary><section id="method.make_ascii_uppercase-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#209">Source</a><pre class="code-header" data-language="rust">fn make_ascii_uppercase(&amp;mut self)</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Converts this type to its ASCII upper case equivalent in-place. <a href="ascii/trait.asciiext.html#tymethod.make_ascii_uppercase">Read more</a>
</div>
<summary><section id="method.make_ascii_lowercase-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ascii.rs.html#209">Source</a><pre class="code-header" data-language="rust">fn make_ascii_lowercase(&amp;mut self)</pre></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span>
</div></span><div class="docblock">Converts this type to its ASCII lower case equivalent in-place. <a href="ascii/trait.asciiext.html#tymethod.make_ascii_lowercase">Read more</a>
</div>
</div>
<summary><section id="impl-Borrow%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#189">Source</a></span><pre class="code-header" data-language="rust">impl Borrow&lt;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#191">Source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;str</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="borrow/trait.borrow.html#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-BorrowMut%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#197">Source</a></span><pre class="code-header" data-language="rust">impl BorrowMut&lt;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#199">Source</a><pre class="code-header" data-language="rust">fn borrow_mut(&amp;mut self) -&gt; &amp;mut str</pre></section></summary><div class="docblock">Mutably borrows from an owned value. <a href="borrow/trait.borrowmut.html#tymethod.borrow_mut">Read more</a>
</div>
</div>
<summary><section id="impl-Clone-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1828">Source</a></span><pre class="code-header" data-language="rust">impl Clone for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1829">Source</a><pre class="code-header" data-language="rust">fn clone(&amp;self) -&gt; Box&lt;str&gt;</pre></section></summary><div class="docblock">Returns a copy of the value. <a href="clone/trait.clone.html#tymethod.clone">Read more</a>
</div>
<summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/clone.rs.html#174">Source</a></span><pre class="code-header" data-language="rust">fn clone_from(&amp;mut self, source: &amp;Self)</pre></section></summary><div class="docblock">Performs copy-assignment from <code>source</code>. <a href="clone/trait.clone.html#method.clone_from">Read more</a>
</div>
</div>
<summary><section id="impl-CloneToUninit-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/clone.rs.html#293">Source</a><pre class="code-header" data-language="rust">impl CloneToUninit for str</pre></section></summary><div class="impl-items">
<summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/clone.rs.html#296">Source</a><pre class="code-header" data-language="rust">unsafe fn clone_to_uninit(&amp;self, dst: *mut u8)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code> <a href="https://github.com/rust-lang/rust/issues/126799">#126799</a>)</span>
</div></span><div class="docblock">Performs copy-assignment from <code>self</code> to <code>dst</code>. <a href="clone/trait.clonetouninit.html#tymethod.clone_to_uninit">Read more</a>
</div>
</div>
<summary><section id="impl-Concat%3Cstr%3E-for-%5BS%5D" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#62">Source</a><pre class="code-header" data-language="rust">impl&lt;S&gt; Concat&lt;str&gt; for [S]where
    S: Borrow&lt;str&gt;,Note: str in Concat&lt;str&gt; is not meaningful here.
This type parameter of the trait only exists to enable another impl.
</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-13" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#63">Source</a><pre class="code-header" data-language="rust">type Output = String</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span>
</div></span><div class="docblock">The resulting type after concatenation</div>
<summary><section id="method.concat" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#65">Source</a><pre class="code-header" data-language="rust">fn concat(slice: &amp;[S]) -&gt; String</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span>
</div></span><div class="docblock">Implementation of <a href="primitive.slice.html#method.concat" title="method slice::concat"><code>[T]::concat</code></a>
</div>
</div>
<summary><section id="impl-Debug-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2687">Source</a></span><pre class="code-header" data-language="rust">impl Debug for str</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2688">Source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="fmt/trait.debug.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Default-for-%26mut+str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2806">Source</a></span><pre class="code-header" data-language="rust">impl Default for &amp;mut str</pre></section></summary><div class="impl-items">
<summary><section id="method.default-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2809">Source</a><pre class="code-header" data-language="rust">fn default() -&gt; &amp;mut str</pre></section></summary><div class="docblock">
<p>Creates an empty mutable str</p> </div>
</div>
<summary><section id="impl-Default-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2797">Source</a></span><pre class="code-header" data-language="rust">impl Default for &amp;str</pre></section></summary><div class="impl-items">
<summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2800">Source</a><pre class="code-header" data-language="rust">fn default() -&gt; &amp;str</pre></section></summary><div class="docblock">
<p>Creates an empty str</p> </div>
</div>
<summary><section id="impl-Default-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1729">Source</a></span><pre class="code-header" data-language="rust">impl Default for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.default-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1731">Source</a><pre class="code-header" data-language="rust">fn default() -&gt; Box&lt;str&gt;</pre></section></summary><div class="docblock">Returns the “default value” for a type. <a href="default/trait.default.html#tymethod.default">Read more</a>
</div>
</div>
<summary><section id="impl-Display-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2736">Source</a></span><pre class="code-header" data-language="rust">impl Display for str</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2737">Source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="fmt/trait.display.html#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Extend%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2345">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; Extend&lt;&amp;'a str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.extend" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2346">Source</a><pre class="code-header" data-language="rust">fn extend&lt;I&gt;(&amp;mut self, iter: I)where
    I: IntoIterator&lt;Item = &amp;'a str&gt;,</pre></section></summary><div class="docblock">Extends a collection with the contents of an iterator. <a href="iter/trait.extend.html#tymethod.extend">Read more</a>
</div>
<summary><section id="method.extend_one" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2351">Source</a><pre class="code-header" data-language="rust">fn extend_one(&amp;mut self, s: &amp;'a str)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span>
</div></span><div class="docblock">Extends a collection with exactly one element.</div>
<summary><section id="method.extend_reserve" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/collect.rs.html#428">Source</a><pre class="code-header" data-language="rust">fn extend_reserve(&amp;mut self, additional: usize)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span>
</div></span><div class="docblock">Reserves capacity in a collection for the given number of additional elements. <a href="iter/trait.extend.html#method.extend_reserve">Read more</a>
</div>
</div>
<summary><section id="impl-From%3C%26mut+str%3E-for-Arc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3678">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;mut str&gt; for Arc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-12" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3691">Source</a><pre class="code-header" data-language="rust">fn from(v: &amp;mut str) -&gt; Arc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Allocates a reference-counted <code>str</code> and copies <code>v</code> into it.</p> <h5 id="example-4">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut original = String::from("eggplant");
let original: &amp;mut str = &amp;mut original;
let shared: Arc&lt;str&gt; = Arc::from(original);
assert_eq!("eggplant", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26mut+str%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/convert.rs.html#175">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;mut str&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/convert.rs.html#190">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;mut str) -&gt; Box&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>&amp;mut str</code> into a <code>Box&lt;str&gt;</code></p> <p>This conversion allocates on the heap and performs a copy of <code>s</code>.</p> <h5 id="examples-78">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut original = String::from("hello");
let original: &amp;mut str = &amp;mut original;
let boxed: Box&lt;str&gt; = Box::from(original);
println!("{boxed}");</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26mut+str%3E-for-Rc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2730">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;mut str&gt; for Rc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2743">Source</a><pre class="code-header" data-language="rust">fn from(v: &amp;mut str) -&gt; Rc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Allocates a reference-counted string slice and copies <code>v</code> into it.</p> <h5 id="example-1">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut original = String::from("statue");
let original: &amp;mut str = &amp;mut original;
let shared: Rc&lt;str&gt; = Rc::from(original);
assert_eq!("statue", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26mut+str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2882">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;mut str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.from-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2887">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;mut str) -&gt; String</pre></section></summary><div class="docblock">
<p>Converts a <code>&amp;mut str</code> into a <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>.</p> <p>The result is allocated on the heap.</p> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Arc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3659">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for Arc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-11" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#3670">Source</a><pre class="code-header" data-language="rust">fn from(v: &amp;str) -&gt; Arc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Allocates a reference-counted <code>str</code> and copies <code>v</code> into it.</p> <h5 id="example-3">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let shared: Arc&lt;str&gt; = Arc::from("eggplant");
assert_eq!("eggplant", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Box%3Cdyn+Error%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/convert.rs.html#686">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; From&lt;&amp;str&gt; for Box&lt;dyn Error + 'a&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/convert.rs.html#701">Source</a><pre class="code-header" data-language="rust">fn from(err: &amp;str) -&gt; Box&lt;dyn Error + 'a&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="primitive.str.html" title="primitive str"><code>str</code></a> into a box of dyn <a href="error/trait.error.html" title="trait std::error::Error"><code>Error</code></a>.</p> <h5 id="examples-81">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::error::Error;
use std::mem;

let a_str_error = "a str error";
let a_boxed_error = Box::&lt;dyn Error&gt;::from(a_str_error);
assert!(mem::size_of::&lt;Box&lt;dyn Error&gt;&gt;() == mem::size_of_val(&amp;a_boxed_error))</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Box%3Cdyn+Error+%2B+Send+%2B+Sync%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/convert.rs.html#662">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; From&lt;&amp;str&gt; for Box&lt;dyn Error + Sync + Send + 'a&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/convert.rs.html#679">Source</a><pre class="code-header" data-language="rust">fn from(err: &amp;str) -&gt; Box&lt;dyn Error + Sync + Send + 'a&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="primitive.str.html" title="primitive str"><code>str</code></a> into a box of dyn <a href="error/trait.error.html" title="trait std::error::Error"><code>Error</code></a> + <a href="marker/trait.send.html" title="trait std::marker::Send"><code>Send</code></a> + <a href="marker/trait.sync.html" title="trait std::marker::Sync"><code>Sync</code></a>.</p> <h5 id="examples-80">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::error::Error;
use std::mem;

let a_str_error = "a str error";
let a_boxed_error = Box::&lt;dyn Error + Send + Sync&gt;::from(a_str_error);
assert!(
    mem::size_of::&lt;Box&lt;dyn Error + Send + Sync&gt;&gt;() == mem::size_of_val(&amp;a_boxed_error))</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/convert.rs.html#155">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/convert.rs.html#168">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;str) -&gt; Box&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>&amp;str</code> into a <code>Box&lt;str&gt;</code></p> <p>This conversion allocates on the heap and performs a copy of <code>s</code>.</p> <h5 id="examples-77">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let boxed: Box&lt;str&gt; = Box::from("hello");
println!("{boxed}");</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2970">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; From&lt;&amp;'a str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2984">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;'a str) -&gt; Cow&lt;'a, str&gt;</pre></section></summary><div class="docblock">
<p>Converts a string slice into a <a href="borrow/enum.cow.html#variant.Borrowed" title="borrow::Cow::Borrowed"><code>Borrowed</code></a> variant. No heap allocation is performed, and the string is not copied.</p> <h5 id="example-2">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!(Cow::from("eggplant"), Cow::Borrowed("eggplant"));</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Rc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2711">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for Rc&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#2722">Source</a><pre class="code-header" data-language="rust">fn from(v: &amp;str) -&gt; Rc&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Allocates a reference-counted string slice and copies <code>v</code> into it.</p> <h5 id="example">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let shared: Rc&lt;str&gt; = Rc::from("statue");
assert_eq!("statue", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2870">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2875">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;str) -&gt; String</pre></section></summary><div class="docblock">
<p>Converts a <code>&amp;str</code> into a <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a>.</p> <p>The result is allocated on the heap.</p> </div>
</div>
<summary><section id="impl-From%3C%26str%3E-for-Vec%3Cu8%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#4002">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;&amp;str&gt; for Vec&lt;u8&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-13" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#4011">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;str) -&gt; Vec&lt;u8&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Allocates a <code>Vec&lt;u8&gt;</code> and fills it with a UTF-8 string.</p> <h5 id="examples-83">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!(Vec::from("123"), vec![b'1', b'2', b'3']);</pre></div> </div>
</div>
<summary><section id="impl-From%3CCow%3C'_,+str%3E%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/convert.rs.html#197">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;Cow&lt;'_, str&gt;&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/convert.rs.html#222">Source</a><pre class="code-header" data-language="rust">fn from(cow: Cow&lt;'_, str&gt;) -&gt; Box&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>Cow&lt;'_, str&gt;</code> into a <code>Box&lt;str&gt;</code></p> <p>When <code>cow</code> is the <code>Cow::Borrowed</code> variant, this conversion allocates on the heap and copies the underlying <code>str</code>. Otherwise, it will try to reuse the owned <code>String</code>’s allocation.</p> <h5 id="examples-79">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::borrow::Cow;

let unboxed = Cow::Borrowed("hello");
let boxed: Box&lt;str&gt; = Box::from(unboxed);
println!("{boxed}");</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let unboxed = Cow::Owned("hello".to_string());
let boxed: Box&lt;str&gt; = Box::from(unboxed);
println!("{boxed}");</pre></div> </div>
</div>
<summary><section id="impl-From%3CString%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2927">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;String&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2939">Source</a><pre class="code-header" data-language="rust">fn from(s: String) -&gt; Box&lt;str&gt;</pre></section></summary><div class="docblock">
<p>Converts the given <a href="string/struct.string.html" title="struct std::string::String"><code>String</code></a> to a boxed <code>str</code> slice that is owned.</p> <h5 id="examples-82">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s1: String = String::from("hello world");
let s2: Box&lt;str&gt; = Box::from(s1);
let s3: String = String::from(s2);

assert_eq!("hello world", s3)</pre></div> </div>
</div>
<summary><section id="impl-FromIterator%3C%26char%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#158">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; FromIterator&lt;&amp;'a char&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#159">Source</a><pre class="code-header" data-language="rust">fn from_iter&lt;T&gt;(iter: T) -&gt; Box&lt;str&gt;where
    T: IntoIterator&lt;Item = &amp;'a char&gt;,</pre></section></summary><div class="docblock">Creates a value from an iterator. <a href="iter/trait.fromiterator.html#tymethod.from_iter">Read more</a>
</div>
</div>
<summary><section id="impl-FromIterator%3C%26str%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#166">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; FromIterator&lt;&amp;'a str&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#167">Source</a><pre class="code-header" data-language="rust">fn from_iter&lt;T&gt;(iter: T) -&gt; Box&lt;str&gt;where
    T: IntoIterator&lt;Item = &amp;'a str&gt;,</pre></section></summary><div class="docblock">Creates a value from an iterator. <a href="iter/trait.fromiterator.html#tymethod.from_iter">Read more</a>
</div>
</div>
<summary><section id="impl-FromIterator%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#3044">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; FromIterator&lt;&amp;'b str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#3045">Source</a><pre class="code-header" data-language="rust">fn from_iter&lt;I&gt;(it: I) -&gt; Cow&lt;'a, str&gt;where
    I: IntoIterator&lt;Item = &amp;'b str&gt;,</pre></section></summary><div class="docblock">Creates a value from an iterator. <a href="iter/trait.fromiterator.html#tymethod.from_iter">Read more</a>
</div>
</div>
<summary><section id="impl-FromIterator%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2247">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; FromIterator&lt;&amp;'a str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2248">Source</a><pre class="code-header" data-language="rust">fn from_iter&lt;I&gt;(iter: I) -&gt; Stringwhere
    I: IntoIterator&lt;Item = &amp;'a str&gt;,</pre></section></summary><div class="docblock">Creates a value from an iterator. <a href="iter/trait.fromiterator.html#tymethod.from_iter">Read more</a>
</div>
</div>
<summary><section id="impl-FromIterator%3CBox%3Cstr,+A%3E%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#182">Source</a></span><pre class="code-header" data-language="rust">impl&lt;A&gt; FromIterator&lt;Box&lt;str, A&gt;&gt; for Box&lt;str&gt;where
    A: Allocator,</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#183">Source</a><pre class="code-header" data-language="rust">fn from_iter&lt;T&gt;(iter: T) -&gt; Box&lt;str&gt;where
    T: IntoIterator&lt;Item = Box&lt;str, A&gt;&gt;,</pre></section></summary><div class="docblock">Creates a value from an iterator. <a href="iter/trait.fromiterator.html#tymethod.from_iter">Read more</a>
</div>
</div>
<summary><section id="impl-FromIterator%3CCow%3C'a,+str%3E%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#190">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; FromIterator&lt;Cow&lt;'a, str&gt;&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#191">Source</a><pre class="code-header" data-language="rust">fn from_iter&lt;T&gt;(iter: T) -&gt; Box&lt;str&gt;where
    T: IntoIterator&lt;Item = Cow&lt;'a, str&gt;&gt;,</pre></section></summary><div class="docblock">Creates a value from an iterator. <a href="iter/trait.fromiterator.html#tymethod.from_iter">Read more</a>
</div>
</div>
<summary><section id="impl-FromIterator%3CString%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#174">Source</a></span><pre class="code-header" data-language="rust">impl FromIterator&lt;String&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#175">Source</a><pre class="code-header" data-language="rust">fn from_iter&lt;T&gt;(iter: T) -&gt; Box&lt;str&gt;where
    T: IntoIterator&lt;Item = String&gt;,</pre></section></summary><div class="docblock">Creates a value from an iterator. <a href="iter/trait.fromiterator.html#tymethod.from_iter">Read more</a>
</div>
</div>
<summary><section id="impl-FromIterator%3Cchar%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#150">Source</a></span><pre class="code-header" data-language="rust">impl FromIterator&lt;char&gt; for Box&lt;str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/boxed/iter.rs.html#151">Source</a><pre class="code-header" data-language="rust">fn from_iter&lt;T&gt;(iter: T) -&gt; Box&lt;str&gt;where
    T: IntoIterator&lt;Item = char&gt;,</pre></section></summary><div class="docblock">Creates a value from an iterator. <a href="iter/trait.fromiterator.html#tymethod.from_iter">Read more</a>
</div>
</div>
<summary><section id="impl-Hash-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#864">Source</a></span><pre class="code-header" data-language="rust">impl Hash for str</pre></section></summary><div class="impl-items">
<summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#866">Source</a><pre class="code-header" data-language="rust">fn hash&lt;H&gt;(&amp;self, state: &amp;mut H)where
    H: Hasher,</pre></section></summary><div class="docblock">Feeds this value into the given <a href="hash/trait.hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.hash.html#tymethod.hash">Read more</a>
</div>
</div>
<summary><section id="impl-Index%3CI%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#52-54">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; Index&lt;I&gt; for strwhere
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#56">Source</a><pre class="code-header" data-language="rust">type Output = &lt;I as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><div class="docblock">The returned type after indexing.</div>
<summary><section id="method.index" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#59">Source</a><pre class="code-header" data-language="rust">fn index(&amp;self, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><div class="docblock">Performs the indexing (<code>container[index]</code>) operation. <a href="ops/trait.index.html#tymethod.index">Read more</a>
</div>
</div>
<summary><section id="impl-IndexMut%3CI%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#65-67">Source</a></span><pre class="code-header" data-language="rust">impl&lt;I&gt; IndexMut&lt;I&gt; for strwhere
    I: SliceIndex&lt;str&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.index_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#70">Source</a><pre class="code-header" data-language="rust">fn index_mut(&amp;mut self, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><div class="docblock">Performs the mutable indexing (<code>container[index]</code>) operation. <a href="ops/trait.indexmut.html#tymethod.index_mut">Read more</a>
</div>
</div>
<summary><section id="impl-Join%3C%26str%3E-for-%5BS%5D" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#72">Source</a><pre class="code-header" data-language="rust">impl&lt;S&gt; Join&lt;&amp;str&gt; for [S]where
    S: Borrow&lt;str&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-14" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#73">Source</a><pre class="code-header" data-language="rust">type Output = String</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span>
</div></span><div class="docblock">The resulting type after concatenation</div>
<summary><section id="method.join" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#75">Source</a><pre class="code-header" data-language="rust">fn join(slice: &amp;[S], sep: &amp;str) -&gt; String</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span>
</div></span><div class="docblock">Implementation of <a href="primitive.slice.html#method.join" title="method slice::join"><code>[T]::join</code></a>
</div>
</div>
<summary><section id="impl-Ord-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#18">Source</a></span><pre class="code-header" data-language="rust">impl Ord for strImplements ordering of strings.
</pre></section></summary><div class="docblock">
<p>Strings are ordered <a href="cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">lexicographically</a> by their byte values. This orders Unicode code points based on their positions in the code charts. This is not necessarily the same as “alphabetical” order, which varies by language and locale. Sorting strings according to culturally-accepted standards requires locale-specific data that is outside the scope of the <code>str</code> type.</p> </div>
<div class="impl-items">
<summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#20">Source</a><pre class="code-header" data-language="rust">fn cmp(&amp;self, other: &amp;str) -&gt; Ordering</pre></section></summary><div class="docblock">This method returns an <a href="cmp/enum.ordering.html" title="enum std::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.ord.html#tymethod.cmp">Read more</a>
</div>
</div>
<summary><section id="impl-PartialEq%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2481">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'b str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2481">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;'b str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2481">Source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;&amp;'b str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3C%26str%3E-for-OsString" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#688-693">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;&amp;str&gt; for OsString</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-11" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#690-692">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-11" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#261">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2477">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2477">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;'a str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2477">Source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;&amp;'a str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2481">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;Cow&lt;'a, str&gt;&gt; for &amp;'b str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2481">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2481">Source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2479">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;Cow&lt;'a, str&gt;&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2479">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2479">Source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3COsStr%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1441-1446">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;OsStr&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-14" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1443-1445">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;OsStr) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-14" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#261">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3COsString%3E-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#696-701">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialEq&lt;OsString&gt; for &amp;'a str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-12" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#698-700">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;OsString) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-12" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#261">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3COsString%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#680-685">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;OsString&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#682-684">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;OsString) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-10" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#261">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CString%3E-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2477">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;String&gt; for &amp;'a str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2477">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;String) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2477">Source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;String) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CString%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2476">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;String&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2476">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;String) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2476">Source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;String) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2479">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;str&gt; for Cow&lt;'a, str&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2479">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2479">Source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-for-OsStr" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1433-1438">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;str&gt; for OsStr</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-13" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1435-1437">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-13" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#261">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-for-OsString" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#672-677">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;str&gt; for OsString</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#674-676">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-9" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#261">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2476">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a, 'b&gt; PartialEq&lt;str&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2476">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2476">Source</a><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#26">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq for str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#28">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#261">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialOrd%3Cstr%3E-for-OsStr" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1476-1481">Source</a></span><pre class="code-header" data-language="rust">impl PartialOrd&lt;str&gt; for OsStr</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1478-1480">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;str) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord.html#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1335">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord.html#method.lt">Read more</a>
</div>
<summary><section id="method.le-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1353">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord.html#method.le">Read more</a>
</div>
<summary><section id="method.gt-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1371">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord.html#method.gt">Read more</a>
</div>
<summary><section id="method.ge-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1389">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord.html#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3Cstr%3E-for-OsString" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#731-736">Source</a></span><pre class="code-header" data-language="rust">impl PartialOrd&lt;str&gt; for OsString</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#733-735">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;str) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord.html#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1335">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord.html#method.lt">Read more</a>
</div>
<summary><section id="method.le-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1353">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord.html#method.le">Read more</a>
</div>
<summary><section id="method.gt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1371">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord.html#method.gt">Read more</a>
</div>
<summary><section id="method.ge-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1389">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord.html#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#44">Source</a></span><pre class="code-header" data-language="rust">impl PartialOrd for strImplements comparison operations on strings.
</pre></section></summary><div class="docblock">
<p>Strings are compared <a href="cmp/trait.ord.html#lexicographical-comparison" title="trait std::cmp::Ord">lexicographically</a> by their byte values. This compares Unicode code points based on their positions in the code charts. This is not necessarily the same as “alphabetical” order, which varies by language and locale. Comparing strings according to culturally-accepted standards requires locale-specific data that is outside the scope of the <code>str</code> type.</p> </div>
<div class="impl-items">
<summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#46">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;str) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord.html#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1335">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord.html#method.lt">Read more</a>
</div>
<summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1353">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord.html#method.le">Read more</a>
</div>
<summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1371">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord.html#method.gt">Read more</a>
</div>
<summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1389">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord.html#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-Pattern-for-%26str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#971">Source</a><pre class="code-header" data-language="rust">impl&lt;'b&gt; Pattern for &amp;'b strNon-allocating substring search.
</pre></section></summary><div class="docblock">
<p>Will handle the pattern <code>""</code> as returning empty matches at each character boundary.</p> <h4 id="examples-76">Examples</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("Hello world".find("world"), Some(6));</pre></div> </div>
<div class="impl-items">
<summary><section id="method.is_prefix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#981">Source</a><pre class="code-header" data-language="rust">fn is_prefix_of(self, haystack: &amp;str) -&gt; bool</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span></summary><div class="docblock">
<p>Checks whether the pattern matches at the front of the haystack.</p> </div>
<summary><section id="method.is_contained_in" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#987">Source</a><pre class="code-header" data-language="rust">fn is_contained_in(self, haystack: &amp;str) -&gt; bool</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span></summary><div class="docblock">
<p>Checks whether the pattern matches anywhere in the haystack</p> </div>
<summary><section id="method.strip_prefix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#1013">Source</a><pre class="code-header" data-language="rust">fn strip_prefix_of(self, haystack: &amp;str) -&gt; Option&lt;&amp;str&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span></summary><div class="docblock">
<p>Removes the pattern from the front of haystack, if it matches.</p> </div>
<summary><section id="method.is_suffix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#1024-1026">Source</a><pre class="code-header" data-language="rust">fn is_suffix_of&lt;'a&gt;(self, haystack: &amp;'a str) -&gt; boolwhere
    &lt;&amp;'b str as Pattern&gt;::Searcher&lt;'a&gt;: ReverseSearcher&lt;'a&gt;,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span></summary><div class="docblock">
<p>Checks whether the pattern matches at the back of the haystack.</p> </div>
<summary><section id="method.strip_suffix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#1033-1035">Source</a><pre class="code-header" data-language="rust">fn strip_suffix_of&lt;'a&gt;(self, haystack: &amp;'a str) -&gt; Option&lt;&amp;'a str&gt;where
    &lt;&amp;'b str as Pattern&gt;::Searcher&lt;'a&gt;: ReverseSearcher&lt;'a&gt;,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span></summary><div class="docblock">
<p>Removes the pattern from the back of haystack, if it matches.</p> </div>
<summary><section id="associatedtype.Searcher" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#972">Source</a><pre class="code-header" data-language="rust">type Searcher&lt;'a&gt; = StrSearcher&lt;'a, 'b&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Associated searcher for this pattern</div>
<summary><section id="method.into_searcher" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#975">Source</a><pre class="code-header" data-language="rust">fn into_searcher(self, haystack: &amp;str) -&gt; StrSearcher&lt;'_, 'b&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Constructs the associated searcher from <code>self</code> and the <code>haystack</code> to search in.</div>
<summary><section id="method.as_utf8_pattern" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#1047">Source</a><pre class="code-header" data-language="rust">fn as_utf8_pattern(&amp;self) -&gt; Option&lt;Utf8Pattern&lt;'_&gt;&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span>
</div></span><div class="docblock">Returns the pattern as utf-8 bytes if possible.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-(Bound%3Cusize%3E,+Bound%3Cusize%3E)" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#376">Source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for (Bound&lt;usize&gt;, Bound&lt;usize&gt;)Implements substring slicing for arbitrary bounds.
</pre></section></summary><div class="docblock">
<p>Returns a slice of the given string bounded by the byte indices provided by each bound.</p> <p>This operation is <em>O</em>(1).</p> <h4 id="panics-4">Panics</h4> <p>Panics if <code>begin</code> or <code>end</code> (if it exists and once adjusted for inclusion/exclusion) does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), if <code>begin &gt; end</code>, or if <code>end &gt; len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#377">Source</a><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#380">Source</a><pre class="code-header" data-language="rust">fn get(self, slice: &amp;str) -&gt; Option&lt;&amp;str&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#385">Source</a><pre class="code-header" data-language="rust">fn get_mut(self, slice: &amp;mut str) -&gt; Option&lt;&amp;mut str&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#390">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked(self, slice: *const str) -&gt; *const str</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked">Read more</a>
</div>
<summary><section id="method.get_unchecked_mut-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#397">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(self, slice: *mut str) -&gt; *mut str</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked_mut">Read more</a>
</div>
<summary><section id="method.index-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#404">Source</a><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;str</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#409">Source</a><pre class="code-header" data-language="rust">fn index_mut(self, slice: &amp;mut str) -&gt; &amp;mut str</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#159">Source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for Range&lt;usize&gt;Implements substring slicing with syntax &amp;self[begin .. end] or &amp;mut self[begin .. end].
</pre></section></summary><div class="docblock">
<p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>end</code>).</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <h4 id="panics-3">Panics</h4> <p>Panics if <code>begin</code> or <code>end</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), if <code>begin &gt; end</code>, or if <code>end &gt; len</code>.</p> <h4 id="examples-75">Examples</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Löwe 老虎 Léopard";
assert_eq!(&amp;s[0 .. 1], "L");

assert_eq!(&amp;s[1 .. 9], "öwe 老");

// these will panic:
// byte 2 lies within `ö`:
// &amp;s[2 ..3];

// byte 8 lies within `老`
// &amp;s[1 .. 8];

// byte 100 is outside the string
// &amp;s[3 .. 100];</pre></div> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#160">Source</a><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#162">Source</a><pre class="code-header" data-language="rust">fn get(self, slice: &amp;str) -&gt; Option&lt;&amp;&lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#176">Source</a><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str,
) -&gt; Option&lt;&amp;mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#189">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str,
) -&gt; *const &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked">Read more</a>
</div>
<summary><section id="method.get_unchecked_mut-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#216">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str,
) -&gt; *mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked_mut">Read more</a>
</div>
<summary><section id="method.index-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#236">Source</a><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;&lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output ⓘ</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#244">Source</a><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str,
) -&gt; &amp;mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output ⓘ</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#261">Source</a><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for Range&lt;usize&gt;</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#262">Source</a><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#264">Source</a><pre class="code-header" data-language="rust">fn get(self, slice: &amp;str) -&gt; Option&lt;&amp;&lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#278">Source</a><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str,
) -&gt; Option&lt;&amp;mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#291">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str,
) -&gt; *const &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked">Read more</a>
</div>
<summary><section id="method.get_unchecked_mut-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#318">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str,
) -&gt; *mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked_mut">Read more</a>
</div>
<summary><section id="method.index-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#338">Source</a><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;&lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#346">Source</a><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str,
) -&gt; &amp;mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#498">Source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeFrom&lt;usize&gt;Implements substring slicing with syntax &amp;self[begin ..] or &amp;mut self[begin ..].
</pre></section></summary><div class="docblock">
<p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>len</code>). Equivalent to <code>&amp;self[begin .. len]</code> or <code>&amp;mut self[begin .. len]</code>.</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <h4 id="panics-6">Panics</h4> <p>Panics if <code>begin</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), or if <code>begin &gt; len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#499">Source</a><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#501">Source</a><pre class="code-header" data-language="rust">fn get(
    self,
    slice: &amp;str,
) -&gt; Option&lt;&amp;&lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#511">Source</a><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str,
) -&gt; Option&lt;&amp;mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#521">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str,
) -&gt; *const &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked">Read more</a>
</div>
<summary><section id="method.get_unchecked_mut-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#527">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str,
) -&gt; *mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked_mut">Read more</a>
</div>
<summary><section id="method.index-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#533">Source</a><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;&lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output ⓘ</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#541">Source</a><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str,
) -&gt; &amp;mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output ⓘ</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#553">Source</a><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeFrom&lt;usize&gt;</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#554">Source</a><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#556">Source</a><pre class="code-header" data-language="rust">fn get(
    self,
    slice: &amp;str,
) -&gt; Option&lt;&amp;&lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#566">Source</a><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str,
) -&gt; Option&lt;&amp;mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#576">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str,
) -&gt; *const &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked">Read more</a>
</div>
<summary><section id="method.get_unchecked_mut-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#582">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str,
) -&gt; *mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked_mut">Read more</a>
</div>
<summary><section id="method.index-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#588">Source</a><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;&lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#596">Source</a><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str,
) -&gt; &amp;mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeFull" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#95">Source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeFullImplements substring slicing with syntax &amp;self[..] or &amp;mut self[..].
</pre></section></summary><div class="docblock">
<p>Returns a slice of the whole string, i.e., returns <code>&amp;self</code> or <code>&amp;mut self</code>. Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>. Unlike other indexing operations, this can never panic.</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <p>Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#96">Source</a><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#98">Source</a><pre class="code-header" data-language="rust">fn get(self, slice: &amp;str) -&gt; Option&lt;&amp;&lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#102">Source</a><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str,
) -&gt; Option&lt;&amp;mut &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#106">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str,
) -&gt; *const &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked">Read more</a>
</div>
<summary><section id="method.get_unchecked_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#110">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str,
) -&gt; *mut &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked_mut">Read more</a>
</div>
<summary><section id="method.index-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#114">Source</a><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;&lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#118">Source</a><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str,
) -&gt; &amp;mut &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#624">Source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeInclusive&lt;usize&gt;Implements substring slicing with syntax &amp;self[begin ..= end] or &amp;mut self[begin ..= end].
</pre></section></summary><div class="docblock">
<p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>end</code>]. Equivalent to <code>&amp;self [begin .. end + 1]</code> or <code>&amp;mut self[begin .. end + 1]</code>, except if <code>end</code> has the maximum value for <code>usize</code>.</p> <p>This operation is <em>O</em>(1).</p> <h4 id="panics-7">Panics</h4> <p>Panics if <code>begin</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), if <code>end</code> does not point to the ending byte offset of a character (<code>end + 1</code> is either a starting byte offset or equal to <code>len</code>), if <code>begin &gt; end</code>, or if <code>end &gt;= len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-8" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#625">Source</a><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#627">Source</a><pre class="code-header" data-language="rust">fn get(
    self,
    slice: &amp;str,
) -&gt; Option&lt;&amp;&lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#631">Source</a><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str,
) -&gt; Option&lt;&amp;mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#635">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str,
) -&gt; *const &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked">Read more</a>
</div>
<summary><section id="method.get_unchecked_mut-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#640">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str,
) -&gt; *mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked_mut">Read more</a>
</div>
<summary><section id="method.index-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#645">Source</a><pre class="code-header" data-language="rust">fn index(
    self,
    slice: &amp;str,
) -&gt; &amp;&lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output ⓘ</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#652">Source</a><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str,
) -&gt; &amp;mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output ⓘ</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#661">Source</a><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeInclusive&lt;usize&gt;</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-9" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#662">Source</a><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#664">Source</a><pre class="code-header" data-language="rust">fn get(
    self,
    slice: &amp;str,
) -&gt; Option&lt;&amp;&lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#668">Source</a><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str,
) -&gt; Option&lt;&amp;mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#672">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str,
) -&gt; *const &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked">Read more</a>
</div>
<summary><section id="method.get_unchecked_mut-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#677">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str,
) -&gt; *mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked_mut">Read more</a>
</div>
<summary><section id="method.index-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#682">Source</a><pre class="code-header" data-language="rust">fn index(
    self,
    slice: &amp;str,
) -&gt; &amp;&lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#689">Source</a><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str,
) -&gt; &amp;mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeTo%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#430">Source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeTo&lt;usize&gt;Implements substring slicing with syntax &amp;self[.. end] or &amp;mut self[.. end].
</pre></section></summary><div class="docblock">
<p>Returns a slice of the given string from the byte range [0, <code>end</code>). Equivalent to <code>&amp;self[0 .. end]</code> or <code>&amp;mut self[0 .. end]</code>.</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <h4 id="panics-5">Panics</h4> <p>Panics if <code>end</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), or if <code>end &gt; len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#431">Source</a><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#433">Source</a><pre class="code-header" data-language="rust">fn get(
    self,
    slice: &amp;str,
) -&gt; Option&lt;&amp;&lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#443">Source</a><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str,
) -&gt; Option&lt;&amp;mut &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#453">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str,
) -&gt; *const &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked">Read more</a>
</div>
<summary><section id="method.get_unchecked_mut-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#458">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str,
) -&gt; *mut &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked_mut">Read more</a>
</div>
<summary><section id="method.index-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#463">Source</a><pre class="code-header" data-language="rust">fn index(self, slice: &amp;str) -&gt; &amp;&lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#471">Source</a><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str,
) -&gt; &amp;mut &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeToInclusive%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#712">Source</a></span><pre class="code-header" data-language="rust">impl SliceIndex&lt;str&gt; for RangeToInclusive&lt;usize&gt;Implements substring slicing with syntax &amp;self[..= end] or &amp;mut self[..= end].
</pre></section></summary><div class="docblock">
<p>Returns a slice of the given string from the byte range [0, <code>end</code>]. Equivalent to <code>&amp;self [0 .. end + 1]</code>, except if <code>end</code> has the maximum value for <code>usize</code>.</p> <p>This operation is <em>O</em>(1).</p> <h4 id="panics-8">Panics</h4> <p>Panics if <code>end</code> does not point to the ending byte offset of a character (<code>end + 1</code> is either a starting byte offset as defined by <code>is_char_boundary</code>, or equal to <code>len</code>), or if <code>end &gt;= len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-10" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#713">Source</a><pre class="code-header" data-language="rust">type Output = str</pre></section></summary><div class="docblock">The output type returned by methods.</div>
<summary><section id="method.get-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#715">Source</a><pre class="code-header" data-language="rust">fn get(
    self,
    slice: &amp;str,
) -&gt; Option&lt;&amp;&lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_mut-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#719">Source</a><pre class="code-header" data-language="rust">fn get_mut(
    self,
    slice: &amp;mut str,
) -&gt; Option&lt;&amp;mut &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, if in bounds.</div>
<summary><section id="method.get_unchecked-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#723">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked(
    self,
    slice: *const str,
) -&gt; *const &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked">Read more</a>
</div>
<summary><section id="method.get_unchecked_mut-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#728">Source</a><pre class="code-header" data-language="rust">unsafe fn get_unchecked_mut(
    self,
    slice: *mut str,
) -&gt; *mut &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable pointer to the output at this location, without performing any bounds checking. <a href="slice/trait.sliceindex.html#tymethod.get_unchecked_mut">Read more</a>
</div>
<summary><section id="method.index-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#733">Source</a><pre class="code-header" data-language="rust">fn index(
    self,
    slice: &amp;str,
) -&gt; &amp;&lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a shared reference to the output at this location, panicking if out of bounds.</div>
<summary><section id="method.index_mut-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#737">Source</a><pre class="code-header" data-language="rust">fn index_mut(
    self,
    slice: &amp;mut str,
) -&gt; &amp;mut &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span>
</div></span><div class="docblock">Returns a mutable reference to the output at this location, panicking if out of bounds.</div>
</div>
<summary><section id="impl-ToOwned-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/alloc/str.rs.html#206">Source</a></span><pre class="code-header" data-language="rust">impl ToOwned for str</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#207">Source</a><pre class="code-header" data-language="rust">type Owned = String</pre></section></summary><div class="docblock">The resulting type after obtaining ownership.</div>
<summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#210">Source</a><pre class="code-header" data-language="rust">fn to_owned(&amp;self) -&gt; String</pre></section></summary><div class="docblock">Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.toowned.html#tymethod.to_owned">Read more</a>
</div>
<summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/str.rs.html#215">Source</a><pre class="code-header" data-language="rust">fn clone_into(&amp;self, target: &amp;mut String)</pre></section></summary><div class="docblock">Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.toowned.html#method.clone_into">Read more</a>
</div>
</div>
<summary><section id="impl-ToSocketAddrs-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/net/socket_addr.rs.html#275-285">Source</a></span><pre class="code-header" data-language="rust">impl ToSocketAddrs for str</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Iter" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/net/socket_addr.rs.html#276">Source</a><pre class="code-header" data-language="rust">type Iter = IntoIter&lt;SocketAddr&gt;</pre></section></summary><div class="docblock">Returned iterator over socket addresses which this type may correspond to.</div>
<summary><section id="method.to_socket_addrs" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/net/socket_addr.rs.html#277-284">Source</a><pre class="code-header" data-language="rust">fn to_socket_addrs(&amp;self) -&gt; Result&lt;IntoIter&lt;SocketAddr&gt;&gt;</pre></section></summary><div class="docblock">Converts this object to an iterator of resolved <a href="net/enum.socketaddr.html" title="enum std::net::SocketAddr"><code>SocketAddr</code></a>s. <a href="net/trait.tosocketaddrs.html#tymethod.to_socket_addrs">Read more</a>
</div>
</div>
<summary><section id="impl-TryFrom%3C%26OsStr%3E-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.72.0">1.72.0</span><a class="src" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1389-1404">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; TryFrom&lt;&amp;'a OsStr&gt; for &amp;'a str</pre></section></summary><div class="impl-items">
<summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1401-1403">Source</a><pre class="code-header" data-language="rust">fn try_from(value: &amp;'a OsStr) -&gt; Result&lt;Self, Self::Error&gt;</pre></section></summary><div class="docblock">
<p>Tries to convert an <code>&amp;OsStr</code> to a <code>&amp;str</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::ffi::OsStr;

let os_str = OsStr::new("foo");
let as_str = &lt;&amp;str&gt;::try_from(os_str).unwrap();
assert_eq!(as_str, "foo");</pre></div> </div>
<summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1390">Source</a><pre class="code-header" data-language="rust">type Error = Utf8Error</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
</div>
<section id="impl-Eq-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#34">Source</a></span><pre class="code-header" data-language="rust">impl Eq for str</pre></section><section id="impl-Error-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.65.0">1.65.0</span><a class="src" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2871">Source</a></span><pre class="code-header" data-language="rust">impl !Error for &amp;str</pre></section><section id="impl-StructuralPartialEq-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/marker.rs.html#220-232">Source</a><pre class="code-header" data-language="rust">impl StructuralPartialEq for str</pre></section><section id="impl-UnsizedConstParamTy-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/marker.rs.html#1067-1080">Source</a><pre class="code-header" data-language="rust">impl UnsizedConstParamTy for str</pre></section>
</div>
<h3 id="synthetic-implementations" class="section-header">Auto Trait Implementations</h3>
<div id="synthetic-implementations-list">
<section id="impl-Freeze-for-str" class="impl"><pre class="code-header" data-language="rust">impl Freeze for str</pre></section><section id="impl-RefUnwindSafe-for-str" class="impl"><pre class="code-header" data-language="rust">impl RefUnwindSafe for str</pre></section><section id="impl-Send-for-str" class="impl"><pre class="code-header" data-language="rust">impl Send for str</pre></section><section id="impl-Sized-for-str" class="impl"><pre class="code-header" data-language="rust">impl !Sized for str</pre></section><section id="impl-Sync-for-str" class="impl"><pre class="code-header" data-language="rust">impl Sync for str</pre></section><section id="impl-Unpin-for-str" class="impl"><pre class="code-header" data-language="rust">impl Unpin for str</pre></section><section id="impl-UnwindSafe-for-str" class="impl"><pre class="code-header" data-language="rust">impl UnwindSafe for str</pre></section>
</div>
<h3 id="blanket-implementations" class="section-header">Blanket Implementations</h3>
<div id="blanket-implementations-list">
<summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#138">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Any for Twhere
    T: 'static + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#139">Source</a><pre class="code-header" data-language="rust">fn type_id(&amp;self) -&gt; TypeId</pre></section></summary><div class="docblock">Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.any.html#tymethod.type_id">Read more</a>
</div>
</div>
<summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#209">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Borrow&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#211">Source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="borrow/trait.borrow.html#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; BorrowMut&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#218">Source</a><pre class="code-header" data-language="rust">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</pre></section></summary><div class="docblock">Mutably borrows from an owned value. <a href="borrow/trait.borrowmut.html#tymethod.borrow_mut">Read more</a>
</div>
</div>
<summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2677">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; ToString for Twhere
    T: Display + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2679">Source</a><pre class="code-header" data-language="rust">fn to_string(&amp;self) -&gt; String</pre></section></summary><div class="docblock">Converts the given value to a <code>String</code>. <a href="string/trait.tostring.html#tymethod.to_string">Read more</a>
</div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/primitive.str.html" class="_attribution-link">https://doc.rust-lang.org/std/primitive.str.html</a>
  </p>
</div>
