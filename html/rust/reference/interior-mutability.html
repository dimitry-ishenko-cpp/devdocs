<h1 id="interior-mutability">Interior Mutability</h1> <p>Sometimes a type needs to be mutated while having multiple aliases. In Rust this is achieved using a pattern called <em>interior mutability</em>. A type has interior mutability if its internal state can be changed through a <a href="types/pointer.html#shared-references-">shared reference</a> to it. This goes against the usual <a href="behavior-considered-undefined.html">requirement</a> that the value pointed to by a shared reference is not mutated.</p> <p><a href="../std/cell/struct.unsafecell.html"><code>std::cell::UnsafeCell&lt;T&gt;</code></a> type is the only allowed way to disable this requirement. When <code>UnsafeCell&lt;T&gt;</code> is immutably aliased, it is still safe to mutate, or obtain a mutable reference to, the <code>T</code> it contains. As with all other types, it is undefined behavior to have multiple <code>&amp;mut UnsafeCell&lt;T&gt;</code> aliases.</p> <p>Other types with interior mutability can be created by using <code>UnsafeCell&lt;T&gt;</code> as a field. The standard library provides a variety of types that provide safe interior mutability APIs. For example, <a href="../std/cell/struct.refcell.html"><code>std::cell::RefCell&lt;T&gt;</code></a> uses run-time borrow checks to ensure the usual rules around multiple references. The <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a> module contains types that wrap a value that is only accessed with atomic operations, allowing the value to be shared and mutated across threads.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/interior-mutability.html" class="_attribution-link">https://doc.rust-lang.org/reference/interior-mutability.html</a>
  </p>
</div>
