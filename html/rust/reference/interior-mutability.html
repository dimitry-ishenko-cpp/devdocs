<h1 id="interior-mutability">Interior Mutability</h1> <div class="rule" id="r-interior-mut"><a class="rule-link" href="#r-interior-mut">[interior-mut]</a></div> <div class="rule" id="r-interior-mut.intro"><a class="rule-link" href="#r-interior-mut.intro">[interior-mut.intro]</a></div> <p>Sometimes a type needs to be mutated while having multiple aliases. In Rust this is achieved using a pattern called <em>interior mutability</em>.</p> <div class="rule" id="r-interior-mut.shared-ref"><a class="rule-link" href="#r-interior-mut.shared-ref">[interior-mut.shared-ref]</a></div> <p>A type has interior mutability if its internal state can be changed through a <a href="types/pointer.html#shared-references-">shared reference</a> to it.</p> <div class="rule" id="r-interior-mut.no-constraint"><a class="rule-link" href="#r-interior-mut.no-constraint">[interior-mut.no-constraint]</a></div> <p>This goes against the usual <a href="behavior-considered-undefined.html">requirement</a> that the value pointed to by a shared reference is not mutated.</p> <div class="rule" id="r-interior-mut.unsafe-cell"><a class="rule-link" href="#r-interior-mut.unsafe-cell">[interior-mut.unsafe-cell]</a></div> <p><a href="https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html"><code>std::cell::UnsafeCell&lt;T&gt;</code></a> type is the only allowed way to disable this requirement. When <code>UnsafeCell&lt;T&gt;</code> is immutably aliased, it is still safe to mutate, or obtain a mutable reference to, the <code>T</code> it contains.</p> <div class="rule" id="r-interior-mut.mut-unsafe-cell"><a class="rule-link" href="#r-interior-mut.mut-unsafe-cell">[interior-mut.mut-unsafe-cell]</a></div> <p>As with all other types, it is undefined behavior to have multiple <code>&amp;mut UnsafeCell&lt;T&gt;</code> aliases.</p> <div class="rule" id="r-interior-mut.abstraction"><a class="rule-link" href="#r-interior-mut.abstraction">[interior-mut.abstraction]</a></div> <p>Other types with interior mutability can be created by using <code>UnsafeCell&lt;T&gt;</code> as a field. The standard library provides a variety of types that provide safe interior mutability APIs.</p> <div class="rule" id="r-interior-mut.ref-cell"><a class="rule-link" href="#r-interior-mut.ref-cell">[interior-mut.ref-cell]</a></div> <p>For example, <a href="https://doc.rust-lang.org/core/cell/struct.RefCell.html"><code>std::cell::RefCell&lt;T&gt;</code></a> uses run-time borrow checks to ensure the usual rules around multiple references.</p> <div class="rule" id="r-interior-mut.atomic"><a class="rule-link" href="#r-interior-mut.atomic">[interior-mut.atomic]</a></div> <p>The <a href="https://doc.rust-lang.org/core/sync/atomic/index.html"><code>std::sync::atomic</code></a> module contains types that wrap a value that is only accessed with atomic operations, allowing the value to be shared and mutated across threads.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/interior-mutability.html" class="_attribution-link">https://doc.rust-lang.org/reference/interior-mutability.html</a>
  </p>
</div>
