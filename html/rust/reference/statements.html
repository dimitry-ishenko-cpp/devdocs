<h1 id="statements">Statements</h1> <div class="rule" id="r-statement"><a class="rule-link" href="#r-statement">[statement]</a></div> <div class="rule" id="r-statement.syntax"><a class="rule-link" href="#r-statement.syntax">[statement.syntax]</a></div> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>Statement</em> :<br> <code>;</code><br> | <a href="items.html"><em>Item</em></a><br> | <a href="#let-statements"><em>LetStatement</em></a><br> | <a href="#expression-statements"><em>ExpressionStatement</em></a><br> | <a href="macros.html#macro-invocation"><em>MacroInvocationSemi</em></a></p> </blockquote> <div class="rule" id="r-statement.intro"><a class="rule-link" href="#r-statement.intro">[statement.intro]</a></div> <p>A <em>statement</em> is a component of a <a href="expressions/block-expr.html">block</a>, which is in turn a component of an outer <a href="expressions.html">expression</a> or <a href="items/functions.html">function</a>.</p> <div class="rule" id="r-statement.kind"><a class="rule-link" href="#r-statement.kind">[statement.kind]</a></div> <p>Rust has two kinds of statement: <a href="#declaration-statements">declaration statements</a> and <a href="#expression-statements">expression statements</a>.</p> <h2 id="declaration-statements">Declaration statements</h2> <div class="rule" id="r-statement.decl"><a class="rule-link" href="#r-statement.decl">[statement.decl]</a></div> <p>A <em>declaration statement</em> is one that introduces one or more <em>names</em> into the enclosing statement block. The declared names may denote new variables or new <a href="items.html">items</a>.</p> <p>The two kinds of declaration statements are item declarations and <code>let</code> statements.</p> <h3 id="item-declarations">Item declarations</h3> <div class="rule" id="r-statement.item"><a class="rule-link" href="#r-statement.item">[statement.item]</a></div> <div class="rule" id="r-statement.item.intro"><a class="rule-link" href="#r-statement.item.intro">[statement.item.intro]</a></div> <p>An <em>item declaration statement</em> has a syntactic form identical to an <a href="items.html">item declaration</a> within a <a href="items/modules.html">module</a>.</p> <div class="rule" id="r-statement.item.scope"><a class="rule-link" href="#r-statement.item.scope">[statement.item.scope]</a></div> <p>Declaring an item within a statement block restricts its <a href="names/scopes.html">scope</a> to the block containing the statement. The item is not given a <a href="paths.html#canonical-paths">canonical path</a> nor are any sub-items it may declare.</p> <div class="rule" id="r-statement.item.associated-scope"><a class="rule-link" href="#r-statement.item.associated-scope">[statement.item.associated-scope]</a></div> <p>The exception to this is that associated items defined by <a href="items/implementations.html">implementations</a> are still accessible in outer scopes as long as the item and, if applicable, trait are accessible. It is otherwise identical in meaning to declaring the item inside a module.</p> <div class="rule" id="r-statement.item.outer-generics"><a class="rule-link" href="#r-statement.item.outer-generics">[statement.item.outer-generics]</a></div> <p>There is no implicit capture of the containing function’s generic parameters, parameters, and local variables. For example, <code>inner</code> may not access <code>outer_var</code>.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn outer() {
  let outer_var = true;

  fn inner() { /* outer_var is not in scope here */ }

  inner();
}
}</pre> <h3 id="let-statements">
<code id="">let</code> statements</h3> <div class="rule" id="r-statement.let"><a class="rule-link" href="#r-statement.let">[statement.let]</a></div> <div class="rule" id="r-statement.let.syntax"><a class="rule-link" href="#r-statement.let.syntax">[statement.let.syntax]</a></div> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>LetStatement</em> :<br> <a href="attributes.html"><em>OuterAttribute</em></a><sup>*</sup> <code>let</code> <a href="patterns.html"><em>PatternNoTopAlt</em></a> ( <code>:</code> <a href="types.html"><em>Type</em></a> )<sup>?</sup> (<code>=</code> <a href="expressions.html"><em>Expression</em></a> <a href="#let-else-restriction">†</a> ( <code>else</code> <a href="expressions/block-expr.html"><em>BlockExpression</em></a>) <sup>?</sup> ) <sup>?</sup> <code>;</code></p> <p><span id="let-else-restriction">† When an <code>else</code> block is specified, the <em>Expression</em> must not be a <a href="expressions/operator-expr.html#lazy-boolean-operators"><em>LazyBooleanExpression</em></a>, or end with a <code>}</code>.</span></p> </blockquote> <div class="rule" id="r-statement.let.intro"><a class="rule-link" href="#r-statement.let.intro">[statement.let.intro]</a></div> <p>A <em><code>let</code> statement</em> introduces a new set of <a href="variables.html">variables</a>, given by a <a href="patterns.html">pattern</a>. The pattern is followed optionally by a type annotation and then either ends, or is followed by an initializer expression plus an optional <code>else</code> block.</p> <div class="rule" id="r-statement.let.inference"><a class="rule-link" href="#r-statement.let.inference">[statement.let.inference]</a></div> <p>When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference.</p> <div class="rule" id="r-statement.let.scope"><a class="rule-link" href="#r-statement.let.scope">[statement.let.scope]</a></div> <p>Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope, except when they are shadowed by another variable declaration.</p> <div class="rule" id="r-statement.let.constraint"><a class="rule-link" href="#r-statement.let.constraint">[statement.let.constraint]</a></div> <p>If an <code>else</code> block is not present, the pattern must be irrefutable. If an <code>else</code> block is present, the pattern may be refutable.</p> <div class="rule" id="r-statement.let.behavior"><a class="rule-link" href="#r-statement.let.behavior">[statement.let.behavior]</a></div> <p>If the pattern does not match (this requires it to be refutable), the <code>else</code> block is executed. The <code>else</code> block must always diverge (evaluate to the <a href="types/never.html">never type</a>).</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let (mut v, w) = (vec![1, 2, 3], 42); // The bindings may be mut or const
let Some(t) = v.pop() else { // Refutable patterns require an else block
    panic!(); // The else block must diverge
};
let [u, v] = [v[0], v[1]] else { // This pattern is irrefutable, so the compiler
                                 // will lint as the else block is redundant.
    panic!();
};
}</pre> <h2 id="expression-statements">Expression statements</h2> <div class="rule" id="r-statement.expr"><a class="rule-link" href="#r-statement.expr">[statement.expr]</a></div> <div class="rule" id="r-statement.expr.syntax"><a class="rule-link" href="#r-statement.expr.syntax">[statement.expr.syntax]</a></div> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>ExpressionStatement</em> :<br> <a href="expressions.html"><em>ExpressionWithoutBlock</em></a> <code>;</code><br> | <a href="expressions.html"><em>ExpressionWithBlock</em></a> <code>;</code><sup>?</sup></p> </blockquote> <div class="rule" id="r-statement.expr.intro"><a class="rule-link" href="#r-statement.expr.intro">[statement.expr.intro]</a></div> <p>An <em>expression statement</em> is one that evaluates an <a href="expressions.html">expression</a> and ignores its result. As a rule, an expression statement’s purpose is to trigger the effects of evaluating its expression.</p> <div class="rule" id="r-statement.expr.restriction-semicolon"><a class="rule-link" href="#r-statement.expr.restriction-semicolon">[statement.expr.restriction-semicolon]</a></div> <p>An expression that consists of only a <a href="expressions/block-expr.html">block expression</a> or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon. This can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression; in this case, it is parsed as a statement.</p> <div class="rule" id="r-statement.expr.constraint-block"><a class="rule-link" href="#r-statement.expr.constraint-block">[statement.expr.constraint-block]</a></div> <p>The type of <a href="expressions.html"><em>ExpressionWithBlock</em></a> expressions when used as statements must be the unit type.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let mut v = vec![1, 2, 3];
v.pop();          // Ignore the element returned from pop
if v.is_empty() {
    v.push(5);
} else {
    v.remove(0);
}                 // Semicolon can be omitted.
[1];              // Separate expression statement, not an indexing expression.
}</pre> <p>When the trailing semicolon is omitted, the result must be type <code>()</code>.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// bad: the block's type is i32, not ()
// Error: expected `()` because of default return type
// if true {
//   1
// }

// good: the block's type is i32
if true {
  1
} else {
  2
};
}</pre> <h2 id="attributes-on-statements">Attributes on Statements</h2> <div class="rule" id="r-statement.attribute"><a class="rule-link" href="#r-statement.attribute">[statement.attribute]</a></div> <p>Statements accept <a href="attributes.html">outer attributes</a>. The attributes that have meaning on a statement are <a href="conditional-compilation.html"><code>cfg</code></a>, and <a href="attributes/diagnostics.html#lint-check-attributes">the lint check attributes</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/statements.html" class="_attribution-link">https://doc.rust-lang.org/reference/statements.html</a>
  </p>
</div>
