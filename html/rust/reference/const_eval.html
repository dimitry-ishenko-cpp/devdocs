<h1 id="constant-evaluation">Constant evaluation</h1> <div class="rule" id="r-const-eval"><a class="rule-link" href="#r-const-eval">[const-eval]</a></div> <div class="rule" id="r-const-eval.general"><a class="rule-link" href="#r-const-eval.general">[const-eval.general]</a></div> <p>Constant evaluation is the process of computing the result of <a href="expressions.html">expressions</a> during compilation. Only a subset of all expressions can be evaluated at compile-time.</p> <h2 id="constant-expressions">Constant expressions</h2> <div class="rule" id="r-const-eval.const-expr"><a class="rule-link" href="#r-const-eval.const-expr">[const-eval.const-expr]</a></div> <div class="rule" id="r-const-eval.const-expr.general"><a class="rule-link" href="#r-const-eval.const-expr.general">[const-eval.const-expr.general]</a></div> <p>Certain forms of expressions, called constant expressions, can be evaluated at compile time.</p> <div class="rule" id="r-const-eval.const-expr.const-context"><a class="rule-link" href="#r-const-eval.const-expr.const-context">[const-eval.const-expr.const-context]</a></div> <p>In <a href="#const-context">const contexts</a>, these are the only allowed expressions, and are always evaluated at compile time.</p> <div class="rule" id="r-const-eval.const-expr.runtime-context"><a class="rule-link" href="#r-const-eval.const-expr.runtime-context">[const-eval.const-expr.runtime-context]</a></div> <p>In other places, such as <a href="statements.html#let-statements">let statements</a>, constant expressions <em>may</em> be, but are not guaranteed to be, evaluated at compile time.</p> <div class="rule" id="r-const-eval.const-expr.error"><a class="rule-link" href="#r-const-eval.const-expr.error">[const-eval.const-expr.error]</a></div> <p>Behaviors such as out of bounds <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> or <a href="expressions/operator-expr.html#overflow">overflow</a> are compiler errors if the value must be evaluated at compile time (i.e. in const contexts). Otherwise, these behaviors are warnings, but will likely panic at run-time.</p> <div class="rule" id="r-const-eval.const-expr.list"><a class="rule-link" href="#r-const-eval.const-expr.list">[const-eval.const-expr.list]</a></div> <p>The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any <a href="destructors.html"><code>Drop::drop</code></a> calls to be run.</p> <div class="rule" id="r-const-eval.const-expr.literal"><a class="rule-link" href="#r-const-eval.const-expr.literal">[const-eval.const-expr.literal]</a></div> <ul> <li>
<a href="expressions/literal-expr.html">Literals</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.parameter"><a class="rule-link" href="#r-const-eval.const-expr.parameter">[const-eval.const-expr.parameter]</a></div> <ul> <li>
<a href="items/generics.html">Const parameters</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.path-item"><a class="rule-link" href="#r-const-eval.const-expr.path-item">[const-eval.const-expr.path-item]</a></div> <ul> <li>
<a href="expressions/path-expr.html">Paths</a> to <a href="items/functions.html">functions</a> and <a href="items/constant-items.html">constants</a>. Recursively defining constants is not allowed.</li> </ul> <div class="rule" id="r-const-eval.const-expr.path-static"><a class="rule-link" href="#r-const-eval.const-expr.path-static">[const-eval.const-expr.path-static]</a></div> <ul> <li>Paths to <a href="items/static-items.html">statics</a> with these restrictions: <ul> <li>Writes to <code>static</code> items are not allowed in any constant evaluation context.</li> <li>Reads from <code>extern</code> statics are not allowed in any constant evaluation context.</li> <li>If the evaluation is <em>not</em> carried out in an initializer of a <code>static</code> item, then reads from any mutable <code>static</code> are not allowed. A mutable <code>static</code> is a <code>static mut</code> item, or a <code>static</code> item with an interior-mutable type.</li> </ul> </li> </ul> <p>These requirements are checked only when the constant is evaluated. In other words, having such accesses syntactically occur in const contexts is allowed as long as they never get executed.</p> <div class="rule" id="r-const-eval.const-expr.tuple"><a class="rule-link" href="#r-const-eval.const-expr.tuple">[const-eval.const-expr.tuple]</a></div> <ul> <li>
<a href="expressions/tuple-expr.html">Tuple expressions</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.array"><a class="rule-link" href="#r-const-eval.const-expr.array">[const-eval.const-expr.array]</a></div> <ul> <li>
<a href="expressions/array-expr.html">Array expressions</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.constructor"><a class="rule-link" href="#r-const-eval.const-expr.constructor">[const-eval.const-expr.constructor]</a></div> <ul> <li>
<a href="expressions/struct-expr.html">Struct</a> expressions.</li> </ul> <div class="rule" id="r-const-eval.const-expr.block"><a class="rule-link" href="#r-const-eval.const-expr.block">[const-eval.const-expr.block]</a></div> <ul> <li>
<a href="expressions/block-expr.html">Block expressions</a>, including <code>unsafe</code> and <code>const</code> blocks. <ul> <li>
<a href="statements.html#let-statements">let statements</a> and thus irrefutable <a href="patterns.html">patterns</a>, including mutable bindings</li> <li><a href="expressions/operator-expr.html#assignment-expressions">assignment expressions</a></li> <li><a href="expressions/operator-expr.html#compound-assignment-expressions">compound assignment expressions</a></li> <li><a href="statements.html#expression-statements">expression statements</a></li> </ul> </li> </ul> <div class="rule" id="r-const-eval.const-expr.field"><a class="rule-link" href="#r-const-eval.const-expr.field">[const-eval.const-expr.field]</a></div> <ul> <li>
<a href="expressions/field-expr.html">Field</a> expressions.</li> </ul> <div class="rule" id="r-const-eval.const-expr.index"><a class="rule-link" href="#r-const-eval.const-expr.index">[const-eval.const-expr.index]</a></div> <ul> <li>Index expressions, <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> or <a href="types/slice.html">slice</a> with a <code>usize</code>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.range"><a class="rule-link" href="#r-const-eval.const-expr.range">[const-eval.const-expr.range]</a></div> <ul> <li>
<a href="expressions/range-expr.html">Range expressions</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.closure"><a class="rule-link" href="#r-const-eval.const-expr.closure">[const-eval.const-expr.closure]</a></div> <ul> <li>
<a href="expressions/closure-expr.html">Closure expressions</a> which donâ€™t capture variables from the environment.</li> </ul> <div class="rule" id="r-const-eval.const-expr.builtin-arith-logic"><a class="rule-link" href="#r-const-eval.const-expr.builtin-arith-logic">[const-eval.const-expr.builtin-arith-logic]</a></div> <ul> <li>Built-in <a href="expressions/operator-expr.html#negation-operators">negation</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">arithmetic</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">logical</a>, <a href="expressions/operator-expr.html#comparison-operators">comparison</a> or <a href="expressions/operator-expr.html#lazy-boolean-operators">lazy boolean</a> operators used on integer and floating point types, <code>bool</code>, and <code>char</code>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.borrows"><a class="rule-link" href="#r-const-eval.const-expr.borrows">[const-eval.const-expr.borrows]</a></div> <ul> <li>All forms of <a href="expressions/operator-expr.html#borrow-operators">borrow</a>s, including raw borrows, with one limitation: mutable borrows and shared borrows to values with interior mutability are only allowed to refer to <em>transient</em> places. A place is <em>transient</em> if its lifetime is strictly contained inside the current <a href="#const-context">const context</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.deref"><a class="rule-link" href="#r-const-eval.const-expr.deref">[const-eval.const-expr.deref]</a></div> <ul> <li>The <a href="expressions/operator-expr.html#the-dereference-operator">dereference operator</a> except for raw pointers.</li> </ul> <div class="rule" id="r-const-eval.const-expr.group"><a class="rule-link" href="#r-const-eval.const-expr.group">[const-eval.const-expr.group]</a></div> <ul> <li>
<a href="expressions/grouped-expr.html">Grouped</a> expressions.</li> </ul> <div class="rule" id="r-const-eval.const-expr.cast"><a class="rule-link" href="#r-const-eval.const-expr.cast">[const-eval.const-expr.cast]</a></div> <ul> <li>
<a href="expressions/operator-expr.html#type-cast-expressions">Cast</a> expressions, except <ul> <li>pointer to address casts and</li> <li>function pointer to address casts.</li> </ul> </li> </ul> <div class="rule" id="r-const-eval.const-expr.const-fn"><a class="rule-link" href="#r-const-eval.const-expr.const-fn">[const-eval.const-expr.const-fn]</a></div> <ul> <li>Calls of <a href="items/functions.html#const-functions">const functions</a> and const methods.</li> </ul> <div class="rule" id="r-const-eval.const-expr.loop"><a class="rule-link" href="#r-const-eval.const-expr.loop">[const-eval.const-expr.loop]</a></div> <ul> <li>
<a href="expressions/loop-expr.html#infinite-loops">loop</a>, <a href="expressions/loop-expr.html#predicate-loops">while</a> and <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> expressions.</li> </ul> <div class="rule" id="r-const-eval.const-expr.if-match"><a class="rule-link" href="#r-const-eval.const-expr.if-match">[const-eval.const-expr.if-match]</a></div> <ul> <li>
<a href="expressions/if-expr.html#if-expressions">if</a>, <a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a> and <a href="expressions/match-expr.html">match</a> expressions.</li> </ul> <h2 id="const-context">Const context</h2> <div class="rule" id="r-const-eval.const-context"><a class="rule-link" href="#r-const-eval.const-context">[const-eval.const-context]</a></div> <div class="rule" id="r-const-eval.const-context.general"><a class="rule-link" href="#r-const-eval.const-context.general">[const-eval.const-context.general]</a></div> <p>A <em>const context</em> is one of the following:</p> <div class="rule" id="r-const-eval.const-context.array-length"><a class="rule-link" href="#r-const-eval.const-context.array-length">[const-eval.const-context.array-length]</a></div> <ul> <li><a href="types/array.html">Array type length expressions</a></li> </ul> <div class="rule" id="r-const-eval.const-context.repeat-length"><a class="rule-link" href="#r-const-eval.const-context.repeat-length">[const-eval.const-context.repeat-length]</a></div> <ul> <li><a href="expressions/array-expr.html">Array repeat length expressions</a></li> </ul> <div class="rule" id="r-const-eval.const-context.init"><a class="rule-link" href="#r-const-eval.const-context.init">[const-eval.const-context.init]</a></div> <ul> <li>The initializer of <ul> <li><a href="items/constant-items.html">constants</a></li> <li><a href="items/static-items.html">statics</a></li> <li><a href="items/enumerations.html#discriminants">enum discriminants</a></li> </ul> </li> </ul> <div class="rule" id="r-const-eval.const-context.generic"><a class="rule-link" href="#r-const-eval.const-context.generic">[const-eval.const-context.generic]</a></div> <ul> <li>A <a href="items/generics.html#const-generics">const generic argument</a>
</li> </ul> <div class="rule" id="r-const-eval.const-context.block"><a class="rule-link" href="#r-const-eval.const-context.block">[const-eval.const-context.block]</a></div> <ul> <li>A <a href="expressions/block-expr.html#const-blocks">const block</a>
</li> </ul> <p>Const contexts that are used as parts of types (array type and repeat length expressions as well as const generic arguments) can only make restricted use of surrounding generic parameters: such an expression must either be a single bare const generic parameter, or an arbitrary expression not making use of any generics.</p> <h2 id="const-functions">Const Functions</h2> <div class="rule" id="r-const-eval.const-fn"><a class="rule-link" href="#r-const-eval.const-fn">[const-eval.const-fn]</a></div> <div class="rule" id="r-const-eval.const-fn.general"><a class="rule-link" href="#r-const-eval.const-fn.general">[const-eval.const-fn.general]</a></div> <p>A <em>const fn</em> is a function that one is permitted to call from a const context.</p> <div class="rule" id="r-const-eval.const-fn.usage"><a class="rule-link" href="#r-const-eval.const-fn.usage">[const-eval.const-fn.usage]</a></div> <p>Declaring a function <code>const</code> has no effect on any existing uses, it only restricts the types that arguments and the return type may use, and restricts the function body to constant expressions.</p> <div class="rule" id="r-const-eval.const-fn.const-context"><a class="rule-link" href="#r-const-eval.const-fn.const-context">[const-eval.const-fn.const-context]</a></div> <p>When called from a const context, the function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So <code>usize</code> is <code>32</code> bits if you are compiling against a <code>32</code> bit system, irrelevant of whether you are building on a <code>64</code> bit or a <code>32</code> bit system.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/const_eval.html" class="_attribution-link">https://doc.rust-lang.org/reference/const_eval.html</a>
  </p>
</div>
