<h1 id="range-expressions">Range expressions</h1> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>RangeExpression</em> :<br> <em>RangeExpr</em><br> | <em>RangeFromExpr</em><br> | <em>RangeToExpr</em><br> | <em>RangeFullExpr</em><br> | <em>RangeInclusiveExpr</em><br> | <em>RangeToInclusiveExpr</em></p> <p><em>RangeExpr</em> :<br> <a href="../expressions.html"><em>Expression</em></a> <code>..</code> <a href="../expressions.html"><em>Expression</em></a></p> <p><em>RangeFromExpr</em> :<br> <a href="../expressions.html"><em>Expression</em></a> <code>..</code></p> <p><em>RangeToExpr</em> :<br> <code>..</code> <a href="../expressions.html"><em>Expression</em></a></p> <p><em>RangeFullExpr</em> :<br> <code>..</code></p> <p><em>RangeInclusiveExpr</em> :<br> <a href="../expressions.html"><em>Expression</em></a> <code>..=</code> <a href="../expressions.html"><em>Expression</em></a></p> <p><em>RangeToInclusiveExpr</em> :<br> <code>..=</code> <a href="../expressions.html"><em>Expression</em></a></p> </blockquote> <p>The <code>..</code> and <code>..=</code> operators will construct an object of one of the <code>std::ops::Range</code> (or <code>core::ops::Range</code>) variants, according to the following table:</p> <div class="table-wrapper">
<table>
<thead><tr>
<th>Production</th>
<th>Syntax</th>
<th>Type</th>
<th>Range</th>
</tr></thead>
<tbody> <tr>
<td><em>RangeExpr</em></td>
<td>start<code>..</code>end</td>
<td><a href="../../std/ops/struct.range.html">std::ops::Range</a></td>
<td>start ≤ x &lt; end</td>
</tr> <tr>
<td><em>RangeFromExpr</em></td>
<td>start<code>..</code>
</td>
<td><a href="../../std/ops/struct.rangefrom.html">std::ops::RangeFrom</a></td>
<td>start ≤ x</td>
</tr> <tr>
<td><em>RangeToExpr</em></td>
<td>
<code>..</code>end</td>
<td><a href="../../std/ops/struct.rangeto.html">std::ops::RangeTo</a></td>
<td>x &lt; end</td>
</tr> <tr>
<td><em>RangeFullExpr</em></td>
<td><code>..</code></td>
<td><a href="../../std/ops/struct.rangefull.html">std::ops::RangeFull</a></td>
<td>-</td>
</tr> <tr>
<td><em>RangeInclusiveExpr</em></td>
<td>start<code>..=</code>end</td>
<td><a href="../../std/ops/struct.rangeinclusive.html">std::ops::RangeInclusive</a></td>
<td>start ≤ x ≤ end</td>
</tr> <tr>
<td><em>RangeToInclusiveExpr</em></td>
<td>
<code>..=</code>end</td>
<td><a href="../../std/ops/struct.rangetoinclusive.html">std::ops::RangeToInclusive</a></td>
<td>x ≤ end</td>
</tr> </tbody>
</table> </div> <p>Examples:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
1..2;   // std::ops::Range
3..;    // std::ops::RangeFrom
..4;    // std::ops::RangeTo
..;     // std::ops::RangeFull
5..=6;  // std::ops::RangeInclusive
..=7;   // std::ops::RangeToInclusive
}</pre> <p>The following expressions are equivalent.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x = std::ops::Range {start: 0, end: 10};
let y = 0..10;

assert_eq!(x, y);
}</pre> <p>Ranges can be used in <code>for</code> loops:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
for i in 1..11 {
    println!("{}", i);
}
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/expressions/range-expr.html" class="_attribution-link">https://doc.rust-lang.org/reference/expressions/range-expr.html</a>
  </p>
</div>
