<h1 id="crates-and-source-files">Crates and source files</h1> <div class="rule" id="r-crate"><a class="rule-link" href="#r-crate">[crate]</a></div> <div class="rule" id="r-crate.syntax"><a class="rule-link" href="#r-crate.syntax">[crate.syntax]</a></div> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>Crate</em> :<br> <a href="attributes.html"><em>InnerAttribute</em></a><sup>*</sup><br> <a href="items.html"><em>Item</em></a><sup>*</sup></p> </blockquote> <blockquote> <p>Note: Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</p> </blockquote> <div class="rule" id="r-crate.compile-time"><a class="rule-link" href="#r-crate.compile-time">[crate.compile-time]</a></div> <p>Rust’s semantics obey a <em>phase distinction</em> between compile-time and run-time.<sup class="footnote-reference"><a href="#phase-distinction">1</a></sup> Semantic rules that have a <em>static interpretation</em> govern the success or failure of compilation, while semantic rules that have a <em>dynamic interpretation</em> govern the behavior of the program at run-time.</p> <div class="rule" id="r-crate.unit"><a class="rule-link" href="#r-crate.unit">[crate.unit]</a></div> <p>The compilation model centers on artifacts called <em>crates</em>. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.<sup class="footnote-reference"><a href="#cratesourcefile">2</a></sup></p> <div class="rule" id="r-crate.module"><a class="rule-link" href="#r-crate.module">[crate.module]</a></div> <p>A <em>crate</em> is a unit of compilation and linking, as well as versioning, distribution, and runtime loading. A crate contains a <em>tree</em> of nested <a href="items/modules.html">module</a> scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical <a href="paths.html">module path</a> denoting its location within the crate’s module tree.</p> <div class="rule" id="r-crate.input-source"><a class="rule-link" href="#r-crate.input-source">[crate.input-source]</a></div> <p>The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension <code>.rs</code>.</p> <div class="rule" id="r-crate.module-def"><a class="rule-link" href="#r-crate.module-def">[crate.module-def]</a></div> <p>A Rust source file describes a module, the name and location of which — in the module tree of the current crate — are defined from outside the source file: either by an explicit <a href="items/modules.html"><em>Module</em></a> item in a referencing source file, or by the name of the crate itself.</p> <div class="rule" id="r-crate.inline-module"><a class="rule-link" href="#r-crate.inline-module">[crate.inline-module]</a></div> <p>Every source file is a module, but not every module needs its own source file: <a href="items/modules.html">module definitions</a> can be nested within one file.</p> <div class="rule" id="r-crate.items"><a class="rule-link" href="#r-crate.items">[crate.items]</a></div> <p>Each source file contains a sequence of zero or more <a href="items.html"><em>Item</em></a> definitions, and may optionally begin with any number of <a href="attributes.html">attributes</a> that apply to the containing module, most of which influence the behavior of the compiler.</p> <div class="rule" id="r-crate.attributes"><a class="rule-link" href="#r-crate.attributes">[crate.attributes]</a></div> <p>The anonymous crate module can have additional attributes that apply to the crate as a whole.</p> <blockquote> <p><strong>Note</strong>: The file’s contents may be preceded by a <a href="input-format.html#shebang-removal">shebang</a>.</p> </blockquote> <pre data-language="rust">#![allow(unused)]
fn main() {
// Specify the crate name.
#![crate_name = "projx"]

// Specify the type of output artifact.
#![crate_type = "lib"]

// Turn on a warning.
// This can be done in any module, not just the anonymous crate module.
#![warn(non_camel_case_types)]
}</pre> <h2 id="main-functions">Main Functions</h2> <div class="rule" id="r-crate.main"><a class="rule-link" href="#r-crate.main">[crate.main]</a></div> <div class="rule" id="r-crate.main.general"><a class="rule-link" href="#r-crate.main.general">[crate.main.general]</a></div> <p>A crate that contains a <code>main</code> <a href="items/functions.html">function</a> can be compiled to an executable.</p> <div class="rule" id="r-crate.main.restriction"><a class="rule-link" href="#r-crate.main.restriction">[crate.main.restriction]</a></div> <p>If a <code>main</code> function is present, it must take no arguments, must not declare any <a href="trait-bounds.html">trait or lifetime bounds</a>, must not have any <a href="items/generics.html#where-clauses">where clauses</a>, and its return type must implement the <a href="../std/process/trait.termination.html"><code>Termination</code></a> trait.</p> <pre data-language="rust">fn main() {}</pre> <pre data-language="rust">fn main() -&gt; ! {
    std::process::exit(0);
}</pre> <pre data-language="rust">fn main() -&gt; impl std::process::Termination {
    std::process::ExitCode::SUCCESS
}</pre> <div class="rule" id="r-crate.main.import"><a class="rule-link" href="#r-crate.main.import">[crate.main.import]</a></div> <p>The <code>main</code> function may be an import, e.g. from an external crate or from the current one.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
mod foo {
    pub fn bar() {
        println!("Hello, world!");
    }
}
use foo::bar as main;
}</pre> <blockquote> <p><strong>Note</strong>: Types with implementations of <a href="../std/process/trait.termination.html"><code>Termination</code></a> in the standard library include:</p> <ul> <li><code>()</code></li> <li><a href="types/never.html"><code>!</code></a></li> <li><a href="https://doc.rust-lang.org/core/convert/enum.Infallible.html"><code>Infallible</code></a></li> <li><a href="../std/process/struct.exitcode.html"><code>ExitCode</code></a></li> <li><code>Result&lt;T, E&gt; where T: Termination, E: Debug</code></li> </ul> </blockquote>  <h3 id="the-no_main-attribute">The <code id="">no_main</code> attribute</h3> <div class="rule" id="r-crate.no_main"><a class="rule-link" href="#r-crate.no_main">[crate.no_main]</a></div> <p>The <em><code>no_main</code> <a href="attributes.html">attribute</a></em> may be applied at the crate level to disable emitting the <code>main</code> symbol for an executable binary. This is useful when some other object being linked to defines <code>main</code>.</p> <h2 id="the-crate_name-attribute">The <code id="">crate_name</code> attribute</h2> <div class="rule" id="r-crate.crate_name"><a class="rule-link" href="#r-crate.crate_name">[crate.crate_name]</a></div> <div class="rule" id="r-crate.crate_name.general"><a class="rule-link" href="#r-crate.crate_name.general">[crate.crate_name.general]</a></div> <p>The <em><code>crate_name</code> <a href="attributes.html">attribute</a></em> may be applied at the crate level to specify the name of the crate with the <a href="attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> syntax.</p> <pre data-language="rust">#![allow(unused)]
#![crate_name = "mycrate"]
fn main() {
}</pre> <div class="rule" id="r-crate.crate_name.restriction"><a class="rule-link" href="#r-crate.crate_name.restriction">[crate.crate_name.restriction]</a></div> <p>The crate name must not be empty, and must only contain <a href="../std/primitive.char.html#method.is_alphanumeric">Unicode alphanumeric</a> or <code>_</code> (U+005F) characters.</p> <div class="footnote-definition" id="phase-distinction">
<sup class="footnote-definition-label">1</sup> <p>This distinction would also exist in an interpreter. Static checks like syntactic analysis, type checking, and lints should happen before the program is executed regardless of when it is executed.</p> </div> <div class="footnote-definition" id="cratesourcefile">
<sup class="footnote-definition-label">2</sup> <p>A crate is somewhat analogous to an <em>assembly</em> in the ECMA-335 CLI model, a <em>library</em> in the SML/NJ Compilation Manager, a <em>unit</em> in the Owens and Flatt module system, or a <em>configuration</em> in Mesa.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/crates-and-source-files.html" class="_attribution-link">https://doc.rust-lang.org/reference/crates-and-source-files.html</a>
  </p>
</div>
