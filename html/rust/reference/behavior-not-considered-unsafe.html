<h1 id="behavior-not-considered-unsafe">Behavior not considered <code id="">unsafe</code>
</h1> <p>The Rust compiler does not consider the following behaviors <em>unsafe</em>, though a programmer may (should) find them undesirable, unexpected, or erroneous.</p> <h5 id="deadlocks">Deadlocks</h5> <h5 id="leaks-of-memory-and-other-resources">Leaks of memory and other resources</h5> <h5 id="exiting-without-calling-destructors">Exiting without calling destructors</h5> <h5 id="exposing-randomized-base-addresses-through-pointer-leaks">Exposing randomized base addresses through pointer leaks</h5> <h5 id="integer-overflow">Integer overflow</h5> <p>If a program contains arithmetic overflow, the programmer has made an error. In the following discussion, we maintain a distinction between arithmetic overflow and wrapping arithmetic. The first is erroneous, while the second is intentional.</p> <p>When the programmer has enabled <code>debug_assert!</code> assertions (for example, by enabling a non-optimized build), implementations must insert dynamic checks that <code>panic</code> on overflow. Other kinds of builds may result in <code>panics</code> or silently wrapped values on overflow, at the implementation's discretion.</p> <p>In the case of implicitly-wrapped overflow, implementations must provide well-defined (even if still considered erroneous) results by using two's complement overflow conventions.</p> <p>The integral types provide inherent methods to allow programmers explicitly to perform wrapping arithmetic. For example, <code>i32::wrapping_add</code> provides two's complement, wrapping addition.</p> <p>The standard library also provides a <code>Wrapping&lt;T&gt;</code> newtype which ensures all standard arithmetic operations for <code>T</code> have wrapping semantics.</p> <p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">RFC 560</a> for error conditions, rationale, and more details about integer overflow.</p> <h5 id="logic-errors">Logic errors</h5> <p>Safe code may impose extra logical constraints that can be checked at neither compile-time nor runtime. If a program breaks such a constraint, the behavior may be unspecified but will not result in undefined behavior. This could include panics, incorrect results, aborts, and non-termination. The behavior may also differ between runs, builds, or kinds of build.</p> <p>For example, implementing both <code>Hash</code> and <code>Eq</code> requires that values considered equal have equal hashes. Another example are data structures like <code>BinaryHeap</code>, <code>BTreeMap</code>, <code>BTreeSet</code>, <code>HashMap</code> and <code>HashSet</code> which describe constraints on the modification of their keys while they are in the data structure. Violating such constraints is not considered unsafe, yet the program is considered erroneous and its behavior unpredictable.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/behavior-not-considered-unsafe.html" class="_attribution-link">https://doc.rust-lang.org/reference/behavior-not-considered-unsafe.html</a>
  </p>
</div>
