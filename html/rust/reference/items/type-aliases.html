<h1 id="type-aliases">Type aliases</h1> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>TypeAlias</em> :<br> <code>type</code> <a href="../identifiers.html">IDENTIFIER</a> <a href="generics.html"><em>GenericParams</em></a><sup>?</sup> ( <code>:</code> <a href="../trait-bounds.html"><em>TypeParamBounds</em></a> )<sup>?</sup> <a href="generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup> ( <code>=</code> <a href="../types.html#type-expressions"><em>Type</em></a> <a href="generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup>)<sup>?</sup> <code>;</code></p> </blockquote> <p>A <em>type alias</em> defines a new name for an existing <a href="../types.html">type</a>. Type aliases are declared with the keyword <code>type</code>. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</p> <p>For example, the following defines the type <code>Point</code> as a synonym for the type <code>(u8, u8)</code>, the type of pairs of unsigned 8 bit integers:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
type Point = (u8, u8);
let p: Point = (41, 68);
}</pre> <p>A type alias to a tuple-struct or unit-struct cannot be used to qualify that type's constructor:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct MyStruct(u32);

use MyStruct as UseAlias;
type TypeAlias = MyStruct;

let _ = UseAlias(5); // OK
let _ = TypeAlias(5); // Doesn't work
}</pre> <p>A type alias, when not used as an associated type, must include a <a href="../types.html#type-expressions"><em>Type</em></a> and may not include <a href="../trait-bounds.html"><em>TypeParamBounds</em></a>.</p> <p>A type alias, when used as an <a href="associated-items.html#associated-types">associated type</a> in a <a href="traits.html">trait</a>, must not include a <a href="../types.html#type-expressions"><em>Type</em></a> specification but may include <a href="../trait-bounds.html"><em>TypeParamBounds</em></a>.</p> <p>A type alias, when used as an <a href="associated-items.html#associated-types">associated type</a> in a <a href="implementations.html#trait-implementations">trait impl</a>, must include a <a href="../types.html#type-expressions"><em>Type</em></a> specification and may not include <a href="../trait-bounds.html"><em>TypeParamBounds</em></a>.</p> <p>Where clauses before the equals sign on a type alias in a <a href="implementations.html#trait-implementations">trait impl</a> (like <code>type TypeAlias&lt;T&gt; where T: Foo = Bar&lt;T&gt;</code>) are deprecated. Where clauses after the equals sign (like <code>type TypeAlias&lt;T&gt; = Bar&lt;T&gt; where T: Foo</code>) are preferred.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/items/type-aliases.html" class="_attribution-link">https://doc.rust-lang.org/reference/items/type-aliases.html</a>
  </p>
</div>
