<h1 id="functions">Functions</h1> <div class="rule" id="r-items.fn"><a class="rule-link" href="#r-items.fn">[items.fn]</a></div> <div class="rule" id="r-items.fn.syntax"><a class="rule-link" href="#r-items.fn.syntax">[items.fn.syntax]</a></div> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>Function</em> :<br> <em>FunctionQualifiers</em> <code>fn</code> <a href="../identifiers.html">IDENTIFIER</a> <a href="generics.html"><em>GenericParams</em></a><sup>?</sup><br> <code>(</code> <em>FunctionParameters</em><sup>?</sup> <code>)</code><br> <em>FunctionReturnType</em><sup>?</sup> <a href="generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup><br> ( <a href="../expressions/block-expr.html"><em>BlockExpression</em></a> | <code>;</code> )</p> <p><em>FunctionQualifiers</em> :<br> <code>const</code><sup>?</sup> <code>async</code><sup class="footnote-reference"><a href="#async-edition">1</a></sup><sup>?</sup> <em>ItemSafety</em><sup>?</sup><sup class="footnote-reference"><a href="#extern-qualifiers">2</a></sup> (<code>extern</code> <em>Abi</em><sup>?</sup>)<sup>?</sup></p> <p><em>ItemSafety</em> :<br> <code>safe</code><sup class="footnote-reference"><a href="#extern-safe">3</a></sup> | <code>unsafe</code></p> <p><em>Abi</em> :<br> <a href="../tokens.html#string-literals">STRING_LITERAL</a> | <a href="../tokens.html#raw-string-literals">RAW_STRING_LITERAL</a></p> <p><em>FunctionParameters</em> :<br> <em>SelfParam</em> <code>,</code><sup>?</sup><br> | (<em>SelfParam</em> <code>,</code>)<sup>?</sup> <em>FunctionParam</em> (<code>,</code> <em>FunctionParam</em>)<sup>*</sup> <code>,</code><sup>?</sup></p> <p><em>SelfParam</em> :<br> <a href="../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> ( <em>ShorthandSelf</em> | <em>TypedSelf</em> )</p> <p><em>ShorthandSelf</em> :<br> (<code>&amp;</code> | <code>&amp;</code> <a href="../trait-bounds.html"><em>Lifetime</em></a>)<sup>?</sup> <code>mut</code><sup>?</sup> <code>self</code></p> <p><em>TypedSelf</em> :<br> <code>mut</code><sup>?</sup> <code>self</code> <code>:</code> <a href="../types.html#type-expressions"><em>Type</em></a></p> <p><em>FunctionParam</em> :<br> <a href="../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> ( <em>FunctionParamPattern</em> | <code>...</code> | <a href="../types.html#type-expressions"><em>Type</em></a> <sup class="footnote-reference"><a href="#fn-param-2015">4</a></sup> )</p> <p><em>FunctionParamPattern</em> :<br> <a href="../patterns.html"><em>PatternNoTopAlt</em></a> <code>:</code> ( <a href="../types.html#type-expressions"><em>Type</em></a> | <code>...</code> )</p> <p><em>FunctionReturnType</em> :<br> <code>-&gt;</code> <a href="../types.html#type-expressions"><em>Type</em></a></p> <div class="footnote-definition" id="async-edition">
<sup class="footnote-definition-label">1</sup> <p>The <code>async</code> qualifier is not allowed in the 2015 edition.</p> </div> <div class="footnote-definition" id="extern-safe">
<sup class="footnote-definition-label">3</sup> <p>The <code>safe</code> function qualifier is only allowed semantically within <code>extern</code> blocks.</p> </div> <div class="footnote-definition" id="extern-qualifiers">
<sup class="footnote-definition-label">2</sup> <p><em>Relevant to editions earlier than Rust 2024</em>: Within <code>extern</code> blocks, the <code>safe</code> or <code>unsafe</code> function qualifier is only allowed when the <code>extern</code> is qualified as <code>unsafe</code>.</p> </div> <div class="footnote-definition" id="fn-param-2015">
<sup class="footnote-definition-label">4</sup> <p>Function parameters with only a type are only allowed in an associated function of a <a href="traits.html">trait item</a> in the 2015 edition.</p> </div> </blockquote> <div class="rule" id="r-items.fn.intro"><a class="rule-link" href="#r-items.fn.intro">[items.fn.intro]</a></div> <p>A <em>function</em> consists of a <a href="../expressions/block-expr.html">block</a> (that’s the <em>body</em> of the function), along with a name, a set of parameters, and an output type. Other than a name, all these are optional.</p> <div class="rule" id="r-items.fn.namespace"><a class="rule-link" href="#r-items.fn.namespace">[items.fn.namespace]</a></div> <p>Functions are declared with the keyword <code>fn</code> which defines the given name in the <a href="../names/namespaces.html">value namespace</a> of the module or block where it is located.</p> <div class="rule" id="r-items.fn.signature"><a class="rule-link" href="#r-items.fn.signature">[items.fn.signature]</a></div> <p>Functions may declare a set of <em>input</em> <a href="../variables.html"><em>variables</em></a> as parameters, through which the caller passes arguments into the function, and the <em>output</em> <a href="../types.html#type-expressions"><em>type</em></a> of the value the function will return to its caller on completion.</p> <div class="rule" id="r-items.fn.implicit-return"><a class="rule-link" href="#r-items.fn.implicit-return">[items.fn.implicit-return]</a></div> <p>If the output type is not explicitly stated, it is the <a href="../types/tuple.html">unit type</a>.</p> <div class="rule" id="r-items.fn.fn-item-type"><a class="rule-link" href="#r-items.fn.fn-item-type">[items.fn.fn-item-type]</a></div> <p>When referred to, a <em>function</em> yields a first-class <em>value</em> of the corresponding zero-sized <a href="../types/function-item.html"><em>function item type</em></a>, which when called evaluates to a direct call to the function.</p> <p>For example, this is a simple function:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn answer_to_life_the_universe_and_everything() -&gt; i32 {
    return 42;
}
}</pre> <div class="rule" id="r-items.fn.safety-qualifiers"><a class="rule-link" href="#r-items.fn.safety-qualifiers">[items.fn.safety-qualifiers]</a></div> <p>The <code>safe</code> function is semantically only allowed when used in an <a href="external-blocks.html"><code>extern</code> block</a>.</p> <h2 id="function-parameters">Function parameters</h2> <div class="rule" id="r-items.fn.params"><a class="rule-link" href="#r-items.fn.params">[items.fn.params]</a></div> <div class="rule" id="r-items.fn.params.intro"><a class="rule-link" href="#r-items.fn.params.intro">[items.fn.params.intro]</a></div> <p>Function parameters are irrefutable <a href="../patterns.html">patterns</a>, so any pattern that is valid in an else-less <code>let</code> binding is also valid as a parameter:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn first((value, _): (i32, i32)) -&gt; i32 { value }
}</pre> <div class="rule" id="r-items.fn.params.self-pat"><a class="rule-link" href="#r-items.fn.params.self-pat">[items.fn.params.self-pat]</a></div> <p>If the first parameter is a <em>SelfParam</em>, this indicates that the function is a <a href="associated-items.html#methods">method</a>.</p> <div class="rule" id="r-items.fn.params.self-restriction"><a class="rule-link" href="#r-items.fn.params.self-restriction">[items.fn.params.self-restriction]</a></div> <p>Functions with a self parameter may only appear as an <a href="associated-items.html#associated-functions-and-methods">associated function</a> in a <a href="traits.html">trait</a> or <a href="implementations.html">implementation</a>.</p> <div class="rule" id="r-items.fn.params.varargs"><a class="rule-link" href="#r-items.fn.params.varargs">[items.fn.params.varargs]</a></div> <p>A parameter with the <code>...</code> token indicates a <a href="external-blocks.html#variadic-functions">variadic function</a>, and may only be used as the last parameter of an <a href="external-blocks.html">external block</a> function. The variadic parameter may have an optional identifier, such as <code>args: ...</code>.</p> <h2 id="function-body">Function body</h2> <div class="rule" id="r-items.fn.body"><a class="rule-link" href="#r-items.fn.body">[items.fn.body]</a></div> <div class="rule" id="r-items.fn.body.intro"><a class="rule-link" href="#r-items.fn.body.intro">[items.fn.body.intro]</a></div> <p>The body block of a function is conceptually wrapped in another block that first binds the argument patterns and then <code>return</code>s the value of the function’s body. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</p> <p>For example, the function above behaves as if it was written as:</p>  <pre data-language="rust">// argument_0 is the actual first argument passed from the caller
let (value, _) = argument_0;
return {
    value
};</pre> <div class="rule" id="r-items.fn.body.bodyless"><a class="rule-link" href="#r-items.fn.body.bodyless">[items.fn.body.bodyless]</a></div> <p>Functions without a body block are terminated with a semicolon. This form may only appear in a <a href="traits.html">trait</a> or <a href="external-blocks.html">external block</a>.</p> <h2 id="generic-functions">Generic functions</h2> <div class="rule" id="r-items.fn.generics"><a class="rule-link" href="#r-items.fn.generics">[items.fn.generics]</a></div> <div class="rule" id="r-items.fn.generics.intro"><a class="rule-link" href="#r-items.fn.generics.intro">[items.fn.generics.intro]</a></div> <p>A <em>generic function</em> allows one or more <em>parameterized types</em> to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// foo is generic over A and B

fn foo&lt;A, B&gt;(x: A, y: B) {
}
}</pre> <div class="rule" id="r-items.fn.generics.param-names"><a class="rule-link" href="#r-items.fn.generics.param-names">[items.fn.generics.param-names]</a></div> <p>Inside the function signature and body, the name of the type parameter can be used as a type name.</p> <div class="rule" id="r-items.fn.generics.param-bounds"><a class="rule-link" href="#r-items.fn.generics.param-bounds">[items.fn.generics.param-bounds]</a></div> <p><a href="traits.html">Trait</a> bounds can be specified for type parameters to allow methods with that trait to be called on values of that type. This is specified using the <code>where</code> syntax:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::fmt::Debug;
fn foo&lt;T&gt;(x: T) where T: Debug {
}
}</pre> <div class="rule" id="r-items.fn.generics.mono"><a class="rule-link" href="#r-items.fn.generics.mono">[items.fn.generics.mono]</a></div> <p>When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the <code>foo</code> function here:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::fmt::Debug;

fn foo&lt;T&gt;(x: &amp;[T]) where T: Debug {
    // details elided
}

foo(&amp;[1, 2]);
}</pre> <p>will instantiate type parameter <code>T</code> with <code>i32</code>.</p> <div class="rule" id="r-items.fn.generics.explicit-arguments"><a class="rule-link" href="#r-items.fn.generics.explicit-arguments">[items.fn.generics.explicit-arguments]</a></div> <p>The type parameters can also be explicitly supplied in a trailing <a href="../paths.html">path</a> component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, <code>mem::size_of::&lt;u32&gt;() == 4</code>.</p> <h2 id="extern-function-qualifier">Extern function qualifier</h2> <div class="rule" id="r-items.fn.extern"><a class="rule-link" href="#r-items.fn.extern">[items.fn.extern]</a></div> <div class="rule" id="r-items.fn.extern.intro"><a class="rule-link" href="#r-items.fn.extern.intro">[items.fn.extern.intro]</a></div> <p>The <code>extern</code> function qualifier allows providing function <em>definitions</em> that can be called with a particular ABI:</p>  <pre data-language="rust">extern "ABI" fn foo() { /* ... */ }</pre> <div class="rule" id="r-items.fn.extern.def"><a class="rule-link" href="#r-items.fn.extern.def">[items.fn.extern.def]</a></div> <p>These are often used in combination with <a href="external-blocks.html">external block</a> items which provide function <em>declarations</em> that can be used to call functions without providing their <em>definition</em>:</p>  <pre data-language="rust">unsafe extern "ABI" {
  unsafe fn foo(); /* no body */
  safe fn bar(); /* no body */
}
unsafe { foo() };
bar();</pre> <div class="rule" id="r-items.fn.extern.default-abi"><a class="rule-link" href="#r-items.fn.extern.default-abi">[items.fn.extern.default-abi]</a></div> <p>When <code>"extern" Abi?*</code> is omitted from <code>FunctionQualifiers</code> in function items, the ABI <code>"Rust"</code> is assigned. For example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo() {}
}</pre> <p>is equivalent to:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
extern "Rust" fn foo() {}
}</pre> <div class="rule" id="r-items.fn.extern.foreign-call"><a class="rule-link" href="#r-items.fn.extern.foreign-call">[items.fn.extern.foreign-call]</a></div> <p>Functions can be called by foreign code, and using an ABI that differs from Rust allows, for example, to provide functions that can be called from other programming languages like C:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// Declares a function with the "C" ABI
extern "C" fn new_i32() -&gt; i32 { 0 }

// Declares a function with the "stdcall" ABI
#[cfg(any(windows, target_arch = "x86"))]
extern "stdcall" fn new_i32_stdcall() -&gt; i32 { 0 }
}</pre> <div class="rule" id="r-items.fn.extern.default-extern"><a class="rule-link" href="#r-items.fn.extern.default-extern">[items.fn.extern.default-extern]</a></div> <p>Just as with <a href="external-blocks.html">external block</a>, when the <code>extern</code> keyword is used and the <code>"ABI"</code> is omitted, the ABI used defaults to <code>"C"</code>. That is, this:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
extern fn new_i32() -&gt; i32 { 0 }
let fptr: extern fn() -&gt; i32 = new_i32;
}</pre> <p>is equivalent to:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
extern "C" fn new_i32() -&gt; i32 { 0 }
let fptr: extern "C" fn() -&gt; i32 = new_i32;
}</pre> <div class="rule" id="r-items.fn.extern.unwind"><a class="rule-link" href="#r-items.fn.extern.unwind">[items.fn.extern.unwind]</a></div> <p>Functions with an ABI that differs from <code>"Rust"</code> do not support unwinding in the exact same way that Rust does. Therefore, unwinding past the end of functions with such ABIs causes the process to abort.</p> <blockquote> <p><strong>Note</strong>: The LLVM backend of the <code>rustc</code> implementation aborts the process by executing an illegal instruction.</p> </blockquote> <h2 id="const-functions">Const functions</h2> <div class="rule" id="r-items.fn.const"><a class="rule-link" href="#r-items.fn.const">[items.fn.const]</a></div> <div class="rule" id="r-items.fn.const.intro"><a class="rule-link" href="#r-items.fn.const.intro">[items.fn.const.intro]</a></div> <p>Functions qualified with the <code>const</code> keyword are <a href="../const_eval.html#const-functions">const functions</a>, as are <a href="structs.html">tuple struct</a> and <a href="enumerations.html">tuple variant</a> constructors. <em>Const functions</em> can be called from within <a href="../const_eval.html#const-context">const contexts</a>.</p> <div class="rule" id="r-items.fn.const.extern"><a class="rule-link" href="#r-items.fn.const.extern">[items.fn.const.extern]</a></div> <p>Const functions may use the <a href="#extern-function-qualifier"><code>extern</code></a> function qualifier.</p> <div class="rule" id="r-items.fn.const.exclusivity"><a class="rule-link" href="#r-items.fn.const.exclusivity">[items.fn.const.exclusivity]</a></div> <p>Const functions are not allowed to be <a href="#async-functions">async</a>.</p> <h2 id="async-functions">Async functions</h2> <div class="rule" id="r-items.fn.async"><a class="rule-link" href="#r-items.fn.async">[items.fn.async]</a></div> <div class="rule" id="r-items.fn.async.intro"><a class="rule-link" href="#r-items.fn.async.intro">[items.fn.async.intro]</a></div> <p>Functions may be qualified as async, and this can also be combined with the <code>unsafe</code> qualifier:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
async fn regular_example() { }
async unsafe fn unsafe_example() { }
}</pre> <div class="rule" id="r-items.fn.async.future"><a class="rule-link" href="#r-items.fn.async.future">[items.fn.async.future]</a></div> <p>Async functions do no work when called: instead, they capture their arguments into a future. When polled, that future will execute the function’s body.</p> <div class="rule" id="r-items.fn.async.desugar-brief"><a class="rule-link" href="#r-items.fn.async.desugar-brief">[items.fn.async.desugar-brief]</a></div> <p>An async function is roughly equivalent to a function that returns <a href="../types/impl-trait.html"><code>impl Future</code></a> and with an <a href="../expressions/block-expr.html#async-blocks"><code>async move</code> block</a> as its body:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// Source
async fn example(x: &amp;str) -&gt; usize {
    x.len()
}
}</pre> <p>is roughly equivalent to:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::future::Future;
// Desugared
fn example&lt;'a&gt;(x: &amp;'a str) -&gt; impl Future&lt;Output = usize&gt; + 'a {
    async move { x.len() }
}
}</pre> <div class="rule" id="r-items.fn.async.desugar"><a class="rule-link" href="#r-items.fn.async.desugar">[items.fn.async.desugar]</a></div> <p>The actual desugaring is more complex:</p> <div class="rule" id="r-items.fn.async.lifetime-capture"><a class="rule-link" href="#r-items.fn.async.lifetime-capture">[items.fn.async.lifetime-capture]</a></div> <ul> <li>The return type in the desugaring is assumed to capture all lifetime parameters from the <code>async fn</code> declaration. This can be seen in the desugared example above, which explicitly outlives, and hence captures, <code>'a</code>.</li> </ul> <div class="rule" id="r-items.fn.async.param-capture"><a class="rule-link" href="#r-items.fn.async.param-capture">[items.fn.async.param-capture]</a></div> <ul> <li>The <a href="../expressions/block-expr.html#async-blocks"><code>async move</code> block</a> in the body captures all function parameters, including those that are unused or bound to a <code>_</code> pattern. This ensures that function parameters are dropped in the same order as they would be if the function were not async, except that the drop occurs when the returned future has been fully awaited.</li> </ul> <p>For more information on the effect of async, see <a href="../expressions/block-expr.html#async-blocks"><code>async</code> blocks</a>.</p> <div class="rule" id="r-items.fn.async.edition2018"><a class="rule-link" href="#r-items.fn.async.edition2018">[items.fn.async.edition2018]</a></div> <blockquote> <p><strong>Edition differences</strong>: Async functions are only available beginning with Rust 2018.</p> </blockquote> <h3 id="combining-async-and-unsafe">Combining <code id="">async</code> and <code>unsafe</code>
</h3> <div class="rule" id="r-items.fn.async.safety"><a class="rule-link" href="#r-items.fn.async.safety">[items.fn.async.safety]</a></div> <div class="rule" id="r-items.fn.async.safety.intro"><a class="rule-link" href="#r-items.fn.async.safety.intro">[items.fn.async.safety.intro]</a></div> <p>It is legal to declare a function that is both async and unsafe. The resulting function is unsafe to call and (like any async function) returns a future. This future is just an ordinary future and thus an <code>unsafe</code> context is not required to “await” it:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// Returns a future that, when awaited, dereferences `x`.
//
// Soundness condition: `x` must be safe to dereference until
// the resulting future is complete.
async unsafe fn unsafe_example(x: *const i32) -&gt; i32 {
  *x
}

async fn safe_example() {
    // An `unsafe` block is required to invoke the function initially:
    let p = 22;
    let future = unsafe { unsafe_example(&amp;p) };

    // But no `unsafe` block required here. This will
    // read the value of `p`:
    let q = future.await;
}
}</pre> <p>Note that this behavior is a consequence of the desugaring to a function that returns an <code>impl Future</code> – in this case, the function we desugar to is an <code>unsafe</code> function, but the return value remains the same.</p> <p>Unsafe is used on an async function in precisely the same way that it is used on other functions: it indicates that the function imposes some additional obligations on its caller to ensure soundness. As in any other unsafe function, these conditions may extend beyond the initial call itself – in the snippet above, for example, the <code>unsafe_example</code> function took a pointer <code>x</code> as argument, and then (when awaited) dereferenced that pointer. This implies that <code>x</code> would have to be valid until the future is finished executing, and it is the caller’s responsibility to ensure that.</p> <h2 id="attributes-on-functions">Attributes on functions</h2> <div class="rule" id="r-items.fn.attributes"><a class="rule-link" href="#r-items.fn.attributes">[items.fn.attributes]</a></div> <div class="rule" id="r-items.fn.attributes.intro"><a class="rule-link" href="#r-items.fn.attributes.intro">[items.fn.attributes.intro]</a></div> <p><a href="../attributes.html">Outer attributes</a> are allowed on functions. <a href="../attributes.html">Inner attributes</a> are allowed directly after the <code>{</code> inside its body <a href="../expressions/block-expr.html">block</a>.</p> <p>This example shows an inner attribute on a function. The function is documented with just the word “Example”.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn documented() {
    #![doc = "Example"]
}
}</pre> <blockquote> <p>Note: Except for lints, it is idiomatic to only use outer attributes on function items.</p> </blockquote> <div class="rule" id="r-items.fn.attributes.builtin-attributes"><a class="rule-link" href="#r-items.fn.attributes.builtin-attributes">[items.fn.attributes.builtin-attributes]</a></div> <p>The attributes that have meaning on a function are <a href="../conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a>, <a href="../conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a>, <a href="../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>, <a href="https://doc.rust-lang.org/rustdoc/the-doc-attribute.html"><code>doc</code></a>, <a href="../abi.html#the-export_name-attribute"><code>export_name</code></a>, <a href="../abi.html#the-link_section-attribute"><code>link_section</code></a>, <a href="../abi.html#the-no_mangle-attribute"><code>no_mangle</code></a>, <a href="../attributes/diagnostics.html#lint-check-attributes">the lint check attributes</a>, <a href="../attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code></a>, <a href="../procedural-macros.html">the procedural macro attributes</a>, <a href="../attributes/testing.html">the testing attributes</a>, and <a href="../attributes/codegen.html#optimization-hints">the optimization hint attributes</a>. Functions also accept attributes macros.</p> <h2 id="attributes-on-function-parameters">Attributes on function parameters</h2> <div class="rule" id="r-items.fn.param-attributes"><a class="rule-link" href="#r-items.fn.param-attributes">[items.fn.param-attributes]</a></div> <div class="rule" id="r-items.fn.param-attributes.intro"><a class="rule-link" href="#r-items.fn.param-attributes.intro">[items.fn.param-attributes.intro]</a></div> <p><a href="../attributes.html">Outer attributes</a> are allowed on function parameters and the permitted <a href="../attributes.html#built-in-attributes-index">built-in attributes</a> are restricted to <code>cfg</code>, <code>cfg_attr</code>, <code>allow</code>, <code>warn</code>, <code>deny</code>, and <code>forbid</code>.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn len(
    #[cfg(windows)] slice: &amp;[u16],
    #[cfg(not(windows))] slice: &amp;[u8],
) -&gt; usize {
    slice.len()
}
}</pre> <div class="rule" id="r-items.fn.param-attributes.parsed-attributes"><a class="rule-link" href="#r-items.fn.param-attributes.parsed-attributes">[items.fn.param-attributes.parsed-attributes]</a></div> <p>Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final <code>TokenStream</code>.</p> <p>For example, the following code defines an inert <code>some_inert_attribute</code> attribute that is not formally defined anywhere and the <code>some_proc_macro_attribute</code> procedural macro is responsible for detecting its presence and removing it from the output token stream.</p>  <pre data-language="rust">#[some_proc_macro_attribute]
fn foo_oof(#[some_inert_attribute] arg: u8) {
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/items/functions.html" class="_attribution-link">https://doc.rust-lang.org/reference/items/functions.html</a>
  </p>
</div>
