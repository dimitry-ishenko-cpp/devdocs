<h1 id="external-blocks">External blocks</h1> <div class="rule" id="r-items.extern"><a class="rule-link" href="#r-items.extern">[items.extern]</a></div> <div class="rule" id="r-items.extern.syntax"><a class="rule-link" href="#r-items.extern.syntax">[items.extern.syntax]</a></div> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>ExternBlock</em> :<br> <code>unsafe</code><sup>?</sup><sup class="footnote-reference"><a href="#unsafe-2024">1</a></sup> <code>extern</code> <a href="functions.html"><em>Abi</em></a><sup>?</sup> <code>{</code><br> <a href="../attributes.html"><em>InnerAttribute</em></a><sup>*</sup><br> <em>ExternalItem</em><sup>*</sup><br> <code>}</code></p> <p><em>ExternalItem</em> :<br> <a href="../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> (<br> <a href="../macros.html#macro-invocation"><em>MacroInvocationSemi</em></a><br> | ( <a href="../visibility-and-privacy.html"><em>Visibility</em></a><sup>?</sup> ( <a href="static-items.html"><em>StaticItem</em></a> | <a href="functions.html"><em>Function</em></a> ) )<br> )</p> <div class="footnote-definition" id="unsafe-2024">
<sup class="footnote-definition-label">1</sup> <p>Starting with the 2024 Edition, the <code>unsafe</code> keyword is required semantically.</p> </div> </blockquote> <div class="rule" id="r-items.extern.intro"><a class="rule-link" href="#r-items.extern.intro">[items.extern.intro]</a></div> <p>External blocks provide <em>declarations</em> of items that are not <em>defined</em> in the current crate and are the basis of Rust’s foreign function interface. These are akin to unchecked imports.</p> <div class="rule" id="r-items.extern.allowed-kinds"><a class="rule-link" href="#r-items.extern.allowed-kinds">[items.extern.allowed-kinds]</a></div> <p>Two kinds of item <em>declarations</em> are allowed in external blocks: <a href="functions.html">functions</a> and <a href="static-items.html">statics</a>.</p> <div class="rule" id="r-items.extern.fn-safety"><a class="rule-link" href="#r-items.extern.fn-safety">[items.extern.fn-safety]</a></div> <p>Calling functions or accessing statics that are declared in external blocks is only allowed in an <code>unsafe</code> context.</p> <div class="rule" id="r-items.extern.namespace"><a class="rule-link" href="#r-items.extern.namespace">[items.extern.namespace]</a></div> <p>The external block defines its functions and statics in the <a href="../names/namespaces.html">value namespace</a> of the module or block where it is located.</p> <div class="rule" id="r-items.extern.unsafe-required"><a class="rule-link" href="#r-items.extern.unsafe-required">[items.extern.unsafe-required]</a></div> <p>The <code>unsafe</code> keyword is semantically required to appear before the <code>extern</code> keyword on external blocks.</p> <div class="rule" id="r-items.extern.edition2024"><a class="rule-link" href="#r-items.extern.edition2024">[items.extern.edition2024]</a></div> <blockquote> <p><strong>Edition differences</strong>: Prior to the 2024 edition, the <code>unsafe</code> keyword is optional. The <code>safe</code> and <code>unsafe</code> item qualifiers are only allowed if the external block itself is marked as <code>unsafe</code>.</p> </blockquote> <h2 id="functions">Functions</h2> <div class="rule" id="r-items.extern.fn"><a class="rule-link" href="#r-items.extern.fn">[items.extern.fn]</a></div> <div class="rule" id="r-items.extern.fn.body"><a class="rule-link" href="#r-items.extern.fn.body">[items.extern.fn.body]</a></div> <p>Functions within external blocks are declared in the same way as other Rust functions, with the exception that they must not have a body and are instead terminated by a semicolon.</p> <div class="rule" id="r-items.extern.fn.param-patterns"><a class="rule-link" href="#r-items.extern.fn.param-patterns">[items.extern.fn.param-patterns]</a></div> <p>Patterns are not allowed in parameters, only <a href="../identifiers.html">IDENTIFIER</a> or <code>_</code> may be used.</p> <div class="rule" id="r-items.extern.fn.qualifiers"><a class="rule-link" href="#r-items.extern.fn.qualifiers">[items.extern.fn.qualifiers]</a></div> <p>The <code>safe</code> and <code>unsafe</code> function qualifiers are allowed, but other function qualifiers (e.g. <code>const</code>, <code>async</code>, <code>extern</code>) are not.</p> <div class="rule" id="r-items.extern.fn.foreign-abi"><a class="rule-link" href="#r-items.extern.fn.foreign-abi">[items.extern.fn.foreign-abi]</a></div> <p>Functions within external blocks may be called by Rust code, just like functions defined in Rust. The Rust compiler automatically translates between the Rust ABI and the foreign ABI.</p> <div class="rule" id="r-items.extern.fn.safety"><a class="rule-link" href="#r-items.extern.fn.safety">[items.extern.fn.safety]</a></div> <p>A function declared in an extern block is implicitly <code>unsafe</code> unless the <code>safe</code> function qualifier is present.</p> <div class="rule" id="r-items.extern.fn.fn-ptr"><a class="rule-link" href="#r-items.extern.fn.fn-ptr">[items.extern.fn.fn-ptr]</a></div> <p>When coerced to a function pointer, a function declared in an extern block has type <code>extern "abi" for&lt;'l1, ..., 'lm&gt; fn(A1, ..., An) -&gt; R</code>, where <code>'l1</code>, … <code>'lm</code> are its lifetime parameters, <code>A1</code>, …, <code>An</code> are the declared types of its parameters, <code>R</code> is the declared return type.</p> <h2 id="statics">Statics</h2> <div class="rule" id="r-items.extern.static"><a class="rule-link" href="#r-items.extern.static">[items.extern.static]</a></div> <div class="rule" id="r-items.extern.static.intro"><a class="rule-link" href="#r-items.extern.static.intro">[items.extern.static.intro]</a></div> <p>Statics within external blocks are declared in the same way as <a href="static-items.html">statics</a> outside of external blocks, except that they do not have an expression initializing their value.</p> <div class="rule" id="r-items.extern.static.safety"><a class="rule-link" href="#r-items.extern.static.safety">[items.extern.static.safety]</a></div> <p>Unless a static item declared in an extern block is qualified as <code>safe</code>, it is <code>unsafe</code> to access that item, whether or not it’s mutable, because there is nothing guaranteeing that the bit pattern at the static’s memory is valid for the type it is declared with, since some arbitrary (e.g. C) code is in charge of initializing the static.</p> <div class="rule" id="r-items.extern.static.mut"><a class="rule-link" href="#r-items.extern.static.mut">[items.extern.static.mut]</a></div> <p>Extern statics can be either immutable or mutable just like <a href="static-items.html">statics</a> outside of external blocks.</p> <div class="rule" id="r-items.extern.static.read-only"><a class="rule-link" href="#r-items.extern.static.read-only">[items.extern.static.read-only]</a></div> <p>An immutable static <em>must</em> be initialized before any Rust code is executed. It is not enough for the static to be initialized before Rust code reads from it. Once Rust code runs, mutating an immutable static (from inside or outside Rust) is UB, except if the mutation happens to bytes inside of an <code>UnsafeCell</code>.</p> <h2 id="abi">ABI</h2> <div class="rule" id="r-items.extern.abi"><a class="rule-link" href="#r-items.extern.abi">[items.extern.abi]</a></div> <div class="rule" id="r-items.extern.abi.intro"><a class="rule-link" href="#r-items.extern.abi.intro">[items.extern.abi.intro]</a></div> <p>By default external blocks assume that the library they are calling uses the standard C ABI on the specific platform. Other ABIs may be specified using an <code>abi</code> string, as shown here:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(any(windows, target_arch = "x86"))]
// Interface to the Windows API
unsafe extern "stdcall" { }
}</pre> <div class="rule" id="r-items.extern.abi.standard"><a class="rule-link" href="#r-items.extern.abi.standard">[items.extern.abi.standard]</a></div> <p>There are three ABI strings which are cross-platform, and which all compilers are guaranteed to support:</p> <div class="rule" id="r-items.extern.abi.rust"><a class="rule-link" href="#r-items.extern.abi.rust">[items.extern.abi.rust]</a></div> <ul> <li>
<code>unsafe extern "Rust"</code> – The default ABI when you write a normal <code>fn foo()</code> in any Rust code.</li> </ul> <div class="rule" id="r-items.extern.abi.c"><a class="rule-link" href="#r-items.extern.abi.c">[items.extern.abi.c]</a></div> <ul> <li>
<code>unsafe extern "C"</code> – This is the same as <code>extern fn foo()</code>; whatever the default your C compiler supports.</li> </ul> <div class="rule" id="r-items.extern.abi.system"><a class="rule-link" href="#r-items.extern.abi.system">[items.extern.abi.system]</a></div> <ul> <li>
<code>unsafe extern "system"</code> – Usually the same as <code>extern "C"</code>, except on Win32, in which case it’s <code>"stdcall"</code>, or what you should use to link to the Windows API itself</li> </ul> <div class="rule" id="r-items.extern.abi.platform"><a class="rule-link" href="#r-items.extern.abi.platform">[items.extern.abi.platform]</a></div> <p>There are also some platform-specific ABI strings:</p> <div class="rule" id="r-items.extern.abi.cdecl"><a class="rule-link" href="#r-items.extern.abi.cdecl">[items.extern.abi.cdecl]</a></div> <ul> <li>
<code>unsafe extern "cdecl"</code> – The default for x86_32 C code.</li> </ul> <div class="rule" id="r-items.extern.abi.stdcall"><a class="rule-link" href="#r-items.extern.abi.stdcall">[items.extern.abi.stdcall]</a></div> <ul> <li>
<code>unsafe extern "stdcall"</code> – The default for the Win32 API on x86_32.</li> </ul> <div class="rule" id="r-items.extern.abi.win64"><a class="rule-link" href="#r-items.extern.abi.win64">[items.extern.abi.win64]</a></div> <ul> <li>
<code>unsafe extern "win64"</code> – The default for C code on x86_64 Windows.</li> </ul> <div class="rule" id="r-items.extern.abi.sysv64"><a class="rule-link" href="#r-items.extern.abi.sysv64">[items.extern.abi.sysv64]</a></div> <ul> <li>
<code>unsafe extern "sysv64"</code> – The default for C code on non-Windows x86_64.</li> </ul> <div class="rule" id="r-items.extern.abi.aapcs"><a class="rule-link" href="#r-items.extern.abi.aapcs">[items.extern.abi.aapcs]</a></div> <ul> <li>
<code>unsafe extern "aapcs"</code> – The default for ARM.</li> </ul> <div class="rule" id="r-items.extern.abi.fastcall"><a class="rule-link" href="#r-items.extern.abi.fastcall">[items.extern.abi.fastcall]</a></div> <ul> <li>
<code>unsafe extern "fastcall"</code> – The <code>fastcall</code> ABI – corresponds to MSVC’s <code>__fastcall</code> and GCC and clang’s <code>__attribute__((fastcall))</code>
</li> </ul> <div class="rule" id="r-items.extern.abi.vectorcall"><a class="rule-link" href="#r-items.extern.abi.vectorcall">[items.extern.abi.vectorcall]</a></div> <ul> <li>
<code>unsafe extern "vectorcall"</code> – The <code>vectorcall</code> ABI – corresponds to MSVC’s <code>__vectorcall</code> and clang’s <code>__attribute__((vectorcall))</code>
</li> </ul> <div class="rule" id="r-items.extern.abi.thiscall"><a class="rule-link" href="#r-items.extern.abi.thiscall">[items.extern.abi.thiscall]</a></div> <ul> <li>
<code>unsafe extern "thiscall"</code> – The default for C++ member functions on MSVC – corresponds to MSVC’s <code>__thiscall</code> and GCC and clang’s <code>__attribute__((thiscall))</code>
</li> </ul> <div class="rule" id="r-items.extern.abi.efiapi"><a class="rule-link" href="#r-items.extern.abi.efiapi">[items.extern.abi.efiapi]</a></div> <ul> <li>
<code>unsafe extern "efiapi"</code> – The ABI used for <a href="https://uefi.org/specifications">UEFI</a> functions.</li> </ul> <h2 id="variadic-functions">Variadic functions</h2> <div class="rule" id="r-items.extern.variadic"><a class="rule-link" href="#r-items.extern.variadic">[items.extern.variadic]</a></div> <p>Functions within external blocks may be variadic by specifying <code>...</code> as the last argument. The variadic parameter may optionally be specified with an identifier.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
unsafe extern "C" {
    safe fn foo(...);
    unsafe fn bar(x: i32, ...);
    unsafe fn with_name(format: *const u8, args: ...);
}
}</pre> <h2 id="attributes-on-extern-blocks">Attributes on extern blocks</h2> <div class="rule" id="r-items.extern.attributes"><a class="rule-link" href="#r-items.extern.attributes">[items.extern.attributes]</a></div> <div class="rule" id="r-items.extern.attributes.intro"><a class="rule-link" href="#r-items.extern.attributes.intro">[items.extern.attributes.intro]</a></div> <p>The following <a href="../attributes.html">attributes</a> control the behavior of external blocks.</p> <h3 id="the-link-attribute">The <code id="">link</code> attribute</h3> <div class="rule" id="r-items.extern.attributes.link"><a class="rule-link" href="#r-items.extern.attributes.link">[items.extern.attributes.link]</a></div> <div class="rule" id="r-items.extern.attributes.link.intro"><a class="rule-link" href="#r-items.extern.attributes.link.intro">[items.extern.attributes.link.intro]</a></div> <p>The <em><code>link</code> attribute</em> specifies the name of a native library that the compiler should link with for the items within an <code>extern</code> block.</p> <div class="rule" id="r-items.extern.attributes.link.syntax"><a class="rule-link" href="#r-items.extern.attributes.link.syntax">[items.extern.attributes.link.syntax]</a></div> <p>It uses the <a href="../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> syntax to specify its inputs. The <code>name</code> key is the name of the native library to link. The <code>kind</code> key is an optional value which specifies the kind of library with the following possible values:</p> <div class="rule" id="r-items.extern.attributes.link.dylib"><a class="rule-link" href="#r-items.extern.attributes.link.dylib">[items.extern.attributes.link.dylib]</a></div> <ul> <li>
<code>dylib</code> — Indicates a dynamic library. This is the default if <code>kind</code> is not specified.</li> </ul> <div class="rule" id="r-items.extern.attributes.link.static"><a class="rule-link" href="#r-items.extern.attributes.link.static">[items.extern.attributes.link.static]</a></div> <ul> <li>
<code>static</code> — Indicates a static library.</li> </ul> <div class="rule" id="r-items.extern.attributes.link.framework"><a class="rule-link" href="#r-items.extern.attributes.link.framework">[items.extern.attributes.link.framework]</a></div> <ul> <li>
<code>framework</code> — Indicates a macOS framework. This is only valid for macOS targets.</li> </ul> <div class="rule" id="r-items.extern.attributes.link.raw-dylib"><a class="rule-link" href="#r-items.extern.attributes.link.raw-dylib">[items.extern.attributes.link.raw-dylib]</a></div> <ul> <li>
<code>raw-dylib</code> — Indicates a dynamic library where the compiler will generate an import library to link against (see <a href="#dylib-versus-raw-dylib"><code>dylib</code> versus <code>raw-dylib</code></a> below for details). This is only valid for Windows targets.</li> </ul> <div class="rule" id="r-items.extern.attributes.link.name-requirement"><a class="rule-link" href="#r-items.extern.attributes.link.name-requirement">[items.extern.attributes.link.name-requirement]</a></div> <p>The <code>name</code> key must be included if <code>kind</code> is specified.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers">[items.extern.attributes.link.modifiers]</a></div> <p>The optional <code>modifiers</code> argument is a way to specify linking modifiers for the library to link.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers.syntax"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.syntax">[items.extern.attributes.link.modifiers.syntax]</a></div> <p>Modifiers are specified as a comma-delimited string with each modifier prefixed with either a <code>+</code> or <code>-</code> to indicate that the modifier is enabled or disabled, respectively.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers.multiple"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.multiple">[items.extern.attributes.link.modifiers.multiple]</a></div> <p>Specifying multiple <code>modifiers</code> arguments in a single <code>link</code> attribute, or multiple identical modifiers in the same <code>modifiers</code> argument is not currently supported. <br> Example: <code>#[link(name = "mylib", kind = "static", modifiers = "+whole-archive")]</code>.</p> <div class="rule" id="r-items.extern.attributes.link.wasm_import_module"><a class="rule-link" href="#r-items.extern.attributes.link.wasm_import_module">[items.extern.attributes.link.wasm_import_module]</a></div> <p>The <code>wasm_import_module</code> key may be used to specify the <a href="https://webassembly.github.io/spec/core/syntax/modules.html">WebAssembly module</a> name for the items within an <code>extern</code> block when importing symbols from the host environment. The default module name is <code>env</code> if <code>wasm_import_module</code> is not specified.</p>  <pre data-language="rust">#[link(name = "crypto")]
unsafe extern {
    // …
}

#[link(name = "CoreFoundation", kind = "framework")]
unsafe extern {
    // …
}

#[link(wasm_import_module = "foo")]
unsafe extern {
    // …
}</pre> <div class="rule" id="r-items.extern.attributes.link.empty-block"><a class="rule-link" href="#r-items.extern.attributes.link.empty-block">[items.extern.attributes.link.empty-block]</a></div> <p>It is valid to add the <code>link</code> attribute on an empty extern block. You can use this to satisfy the linking requirements of extern blocks elsewhere in your code (including upstream crates) instead of adding the attribute to each extern block.</p> <h4 id="linking-modifiers-bundle">Linking modifiers: <code id="">bundle</code>
</h4> <div class="rule" id="r-items.extern.attributes.link.modifiers.bundle"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.bundle">[items.extern.attributes.link.modifiers.bundle]</a></div> <div class="rule" id="r-items.extern.attributes.link.modifiers.bundle.allowed-kinds"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.bundle.allowed-kinds">[items.extern.attributes.link.modifiers.bundle.allowed-kinds]</a></div> <p>This modifier is only compatible with the <code>static</code> linking kind. Using any other kind will result in a compiler error.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers.bundle.behavior"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.bundle.behavior">[items.extern.attributes.link.modifiers.bundle.behavior]</a></div> <p>When building a rlib or staticlib <code>+bundle</code> means that the native static library will be packed into the rlib or staticlib archive, and then retrieved from there during linking of the final binary.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers.bundle.behavior-negative"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.bundle.behavior-negative">[items.extern.attributes.link.modifiers.bundle.behavior-negative]</a></div> <p>When building a rlib <code>-bundle</code> means that the native static library is registered as a dependency of that rlib “by name”, and object files from it are included only during linking of the final binary, the file search by that name is also performed during final linking. <br> When building a staticlib <code>-bundle</code> means that the native static library is simply not included into the archive and some higher level build system will need to add it later during linking of the final binary.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers.bundle.no-effect"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.bundle.no-effect">[items.extern.attributes.link.modifiers.bundle.no-effect]</a></div> <p>This modifier has no effect when building other targets like executables or dynamic libraries.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers.bundle.default"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.bundle.default">[items.extern.attributes.link.modifiers.bundle.default]</a></div> <p>The default for this modifier is <code>+bundle</code>.</p> <p>More implementation details about this modifier can be found in <a href="https://doc.rust-lang.org/rustc/command-line-arguments.html#linking-modifiers-bundle"><code>bundle</code> documentation for rustc</a>.</p> <h4 id="linking-modifiers-whole-archive">Linking modifiers: <code id="">whole-archive</code>
</h4> <div class="rule" id="r-items.extern.attributes.link.modifiers.whole-archive"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.whole-archive">[items.extern.attributes.link.modifiers.whole-archive]</a></div> <div class="rule" id="r-items.extern.attributes.link.modifiers.whole-archive.allowed-kinds"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.whole-archive.allowed-kinds">[items.extern.attributes.link.modifiers.whole-archive.allowed-kinds]</a></div> <p>This modifier is only compatible with the <code>static</code> linking kind. Using any other kind will result in a compiler error.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers.whole-archive.behavior"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.whole-archive.behavior">[items.extern.attributes.link.modifiers.whole-archive.behavior]</a></div> <p><code>+whole-archive</code> means that the static library is linked as a whole archive without throwing any object files away.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers.whole-archive.default"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.whole-archive.default">[items.extern.attributes.link.modifiers.whole-archive.default]</a></div> <p>The default for this modifier is <code>-whole-archive</code>.</p> <p>More implementation details about this modifier can be found in <a href="https://doc.rust-lang.org/rustc/command-line-arguments.html#linking-modifiers-whole-archive"><code>whole-archive</code> documentation for rustc</a>.</p> <h3 id="linking-modifiers-verbatim">Linking modifiers: <code id="">verbatim</code>
</h3> <div class="rule" id="r-items.extern.attributes.link.modifiers.verbatim"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.verbatim">[items.extern.attributes.link.modifiers.verbatim]</a></div> <div class="rule" id="r-items.extern.attributes.link.modifiers.verbatim.allowed-kinds"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.verbatim.allowed-kinds">[items.extern.attributes.link.modifiers.verbatim.allowed-kinds]</a></div> <p>This modifier is compatible with all linking kinds.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers.verbatim.behavior"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.verbatim.behavior">[items.extern.attributes.link.modifiers.verbatim.behavior]</a></div> <p><code>+verbatim</code> means that rustc itself won’t add any target-specified library prefixes or suffixes (like <code>lib</code> or <code>.a</code>) to the library name, and will try its best to ask for the same thing from the linker.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers.verbatim.behavior-negative"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.verbatim.behavior-negative">[items.extern.attributes.link.modifiers.verbatim.behavior-negative]</a></div> <p><code>-verbatim</code> means that rustc will either add a target-specific prefix and suffix to the library name before passing it to linker, or won’t prevent linker from implicitly adding it.</p> <div class="rule" id="r-items.extern.attributes.link.modifiers.verbatim.default"><a class="rule-link" href="#r-items.extern.attributes.link.modifiers.verbatim.default">[items.extern.attributes.link.modifiers.verbatim.default]</a></div> <p>The default for this modifier is <code>-verbatim</code>.</p> <p>More implementation details about this modifier can be found in <a href="https://doc.rust-lang.org/rustc/command-line-arguments.html#linking-modifiers-verbatim"><code>verbatim</code> documentation for rustc</a>.</p> <h4 id="dylib-versus-raw-dylib">
<code id="">dylib</code> versus <code>raw-dylib</code>
</h4> <div class="rule" id="r-items.extern.attributes.link.kind-raw-dylib"><a class="rule-link" href="#r-items.extern.attributes.link.kind-raw-dylib">[items.extern.attributes.link.kind-raw-dylib]</a></div> <div class="rule" id="r-items.extern.attributes.link.kind-raw-dylib.intro"><a class="rule-link" href="#r-items.extern.attributes.link.kind-raw-dylib.intro">[items.extern.attributes.link.kind-raw-dylib.intro]</a></div> <p>On Windows, linking against a dynamic library requires that an import library is provided to the linker: this is a special static library that declares all of the symbols exported by the dynamic library in such a way that the linker knows that they have to be dynamically loaded at runtime.</p> <div class="rule" id="r-items.extern.attributes.link.kind-raw-dylib.import"><a class="rule-link" href="#r-items.extern.attributes.link.kind-raw-dylib.import">[items.extern.attributes.link.kind-raw-dylib.import]</a></div> <p>Specifying <code>kind = "dylib"</code> instructs the Rust compiler to link an import library based on the <code>name</code> key. The linker will then use its normal library resolution logic to find that import library. Alternatively, specifying <code>kind = "raw-dylib"</code> instructs the compiler to generate an import library during compilation and provide that to the linker instead.</p> <div class="rule" id="r-items.extern.attributes.link.kind-raw-dylib.platform-specific"><a class="rule-link" href="#r-items.extern.attributes.link.kind-raw-dylib.platform-specific">[items.extern.attributes.link.kind-raw-dylib.platform-specific]</a></div> <p><code>raw-dylib</code> is only supported on Windows. Using it when targeting other platforms will result in a compiler error.</p> <h4 id="the-import_name_type-key">The <code id="">import_name_type</code> key</h4> <div class="rule" id="r-items.extern.attributes.link.import_name_type"><a class="rule-link" href="#r-items.extern.attributes.link.import_name_type">[items.extern.attributes.link.import_name_type]</a></div> <div class="rule" id="r-items.extern.attributes.link.import_name_type.intro"><a class="rule-link" href="#r-items.extern.attributes.link.import_name_type.intro">[items.extern.attributes.link.import_name_type.intro]</a></div> <p>On x86 Windows, names of functions are “decorated” (i.e., have a specific prefix and/or suffix added) to indicate their calling convention. For example, a <code>stdcall</code> calling convention function with the name <code>fn1</code> that has no arguments would be decorated as <code>_fn1@0</code>. However, the <a href="https://learn.microsoft.com/windows/win32/debug/pe-format#import-name-type">PE Format</a> does also permit names to have no prefix or be undecorated. Additionally, the MSVC and GNU toolchains use different decorations for the same calling conventions which means, by default, some Win32 functions cannot be called using the <code>raw-dylib</code> link kind via the GNU toolchain.</p> <div class="rule" id="r-items.extern.attributes.link.import_name_type.values"><a class="rule-link" href="#r-items.extern.attributes.link.import_name_type.values">[items.extern.attributes.link.import_name_type.values]</a></div> <p>To allow for these differences, when using the <code>raw-dylib</code> link kind you may also specify the <code>import_name_type</code> key with one of the following values to change how functions are named in the generated import library:</p> <ul> <li>
<code>decorated</code>: The function name will be fully-decorated using the MSVC toolchain format.</li> <li>
<code>noprefix</code>: The function name will be decorated using the MSVC toolchain format, but skipping the leading <code>?</code>, <code>@</code>, or optionally <code>_</code>.</li> <li>
<code>undecorated</code>: The function name will not be decorated.</li> </ul> <div class="rule" id="r-items.extern.attributes.link.import_name_type.default"><a class="rule-link" href="#r-items.extern.attributes.link.import_name_type.default">[items.extern.attributes.link.import_name_type.default]</a></div> <p>If the <code>import_name_type</code> key is not specified, then the function name will be fully-decorated using the target toolchain’s format.</p> <div class="rule" id="r-items.extern.attributes.link.import_name_type.variables"><a class="rule-link" href="#r-items.extern.attributes.link.import_name_type.variables">[items.extern.attributes.link.import_name_type.variables]</a></div> <p>Variables are never decorated and so the <code>import_name_type</code> key has no effect on how they are named in the generated import library.</p> <div class="rule" id="r-items.extern.attributes.link.import_name_type.platform-specific"><a class="rule-link" href="#r-items.extern.attributes.link.import_name_type.platform-specific">[items.extern.attributes.link.import_name_type.platform-specific]</a></div> <p>The <code>import_name_type</code> key is only supported on x86 Windows. Using it when targeting other platforms will result in a compiler error.</p> <h3 id="the-link_name-attribute">The <code id="">link_name</code> attribute</h3> <div class="rule" id="r-items.extern.attributes.link_name"><a class="rule-link" href="#r-items.extern.attributes.link_name">[items.extern.attributes.link_name]</a></div> <div class="rule" id="r-items.extern.attributes.link_name.intro"><a class="rule-link" href="#r-items.extern.attributes.link_name.intro">[items.extern.attributes.link_name.intro]</a></div> <p>The <em><code>link_name</code> attribute</em> may be specified on declarations inside an <code>extern</code> block to indicate the symbol to import for the given function or static.</p> <div class="rule" id="r-items.extern.attributes.link_name.syntax"><a class="rule-link" href="#r-items.extern.attributes.link_name.syntax">[items.extern.attributes.link_name.syntax]</a></div> <p>It uses the <a href="../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> syntax to specify the name of the symbol.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
unsafe extern {
    #[link_name = "actual_symbol_name"]
    safe fn name_in_rust();
}
}</pre> <div class="rule" id="r-items.extern.attributes.link_name.exclusive"><a class="rule-link" href="#r-items.extern.attributes.link_name.exclusive">[items.extern.attributes.link_name.exclusive]</a></div> <p>Using this attribute with the <code>link_ordinal</code> attribute will result in a compiler error.</p> <h3 id="the-link_ordinal-attribute">The <code id="">link_ordinal</code> attribute</h3> <div class="rule" id="r-items.extern.attributes.link_ordinal"><a class="rule-link" href="#r-items.extern.attributes.link_ordinal">[items.extern.attributes.link_ordinal]</a></div> <div class="rule" id="r-items.extern.attributes.link_ordinal.intro"><a class="rule-link" href="#r-items.extern.attributes.link_ordinal.intro">[items.extern.attributes.link_ordinal.intro]</a></div> <p>The <em><code>link_ordinal</code> attribute</em> can be applied on declarations inside an <code>extern</code> block to indicate the numeric ordinal to use when generating the import library to link against. An ordinal is a unique number per symbol exported by a dynamic library on Windows and can be used when the library is being loaded to find that symbol rather than having to look it up by name.</p> <div class="warning"> <blockquote> <p><em><strong>Warning:</strong></em> <code>link_ordinal</code> should only be used in cases where the ordinal of the symbol is known to be stable: if the ordinal of a symbol is not explicitly set when its containing binary is built then one will be automatically assigned to it, and that assigned ordinal may change between builds of the binary.</p> </blockquote> </div> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(all(windows, target_arch = "x86"))]
#[link(name = "exporter", kind = "raw-dylib")]
unsafe extern "stdcall" {
    #[link_ordinal(15)]
    safe fn imported_function_stdcall(i: i32);
}
}</pre> <div class="rule" id="r-items.extern.attributes.link_ordinal.allowed-kinds"><a class="rule-link" href="#r-items.extern.attributes.link_ordinal.allowed-kinds">[items.extern.attributes.link_ordinal.allowed-kinds]</a></div> <p>This attribute is only used with the <code>raw-dylib</code> linking kind. Using any other kind will result in a compiler error.</p> <div class="rule" id="r-items.extern.attributes.link_ordinal.exclusive"><a class="rule-link" href="#r-items.extern.attributes.link_ordinal.exclusive">[items.extern.attributes.link_ordinal.exclusive]</a></div> <p>Using this attribute with the <code>link_name</code> attribute will result in a compiler error.</p> <h3 id="attributes-on-function-parameters">Attributes on function parameters</h3> <div class="rule" id="r-items.extern.attributes.fn-parameters"><a class="rule-link" href="#r-items.extern.attributes.fn-parameters">[items.extern.attributes.fn-parameters]</a></div> <p>Attributes on extern function parameters follow the same rules and restrictions as <a href="functions.html#attributes-on-function-parameters">regular function parameters</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/items/external-blocks.html" class="_attribution-link">https://doc.rust-lang.org/reference/items/external-blocks.html</a>
  </p>
</div>
