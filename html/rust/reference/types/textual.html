<h1 id="textual-types">Textual types</h1> <div class="rule" id="r-type.text"><a class="rule-link" href="#r-type.text">[type.text]</a></div> <div class="rule" id="r-type.text.intro"><a class="rule-link" href="#r-type.text.intro">[type.text.intro]</a></div> <p>The types <code>char</code> and <code>str</code> hold textual data.</p> <div class="rule" id="r-type.text.char-value"><a class="rule-link" href="#r-type.text.char-value">[type.text.char-value]</a></div> <p>A value of type <code>char</code> is a <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a> (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range.</p> <div class="rule" id="r-type.text.char-precondition"><a class="rule-link" href="#r-type.text.char-precondition">[type.text.char-precondition]</a></div> <p>It is immediate <a href="../behavior-considered-undefined.html">undefined behavior</a> to create a <code>char</code> that falls outside this range. A <code>[char]</code> is effectively a UCS-4 / UTF-32 string of length 1.</p> <div class="rule" id="r-type.text.str-value"><a class="rule-link" href="#r-type.text.str-value">[type.text.str-value]</a></div> <p>A value of type <code>str</code> is represented the same way as <code>[u8]</code>, a slice of 8-bit unsigned bytes. However, the Rust standard library makes extra assumptions about <code>str</code>: methods working on <code>str</code> assume and ensure that the data in there is valid UTF-8. Calling a <code>str</code> method with a non-UTF-8 buffer can cause <a href="../behavior-considered-undefined.html">undefined behavior</a> now or in the future.</p> <div class="rule" id="r-type.text.str-unsized"><a class="rule-link" href="#r-type.text.str-unsized">[type.text.str-unsized]</a></div> <p>Since <code>str</code> is a <a href="../dynamically-sized-types.html">dynamically sized type</a>, it can only be instantiated through a pointer type, such as <code>&amp;str</code>.</p> <h2 id="layout-and-bit-validity">Layout and bit validity</h2> <div class="rule" id="r-type.text.layout"><a class="rule-link" href="#r-type.text.layout">[type.text.layout]</a></div> <div class="rule" id="r-type.layout.char-layout"><a class="rule-link" href="#r-type.layout.char-layout">[type.layout.char-layout]</a></div> <p><code>char</code> is guaranteed to have the same size and alignment as <code>u32</code> on all platforms.</p> <div class="rule" id="r-type.layout.char-validity"><a class="rule-link" href="#r-type.layout.char-validity">[type.layout.char-validity]</a></div> <p>Every byte of a <code>char</code> is guaranteed to be initialized (in other words, <code>transmute::&lt;char, [u8; size_of::&lt;char&gt;()]&gt;(...)</code> is always sound â€“ but since some bit patterns are invalid <code>char</code>s, the inverse is not always sound).</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/types/textual.html" class="_attribution-link">https://doc.rust-lang.org/reference/types/textual.html</a>
  </p>
</div>
