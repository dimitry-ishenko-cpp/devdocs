<h1 id="boolean-type">Boolean type</h1> <pre data-language="rust">#![allow(unused)]
fn main() {
let b: bool = true;
}</pre> <p>The <em>boolean type</em> or <em>bool</em> is a primitive data type that can take on one of two values, called <em>true</em> and <em>false</em>.</p> <p>Values of this type may be created using a <a href="../expressions/literal-expr.html">literal expression</a> using the keywords <code>true</code> and <code>false</code> corresponding to the value of the same name.</p> <p>This type is a part of the <a href="../names/preludes.html#language-prelude">language prelude</a> with the <a href="../names.html">name</a> <code>bool</code>.</p> <p>An object with the boolean type has a <a href="../type-layout.html#size-and-alignment">size and alignment</a> of 1 each. The value false has the bit pattern <code>0x00</code> and the value true has the bit pattern <code>0x01</code>. It is <a href="../behavior-considered-undefined.html">undefined behavior</a> for an object with the boolean type to have any other bit pattern.</p> <p>The boolean type is the type of many operands in various <a href="../expressions.html">expressions</a>:</p> <ul> <li>The condition operand in <a href="../expressions/if-expr.html#if-expressions">if expressions</a> and <a href="../expressions/loop-expr.html#predicate-loops">while expressions</a>
</li> <li>The operands in <a href="../expressions/operator-expr.html#lazy-boolean-operators">lazy boolean operator expressions</a>
</li> </ul> <blockquote> <p><strong>Note</strong>: The boolean type acts similarly to but is not an <a href="enum.html">enumerated type</a>. In practice, this mostly means that constructors are not associated to the type (e.g. <code>bool::true</code>).</p> </blockquote> <p>Like all primitives, the boolean type <a href="../items/implementations.html">implements</a> the <a href="../items/traits.html">traits</a> <a href="../special-types-and-traits.html#clone"><code>Clone</code></a>, <a href="../special-types-and-traits.html#copy"><code>Copy</code></a>, <a href="../special-types-and-traits.html#sized"><code>Sized</code></a>, <a href="../special-types-and-traits.html#send"><code>Send</code></a>, and <a href="../special-types-and-traits.html#sync"><code>Sync</code></a>.</p> <blockquote> <p><strong>Note</strong>: See the <a href="../../std/primitive.bool.html">standard library docs</a> for library operations.</p> </blockquote> <h2 id="operations-on-boolean-values">Operations on boolean values</h2>  When using certain operator expressions with a <p>boolean type for its operands, they evaluate using the rules of <a href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean logic</a>.</p> <h3 id="logical-not">Logical not</h3> <div class="table-wrapper">
<table>
<thead><tr>
<th><code>b</code></th>
<th><a href="../expressions/operator-expr.html#negation-operators"><code>!b</code></a></th>
</tr></thead>
<tbody> <tr>
<td><code>true</code></td>
<td><code>false</code></td>
</tr> <tr>
<td><code>false</code></td>
<td><code>true</code></td>
</tr> </tbody>
</table> </div> <h3 id="logical-or">Logical or</h3> <div class="table-wrapper">
<table>
<thead><tr>
<th><code>a</code></th>
<th><code>b</code></th>
<th><a href="../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a | b</code></a></th>
</tr></thead>
<tbody> <tr>
<td><code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
</tr> <tr>
<td><code>true</code></td>
<td><code>false</code></td>
<td><code>true</code></td>
</tr> <tr>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
</tr> <tr>
<td><code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
</tr> </tbody>
</table> </div> <h3 id="logical-and">Logical and</h3> <div class="table-wrapper">
<table>
<thead><tr>
<th><code>a</code></th>
<th><code>b</code></th>
<th><a href="../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a &amp; b</code></a></th>
</tr></thead>
<tbody> <tr>
<td><code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
</tr> <tr>
<td><code>true</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
</tr> <tr>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
</tr> <tr>
<td><code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
</tr> </tbody>
</table> </div> <h3 id="logical-xor">Logical xor</h3> <div class="table-wrapper">
<table>
<thead><tr>
<th><code>a</code></th>
<th><code>b</code></th>
<th><a href="../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a ^ b</code></a></th>
</tr></thead>
<tbody> <tr>
<td><code>true</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
</tr> <tr>
<td><code>true</code></td>
<td><code>false</code></td>
<td><code>true</code></td>
</tr> <tr>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
</tr> <tr>
<td><code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
</tr> </tbody>
</table> </div> <h3 id="comparisons">Comparisons</h3> <div class="table-wrapper">
<table>
<thead><tr>
<th><code>a</code></th>
<th><code>b</code></th>
<th><a href="../expressions/operator-expr.html#comparison-operators"><code>a == b</code></a></th>
</tr></thead>
<tbody> <tr>
<td><code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
</tr> <tr>
<td><code>true</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
</tr> <tr>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
</tr> <tr>
<td><code>false</code></td>
<td><code>false</code></td>
<td><code>true</code></td>
</tr> </tbody>
</table> </div>
<div class="table-wrapper">
<table>
<thead><tr>
<th><code>a</code></th>
<th><code>b</code></th>
<th><a href="../expressions/operator-expr.html#comparison-operators"><code>a &gt; b</code></a></th>
</tr></thead>
<tbody> <tr>
<td><code>true</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
</tr> <tr>
<td><code>true</code></td>
<td><code>false</code></td>
<td><code>true</code></td>
</tr> <tr>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
</tr> <tr>
<td><code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
</tr> </tbody>
</table> </div> <ul> <li>
<code>a != b</code> is the same as <code>!(a == b)</code>
</li> <li>
<code>a &gt;= b</code> is the same as <code>a == b | a &gt; b</code>
</li> <li>
<code>a &lt; b</code> is the same as <code>!(a &gt;= b)</code>
</li> <li>
<code>a &lt;= b</code> is the same as <code>a == b | a &lt; b</code>
</li> </ul> <h2 id="bit-validity">Bit validity</h2> <p>The single byte of a <code>bool</code> is guaranteed to be initialized (in other words, <code>transmute::&lt;bool, u8&gt;(...)</code> is always sound -- but since some bit patterns are invalid <code>bool</code>s, the inverse is not always sound).</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/types/boolean.html" class="_attribution-link">https://doc.rust-lang.org/reference/types/boolean.html</a>
  </p>
</div>
