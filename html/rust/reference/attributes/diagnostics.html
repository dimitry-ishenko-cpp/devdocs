<h1 id="diagnostic-attributes">Diagnostic attributes</h1> <div class="rule" id="r-attributes.diagnostics"><a class="rule-link" href="#r-attributes.diagnostics">[attributes.diagnostics]</a></div> <p>The following <a href="../attributes.html">attributes</a> are used for controlling or generating diagnostic messages during compilation.</p> <h2 id="lint-check-attributes">Lint check attributes</h2> <div class="rule" id="r-attributes.diagnostics.lint"><a class="rule-link" href="#r-attributes.diagnostics.lint">[attributes.diagnostics.lint]</a></div> <p>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation.</p> <div class="rule" id="r-attributes.diagnostics.lint.level"><a class="rule-link" href="#r-attributes.diagnostics.lint.level">[attributes.diagnostics.lint.level]</a></div> <p>The lint attributes <code>allow</code>, <code>expect</code>, <code>warn</code>, <code>deny</code>, and <code>forbid</code> use the <a href="../attributes.html#meta-item-attribute-syntax"><em>MetaListPaths</em></a> syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</p> <p>For any lint check <code>C</code>:</p> <div class="rule" id="r-attributes.diagnostics.lint.allow"><a class="rule-link" href="#r-attributes.diagnostics.lint.allow">[attributes.diagnostics.lint.allow]</a></div> <ul> <li>
<code>#[allow(C)]</code> overrides the check for <code>C</code> so that violations will go unreported.</li> </ul> <div class="rule" id="r-attributes.diagnostics.lint.expect"><a class="rule-link" href="#r-attributes.diagnostics.lint.expect">[attributes.diagnostics.lint.expect]</a></div> <ul> <li>
<code>#[expect(C)]</code> indicates that lint <code>C</code> is expected to be emitted. The attribute will suppress the emission of <code>C</code> or issue a warning, if the expectation is unfulfilled.</li> </ul> <div class="rule" id="r-attributes.diagnostics.lint.warn"><a class="rule-link" href="#r-attributes.diagnostics.lint.warn">[attributes.diagnostics.lint.warn]</a></div> <ul> <li>
<code>#[warn(C)]</code> warns about violations of <code>C</code> but continues compilation.</li> </ul> <div class="rule" id="r-attributes.diagnostics.lint.deny"><a class="rule-link" href="#r-attributes.diagnostics.lint.deny">[attributes.diagnostics.lint.deny]</a></div> <ul> <li>
<code>#[deny(C)]</code> signals an error after encountering a violation of <code>C</code>,</li> </ul> <div class="rule" id="r-attributes.diagnostics.lint.forbid"><a class="rule-link" href="#r-attributes.diagnostics.lint.forbid">[attributes.diagnostics.lint.forbid]</a></div> <ul> <li>
<code>#[forbid(C)]</code> is the same as <code>deny(C)</code>, but also forbids changing the lint level afterwards,</li> </ul> <blockquote> <p>Note: The lint checks supported by <code>rustc</code> can be found via <code>rustc -W help</code>, along with their default settings and are documented in the <a href="https://doc.rust-lang.org/rustc/lints/index.html">rustc book</a>.</p> </blockquote> <pre data-language="rust">#![allow(unused)]
fn main() {
pub mod m1 {
    // Missing documentation is ignored here
    #[allow(missing_docs)]
    pub fn undocumented_one() -&gt; i32 { 1 }

    // Missing documentation signals a warning here
    #[warn(missing_docs)]
    pub fn undocumented_too() -&gt; i32 { 2 }

    // Missing documentation signals an error here
    #[deny(missing_docs)]
    pub fn undocumented_end() -&gt; i32 { 3 }
}
}</pre> <div class="rule" id="r-attributes.diagnostics.lint.override"><a class="rule-link" href="#r-attributes.diagnostics.lint.override">[attributes.diagnostics.lint.override]</a></div> <p>Lint attributes can override the level specified from a previous attribute, as long as the level does not attempt to change a forbidden lint (except for <code>deny</code>, which is allowed inside a <code>forbid</code> context, but ignored). Previous attributes are those from a higher level in the syntax tree, or from a previous attribute on the same entity as listed in left-to-right source order.</p> <p>This example shows how one can use <code>allow</code> and <code>warn</code> to toggle a particular check on and off:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[warn(missing_docs)]
pub mod m2 {
    #[allow(missing_docs)]
    pub mod nested {
        // Missing documentation is ignored here
        pub fn undocumented_one() -&gt; i32 { 1 }

        // Missing documentation signals a warning here,
        // despite the allow above.
        #[warn(missing_docs)]
        pub fn undocumented_two() -&gt; i32 { 2 }
    }

    // Missing documentation signals a warning here
    pub fn undocumented_too() -&gt; i32 { 3 }
}
}</pre> <p>This example shows how one can use <code>forbid</code> to disallow uses of <code>allow</code> or <code>expect</code> for that lint check:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[forbid(missing_docs)]
pub mod m3 {
    // Attempting to toggle warning signals an error here
    #[allow(missing_docs)]
    /// Returns 2.
    pub fn undocumented_too() -&gt; i32 { 2 }
}
}</pre> <blockquote> <p>Note: <code>rustc</code> allows setting lint levels on the <a href="https://doc.rust-lang.org/rustc/lints/levels.html#via-compiler-flag">command-line</a>, and also supports <a href="https://doc.rust-lang.org/rustc/lints/levels.html#capping-lints">setting caps</a> on the lints that are reported.</p> </blockquote> <h3 id="lint-reasons">Lint Reasons</h3> <div class="rule" id="r-attributes.diagnostics.lint.reason"><a class="rule-link" href="#r-attributes.diagnostics.lint.reason">[attributes.diagnostics.lint.reason]</a></div> <p>All lint attributes support an additional <code>reason</code> parameter, to give context why a certain attribute was added. This reason will be displayed as part of the lint message if the lint is emitted at the defined level.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// `keyword_idents` is allowed by default. Here we deny it to
// avoid migration of identifiers when we update the edition.
#![deny(
    keyword_idents,
    reason = "we want to avoid these idents to be future compatible"
)]

// This name was allowed in Rust's 2015 edition. We still aim to avoid
// this to be future compatible and not confuse end users.
fn dyn() {}
}</pre> <p>Here is another example, where the lint is allowed with a reason:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::path::PathBuf;

pub fn get_path() -&gt; PathBuf {
    // The `reason` parameter on `allow` attributes acts as documentation for the reader.
    #[allow(unused_mut, reason = "this is only modified on some platforms")]
    let mut file_name = PathBuf::from("git");

    #[cfg(target_os = "windows")]
    file_name.set_extension("exe");

    file_name
}
}</pre> <h3 id="the-expect-attribute">The <code id="">#[expect]</code> attribute</h3> <div class="rule" id="r-attributes.diagnostics.expect"><a class="rule-link" href="#r-attributes.diagnostics.expect">[attributes.diagnostics.expect]</a></div> <div class="rule" id="r-attributes.diagnostics.expect.intro"><a class="rule-link" href="#r-attributes.diagnostics.expect.intro">[attributes.diagnostics.expect.intro]</a></div> <p>The <code>#[expect(C)]</code> attribute creates a lint expectation for lint <code>C</code>. The expectation will be fulfilled, if a <code>#[warn(C)]</code> attribute at the same location would result in a lint emission. If the expectation is unfulfilled, because lint <code>C</code> would not be emitted, the <code>unfulfilled_lint_expectations</code> lint will be emitted at the attribute.</p> <pre data-language="rust">fn main() {
    // This `#[expect]` attribute creates a lint expectation, that the `unused_variables`
    // lint would be emitted by the following statement. This expectation is
    // unfulfilled, since the `question` variable is used by the `println!` macro.
    // Therefore, the `unfulfilled_lint_expectations` lint will be emitted at the
    // attribute.
    #[expect(unused_variables)]
    let question = "who lives in a pineapple under the sea?";
    println!("{question}");

    // This `#[expect]` attribute creates a lint expectation that will be fulfilled, since
    // the `answer` variable is never used. The `unused_variables` lint, that would usually
    // be emitted, is suppressed. No warning will be issued for the statement or attribute.
    #[expect(unused_variables)]
    let answer = "SpongeBob SquarePants!";
}</pre> <div class="rule" id="r-attributes.diagnostics.expect.fulfillment"><a class="rule-link" href="#r-attributes.diagnostics.expect.fulfillment">[attributes.diagnostics.expect.fulfillment]</a></div> <p>The lint expectation is only fulfilled by lint emissions which have been suppressed by the <code>expect</code> attribute. If the lint level is modified in the scope with other level attributes like <code>allow</code> or <code>warn</code>, the lint emission will be handled accordingly and the expectation will remain unfulfilled.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[expect(unused_variables)]
fn select_song() {
    // This will emit the `unused_variables` lint at the warn level
    // as defined by the `warn` attribute. This will not fulfill the
    // expectation above the function.
    #[warn(unused_variables)]
    let song_name = "Crab Rave";

    // The `allow` attribute suppresses the lint emission. This will not
    // fulfill the expectation as it has been suppressed by the `allow`
    // attribute and not the `expect` attribute above the function.
    #[allow(unused_variables)]
    let song_creator = "Noisestorm";

    // This `expect` attribute will suppress the `unused_variables` lint emission
    // at the variable. The `expect` attribute above the function will still not
    // be fulfilled, since this lint emission has been suppressed by the local
    // expect attribute.
    #[expect(unused_variables)]
    let song_version = "Monstercat Release";
}
}</pre> <div class="rule" id="r-attributes.diagnostics.expect.independent"><a class="rule-link" href="#r-attributes.diagnostics.expect.independent">[attributes.diagnostics.expect.independent]</a></div> <p>If the <code>expect</code> attribute contains several lints, each one is expected separately. For a lint group it’s enough if one lint inside the group has been emitted:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// This expectation will be fulfilled by the unused value inside the function
// since the emitted `unused_variables` lint is inside the `unused` lint group.
#[expect(unused)]
pub fn thoughts() {
    let unused = "I'm running out of examples";
}

pub fn another_example() {
    // This attribute creates two lint expectations. The `unused_mut` lint will be
    // suppressed and with that fulfill the first expectation. The `unused_variables`
    // wouldn't be emitted, since the variable is used. That expectation will therefore
    // be unsatisfied, and a warning will be emitted.
    #[expect(unused_mut, unused_variables)]
    let mut link = "https://www.rust-lang.org/";

    println!("Welcome to our community: {link}");
}
}</pre> <blockquote> <p>Note: The behavior of <code>#[expect(unfulfilled_lint_expectations)]</code> is currently defined to always generate the <code>unfulfilled_lint_expectations</code> lint.</p> </blockquote> <h3 id="lint-groups">Lint groups</h3> <div class="rule" id="r-attributes.diagnostics.lint.group"><a class="rule-link" href="#r-attributes.diagnostics.lint.group">[attributes.diagnostics.lint.group]</a></div> <p>Lints may be organized into named groups so that the level of related lints can be adjusted together. Using a named group is equivalent to listing out the lints within that group.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// This allows all lints in the "unused" group.
#[allow(unused)]
// This overrides the "unused_must_use" lint from the "unused"
// group to deny.
#[deny(unused_must_use)]
fn example() {
    // This does not generate a warning because the "unused_variables"
    // lint is in the "unused" group.
    let x = 1;
    // This generates an error because the result is unused and
    // "unused_must_use" is marked as "deny".
    std::fs::remove_file("some_file"); // ERROR: unused `Result` that must be used
}
}</pre> <div class="rule" id="r-attributes.diagnostics.lint.group.warnings"><a class="rule-link" href="#r-attributes.diagnostics.lint.group.warnings">[attributes.diagnostics.lint.group.warnings]</a></div> <p>There is a special group named “warnings” which includes all lints at the “warn” level. The “warnings” group ignores attribute order and applies to all lints that would otherwise warn within the entity.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
unsafe fn an_unsafe_fn() {}
// The order of these two attributes does not matter.
#[deny(warnings)]
// The unsafe_code lint is normally "allow" by default.
#[warn(unsafe_code)]
fn example_err() {
    // This is an error because the `unsafe_code` warning has
    // been lifted to "deny".
    unsafe { an_unsafe_fn() } // ERROR: usage of `unsafe` block
}
}</pre> <h3 id="tool-lint-attributes">Tool lint attributes</h3> <div class="rule" id="r-attributes.diagnostics.lint.tool"><a class="rule-link" href="#r-attributes.diagnostics.lint.tool">[attributes.diagnostics.lint.tool]</a></div> <div class="rule" id="r-attributes.diagnostics.lint.tool.intro"><a class="rule-link" href="#r-attributes.diagnostics.lint.tool.intro">[attributes.diagnostics.lint.tool.intro]</a></div> <p>Tool lints allows using scoped lints, to <code>allow</code>, <code>warn</code>, <code>deny</code> or <code>forbid</code> lints of certain tools.</p> <div class="rule" id="r-attributes.diagnostics.lint.tool.activation"><a class="rule-link" href="#r-attributes.diagnostics.lint.tool.activation">[attributes.diagnostics.lint.tool.activation]</a></div> <p>Tool lints only get checked when the associated tool is active. If a lint attribute, such as <code>allow</code>, references a nonexistent tool lint, the compiler will not warn about the nonexistent lint until you use the tool.</p> <p>Otherwise, they work just like regular lint attributes:</p> <pre data-language="rust">// set the entire `pedantic` clippy lint group to warn
#![warn(clippy::pedantic)]
// silence warnings from the `filter_map` clippy lint
#![allow(clippy::filter_map)]

fn main() {
    // ...
}

// silence the `cmp_nan` clippy lint just for this function
#[allow(clippy::cmp_nan)]
fn foo() {
    // ...
}</pre> <blockquote> <p>Note: <code>rustc</code> currently recognizes the tool lints for “<a href="https://github.com/rust-lang/rust-clippy">clippy</a>” and “<a href="https://doc.rust-lang.org/rustdoc/lints.html">rustdoc</a>”.</p> </blockquote> <h2 id="the-deprecated-attribute">The <code id="">deprecated</code> attribute</h2> <div class="rule" id="r-attributes.diagnostics.deprecated"><a class="rule-link" href="#r-attributes.diagnostics.deprecated">[attributes.diagnostics.deprecated]</a></div> <div class="rule" id="r-attributes.diagnostics.deprecated.intro"><a class="rule-link" href="#r-attributes.diagnostics.deprecated.intro">[attributes.diagnostics.deprecated.intro]</a></div> <p>The <em><code>deprecated</code> attribute</em> marks an item as deprecated. <code>rustc</code> will issue warnings on usage of <code>#[deprecated]</code> items. <code>rustdoc</code> will show item deprecation, including the <code>since</code> version and <code>note</code>, if available.</p> <div class="rule" id="r-attributes.diagnostics.deprecated.syntax"><a class="rule-link" href="#r-attributes.diagnostics.deprecated.syntax">[attributes.diagnostics.deprecated.syntax]</a></div> <p>The <code>deprecated</code> attribute has several forms:</p> <ul> <li>
<code>deprecated</code> — Issues a generic message.</li> <li>
<code>deprecated = "message"</code> — Includes the given string in the deprecation message.</li> <li>
<a href="../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> syntax with two optional fields: <ul> <li>
<code>since</code> — Specifies a version number when the item was deprecated. <code>rustc</code> does not currently interpret the string, but external tools like <a href="https://github.com/rust-lang/rust-clippy">Clippy</a> may check the validity of the value.</li> <li>
<code>note</code> — Specifies a string that should be included in the deprecation message. This is typically used to provide an explanation about the deprecation and preferred alternatives.</li> </ul> </li> </ul> <div class="rule" id="r-attributes.diagnostic.deprecated.allowed-positions"><a class="rule-link" href="#r-attributes.diagnostic.deprecated.allowed-positions">[attributes.diagnostic.deprecated.allowed-positions]</a></div> <p>The <code>deprecated</code> attribute may be applied to any <a href="../items.html">item</a>, <a href="../items/traits.html">trait item</a>, <a href="../items/enumerations.html">enum variant</a>, <a href="../items/structs.html">struct field</a>, <a href="../items/external-blocks.html">external block item</a>, or <a href="../macros-by-example.html">macro definition</a>. It cannot be applied to <a href="../items/implementations.html#trait-implementations">trait implementation items</a>. When applied to an item containing other items, such as a <a href="../items/modules.html">module</a> or <a href="../items/implementations.html">implementation</a>, all child items inherit the deprecation attribute.</p>  <p>Here is an example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[deprecated(since = "5.2.0", note = "foo was rarely used. Users should instead use bar")]
pub fn foo() {}

pub fn bar() {}
}</pre> <p>The <a href="https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md">RFC</a> contains motivations and more details.</p> <h2 id="the-must_use-attribute">The <code id="">must_use</code> attribute</h2> <div class="rule" id="r-attributes.diagnostics.must_use"><a class="rule-link" href="#r-attributes.diagnostics.must_use">[attributes.diagnostics.must_use]</a></div> <div class="rule" id="r-attributes.diagnostics.must_use.intro"><a class="rule-link" href="#r-attributes.diagnostics.must_use.intro">[attributes.diagnostics.must_use.intro]</a></div> <p>The <em><code>must_use</code> attribute</em> is used to issue a diagnostic warning when a value is not “used”.</p> <div class="rule" id="r-attributes.diagnostics.must_use.allowed-positions"><a class="rule-link" href="#r-attributes.diagnostics.must_use.allowed-positions">[attributes.diagnostics.must_use.allowed-positions]</a></div> <p>The <code>must_use</code> attribute can be applied to user-defined composite types (<a href="../items/structs.html"><code>struct</code>s</a>, <a href="../items/enumerations.html"><code>enum</code>s</a>, and <a href="../items/unions.html"><code>union</code>s</a>), <a href="../items/functions.html">functions</a>, and <a href="../items/traits.html">traits</a>.</p> <div class="rule" id="r-attributes.diagnostics.must_use.message"><a class="rule-link" href="#r-attributes.diagnostics.must_use.message">[attributes.diagnostics.must_use.message]</a></div> <p>The <code>must_use</code> attribute may include a message by using the <a href="../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> syntax such as <code>#[must_use = "example message"]</code>. The message will be given alongside the warning.</p> <div class="rule" id="r-attributes.diagnostics.must_use.type"><a class="rule-link" href="#r-attributes.diagnostics.must_use.type">[attributes.diagnostics.must_use.type]</a></div> <p>When used on user-defined composite types, if the <a href="../expressions.html">expression</a> of an <a href="../statements.html#expression-statements">expression statement</a> has that type, then the <code>unused_must_use</code> lint is violated.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[must_use]
struct MustUse {
    // some fields
}

impl MustUse {
  fn new() -&gt; MustUse { MustUse {} }
}

// Violates the `unused_must_use` lint.
MustUse::new();
}</pre> <div class="rule" id="r-attributes.diagnostics.must_use.fn"><a class="rule-link" href="#r-attributes.diagnostics.must_use.fn">[attributes.diagnostics.must_use.fn]</a></div> <p>When used on a function, if the <a href="../expressions.html">expression</a> of an <a href="../statements.html#expression-statements">expression statement</a> is a <a href="../expressions/call-expr.html">call expression</a> to that function, then the <code>unused_must_use</code> lint is violated.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[must_use]
fn five() -&gt; i32 { 5i32 }

// Violates the unused_must_use lint.
five();
}</pre> <div class="rule" id="r-attributes.diagnostics.must_use.trait"><a class="rule-link" href="#r-attributes.diagnostics.must_use.trait">[attributes.diagnostics.must_use.trait]</a></div> <p>When used on a <a href="../items/traits.html">trait declaration</a>, a <a href="../expressions/call-expr.html">call expression</a> of an <a href="../statements.html#expression-statements">expression statement</a> to a function that returns an <a href="../types/impl-trait.html">impl trait</a> or a <a href="../types/trait-object.html">dyn trait</a> of that trait violates the <code>unused_must_use</code> lint.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[must_use]
trait Critical {}
impl Critical for i32 {}

fn get_critical() -&gt; impl Critical {
    4i32
}

// Violates the `unused_must_use` lint.
get_critical();
}</pre> <div class="rule" id="r-attributes.diagnostics.must_use.trait-function"><a class="rule-link" href="#r-attributes.diagnostics.must_use.trait-function">[attributes.diagnostics.must_use.trait-function]</a></div> <p>When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Trait {
    #[must_use]
    fn use_me(&amp;self) -&gt; i32;
}

impl Trait for i32 {
    fn use_me(&amp;self) -&gt; i32 { 0i32 }
}

// Violates the `unused_must_use` lint.
5i32.use_me();
}</pre> <div class="rule" id="r-attributes.diagnostics.must_use.trait-impl-function"><a class="rule-link" href="#r-attributes.diagnostics.must_use.trait-impl-function">[attributes.diagnostics.must_use.trait-impl-function]</a></div> <p>When used on a function in a trait implementation, the attribute does nothing.</p> <blockquote> <p>Note: Trivial no-op expressions containing the value will not violate the lint. Examples include wrapping the value in a type that does not implement <a href="../special-types-and-traits.html#drop"><code>Drop</code></a> and then not using that type and being the final expression of a <a href="../expressions/block-expr.html">block expression</a> that is not used.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[must_use]
fn five() -&gt; i32 { 5i32 }

// None of these violate the unused_must_use lint.
(five(),);
Some(five());
{ five() };
if true { five() } else { 0i32 };
match true {
    _ =&gt; five()
};
}</pre> </blockquote> <blockquote> <p>Note: It is idiomatic to use a <a href="../statements.html#let-statements">let statement</a> with a pattern of <code>_</code> when a must-used value is purposely discarded.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[must_use]
fn five() -&gt; i32 { 5i32 }

// Does not violate the unused_must_use lint.
let _ = five();
}</pre> </blockquote> <h2 id="the-diagnostic-tool-attribute-namespace">The <code id="">diagnostic</code> tool attribute namespace</h2> <div class="rule" id="r-attributes.diagnostic.namespace"><a class="rule-link" href="#r-attributes.diagnostic.namespace">[attributes.diagnostic.namespace]</a></div> <div class="rule" id="r-attributes.diagnostic.namespace.intro"><a class="rule-link" href="#r-attributes.diagnostic.namespace.intro">[attributes.diagnostic.namespace.intro]</a></div> <p>The <code>#[diagnostic]</code> attribute namespace is a home for attributes to influence compile-time error messages. The hints provided by these attributes are not guaranteed to be used.</p> <div class="rule" id="r-attributes.diagnostic.namespace.unknown-invalid-syntax">
<a class="rule-link" href="#r-attributes.diagnostic.namespace.unknown-invalid-syntax">[attributes.diagnostic.namespace.unknown-invalid-syntax]</a><span class="popup-container"> <a href="javascript:void(0).html" onclick="spec_toggle_tests('attributes.diagnostic.namespace.unknown-invalid-syntax');">Tests</a> <div id="tests-attributes.diagnostic.namespace.unknown-invalid-syntax" class="tests-popup popup-hidden"> Tests with this rule: <ul>
<li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/deny_malformed_attribute.rs">tests/ui/diagnostic_namespace/deny_malformed_attribute.rs</a></li> <li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/non_existing_attributes_accepted.rs">tests/ui/diagnostic_namespace/non_existing_attributes_accepted.rs</a></li> <li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/suggest_typos.rs">tests/ui/diagnostic_namespace/suggest_typos.rs</a></li> </ul>
</div></span>
</div> <p>Unknown attributes in this namespace are accepted, though they may emit warnings for unused attributes. Additionally, invalid inputs to known attributes will typically be a warning (see the attribute definitions for details). This is meant to allow adding or discarding attributes and changing inputs in the future to allow changes without the need to keep the non-meaningful attributes or options working.</p> <h3 id="the-diagnosticon_unimplemented-attribute">The <code id="">diagnostic::on_unimplemented</code> attribute</h3> <div class="rule" id="r-attributes.diagnostic.on_unimplemented"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented">[attributes.diagnostic.on_unimplemented]</a></div> <div class="rule" id="r-attributes.diagnostic.on_unimplemented.intro">
<a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.intro">[attributes.diagnostic.on_unimplemented.intro]</a><span class="popup-container"> <a href="javascript:void(0).html" onclick="spec_toggle_tests('attributes.diagnostic.on_unimplemented.intro');">Tests</a> <div id="tests-attributes.diagnostic.on_unimplemented.intro" class="tests-popup popup-hidden"> Tests with this rule: <ul>
<li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/custom-on-unimplemented-diagnostic.rs">tests/ui/diagnostic_namespace/on_unimplemented/custom-on-unimplemented-diagnostic.rs</a></li> <li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/error_is_shown_in_downstream_crates.rs">tests/ui/diagnostic_namespace/on_unimplemented/error_is_shown_in_downstream_crates.rs</a></li> <li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/on_unimplemented_simple.rs">tests/ui/diagnostic_namespace/on_unimplemented/on_unimplemented_simple.rs</a></li> <li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/traits/negative-bounds/on-unimplemented.rs">tests/ui/traits/negative-bounds/on-unimplemented.rs</a></li> </ul>
</div></span>
</div> <p>The <code>#[diagnostic::on_unimplemented]</code> attribute is a hint to the compiler to supplement the error message that would normally be generated in scenarios where a trait is required but not implemented on a type.</p> <div class="rule" id="r-attributes.diagnostic.on_unimplemented.allowed-positions"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.allowed-positions">[attributes.diagnostic.on_unimplemented.allowed-positions]</a></div> <p>The attribute should be placed on a <a href="../items/traits.html">trait declaration</a>, though it is not an error to be located in other positions.</p> <div class="rule" id="r-attributes.diagnostic.on_unimplemented.syntax">
<a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.syntax">[attributes.diagnostic.on_unimplemented.syntax]</a><span class="popup-container"> <a href="javascript:void(0).html" onclick="spec_toggle_tests('attributes.diagnostic.on_unimplemented.syntax');">Tests</a> <div id="tests-attributes.diagnostic.on_unimplemented.syntax" class="tests-popup popup-hidden"> Tests with this rule: <ul>
<li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/malformed_foreign_on_unimplemented.rs">tests/ui/diagnostic_namespace/malformed_foreign_on_unimplemented.rs</a></li> <li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs">tests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs</a></li> <li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/do_not_fail_parsing_on_invalid_options_1.rs">tests/ui/diagnostic_namespace/on_unimplemented/do_not_fail_parsing_on_invalid_options_1.rs</a></li> <li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/ignore_unsupported_options_and_continue_to_use_fallback.rs">tests/ui/diagnostic_namespace/on_unimplemented/ignore_unsupported_options_and_continue_to_use_fallback.rs</a></li> </ul>
</div></span>
</div> <p>The attribute uses the <a href="../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> syntax to specify its inputs, though any malformed input to the attribute is not considered as an error to provide both forwards and backwards compatibility.</p> <div class="rule" id="r-attributes.diagnostic.on_unimplemented.keys">
<a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.keys">[attributes.diagnostic.on_unimplemented.keys]</a><span class="popup-container"> <a href="javascript:void(0).html" onclick="spec_toggle_tests('attributes.diagnostic.on_unimplemented.keys');">Tests</a> <div id="tests-attributes.diagnostic.on_unimplemented.keys" class="tests-popup popup-hidden"> Tests with this rule: <ul>
<li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/custom-on-unimplemented-diagnostic.rs">tests/ui/diagnostic_namespace/on_unimplemented/custom-on-unimplemented-diagnostic.rs</a></li> <li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs">tests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs</a></li> <li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/on_unimplemented_simple.rs">tests/ui/diagnostic_namespace/on_unimplemented/on_unimplemented_simple.rs</a></li> </ul>
</div></span>
</div> <p>The following keys have the given meaning:</p> <ul> <li>
<code>message</code> — The text for the top level error message.</li> <li>
<code>label</code> — The text for the label shown inline in the broken code in the error message.</li> <li>
<code>note</code> — Provides additional notes.</li> </ul> <div class="rule" id="r-attributes.diagnostic.on_unimplemented.note-repetition">
<a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.note-repetition">[attributes.diagnostic.on_unimplemented.note-repetition]</a><span class="popup-container"> <a href="javascript:void(0).html" onclick="spec_toggle_tests('attributes.diagnostic.on_unimplemented.note-repetition');">Tests</a> <div id="tests-attributes.diagnostic.on_unimplemented.note-repetition" class="tests-popup popup-hidden"> Tests with this rule: <ul>
<li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/multiple_notes.rs">tests/ui/diagnostic_namespace/on_unimplemented/multiple_notes.rs</a></li> </ul>
</div></span>
</div> <p>The <code>note</code> option can appear several times, which results in several note messages being emitted.</p> <div class="rule" id="r-attributes.diagnostic.on_unimplemented.repetition">
<a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.repetition">[attributes.diagnostic.on_unimplemented.repetition]</a><span class="popup-container"> <a href="javascript:void(0).html" onclick="spec_toggle_tests('attributes.diagnostic.on_unimplemented.repetition');">Tests</a> <div id="tests-attributes.diagnostic.on_unimplemented.repetition" class="tests-popup popup-hidden"> Tests with this rule: <ul>
<li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/ignore_unsupported_options_and_continue_to_use_fallback.rs">tests/ui/diagnostic_namespace/on_unimplemented/ignore_unsupported_options_and_continue_to_use_fallback.rs</a></li> <li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/report_warning_on_duplicated_options.rs">tests/ui/diagnostic_namespace/on_unimplemented/report_warning_on_duplicated_options.rs</a></li> </ul>
</div></span>
</div> <p>If any of the other options appears several times the first occurrence of the relevant option specifies the actually used value. Subsequent occurrences generates a warning.</p> <div class="rule" id="r-attributes.diagnostic.on_unimplemented.unknown-keys">
<a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.unknown-keys">[attributes.diagnostic.on_unimplemented.unknown-keys]</a><span class="popup-container"> <a href="javascript:void(0).html" onclick="spec_toggle_tests('attributes.diagnostic.on_unimplemented.unknown-keys');">Tests</a> <div id="tests-attributes.diagnostic.on_unimplemented.unknown-keys" class="tests-popup popup-hidden"> Tests with this rule: <ul>
<li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/do_not_fail_parsing_on_invalid_options_1.rs">tests/ui/diagnostic_namespace/on_unimplemented/do_not_fail_parsing_on_invalid_options_1.rs</a></li> </ul>
</div></span>
</div> <p>A warning is generated for any unknown keys.</p> <div class="rule" id="r-attributes.diagnostic.on_unimplemented.format-string"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.format-string">[attributes.diagnostic.on_unimplemented.format-string]</a></div> <p>All three options accept a string as an argument, interpreted using the same formatting as a <a href="https://doc.rust-lang.org/alloc/fmt/index.html"><code>std::fmt</code></a> string.</p> <div class="rule" id="r-attributes.diagnostic.on_unimplemented.format-parameters">
<a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.format-parameters">[attributes.diagnostic.on_unimplemented.format-parameters]</a><span class="popup-container"> <a href="javascript:void(0).html" onclick="spec_toggle_tests('attributes.diagnostic.on_unimplemented.format-parameters');">Tests</a> <div id="tests-attributes.diagnostic.on_unimplemented.format-parameters" class="tests-popup popup-hidden"> Tests with this rule: <ul>
<li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs">tests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs</a></li> </ul>
</div></span>
</div> <p>Format parameters with the given named parameter will be replaced with the following text:</p> <ul> <li>
<code>{Self}</code> — The name of the type implementing the trait.</li> <li>
<code>{</code> <em>GenericParameterName</em> <code>}</code> — The name of the generic argument’s type for the given generic parameter.</li> </ul> <div class="rule" id="r-attributes.diagnostic.on_unimplemented.invalid-formats">
<a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.invalid-formats">[attributes.diagnostic.on_unimplemented.invalid-formats]</a><span class="popup-container"> <a href="javascript:void(0).html" onclick="spec_toggle_tests('attributes.diagnostic.on_unimplemented.invalid-formats');">Tests</a> <div id="tests-attributes.diagnostic.on_unimplemented.invalid-formats" class="tests-popup popup-hidden"> Tests with this rule: <ul>
<li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs">tests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs</a></li> </ul>
</div></span>
</div> <p>Any other format parameter will generate a warning, but will otherwise be included in the string as-is.</p> <div class="rule" id="r-attributes.diagnostic.on_unimplemented.invalid-string">
<a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.invalid-string">[attributes.diagnostic.on_unimplemented.invalid-string]</a><span class="popup-container"> <a href="javascript:void(0).html" onclick="spec_toggle_tests('attributes.diagnostic.on_unimplemented.invalid-string');">Tests</a> <div id="tests-attributes.diagnostic.on_unimplemented.invalid-string" class="tests-popup popup-hidden"> Tests with this rule: <ul>
<li><a href="https://github.com/rust-lang/rust/blob/1.85.0/tests/ui/diagnostic_namespace/on_unimplemented/broken_format.rs">tests/ui/diagnostic_namespace/on_unimplemented/broken_format.rs</a></li> </ul>
</div></span>
</div> <p>Invalid format strings may generate a warning, but are otherwise allowed, but may not display as intended. Format specifiers may generate a warning, but are otherwise ignored.</p> <p>In this example:</p> <pre data-language="rust">#[diagnostic::on_unimplemented(
    message = "My Message for `ImportantTrait&lt;{A}&gt;` implemented for `{Self}`",
    label = "My Label",
    note = "Note 1",
    note = "Note 2"
)]
trait ImportantTrait&lt;A&gt; {}

fn use_my_trait(_: impl ImportantTrait&lt;i32&gt;) {}

fn main() {
    use_my_trait(String::new());
}</pre> <p>the compiler may generate an error message which looks like this:</p> <pre>error[E0277]: My Message for `ImportantTrait&lt;i32&gt;` implemented for `String`
  --&gt; src/main.rs:14:18
   |
14 |     use_my_trait(String::new());
   |     ------------ ^^^^^^^^^^^^^ My Label
   |     |
   |     required by a bound introduced by this call
   |
   = help: the trait `ImportantTrait&lt;i32&gt;` is not implemented for `String`
   = note: Note 1
   = note: Note 2
</pre> <h3 id="the-diagnosticdo_not_recommend-attribute">The <code id="">diagnostic::do_not_recommend</code> attribute</h3> <div class="rule" id="r-attributes.diagnostic.do_not_recommend"><a class="rule-link" href="#r-attributes.diagnostic.do_not_recommend">[attributes.diagnostic.do_not_recommend]</a></div> <div class="rule" id="r-attributes.diagnostic.do_not_recommend.intro"><a class="rule-link" href="#r-attributes.diagnostic.do_not_recommend.intro">[attributes.diagnostic.do_not_recommend.intro]</a></div> <p>The <code>#[diagnostic::do_not_recommend]</code> attribute is a hint to the compiler to not show the annotated trait implementation as part of a diagnostic message.</p> <blockquote> <p><strong>Note</strong>: Suppressing the recommendation can be useful if you know that the recommendation would normally not be useful to the programmer. This often occurs with broad, blanket impls. The recommendation may send the programmer down the wrong path, or the trait implementation may be an internal detail that you don’t want to expose, or the bounds may not be able to be satisfied by the programmer.</p> <p>For example, in an error message about a type not implementing a required trait, the compiler may find a trait implementation that would satisfy the requirements if it weren’t for specific bounds in the trait implementation. The compiler may tell the user that there is an impl, but the problem is the bounds in the trait implementation. The <code>#[diagnostic::do_not_recommend]</code> attribute can be used to tell the compiler to <em>not</em> tell the user about the trait implementation, and instead simply tell the user the type doesn’t implement the required trait.</p> </blockquote> <div class="rule" id="r-attributes.diagnostic.do_not_recommend.allowed-positions"><a class="rule-link" href="#r-attributes.diagnostic.do_not_recommend.allowed-positions">[attributes.diagnostic.do_not_recommend.allowed-positions]</a></div> <p>The attribute should be placed on a <a href="../items/implementations.html#trait-implementations">trait implementation item</a>, though it is not an error to be located in other positions.</p> <div class="rule" id="r-attributes.diagnostic.do_not_recommend.syntax"><a class="rule-link" href="#r-attributes.diagnostic.do_not_recommend.syntax">[attributes.diagnostic.do_not_recommend.syntax]</a></div> <p>The attribute does not accept any arguments, though unexpected arguments are not considered as an error.</p> <p>In the following example, there is a trait called <code>AsExpression</code> which is used for casting arbitrary types to the <code>Expression</code> type used in an SQL library. There is a method called <code>check</code> which takes an <code>AsExpression</code>.</p> <pre data-language="rust">pub trait Expression {
    type SqlType;
}

pub trait AsExpression&lt;ST&gt; {
    type Expression: Expression&lt;SqlType = ST&gt;;
}

pub struct Text;
pub struct Integer;

pub struct Bound&lt;T&gt;(T);
pub struct SelectInt;

impl Expression for SelectInt {
    type SqlType = Integer;
}

impl&lt;T&gt; Expression for Bound&lt;T&gt; {
    type SqlType = T;
}

impl AsExpression&lt;Integer&gt; for i32 {
    type Expression = Bound&lt;Integer&gt;;
}

impl AsExpression&lt;Text&gt; for &amp;'_ str {
    type Expression = Bound&lt;Text&gt;;
}

impl&lt;T&gt; Foo for T where T: Expression {}

// Uncomment this line to change the recommendation.
// #[diagnostic::do_not_recommend]
impl&lt;T, ST&gt; AsExpression&lt;ST&gt; for T
where
    T: Expression&lt;SqlType = ST&gt;,
{
    type Expression = T;
}

trait Foo: Expression + Sized {
    fn check&lt;T&gt;(&amp;self, _: T) -&gt; &lt;T as AsExpression&lt;&lt;Self as Expression&gt;::SqlType&gt;&gt;::Expression
    where
        T: AsExpression&lt;Self::SqlType&gt;,
    {
        todo!()
    }
}

fn main() {
    SelectInt.check("bar");
}</pre> <p>The <code>SelectInt</code> type’s <code>check</code> method is expecting an <code>Integer</code> type. Calling it with an i32 type works, as it gets converted to an <code>Integer</code> by the <code>AsExpression</code> trait. However, calling it with a string does not, and generates a an error that may look like this:</p> <pre>error[E0277]: the trait bound `&amp;str: Expression` is not satisfied
  --&gt; src/main.rs:53:15
   |
53 |     SelectInt.check("bar");
   |               ^^^^^ the trait `Expression` is not implemented for `&amp;str`
   |
   = help: the following other types implement trait `Expression`:
             Bound&lt;T&gt;
             SelectInt
note: required for `&amp;str` to implement `AsExpression&lt;Integer&gt;`
  --&gt; src/main.rs:45:13
   |
45 | impl&lt;T, ST&gt; AsExpression&lt;ST&gt; for T
   |             ^^^^^^^^^^^^^^^^     ^
46 | where
47 |     T: Expression&lt;SqlType = ST&gt;,
   |        ------------------------ unsatisfied trait bound introduced here
</pre> <p>By adding the <code>#[diagnostic::do_no_recommend]</code> attribute to the blanket <code>impl</code> for <code>AsExpression</code>, the message changes to:</p> <pre>error[E0277]: the trait bound `&amp;str: AsExpression&lt;Integer&gt;` is not satisfied
  --&gt; src/main.rs:53:15
   |
53 |     SelectInt.check("bar");
   |               ^^^^^ the trait `AsExpression&lt;Integer&gt;` is not implemented for `&amp;str`
   |
   = help: the trait `AsExpression&lt;Integer&gt;` is not implemented for `&amp;str`
           but trait `AsExpression&lt;Text&gt;` is implemented for it
   = help: for that trait implementation, expected `Text`, found `Integer`
</pre> <p>The first error message includes a somewhat confusing error message about the relationship of <code>&amp;str</code> and <code>Expression</code>, as well as the unsatisfied trait bound in the blanket impl. After adding <code>#[diagnostic::do_no_recommend]</code>, it no longer considers the blanket impl for the recommendation. The message should be a little clearer, with an indication that a string cannot be converted to an <code>Integer</code>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html" class="_attribution-link">https://doc.rust-lang.org/reference/attributes/diagnostics.html</a>
  </p>
</div>
