<h1 title="Interface GuardingTypeConverterFactory" class="title">Interface GuardingTypeConverterFactory</h1> <section class="class-description" id="class-description">  <pre class="lang-java" data-language="java">public interface GuardingTypeConverterFactory</pre> <div class="block">Optional interface that can be implemented by <a href="guardingdynamiclinker.html" title="interface in jdk.dynalink.linker"><code>GuardingDynamicLinker</code></a> implementations to provide language-specific type conversion capabilities. Note that if you implement this interface, you will very likely want to implement <a href="conversioncomparator.html" title="interface in jdk.dynalink.linker"><code>ConversionComparator</code></a> interface too, as your additional language-specific conversions, in absence of a strategy for prioritizing these conversions, will cause more ambiguity for <a href="../beans/beanslinker.html" title="class in jdk.dynalink.beans"><code>BeansLinker</code></a> in selecting the correct overload when trying to link to an overloaded Java method.</div> </section> <section class="summary"> <section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">       <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code><a href="guardedinvocation.html" title="class in jdk.dynalink.linker">GuardedInvocation</a></code></td>
<td><code><a href="#convertToType(java.lang.Class,java.lang.Class,java.util.function.Supplier)" class="member-name-link">convertToType</a><wbr>(<a href="../../../../java.base/java/lang/class.html" title="class in java.lang">Class</a>&lt;?&gt; sourceType,
 <a href="../../../../java.base/java/lang/class.html" title="class in java.lang">Class</a>&lt;?&gt; targetType,
 <a href="../../../../java.base/java/util/function/supplier.html" title="interface in java.util.function">Supplier</a>&lt;<a href="../../../../java.base/java/lang/invoke/methodhandles.lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&gt; lookupSupplier)</wbr></code></td>
<td> <div class="block">Returns a guarded type conversion that receives a value of the specified source type and returns a value converted to the specified target type.</div> </td>
</tr>
</table> </div> </div> </section> </section> <section class="details"> <section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="convertToType(java.lang.Class,java.lang.Class,java.util.function.Supplier)"> <h3>convertToType</h3> <pre class="lang-java" data-language="java">GuardedInvocation convertToType(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType, Supplier&lt;MethodHandles.Lookup&gt; lookupSupplier) throws Exception</pre> <div class="block">Returns a guarded type conversion that receives a value of the specified source type and returns a value converted to the specified target type. Value types can be either primitives or reference types, including interfaces, so you can even provide converters for converting your language's objects to Java interfaces and classes by generating adapters for them. <p> The type of the invocation is <code>(sourceType)→targetType</code>, while the type of the guard is <code>(sourceType)→boolean</code>. You are allowed to return unconditional invocations (with no guard) if the source type is specific to your runtime and your runtime only. </p>
<p>Note that this method will never be invoked for <a href="support/typeutilities.html#isMethodInvocationConvertible(java.lang.Class,java.lang.Class)"><code>method
 invocation conversions</code></a> as those can be automatically applied by <a href="../../../../java.base/java/lang/invoke/methodhandle.html#asType(java.lang.invoke.MethodType)"><code>MethodHandle.asType(MethodType)</code></a>. An implementation can assume it is never requested to produce a converter for those conversions. If a language runtime needs to customize method invocation conversions, it should <a href="../dynamiclinkerfactory.html#setAutoConversionStrategy(jdk.dynalink.linker.MethodTypeConversionStrategy)"><code>set an autoconversion strategy in the dynamic linker factory</code></a> instead. </p>
<p>Dynalink is at liberty to either cache some of the returned converters or to repeatedly request the converter factory to create the same conversion.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>sourceType</code> - source type</dd> <dd>
<code>targetType</code> - the target type.</dd> <dd>
<code>lookupSupplier</code> - a supplier for retrieving the lookup of the class on whose behalf a type converter is requested. When a converter is requested as part of linking an <code>invokedynamic</code> instruction the supplier will return the lookup passed to the bootstrap method, otherwise if the method is invoked from within a <a href="linkerservices.html#getWithLookup(java.util.function.Supplier,jdk.dynalink.SecureLookupSupplier)"><code>LinkerServices.getWithLookup(Supplier, jdk.dynalink.SecureLookupSupplier)</code></a> it will delegate to the secure lookup supplier. In any other case, it will return the public lookup. A typical case where the lookup might be needed is when the converter creates a Java adapter class on the fly (e.g. to convert some object from the dynamic language into a Java interface for interoperability). Invoking the <a href="../../../../java.base/java/util/function/supplier.html#get()"><code>Supplier.get()</code></a> method on the passed supplier will be subject to the same security checks as <a href="../securelookupsupplier.html#getLookup()"><code>SecureLookupSupplier.getLookup()</code></a>. An implementation should avoid retrieving the lookup if it is not needed so as to avoid the expense of <code>AccessController.doPrivileged</code> call.</dd> <dt>Returns:</dt> <dd>a guarded invocation that can take an object (if it passes guard) and return another object that is its representation coerced into the target type. In case the factory is certain it is unable to handle a conversion, it can return null. In case the factory is certain that it can always handle the conversion, it can return an unconditional invocation (one whose guard is null).</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/exception.html" title="class in java.lang">Exception</a></code> - if there was an error during creation of the converter</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="linkerservices.html#getWithLookup(java.util.function.Supplier,jdk.dynalink.SecureLookupSupplier)"><code>LinkerServices.getWithLookup(Supplier, SecureLookupSupplier)</code></a></li> </ul> </dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2023, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/jdk.dynalink/jdk/dynalink/linker/GuardingTypeConverterFactory.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/21/docs/api/jdk.dynalink/jdk/dynalink/linker/GuardingTypeConverterFactory.html</a>
  </p>
</div>
