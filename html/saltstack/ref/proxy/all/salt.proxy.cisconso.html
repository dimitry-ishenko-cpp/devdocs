<h1>salt.proxy.cisconso</h1> <p>Proxy Minion interface module for managing (practically) any network device with Cisco Network Services Orchestrator (Cisco NSO). Cisco NSO uses a series of remote polling agents, APIs and SSH commands to fetch network configuration and represent it in a data model. PyNSO, the Python module used by this proxy minion does the task of converting native Python dictionaries into NETCONF/YANG syntax that the REST API for Cisco NSO can then use to set the configuration of the target network device.</p> <dl class="simple"> <dt>Supported devices:</dt>
<dd>
<ul class="simple"> <li><p>A10 AX Series</p></li> <li><p>Arista 7150 Series</p></li> <li><p>Ciena 3000, 5000, ESM</p></li> <li><p>H3c S5800 Series</p></li> <li><p>Overture 1400, 2200, 5000, 5100, 6000</p></li> <li><p>Accedian MetroNID</p></li> <li><p>Avaya ERS 4000, SR8000, VSP 9000</p></li> <li>
<dl class="simple"> <dt>Cisco: APIC-DC, ASA, IOS, IOS XE, IOS XR, er, ME-4600, NX OS,</dt>
<dd>
<p>Prime Network Registrar, Quantum, StarOS, UCS ManagWSA</p> </dd> </dl> </li> <li><p>Huawei: NE40E, quidway series, Enterprise Network Simulation Framework</p></li> <li><p>PaloAlto PA-2000, PA-3000, Virtualized Firewalls</p></li> <li><p>Adtran 900 Series</p></li> <li><p>Brocade ADX, MLX, Netiron, Vyatta</p></li> <li><p>Dell Force 10 Networking S-Series</p></li> <li><p>Infinera DTN-X Multi-Terabit Packet Optical Network Platform</p></li> <li><p>Pulsecom SuperG</p></li> <li><p>Adva 150CC Series</p></li> <li><p>CableLabs Converged Cable Access Platform</p></li> <li><p>Ericsson EFN324 Series, SE family</p></li> <li><p>Juniper: Contrail, EX, M, MX, QFX, SRX, Virtual SRX</p></li> <li><p>Quagga Routing Software</p></li> <li><p>Affirmed Networks</p></li> <li><p>Citrix Netscaler</p></li> <li><p>F5 BIG-IP</p></li> <li><p>NEC iPasolink</p></li> <li><p>Riverbed Steelhead Series</p></li> <li><p>Alcatel-Lucent 7XXX, SAM</p></li> <li><p>Clavister</p></li> <li><p>Fortinet</p></li> <li><p>Nominum DCS</p></li> <li><p>Sonus SBC 5000 Series</p></li> <li><p>Allied Telesys</p></li> <li><p>Open vSwitch</p></li> </ul> </dd> </dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.0.</span></p> </div> <dl class="field-list simple"> <dt class="field-odd">codeauthor</dt> <dd class="field-odd">
<p><cite>Anthony Shaw &lt;anthony.shaw@dimensiondata.com&gt;</cite></p> </dd> </dl> <p>This proxy minion enables a consistent interface to fetch, control and maintain the configuration of network devices via a NETCONF-compliant control plane. Cisco Network Services Orchestrator.</p> <p>More in-depth conceptual reading on Proxy Minions can be found in the <a class="reference internal" href="https://docs.saltproject.io/en/latest/topics/proxyminion/index.html#proxy-minion"><span class="std std-ref">Proxy Minion</span></a> section of Salt's documentation.</p> <div class="section" id="dependencies"> <h2>Dependencies</h2> <ul class="simple"> <li><p>pynso Python module</p></li> </ul> <div class="section" id="pynso"> <h3>PyNSO</h3> <p>PyNSO can be installed via pip:</p> <pre class="highlight-bash notranslate" data-language="bash">pip install pynso</pre> </div> </div> <div class="section" id="configuration"> <h2>Configuration</h2> <p>To use this integration proxy module, please configure the following:</p> <div class="section" id="pillar"> <h3>Pillar</h3> <p>Proxy minions get their configuration from Salt's Pillar. Every proxy must have a stanza in Pillar and a reference in the Pillar top-file that matches the ID. At a minimum for communication with the NSO host, the pillar should look like this:</p> <pre class="highlight-yaml notranslate" data-language="yaml">proxy:
  proxytype: cisconso
  host: &lt;ip or dns name of host&gt;
  port: 8080
  use_ssl: false
  username: &lt;username&gt;
  password: password</pre> <div class="section" id="proxytype"> <h4>proxytype</h4> <p>The <code class="docutils literal notranslate"><span class="pre">proxytype</span></code> key and value pair is critical, as it tells Salt which interface to load from the <code class="docutils literal notranslate"><span class="pre">proxy</span></code> directory in Salt's install hierarchy, or from <code class="docutils literal notranslate"><span class="pre">/srv/salt/_proxy</span></code> on the Salt Master (if you have created your own proxy module, for example). To use this Cisco NSO Proxy Module, set this to <code class="docutils literal notranslate"><span class="pre">cisconso</span></code>.</p> </div> <div class="section" id="host"> <h4>host</h4> <p>The location, or IP/dns, of the Cisco NSO API host. Required.</p> </div> <div class="section" id="username"> <h4>username</h4> <p>The username used to login to the Cisco NSO host, such as <code class="docutils literal notranslate"><span class="pre">admin</span></code>. Required.</p> </div> <div class="section" id="passwords"> <h4>passwords</h4> <p>The password for the given user. Required.</p> </div> <div class="section" id="use-ssl"> <h4>use_ssl</h4> <p>Whether to use HTTPS messaging to speak to the API.</p> </div> <div class="section" id="port"> <h4>port</h4> <p>The port that the Cisco NSO API is running on, 8080 by default</p> </div> </div> <div class="section" id="salt-proxy"> <h3>Salt Proxy</h3> <p>After your pillar is in place, you can test the proxy. The proxy can run on any machine that has network connectivity to your Salt Master and to the Cisco NSO host in question. SaltStack recommends that the machine running the salt-proxy process also run a regular minion, though it is not strictly necessary.</p> <p>On the machine that will run the proxy, make sure there is an <code class="docutils literal notranslate"><span class="pre">/etc/salt/proxy</span></code> file with at least the following in it:</p> <pre class="highlight-yaml notranslate" data-language="yaml">master: &lt;ip or hostname of salt-master&gt;</pre> <p>You can then start the salt-proxy process with:</p> <pre class="highlight-bash notranslate" data-language="bash">salt-proxy --proxyid &lt;id you want to give the host&gt;</pre> <p>You may want to add <code class="docutils literal notranslate"><span class="pre">-l</span> <span class="pre">debug</span></code> to run the above in the foreground in debug mode just to make sure everything is OK.</p> <p>Next, accept the key for the proxy on your salt-master, just like you would for a regular minion:</p> <pre class="highlight-bash notranslate" data-language="bash">salt-key -a &lt;id you gave the cisconso host&gt;</pre> <p>You can confirm that the pillar data is in place for the proxy:</p> <pre class="highlight-bash notranslate" data-language="bash">salt &lt;id&gt; pillar.items</pre> <p>And now you should be able to ping the Cisco NSO host to make sure it is responding:</p> <pre class="highlight-bash notranslate" data-language="bash">salt &lt;id&gt; test.ping</pre> <dl class="py function"> <h3 id="salt.proxy.cisconso.apply_rollback"> salt.proxy.cisconso.apply_rollback(datastore, name)</h3> <dd>
<p>Apply a system rollback</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li><p><strong>datastore</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">DatastoreType</span></code> (<code class="docutils literal notranslate"><span class="pre">str</span></code> enum).) -- The datastore, e.g. running, operational. One of the NETCONF store IETF types</p></li> <li><p><strong>name</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) -- an ID of the rollback to restore</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.cisconso.get_data"> salt.proxy.cisconso.get_data(datastore, path)</h3> <dd>
<p>Get the configuration of the device tree at the given path</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li><p><strong>datastore</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">DatastoreType</span></code> (<code class="docutils literal notranslate"><span class="pre">str</span></code> enum).) -- The datastore, e.g. running, operational. One of the NETCONF store IETF types</p></li> <li><p><strong>path</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">str</span></code> OR <code class="docutils literal notranslate"><span class="pre">tuple</span></code>) -- The device path, a list of element names in order, comma separated</p></li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>The network configuration at that tree</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><code class="docutils literal notranslate"><span class="pre">dict</span></code></p> </dd> </dl> <pre class="highlight-bash notranslate" data-language="bash">salt cisco-nso cisconso.get_data devices</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.cisconso.get_rollback"> salt.proxy.cisconso.get_rollback(name)</h3> <dd>
<p>Get the backup of stored a configuration rollback</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>name</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) -- Typically an ID of the backup</p> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><code class="docutils literal notranslate"><span class="pre">str</span></code></p> </dd> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p>the contents of the rollback snapshot</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.cisconso.get_rollbacks"> salt.proxy.cisconso.get_rollbacks()</h3> <dd>
<p>Get a list of stored configuration rollbacks</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.cisconso.grains"> salt.proxy.cisconso.grains()</h3> <dd>
<p>Get the grains from the proxy device.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.cisconso.init"> salt.proxy.cisconso.init(opts)</h3> 
</dl> <dl class="py function"> <h3 id="salt.proxy.cisconso.ping"> salt.proxy.cisconso.ping()</h3> <dd>
<p>Check to see if the host is responding. Returns False if the host didn't respond, True otherwise.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt cisco-nso test.ping</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.cisconso.set_data_value"> salt.proxy.cisconso.set_data_value(datastore, path, data)</h3> <dd>
<p>Get a data entry in a datastore</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li><p><strong>datastore</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">DatastoreType</span></code> (<code class="docutils literal notranslate"><span class="pre">str</span></code> enum).) -- The datastore, e.g. running, operational. One of the NETCONF store IETF types</p></li> <li><p><strong>path</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">str</span></code> OR <code class="docutils literal notranslate"><span class="pre">tuple</span></code>) -- The device path to set the value at, a list of element names in order, comma separated</p></li> <li><p><strong>data</strong> (<code class="docutils literal notranslate"><span class="pre">dict</span></code>) -- The new value at the given path</p></li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p> </dd> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if successful, otherwise error.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.cisconso.shutdown"> salt.proxy.cisconso.shutdown()</h3> <dd>
<p>Shutdown the connection to the proxy device. For this proxy, shutdown is a no-op.</p> </dd>
</dl> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 SaltStack.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.saltproject.io/en/latest/ref/proxy/all/salt.proxy.cisconso.html" class="_attribution-link">https://docs.saltproject.io/en/latest/ref/proxy/all/salt.proxy.cisconso.html</a>
  </p>
</div>
