<h1>salt.proxy.fx2</h1> <div class="section" id="dell-fx2-chassis"> <h2>Dell FX2 chassis</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 2015.8.2.</span></p> </div> <p>Proxy minion interface module for managing Dell FX2 chassis (Dell Chassis Management Controller version 1.2 and above, iDRAC8 version 2.00 and above)</p> <div class="section" id="dependencies"> <h3>Dependencies</h3> <ul class="simple"> <li><p><a class="reference internal" href="../../modules/all/salt.modules.dracr.html#module-salt.modules.dracr" title="salt.modules.dracr"><code class="xref py py-mod docutils literal notranslate"><span class="pre">iDRAC</span> <span class="pre">Remote</span> <span class="pre">execution</span> <span class="pre">module</span> <span class="pre">(salt.modules.dracr)</span></code></a></p></li> <li><p><a class="reference internal" href="../../modules/all/salt.modules.chassis.html#module-salt.modules.chassis" title="salt.modules.chassis"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Chassis</span> <span class="pre">command</span> <span class="pre">shim</span> <span class="pre">(salt.modules.chassis)</span></code></a></p></li> <li><p><a class="reference internal" href="../../states/all/salt.states.dellchassis.html#module-salt.states.dellchassis" title="salt.states.dellchassis"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Dell</span> <span class="pre">Chassis</span> <span class="pre">States</span> <span class="pre">(salt.states.dellchassis)</span></code></a></p></li> <li><p>Dell's <code class="docutils literal notranslate"><span class="pre">racadm</span></code> command line interface to CMC and iDRAC devices.</p></li> </ul> <p><strong>Special Note: SaltStack thanks</strong> <a class="reference external" href="http://adobe.com/">Adobe Corporation</a> <strong>for their support in creating this proxy minion integration.</strong></p> <p>This proxy minion enables Dell FX2 and FX2s (hereafter referred to as simply "chassis", "CMC", or "FX2") chassis to be treated individually like a salt-minion.</p> <p>Since the CMC embedded in the chassis does not run an OS capable of hosting a Python stack, the chassis can't run a minion directly. Salt's "Proxy Minion" functionality enables you to designate another machine to host a minion process that "proxies" communication from the salt-master. The master does not know nor care that the target is not a real minion.</p> <p>More in-depth conceptual reading on Proxy Minions can be found <a class="reference internal" href="https://docs.saltproject.io/en/latest/topics/proxyminion/index.html#proxy-minion"><span class="std std-ref">in the Proxy Minion section</span></a> of Salt's documentation.</p> <p>To configure this integration, follow these steps:</p> </div> <div class="section" id="pillar"> <h3>Pillar</h3> <p>Proxy minions get their configuration from Salt's Pillar. Every proxy must have a stanza in Pillar, and a reference in the Pillar topfile that matches the ID. At a minimum for communication with the chassis the pillar should look like this:</p> <pre class="highlight-yaml notranslate" data-language="yaml">proxy:
  host: &lt;ip or dns name of chassis controller&gt;
  admin_username: &lt;iDRAC username for the CMC, usually 'root'&gt;
  fallback_admin_username: &lt;username to try if the first fails&gt;
  passwords:
    - first_password
    - second_password
    - third-password
  proxytype: fx2</pre> <p>The <code class="docutils literal notranslate"><span class="pre">proxytype</span></code> line above is critical, it tells Salt which interface to load from the <code class="docutils literal notranslate"><span class="pre">proxy</span></code> directory in Salt's install hierarchy, or from <code class="docutils literal notranslate"><span class="pre">/srv/salt/_proxy</span></code> on the salt-master (if you have created your own proxy module, for example).</p> <p>The proxy integration will try the passwords listed in order. It is configured this way so you can have a regular password, a potential fallback password, and the third password can be the one you intend to change the chassis to use. This way, after it is changed, you should not need to restart the proxy minion--it should just pick up the third password in the list. You can then change pillar at will to move that password to the front and retire the unused ones.</p> <p>Beware, many Dell CMC and iDRAC units are configured to lockout IP addresses or users after too many failed password attempts. This can generate user panic in the form of "I no longer know what the password is!!!". To mitigate panic try the web interface from a different IP, or setup a emergency administrator user in the CMC before doing a wholesale password rotation.</p> <p>The automatic lockout can be disabled via Salt with the following:</p> <pre class="highlight-bash notranslate" data-language="bash">salt &lt;cmc&gt; chassis.cmd set_general cfgRacTuning cfgRacTuneIpBlkEnable 0</pre> <p>and then verified with</p> <pre class="highlight-bash notranslate" data-language="bash">salt &lt;cmc&gt; chassis.cmd get_general cfgRacTuning cfgRacTuneIpBlkEnable</pre> </div> <div class="section" id="salt-proxy"> <h3>salt-proxy</h3> <p>After your pillar is in place, you can test the proxy. The proxy can run on any machine that has network connectivity to your salt-master and to the chassis in question. SaltStack recommends that this machine also run a regular minion, though it is not strictly necessary.</p> <p>On the machine that will run the proxy, make sure there is an <code class="docutils literal notranslate"><span class="pre">/etc/salt/proxy</span></code> file with at least the following in it:</p> <pre class="highlight-yaml notranslate" data-language="yaml">master: &lt;ip or hostname of salt-master&gt;</pre> <p>You can start the proxy with</p> <pre class="highlight-bash notranslate" data-language="bash">salt-proxy --proxyid &lt;id you want to give the chassis&gt;</pre> <p>You may want to add <code class="docutils literal notranslate"><span class="pre">-l</span> <span class="pre">debug</span></code> to run the above in the foreground in debug mode just to make sure everything is OK.</p> <p>Next, accept the key for the proxy on your salt-master, just like you would for a regular minion:</p> <pre class="highlight-bash notranslate" data-language="bash">salt-key -a &lt;id you want to give the chassis&gt;</pre> <p>You can confirm that the pillar data is in place for the proxy:</p> <pre class="highlight-bash notranslate" data-language="bash">salt &lt;id&gt; pillar.items</pre> <p>And now you should be able to ping the chassis to make sure it is responding:</p> <pre class="highlight-bash notranslate" data-language="bash">salt &lt;id&gt; test.ping</pre> <p>At this point you can execute one-off commands against the chassis. For example, you can get the chassis inventory:</p> <pre class="highlight-bash notranslate" data-language="bash">salt &lt;id&gt; chassis.cmd inventory</pre> <p>Note that you don't need to provide credentials or an ip/hostname. Salt knows to use the credentials you stored in Pillar.</p> <p>It's important to understand how this particular proxy works. <a class="reference internal" href="../../modules/all/salt.modules.dracr.html#module-salt.modules.dracr" title="salt.modules.dracr"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Salt.modules.dracr</span></code></a> is a standard Salt execution module. If you pull up the docs for it you'll see that almost every function in the module takes credentials and a target host. When credentials and a host aren't passed, Salt runs <code class="docutils literal notranslate"><span class="pre">racadm</span></code> against the local machine. If you wanted you could run functions from this module on any host where an appropriate version of <code class="docutils literal notranslate"><span class="pre">racadm</span></code> is installed, and that host would reach out over the network and communicate with the chassis.</p> <p><code class="docutils literal notranslate"><span class="pre">Chassis.cmd</span></code> acts as a "shim" between the execution module and the proxy. Its first parameter is always the function from salt.modules.dracr to execute. If the function takes more positional or keyword arguments you can append them to the call. It's this shim that speaks to the chassis through the proxy, arranging for the credentials and hostname to be pulled from the pillar section for this proxy minion.</p> <p>Because of the presence of the shim, to lookup documentation for what functions you can use to interface with the chassis, you'll want to look in <a class="reference internal" href="../../modules/all/salt.modules.dracr.html#module-salt.modules.dracr" title="salt.modules.dracr"><code class="xref py py-mod docutils literal notranslate"><span class="pre">salt.modules.dracr</span></code></a> instead of <a class="reference internal" href="../../modules/all/salt.modules.chassis.html#module-salt.modules.chassis" title="salt.modules.chassis"><code class="xref py py-mod docutils literal notranslate"><span class="pre">salt.modules.chassis</span></code></a>.</p> </div> <div class="section" id="states"> <h3>States</h3> <p>Associated states are thoroughly documented in <a class="reference internal" href="../../states/all/salt.states.dellchassis.html#module-salt.states.dellchassis" title="salt.states.dellchassis"><code class="xref py py-mod docutils literal notranslate"><span class="pre">salt.states.dellchassis</span></code></a>. Look there to find an example structure for pillar as well as an example <code class="docutils literal notranslate"><span class="pre">.sls</span></code> file for standing up a Dell Chassis from scratch.</p> <dl class="py function"> <h3 id="salt.proxy.fx2.admin_password"> salt.proxy.fx2.admin_password()</h3> <dd>
<p>Return the admin_password in the DETAILS dictionary, or 'calvin' (the Dell default) if there is none present</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.fx2.admin_username"> salt.proxy.fx2.admin_username()</h3> <dd>
<p>Return the admin_username in the DETAILS dictionary, or root if there is none present</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.fx2.chconfig"> salt.proxy.fx2.chconfig(cmd, *args, **kwargs)</h3> <dd>
<p>This function is called by the <a class="reference internal" href="../../modules/all/salt.modules.chassis.html#salt.modules.chassis.cmd" title="salt.modules.chassis.cmd"><code class="xref py py-mod docutils literal notranslate"><span class="pre">salt.modules.chassis.cmd</span></code></a> shim. It then calls whatever is passed in <code class="docutils literal notranslate"><span class="pre">cmd</span></code> inside the <a class="reference internal" href="../../modules/all/salt.modules.dracr.html#module-salt.modules.dracr" title="salt.modules.dracr"><code class="xref py py-mod docutils literal notranslate"><span class="pre">salt.modules.dracr</span></code></a> module.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li><p><strong>cmd</strong> -- The command to call inside salt.modules.dracr</p></li> <li><p><strong>args</strong> -- Arguments that need to be passed to that command</p></li> <li><p><strong>kwargs</strong> -- Keyword arguments that need to be passed to that command</p></li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>Passthrough the return from the dracr module.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.fx2.find_credentials"> salt.proxy.fx2.find_credentials()</h3> <dd>
<p>Cycle through all the possible credentials and return the first one that works</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.fx2.grains"> salt.proxy.fx2.grains()</h3> <dd>
<p>Get the grains from the proxied device</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.fx2.grains_refresh"> salt.proxy.fx2.grains_refresh()</h3> <dd>
<p>Refresh the grains from the proxied device</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.fx2.host"> salt.proxy.fx2.host()</h3> 
</dl> <dl class="py function"> <h3 id="salt.proxy.fx2.init"> salt.proxy.fx2.init(opts)</h3> <dd>
<p>This function gets called when the proxy starts up. We check opts to see if a fallback user and password are supplied. If they are present, and the primary credentials don't work, then we try the backup before failing.</p> <p>Whichever set of credentials works is placed in the persistent DETAILS dictionary and will be used for further communication with the chassis.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.fx2.ping"> salt.proxy.fx2.ping()</h3> <dd>
<p>Is the chassis responding?</p> <dl class="field-list simple"> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p>Returns False if the chassis didn't respond, True otherwise.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.fx2.shutdown"> salt.proxy.fx2.shutdown(opts)</h3> <dd>
<p>Shutdown the connection to the proxied device. For this proxy shutdown is a no-op.</p> </dd>
</dl> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 SaltStack.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.saltproject.io/en/latest/ref/proxy/all/salt.proxy.fx2.html" class="_attribution-link">https://docs.saltproject.io/en/latest/ref/proxy/all/salt.proxy.fx2.html</a>
  </p>
</div>
