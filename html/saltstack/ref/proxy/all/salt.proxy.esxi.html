<h1>salt.proxy.esxi</h1> <p>Proxy Minion interface module for managing VMware ESXi hosts.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2015.8.4.</span></p> </div> <p><strong>Special Note: SaltStack thanks</strong> <a class="reference external" href="http://adobe.com/">Adobe Corporation</a> <strong>for their support in creating this Proxy Minion integration.</strong></p> <p>This proxy minion enables VMware ESXi (hereafter referred to as simply 'ESXi') hosts to be treated individually like a Salt Minion.</p> <p>Since the ESXi host may not necessarily run on an OS capable of hosting a Python stack, the ESXi host can't run a Salt Minion directly. Salt's "Proxy Minion" functionality enables you to designate another machine to host a minion process that "proxies" communication from the Salt Master. The master does not know nor care that the target is not a "real" Salt Minion.</p> <p>More in-depth conceptual reading on Proxy Minions can be found in the <a class="reference internal" href="https://docs.saltproject.io/en/latest/topics/proxyminion/index.html#proxy-minion"><span class="std std-ref">Proxy Minion</span></a> section of Salt's documentation.</p> <div class="section" id="dependencies"> <h2>Dependencies</h2> <ul class="simple"> <li><p>pyVmomi Python Module</p></li> <li><p>ESXCLI</p></li> </ul> <div class="section" id="pyvmomi"> <h3>pyVmomi</h3> <p>PyVmomi can be installed via pip:</p> <pre class="highlight-bash notranslate" data-language="bash">pip install pyVmomi</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Version 6.0 of pyVmomi has some problems with SSL error handling on certain versions of Python. If using version 6.0 of pyVmomi, Python 2.6, Python 2.7.9, or newer must be present. This is due to an upstream dependency in pyVmomi 6.0 that is not supported in Python versions 2.7 to 2.7.8. If the version of Python is not in the supported range, you will need to install an earlier version of pyVmomi. See <a class="reference external" href="https://github.com/saltstack/salt/issues/29537">Issue #29537</a> for more information.</p> </div> <p>Based on the note above, to install an earlier version of pyVmomi than the version currently listed in PyPi, run the following:</p> <pre class="highlight-bash notranslate" data-language="bash">pip install pyVmomi==5.5.0.2014.1.1</pre> <p>The 5.5.0.2014.1.1 is a known stable version that this original ESXi State Module was developed against.</p> </div> <div class="section" id="esxcli"> <h3>ESXCLI</h3> <p>Currently, about a third of the functions used in the vSphere Execution Module require the ESXCLI package be installed on the machine running the Proxy Minion process.</p> <p>The ESXCLI package is also referred to as the VMware vSphere CLI, or vCLI. VMware provides vCLI package installation instructions for <a class="reference external" href="http://pubs.vmware.com/vsphere-55/index.jsp#com.vmware.vcli.getstart.doc/cli_install.4.2.html">vSphere 5.5</a> and <a class="reference external" href="http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.vcli.getstart.doc/cli_install.4.2.html">vSphere 6.0</a>.</p> <p>Once all of the required dependencies are in place and the vCLI package is installed, you can check to see if you can connect to your ESXi host or vCenter server by running the following command:</p> <pre class="highlight-bash notranslate" data-language="bash">esxcli -s &lt;host-location&gt; -u &lt;username&gt; -p &lt;password&gt; system syslog config get</pre> <p>If the connection was successful, ESXCLI was successfully installed on your system. You should see output related to the ESXi host's syslog configuration.</p> </div> </div> <div class="section" id="configuration"> <h2>Configuration</h2> <p>To use this integration proxy module, please configure the following:</p> <div class="section" id="pillar"> <h3>Pillar</h3> <p>Proxy minions get their configuration from Salt's Pillar. Every proxy must have a stanza in Pillar and a reference in the Pillar top-file that matches the ID. At a minimum for communication with the ESXi host, the pillar should look like this:</p> <pre class="highlight-yaml notranslate" data-language="yaml">proxy:
  proxytype: esxi
  host: &lt;ip or dns name of esxi host&gt;
  username: &lt;ESXi username&gt;
  passwords:
    - first_password
    - second_password
    - third_password
  credstore: &lt;path to credential store&gt;</pre> <div class="section" id="proxytype"> <h4>proxytype</h4> <p>The <code class="docutils literal notranslate"><span class="pre">proxytype</span></code> key and value pair is critical, as it tells Salt which interface to load from the <code class="docutils literal notranslate"><span class="pre">proxy</span></code> directory in Salt's install hierarchy, or from <code class="docutils literal notranslate"><span class="pre">/srv/salt/_proxy</span></code> on the Salt Master (if you have created your own proxy module, for example). To use this ESXi Proxy Module, set this to <code class="docutils literal notranslate"><span class="pre">esxi</span></code>.</p> </div> <div class="section" id="host"> <h4>host</h4> <p>The location, or ip/dns, of the ESXi host. Required.</p> </div> <div class="section" id="username"> <h4>username</h4> <p>The username used to login to the ESXi host, such as <code class="docutils literal notranslate"><span class="pre">root</span></code>. Required.</p> </div> <div class="section" id="passwords"> <h4>passwords</h4> <p>A list of passwords to be used to try and login to the ESXi host. At least one password in this list is required.</p> <p>The proxy integration will try the passwords listed in order. It is configured this way so you can have a regular password and the password you may be updating for an ESXi host either via the <a class="reference internal" href="../../modules/all/salt.modules.vsphere.html#salt.modules.vsphere.update_host_password" title="salt.modules.vsphere.update_host_password"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vsphere.update_host_password</span></code></a> execution module function or via the <a class="reference internal" href="../../states/all/salt.states.esxi.html#salt.states.esxi.password_present" title="salt.states.esxi.password_present"><code class="xref py py-mod docutils literal notranslate"><span class="pre">esxi.password_present</span></code></a> state function. This way, after the password is changed, you should not need to restart the proxy minion--it should just pick up the new password provided in the list. You can then change pillar at will to move that password to the front and retire the unused ones.</p> <p>This also allows you to use any number of potential fallback passwords.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When a password is changed on the host to one in the list of possible passwords, the further down on the list the password is, the longer individual commands will take to return. This is due to the nature of pyVmomi's login system. We have to wait for the first attempt to fail before trying the next password on the list.</p> <p>This scenario is especially true, and even slower, when the proxy minion first starts. If the correct password is not the first password on the list, it may take up to a minute for <code class="docutils literal notranslate"><span class="pre">test.ping</span></code> to respond with a <code class="docutils literal notranslate"><span class="pre">True</span></code> result. Once the initial authorization is complete, the responses for commands will be a little faster.</p> <p>To avoid these longer waiting periods, SaltStack recommends moving the correct password to the top of the list and restarting the proxy minion at your earliest convenience.</p> </div> </div> <div class="section" id="protocol"> <h4>protocol</h4> <p>If the ESXi host is not using the default protocol, set this value to an alternate protocol. Default is <code class="docutils literal notranslate"><span class="pre">https</span></code>.</p> </div> <div class="section" id="port"> <h4>port</h4> <p>If the ESXi host is not using the default port, set this value to an alternate port. Default is <code class="docutils literal notranslate"><span class="pre">443</span></code>.</p> </div> <div class="section" id="credstore"> <h4>credstore</h4> <p>If the ESXi host is using an untrusted SSL certificate, set this value to the file path where the credential store is located. This file is passed to <code class="docutils literal notranslate"><span class="pre">esxcli</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">&lt;HOME&gt;/.vmware/credstore/vicredentials.xml</span></code> on Linux and <code class="docutils literal notranslate"><span class="pre">&lt;APPDATA&gt;/VMware/credstore/vicredentials.xml</span></code> on Windows.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code class="docutils literal notranslate"><span class="pre">HOME</span></code> variable is sometimes not set for processes running as system services. If you want to rely on the default credential store location, make sure <code class="docutils literal notranslate"><span class="pre">HOME</span></code> is set for the proxy process.</p> </div> </div> </div> <div class="section" id="salt-proxy"> <h3>Salt Proxy</h3> <p>After your pillar is in place, you can test the proxy. The proxy can run on any machine that has network connectivity to your Salt Master and to the ESXi host in question. SaltStack recommends that the machine running the salt-proxy process also run a regular minion, though it is not strictly necessary.</p> <p>On the machine that will run the proxy, make sure there is an <code class="docutils literal notranslate"><span class="pre">/etc/salt/proxy</span></code> file with at least the following in it:</p> <pre class="highlight-yaml notranslate" data-language="yaml">master: &lt;ip or hostname of salt-master&gt;</pre> <p>You can then start the salt-proxy process with:</p> <pre class="highlight-bash notranslate" data-language="bash">salt-proxy --proxyid &lt;id you want to give the host&gt;</pre> <p>You may want to add <code class="docutils literal notranslate"><span class="pre">-l</span> <span class="pre">debug</span></code> to run the above in the foreground in debug mode just to make sure everything is OK.</p> <p>Next, accept the key for the proxy on your salt-master, just like you would for a regular minion:</p> <pre class="highlight-bash notranslate" data-language="bash">salt-key -a &lt;id you gave the esxi host&gt;</pre> <p>You can confirm that the pillar data is in place for the proxy:</p> <pre class="highlight-bash notranslate" data-language="bash">salt &lt;id&gt; pillar.items</pre> <p>And now you should be able to ping the ESXi host to make sure it is responding:</p> <pre class="highlight-bash notranslate" data-language="bash">salt &lt;id&gt; test.ping</pre> <p>At this point you can execute one-off commands against the host. For example, you can get the ESXi host's system information:</p> <pre class="highlight-bash notranslate" data-language="bash">salt &lt;id&gt; esxi.cmd system_info</pre> <p>Note that you don't need to provide credentials or an ip/hostname. Salt knows to use the credentials you stored in Pillar.</p> <p>It's important to understand how this particular proxy works. <a class="reference internal" href="../../modules/all/salt.modules.vsphere.html#module-salt.modules.vsphere" title="salt.modules.vsphere"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Salt.modules.vsphere</span></code></a> is a standard Salt execution module. If you pull up the docs for it you'll see that almost every function in the module takes credentials and a target host. When credentials and a host aren't passed, Salt runs commands through <code class="docutils literal notranslate"><span class="pre">pyVmomi</span></code> against the local machine. If you wanted, you could run functions from this module on any host where an appropriate version of <code class="docutils literal notranslate"><span class="pre">pyVmomi</span></code> is installed, and that host would reach out over the network and communicate with the ESXi host.</p> <p><code class="docutils literal notranslate"><span class="pre">esxi.cmd</span></code> acts as a "shim" between the execution module and the proxy. Its first parameter is always the function from salt.modules.vsphere. If the function takes more positional or keyword arguments you can append them to the call. It's this shim that speaks to the ESXi host through the proxy, arranging for the credentials and hostname to be pulled from the Pillar section for this Proxy Minion.</p> <p>Because of the presence of the shim, to lookup documentation for what functions you can use to interface with the ESXi host, you'll want to look in <a class="reference internal" href="../../modules/all/salt.modules.vsphere.html#module-salt.modules.vsphere" title="salt.modules.vsphere"><code class="xref py py-mod docutils literal notranslate"><span class="pre">salt.modules.vsphere</span></code></a> instead of <a class="reference internal" href="../../modules/all/salt.modules.esxi.html#module-salt.modules.esxi" title="salt.modules.esxi"><code class="xref py py-mod docutils literal notranslate"><span class="pre">salt.modules.esxi</span></code></a>.</p> </div> <div class="section" id="states"> <h3>States</h3> <p>Associated states are thoroughly documented in <a class="reference internal" href="../../states/all/salt.states.esxi.html#module-salt.states.esxi" title="salt.states.esxi"><code class="xref py py-mod docutils literal notranslate"><span class="pre">salt.states.esxi</span></code></a>. Look there to find an example structure for Pillar as well as an example <code class="docutils literal notranslate"><span class="pre">.sls</span></code> file for standing up an ESXi host from scratch.</p> <dl class="py function"> <h3 id="salt.proxy.esxi.ch_config"> salt.proxy.esxi.ch_config(cmd, *args, **kwargs)</h3> <dd>
<p>This function is called by the <a class="reference internal" href="../../modules/all/salt.modules.esxi.html#salt.modules.esxi.cmd" title="salt.modules.esxi.cmd"><code class="xref py py-mod docutils literal notranslate"><span class="pre">salt.modules.esxi.cmd</span></code></a> shim. It then calls whatever is passed in <code class="docutils literal notranslate"><span class="pre">cmd</span></code> inside the <a class="reference internal" href="../../modules/all/salt.modules.vsphere.html#module-salt.modules.vsphere" title="salt.modules.vsphere"><code class="xref py py-mod docutils literal notranslate"><span class="pre">salt.modules.vsphere</span></code></a> module. Passes the return through from the vsphere module.</p> <dl class="simple"> <dt>cmd</dt>
<dd>
<p>The command to call inside salt.modules.vsphere</p> </dd> <dt>args</dt>
<dd>
<p>Arguments that need to be passed to that command.</p> </dd> <dt>kwargs</dt>
<dd>
<p>Keyword arguments that need to be passed to that command.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.esxi.find_credentials"> salt.proxy.esxi.find_credentials(host)</h3> <dd>
<p>Cycle through all the possible credentials and return the first one that works.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.esxi.get_details"> salt.proxy.esxi.get_details()</h3> <dd>
<p>Return the proxy details</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.esxi.grains"> salt.proxy.esxi.grains()</h3> <dd>
<p>Get the grains from the proxy device.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.esxi.grains_refresh"> salt.proxy.esxi.grains_refresh()</h3> <dd>
<p>Refresh the grains from the proxy device.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.esxi.init"> salt.proxy.esxi.init(opts)</h3> <dd>
<p>This function gets called when the proxy starts up. For ESXi devices, the host, login credentials, and, if configured, the protocol and port are cached.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.esxi.is_connected_via_vcenter"> salt.proxy.esxi.is_connected_via_vcenter()</h3> 
</dl> <dl class="py function"> <h3 id="salt.proxy.esxi.ping"> salt.proxy.esxi.ping()</h3> <dd>
<p>Returns True if connection is to be done via a vCenter (no connection is attempted). Check to see if the host is responding when connecting directly via an ESXi host.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt esxi-host test.ping</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.proxy.esxi.shutdown"> salt.proxy.esxi.shutdown()</h3> <dd>
<p>Shutdown the connection to the proxy device. For this proxy, shutdown is a no-op.</p> </dd>
</dl> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 SaltStack.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.saltproject.io/en/latest/ref/proxy/all/salt.proxy.esxi.html" class="_attribution-link">https://docs.saltproject.io/en/latest/ref/proxy/all/salt.proxy.esxi.html</a>
  </p>
</div>
