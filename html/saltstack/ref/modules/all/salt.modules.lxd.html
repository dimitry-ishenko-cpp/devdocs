<h1>salt.modules.lxd</h1> <p>Module for managing the LXD daemon and its containers.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2019.2.0.</span></p> </div> <p><a class="reference external" href="https://linuxcontainers.org/lxd/">LXD(1)</a> is a container "hypervisor". This execution module provides several functions to help manage it and its containers.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <ul> <li>
<p><a class="reference external" href="https://github.com/lxc/pylxd/blob/master/doc/source/installation.rst">pylxd(2)</a> version &gt;=2.2.5 is required to let this work, currently only available via pip.</p> <blockquote> <div>
<p>To install on Ubuntu:</p> <p>$ apt-get install libssl-dev python-pip $ pip install -U pylxd</p> </div>
</blockquote> </li> <li><p>you need lxd installed on the minion for the init() and version() methods.</p></li> <li><p>for the config_get() and config_get() methods you need to have lxd-client installed.</p></li> </ul> </div> <dl class="field-list simple"> <dt class="field-odd">maintainer</dt> <dd class="field-odd">
<p>Ren√© Jochum &lt;<a class="reference external" href="mailto:rene%40jochums.at.html">rene<span>@</span>jochums<span>.</span>at</a>&gt;</p> </dd> <dt class="field-even">maturity</dt> <dd class="field-even">
<p>new</p> </dd> <dt class="field-odd">depends</dt> <dd class="field-odd">
<p>python-pylxd</p> </dd> <dt class="field-even">platform</dt> <dd class="field-even">
<p>Linux</p> </dd> </dl> <dl class="py function"> <h3 id="salt.modules.lxd.authenticate"> salt.modules.lxd.authenticate(remote_addr, password, cert, key, verify_cert=True)</h3> <dd>
<p>Authenticate with a remote LXDaemon.</p> <dl> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a></p> </dd> </dl> </dd> <dt>password :</dt>
<dd>
<p>The password of the remote.</p> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.authenticate https://srv01:8443 &lt;yourpass&gt; ~/.config/lxc/client.crt ~/.config/lxc/client.key false</pre> <p>See the <a class="reference external" href="http://docs.python-requests.org/en/master/user/advanced/#ssl-cert-verification">requests-docs</a> for the SSL stuff.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.config_get"> salt.modules.lxd.config_get(key)</h3> <dd>
<p>Get an LXD daemon config option</p> <dl class="simple"> <dt>key :</dt>
<dd>
<p>The key of the config value to retrieve</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.config_get core.https_address</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.config_set"> salt.modules.lxd.config_set(key, value)</h3> <dd>
<p>Set an LXD daemon config option</p> <p>CLI Examples:</p> <p>To listen on IPv4 and IPv6 port 8443, you can omit the :8443 its the default:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.config_set core.https_address [::]:8443</pre> <p>To set the server trust password:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.config_set core.trust_password blah</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_config_delete"> salt.modules.lxd.container_config_delete(name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Delete a container config value</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container</p> </dd> <dt>config_key :</dt>
<dd>
<p>The config key to delete</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_config_get"> salt.modules.lxd.container_config_get(name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Get a container config value</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container</p> </dd> <dt>config_key :</dt>
<dd>
<p>The config key to retrieve</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_config_set"> salt.modules.lxd.container_config_set(name, config_key, config_value, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Set a container config value</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container</p> </dd> <dt>config_key :</dt>
<dd>
<p>The config key to set</p> </dd> <dt>config_value :</dt>
<dd>
<p>The config value to set</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_create"> salt.modules.lxd.container_create(name, source, profiles=None, config=None, devices=None, architecture='x86_64', ephemeral=False, wait=True, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False)</h3> <dd>
<p>Create a container</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the container</p> </dd> <dt>source :</dt>
<dd>
<dl class="simple"> <dt>Can be either a string containing an image alias:</dt>
<dd>
<p>"xenial/amd64"</p> </dd> <dt>or an dict with type "image" with alias:</dt>
<dd>
<dl class="simple"> <dt>{"type": "image",</dt>
<dd>
<p>"alias": "xenial/amd64"}</p> </dd> </dl> </dd> <dt>or image with "fingerprint":</dt>
<dd>
<dl class="simple"> <dt>{"type": "image",</dt>
<dd>
<p>"fingerprint": "SHA-256"}</p> </dd> </dl> </dd> <dt>or image with "properties":</dt>
<dd>
<dl class="simple"> <dt>{"type": "image",</dt>
<dd>
<dl class="simple"> <dt>"properties": {</dt>
<dd>
<p>"os": "ubuntu", "release": "14.04", "architecture": "x86_64"}}</p> </dd> </dl> </dd> </dl> </dd> <dt>or none:</dt>
<dd>
<p>{"type": "none"}</p> </dd> <dt>or copy:</dt>
<dd>
<dl class="simple"> <dt>{"type": "copy",</dt>
<dd>
<p>"source": "my-old-container"}</p> </dd> </dl> </dd> </dl> </dd> <dt>profiles<span class="classifier">['default']</span>
</dt>
<dd>
<p>List of profiles to apply on this container</p> </dd> <dt>config :</dt>
<dd>
<p>A config dict or None (None = unset).</p> <dl class="simple"> <dt>Can also be a list:</dt>
<dd>
<dl class="simple"> <dt>[{'key': 'boot.autostart', 'value': 1},</dt>
<dd>
<p>{'key': 'security.privileged', 'value': '1'}]</p> </dd> </dl> </dd> </dl> </dd> <dt>devices :</dt>
<dd>
<p>A device dict or None (None = unset).</p> </dd> <dt>architecture<span class="classifier">'x86_64'</span>
</dt>
<dd>
<dl class="simple"> <dt>Can be one of the following:</dt>
<dd>
<ul class="simple"> <li><p>unknown</p></li> <li><p>i686</p></li> <li><p>x86_64</p></li> <li><p>armv7l</p></li> <li><p>aarch64</p></li> <li><p>ppc</p></li> <li><p>ppc64</p></li> <li><p>ppc64le</p></li> <li><p>s390x</p></li> </ul> </dd> </dl> </dd> <dt>ephemeral<span class="classifier">False</span>
</dt>
<dd>
<p>Destroy this container after stop?</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> <dt>_raw<span class="classifier">False</span>
</dt>
<dd>
<p>Return the raw pyxld object or a dict?</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.container_create test xenial/amd64</pre> <p>See also the <a class="reference external" href="https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1">rest-api-docs</a>.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_delete"> salt.modules.lxd.container_delete(name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Delete a container</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container to delete</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_device_add"> salt.modules.lxd.container_device_add(name, device_name, device_type='disk', remote_addr=None, cert=None, key=None, verify_cert=True, **kwargs)</h3> <dd>
<p>Add a container device</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container</p> </dd> <dt>device_name :</dt>
<dd>
<p>The device name to add</p> </dd> <dt>device_type :</dt>
<dd>
<p>Type of the device</p> </dd> <dt>** kwargs :</dt>
<dd>
<p>Additional device args</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_device_delete"> salt.modules.lxd.container_device_delete(name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Delete a container device</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container</p> </dd> <dt>device_name :</dt>
<dd>
<p>The device name to delete</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_device_get"> salt.modules.lxd.container_device_get(name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Get a container device</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container</p> </dd> <dt>device_name :</dt>
<dd>
<p>The device name to retrieve</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_execute"> salt.modules.lxd.container_execute(name, cmd, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Execute a command list on a container.</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container</p> </dd> <dt>cmd :</dt>
<dd>
<p>Command to be executed (as a list)</p> <dl class="simple"> <dt>Example :</dt>
<dd>
<p>'["ls", "-l"]'</p> </dd> </dl> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.container_execute &lt;container name&gt; '["ls", "-l"]'</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_file_get"> salt.modules.lxd.container_file_get(name, src, dst, overwrite=False, mode=None, uid=None, gid=None, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Get a file from a container</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container</p> </dd> <dt>src :</dt>
<dd>
<p>The source file or directory</p> </dd> <dt>dst :</dt>
<dd>
<p>The destination file or directory</p> </dd> <dt>mode :</dt>
<dd>
<p>Set file mode to octal number</p> </dd> <dt>uid :</dt>
<dd>
<p>Set file uid (owner)</p> </dd> <dt>gid :</dt>
<dd>
<p>Set file gid (group)</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_file_put"> salt.modules.lxd.container_file_put(name, src, dst, recursive=False, overwrite=False, mode=None, uid=None, gid=None, saltenv='base', remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Put a file into a container</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container</p> </dd> <dt>src :</dt>
<dd>
<p>The source file or directory</p> </dd> <dt>dst :</dt>
<dd>
<p>The destination file or directory</p> </dd> <dt>recursive :</dt>
<dd>
<p>Decent into src directory</p> </dd> <dt>overwrite :</dt>
<dd>
<p>Replace destination if it exists</p> </dd> <dt>mode :</dt>
<dd>
<p>Set file mode to octal number</p> </dd> <dt>uid :</dt>
<dd>
<p>Set file uid (owner)</p> </dd> <dt>gid :</dt>
<dd>
<p>Set file gid (group)</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.container_file_put &lt;container name&gt; /var/tmp/foo /var/tmp/</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_freeze"> salt.modules.lxd.container_freeze(name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Freeze a container</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container to freeze</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_get"> salt.modules.lxd.container_get(name=None, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False)</h3> <dd>
<p>Gets a container from the LXD</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the container to get.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> <dt>_raw :</dt>
<dd>
<p>Return the pylxd object, this is internal and by states in use.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_list"> salt.modules.lxd.container_list(list_names=False, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Lists containers</p> <dl> <dt>list_names<span class="classifier">False</span>
</dt>
<dd>
<p>Only return a list of names when True</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Examples:</p> <p>Full dict with all available information:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.container_list</pre> <p>For a list of names:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.container_list true</pre> <p>See also <a class="reference external" href="https://github.com/lxc/pylxd/blob/master/doc/source/containers.rst#container-attributes">container-attributes</a>.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_migrate"> salt.modules.lxd.container_migrate(name, stop_and_start=False, remote_addr=None, cert=None, key=None, verify_cert=True, src_remote_addr=None, src_cert=None, src_key=None, src_verify_cert=None)</h3> <dd>
<p>Migrate a container.</p> <p>If the container is running, it either must be shut down first (use stop_and_start=True) or criu must be installed on the source and destination machines.</p> <p>For this operation both certs need to be authenticated, use <code class="xref py py-mod docutils literal notranslate"><span class="pre">lxd.authenticate</span> <span class="pre">&lt;salt.modules.lxd.authenticate</span></code> to authenticate your cert(s).</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container to migrate</p> </dd> <dt>stop_and_start :</dt>
<dd>
<p>Stop the container on the source and start it on dest</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash"># Authorize
salt '*' lxd.authenticate https://srv01:8443 &lt;yourpass&gt; ~/.config/lxc/client.crt ~/.config/lxc/client.key false
salt '*' lxd.authenticate https://srv02:8443 &lt;yourpass&gt; ~/.config/lxc/client.crt ~/.config/lxc/client.key false

# Migrate phpmyadmin from srv01 to srv02
salt '*' lxd.container_migrate phpmyadmin stop_and_start=true remote_addr=https://srv02:8443 cert=~/.config/lxc/client.crt key=~/.config/lxc/client.key verify_cert=False src_remote_addr=https://srv01:8443</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_rename"> salt.modules.lxd.container_rename(name, newname, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Rename a container</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container to Rename</p> </dd> <dt>newname :</dt>
<dd>
<p>The new name of the container</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_restart"> salt.modules.lxd.container_restart(name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Restart a container</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container to restart</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_start"> salt.modules.lxd.container_start(name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Start a container</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container to start</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_state"> salt.modules.lxd.container_state(name=None, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Get container state</p> <dl> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_stop"> salt.modules.lxd.container_stop(name, timeout=30, force=True, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Stop a container</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container to stop</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.container_unfreeze"> salt.modules.lxd.container_unfreeze(name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Unfreeze a container</p> <dl> <dt>name :</dt>
<dd>
<p>Name of the container to unfreeze</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.image_alias_add"> salt.modules.lxd.image_alias_add(image, alias, description='', remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Create an alias on the given image</p> <dl> <dt>image :</dt>
<dd>
<p>An image alias, a fingerprint or a image object</p> </dd> <dt>alias :</dt>
<dd>
<p>The alias to add</p> </dd> <dt>description :</dt>
<dd>
<p>Description of the alias</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.image_alias_add xenial/amd64 x "Short version of xenial/amd64"</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.image_alias_delete"> salt.modules.lxd.image_alias_delete(image, alias, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Delete an alias (this is currently not restricted to the image)</p> <dl> <dt>image :</dt>
<dd>
<p>An image alias, a fingerprint or a image object</p> </dd> <dt>alias :</dt>
<dd>
<p>The alias to delete</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.image_alias_add xenial/amd64 x "Short version of xenial/amd64"</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.image_copy_lxd"> salt.modules.lxd.image_copy_lxd(source, src_remote_addr, src_cert, src_key, src_verify_cert, remote_addr, cert, key, verify_cert=True, aliases=None, public=None, auto_update=None, _raw=False)</h3> <dd>
<p>Copy an image from another LXD instance</p> <dl> <dt>source :</dt>
<dd>
<p>An alias or a fingerprint of the source.</p> </dd> <dt>src_remote_addr :</dt>
<dd>
<p>An URL to the source remote daemon</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://mysourceserver.lan:8443">https://mysourceserver.lan:8443</a></p> </dd> </dl> </dd> <dt>src_cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate for the source</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>src_key :</dt>
<dd>
<p>PEM Formatted SSL Key for the source</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>src_verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>Address of the destination daemon</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://mydestserver.lan:8443">https://mydestserver.lan:8443</a></p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate for the destination</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key for the destination</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> <dt>aliases<span class="classifier">[]</span>
</dt>
<dd>
<p>List of aliases to append to the copied image</p> </dd> <dt>public<span class="classifier">None</span>
</dt>
<dd>
<p>Make this image public available, None = copy source</p> </dd> <dt>auto_update<span class="classifier">None</span>
</dt>
<dd>
<p>Wherever to auto-update from the original source, None = copy source</p> </dd> <dt>_raw<span class="classifier">False</span>
</dt>
<dd>
<p>Return the raw pylxd object or a dict of the destination image?</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.image_copy_lxd xenial/amd64 https://srv01:8443 ~/.config/lxc/client.crt ~/.config/lxc/client.key false https://srv02:8443 ~/.config/lxc/client.crt ~/.config/lxc/client.key false aliases="['xenial/amd64']"</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.image_delete"> salt.modules.lxd.image_delete(image, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Delete an image by an alias or fingerprint</p> <dl> <dt>name :</dt>
<dd>
<p>The alias or fingerprint of the image to delete, can be a obj for the states.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.image_delete xenial/amd64</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.image_from_file"> salt.modules.lxd.image_from_file(filename, remote_addr=None, cert=None, key=None, verify_cert=True, aliases=None, public=False, saltenv='base', _raw=False)</h3> <dd>
<p>Create an image from a file</p> <dl> <dt>filename :</dt>
<dd>
<p>The filename of the rootfs</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> <dt>aliases<span class="classifier">[]</span>
</dt>
<dd>
<p>List of aliases to append to the copied image</p> </dd> <dt>public<span class="classifier">False</span>
</dt>
<dd>
<p>Make this image public available</p> </dd> <dt>saltenv<span class="classifier">base</span>
</dt>
<dd>
<p>The saltenv to use for salt:// copies</p> </dd> <dt>_raw<span class="classifier">False</span>
</dt>
<dd>
<p>Return the raw pylxd object or a dict of the image?</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.image_from_file salt://lxd/files/busybox.tar.xz aliases=["busybox-amd64"]</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.image_from_simplestreams"> salt.modules.lxd.image_from_simplestreams(server, alias, remote_addr=None, cert=None, key=None, verify_cert=True, aliases=None, public=False, auto_update=False, _raw=False)</h3> <dd>
<p>Create an image from simplestreams</p> <dl> <dt>server :</dt>
<dd>
<p>Simplestreams server URI</p> </dd> <dt>alias :</dt>
<dd>
<p>The alias of the image to retrieve</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> <dt>aliases<span class="classifier">[]</span>
</dt>
<dd>
<p>List of aliases to append to the copied image</p> </dd> <dt>public<span class="classifier">False</span>
</dt>
<dd>
<p>Make this image public available</p> </dd> <dt>auto_update<span class="classifier">False</span>
</dt>
<dd>
<p>Should LXD auto update that image?</p> </dd> <dt>_raw<span class="classifier">False</span>
</dt>
<dd>
<p>Return the raw pylxd object or a dict of the image?</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.image_from_simplestreams "https://cloud-images.ubuntu.com/releases" "trusty/amd64" aliases='["t", "trusty/amd64"]' auto_update=True</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.image_from_url"> salt.modules.lxd.image_from_url(url, remote_addr=None, cert=None, key=None, verify_cert=True, aliases=None, public=False, auto_update=False, _raw=False)</h3> <dd>
<p>Create an image from an url</p> <dl> <dt>url :</dt>
<dd>
<p>The URL from where to download the image</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> <dt>aliases<span class="classifier">[]</span>
</dt>
<dd>
<p>List of aliases to append to the copied image</p> </dd> <dt>public<span class="classifier">False</span>
</dt>
<dd>
<p>Make this image public available</p> </dd> <dt>auto_update<span class="classifier">False</span>
</dt>
<dd>
<p>Should LXD auto update that image?</p> </dd> <dt>_raw<span class="classifier">False</span>
</dt>
<dd>
<p>Return the raw pylxd object or a dict of the image?</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.image_from_url https://dl.stgraber.org/lxd aliases='["busybox-amd64"]'</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.image_get"> salt.modules.lxd.image_get(fingerprint, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False)</h3> <dd>
<p>Get an image by its fingerprint</p> <dl> <dt>fingerprint :</dt>
<dd>
<p>The fingerprint of the image to retrieve</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> <dt>_raw<span class="classifier">False</span>
</dt>
<dd>
<p>Return the raw pylxd object or a dict of it?</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.image_get &lt;fingerprint&gt;</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.image_get_by_alias"> salt.modules.lxd.image_get_by_alias(alias, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False)</h3> <dd>
<p>Get an image by an alias</p> <dl> <dt>alias :</dt>
<dd>
<p>The alias of the image to retrieve</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> <dt>_raw<span class="classifier">False</span>
</dt>
<dd>
<p>Return the raw pylxd object or a dict of it?</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.image_get_by_alias xenial/amd64</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.image_list"> salt.modules.lxd.image_list(list_aliases=False, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Lists all images from the LXD.</p> <p>list_aliases :</p> <blockquote> <div>
<p>Return a dict with the fingerprint as key and a list of aliases as value instead.</p> </div>
</blockquote> <dl> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.image_list true --out=json
salt '*' lxd.image_list --out=json</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.init"> salt.modules.lxd.init(storage_backend='dir', trust_password=None, network_address=None, network_port=None, storage_create_device=None, storage_create_loop=None, storage_pool=None)</h3> <dd>
<p>Calls lxd init --auto -- opts</p> <dl class="simple"> <dt>storage_backend :</dt>
<dd>
<p>Storage backend to use (zfs or dir, default: dir)</p> </dd> <dt>trust_password :</dt>
<dd>
<p>Password required to add new clients</p> </dd> <dt>network_address<span class="classifier">None</span>
</dt>
<dd>
<p>Address to bind LXD to (default: none)</p> </dd> <dt>network_port<span class="classifier">None</span>
</dt>
<dd>
<p>Port to bind LXD to (Default: 8443)</p> </dd> <dt>storage_create_device<span class="classifier">None</span>
</dt>
<dd>
<p>Setup device based storage using this DEVICE</p> </dd> <dt>storage_create_loop<span class="classifier">None</span>
</dt>
<dd>
<p>Setup loop based storage with this SIZE in GB</p> </dd> <dt>storage_pool<span class="classifier">None</span>
</dt>
<dd>
<p>Storage pool to use or create</p> </dd> </dl> <p>CLI Examples:</p> <p>To listen on all IPv4/IPv6 Addresses:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.init dir PaSsW0rD [::]</pre> <p>To not listen on Network:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.init</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.normalize_input_values"> salt.modules.lxd.normalize_input_values(config, devices)</h3> <dd>
<p>normalize config input so returns can be put into mongodb, which doesn't like <cite>.</cite></p> <p>This is not meant to be used on the commandline.</p> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.normalize_input_values config={} devices={}</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.profile_config_delete"> salt.modules.lxd.profile_config_delete(name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Delete a profile config item.</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the profile to delete the config item.</p> </dd> <dt>config_key :</dt>
<dd>
<p>The config key for the value to retrieve.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.profile_config_delete autostart boot.autostart.delay</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.profile_config_get"> salt.modules.lxd.profile_config_get(name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Get a profile config item.</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the profile to get the config item from.</p> </dd> <dt>config_key :</dt>
<dd>
<p>The key for the item to retrieve.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.profile_config_get autostart boot.autostart</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.profile_config_set"> salt.modules.lxd.profile_config_set(name, config_key, config_value, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Set a profile config item.</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the profile to set the config item to.</p> </dd> <dt>config_key :</dt>
<dd>
<p>The items key.</p> </dd> <dt>config_value :</dt>
<dd>
<p>Its items value.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.profile_config_set autostart boot.autostart 0</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.profile_create"> salt.modules.lxd.profile_create(name, config=None, devices=None, description=None, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Creates a profile.</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the profile to get.</p> </dd> <dt>config :</dt>
<dd>
<p>A config dict or None (None = unset).</p> <dl class="simple"> <dt>Can also be a list:</dt>
<dd>
<dl class="simple"> <dt>[{'key': 'boot.autostart', 'value': 1},</dt>
<dd>
<p>{'key': 'security.privileged', 'value': '1'}]</p> </dd> </dl> </dd> </dl> </dd> <dt>devices :</dt>
<dd>
<p>A device dict or None (None = unset).</p> </dd> <dt>description :</dt>
<dd>
<p>A description string or None (None = unset).</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.profile_create autostart config="{boot.autostart: 1, boot.autostart.delay: 2, boot.autostart.priority: 1}"
salt '*' lxd.profile_create shared_mounts devices="{shared_mount: {type: 'disk', source: '/home/shared', path: '/home/shared'}}"</pre> <p>See the <a class="reference external" href="https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-10">lxd-docs</a> for the details about the config and devices dicts.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.profile_delete"> salt.modules.lxd.profile_delete(name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Deletes a profile.</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the profile to delete.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.profile_delete shared_mounts</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.profile_device_delete"> salt.modules.lxd.profile_device_delete(name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Delete a profile device.</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the profile to delete the device.</p> </dd> <dt>device_name :</dt>
<dd>
<p>The name of the device to delete.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.profile_device_delete autostart eth1</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.profile_device_get"> salt.modules.lxd.profile_device_get(name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Get a profile device.</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the profile to get the device from.</p> </dd> <dt>device_name :</dt>
<dd>
<p>The name of the device to retrieve.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.profile_device_get default eth0</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.profile_device_set"> salt.modules.lxd.profile_device_set(name, device_name, device_type='disk', remote_addr=None, cert=None, key=None, verify_cert=True, **kwargs)</h3> <dd>
<p>Set a profile device.</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the profile to set the device to.</p> </dd> <dt>device_name :</dt>
<dd>
<p>The name of the device to set.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.profile_device_set autostart eth1 nic nictype=bridged parent=lxdbr0</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.profile_get"> salt.modules.lxd.profile_get(name, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False)</h3> <dd>
<p>Gets a profile from the LXD</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the profile to get.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> <dt>_raw :</dt>
<dd>
<p>Return the pylxd object, this is internal and by states in use.</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.profile_get autostart</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.profile_list"> salt.modules.lxd.profile_list(list_names=False, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Lists all profiles from the LXD.</p> <p>list_names :</p> <blockquote> <div>
<p>Return a list of names instead of full blown dicts.</p> </div>
</blockquote> <dl> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.profile_list true --out=json
salt '*' lxd.profile_list --out=json</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.pylxd_client_get"> salt.modules.lxd.pylxd_client_get(remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Get an pyxld client, this is not meant to be run over the CLI.</p> <dl> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr and its a TCP Address!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> <p>See the <a class="reference external" href="http://docs.python-requests.org/en/master/user/advanced/#ssl-cert-verification">requests-docs</a> for the SSL stuff.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.pylxd_save_object"> salt.modules.lxd.pylxd_save_object(obj)</h3> <dd>
<dl class="simple"> <dt>Saves an object (profile/image/container) and</dt>
<dd>
<p>translate its execpetion on failure</p> </dd> <dt>obj :</dt>
<dd>
<p>The object to save</p> </dd> </dl> <p>This is an internal method, no CLI Example.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.pylxd_version"> salt.modules.lxd.pylxd_version()</h3> <dd>
<p>Returns the actual pylxd version.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.pylxd_version</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.snapshots_all"> salt.modules.lxd.snapshots_all(container, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Get all snapshots for a container</p> <dl> <dt>container :</dt>
<dd>
<p>The name of the container to get.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote server. The 'cert' and 'key' fields must also be provided if 'remote_addr' is defined.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Verify the ssl certificate. Default: True</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.snapshots_all test-container</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.snapshots_create"> salt.modules.lxd.snapshots_create(container, name=None, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Create a snapshot for a container</p> <dl> <dt>container :</dt>
<dd>
<p>The name of the container to get.</p> </dd> <dt>name :</dt>
<dd>
<p>The name of the snapshot.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote server. The 'cert' and 'key' fields must also be provided if 'remote_addr' is defined.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Verify the ssl certificate. Default: True</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.snapshots_create test-container test-snapshot</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.snapshots_delete"> salt.modules.lxd.snapshots_delete(container, name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Delete a snapshot for a container</p> <dl> <dt>container :</dt>
<dd>
<p>The name of the container to get.</p> </dd> <dt>name :</dt>
<dd>
<p>The name of the snapshot.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote server. The 'cert' and 'key' fields must also be provided if 'remote_addr' is defined.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Verify the ssl certificate. Default: True</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.snapshots_delete test-container test-snapshot</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.snapshots_get"> salt.modules.lxd.snapshots_get(container, name, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Get information about snapshot for a container</p> <dl> <dt>container :</dt>
<dd>
<p>The name of the container to get.</p> </dd> <dt>name :</dt>
<dd>
<p>The name of the snapshot.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote server. The 'cert' and 'key' fields must also be provided if 'remote_addr' is defined.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Certificate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Verify the ssl certificate. Default: True</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.snapshots_get test-container test-snapshot</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.sync_config_devices"> salt.modules.lxd.sync_config_devices(obj, newconfig, newdevices, test=False)</h3> <dd>
<p>Syncs the given config and devices with the object (a profile or a container) returns a changes dict with all changes made.</p> <dl class="simple"> <dt>obj :</dt>
<dd>
<p>The object to sync with / or just test with.</p> </dd> <dt>newconfig:</dt>
<dd>
<p>The new config to check with the obj.</p> </dd> <dt>newdevices:</dt>
<dd>
<p>The new devices to check with the obj.</p> </dd> <dt>test:</dt>
<dd>
<p>Wherever to not change anything and give "Would change" message.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.lxd.version"> salt.modules.lxd.version()</h3> <dd>
<p>Returns the actual lxd version.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' lxd.version</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 SaltStack.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.saltproject.io/en/latest/ref/modules/all/salt.modules.lxd.html" class="_attribution-link">https://docs.saltproject.io/en/latest/ref/modules/all/salt.modules.lxd.html</a>
  </p>
</div>
