<h1>salt.modules.state</h1> <p>Control the state system on the minion.</p> <div class="section" id="state-caching"> <h2>State Caching</h2> <p>When a highstate is called, the minion automatically caches a copy of the last high data. If you then run a highstate with cache=True it will use that cached highdata and won't hit the fileserver except for <code class="docutils literal notranslate"><span class="pre">salt://</span></code> links in the states themselves.</p> <dl class="py function"> <h3 id="salt.modules.state.apply_"> salt.modules.state.apply_(mods=None, **kwargs)</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2015.5.0.</span></p> </div> <p>This function will call <a class="reference internal" href="#salt.modules.state.highstate" title="salt.modules.state.highstate"><code class="xref py py-mod docutils literal notranslate"><span class="pre">state.highstate</span></code></a> or <a class="reference internal" href="#salt.modules.state.sls" title="salt.modules.state.sls"><code class="xref py py-mod docutils literal notranslate"><span class="pre">state.sls</span></code></a> based on the arguments passed to this function. It exists as a more intuitive way of applying states.</p> <p class="rubric">APPLYING ALL STATES CONFIGURED IN TOP.SLS (A.K.A. <a class="reference internal" href="https://docs.saltproject.io/en/latest/topics/tutorials/states_pt1.html#running-highstate"><span class="std std-ref">HIGHSTATE</span></a>)</p> <p>To apply all configured states, simply run <code class="docutils literal notranslate"><span class="pre">state.apply</span></code>:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.apply</pre> <p>The following additional arguments are also accepted when applying all states configured in top.sls:</p> <dl> <dt>test</dt>
<dd>
<p>Run states in test-only (dry-run) mode</p> </dd> <dt>mock</dt>
<dd>
<p>The mock option allows for the state run to execute without actually calling any states. This then returns a mocked return which will show the requisite ordering as well as fully validate the state run.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2015.8.4.</span></p> </div> </dd> <dt>pillar</dt>
<dd>
<p>Custom Pillar values, passed as a dictionary of key-value pairs</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.apply stuff pillar='{"foo": "bar"}'</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Values passed this way will override Pillar values set via <code class="docutils literal notranslate"><span class="pre">pillar_roots</span></code> or an external Pillar source.</p> </div> </dd> <dt>exclude</dt>
<dd>
<p>Exclude specific states from execution. Accepts a list of sls names, a comma-separated string of sls names, or a list of dictionaries containing <code class="docutils literal notranslate"><span class="pre">sls</span></code> or <code class="docutils literal notranslate"><span class="pre">id</span></code> keys. Glob-patterns may be used to match multiple states.</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.apply exclude=bar,baz
salt '*' state.apply exclude=foo*
salt '*' state.apply exclude="[{'id': 'id_to_exclude'}, {'sls': 'sls_to_exclude'}]"</pre> </dd> <dt>queue<span class="classifier">False</span>
</dt>
<dd>
<p>Instead of failing immediately when another state run is in progress, queue the new state run to begin running once the other has finished.</p> <p>This option starts a new thread for each queued state run, so use this option sparingly.</p> </dd> <dt>localconfig</dt>
<dd>
<p>Optionally, instead of using the minion config, load minion opts from the file specified by this argument, and then merge them with the options from the minion config. This functionality allows for specific states to be run with their own custom minion configuration, including different pillars, file_roots, etc.</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.apply localconfig=/path/to/minion.yml</pre> </dd> </dl> <p class="rubric">APPLYING INDIVIDUAL SLS FILES (A.K.A. <a class="reference internal" href="#salt.modules.state.sls" title="salt.modules.state.sls"><code class="xref py py-func docutils literal notranslate"><span class="pre">STATE.SLS</span></code></a>)</p> <p>To apply individual SLS files, pass them as a comma-separated list:</p> <pre class="highlight-bash notranslate" data-language="bash"># Run the states configured in salt://stuff.sls (or salt://stuff/init.sls)
salt '*' state.apply stuff

# Run the states configured in salt://stuff.sls (or salt://stuff/init.sls)
# and salt://pkgs.sls (or salt://pkgs/init.sls).
salt '*' state.apply stuff,pkgs

# Run the states configured in a more deeply nested directory such as salt://my/organized/stuff.sls (or salt://my/organized/stuff/init.sls)
salt '*' state.apply my.organized.stuff</pre> <p>The following additional arguments are also accepted when applying individual SLS files:</p> <dl> <dt>test</dt>
<dd>
<p>Run states in test-only (dry-run) mode</p> </dd> <dt>mock</dt>
<dd>
<p>The mock option allows for the state run to execute without actually calling any states. This then returns a mocked return which will show the requisite ordering as well as fully validate the state run.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2015.8.4.</span></p> </div> </dd> <dt>pillar</dt>
<dd>
<p>Custom Pillar values, passed as a dictionary of key-value pairs</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.apply stuff pillar='{"foo": "bar"}'</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Values passed this way will override Pillar values set via <code class="docutils literal notranslate"><span class="pre">pillar_roots</span></code> or an external Pillar source.</p> </div> </dd> <dt>queue<span class="classifier">False</span>
</dt>
<dd>
<p>Instead of failing immediately when another state run is in progress, queue the new state run to begin running once the other has finished.</p> <p>This option starts a new thread for each queued state run, so use this option sparingly.</p> </dd> <dt>concurrent<span class="classifier">False</span>
</dt>
<dd>
<p>Execute state runs concurrently instead of serially</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This flag is potentially dangerous. It is designed for use when multiple state runs can safely be run at the same time. Do <em>not</em> use this flag for performance optimization.</p> </div> </dd> <dt>saltenv</dt>
<dd>
<p>Specify a salt fileserver environment to be used when applying states</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.17.0: </span>Argument name changed from <code class="docutils literal notranslate"><span class="pre">env</span></code> to <code class="docutils literal notranslate"><span class="pre">saltenv</span></code></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2014.7.0: </span>If no saltenv is specified, the minion config will be checked for an <code class="docutils literal notranslate"><span class="pre">environment</span></code> parameter and if found, it will be used. If none is found, <code class="docutils literal notranslate"><span class="pre">base</span></code> will be used. In prior releases, the minion config was not checked and <code class="docutils literal notranslate"><span class="pre">base</span></code> would always be assumed when the saltenv was not explicitly set.</p> </div> </dd> <dt>pillarenv</dt>
<dd>
<p>Specify a Pillar environment to be used when applying states. This can also be set in the minion config file using the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> option. When neither the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> minion config option nor this CLI argument is used, all Pillar environments will be merged together.</p> </dd> <dt>localconfig</dt>
<dd>
<p>Optionally, instead of using the minion config, load minion opts from the file specified by this argument, and then merge them with the options from the minion config. This functionality allows for specific states to be run with their own custom minion configuration, including different pillars, file_roots, etc.</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.apply stuff localconfig=/path/to/minion.yml</pre> </dd> <dt>sync_mods</dt>
<dd>
<p>If specified, the desired custom module types will be synced prior to running the SLS files:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.apply stuff sync_mods=states,modules
salt '*' state.apply stuff sync_mods=all</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This option is ignored when no SLS files are specified, as a <a class="reference internal" href="https://docs.saltproject.io/en/latest/topics/tutorials/states_pt1.html#running-highstate"><span class="std std-ref">highstate</span></a> automatically syncs all custom module types.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2017.7.8,2018.3.3,2019.2.0.</span></p> </div> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.check_request"> salt.modules.state.check_request(name=None)</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2015.5.0.</span></p> </div> <p>Return the state request information, if any</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.check_request</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.clear_cache"> salt.modules.state.clear_cache()</h3> <dd>
<p>Clear out cached state files, forcing even cache runs to refresh the cache on the next state execution.</p> <p>Remember that the state cache is completely disabled by default, this execution only applies if cache=True is used in states</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.clear_cache</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.clear_request"> salt.modules.state.clear_request(name=None)</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2015.5.0.</span></p> </div> <p>Clear out the state execution request without executing it</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.clear_request</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.disable"> salt.modules.state.disable(states)</h3> <dd>
<p>Disable state runs.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.disable highstate

salt '*' state.disable highstate,test.succeed_without_changes</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>To disable a state file from running provide the same name that would be passed in a state.sls call.</p> <p>salt '*' state.disable bind.config</p> </div> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.enable"> salt.modules.state.enable(states)</h3> <dd>
<p>Enable state function or sls run</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.enable highstate

salt '*' state.enable test.succeed_without_changes</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>To enable a state file from running provide the same name that would be passed in a state.sls call.</p> <p>salt '*' state.disable bind.config</p> </div> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.event"> salt.modules.state.event(tagmatch='*', count=- 1, quiet=False, sock_dir=None, pretty=False, node='minion')</h3> <dd>
<p>Watch Salt's event bus and block until the given tag is matched</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.3.0.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2019.2.0: </span><code class="docutils literal notranslate"><span class="pre">tagmatch</span></code> can now be either a glob or regular expression.</p> </div> <p>This is useful for utilizing Salt's event bus from shell scripts or for taking simple actions directly from the CLI.</p> <p>Enable debug logging to see ignored events.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li><p><strong>tagmatch</strong> -- the event is written to stdout for each tag that matches this glob or regular expression.</p></li> <li><p><strong>count</strong> -- this number is decremented for each event that matches the <code class="docutils literal notranslate"><span class="pre">tagmatch</span></code> parameter; pass <code class="docutils literal notranslate"><span class="pre">-1</span></code> to listen forever.</p></li> <li><p><strong>quiet</strong> -- do not print to stdout; just block</p></li> <li><p><strong>sock_dir</strong> -- path to the Salt master's event socket file.</p></li> <li><p><strong>pretty</strong> -- Output the JSON all on a single line if <code class="docutils literal notranslate"><span class="pre">False</span></code> (useful for shell tools); pretty-print the JSON output if <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li> <li><p><strong>node</strong> -- Watch the minion-side or master-side event bus.</p></li> </ul> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt-call --local state.event pretty=True</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.get_pauses"> salt.modules.state.get_pauses(jid=None)</h3> <dd>
<p>Get a report on all of the currently paused state runs and pause run settings. Optionally send in a jid if you only desire to see a single pause data set.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.high"> salt.modules.state.high(data, test=None, queue=False, **kwargs)</h3> <dd>
<p>Execute the compound calls stored in a single set of high data</p> <p>This function is mostly intended for testing the state system and is not likely to be needed in everyday usage.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.high '{"vim": {"pkg": ["installed"]}}'</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.highstate"> salt.modules.state.highstate(test=None, queue=False, **kwargs)</h3> <dd>
<p>Retrieve the state data from the salt master for this minion and execute it</p> <dl> <dt>test</dt>
<dd>
<p>Run states in test-only (dry-run) mode</p> </dd> <dt>pillar</dt>
<dd>
<p>Custom Pillar values, passed as a dictionary of key-value pairs</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.highstate stuff pillar='{"foo": "bar"}'</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Values passed this way will override Pillar values set via <code class="docutils literal notranslate"><span class="pre">pillar_roots</span></code> or an external Pillar source.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.3.0: </span>GPG-encrypted CLI Pillar data is now supported via the GPG renderer. See <a class="reference internal" href="../../renderers/all/salt.renderers.gpg.html#encrypted-cli-pillar-data"><span class="std std-ref">here</span></a> for details.</p> </div> </dd> <dt>pillar_enc</dt>
<dd>
<p>Specify which renderer to use to decrypt encrypted data located within the <code class="docutils literal notranslate"><span class="pre">pillar</span></code> value. Currently, only <code class="docutils literal notranslate"><span class="pre">gpg</span></code> is supported.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.3.0.</span></p> </div> </dd> <dt>exclude</dt>
<dd>
<p>Exclude specific states from execution. Accepts a list of sls names, a comma-separated string of sls names, or a list of dictionaries containing <code class="docutils literal notranslate"><span class="pre">sls</span></code> or <code class="docutils literal notranslate"><span class="pre">id</span></code> keys. Glob-patterns may be used to match multiple states.</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.highstate exclude=bar,baz
salt '*' state.highstate exclude=foo*
salt '*' state.highstate exclude="[{'id': 'id_to_exclude'}, {'sls': 'sls_to_exclude'}]"</pre> </dd> <dt>saltenv</dt>
<dd>
<p>Specify a salt fileserver environment to be used when applying states</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.17.0: </span>Argument name changed from <code class="docutils literal notranslate"><span class="pre">env</span></code> to <code class="docutils literal notranslate"><span class="pre">saltenv</span></code>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2014.7.0: </span>If no saltenv is specified, the minion config will be checked for a <code class="docutils literal notranslate"><span class="pre">saltenv</span></code> parameter and if found, it will be used. If none is found, <code class="docutils literal notranslate"><span class="pre">base</span></code> will be used. In prior releases, the minion config was not checked and <code class="docutils literal notranslate"><span class="pre">base</span></code> would always be assumed when the saltenv was not explicitly set.</p> </div> </dd> <dt>pillarenv</dt>
<dd>
<p>Specify a Pillar environment to be used when applying states. This can also be set in the minion config file using the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> option. When neither the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> minion config option nor this CLI argument is used, all Pillar environments will be merged together.</p> </dd> <dt>queue<span class="classifier">False</span>
</dt>
<dd>
<p>Instead of failing immediately when another state run is in progress, queue the new state run to begin running once the other has finished.</p> <p>This option starts a new thread for each queued state run, so use this option sparingly.</p> </dd> <dt>localconfig</dt>
<dd>
<p>Optionally, instead of using the minion config, load minion opts from the file specified by this argument, and then merge them with the options from the minion config. This functionality allows for specific states to be run with their own custom minion configuration, including different pillars, file_roots, etc.</p> </dd> <dt>mock</dt>
<dd>
<p>The mock option allows for the state run to execute without actually calling any states. This then returns a mocked return which will show the requisite ordering as well as fully validate the state run.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2015.8.4.</span></p> </div> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.highstate

salt '*' state.highstate whitelist=sls1_to_run,sls2_to_run
salt '*' state.highstate exclude=sls_to_exclude
salt '*' state.highstate exclude="[{'id': 'id_to_exclude'}, {'sls': 'sls_to_exclude'}]"

salt '*' state.highstate pillar="{foo: 'Foo!', bar: 'Bar!'}"</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.id_exists"> salt.modules.state.id_exists(ids, mods, test=None, queue=False, **kwargs)</h3> <dd>
<p>Tests for the existence of a specific ID or list of IDs within the specified SLS file(s). Similar to <a class="reference internal" href="#salt.modules.state.sls_exists" title="salt.modules.state.sls_exists"><code class="xref py py-func docutils literal notranslate"><span class="pre">state.sls_exists</span></code></a>, returns True or False. The default environment is base``, use <code class="docutils literal notranslate"><span class="pre">saltenv</span></code> to specify a different environment.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2019.2.0.</span></p> </div> <dl class="simple"> <dt>saltenv</dt>
<dd>
<p>Specify a salt fileserver environment from which to look for the SLS files specified in the <code class="docutils literal notranslate"><span class="pre">mods</span></code> argument</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.id_exists create_myfile,update_template filestate saltenv=dev</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.list_disabled"> salt.modules.state.list_disabled()</h3> <dd>
<p>List the states which are currently disabled</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.list_disabled</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.low"> salt.modules.state.low(data, queue=False, **kwargs)</h3> <dd>
<p>Execute a single low data call</p> <p>This function is mostly intended for testing the state system and is not likely to be needed in everyday usage.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.low '{"state": "pkg", "fun": "installed", "name": "vi"}'</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.orchestrate"> salt.modules.state.orchestrate(mods, saltenv='base', test=None, exclude=None, pillar=None, pillarenv=None)</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.0.</span></p> </div> <p>Execute the orchestrate runner from a masterless minion.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>More Orchestrate documentation</p> <ul class="simple"> <li><p><a class="reference internal" href="https://docs.saltproject.io/en/latest/topics/orchestrate/orchestrate_runner.html#orchestrate-runner"><span class="std std-ref">Full Orchestrate Tutorial</span></a></p></li> <li><p>Docs for the salt state module <a class="reference internal" href="../../states/all/salt.states.saltmod.html#module-salt.states.saltmod" title="salt.states.saltmod"><code class="xref py py-mod docutils literal notranslate"><span class="pre">salt.states.saltmod</span></code></a></p></li> </ul> </div> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt-call --local state.orchestrate webserver
salt-call --local state.orchestrate webserver saltenv=dev test=True
salt-call --local state.orchestrate webserver saltenv=dev pillarenv=aws</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.pause"> salt.modules.state.pause(jid, state_id=None, duration=None)</h3> <dd>
<p>Set up a state id pause, this instructs a running state to pause at a given state id. This needs to pass in the jid of the running state and can optionally pass in a duration in seconds. If a state_id is not passed then the jid referenced will be paused at the beginning of the next state run.</p> <p>The given state id is the id got a given state execution, so given a state that looks like this:</p> <pre class="highlight-yaml notranslate" data-language="yaml">vim:
  pkg.installed: []</pre> <p>The state_id to pass to <cite>pause</cite> is <cite>vim</cite></p> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.pause 20171130110407769519
salt '*' state.pause 20171130110407769519 vim
salt '*' state.pause 20171130110407769519 vim 20</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.pkg"> salt.modules.state.pkg(pkg_path, pkg_sum, hash_type, test=None, **kwargs)</h3> <dd>
<p>Execute a packaged state run, the packaged state run will exist in a tarball available locally. This packaged state can be generated using salt-ssh.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.pkg /tmp/salt_state.tgz 760a9353810e36f6d81416366fc426dc md5</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.request"> salt.modules.state.request(mods=None, **kwargs)</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2015.5.0.</span></p> </div> <p>Request that the local admin execute a state run via <cite>salt-call state.run_request</cite>. All arguments match those of state.apply.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.request
salt '*' state.request stuff
salt '*' state.request stuff,pkgs</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.resume"> salt.modules.state.resume(jid, state_id=None)</h3> <dd>
<p>Remove a pause from a jid, allowing it to continue. If the state_id is not specified then the a general pause will be resumed.</p> <p>The given state_id is the id got a given state execution, so given a state that looks like this:</p> <pre class="highlight-yaml notranslate" data-language="yaml">vim:
  pkg.installed: []</pre> <p>The state_id to pass to <cite>rm_pause</cite> is <cite>vim</cite></p> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.resume 20171130110407769519
salt '*' state.resume 20171130110407769519 vim</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.run_request"> salt.modules.state.run_request(name='default', **kwargs)</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2015.5.0.</span></p> </div> <p>Execute the pending state request</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.run_request</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.running"> salt.modules.state.running(concurrent=False)</h3> <dd>
<p>Return a list of strings that contain state return data if a state function is already running. This function is used to prevent multiple state calls from being run at the same time.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.running</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.show_highstate"> salt.modules.state.show_highstate(queue=False, **kwargs)</h3> <dd>
<p>Retrieve the highstate data from the salt master and display it</p> <p>Custom Pillar data can be passed with the <code class="docutils literal notranslate"><span class="pre">pillar</span></code> kwarg.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.show_highstate</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.show_low_sls"> salt.modules.state.show_low_sls(mods, test=None, queue=False, **kwargs)</h3> <dd>
<p>Display the low data from a specific sls. The default environment is <code class="docutils literal notranslate"><span class="pre">base</span></code>, use <code class="docutils literal notranslate"><span class="pre">saltenv</span></code> to specify a different environment.</p> <dl> <dt>saltenv</dt>
<dd>
<p>Specify a salt fileserver environment to be used when applying states</p> </dd> <dt>pillar</dt>
<dd>
<p>Custom Pillar values, passed as a dictionary of key-value pairs</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.show_low_sls stuff pillar='{"foo": "bar"}'</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Values passed this way will override Pillar values set via <code class="docutils literal notranslate"><span class="pre">pillar_roots</span></code> or an external Pillar source.</p> </div> </dd> <dt>pillarenv</dt>
<dd>
<p>Specify a Pillar environment to be used when applying states. This can also be set in the minion config file using the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> option. When neither the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> minion config option nor this CLI argument is used, all Pillar environments will be merged together.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.show_low_sls foo
salt '*' state.show_low_sls foo saltenv=dev</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.show_lowstate"> salt.modules.state.show_lowstate(queue=False, **kwargs)</h3> <dd>
<p>List out the low data that will be applied to this minion</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.show_lowstate</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.show_sls"> salt.modules.state.show_sls(mods, test=None, queue=False, **kwargs)</h3> <dd>
<p>Display the state data from a specific sls or list of sls files on the master. The default environment is <code class="docutils literal notranslate"><span class="pre">base</span></code>, use <code class="docutils literal notranslate"><span class="pre">saltenv</span></code> to specify a different environment.</p> <p>This function does not support topfiles. For <code class="docutils literal notranslate"><span class="pre">top.sls</span></code> please use <code class="docutils literal notranslate"><span class="pre">show_top</span></code> instead.</p> <p>Custom Pillar data can be passed with the <code class="docutils literal notranslate"><span class="pre">pillar</span></code> kwarg.</p> <dl class="simple"> <dt>saltenv</dt>
<dd>
<p>Specify a salt fileserver environment to be used when applying states</p> </dd> <dt>pillarenv</dt>
<dd>
<p>Specify a Pillar environment to be used when applying states. This can also be set in the minion config file using the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> option. When neither the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> minion config option nor this CLI argument is used, all Pillar environments will be merged together.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.show_sls core,edit.vim saltenv=dev</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.show_state_usage"> salt.modules.state.show_state_usage(queue=False, **kwargs)</h3> <dd>
<p>Retrieve the highstate data from the salt master to analyse used and unused states</p> <p>Custom Pillar data can be passed with the <code class="docutils literal notranslate"><span class="pre">pillar</span></code> kwarg.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.show_state_usage</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.show_states"> salt.modules.state.show_states(queue=False, **kwargs)</h3> <dd>
<p>Returns the list of states that will be applied on highstate.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.show_states</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2019.2.0.</span></p> </div> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.show_top"> salt.modules.state.show_top(queue=False, **kwargs)</h3> <dd>
<p>Return the top data that the minion will use for a highstate</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.show_top</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.single"> salt.modules.state.single(fun, name, test=None, queue=False, **kwargs)</h3> <dd>
<p>Execute a single state function with the named kwargs, returns False if insufficient data is sent to the command</p> <p>By default, the values of the kwargs will be parsed as YAML. So, you can specify lists values, or lists of single entry key-value maps, as you would in a YAML salt file. Alternatively, JSON format of keyword values is also supported.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.single pkg.installed name=vim</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.sls"> salt.modules.state.sls(mods, test=None, exclude=None, queue=False, sync_mods=None, **kwargs)</h3> <dd>
<p>Execute the states in one or more SLS files</p> <dl> <dt>test</dt>
<dd>
<p>Run states in test-only (dry-run) mode</p> </dd> <dt>pillar</dt>
<dd>
<p>Custom Pillar values, passed as a dictionary of key-value pairs</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.sls stuff pillar='{"foo": "bar"}'</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Values passed this way will override existing Pillar values set via <code class="docutils literal notranslate"><span class="pre">pillar_roots</span></code> or an external Pillar source. Pillar values that are not included in the kwarg will not be overwritten.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.3.0: </span>GPG-encrypted CLI Pillar data is now supported via the GPG renderer. See <a class="reference internal" href="../../renderers/all/salt.renderers.gpg.html#encrypted-cli-pillar-data"><span class="std std-ref">here</span></a> for details.</p> </div> </dd> <dt>pillar_enc</dt>
<dd>
<p>Specify which renderer to use to decrypt encrypted data located within the <code class="docutils literal notranslate"><span class="pre">pillar</span></code> value. Currently, only <code class="docutils literal notranslate"><span class="pre">gpg</span></code> is supported.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.3.0.</span></p> </div> </dd> <dt>exclude</dt>
<dd>
<p>Exclude specific states from execution. Accepts a list of sls names, a comma-separated string of sls names, or a list of dictionaries containing <code class="docutils literal notranslate"><span class="pre">sls</span></code> or <code class="docutils literal notranslate"><span class="pre">id</span></code> keys. Glob-patterns may be used to match multiple states.</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.sls foo,bar,baz exclude=bar,baz
salt '*' state.sls foo,bar,baz exclude=ba*
salt '*' state.sls foo,bar,baz exclude="[{'id': 'id_to_exclude'}, {'sls': 'sls_to_exclude'}]"</pre> </dd> <dt>queue<span class="classifier">False</span>
</dt>
<dd>
<p>Instead of failing immediately when another state run is in progress, queue the new state run to begin running once the other has finished.</p> <p>This option starts a new thread for each queued state run, so use this option sparingly.</p> </dd> <dt>concurrent<span class="classifier">False</span>
</dt>
<dd>
<p>Execute state runs concurrently instead of serially</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This flag is potentially dangerous. It is designed for use when multiple state runs can safely be run at the same time. Do <em>not</em> use this flag for performance optimization.</p> </div> </dd> <dt>saltenv</dt>
<dd>
<p>Specify a salt fileserver environment to be used when applying states</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.17.0: </span>Argument name changed from <code class="docutils literal notranslate"><span class="pre">env</span></code> to <code class="docutils literal notranslate"><span class="pre">saltenv</span></code>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2014.7.0: </span>If no saltenv is specified, the minion config will be checked for an <code class="docutils literal notranslate"><span class="pre">environment</span></code> parameter and if found, it will be used. If none is found, <code class="docutils literal notranslate"><span class="pre">base</span></code> will be used. In prior releases, the minion config was not checked and <code class="docutils literal notranslate"><span class="pre">base</span></code> would always be assumed when the saltenv was not explicitly set.</p> </div> </dd> <dt>pillarenv</dt>
<dd>
<p>Specify a Pillar environment to be used when applying states. This can also be set in the minion config file using the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> option. When neither the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> minion config option nor this CLI argument is used, all Pillar environments will be merged together.</p> </dd> <dt>localconfig</dt>
<dd>
<p>Optionally, instead of using the minion config, load minion opts from the file specified by this argument, and then merge them with the options from the minion config. This functionality allows for specific states to be run with their own custom minion configuration, including different pillars, file_roots, etc.</p> </dd> <dt>mock</dt>
<dd>
<p>The mock option allows for the state run to execute without actually calling any states. This then returns a mocked return which will show the requisite ordering as well as fully validate the state run.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2015.8.4.</span></p> </div> </dd> <dt>sync_mods</dt>
<dd>
<p>If specified, the desired custom module types will be synced prior to running the SLS files:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.sls stuff sync_mods=states,modules
salt '*' state.sls stuff sync_mods=all</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2017.7.8,2018.3.3,2019.2.0.</span></p> </div> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash"># Run the states configured in salt://example.sls (or salt://example/init.sls)
salt '*' state.apply example

# Run the states configured in salt://core.sls (or salt://core/init.sls)
# and salt://edit/vim.sls (or salt://edit/vim/init.sls)
salt '*' state.sls core,edit.vim

# Run the states configured in a more deeply nested directory such as salt://my/nested/state.sls (or salt://my/nested/state/init.sls)
salt '*' state.sls my.nested.state

salt '*' state.sls core exclude="[{'id': 'id_to_exclude'}, {'sls': 'sls_to_exclude'}]"
salt '*' state.sls myslsfile pillar="{foo: 'Foo!', bar: 'Bar!'}"</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.sls_exists"> salt.modules.state.sls_exists(mods, test=None, queue=False, **kwargs)</h3> <dd>
<p>Tests for the existence the of a specific SLS or list of SLS files on the master. Similar to <a class="reference internal" href="#salt.modules.state.show_sls" title="salt.modules.state.show_sls"><code class="xref py py-func docutils literal notranslate"><span class="pre">state.show_sls</span></code></a>, rather than returning state details, returns True or False. The default environment is <code class="docutils literal notranslate"><span class="pre">base</span></code>, use <code class="docutils literal notranslate"><span class="pre">saltenv</span></code> to specify a different environment.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2019.2.0.</span></p> </div> <dl class="simple"> <dt>saltenv</dt>
<dd>
<p>Specify a salt fileserver environment from which to look for the SLS files specified in the <code class="docutils literal notranslate"><span class="pre">mods</span></code> argument</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.sls_exists core,edit.vim saltenv=dev</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.sls_id"> salt.modules.state.sls_id(id_, mods, test=None, queue=False, **kwargs)</h3> <dd>
<p>Call a single ID from the named module(s) and handle all requisites</p> <p>The state ID comes <em>before</em> the module ID(s) on the command line.</p> <dl class="simple"> <dt>id</dt>
<dd>
<p>ID to call</p> </dd> <dt>mods</dt>
<dd>
<p>Comma-delimited list of modules to search for given id and its requisites</p> </dd> </dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 2014.7.0.</span></p> </div> <dl> <dt>saltenv<span class="classifier">base</span>
</dt>
<dd>
<p>Specify a salt fileserver environment to be used when applying states</p> </dd> <dt>pillarenv</dt>
<dd>
<p>Specify a Pillar environment to be used when applying states. This can also be set in the minion config file using the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> option. When neither the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> minion config option nor this CLI argument is used, all Pillar environments will be merged together.</p> </dd> <dt>pillar</dt>
<dd>
<p>Custom Pillar values, passed as a dictionary of key-value pairs</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.sls_id my_state my_module pillar='{"foo": "bar"}'</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Values passed this way will override existing Pillar values set via <code class="docutils literal notranslate"><span class="pre">pillar_roots</span></code> or an external Pillar source. Pillar values that are not included in the kwarg will not be overwritten.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2018.3.0.</span></p> </div> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.sls_id my_state my_module

salt '*' state.sls_id my_state my_module,a_common_module</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.soft_kill"> salt.modules.state.soft_kill(jid, state_id=None)</h3> <dd>
<p>Set up a state run to die before executing the given state id, this instructs a running state to safely exit at a given state id. This needs to pass in the jid of the running state. If a state_id is not passed then the jid referenced will be safely exited at the beginning of the next state run.</p> <p>The given state id is the id got a given state execution, so given a state that looks like this:</p> <pre class="highlight-yaml notranslate" data-language="yaml">vim:
  pkg.installed: []</pre> <p>The state_id to pass to <cite>soft_kill</cite> is <cite>vim</cite></p> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.soft_kill 20171130110407769519
salt '*' state.soft_kill 20171130110407769519 vim</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.template"> salt.modules.state.template(tem, queue=False, **kwargs)</h3> <dd>
<p>Execute the information stored in a template file on the minion.</p> <p>This function does not ask a master for a SLS file to render but instead directly processes the file at the provided path on the minion.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.template '&lt;Path to template on the minion&gt;'</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.template_str"> salt.modules.state.template_str(tem, queue=False, **kwargs)</h3> <dd>
<p>Execute the information stored in a string from an sls template</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.template_str '&lt;Template String&gt;'</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.test"> salt.modules.state.test(*args, **kwargs)</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 3001.</span></p> </div> <p>Alias for <cite>state.apply</cite> with the kwarg <cite>test</cite> forced to <cite>True</cite>.</p> <p>This is a nicety to avoid the need to type out <cite>test=True</cite> and the possibility of a typo causing changes you do not intend.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.state.top"> salt.modules.state.top(topfn, test=None, queue=False, **kwargs)</h3> <dd>
<p>Execute a specific top file instead of the default. This is useful to apply configurations from a different environment (for example, dev or prod), without modifying the default top file.</p> <dl> <dt>queue<span class="classifier">False</span>
</dt>
<dd>
<p>Instead of failing immediately when another state run is in progress, queue the new state run to begin running once the other has finished.</p> <p>This option starts a new thread for each queued state run, so use this option sparingly.</p> </dd> <dt>saltenv</dt>
<dd>
<p>Specify a salt fileserver environment to be used when applying states</p> </dd> <dt>pillarenv</dt>
<dd>
<p>Specify a Pillar environment to be used when applying states. This can also be set in the minion config file using the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> option. When neither the <a class="reference internal" href="https://docs.saltproject.io/en/latest/ref/configuration/minion.html#std-conf_minion-pillarenv"><code class="xref std std-conf_minion docutils literal notranslate"><span class="pre">pillarenv</span></code></a> minion config option nor this CLI argument is used, all Pillar environments will be merged together.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2017.7.0.</span></p> </div> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' state.top reverse_top.sls
salt '*' state.top prod_top.sls exclude=sls_to_exclude
salt '*' state.top dev_top.sls exclude="[{'id': 'id_to_exclude'}, {'sls': 'sls_to_exclude'}]"</pre> </dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 SaltStack.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.saltproject.io/en/latest/ref/modules/all/salt.modules.state.html" class="_attribution-link">https://docs.saltproject.io/en/latest/ref/modules/all/salt.modules.state.html</a>
  </p>
</div>
