<h1>salt.modules.nftables</h1> <p>Support for nftables</p> <dl class="py function"> <h3 id="salt.modules.nftables.append"> salt.modules.nftables.append(table='filter', chain=None, rule=None, family='ipv4')</h3> <dd>
<p>Append a rule to the specified table &amp; chain.</p> <dl class="simple"> <dt>This function accepts a rule in a standard nftables command format,</dt>
<dd>
<p>starting with the chain. Trying to force users to adapt to a new method of creating rules would be irritating at best, and we already have a parser that can handle it.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.append filter input \
    rule='tcp dport 22 log accept'

IPv6:
salt '*' nftables.append filter input \
    rule='tcp dport 22 log accept' \
    family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.build_rule"> salt.modules.nftables.build_rule(table=None, chain=None, command=None, position='', full=None, family='ipv4', **kwargs)</h3> <dd>
<p>Build a well-formatted nftables rule based on kwargs. A <cite>table</cite> and <cite>chain</cite> are not required, unless <cite>full</cite> is True.</p> <p>If <cite>full</cite> is <cite>True</cite>, then <cite>table</cite>, <cite>chain</cite> and <cite>command</cite> are required. <cite>command</cite> may be specified as either insert, append, or delete. This will return the nftables command, exactly as it would be used from the command line.</p> <p>If a position is required (as with <cite>insert</cite> or <cite>delete</cite>), it may be specified as <cite>position</cite>. This will only be useful if <cite>full</cite> is True.</p> <p>If <cite>connstate</cite> is passed in, it will automatically be changed to <cite>state</cite>.</p> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.build_rule match=state \
    connstate=RELATED,ESTABLISHED jump=ACCEPT
salt '*' nftables.build_rule filter input command=insert position=3 \
    full=True match=state state=related,established jump=accept

IPv6:
salt '*' nftables.build_rule match=state \
    connstate=related,established jump=accept \
    family=ipv6
salt '*' nftables.build_rule filter input command=insert position=3 \
    full=True match=state state=related,established jump=accept \
    family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.check"> salt.modules.nftables.check(table='filter', chain=None, rule=None, family='ipv4')</h3> <dd>
<p>Check for the existence of a rule in the table and chain</p> <dl class="simple"> <dt>This function accepts a rule in a standard nftables command format,</dt>
<dd>
<p>starting with the chain. Trying to force users to adapt to a new method of creating rules would be irritating at best, and we already have a parser that can handle it.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.check filter input \
    rule='tcp dport 22 log accept'

IPv6:
salt '*' nftables.check filter input \
    rule='tcp dport 22 log accept' \
    family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.check_chain"> salt.modules.nftables.check_chain(table='filter', chain=None, family='ipv4')</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2014.7.0.</span></p> </div> <p>Check for the existence of a chain in the table</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.check_chain filter input

IPv6:
salt '*' nftables.check_chain filter input family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.check_table"> salt.modules.nftables.check_table(table=None, family='ipv4')</h3> <dd>
<p>Check for the existence of a table</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.check_table nat</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.delete"> salt.modules.nftables.delete(table, chain=None, position=None, rule=None, family='ipv4')</h3> <dd>
<dl class="simple"> <dt>Delete a rule from the specified table &amp; chain, specifying either the rule</dt>
<dd>
<p>in its entirety, or the rule's position in the chain.</p> </dd> <dt>This function accepts a rule in a standard nftables command format,</dt>
<dd>
<p>starting with the chain. Trying to force users to adapt to a new method of creating rules would be irritating at best, and we already have a parser that can handle it.</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.delete filter input position=3

salt '*' nftables.delete filter input \
    rule='tcp dport 22 log accept'

IPv6:
salt '*' nftables.delete filter input position=3 family=ipv6

salt '*' nftables.delete filter input \
    rule='tcp dport 22 log accept' \
    family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.delete_chain"> salt.modules.nftables.delete_chain(table='filter', chain=None, family='ipv4')</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2014.7.0.</span></p> </div> <p>Delete the chain from the specified table.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.delete_chain filter input

salt '*' nftables.delete_chain filter foo

IPv6:
salt '*' nftables.delete_chain filter input family=ipv6

salt '*' nftables.delete_chain filter foo family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.delete_table"> salt.modules.nftables.delete_table(table, family='ipv4')</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2014.7.0.</span></p> </div> <p>Create new custom table.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.delete_table filter

IPv6:
salt '*' nftables.delete_table filter family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.flush"> salt.modules.nftables.flush(table='filter', chain='', family='ipv4')</h3> <dd>
<p>Flush the chain in the specified table, flush all chains in the specified table if chain is not specified.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.flush filter

salt '*' nftables.flush filter input

IPv6:
salt '*' nftables.flush filter input family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.get_policy"> salt.modules.nftables.get_policy(table='filter', chain=None, family='ipv4')</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 3002.</span></p> </div> <p>Return the current policy for the specified table/chain</p> <dl class="simple"> <dt>table</dt>
<dd>
<p>Name of the table containing the chain to check</p> </dd> <dt>chain</dt>
<dd>
<p>Name of the chain to get the policy for</p> </dd> <dt>family</dt>
<dd>
<p>Networking family, either ipv4 or ipv6</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.get_policy filter input

IPv6:
salt '*' nftables.get_policy filter input family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.get_rule_handle"> salt.modules.nftables.get_rule_handle(table='filter', chain=None, rule=None, family='ipv4')</h3> <dd>
<p>Get the handle for a particular rule</p> <dl class="simple"> <dt>This function accepts a rule in a standard nftables command format,</dt>
<dd>
<p>starting with the chain. Trying to force users to adapt to a new method of creating rules would be irritating at best, and we already have a parser that can handle it.</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.get_rule_handle filter input \
    rule='tcp dport 22 log accept'

IPv6:
salt '*' nftables.get_rule_handle filter input \
    rule='tcp dport 22 log accept' \
    family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.get_rules"> salt.modules.nftables.get_rules(family='ipv4')</h3> <dd>
<p>Return a data structure of the current, in-memory rules</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.get_rules

salt '*' nftables.get_rules family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.get_rules_json"> salt.modules.nftables.get_rules_json(family='ipv4')</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 3002.</span></p> </div> <p>Return a list of dictionaries comprising the current, in-memory rules</p> <dl class="simple"> <dt>family</dt>
<dd>
<p>Networking family, either ipv4 or ipv6</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.get_rules_json

salt '*' nftables.get_rules_json family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.get_saved_rules"> salt.modules.nftables.get_saved_rules(conf_file=None)</h3> <dd>
<p>Return a data structure of the rules in the conf file</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.get_saved_rules</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.insert"> salt.modules.nftables.insert(table='filter', chain=None, position=None, rule=None, family='ipv4')</h3> <dd>
<p>Insert a rule into the specified table &amp; chain, at the specified position.</p> <p>If position is not specified, rule will be inserted in first position.</p> <dl class="simple"> <dt>This function accepts a rule in a standard nftables command format,</dt>
<dd>
<p>starting with the chain. Trying to force users to adapt to a new method of creating rules would be irritating at best, and we already have a parser that can handle it.</p> </dd> </dl> <p>CLI Examples:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.insert filter input \
    rule='tcp dport 22 log accept'

salt '*' nftables.insert filter input position=3 \
    rule='tcp dport 22 log accept'

IPv6:
salt '*' nftables.insert filter input \
    rule='tcp dport 22 log accept' \
    family=ipv6

salt '*' nftables.insert filter input position=3 \
    rule='tcp dport 22 log accept' \
    family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.list_tables"> salt.modules.nftables.list_tables(family='ipv4')</h3> <dd>
<p>Return a data structure of the current, in-memory tables</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.list_tables

salt '*' nftables.list_tables family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.new_chain"> salt.modules.nftables.new_chain(table='filter', chain=None, table_type=None, hook=None, priority=None, family='ipv4')</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2014.7.0.</span></p> </div> <p>Create new chain to the specified table.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.new_chain filter input

salt '*' nftables.new_chain filter input \
        table_type=filter hook=input priority=0

salt '*' nftables.new_chain filter foo

IPv6:
salt '*' nftables.new_chain filter input family=ipv6

salt '*' nftables.new_chain filter input \
        table_type=filter hook=input priority=0 family=ipv6

salt '*' nftables.new_chain filter foo family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.new_table"> salt.modules.nftables.new_table(table, family='ipv4')</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2014.7.0.</span></p> </div> <p>Create new custom table.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.new_table filter

IPv6:
salt '*' nftables.new_table filter family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.save"> salt.modules.nftables.save(filename=None, family='ipv4')</h3> <dd>
<div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3002.</span></p> </div> <p>Save the current in-memory rules to disk. On systems where /etc/nftables is a directory, a file named salt-all-in-one.nft will be dropped inside by default. The main nftables configuration will need to include this file.</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.save /etc/nftables</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.set_policy"> salt.modules.nftables.set_policy(table='filter', chain=None, policy=None, family='ipv4')</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 3002.</span></p> </div> <p>Set the current policy for the specified table/chain. This only works on chains with an existing base chain.</p> <dl class="simple"> <dt>table</dt>
<dd>
<p>Name of the table containing the chain to modify</p> </dd> <dt>chain</dt>
<dd>
<p>Name of the chain to set the policy for</p> </dd> <dt>policy</dt>
<dd>
<p>accept or drop</p> </dd> <dt>family</dt>
<dd>
<p>Networking family, either ipv4 or ipv6</p> </dd> </dl> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.set_policy filter input accept

IPv6:
salt '*' nftables.set_policy filter input accept family=ipv6</pre> </dd>
</dl> <dl class="py function"> <h3 id="salt.modules.nftables.version"> salt.modules.nftables.version()</h3> <dd>
<p>Return version from nftables --version</p> <p>CLI Example:</p> <pre class="highlight-bash notranslate" data-language="bash">salt '*' nftables.version</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 SaltStack.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.saltproject.io/en/latest/ref/modules/all/salt.modules.nftables.html" class="_attribution-link">https://docs.saltproject.io/en/latest/ref/modules/all/salt.modules.nftables.html</a>
  </p>
</div>
