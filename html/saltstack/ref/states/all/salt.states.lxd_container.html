<h1>salt.states.lxd_container</h1> <p>Manage LXD containers.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2019.2.0.</span></p> </div> <dl class="field-list simple"> <dt class="field-odd">maintainer</dt> <dd class="field-odd">
<p>Ren√© Jochum &lt;<a class="reference external" href="mailto:rene%40jochums.at.html">rene<span>@</span>jochums<span>.</span>at</a>&gt;</p> </dd> <dt class="field-even">maturity</dt> <dd class="field-even">
<p>new</p> </dd> <dt class="field-odd">depends</dt> <dd class="field-odd">
<p>python-pylxd</p> </dd> <dt class="field-even">platform</dt> <dd class="field-even">
<p>Linux</p> </dd> </dl> <dl class="py function"> <h3 id="salt.states.lxd_container.absent"> salt.states.lxd_container.absent(name, stop=False, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Ensure a LXD container is not present, destroying it if present</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the container to destroy</p> </dd> <dt>stop :</dt>
<dd>
<p>stop before destroying default: false</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Zertifikate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.lxd_container.frozen"> salt.states.lxd_container.frozen(name, start=True, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Ensure a LXD container is frozen, start and freeze it if start is true</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the container to freeze</p> </dd> <dt>start :</dt>
<dd>
<p>start and freeze it</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Zertifikate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.lxd_container.migrated"> salt.states.lxd_container.migrated(name, remote_addr, cert, key, verify_cert, src_remote_addr, stop_and_start=False, src_cert=None, src_key=None, src_verify_cert=None)</h3> <dd>
<p>Ensure a container is migrated to another host</p> <p>If the container is running, it either must be shut down first (use stop_and_start=True) or criu must be installed on the source and destination machines.</p> <p>For this operation both certs need to be authenticated, use <code class="xref py py-mod docutils literal notranslate"><span class="pre">lxd.authenticate</span> <span class="pre">&lt;salt.states.lxd.authenticate</span></code> to authenticate your cert(s).</p> <dl> <dt>name :</dt>
<dd>
<p>The container to migrate</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to the destination remote Server</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Zertifikate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> <dt>src_remote_addr :</dt>
<dd>
<p>An URL to the source remote Server</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>stop_and_start:</dt>
<dd>
<p>Stop before migrating and start after</p> </dd> <dt>src_cert :</dt>
<dd>
<p>PEM Formatted SSL Zertifikate, if None we copy "cert"</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>src_key :</dt>
<dd>
<p>PEM Formatted SSL Key, if None we copy "key"</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>src_verify_cert :</dt>
<dd>
<p>Wherever to verify the cert, if None we copy "verify_cert"</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.lxd_container.present"> salt.states.lxd_container.present(name, running=None, source=None, profiles=None, config=None, devices=None, architecture='x86_64', ephemeral=False, restart_on_change=False, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Create the named container if it does not exist</p> <dl> <dt>name</dt>
<dd>
<p>The name of the container to be created</p> </dd> <dt>running<span class="classifier">None</span>
</dt>
<dd>
<ul class="simple"> <li><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, ensure that the container is running</p></li> <li><p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, ensure that the container is stopped</p></li> <li><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, do nothing with regards to the running state of the container</p></li> </ul> </dd> <dt>source<span class="classifier">None</span>
</dt>
<dd>
<p>Can be either a string containing an image alias:</p> <pre class="highlight-none notranslate" data-language="none">"xenial/amd64"</pre> <p>or an dict with type "image" with alias:</p> <pre class="highlight-python notranslate" data-language="python">{"type": "image",
 "alias": "xenial/amd64"}</pre> <p>or image with "fingerprint":</p> <pre class="highlight-python notranslate" data-language="python">{"type": "image",
 "fingerprint": "SHA-256"}</pre> <p>or image with "properties":</p> <pre class="highlight-python notranslate" data-language="python">{"type": "image",
 "properties": {
    "os": "ubuntu",
    "release": "14.04",
    "architecture": "x86_64"
 }}</pre> <p>or none:</p> <pre class="highlight-python notranslate" data-language="python">{"type": "none"}</pre> <p>or copy:</p> <pre class="highlight-python notranslate" data-language="python">{"type": "copy",
 "source": "my-old-container"}</pre> </dd> <dt>profiles<span class="classifier">['default']</span>
</dt>
<dd>
<p>List of profiles to apply on this container</p> </dd> <dt>config :</dt>
<dd>
<p>A config dict or None (None = unset).</p> <p>Can also be a list:</p> <pre class="highlight-python notranslate" data-language="python">[{'key': 'boot.autostart', 'value': 1},
 {'key': 'security.privileged', 'value': '1'}]</pre> </dd> <dt>devices :</dt>
<dd>
<p>A device dict or None (None = unset).</p> </dd> <dt>architecture<span class="classifier">'x86_64'</span>
</dt>
<dd>
<p>Can be one of the following:</p> <ul class="simple"> <li><p>unknown</p></li> <li><p>i686</p></li> <li><p>x86_64</p></li> <li><p>armv7l</p></li> <li><p>aarch64</p></li> <li><p>ppc</p></li> <li><p>ppc64</p></li> <li><p>ppc64le</p></li> <li><p>s390x</p></li> </ul> </dd> <dt>ephemeral<span class="classifier">False</span>
</dt>
<dd>
<p>Destroy this container after stop?</p> </dd> <dt>restart_on_change<span class="classifier">False</span>
</dt>
<dd>
<p>Restart the container when we detect changes on the config or its devices?</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Zertifikate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.lxd_container.running"> salt.states.lxd_container.running(name, restart=False, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Ensure a LXD container is running and restart it if restart is True</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the container to start/restart.</p> </dd> <dt>restart :</dt>
<dd>
<p>restart the container if it is already started.</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Zertifikate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.lxd_container.stopped"> salt.states.lxd_container.stopped(name, kill=False, remote_addr=None, cert=None, key=None, verify_cert=True)</h3> <dd>
<p>Ensure a LXD container is stopped, kill it if kill is true else stop it</p> <dl> <dt>name :</dt>
<dd>
<p>The name of the container to stop</p> </dd> <dt>kill :</dt>
<dd>
<p>kill if true</p> </dd> <dt>remote_addr :</dt>
<dd>
<p>An URL to a remote Server, you also have to give cert and key if you provide remote_addr!</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p><a class="reference external" href="https://myserver.lan:8443">https://myserver.lan:8443</a> /var/lib/mysocket.sock</p> </dd> </dl> </dd> <dt>cert :</dt>
<dd>
<p>PEM Formatted SSL Zertifikate.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.crt</p> </dd> </dl> </dd> <dt>key :</dt>
<dd>
<p>PEM Formatted SSL Key.</p> <dl class="simple"> <dt>Examples:</dt>
<dd>
<p>~/.config/lxc/client.key</p> </dd> </dl> </dd> <dt>verify_cert<span class="classifier">True</span>
</dt>
<dd>
<p>Wherever to verify the cert, this is by default True but in the most cases you want to set it off as LXD normally uses self-signed certificates.</p> </dd> </dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 SaltStack.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.saltproject.io/en/latest/ref/states/all/salt.states.lxd_container.html" class="_attribution-link">https://docs.saltproject.io/en/latest/ref/states/all/salt.states.lxd_container.html</a>
  </p>
</div>
