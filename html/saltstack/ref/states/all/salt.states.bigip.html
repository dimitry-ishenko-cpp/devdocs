<h1>salt.states.bigip</h1> <dl class="simple"> <dt>A state module designed to enforce load-balancing configurations for F5 Big-IP entities.</dt>
<dd>
<dl class="field-list simple"> <dt class="field-odd">maturity</dt> <dd class="field-odd">
<p>develop</p> </dd> <dt class="field-even">platform</dt> <dd class="field-even">
<p>f5_bigip_11.6</p> </dd> </dl> </dd> </dl> <dl class="py function"> <h3 id="salt.states.bigip.add_pool_member"> salt.states.bigip.add_pool_member(hostname, username, password, name, member)</h3> <dd>
<p>A function to connect to a bigip device and add a new member to an existing pool.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the pool to modify</p> </dd> <dt>member</dt>
<dd>
<p>The member to add to the pool</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.create_monitor"> salt.states.bigip.create_monitor(hostname, username, password, monitor_type, name, **kwargs)</h3> <dd>
<p>A function to connect to a bigip device and create a monitor.</p> <dl> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>monitor_type</dt>
<dd>
<p>The type of monitor to create</p> </dd> <dt>name</dt>
<dd>
<p>The name of the monitor to create</p> </dd> <dt>kwargs</dt>
<dd>
<p>[ arg=val ] ...</p> <p>Consult F5 BIGIP user guide for specific options for each monitor type. Typically, tmsh arg names are used.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.create_node"> salt.states.bigip.create_node(hostname, username, password, name, address)</h3> <dd>
<p>Create a new node if it does not already exist.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the node to create</p> </dd> <dt>address</dt>
<dd>
<p>The address of the node</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.create_pool"> salt.states.bigip.create_pool(hostname, username, password, name, members=None, allow_nat=None, allow_snat=None, description=None, gateway_failsafe_device=None, ignore_persisted_weight=None, ip_tos_to_client=None, ip_tos_to_server=None, link_qos_to_client=None, link_qos_to_server=None, load_balancing_mode=None, min_active_members=None, min_up_members=None, min_up_members_action=None, min_up_members_checking=None, monitor=None, profiles=None, queue_depth_limit=None, queue_on_connection_limit=None, queue_time_limit=None, reselect_tries=None, service_down_action=None, slow_ramp_time=None)</h3> <dd>
<p>Create a new node if it does not already exist.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the pool to create</p> </dd> <dt>members</dt>
<dd>
<p>List of members to be added to the pool</p> </dd> <dt>allow_nat</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>allow_snat</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>description</dt>
<dd>
<p>[string]</p> </dd> <dt>gateway_failsafe_device</dt>
<dd>
<p>[string]</p> </dd> <dt>ignore_persisted_weight</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>ip_tos_to_client</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>ip_tos_to_server</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>link_qos_to_client</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>link_qos_to_server</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>load_balancing_mode</dt>
<dd>
<p>[dynamic-ratio-member | dynamic-ratio-node | fastest-app-response | fastest-node | least-connections-members | least-connections-node | least-sessions | observed-member | observed-node | predictive-member | predictive-node | ratio-least-connections-member | ratio-least-connections-node | ratio-member | ratio-node | ratio-session | round-robin | weighted-least-connections-member | weighted-least-connections-node]</p> </dd> <dt>min_active_members</dt>
<dd>
<p>[integer]</p> </dd> <dt>min_up_members</dt>
<dd>
<p>[integer]</p> </dd> <dt>min_up_members_action</dt>
<dd>
<p>[failover | reboot | restart-all]</p> </dd> <dt>min_up_members_checking</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>monitor</dt>
<dd>
<p>[name]</p> </dd> <dt>profiles</dt>
<dd>
<p>[none | profile_name]</p> </dd> <dt>queue_depth_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>queue_on_connection_limit</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>queue_time_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>reselect_tries</dt>
<dd>
<p>[integer]</p> </dd> <dt>service_down_action</dt>
<dd>
<p>[drop | none | reselect | reset]</p> </dd> <dt>slow_ramp_time</dt>
<dd>
<p>[integer]</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.create_profile"> salt.states.bigip.create_profile(hostname, username, password, profile_type, name, **kwargs)</h3> <dd>
<p>A function to connect to a bigip device and create a profile.</p> <dl> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>profile_type</dt>
<dd>
<p>The type of profile to create</p> </dd> <dt>name</dt>
<dd>
<p>The name of the profile to create</p> </dd> <dt>kwargs</dt>
<dd>
<p>[ arg=val ] ...</p> <p>Consult F5 BIGIP user guide for specific options for each profile type. Typically, tmsh arg names are used.</p> </dd> </dl> <p>Special Characters <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">,</span></code> and <code class="docutils literal notranslate"><span class="pre">:</span></code> must be escaped using <code class="docutils literal notranslate"><span class="pre">\</span></code> when used within strings.</p> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.create_virtual"> salt.states.bigip.create_virtual(hostname, username, password, name, destination, pool=None, address_status=None, auto_lasthop=None, bwc_policy=None, cmp_enabled=None, connection_limit=None, dhcp_relay=None, description=None, fallback_persistence=None, flow_eviction_policy=None, gtm_score=None, ip_forward=None, ip_protocol=None, internal=None, twelve_forward=None, last_hop_pool=None, mask=None, mirror=None, nat64=None, persist=None, profiles=None, policies=None, rate_class=None, rate_limit=None, rate_limit_mode=None, rate_limit_dst=None, rate_limit_src=None, rules=None, related_rules=None, reject=None, source=None, source_address_translation=None, source_port=None, virtual_state=None, traffic_classes=None, translate_address=None, translate_port=None, vlans=None)</h3> <dd>
<p>A function to connect to a bigip device and create a virtual server if it does not already exists.</p> <dl> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the virtual to create</p> </dd> <dt>destination</dt>
<dd>
<p>[ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]</p> </dd> <dt>pool</dt>
<dd>
<p>[ [pool_name] | none]</p> </dd> <dt>address_status</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>auto_lasthop</dt>
<dd>
<p>[default | enabled | disabled ]</p> </dd> <dt>bwc_policy</dt>
<dd>
<p>[none] | string]</p> </dd> <dt>cmp_enabled</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>dhcp_relay</dt>
<dd>
<p>[yes | no}</p> </dd> <dt>connection_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>description</dt>
<dd>
<p>[string]</p> </dd> <dt>state</dt>
<dd>
<p>[disabled | enabled]</p> </dd> <dt>fallback_persistence</dt>
<dd>
<p>[none | [profile name] ]</p> </dd> <dt>flow_eviction_policy</dt>
<dd>
<p>[none | [eviction policy name] ]</p> </dd> <dt>gtm_score</dt>
<dd>
<p>[integer]</p> </dd> <dt>ip_forward</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>ip_protocol</dt>
<dd>
<p>[any | protocol]</p> </dd> <dt>internal</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>twelve_forward(12-forward)</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>last_hop-pool</dt>
<dd>
<p>[ [pool_name] | none]</p> </dd> <dt>mask</dt>
<dd>
<p>{ [ipv4] | [ipv6] }</p> </dd> <dt>mirror</dt>
<dd>
<p>{ [disabled | enabled | none] }</p> </dd> <dt>nat64</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>persist</dt>
<dd>
<p>[list]</p> </dd> <dt>profiles</dt>
<dd>
<p>[none | default | list ]</p> </dd> <dt>policies</dt>
<dd>
<p>[none | default | list ]</p> </dd> <dt>rate_class</dt>
<dd>
<p>[name]</p> </dd> <dt>rate_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>rate_limit-mode</dt>
<dd>
<p>[destination | object | object-destination | object-source | object-source-destination | source | source-destination]</p> </dd> <dt>rate_limit-dst</dt>
<dd>
<p>[integer]</p> </dd> <dt>rate_limit-src</dt>
<dd>
<p>[integer]</p> </dd> <dt>rules</dt>
<dd>
<p>[none | list ]</p> </dd> <dt>related_rules</dt>
<dd>
<p>[none | list ]</p> </dd> <dt>reject</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>source</dt>
<dd>
<p>{ [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }</p> </dd> <dt>source_address_translation</dt>
<dd>
<p>[none | snat:pool_name | lsn | automap | dictionary ]</p> </dd> <dt>source_port</dt>
<dd>
<p>[change | preserve | preserve-strict]</p> </dd> <dt>state</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>traffic_classes</dt>
<dd>
<p>[none | default | list ]</p> </dd> <dt>translate_address</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>translate_port</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>vlans</dt>
<dd>
<p>[none | default | dictionary]</p> <dl class="simple"> <dt>vlan_ids</dt>
<dd>
<p>[ list]</p> </dd> <dt>enabled</dt>
<dd>
<p>[ true | false ]</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.delete_monitor"> salt.states.bigip.delete_monitor(hostname, username, password, monitor_type, name)</h3> <dd>
<p>Modify an existing monitor. If it does exists, only the parameters specified will be enforced.</p> <dl> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>monitor_type</dt>
<dd>
<p>The type of monitor to create</p> </dd> <dt>name</dt>
<dd>
<p>The name of the monitor to create</p> </dd> <dt>kwargs</dt>
<dd>
<p>[ arg=val ] ...</p> <p>Consult F5 BIGIP user guide for specific options for each monitor type. Typically, tmsh arg names are used.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.delete_node"> salt.states.bigip.delete_node(hostname, username, password, name)</h3> <dd>
<p>Delete an existing node.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the node which will be deleted.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.delete_pool"> salt.states.bigip.delete_pool(hostname, username, password, name)</h3> <dd>
<p>Delete an existing pool.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the pool which will be deleted</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.delete_pool_member"> salt.states.bigip.delete_pool_member(hostname, username, password, name, member)</h3> <dd>
<p>Delete an existing pool member.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the pool to be modified</p> </dd> <dt>member</dt>
<dd>
<p>The name of the member to delete from the pool</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.delete_profile"> salt.states.bigip.delete_profile(hostname, username, password, profile_type, name)</h3> <dd>
<p>Modify an existing profile. If it does exists, only the parameters specified will be enforced.</p> <dl> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>profile_type</dt>
<dd>
<p>The type of profile to create</p> </dd> <dt>name</dt>
<dd>
<p>The name of the profile to create</p> </dd> <dt>kwargs</dt>
<dd>
<p>[ arg=val ] ...</p> <p>Consult F5 BIGIP user guide for specific options for each profile type. Typically, tmsh arg names are used.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.delete_virtual"> salt.states.bigip.delete_virtual(hostname, username, password, name)</h3> <dd>
<p>Delete an existing virtual.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the virtual which will be deleted</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.list_monitor"> salt.states.bigip.list_monitor(hostname, username, password, monitor_type, name)</h3> <dd>
<p>A function to list an existing monitor.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>monitor_type</dt>
<dd>
<p>The type of monitor to list</p> </dd> <dt>name</dt>
<dd>
<p>The name of the monitor to list</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.list_node"> salt.states.bigip.list_node(hostname, username, password, name)</h3> <dd>
<p>A function to connect to a bigip device and list a specific node.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the node to list.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.list_pool"> salt.states.bigip.list_pool(hostname, username, password, name)</h3> <dd>
<p>A function to connect to a bigip device and list a specific pool.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the pool to list.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.list_profile"> salt.states.bigip.list_profile(hostname, username, password, profile_type, name)</h3> <dd>
<p>A function to list an existing profile.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>profile_type</dt>
<dd>
<p>The type of profile to list</p> </dd> <dt>name</dt>
<dd>
<p>The name of the profile to list</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.list_virtual"> salt.states.bigip.list_virtual(hostname, username, password, name)</h3> <dd>
<p>A function to list a specific virtual.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the virtual to list</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.manage_monitor"> salt.states.bigip.manage_monitor(hostname, username, password, monitor_type, name, **kwargs)</h3> <dd>
<p>Create a new monitor if a monitor of this type and name does not already exists. If it does exists, only the parameters specified will be enforced.</p> <dl> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>monitor_type</dt>
<dd>
<p>The type of monitor to create</p> </dd> <dt>name</dt>
<dd>
<p>The name of the monitor to create</p> </dd> <dt>kwargs</dt>
<dd>
<p>[ arg=val ] ...</p> <p>Consult F5 BIGIP user guide for specific options for each monitor type. Typically, tmsh arg names are used.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.manage_node"> salt.states.bigip.manage_node(hostname, username, password, name, address, connection_limit=None, description=None, dynamic_ratio=None, logging=None, monitor=None, rate_limit=None, ratio=None, session=None, node_state=None)</h3> <dd>
<p>Manages a node of a given bigip device. If the node does not exist it will be created, otherwise, only the properties which are different than the existing will be updated.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the node to manage.</p> </dd> <dt>address</dt>
<dd>
<p>The address of the node</p> </dd> <dt>connection_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>description</dt>
<dd>
<p>[string]</p> </dd> <dt>dynam</dt>
<dd>
<p>c_ratio: [integer]</p> </dd> <dt>logging</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>monitor</dt>
<dd>
<p>[[name] | none | default]</p> </dd> <dt>rate_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>ratio</dt>
<dd>
<p>[integer]</p> </dd> <dt>session</dt>
<dd>
<p>[user-enabled | user-disabled]</p> </dd> <dt>node_state (state)</dt>
<dd>
<p>[user-down | user-up ]</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.manage_pool"> salt.states.bigip.manage_pool(hostname, username, password, name, allow_nat=None, allow_snat=None, description=None, gateway_failsafe_device=None, ignore_persisted_weight=None, ip_tos_to_client=None, ip_tos_to_server=None, link_qos_to_client=None, link_qos_to_server=None, load_balancing_mode=None, min_active_members=None, min_up_members=None, min_up_members_action=None, min_up_members_checking=None, monitor=None, profiles=None, queue_depth_limit=None, queue_on_connection_limit=None, queue_time_limit=None, reselect_tries=None, service_down_action=None, slow_ramp_time=None)</h3> <dd>
<p>Create a new pool if it does not already exist. Pool members are managed separately. Only the parameters specified are enforced.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the pool to create</p> </dd> <dt>allow_nat</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>allow_snat</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>description</dt>
<dd>
<p>[string]</p> </dd> <dt>gateway_failsafe_device</dt>
<dd>
<p>[string]</p> </dd> <dt>ignore_persisted_weight</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>ip_tos_to_client</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>ip_tos_to_server</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>link_qos_to_client</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>link_qos_to_server</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>load_balancing_mode</dt>
<dd>
<p>[dynamic-ratio-member | dynamic-ratio-node | fastest-app-response | fastest-node | least-connections-members | least-connections-node | least-sessions | observed-member | observed-node | predictive-member | predictive-node | ratio-least-connections-member | ratio-least-connections-node | ratio-member | ratio-node | ratio-session | round-robin | weighted-least-connections-member | weighted-least-connections-node]</p> </dd> <dt>min_active_members</dt>
<dd>
<p>[integer]</p> </dd> <dt>min_up_members</dt>
<dd>
<p>[integer]</p> </dd> <dt>min_up_members_action</dt>
<dd>
<p>[failover | reboot | restart-all]</p> </dd> <dt>min_up_members_checking</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>monitor</dt>
<dd>
<p>[name]</p> </dd> <dt>profiles</dt>
<dd>
<p>[none | profile_name]</p> </dd> <dt>queue_depth_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>queue_on_connection_limit</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>queue_time_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>reselect_tries</dt>
<dd>
<p>[integer]</p> </dd> <dt>service_down_action</dt>
<dd>
<p>[drop | none | reselect | reset]</p> </dd> <dt>slow_ramp_time</dt>
<dd>
<p>[integer]</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.manage_pool_members"> salt.states.bigip.manage_pool_members(hostname, username, password, name, members)</h3> <dd>
<p>Manage the members of an existing pool. This function replaces all current pool members. Only the parameters specified are enforced.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the pool to modify</p> </dd> <dt>members</dt>
<dd>
<p>list of pool members to manage.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.manage_profile"> salt.states.bigip.manage_profile(hostname, username, password, profile_type, name, **kwargs)</h3> <dd>
<p>Create a new profile if a monitor of this type and name does not already exists. If it does exists, only the parameters specified will be enforced.</p> <dl> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>profile_type</dt>
<dd>
<p>The type of profile to create</p> </dd> <dt>name</dt>
<dd>
<p>The name of the profile to create</p> </dd> <dt>kwargs</dt>
<dd>
<p>[ arg=val ] ...</p> <p>Consult F5 BIGIP user guide for specific options for each profile type. Typically, tmsh arg names are used.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.manage_virtual"> salt.states.bigip.manage_virtual(hostname, username, password, name, destination, pool=None, address_status=None, auto_lasthop=None, bwc_policy=None, cmp_enabled=None, connection_limit=None, dhcp_relay=None, description=None, fallback_persistence=None, flow_eviction_policy=None, gtm_score=None, ip_forward=None, ip_protocol=None, internal=None, twelve_forward=None, last_hop_pool=None, mask=None, mirror=None, nat64=None, persist=None, profiles=None, policies=None, rate_class=None, rate_limit=None, rate_limit_mode=None, rate_limit_dst=None, rate_limit_src=None, rules=None, related_rules=None, reject=None, source=None, source_address_translation=None, source_port=None, virtual_state=None, traffic_classes=None, translate_address=None, translate_port=None, vlans=None)</h3> <dd>
<p>Manage a virtual server. If a virtual does not exists it will be created, otherwise only the parameters specified will be enforced.</p> <dl> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the virtual to create</p> </dd> <dt>destination</dt>
<dd>
<p>[ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]</p> </dd> <dt>pool</dt>
<dd>
<p>[ [pool_name] | none]</p> </dd> <dt>address_status</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>auto_lasthop</dt>
<dd>
<p>[default | enabled | disabled ]</p> </dd> <dt>bwc_policy</dt>
<dd>
<p>[none] | string]</p> </dd> <dt>cmp_enabled</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>dhcp_relay</dt>
<dd>
<p>[yes | no}</p> </dd> <dt>connection_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>description</dt>
<dd>
<p>[string]</p> </dd> <dt>state</dt>
<dd>
<p>[disabled | enabled]</p> </dd> <dt>fallback_persistence</dt>
<dd>
<p>[none | [profile name] ]</p> </dd> <dt>flow_eviction_policy</dt>
<dd>
<p>[none | [eviction policy name] ]</p> </dd> <dt>gtm_score</dt>
<dd>
<p>[integer]</p> </dd> <dt>ip_forward</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>ip_protocol</dt>
<dd>
<p>[any | protocol]</p> </dd> <dt>internal</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>twelve_forward(12-forward)</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>last_hop-pool</dt>
<dd>
<p>[ [pool_name] | none]</p> </dd> <dt>mask</dt>
<dd>
<p>{ [ipv4] | [ipv6] }</p> </dd> <dt>mirror</dt>
<dd>
<p>{ [disabled | enabled | none] }</p> </dd> <dt>nat64</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>persist</dt>
<dd>
<p>[list]</p> </dd> <dt>profiles</dt>
<dd>
<p>[none | default | list ]</p> </dd> <dt>policies</dt>
<dd>
<p>[none | default | list ]</p> </dd> <dt>rate_class</dt>
<dd>
<p>[name]</p> </dd> <dt>rate_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>rate_limit-mode</dt>
<dd>
<p>[destination | object | object-destination | object-source | object-source-destination | source | source-destination]</p> </dd> <dt>rate_limit-dst</dt>
<dd>
<p>[integer]</p> </dd> <dt>rate_limit-src</dt>
<dd>
<p>[integer]</p> </dd> <dt>rules</dt>
<dd>
<p>[none | list ]</p> </dd> <dt>related_rules</dt>
<dd>
<p>[none | list ]</p> </dd> <dt>reject</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>source</dt>
<dd>
<p>{ [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }</p> </dd> <dt>source_address_translation</dt>
<dd>
<p>[none | snat:pool_name | lsn | automap | dictionary ]</p> </dd> <dt>source_port</dt>
<dd>
<p>[change | preserve | preserve-strict]</p> </dd> <dt>state</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>traffic_classes</dt>
<dd>
<p>[none | default | list ]</p> </dd> <dt>translate_address</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>translate_port</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>vlans</dt>
<dd>
<p>[none | default | dictionary]</p> <dl class="simple"> <dt>vlan_ids</dt>
<dd>
<p>[ list]</p> </dd> <dt>enabled</dt>
<dd>
<p>[ true | false ]</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.modify_monitor"> salt.states.bigip.modify_monitor(hostname, username, password, monitor_type, name, **kwargs)</h3> <dd>
<p>Modify an existing monitor. If it does exists, only the parameters specified will be enforced.</p> <dl> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>monitor_type</dt>
<dd>
<p>The type of monitor to create</p> </dd> <dt>name</dt>
<dd>
<p>The name of the monitor to create</p> </dd> <dt>kwargs</dt>
<dd>
<p>[ arg=val ] ...</p> <p>Consult F5 BIGIP user guide for specific options for each monitor type. Typically, tmsh arg names are used.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.modify_node"> salt.states.bigip.modify_node(hostname, username, password, name, connection_limit=None, description=None, dynamic_ratio=None, logging=None, monitor=None, rate_limit=None, ratio=None, session=None, node_state=None)</h3> <dd>
<p>Modify an existing node. Only a node which already exists will be modified and only the parameters specified will be enforced.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the node to modify</p> </dd> <dt>connection_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>description</dt>
<dd>
<p>[string]</p> </dd> <dt>dynamic_ratio</dt>
<dd>
<p>[integer]</p> </dd> <dt>logging</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>monitor</dt>
<dd>
<p>[[name] | none | default]</p> </dd> <dt>rate_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>ratio</dt>
<dd>
<p>[integer]</p> </dd> <dt>session</dt>
<dd>
<p>[user-enabled | user-disabled]</p> </dd> <dt>node_state (state)</dt>
<dd>
<p>[user-down | user-up ]</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.modify_pool"> salt.states.bigip.modify_pool(hostname, username, password, name, allow_nat=None, allow_snat=None, description=None, gateway_failsafe_device=None, ignore_persisted_weight=None, ip_tos_to_client=None, ip_tos_to_server=None, link_qos_to_client=None, link_qos_to_server=None, load_balancing_mode=None, min_active_members=None, min_up_members=None, min_up_members_action=None, min_up_members_checking=None, monitor=None, profiles=None, queue_depth_limit=None, queue_on_connection_limit=None, queue_time_limit=None, reselect_tries=None, service_down_action=None, slow_ramp_time=None)</h3> <dd>
<p>Modify an existing pool. Pool members are managed separately. Only the parameters specified are enforced.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the pool to create</p> </dd> <dt>allow_nat</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>allow_snat</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>description</dt>
<dd>
<p>[string]</p> </dd> <dt>gateway_failsafe_device</dt>
<dd>
<p>[string]</p> </dd> <dt>ignore_persisted_weight</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>ip_tos_to_client</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>ip_tos_to_server</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>link_qos_to_client</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>link_qos_to_server</dt>
<dd>
<p>[pass-through | [integer]]</p> </dd> <dt>load_balancing_mode</dt>
<dd>
<p>[dynamic-ratio-member | dynamic-ratio-node | fastest-app-response | fastest-node | least-connections-members | least-connections-node | least-sessions | observed-member | observed-node | predictive-member | predictive-node | ratio-least-connections-member | ratio-least-connections-node | ratio-member | ratio-node | ratio-session | round-robin | weighted-least-connections-member | weighted-least-connections-node]</p> </dd> <dt>min_active_members</dt>
<dd>
<p>[integer]</p> </dd> <dt>min_up_members</dt>
<dd>
<p>[integer]</p> </dd> <dt>min_up_members_action</dt>
<dd>
<p>[failover | reboot | restart-all]</p> </dd> <dt>min_up_members_checking</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>monitor</dt>
<dd>
<p>[name]</p> </dd> <dt>profiles</dt>
<dd>
<p>[none | profile_name]</p> </dd> <dt>queue_depth_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>queue_on_connection_limit</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>queue_time_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>reselect_tries</dt>
<dd>
<p>[integer]</p> </dd> <dt>service_down_action</dt>
<dd>
<p>[drop | none | reselect | reset]</p> </dd> <dt>slow_ramp_time</dt>
<dd>
<p>[integer]</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.modify_pool_member"> salt.states.bigip.modify_pool_member(hostname, username, password, name, member, connection_limit=None, description=None, dynamic_ratio=None, inherit_profile=None, logging=None, monitor=None, priority_group=None, profiles=None, rate_limit=None, ratio=None, session=None, member_state=None)</h3> <dd>
<p>A function to connect to a bigip device and modify a member of an existing pool.</p> <dl class="simple"> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the pool to modify</p> </dd> <dt>member</dt>
<dd>
<p>The member modify</p> </dd> <dt>connection_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>description</dt>
<dd>
<p>[string]</p> </dd> <dt>dynamic_ratio</dt>
<dd>
<p>[integer]</p> </dd> <dt>inherit_profile</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>logging</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>monitor</dt>
<dd>
<p>[name]</p> </dd> <dt>priority_group</dt>
<dd>
<p>[integer]</p> </dd> <dt>profiles</dt>
<dd>
<p>[none | profile_name]</p> </dd> <dt>rate_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>ratio</dt>
<dd>
<p>[integer]</p> </dd> <dt>session</dt>
<dd>
<p>[user-enabled | user-disabled]</p> </dd> <dt>member_state (state)</dt>
<dd>
<p>[ user-up | user-down ]</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.modify_profile"> salt.states.bigip.modify_profile(hostname, username, password, profile_type, name, **kwargs)</h3> <dd>
<p>Modify an existing profile. If it does exists, only the parameters specified will be enforced.</p> <dl> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>profile_type</dt>
<dd>
<p>The type of profile to create</p> </dd> <dt>name</dt>
<dd>
<p>The name of the profile to create</p> </dd> <dt>kwargs</dt>
<dd>
<p>[ arg=val ] ...</p> <p>Consult F5 BIGIP user guide for specific options for each monitor type. Typically, tmsh arg names are used.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 id="salt.states.bigip.modify_virtual"> salt.states.bigip.modify_virtual(hostname, username, password, name, destination, pool=None, address_status=None, auto_lasthop=None, bwc_policy=None, cmp_enabled=None, connection_limit=None, dhcp_relay=None, description=None, fallback_persistence=None, flow_eviction_policy=None, gtm_score=None, ip_forward=None, ip_protocol=None, internal=None, twelve_forward=None, last_hop_pool=None, mask=None, mirror=None, nat64=None, persist=None, profiles=None, policies=None, rate_class=None, rate_limit=None, rate_limit_mode=None, rate_limit_dst=None, rate_limit_src=None, rules=None, related_rules=None, reject=None, source=None, source_address_translation=None, source_port=None, virtual_state=None, traffic_classes=None, translate_address=None, translate_port=None, vlans=None)</h3> <dd>
<p>Modify an virtual server. modify an existing virtual. Only parameters specified will be enforced.</p> <dl> <dt>hostname</dt>
<dd>
<p>The host/address of the bigip device</p> </dd> <dt>username</dt>
<dd>
<p>The iControl REST username</p> </dd> <dt>password</dt>
<dd>
<p>The iControl REST password</p> </dd> <dt>name</dt>
<dd>
<p>The name of the virtual to create</p> </dd> <dt>destination</dt>
<dd>
<p>[ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]</p> </dd> <dt>pool</dt>
<dd>
<p>[ [pool_name] | none]</p> </dd> <dt>address_status</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>auto_lasthop</dt>
<dd>
<p>[default | enabled | disabled ]</p> </dd> <dt>bwc_policy</dt>
<dd>
<p>[none] | string]</p> </dd> <dt>cmp_enabled</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>dhcp_relay</dt>
<dd>
<p>[yes | no}</p> </dd> <dt>connection_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>description</dt>
<dd>
<p>[string]</p> </dd> <dt>state</dt>
<dd>
<p>[disabled | enabled]</p> </dd> <dt>fallback_persistence</dt>
<dd>
<p>[none | [profile name] ]</p> </dd> <dt>flow_eviction_policy</dt>
<dd>
<p>[none | [eviction policy name] ]</p> </dd> <dt>gtm_score</dt>
<dd>
<p>[integer]</p> </dd> <dt>ip_forward</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>ip_protocol</dt>
<dd>
<p>[any | protocol]</p> </dd> <dt>internal</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>twelve_forward(12-forward)</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>last_hop-pool</dt>
<dd>
<p>[ [pool_name] | none]</p> </dd> <dt>mask</dt>
<dd>
<p>{ [ipv4] | [ipv6] }</p> </dd> <dt>mirror</dt>
<dd>
<p>{ [disabled | enabled | none] }</p> </dd> <dt>nat64</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>persist</dt>
<dd>
<p>[list]</p> </dd> <dt>profiles</dt>
<dd>
<p>[none | default | list ]</p> </dd> <dt>policies</dt>
<dd>
<p>[none | default | list ]</p> </dd> <dt>rate_class</dt>
<dd>
<p>[name]</p> </dd> <dt>rate_limit</dt>
<dd>
<p>[integer]</p> </dd> <dt>rate_limit-mode</dt>
<dd>
<p>[destination | object | object-destination | object-source | object-source-destination | source | source-destination]</p> </dd> <dt>rate_limit_dst</dt>
<dd>
<p>[integer]</p> </dd> <dt>rate_limit_src</dt>
<dd>
<p>[integer]</p> </dd> <dt>rules</dt>
<dd>
<p>[none | list ]</p> </dd> <dt>related_rules</dt>
<dd>
<p>[none | list ]</p> </dd> <dt>reject</dt>
<dd>
<p>[yes | no]</p> </dd> <dt>source</dt>
<dd>
<p>{ [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }</p> </dd> <dt>source_address_translation</dt>
<dd>
<p>[none | snat:pool_name | lsn | automap | dictionary ]</p> </dd> <dt>source_port</dt>
<dd>
<p>[change | preserve | preserve-strict]</p> </dd> <dt>state</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>traffic_classes</dt>
<dd>
<p>[none | default | list ]</p> </dd> <dt>translate_address</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>translate_port</dt>
<dd>
<p>[enabled | disabled]</p> </dd> <dt>vlans</dt>
<dd>
<p>[none | default | dictionary ]</p> <dl class="simple"> <dt>vlan_ids</dt>
<dd>
<p>[ list]</p> </dd> <dt>enabled</dt>
<dd>
<p>[ true | false ]</p> </dd> </dl> </dd> </dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 SaltStack.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.saltproject.io/en/latest/ref/states/all/salt.states.bigip.html" class="_attribution-link">https://docs.saltproject.io/en/latest/ref/states/all/salt.states.bigip.html</a>
  </p>
</div>
