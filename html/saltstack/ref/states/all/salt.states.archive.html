<h1>salt.states.archive</h1> <p>Extract an archive</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2014.1.0.</span></p> </div> <dl class="py function"> <h3 id="salt.states.archive.extracted"> salt.states.archive.extracted(name, source, source_hash=None, source_hash_name=None, source_hash_update=False, skip_files_list_verify=False, skip_verify=False, password=None, options=None, list_options=None, force=False, overwrite=False, clean=False, clean_parent=False, user=None, group=None, if_missing=None, trim_output=False, use_cmd_unzip=None, extract_perms=True, enforce_toplevel=True, enforce_ownership_on=None, archive_format=None, **kwargs)</h3> <dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2014.1.0.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.11.0: </span>This state has been rewritten. Some arguments are new to this release and will not be available in the 2016.3 release cycle (and earlier). Additionally, the <strong>ZIP Archive Handling</strong> section below applies specifically to the 2016.11.0 release (and newer).</p> </div> <p>Ensure that an archive is extracted to a specific directory.</p> <div class="admonition important"> <p class="admonition-title">Important</p> <p><strong>Changes for 2016.11.0</strong></p> <p>In earlier releases, this state would rely on the <code class="docutils literal notranslate"><span class="pre">if_missing</span></code> argument to determine whether or not the archive needed to be extracted. When this argument was not passed, then the state would just assume <code class="docutils literal notranslate"><span class="pre">if_missing</span></code> is the same as the <code class="docutils literal notranslate"><span class="pre">name</span></code> argument (i.e. the parent directory into which the archive would be extracted).</p> <p>This caused a number of annoyances. One such annoyance was the need to know beforehand a path that would result from the extraction of the archive, and setting <code class="docutils literal notranslate"><span class="pre">if_missing</span></code> to that directory, like so:</p> <pre class="highlight-yaml notranslate" data-language="yaml">extract_myapp:
  archive.extracted:
    - name: /var/www
    - source: salt://apps/src/myapp-16.2.4.tar.gz
    - user: www
    - group: www
    - if_missing: /var/www/myapp-16.2.4</pre> <p>If <code class="docutils literal notranslate"><span class="pre">/var/www</span></code> already existed, this would effectively make <code class="docutils literal notranslate"><span class="pre">if_missing</span></code> a required argument, just to get Salt to extract the archive.</p> <p>Some users worked around this by adding the top-level directory of the archive to the end of the <code class="docutils literal notranslate"><span class="pre">name</span></code> argument, and then used <code class="docutils literal notranslate"><span class="pre">--strip</span></code> or <code class="docutils literal notranslate"><span class="pre">--strip-components</span></code> to remove that top-level dir when extracting:</p> <pre class="highlight-yaml notranslate" data-language="yaml">extract_myapp:
  archive.extracted:
    - name: /var/www/myapp-16.2.4
    - source: salt://apps/src/myapp-16.2.4.tar.gz
    - user: www
    - group: www</pre> <p>With the rewrite for 2016.11.0, these workarounds are no longer necessary. <code class="docutils literal notranslate"><span class="pre">if_missing</span></code> is still a supported argument, but it is no longer required. The equivalent SLS in 2016.11.0 would be:</p> <pre class="highlight-yaml notranslate" data-language="yaml">extract_myapp:
  archive.extracted:
    - name: /var/www
    - source: salt://apps/src/myapp-16.2.4.tar.gz
    - user: www
    - group: www</pre> <p>Salt now uses a function called <code class="xref py py-func docutils literal notranslate"><span class="pre">archive.list</span></code> to get a list of files/directories in the archive. Using this information, the state can now check the minion to see if any paths are missing, and know whether or not the archive needs to be extracted. This makes the <code class="docutils literal notranslate"><span class="pre">if_missing</span></code> argument unnecessary in most use cases.</p> </div> <div class="admonition important"> <p class="admonition-title">Important</p> <p><strong>ZIP Archive Handling</strong></p> <p><em>Note: this information applies to 2016.11.0 and later.</em></p> <p>Salt has two different functions for extracting ZIP archives:</p> <ol class="arabic simple"> <li><p><a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.unzip" title="salt.modules.archive.unzip"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.unzip</span></code></a>, which uses Python's <a class="reference external" href="https://docs.python.org/2/library/zipfile.html">zipfile</a> module to extract ZIP files.</p></li> <li><p><a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.cmd_unzip" title="salt.modules.archive.cmd_unzip"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.cmd_unzip</span></code></a>, which uses the <code class="docutils literal notranslate"><span class="pre">unzip</span></code> CLI command to extract ZIP files.</p></li> </ol> <p>Salt will prefer the use of <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.cmd_unzip" title="salt.modules.archive.cmd_unzip"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.cmd_unzip</span></code></a> when CLI options are specified (via the <code class="docutils literal notranslate"><span class="pre">options</span></code> argument), and will otherwise prefer the <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.unzip" title="salt.modules.archive.unzip"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.unzip</span></code></a> function. Use of <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.cmd_unzip" title="salt.modules.archive.cmd_unzip"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.cmd_unzip</span></code></a> can be forced however by setting the <code class="docutils literal notranslate"><span class="pre">use_cmd_unzip</span></code> argument to <code class="docutils literal notranslate"><span class="pre">True</span></code>. By contrast, setting this argument to <code class="docutils literal notranslate"><span class="pre">False</span></code> will force usage of <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.unzip" title="salt.modules.archive.unzip"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.unzip</span></code></a>. For example:</p> <pre class="highlight-yaml notranslate" data-language="yaml">/var/www:
  archive.extracted:
    - source: salt://foo/bar/myapp.zip
    - use_cmd_unzip: True</pre> <p>When <code class="docutils literal notranslate"><span class="pre">use_cmd_unzip</span></code> is omitted, Salt will choose which extraction function to use based on the source archive and the arguments passed to the state. When in doubt, simply do not set this argument; it is provided as a means of overriding the logic Salt uses to decide which function to use.</p> <p>There are differences in the features available in both extraction functions. These are detailed below.</p> <ul> <li><p><em>Command-line options</em> (only supported by <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.cmd_unzip" title="salt.modules.archive.cmd_unzip"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.cmd_unzip</span></code></a>) - When the <code class="docutils literal notranslate"><span class="pre">options</span></code> argument is used, <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.cmd_unzip" title="salt.modules.archive.cmd_unzip"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.cmd_unzip</span></code></a> is the only function that can be used to extract the archive. Therefore, if <code class="docutils literal notranslate"><span class="pre">use_cmd_unzip</span></code> is specified and set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, and <code class="docutils literal notranslate"><span class="pre">options</span></code> is also set, the state will not proceed.</p></li> <li>
<p><em>Permissions</em> - Due to an <a class="reference external" href="https://bugs.python.org/issue15795">upstream bug in Python</a>, permissions are not preserved when the <a class="reference external" href="https://docs.python.org/2/library/zipfile.html">zipfile</a> module is used to extract an archive. As of the 2016.11.0 release, <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.unzip" title="salt.modules.archive.unzip"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.unzip</span></code></a> (as well as this state) has an <code class="docutils literal notranslate"><span class="pre">extract_perms</span></code> argument which, when set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default), will attempt to match the permissions of the extracted files/directories to those defined within the archive. To disable this functionality and have the state not attempt to preserve the permissions from the ZIP archive, set <code class="docutils literal notranslate"><span class="pre">extract_perms</span></code> to <code class="docutils literal notranslate"><span class="pre">False</span></code>:</p> <pre class="highlight-yaml notranslate" data-language="yaml">/var/www:
  archive.extracted:
    - source: salt://foo/bar/myapp.zip
    - extract_perms: False</pre> </li> </ul> </div> <dl> <dt>name</dt>
<dd>
<p>Directory into which the archive should be extracted</p> </dd> <dt>source</dt>
<dd>
<p>Archive to be extracted</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This argument uses the same syntax as its counterpart in the <a class="reference internal" href="salt.states.file.html#salt.states.file.managed" title="salt.states.file.managed"><code class="xref py py-func docutils literal notranslate"><span class="pre">file.managed</span></code></a> state.</p> </div> </dd> <dt>source_hash</dt>
<dd>
<p>Hash of source file, or file with list of hash-to-file mappings</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This argument uses the same syntax as its counterpart in the <a class="reference internal" href="salt.states.file.html#salt.states.file.managed" title="salt.states.file.managed"><code class="xref py py-func docutils literal notranslate"><span class="pre">file.managed</span></code></a> state.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.11.0: </span>If this argument specifies the hash itself, instead of a URI to a file containing hashes, the hash type can now be omitted and Salt will determine the hash type based on the length of the hash. For example, both of the below states are now valid, while before only the second one would be:</p> </div> <pre class="highlight-yaml notranslate" data-language="yaml">foo_app:
  archive.extracted:
    - name: /var/www
    - source: https://mydomain.tld/foo.tar.gz
    - source_hash: 3360db35e682f1c5f9c58aa307de16d41361618c

bar_app:
  archive.extracted:
    - name: /var/www
    - source: https://mydomain.tld/bar.tar.gz
    - source_hash: sha1=5edb7d584b82ddcbf76e311601f5d4442974aaa5</pre> </dd> <dt>source_hash_name</dt>
<dd>
<p>When <code class="docutils literal notranslate"><span class="pre">source_hash</span></code> refers to a hash file, Salt will try to find the correct hash by matching the filename part of the <code class="docutils literal notranslate"><span class="pre">source</span></code> URI. When managing a file with a <code class="docutils literal notranslate"><span class="pre">source</span></code> of <code class="docutils literal notranslate"><span class="pre">salt://files/foo.tar.gz</span></code>, then the following line in a hash file would match:</p> <pre class="highlight-text notranslate" data-language="text">acbd18db4cc2f85cedef654fccc4a4d8    foo.tar.gz</pre> <p>This line would also match:</p> <pre class="highlight-text notranslate" data-language="text">acbd18db4cc2f85cedef654fccc4a4d8    ./dir1/foo.tar.gz</pre> <p>However, sometimes a hash file will include multiple similar paths:</p> <pre class="highlight-text notranslate" data-language="text">37b51d194a7513e45b56f6524f2d51f2    ./dir1/foo.txt
acbd18db4cc2f85cedef654fccc4a4d8    ./dir2/foo.txt
73feffa4b7f6bb68e44cf984c85f6e88    ./dir3/foo.txt</pre> <p>In cases like this, Salt may match the incorrect hash. This argument can be used to tell Salt which filename to match, to ensure that the correct hash is identified. For example:</p> <pre class="highlight-yaml notranslate" data-language="yaml">/var/www:
  archive.extracted:
    - source: https://mydomain.tld/dir2/foo.tar.gz
    - source_hash: https://mydomain.tld/hashes
    - source_hash_name: ./dir2/foo.tar.gz</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This argument must contain the full filename entry from the checksum file, as this argument is meant to disambiguate matches for multiple files that have the same basename. So, in the example above, simply using <code class="docutils literal notranslate"><span class="pre">foo.txt</span></code> would not match.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.0.</span></p> </div> </dd> <dt>source_hash_update<span class="classifier">False</span>
</dt>
<dd>
<p>Set this to <code class="docutils literal notranslate"><span class="pre">True</span></code> if archive should be extracted if source_hash has changed and there is a difference between the archive and the local files. This would extract regardless of the <code class="docutils literal notranslate"><span class="pre">if_missing</span></code> parameter.</p> <p>Note that this is only checked if the <code class="docutils literal notranslate"><span class="pre">source</span></code> value has not changed. If it has (e.g. to increment a version number in the path) then the archive will not be extracted even if the hash has changed.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Setting this to <code class="docutils literal notranslate"><span class="pre">True</span></code> along with <code class="docutils literal notranslate"><span class="pre">keep_source</span></code> set to <code class="docutils literal notranslate"><span class="pre">False</span></code> will result the <code class="docutils literal notranslate"><span class="pre">source</span></code> re-download to do a archive file list check. If it's not desirable please consider the <code class="docutils literal notranslate"><span class="pre">skip_files_list_verify</span></code> argument.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.3.0.</span></p> </div> </dd> <dt>skip_files_list_verify<span class="classifier">False</span>
</dt>
<dd>
<p>Set this to <code class="docutils literal notranslate"><span class="pre">True</span></code> if archive should be extracted if <code class="docutils literal notranslate"><span class="pre">source_hash</span></code> has changed but only checksums of the archive will be checked to determine if the extraction is required.</p> <p>It will try to find a local cache of the <code class="docutils literal notranslate"><span class="pre">source</span></code> and check its hash against the <code class="docutils literal notranslate"><span class="pre">source_hash</span></code>. If there is no local cache available, for example if you set the <code class="docutils literal notranslate"><span class="pre">keep_source</span></code> to <code class="docutils literal notranslate"><span class="pre">False</span></code>, it will try to find a cached source hash file in the Minion archives cache directory.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The current limitation of this logic is that you have to set minions <code class="docutils literal notranslate"><span class="pre">hash_type</span></code> config option to the same one that you're going to pass via <code class="docutils literal notranslate"><span class="pre">source_hash</span></code> argument.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>With this argument set to <code class="docutils literal notranslate"><span class="pre">True</span></code> Salt will only check for the <code class="docutils literal notranslate"><span class="pre">source_hash</span></code> against the local hash of the <code class="docutils literal notranslate"><span class="pre">sourse</span></code>. So if you, for example, remove extracted files without clearing the Salt Minion cache next time you execute the state Salt will not notice that extraction is required if the hashes are still match.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3000.</span></p> </div> </dd> <dt>skip_verify<span class="classifier">False</span>
</dt>
<dd>
<p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, hash verification of remote file sources (<code class="docutils literal notranslate"><span class="pre">http://</span></code>, <code class="docutils literal notranslate"><span class="pre">https://</span></code>, <code class="docutils literal notranslate"><span class="pre">ftp://</span></code>) will be skipped, and the <code class="docutils literal notranslate"><span class="pre">source_hash</span></code> argument will be ignored.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.3.4.</span></p> </div> </dd> <dt>keep_source<span class="classifier">True</span>
</dt>
<dd>
<p>For <code class="docutils literal notranslate"><span class="pre">source</span></code> archives not local to the minion (i.e. from the Salt fileserver or a remote source such as <code class="docutils literal notranslate"><span class="pre">http(s)</span></code> or <code class="docutils literal notranslate"><span class="pre">ftp</span></code>), Salt will need to download the archive to the minion cache before they can be extracted. To remove the downloaded archive after extraction, set this argument to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2017.7.3.</span></p> </div> </dd> <dt>keep<span class="classifier">True</span>
</dt>
<dd>
<p>Same as <code class="docutils literal notranslate"><span class="pre">keep_source</span></code>, kept for backward-compatibility.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If both <code class="docutils literal notranslate"><span class="pre">keep_source</span></code> and <code class="docutils literal notranslate"><span class="pre">keep</span></code> are used, <code class="docutils literal notranslate"><span class="pre">keep</span></code> will be ignored.</p> </div> </dd> <dt>password</dt>
<dd>
<p><strong>For ZIP archives only.</strong> Password used for extraction.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.3.0.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.11.0: </span>The newly-added <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.is_encrypted" title="salt.modules.archive.is_encrypted"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.is_encrypted</span></code></a> function will be used to determine if the archive is password-protected. If it is, then the <code class="docutils literal notranslate"><span class="pre">password</span></code> argument will be required for the state to proceed.</p> </div> </dd> <dt>options</dt>
<dd>
<p><strong>For tar and zip archives only.</strong> This option can be used to specify a string of additional arguments to pass to the tar/zip command.</p> <p>If this argument is not used, then the minion will attempt to use Python's native <a class="reference external" href="https://docs.python.org/2/library/tarfile.html">tarfile</a>/<a class="reference external" href="https://docs.python.org/2/library/zipfile.html">zipfile</a> support to extract it. For zip archives, this argument is mostly used to overwrite existing files with <code class="docutils literal notranslate"><span class="pre">o</span></code>.</p> <p>Using this argument means that the <code class="docutils literal notranslate"><span class="pre">tar</span></code> or <code class="docutils literal notranslate"><span class="pre">unzip</span></code> command will be used, which is less platform-independent, so keep this in mind when using this option; the CLI options must be valid options for the <code class="docutils literal notranslate"><span class="pre">tar</span></code>/<code class="docutils literal notranslate"><span class="pre">unzip</span></code> implementation on the minion's OS.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.0.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2015.8.11,2016.3.2: </span>XZ-compressed tar archives no longer require <code class="docutils literal notranslate"><span class="pre">J</span></code> to manually be set in the <code class="docutils literal notranslate"><span class="pre">options</span></code>, they are now detected automatically and decompressed using the <a class="reference external" href="http://tukaani.org/xz/">xz</a> CLI command and extracted using <code class="docutils literal notranslate"><span class="pre">tar</span>
<span class="pre">xvf</span></code>. This is a more platform-independent solution, as not all tar implementations support the <code class="docutils literal notranslate"><span class="pre">J</span></code> argument for extracting archives.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For tar archives, main operators like <code class="docutils literal notranslate"><span class="pre">-x</span></code>, <code class="docutils literal notranslate"><span class="pre">--extract</span></code>, <code class="docutils literal notranslate"><span class="pre">--get</span></code>, <code class="docutils literal notranslate"><span class="pre">-c</span></code> and <code class="docutils literal notranslate"><span class="pre">-f</span></code>/<code class="docutils literal notranslate"><span class="pre">--file</span></code> should <em>not</em> be used here.</p> </div> </dd> <dt>list_options</dt>
<dd>
<p><strong>For tar archives only.</strong> This state uses <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.list_" title="salt.modules.archive.list_"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.list</span></code></a> to discover the contents of the source archive so that it knows which file paths should exist on the minion if the archive has already been extracted. For the vast majority of tar archives, <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.list_" title="salt.modules.archive.list_"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.list</span></code></a> "just works". Archives compressed using gzip, bzip2, and xz/lzma (with the help of the <a class="reference external" href="http://tukaani.org/xz/">xz</a> CLI command) are supported automatically. However, for archives compressed using other compression types, CLI options must be passed to <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.list_" title="salt.modules.archive.list_"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.list</span></code></a>.</p> <p>This argument will be passed through to <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.list_" title="salt.modules.archive.list_"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.list</span></code></a> as its <code class="docutils literal notranslate"><span class="pre">options</span></code> argument, to allow it to successfully list the archive's contents. For the vast majority of archives, this argument should not need to be used, it should only be needed in cases where the state fails with an error stating that the archive's contents could not be listed.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.0.</span></p> </div> </dd> <dt>force<span class="classifier">False</span>
</dt>
<dd>
<p>If a path that should be occupied by a file in the extracted result is instead a directory (or vice-versa), the state will fail. Set this argument to <code class="docutils literal notranslate"><span class="pre">True</span></code> to force these paths to be removed in order to allow the archive to be extracted.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Use this option <em>very</em> carefully.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.0.</span></p> </div> </dd> <dt>overwrite<span class="classifier">False</span>
</dt>
<dd>
<p>Set this to <code class="docutils literal notranslate"><span class="pre">True</span></code> to force the archive to be extracted. This is useful for cases where the filenames/directories have not changed, but the content of the files have.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.1.</span></p> </div> </dd> <dt>clean<span class="classifier">False</span>
</dt>
<dd>
<p>Set this to <code class="docutils literal notranslate"><span class="pre">True</span></code> to remove any top-level files and recursively remove any top-level directory paths before extracting.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Files will only be cleaned first if extracting the archive is deemed necessary, either by paths missing on the minion, or if <code class="docutils literal notranslate"><span class="pre">overwrite</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.1.</span></p> </div> </dd> <dt>clean_parent<span class="classifier">False</span>
</dt>
<dd>
<p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and the archive is extracted, delete the parent directory (i.e. the directory into which the archive is extracted), and then re-create that directory before extracting. Note that <code class="docutils literal notranslate"><span class="pre">clean</span></code> and <code class="docutils literal notranslate"><span class="pre">clean_parent</span></code> are mutually exclusive.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3000.</span></p> </div> </dd> <dt>user</dt>
<dd>
<p>The user to own each extracted file. Not available on Windows.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2015.8.0.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.3.0: </span>When used in combination with <code class="docutils literal notranslate"><span class="pre">if_missing</span></code>, ownership will only be enforced if <code class="docutils literal notranslate"><span class="pre">if_missing</span></code> is a directory.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.11.0: </span>Ownership will be enforced only on the file/directory paths found by running <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.list_" title="salt.modules.archive.list_"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.list</span></code></a> on the source archive. An alternative root directory on which to enforce ownership can be specified using the <code class="docutils literal notranslate"><span class="pre">enforce_ownership_on</span></code> argument.</p> </div> </dd> <dt>group</dt>
<dd>
<p>The group to own each extracted file. Not available on Windows.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2015.8.0.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.3.0: </span>When used in combination with <code class="docutils literal notranslate"><span class="pre">if_missing</span></code>, ownership will only be enforced if <code class="docutils literal notranslate"><span class="pre">if_missing</span></code> is a directory.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.11.0: </span>Ownership will be enforced only on the file/directory paths found by running <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.list_" title="salt.modules.archive.list_"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.list</span></code></a> on the source archive. An alternative root directory on which to enforce ownership can be specified using the <code class="docutils literal notranslate"><span class="pre">enforce_ownership_on</span></code> argument.</p> </div> </dd> <dt>if_missing</dt>
<dd>
<p>If specified, this path will be checked, and if it exists then the archive will not be extracted. This path can be either a directory or a file, so this option can also be used to check for a semaphore file and conditionally skip extraction.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.3.0: </span>When used in combination with either <code class="docutils literal notranslate"><span class="pre">user</span></code> or <code class="docutils literal notranslate"><span class="pre">group</span></code>, ownership will only be enforced when <code class="docutils literal notranslate"><span class="pre">if_missing</span></code> is a directory.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.11.0: </span>Ownership enforcement is no longer tied to this argument, it is simply checked for existence and extraction will be skipped if if is present.</p> </div> </dd> <dt>trim_output<span class="classifier">False</span>
</dt>
<dd>
<p>Useful for archives with many files in them. This can either be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (in which case only the first 100 files extracted will be in the state results), or it can be set to an integer for more exact control over the max number of files to include in the state results.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.3.0.</span></p> </div> </dd> <dt>use_cmd_unzip<span class="classifier">False</span>
</dt>
<dd>
<p>Set to <code class="docutils literal notranslate"><span class="pre">True</span></code> for zip files to force usage of the <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.cmd_unzip" title="salt.modules.archive.cmd_unzip"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.cmd_unzip</span></code></a> function to extract.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.0.</span></p> </div> </dd> <dt>extract_perms<span class="classifier">True</span>
</dt>
<dd>
<p><strong>For ZIP archives only.</strong> When using <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.unzip" title="salt.modules.archive.unzip"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.unzip</span></code></a> to extract ZIP archives, Salt works around an <a class="reference external" href="https://bugs.python.org/issue15795">upstream bug in Python</a> to set the permissions on extracted files/directories to match those encoded into the ZIP archive. Set this argument to <code class="docutils literal notranslate"><span class="pre">False</span></code> to skip this workaround.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.0.</span></p> </div> </dd> <dt>enforce_toplevel<span class="classifier">True</span>
</dt>
<dd>
<p>This option will enforce a single directory at the top level of the source archive, to prevent extracting a 'tar-bomb'. Set this argument to <code class="docutils literal notranslate"><span class="pre">False</span></code> to allow archives with files (or multiple directories) at the top level to be extracted.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.0.</span></p> </div> </dd> <dt>enforce_ownership_on</dt>
<dd>
<p>When <code class="docutils literal notranslate"><span class="pre">user</span></code> or <code class="docutils literal notranslate"><span class="pre">group</span></code> is specified, Salt will default to enforcing permissions on the file/directory paths detected by running <a class="reference internal" href="../../modules/all/salt.modules.archive.html#salt.modules.archive.list_" title="salt.modules.archive.list_"><code class="xref py py-func docutils literal notranslate"><span class="pre">archive.list</span></code></a> on the source archive. Use this argument to specify an alternate directory on which ownership should be enforced.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This path must be within the path specified by the <code class="docutils literal notranslate"><span class="pre">name</span></code> argument.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2016.11.0.</span></p> </div> </dd> <dt>archive_format</dt>
<dd>
<p>One of <code class="docutils literal notranslate"><span class="pre">tar</span></code>, <code class="docutils literal notranslate"><span class="pre">zip</span></code>, or <code class="docutils literal notranslate"><span class="pre">rar</span></code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2016.11.0: </span>If omitted, the archive format will be guessed based on the value of the <code class="docutils literal notranslate"><span class="pre">source</span></code> argument. If the minion is running a release older than 2016.11.0, this option is required.</p> </div> </dd> </dl> <p><strong>Examples</strong></p> <ol class="arabic"> <li>
<p>tar with lmza (i.e. xz) compression:</p> <pre class="highlight-yaml notranslate" data-language="yaml">graylog2-server:
  archive.extracted:
    - name: /opt/
    - source: https://github.com/downloads/Graylog2/graylog2-server/graylog2-server-0.9.6p1.tar.lzma
    - source_hash: md5=499ae16dcae71eeb7c3a30c75ea7a1a6</pre> </li> <li>
<p>tar archive with flag for verbose output, and enforcement of user/group ownership:</p> <pre class="highlight-yaml notranslate" data-language="yaml">graylog2-server:
  archive.extracted:
    - name: /opt/
    - source: https://github.com/downloads/Graylog2/graylog2-server/graylog2-server-0.9.6p1.tar.gz
    - source_hash: md5=499ae16dcae71eeb7c3a30c75ea7a1a6
    - options: v
    - user: foo
    - group: foo</pre> </li> <li>
<p>tar archive, with <code class="docutils literal notranslate"><span class="pre">source_hash_update</span></code> set to <code class="docutils literal notranslate"><span class="pre">True</span></code> to prevent state from attempting extraction unless the <code class="docutils literal notranslate"><span class="pre">source_hash</span></code> differs from the previous time the archive was extracted:</p> <pre class="highlight-yaml notranslate" data-language="yaml">graylog2-server:
  archive.extracted:
    - name: /opt/
    - source: https://github.com/downloads/Graylog2/graylog2-server/graylog2-server-0.9.6p1.tar.lzma
    - source_hash: md5=499ae16dcae71eeb7c3a30c75ea7a1a6
    - source_hash_update: True</pre> </li> </ol> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 SaltStack.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.saltproject.io/en/latest/ref/states/all/salt.states.archive.html" class="_attribution-link">https://docs.saltproject.io/en/latest/ref/states/all/salt.states.archive.html</a>
  </p>
</div>
