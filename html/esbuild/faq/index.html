<h1>FAQ</h1>
<p>This is a collection of common questions about esbuild. You can also ask questions on the <a href="https://github.com/evanw/esbuild/issues">GitHub issue tracker</a>.</p>
<ul> <li><a href="#why-is-esbuild-fast">Why is esbuild fast?</a></li> <li><a href="#benchmark-details">Benchmark details</a></li> <li><a href="#upcoming-roadmap">Upcoming roadmap</a></li> <li><a href="#production-readiness">Production readiness</a></li> <li><a href="#anti-virus-software">Anti-virus software</a></li> <li><a href="#old-go-version">Outdated version of Go</a></li> <li><a href="#minified-newlines">Minified newlines</a></li> <li><a href="#top-level-name-collisions">Avoiding name collisions</a></li> <li><a href="#top-level-var">Top-level <code>var</code></a></li> </ul>
<h2 id="why-is-esbuild-fast">Why is esbuild fast?</h2>
<p>Several reasons:</p>
<ul>
<li>
<p> It's written in <a href="https://go.dev/">Go</a> and compiles to native code. </p> <p> Most other bundlers are written in JavaScript, but a command-line application is a worst-case performance situation for a JIT-compiled language. Every time you run your bundler, the JavaScript VM is seeing your bundler's code for the first time without any optimization hints. While esbuild is busy parsing your JavaScript, node is busy parsing your bundler's JavaScript. By the time node has finished parsing your bundler's code, esbuild might have already exited and your bundler hasn't even started bundling yet. </p> <p> In addition, Go is designed from the core for parallelism while JavaScript is not. Go has shared memory between threads while JavaScript has to serialize data between threads. Both Go and JavaScript have parallel garbage collectors, but Go's heap is shared between all threads while JavaScript has a separate heap per JavaScript thread. This seems to cut the amount of parallelism that's possible with JavaScript worker threads in half <a href="https://github.com/evanw/esbuild/issues/111#issuecomment-719910381">according to my testing</a>, presumably since half of your CPU cores are busy collecting garbage for the other half. </p>
</li>
<li>
<p> Parallelism is used heavily. </p> <p> The algorithms inside esbuild are carefully designed to fully saturate all available CPU cores when possible. There are roughly three phases: parsing, linking, and code generation. Parsing and code generation are most of the work and are fully parallelizable (linking is an inherently serial task for the most part). Since all threads share memory, work can easily be shared when bundling different entry points that import the same JavaScript libraries. Most modern computers have many cores so parallelism is a big win. </p>
</li>
<li>
<p> Everything in esbuild is written from scratch. </p> <p> There are a lot of performance benefits with writing everything yourself instead of using 3rd-party libraries. You can have performance in mind from the beginning, you can make sure everything uses consistent data structures to avoid expensive conversions, and you can make wide architectural changes whenever necessary. The drawback is of course that it's a lot of work. </p> <p> For example, many bundlers use the official TypeScript compiler as a parser. But it was built to serve the goals of the TypeScript compiler team and they do not have performance as a top priority. Their code makes pretty heavy use of <a href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">megamorphic object shapes</a> and unnecessary <a href="https://github.com/microsoft/TypeScript/issues/39247">dynamic property accesses</a> (both well-known JavaScript speed bumps). And the TypeScript parser appears to still run the type checker even when type checking is disabled. None of these are an issue with esbuild's custom TypeScript parser. </p>
</li>
<li>
<p> Memory is used efficiently. </p> <p> Compilers are ideally mostly O(n) complexity in the length of the input. So if you are processing a lot of data, memory access speed is likely going to heavily affect performance. The fewer passes you have to make over your data (and also the fewer different representations you need to transform your data into), the faster your compiler will go. </p> <p> For example, esbuild only touches the whole JavaScript AST three times: </p> <ol> <li>A pass for lexing, parsing, scope setup, and declaring symbols</li> <li>A pass for binding symbols, minifying syntax, JSX/TS to JS, and ESNext-to-ES2015</li> <li>A pass for minifying identifiers, minifying whitespace, generating code, and generating source maps</li> </ol> <p> This maximizes reuse of AST data while it's still hot in the CPU cache. Other bundlers do these steps in separate passes instead of interleaving them. They may also convert between data representations to glue multiple libraries together (e.g. string→TS→JS→string, then string→JS→older JS→string, then string→JS→minified JS→string) which uses more memory and slows things down. </p> <p> Another benefit of Go is that it can store things compactly in memory, which enables it to use less memory and fit more in the CPU cache. All object fields have types and fields are packed tightly together so e.g. several boolean flags only take one byte each. Go also has value semantics and can embed one object directly in another so it comes "for free" without another allocation. JavaScript doesn't have these features and also has other drawbacks such as JIT overhead (e.g. hidden class slots) and inefficient representations (e.g. non-integer numbers are heap-allocated with pointers). </p>
</li>
</ul>
<p>Each one of these factors is only a somewhat significant speedup, but together they can result in a bundler that is multiple orders of magnitude faster than other bundlers commonly in use today.</p>
<h2 id="benchmark-details">Benchmark details</h2>
<p>Here are the details about each benchmark:</p>
<figcaption>JavaScript benchmark</figcaption><p>This benchmark approximates a large JavaScript codebase by duplicating the <a href="https://github.com/mrdoob/three.js">three.js</a> library 10 times and building a single bundle from scratch, without any caches. The benchmark can be run with <code>make bench-three</code> in the <a href="https://github.com/evanw/esbuild">esbuild repo</a>.</p>
<table> <thead> <tr> <th style="text-align:left">Bundler</th> <th style="text-align:right">Time</th> <th style="text-align:right">Relative slowdown</th> <th style="text-align:right">Absolute speed</th> <th style="text-align:right">Output size</th> </tr> </thead> <tbody> <tr> <td style="text-align:left">esbuild</td> <td style="text-align:right">0.39s</td> <td style="text-align:right">1x</td> <td style="text-align:right">1403.7 kloc/s</td> <td style="text-align:right">5.80mb</td> </tr> <tr> <td style="text-align:left">parcel 2</td> <td style="text-align:right">14.91s</td> <td style="text-align:right">38x</td> <td style="text-align:right">36.7 kloc/s</td> <td style="text-align:right">5.78mb</td> </tr> <tr> <td style="text-align:left">rollup 4 + terser</td> <td style="text-align:right">34.10s</td> <td style="text-align:right">87x</td> <td style="text-align:right">16.1 kloc/s</td> <td style="text-align:right">5.82mb</td> </tr> <tr> <td style="text-align:left">webpack 5</td> <td style="text-align:right">41.21s</td> <td style="text-align:right">106x</td> <td style="text-align:right">13.3 kloc/s</td> <td style="text-align:right">5.84mb</td> </tr> </tbody> </table>
<p>Each time reported is the best of three runs. I'm running esbuild with <code>--bundle <wbr>--minify <wbr>--sourcemap</wbr></wbr></code>. I used the <a href="https://github.com/rollup/plugins/tree/master/packages/terser"><code>@rollup/<wbr>plugin-<wbr>terser</wbr></wbr></code></a> plugin because Rollup itself doesn't support minification. Webpack 5 uses <code>--mode=<wbr>production <wbr>--devtool=<wbr>sourcemap</wbr></wbr></wbr></code>. Parcel 2 uses the default options. Absolute speed is based on the total line count including comments and blank lines, which is currently 547,441. The tests were done on a 6-core 2019 MacBook Pro with 16gb of RAM and with <a href="https://en.wikipedia.org/wiki/Spotlight_(software)">macOS Spotlight</a> disabled.</p>
<figcaption>TypeScript benchmark</figcaption><p>This benchmark uses the old <a href="https://github.com/rome/tools">Rome</a> code base (prior to their Rust rewrite) to approximate a large TypeScript codebase. All code must be combined into a single minified bundle with source maps and the resulting bundle must work correctly. The benchmark can be run with <code>make bench-rome</code> in the <a href="https://github.com/evanw/esbuild">esbuild repo</a>.</p>
<table> <thead> <tr> <th style="text-align:left">Bundler</th> <th style="text-align:right">Time</th> <th style="text-align:right">Relative slowdown</th> <th style="text-align:right">Absolute speed</th> <th style="text-align:right">Output size</th> </tr> </thead> <tbody> <tr> <td style="text-align:left">esbuild</td> <td style="text-align:right">0.10s</td> <td style="text-align:right">1x</td> <td style="text-align:right">1318.4 kloc/s</td> <td style="text-align:right">0.97mb</td> </tr> <tr> <td style="text-align:left">parcel 2</td> <td style="text-align:right">6.91ѕ</td> <td style="text-align:right">69x</td> <td style="text-align:right">16.1 kloc/s</td> <td style="text-align:right">0.96mb</td> </tr> <tr> <td style="text-align:left">webpack 5</td> <td style="text-align:right">16.69ѕ</td> <td style="text-align:right">167x</td> <td style="text-align:right">8.3 kloc/s</td> <td style="text-align:right">1.27mb</td> </tr> </tbody> </table>
<p>Each time reported is the best of three runs. I'm running esbuild with <code>--bundle <wbr>--minify <wbr>--sourcemap <wbr>--platform=<wbr>node</wbr></wbr></wbr></wbr></code>. Webpack 5 uses <a href="https://github.com/TypeStrong/ts-loader"><code>ts-loader</code></a> with <code>transpileOnly: <wbr>true</wbr></code> and <code>--mode=<wbr>production <wbr>--devtool=<wbr>sourcemap</wbr></wbr></wbr></code>. Parcel 2 uses <code>"engines": <wbr>"node"</wbr></code> in <code>package.json</code>. Absolute speed is based on the total line count including comments and blank lines, which is currently 131,836. The tests were done on a 6-core 2019 MacBook Pro with 16gb of RAM and with <a href="https://en.wikipedia.org/wiki/Spotlight_(software)">macOS Spotlight</a> disabled.</p>
<p>The results don't include Rollup because I couldn't get it to work for reasons relating to TypeScript compilation. I tried <a href="https://github.com/rollup/plugins/tree/master/packages/typescript"><code>@rollup/<wbr>plugin-<wbr>typescript</wbr></wbr></code></a> but you can't disable type checking, and I tried <a href="https://github.com/rollup/plugins/tree/master/packages/sucrase"><code>@rollup/<wbr>plugin-<wbr>sucrase</wbr></wbr></code></a> but there's no way to provide a <code>tsconfig.json</code> file (which is required for correct path resolution).</p>
<h2 id="upcoming-roadmap">Upcoming roadmap</h2>
<p>These features are already in progress and are first priority:</p>
<ul><li>Code splitting (<a href="https://github.com/evanw/esbuild/issues/16">#16</a>, <a href="../api/index.html#splitting">docs</a>)</li></ul>
<p>These are potential future features but may not happen or may happen to a more limited extent:</p>
<ul><li>HTML content type (<a href="https://github.com/evanw/esbuild/issues/31">#31</a>)</li></ul>
<p>After that point, I will consider esbuild to be relatively complete. I'm planning for esbuild to reach a mostly stable state and then stop accumulating more features. This will involve saying "no" to requests for adding major features to esbuild itself. I don't think esbuild should become an all-in-one solution for all frontend needs. In particular, I want to avoid the pain and problems of the "webpack config" model where the underlying tool is too flexible and usability suffers.</p>
<p>For example, I am <em>not</em> planning to include these features in esbuild's core itself:</p>
<ul>
<li>Support for other frontend languages (e.g. <a href="https://elm-lang.org/">Elm</a>, <a href="https://svelte.dev/">Svelte</a>, <a href="https://vuejs.org/">Vue</a>, <a href="https://angular.io/">Angular</a>)</li>
<li>TypeScript type checking (just run <code>tsc</code> separately)</li>
<li>An API for custom AST manipulation</li>
<li>Hot-module reloading</li>
<li>Module federation</li>
</ul>
<p>I hope that the extensibility points I'm adding to esbuild (<a href="../plugins/index.html">plugins</a> and the <a href="../api/index.html">API</a>) will make esbuild useful to include as part of more customized build workflows, but I'm not intending or expecting these extensibility points to cover all use cases. If you have very custom requirements then you should be using other tools. I also hope esbuild inspires other build tools to dramatically improve performance by overhauling their implementations so that everyone can benefit, not just those that use esbuild.</p>
<p>I am planning to continue to maintain everything in esbuild's existing scope even after esbuild reaches stability. This means implementing support for newly-released JavaScript and TypeScript syntax features, for example.</p>
<h2 id="production-readiness">Production readiness</h2>
<p>This project has not yet hit version 1.0.0 and is still in active development. That said, it is far beyond the alpha stage and is pretty stable. I think of it as a late-stage beta. For some early-adopters that means it's good enough to use for real things. Some other people think this means esbuild isn't ready yet. This section doesn't try to convince you either way. It just tries to give you enough information so you can decide for yourself whether you want to use esbuild as your bundler.</p>
<p>Some data points:</p>
<ul>
<li>
<strong>Used by other projects</strong> <p> The API is already being used as a library within many other developer tools. For example, <a href="https://vitejs.dev/">Vite</a> and <a href="https://www.snowpack.dev/">Snowpack</a> are using esbuild to transform TypeScript into JavaScript and <a href="https://aws.amazon.com/cdk/">Amazon CDK</a> (Cloud Development Kit) and <a href="https://www.phoenixframework.org/">Phoenix</a> are using esbuild to bundle code. </p>
</li>
<li>
<strong>API stability</strong> <p> Even though esbuild's version is not yet 1.0.0, effort is still made to keep the API stable. Patch versions are intended for backwards-compatible changes and minor versions are intended for backwards-incompatible changes. If you plan to use esbuild for something real, you should either pin the exact version (maximum safety) or pin the major and minor versions (only accept backwards-compatible upgrades). </p>
</li>
<li>
<strong>Only one main developer</strong> <p> This tool is primarily built by <a href="https://github.com/evanw">me</a>. For some people this is fine, but for others this means esbuild is not a suitable tool for their organization. That's ok with me. I'm building esbuild because I find it fun to build and because it's the tool I'd want to use. I'm sharing it with the world because there are others that want to use it too, because the feedback makes the tool itself better, and because I think it will inspire the ecosystem to make better tools. </p>
</li>
<li>
<strong>Not always open to scope expansion</strong> <p> I'm not planning on including major features that I'm not interested in building and/or maintaining. I also want to limit the project's scope so it doesn't get too complex and unwieldy, both from an architectural perspective, a testing and correctness perspective, and from a usability perspective. Think of esbuild as a "linker" for the web. It knows how to transform and bundle JavaScript and CSS. But the details of how your source code ends up as plain JavaScript or CSS may need to be 3rd-party code. </p> <p> I'm hoping that <a href="../plugins/index.html">plugins</a> will allow the community to add major features (e.g. WebAssembly import) without needing to contribute to esbuild itself. However, not everything is exposed in the plugin API and it may be the case that it's not possible to add a particular feature to esbuild that you may want to add. This is intentional; esbuild is not meant to be an all-in-one solution for all frontend needs. </p>
</li>
</ul>
<h2 id="anti-virus-software">Anti-virus software</h2>
<p>Since esbuild is written in native code, anti-virus software can sometimes incorrectly flag it as a virus. <em>This does not mean esbuild is a virus.</em> I do not publish malicious code and I take supply chain security very seriously.</p>
<p>Virtually all of esbuild's code is first-party code except for <a href="https://github.com/evanw/esbuild/blob/main/go.mod">one dependency</a> on Google's set of supplemental Go packages. My development work is done on different machine that is isolated from the one I use to publish builds. I have done additional work to ensure that esbuild's published builds are completely reproducible and after every release, published builds are <a href="https://github.com/evanw/esbuild/blob/main/.github/workflows/validate.yml">automatically compared</a> to ones locally-built in an unrelated environment to ensure that they are bitwise identical (i.e. that the Go compiler itself has not been compromised). You can also build esbuild from source yourself and compare your build artifacts to the published ones to independently verify this.</p>
<p>Having to deal with false-positives is an unfortunate reality of using anti-virus software. Here are some possible workarounds if your anti-virus won't let you use esbuild:</p>
<ul>
<li>Ignore your anti-virus software and remove esbuild from quarantine</li>
<li>Report the specific esbuild native executable as a false-positive to your anti-virus software vendor</li>
<li>Use <a href="../getting-started/index.html#wasm"><code>esbuild-wasm</code></a> instead of <code>esbuild</code> to bypass your anti-virus software (which likely won't flag WebAssembly files the same way it flags native executables)</li>
<li>Use another build tool instead of esbuild</li>
</ul>
<h2 id="old-go-version">Outdated version of Go</h2>
<p>If you use an automated dependency vulnerability scanner, you may get a report that the version of the Go compiler that esbuild uses and/or the version of <code>golang.org/x/sys</code> (esbuild's only dependency) is outdated. These reports are benign and should be ignored.</p>
<p>This happens because esbuild's code is deliberately intended to be compilable with Go 1.13. Later versions of Go have dropped support for certain older platforms that I want esbuild to be able to run on (e.g. older versions of macOS). While esbuild's published binaries are compiled with a much newer version of the Go compiler (and therefore don't work on older versions of macOS), you are currently still able to compile the latest version of esbuild for yourself with Go 1.13 and use it on older versions of macOS because esbuild's code can still be compiled with Go as far back as 1.13.</p>
<p>People and/or automated tools sometimes see the <code>go 1.13</code> line in <a href="https://github.com/evanw/esbuild/blob/main/go.mod"><code>go.mod</code></a> and complain that esbuild's published binaries are built with Go 1.13, which is a really old version of Go. However, that's not true. That line in <code>go.mod</code> only specifies the minimum compiler version. It has nothing to do with the version of Go that esbuild's published binaries are built with, which is a much newer version of Go. <a href="https://go.dev/ref/mod#go-mod-file-go">Please read the documentation.</a></p>
<p>People also sometimes want esbuild to update the <code>golang.org/x/sys</code> dependency because there is a known vulnerability in the version that esbuild uses (specifically <a href="https://pkg.go.dev/vuln/GO-2022-0493">GO-2022-0493</a> about the <code>Faccessat</code> function). The problem that prevents esbuild from updating to a newer version of the <code>golang.org/x/sys</code> dependency is that newer versions have started using the <code>unsafe.Slice</code> function, which was first introduced in Go 1.17 (and therefore doesn't compile in older versions of Go). However, this vulnerability report is irrelevant because a) esbuild doesn't ever call that function in the first place and b) esbuild is a build tool, not a sandbox, and esbuild's file system access is not security-sensitive.</p>
<p>I'm not going to drop compatibility with older platforms and prevent some people from being able to use esbuild just to work around irrelevant vulnerability reports. Please ignore any reports about the issues described above.</p>
<h2 id="minified-newlines">Minified newlines</h2>
<p>People are sometimes surprised that esbuild's minifier typically changes the character escape sequence <code>\n</code> within JavaScript strings into a newline character in a template literal. But this is intentional. <strong>This is not a bug with esbuild</strong>. The job of a minifier is to generate as compact an output as possible that's equivalent to the input. The character escape sequence <code>\n</code> is two bytes long while a newline character is one byte long.</p>
<p>For example, this code is 21 bytes long:</p>
<pre data-language="javascript" class="">var text="a\nb\nc\n";</pre>
<p>While this code is 18 bytes long:</p>
<pre data-language="javascript" class="">var text=`a
b
c
`;</pre>
<p>So the second code is fully minified while the first one isn't. Minifying code does not mean putting it all on one line. Instead, minifying code means generating equivalent code that uses as few bytes as possible. In JavaScript, an untagged template literal is equivalent to a string literal, so esbuild is doing the correct thing here.</p>
<h2 id="top-level-name-collisions">Avoiding name collisions</h2>
<p>Top-level variables in an entry point module should never end up in the global scope when running esbuild's output in a browser. If that happens, it means you did not follow <a href="../api/index.html#format">esbuild's documentation about output formats</a> and are using esbuild incorrectly. <strong>This is not a bug with esbuild.</strong></p>
<p>Specifically, you must do either one of the following when running esbuild's output in a browser:</p>
<ol>
<li>
<code>--format=<wbr>iife</wbr></code> with <code>&lt;script <wbr>src="..."&gt;</wbr></code> <p> If you are running your code in the global scope, then you should be using <code>--format=<wbr>iife</wbr></code>. This causes esbuild's output to wrap your code so that top-level variables are declared in a nested scope. </p>
</li>
<li>
<code>--format=<wbr>esm</wbr></code> with <code>&lt;script <wbr>src="..." <wbr>type="module"&gt;</wbr></wbr></code> <p> If you are using <code>--format=<wbr>esm</wbr></code>, then you must run your code as a module. This causes the browser to wrap your code so that top-level variables are declared in a nested scope. </p>
</li>
</ol>
<p>Using <code>--format=<wbr>esm</wbr></code> with <code>&lt;script <wbr>src="..."&gt;</wbr></code> will break your code in subtle and confusing ways (omitting <code>type="<wbr>module"</wbr></code> means that all top-level variables will end up in the global scope, which will then collide with top-level variables that have the same name in other JavaScript files).</p>
<h2 id="top-level-var">Top-level <code>var</code>
</h2>
<p>People are sometimes surprised that esbuild sometimes rewrites top-level <code>let</code>, <code>const</code>, and <code>class</code> declarations as <code>var</code> declarations instead. This is done for a few reasons:</p>
<ul>
<li>
<strong>For correctness</strong> <p> Bundling sometimes needs to lazily-initialize a module. For example, this happens when you call <code>require()</code> or <code>import()</code> using the path of a module within the bundle. Doing this involves separating the declaration and initialization of top-level symbols by moving the initialization into a closure. So for example <code>class</code> statements are rewritten as an assignment of a class expression to a variable. Keeping the declarations out of the lazy-initialization closure is important for performance, since it means other modules can reference them directly instead by name instead of indirectly via a slower property access. </p> <p> Another case where this is needed is when transforming top-level <code>using</code> declarations. This involves wrapping the entire module body in a <code>try</code> block, which also involves separating the declaration and initialization of top-level symbols. Top-level symbols may need to be exported, which means they cannot be declared within the <code>try</code> block. </p> <p> In both of these cases esbuild will fail with a build error if the source code contains a mutation of a <code>const</code> symbol, so it's not possible for esbuild's rewriting of top-level <code>const</code> into <code>var</code> to result in the mutation of a constant. </p> <p> Due to esbuild's current architecture, the part of esbuild that does this transformation (the parser) cannot know whether the current module will end up being lazily initialized or not. The information for this decision may only be discovered later on in the build, or may even change in future incremental builds that reuse the same AST (per-file ASTs are transformed once during parsing and then cached and reused across incremental builds). So this transformation is always done when bundling is active. </p>
</li>
<li>
<strong>For performance</strong> <p> Multiple JavaScript VMs have had and continue to have performance issues with TDZ (i.e. "temporal dead zone") checks. These checks validate that a let, or const, or class symbol isn't used before it's initialized. Here are two issues with well-known VMs: </p> <ul> <li> V8: <a href="https://bugs.chromium.org/p/v8/issues/detail?id=13723">https://bugs.chromium.org/p/v8/issues/detail?id=13723</a> (10% slowdown) </li> <li> JavaScriptCore: <a href="https://bugs.webkit.org/show_bug.cgi?id=199866">https://bugs.webkit.org/show_bug.cgi?id=199866</a> (1,000% slowdown!) </li> </ul> <p> JavaScriptCore had a severe performance issue as their TDZ implementation had time complexity that was quadratic in the number of variables needing TDZ checks in the same scope (with the top-level scope typically being the worst offender). V8 has ongoing issues with TDZ checks being present throughout the code their JIT generates even when they have already been checked earlier in the same function or when the function in question has already been run (so the checks have already happened). </p> <p> In JavaScript, <code>let</code>, <code>const</code>, and <code>class</code> declarations all introduce TDZ checks while <code>var</code> declarations do not. Since bundling typically merges many modules into a single very large top-level scope, the performance impact of these TDZ checks can be pretty severe. Converting top-level <code>let</code>, <code>const</code>, and <code>class</code> declarations into <code>var</code> helps automatically make your code faster. </p>
</li>
</ul>
<p>Note that esbuild doesn't preserve top-level TDZ side effects because modules may need to be lazily initialized (as described above), which means separating declaration from initialization. TDZ checks for top-level symbols could hypothetically still be supported by generating extra code that checks before each use of a top-level symbol and throws if it hasn't been initialized yet (effectively manually implementing what a real JavaScript VM would do). However, this seems like an excessive overhead for both code size and run time, and does not seem like something that a production-oriented bundler should do.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2020 Evan Wallace<br>Licensed under the MIT License.<br>
    <a href="https://esbuild.github.io/faq/" class="_attribution-link">https://esbuild.github.io/faq/</a>
  </p>
</div>
