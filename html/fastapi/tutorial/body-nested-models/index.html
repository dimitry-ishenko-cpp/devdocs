<h1 id="body-nested-models">Body - Nested Models</h1> <p>With <strong>FastAPI</strong>, you can define, validate, document, and use arbitrarily deeply nested models (thanks to Pydantic).</p> <h2 id="list-fields">List fields</h2> <p>You can define an attribute to be a subtype. For example, a Python <code>list</code>:</p> <div class="tabbed-set tabbed-alternate" data-tabs="1:2"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_1_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_1_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <p>This will make <code>tags</code> be a list, although it doesn't declare the type of the elements of the list.</p> <h2 id="list-fields-with-type-parameter">List fields with type parameter</h2> <p>But Python has a specific way to declare lists with internal types, or "type parameters":</p> <h3 id="import-typings-list">Import typing's <code>List</code>
</h3> <p>In Python 3.9 and above you can use the standard <code>list</code> to declare these type annotations as we'll see below. ðŸ’¡</p> <p>But in Python versions before 3.9 (3.6 and above), you first need to import <code>List</code> from standard Python's <code>typing</code> module:</p> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: List[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> <h3 id="declare-a-list-with-a-type-parameter">Declare a <code>list</code> with a type parameter</h3> <p>To declare types that have type parameters (internal types), like <code>list</code>, <code>dict</code>, <code>tuple</code>:</p> <ul> <li>If you are in a Python version lower than 3.9, import their equivalent version from the <code>typing</code> module</li> <li>Pass the internal type(s) as "type parameters" using square brackets: <code>[</code> and <code>]</code>
</li> </ul> <p>In Python 3.9 it would be:</p> <div class="highlight"><pre class="language-python" data-language="python">my_list: list[str]
</pre></div> <p>In versions of Python before 3.9, it would be:</p> <div class="highlight"><pre class="language-python" data-language="python">from typing import List

my_list: List[str]
</pre></div> <p>That's all standard Python syntax for type declarations.</p> <p>Use that same standard syntax for model attributes with internal types.</p> <p>So, in our example, we can make <code>tags</code> be specifically a "list of strings":</p> <div class="tabbed-set tabbed-alternate" data-tabs="2:3"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_2_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_2_2">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_2_3">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: List[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <h2 id="set-types">Set types</h2> <p>But then we think about it, and realize that tags shouldn't repeat, they would probably be unique strings.</p> <p>And Python has a special data type for sets of unique items, the <code>set</code>.</p> <p>Then we can declare <code>tags</code> as a set of strings:</p> <div class="tabbed-set tabbed-alternate" data-tabs="3:3"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_3_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_3_2">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_3_3">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <p>With this, even if you receive a request with duplicate data, it will be converted to a set of unique items.</p> <p>And whenever you output that data, even if the source had duplicates, it will be output as a set of unique items.</p> <p>And it will be annotated / documented accordingly too.</p> <h2 id="nested-models">Nested Models</h2> <p>Each attribute of a Pydantic model has a type.</p> <p>But that type can itself be another Pydantic model.</p> <p>So, you can declare deeply nested JSON "objects" with specific attribute names, types and validations.</p> <p>All that, arbitrarily nested.</p> <h3 id="define-a-submodel">Define a submodel</h3> <p>For example, we can define an <code>Image</code> model:</p> <div class="tabbed-set tabbed-alternate" data-tabs="4:3"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_4_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_4_2">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_4_3">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <h3 id="use-the-submodel-as-a-type">Use the submodel as a type</h3> <p>And then we can use it as the type of an attribute:</p> <div class="tabbed-set tabbed-alternate" data-tabs="5:3"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_5_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_5_2">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_5_3">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <p>This would mean that <strong>FastAPI</strong> would expect a body similar to:</p> <div class="highlight"><pre class="language-python" data-language="python">{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": ["rock", "metal", "bar"],
    "image": {
        "url": "http://example.com/baz.jpg",
        "name": "The Foo live"
    }
}
</pre></div> <p>Again, doing just that declaration, with <strong>FastAPI</strong> you get:</p> <ul> <li>Editor support (completion, etc.), even for nested models</li> <li>Data conversion</li> <li>Data validation</li> <li>Automatic documentation</li> </ul> <h2 id="special-types-and-validation">Special types and validation</h2> <p>Apart from normal singular types like <code>str</code>, <code>int</code>, <code>float</code>, etc. you can use more complex singular types that inherit from <code>str</code>.</p> <p>To see all the options you have, checkout the docs for <a href="https://docs.pydantic.dev/latest/concepts/types/" class="external-link" target="_blank">Pydantic's exotic types</a>. You will see some examples in the next chapter.</p> <p>For example, as in the <code>Image</code> model we have a <code>url</code> field, we can declare it to be an instance of Pydantic's <code>HttpUrl</code> instead of a <code>str</code>:</p> <div class="tabbed-set tabbed-alternate" data-tabs="6:3"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_6_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_6_2">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_6_3">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <p>The string will be checked to be a valid URL, and documented in JSON Schema / OpenAPI as such.</p> <h2 id="attributes-with-lists-of-submodels">Attributes with lists of submodels</h2> <p>You can also use Pydantic models as subtypes of <code>list</code>, <code>set</code>, etc.:</p> <div class="tabbed-set tabbed-alternate" data-tabs="7:3"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_7_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    images: list[Image] | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_7_2">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    images: Union[list[Image], None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_7_3">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Set, Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    images: Union[List[Image], None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <p>This will expect (convert, validate, document, etc.) a JSON body like:</p> <div class="highlight"><pre class="language-python" data-language="python">{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": [
        "rock",
        "metal",
        "bar"
    ],
    "images": [
        {
            "url": "http://example.com/baz.jpg",
            "name": "The Foo live"
        },
        {
            "url": "http://example.com/dave.jpg",
            "name": "The Baz"
        }
    ]
}
</pre></div> <div class="admonition info"> <p class="admonition-title">Info</p> <p>Notice how the <code>images</code> key now has a list of image objects.</p> </div> <h2 id="deeply-nested-models">Deeply nested models</h2> <p>You can define arbitrarily deeply nested models:</p> <div class="tabbed-set tabbed-alternate" data-tabs="8:3"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_8_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    images: list[Image] | None = None


class Offer(BaseModel):
    name: str
    description: str | None = None
    price: float
    items: list[Item]


@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_8_2">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    images: Union[list[Image], None] = None


class Offer(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    items: list[Item]


@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_8_3">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Set, Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    images: Union[List[Image], None] = None


class Offer(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    items: List[Item]


@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer
</pre></div> </div> </div> </div> <div class="admonition info"> <p class="admonition-title">Info</p> <p>Notice how <code>Offer</code> has a list of <code>Item</code>s, which in turn have an optional list of <code>Image</code>s</p> </div> <h2 id="bodies-of-pure-lists">Bodies of pure lists</h2> <p>If the top level value of the JSON body you expect is a JSON <code>array</code> (a Python <code>list</code>), you can declare the type in the parameter of the function, the same as in Pydantic models:</p> <div class="highlight"><pre class="language-python" data-language="python">images: List[Image]
</pre></div> <p>or in Python 3.9 and above:</p> <div class="highlight"><pre class="language-python" data-language="python">images: list[Image]
</pre></div> <p>as in:</p> <div class="tabbed-set tabbed-alternate" data-tabs="9:2"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_9_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


@app.post("/images/multiple/")
async def create_multiple_images(images: list[Image]):
    return images
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_9_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


@app.post("/images/multiple/")
async def create_multiple_images(images: List[Image]):
    return images
</pre></div> </div> </div> </div> <h2 id="editor-support-everywhere">Editor support everywhere</h2> <p>And you get editor support everywhere.</p> <p>Even for items inside of lists:</p> <p><img src="data:image/png;base64,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"></p> <p>You couldn't get this kind of editor support if you were working directly with <code>dict</code> instead of Pydantic models.</p> <p>But you don't have to worry about them either, incoming dicts are converted automatically and your output is converted automatically to JSON too.</p> <h2 id="bodies-of-arbitrary-dicts">Bodies of arbitrary <code>dict</code>s</h2> <p>You can also declare a body as a <code>dict</code> with keys of some type and values of some other type.</p> <p>This way, you don't have to know beforehand what the valid field/attribute names are (as would be the case with Pydantic models).</p> <p>This would be useful if you want to receive keys that you don't already know.</p> <hr> <p>Another useful case is when you want to have keys of another type (e.g., <code>int</code>).</p> <p>That's what we are going to see here.</p> <p>In this case, you would accept any <code>dict</code> as long as it has <code>int</code> keys with <code>float</code> values:</p> <div class="tabbed-set tabbed-alternate" data-tabs="10:2"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_10_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI

app = FastAPI()


@app.post("/index-weights/")
async def create_index_weights(weights: dict[int, float]):
    return weights
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_10_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Dict

from fastapi import FastAPI

app = FastAPI()


@app.post("/index-weights/")
async def create_index_weights(weights: Dict[int, float]):
    return weights
</pre></div> </div> </div> </div> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Keep in mind that JSON only supports <code>str</code> as keys.</p> <p>But Pydantic has automatic data conversion.</p> <p>This means that, even though your API clients can only send strings as keys, as long as those strings contain pure integers, Pydantic will convert them and validate them.</p> <p>And the <code>dict</code> you receive as <code>weights</code> will actually have <code>int</code> keys and <code>float</code> values.</p> </div> <h2 id="recap">Recap</h2> <p>With <strong>FastAPI</strong> you have the maximum flexibility provided by Pydantic models, while keeping your code simple, short and elegant.</p> <p>But with all the benefits:</p> <ul> <li>Editor support (completion everywhere!)</li> <li>Data conversion (a.k.a. parsing / serialization)</li> <li>Data validation</li> <li>Schema documentation</li> <li>Automatic docs</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2018 SebastiÃ¡n RamÃ­rez<br>Licensed under the MIT License.<br>
    <a href="https://fastapi.tiangolo.com/tutorial/body-nested-models/" class="_attribution-link">https://fastapi.tiangolo.com/tutorial/body-nested-models/</a>
  </p>
</div>
