<h1 id="body-nested-models">Body - Nested Models</h1> <p>With <strong>FastAPI</strong>, you can define, validate, document, and use arbitrarily deeply nested models (thanks to Pydantic).</p> <h2 id="list-fields">List fields</h2> <p>You can define an attribute to be a subtype. For example, a Python <code>list</code>:</p> <div class="tabbed-set tabbed-alternate" data-tabs="1:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_1_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="2:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_2_1">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> </details> <p>This will make <code>tags</code> be a list, although it doesn't declare the type of the elements of the list.</p> <h2 id="list-fields-with-type-parameter">List fields with type parameter</h2> <p>But Python has a specific way to declare lists with internal types, or "type parameters":</p> <h3 id="import-typings-list">Import typing's <code>List</code>
</h3> <p>In Python 3.9 and above you can use the standard <code>list</code> to declare these type annotations as we'll see below. ðŸ’¡</p> <p>But in Python versions before 3.9 (3.6 and above), you first need to import <code>List</code> from standard Python's <code>typing</code> module:</p> <div class="tabbed-set tabbed-alternate" data-tabs="3:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_3_1">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: List[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="4:2"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_4_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_4_2">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> </details> <h3 id="declare-a-list-with-a-type-parameter">Declare a <code>list</code> with a type parameter</h3> <p>To declare types that have type parameters (internal types), like <code>list</code>, <code>dict</code>, <code>tuple</code>:</p> <ul> <li>If you are in a Python version lower than 3.9, import their equivalent version from the <code>typing</code> module</li> <li>Pass the internal type(s) as "type parameters" using square brackets: <code>[</code> and <code>]</code>
</li> </ul> <p>In Python 3.9 it would be:</p> <div class="highlight"><pre class="language-python" data-language="python">my_list: list[str]
</pre></div> <p>In versions of Python before 3.9, it would be:</p> <div class="highlight"><pre class="language-python" data-language="python">from typing import List

my_list: List[str]
</pre></div> <p>That's all standard Python syntax for type declarations.</p> <p>Use that same standard syntax for model attributes with internal types.</p> <p>So, in our example, we can make <code>tags</code> be specifically a "list of strings":</p> <div class="tabbed-set tabbed-alternate" data-tabs="5:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_5_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="6:2"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_6_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_6_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: List[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> </details> <h2 id="set-types">Set types</h2> <p>But then we think about it, and realize that tags shouldn't repeat, they would probably be unique strings.</p> <p>And Python has a special data type for sets of unique items, the <code>set</code>.</p> <p>Then we can declare <code>tags</code> as a set of strings:</p> <div class="tabbed-set tabbed-alternate" data-tabs="7:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_7_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="8:2"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_8_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_8_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> </details> <p>With this, even if you receive a request with duplicate data, it will be converted to a set of unique items.</p> <p>And whenever you output that data, even if the source had duplicates, it will be output as a set of unique items.</p> <p>And it will be annotated / documented accordingly too.</p> <h2 id="nested-models">Nested Models</h2> <p>Each attribute of a Pydantic model has a type.</p> <p>But that type can itself be another Pydantic model.</p> <p>So, you can declare deeply nested JSON "objects" with specific attribute names, types and validations.</p> <p>All that, arbitrarily nested.</p> <h3 id="define-a-submodel">Define a submodel</h3> <p>For example, we can define an <code>Image</code> model:</p> <div class="tabbed-set tabbed-alternate" data-tabs="9:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_9_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="10:2"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_10_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_10_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> </details> <h3 id="use-the-submodel-as-a-type">Use the submodel as a type</h3> <p>And then we can use it as the type of an attribute:</p> <div class="tabbed-set tabbed-alternate" data-tabs="11:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_11_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="12:2"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_12_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_12_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> </details> <p>This would mean that <strong>FastAPI</strong> would expect a body similar to:</p> <div class="highlight"><pre class="language-python" data-language="python">{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": ["rock", "metal", "bar"],
    "image": {
        "url": "http://example.com/baz.jpg",
        "name": "The Foo live"
    }
}
</pre></div> <p>Again, doing just that declaration, with <strong>FastAPI</strong> you get:</p> <ul> <li>Editor support (completion, etc.), even for nested models</li> <li>Data conversion</li> <li>Data validation</li> <li>Automatic documentation</li> </ul> <h2 id="special-types-and-validation">Special types and validation</h2> <p>Apart from normal singular types like <code>str</code>, <code>int</code>, <code>float</code>, etc. you can use more complex singular types that inherit from <code>str</code>.</p> <p>To see all the options you have, checkout <a href="https://docs.pydantic.dev/latest/concepts/types/" class="external-link" target="_blank">Pydantic's Type Overview</a>. You will see some examples in the next chapter.</p> <p>For example, as in the <code>Image</code> model we have a <code>url</code> field, we can declare it to be an instance of Pydantic's <code>HttpUrl</code> instead of a <code>str</code>:</p> <div class="tabbed-set tabbed-alternate" data-tabs="13:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_13_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="14:2"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_14_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_14_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> </details> <p>The string will be checked to be a valid URL, and documented in JSON Schema / OpenAPI as such.</p> <h2 id="attributes-with-lists-of-submodels">Attributes with lists of submodels</h2> <p>You can also use Pydantic models as subtypes of <code>list</code>, <code>set</code>, etc.:</p> <div class="tabbed-set tabbed-alternate" data-tabs="15:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_15_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    images: list[Image] | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="16:2"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_16_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    images: Union[list[Image], None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_16_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Set, Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    images: Union[List[Image], None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
</pre></div> </div> </div> </div> </details> <p>This will expect (convert, validate, document, etc.) a JSON body like:</p> <div class="highlight"><pre class="language-python" data-language="python">{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": [
        "rock",
        "metal",
        "bar"
    ],
    "images": [
        {
            "url": "http://example.com/baz.jpg",
            "name": "The Foo live"
        },
        {
            "url": "http://example.com/dave.jpg",
            "name": "The Baz"
        }
    ]
}
</pre></div> <div class="admonition info"> <p class="admonition-title">Info</p> <p>Notice how the <code>images</code> key now has a list of image objects.</p> </div> <h2 id="deeply-nested-models">Deeply nested models</h2> <p>You can define arbitrarily deeply nested models:</p> <div class="tabbed-set tabbed-alternate" data-tabs="17:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_17_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    images: list[Image] | None = None


class Offer(BaseModel):
    name: str
    description: str | None = None
    price: float
    items: list[Item]


@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer
</pre></div> </div> </div> </div> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="18:2"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_18_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    images: Union[list[Image], None] = None


class Offer(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    items: list[Item]


@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_18_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Set, Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    images: Union[List[Image], None] = None


class Offer(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    items: List[Item]


@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer
</pre></div> </div> </div> </div> </details> <div class="admonition info"> <p class="admonition-title">Info</p> <p>Notice how <code>Offer</code> has a list of <code>Item</code>s, which in turn have an optional list of <code>Image</code>s</p> </div> <h2 id="bodies-of-pure-lists">Bodies of pure lists</h2> <p>If the top level value of the JSON body you expect is a JSON <code>array</code> (a Python <code>list</code>), you can declare the type in the parameter of the function, the same as in Pydantic models:</p> <div class="highlight"><pre class="language-python" data-language="python">images: List[Image]
</pre></div> <p>or in Python 3.9 and above:</p> <div class="highlight"><pre class="language-python" data-language="python">images: list[Image]
</pre></div> <p>as in:</p> <div class="tabbed-set tabbed-alternate" data-tabs="19:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_19_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


@app.post("/images/multiple/")
async def create_multiple_images(images: list[Image]):
    return images
</pre></div> </div> </div> </div> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="20:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_20_1">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


@app.post("/images/multiple/")
async def create_multiple_images(images: List[Image]):
    return images
</pre></div> </div> </div> </div> </details> <h2 id="editor-support-everywhere">Editor support everywhere</h2> <p>And you get editor support everywhere.</p> <p>Even for items inside of lists:</p> <p><img src="data:image/png;base64,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"></p> <p>You couldn't get this kind of editor support if you were working directly with <code>dict</code> instead of Pydantic models.</p> <p>But you don't have to worry about them either, incoming dicts are converted automatically and your output is converted automatically to JSON too.</p> <h2 id="bodies-of-arbitrary-dicts">Bodies of arbitrary <code>dict</code>s</h2> <p>You can also declare a body as a <code>dict</code> with keys of some type and values of some other type.</p> <p>This way, you don't have to know beforehand what the valid field/attribute names are (as would be the case with Pydantic models).</p> <p>This would be useful if you want to receive keys that you don't already know.</p> <hr> <p>Another useful case is when you want to have keys of another type (e.g., <code>int</code>).</p> <p>That's what we are going to see here.</p> <p>In this case, you would accept any <code>dict</code> as long as it has <code>int</code> keys with <code>float</code> values:</p> <div class="tabbed-set tabbed-alternate" data-tabs="21:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_21_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import FastAPI

app = FastAPI()


@app.post("/index-weights/")
async def create_index_weights(weights: dict[int, float]):
    return weights
</pre></div> </div> </div> </div> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="22:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_22_1">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Dict

from fastapi import FastAPI

app = FastAPI()


@app.post("/index-weights/")
async def create_index_weights(weights: Dict[int, float]):
    return weights
</pre></div> </div> </div> </div> </details> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Keep in mind that JSON only supports <code>str</code> as keys.</p> <p>But Pydantic has automatic data conversion.</p> <p>This means that, even though your API clients can only send strings as keys, as long as those strings contain pure integers, Pydantic will convert them and validate them.</p> <p>And the <code>dict</code> you receive as <code>weights</code> will actually have <code>int</code> keys and <code>float</code> values.</p> </div> <h2 id="recap">Recap</h2> <p>With <strong>FastAPI</strong> you have the maximum flexibility provided by Pydantic models, while keeping your code simple, short and elegant.</p> <p>But with all the benefits:</p> <ul> <li>Editor support (completion everywhere!)</li> <li>Data conversion (a.k.a. parsing / serialization)</li> <li>Data validation</li> <li>Schema documentation</li> <li>Automatic docs</li> </ul> <form class="md-feedback" name="feedback" hidden> <fieldset> <legend class="md-feedback__title"> Was this page helpful? </legend> <div class="md-feedback__inner">  <div class="md-feedback__note"> <div data-md-value="1" hidden> Thanks for your feedback! </div> <div data-md-value="0" hidden> Thanks for your feedback! </div> </div> </div> </fieldset> </form><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2018 SebastiÃ¡n RamÃ­rez<br>Licensed under the MIT License.<br>
    <a href="https://fastapi.tiangolo.com/tutorial/body-nested-models/" class="_attribution-link">https://fastapi.tiangolo.com/tutorial/body-nested-models/</a>
  </p>
</div>
