<h1 id="sql-relational-databases">SQL (Relational) Databases</h1> <p><strong>FastAPI</strong> doesn't require you to use a SQL (relational) database. But you can use <strong>any database</strong> that you want.</p> <p>Here we'll see an example using <a href="https://sqlmodel.tiangolo.com/" class="external-link" target="_blank">SQLModel</a>.</p> <p><strong>SQLModel</strong> is built on top of <a href="https://www.sqlalchemy.org/" class="external-link" target="_blank">SQLAlchemy</a> and Pydantic. It was made by the same author of <strong>FastAPI</strong> to be the perfect match for FastAPI applications that need to use <strong>SQL databases</strong>.</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>You could use any other SQL or NoSQL database library you want (in some cases called <abbr title="Object Relational Mapper, a fancy term for a library where some classes represent SQL tables and instances represent rows in those tables">"ORMs"</abbr>), FastAPI doesn't force you to use anything. ðŸ˜Ž</p> </div> <p>As SQLModel is based on SQLAlchemy, you can easily use <strong>any database supported</strong> by SQLAlchemy (which makes them also supported by SQLModel), like:</p> <ul> <li>PostgreSQL</li> <li>MySQL</li> <li>SQLite</li> <li>Oracle</li> <li>Microsoft SQL Server, etc.</li> </ul> <p>In this example, we'll use <strong>SQLite</strong>, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is.</p> <p>Later, for your production application, you might want to use a database server like <strong>PostgreSQL</strong>.</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>There is an official project generator with <strong>FastAPI</strong> and <strong>PostgreSQL</strong> including a frontend and more tools: <a href="https://github.com/fastapi/full-stack-fastapi-template" class="external-link" target="_blank">https://github.com/fastapi/full-stack-fastapi-template</a></p> </div> <p>This is a very simple and short tutorial, if you want to learn about databases in general, about SQL, or more advanced features, go to the <a href="https://sqlmodel.tiangolo.com/" class="external-link" target="_blank">SQLModel docs</a>.</p> <h2 id="install-sqlmodel">Install <code>SQLModel</code>
</h2> <p>First, make sure you create your <a class="internal-link" data-preview="" href="https://fastapi.tiangolo.com/virtual-environments/" target="_blank">virtual environment</a>, activate it, and then install <code>sqlmodel</code>:</p> <div class="termy"> <div class="highlight"><pre class="language-python" data-language="python">$ pip install sqlmodel
---&gt; 100%
</pre></div> </div> <h2 id="create-the-app-with-a-single-model">Create the App with a Single Model</h2> <p>We'll create the simplest first version of the app with a single <strong>SQLModel</strong> model first.</p> <p>Later we'll improve it increasing security and versatility with <strong>multiple models</strong> below. ðŸ¤“</p> <h3 id="create-models">Create Models</h3> <p>Import <code>SQLModel</code> and create a database model:</p> <div class="tabbed-set tabbed-alternate" data-tabs="1:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_1_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="2:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_2_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="3:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_3_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_3_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_3_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_3_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_3_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <p>The <code>Hero</code> class is very similar to a Pydantic model (in fact, underneath, it actually <em>is a Pydantic model</em>).</p> <p>There are a few differences:</p> <ul> <li> <p><code>table=True</code> tells SQLModel that this is a <em>table model</em>, it should represent a <strong>table</strong> in the SQL database, it's not just a <em>data model</em> (as would be any other regular Pydantic class).</p> </li> <li> <p><code>Field(primary_key=True)</code> tells SQLModel that the <code>id</code> is the <strong>primary key</strong> in the SQL database (you can learn more about SQL primary keys in the SQLModel docs).</p> <p>By having the type as <code>int | None</code>, SQLModel will know that this column should be an <code>INTEGER</code> in the SQL database and that it should be <code>NULLABLE</code>.</p> </li> <li> <p><code>Field(index=True)</code> tells SQLModel that it should create a <strong>SQL index</strong> for this column, that would allow faster lookups in the database when reading data filtered by this column.</p> <p>SQLModel will know that something declared as <code>str</code> will be a SQL column of type <code>TEXT</code> (or <code>VARCHAR</code>, depending on the database).</p> </li> </ul> <h3 id="create-an-engine">Create an Engine</h3> <p>A SQLModel <code>engine</code> (underneath it's actually a SQLAlchemy <code>engine</code>) is what <strong>holds the connections</strong> to the database.</p> <p>You would have <strong>one single <code>engine</code> object</strong> for all your code to connect to the same database.</p> <div class="tabbed-set tabbed-alternate" data-tabs="4:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_4_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="5:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_5_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="6:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_6_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_6_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_6_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_6_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_6_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <p>Using <code>check_same_thread=False</code> allows FastAPI to use the same SQLite database in different threads. This is necessary as <strong>one single request</strong> could use <strong>more than one thread</strong> (for example in dependencies).</p> <p>Don't worry, with the way the code is structured, we'll make sure we use <strong>a single SQLModel <em>session</em> per request</strong> later, this is actually what the <code>check_same_thread</code> is trying to achieve.</p> <h3 id="create-the-tables">Create the Tables</h3> <p>We then add a function that uses <code>SQLModel.metadata.create_all(engine)</code> to <strong>create the tables</strong> for all the <em>table models</em>.</p> <div class="tabbed-set tabbed-alternate" data-tabs="7:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_7_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

def create_db_and_tables():
    SQLModel.metadata.create_all(engine)

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="8:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_8_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="9:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_9_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_9_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_9_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_9_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_9_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h3 id="create-a-session-dependency">Create a Session Dependency</h3> <p>A <strong><code>Session</code></strong> is what stores the <strong>objects in memory</strong> and keeps track of any changes needed in the data, then it <strong>uses the <code>engine</code></strong> to communicate with the database.</p> <p>We will create a FastAPI <strong>dependency</strong> with <code>yield</code> that will provide a new <code>Session</code> for each request. This is what ensures that we use a single session per request. ðŸ¤“</p> <p>Then we create an <code>Annotated</code> dependency <code>SessionDep</code> to simplify the rest of the code that will use this dependency.</p> <div class="tabbed-set tabbed-alternate" data-tabs="10:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_10_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="11:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_11_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="12:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_12_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_12_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_12_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_12_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_12_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h3 id="create-database-tables-on-startup">Create Database Tables on Startup</h3> <p>We will create the database tables when the application starts.</p> <div class="tabbed-set tabbed-alternate" data-tabs="13:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_13_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="14:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_14_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="15:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_15_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_15_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_15_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_15_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_15_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <p>Here we create the tables on an application startup event.</p> <p>For production you would probably use a migration script that runs before you start your app. ðŸ¤“</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>SQLModel will have migration utilities wrapping Alembic, but for now, you can use <a href="https://alembic.sqlalchemy.org/en/latest/" class="external-link" target="_blank">Alembic</a> directly.</p> </div> <h3 id="create-a-hero">Create a Hero</h3> <p>Because each SQLModel model is also a Pydantic model, you can use it in the same <strong>type annotations</strong> that you could use Pydantic models.</p> <p>For example, if you declare a parameter of type <code>Hero</code>, it will be read from the <strong>JSON body</strong>.</p> <p>The same way, you can declare it as the function's <strong>return type</strong>, and then the shape of the data will show up in the automatic API docs UI.</p> <div class="tabbed-set tabbed-alternate" data-tabs="16:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_16_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="17:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_17_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="18:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_18_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_18_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_18_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_18_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_18_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <p>Here we use the <code>SessionDep</code> dependency (a <code>Session</code>) to add the new <code>Hero</code> to the <code>Session</code> instance, commit the changes to the database, refresh the data in the <code>hero</code>, and then return it.</p> <h3 id="read-heroes">Read Heroes</h3> <p>We can <strong>read</strong> <code>Hero</code>s from the database using a <code>select()</code>. We can include a <code>limit</code> and <code>offset</code> to paginate the results.</p> <div class="tabbed-set tabbed-alternate" data-tabs="19:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_19_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="20:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_20_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="21:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_21_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_21_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_21_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_21_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_21_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h3 id="read-one-hero">Read One Hero</h3> <p>We can <strong>read</strong> a single <code>Hero</code>.</p> <div class="tabbed-set tabbed-alternate" data-tabs="22:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_22_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="23:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_23_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="24:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_24_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_24_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_24_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_24_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_24_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h3 id="delete-a-hero">Delete a Hero</h3> <p>We can also <strong>delete</strong> a <code>Hero</code>.</p> <div class="tabbed-set tabbed-alternate" data-tabs="25:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_25_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="26:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_26_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="27:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_27_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_27_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_27_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_27_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_27_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)
    secret_name: str


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/")
def create_hero(hero: Hero, session: Session = Depends(get_session)) -&gt; Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero


@app.get("/heroes/")
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
) -&gt; List[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: Session = Depends(get_session)) -&gt; Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h3 id="run-the-app">Run the App</h3> <p>You can run the app:</p> <div class="termy"> <div class="highlight"><pre class="language-python" data-language="python">$ fastapi dev main.py

&lt;span style="color: green;"&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
</pre></div> </div> <p>Then go to the <code>/docs</code> UI, you will see that <strong>FastAPI</strong> is using these <strong>models</strong> to <strong>document</strong> the API, and it will use them to <strong>serialize</strong> and <strong>validate</strong> the data too.</p> <div class="screenshot"> <img src="data:image/png;base64,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"> </div> <h2 id="update-the-app-with-multiple-models">Update the App with Multiple Models</h2> <p>Now let's <strong>refactor</strong> this app a bit to increase <strong>security</strong> and <strong>versatility</strong>.</p> <p>If you check the previous app, in the UI you can see that, up to now, it lets the client decide the <code>id</code> of the <code>Hero</code> to create. ðŸ˜±</p> <p>We shouldn't let that happen, they could overwrite an <code>id</code> we already have assigned in the DB. Deciding the <code>id</code> should be done by the <strong>backend</strong> or the <strong>database</strong>, <strong>not by the client</strong>.</p> <p>Additionally, we create a <code>secret_name</code> for the hero, but so far, we are returning it everywhere, that's not very <strong>secret</strong>... ðŸ˜…</p> <p>We'll fix these things by adding a few <strong>extra models</strong>. Here's where SQLModel will shine. âœ¨</p> <h3 id="create-multiple-models">Create Multiple Models</h3> <p>In <strong>SQLModel</strong>, any model class that has <code>table=True</code> is a <strong>table model</strong>.</p> <p>And any model class that doesn't have <code>table=True</code> is a <strong>data model</strong>, these ones are actually just Pydantic models (with a couple of small extra features). ðŸ¤“</p> <p>With SQLModel, we can use <strong>inheritance</strong> to <strong>avoid duplicating</strong> all the fields in all the cases.</p> <h4 id="herobase-the-base-class">
<code>HeroBase</code> - the base class</h4> <p>Let's start with a <code>HeroBase</code> model that has all the <strong>fields that are shared</strong> by all the models:</p> <ul> <li><code>name</code></li> <li><code>age</code></li> </ul> <div class="tabbed-set tabbed-alternate" data-tabs="28:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_28_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="29:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_29_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="30:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_30_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_30_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_30_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_30_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_30_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h4 id="hero-the-table-model">
<code>Hero</code> - the <em>table model</em>
</h4> <p>Then let's create <code>Hero</code>, the actual <em>table model</em>, with the <strong>extra fields</strong> that are not always in the other models:</p> <ul> <li><code>id</code></li> <li><code>secret_name</code></li> </ul> <p>Because <code>Hero</code> inherits form <code>HeroBase</code>, it <strong>also</strong> has the <strong>fields</strong> declared in <code>HeroBase</code>, so all the fields for <code>Hero</code> are:</p> <ul> <li><code>id</code></li> <li><code>name</code></li> <li><code>age</code></li> <li><code>secret_name</code></li> </ul> <div class="tabbed-set tabbed-alternate" data-tabs="31:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_31_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="32:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_32_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="33:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_33_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_33_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_33_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_33_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_33_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h4 id="heropublic-the-public-data-model">
<code>HeroPublic</code> - the public <em>data model</em>
</h4> <p>Next, we create a <code>HeroPublic</code> model, this is the one that will be <strong>returned</strong> to the clients of the API.</p> <p>It has the same fields as <code>HeroBase</code>, so it won't include <code>secret_name</code>.</p> <p>Finally, the identity of our heroes is protected! ðŸ¥·</p> <p>It also re-declares <code>id: int</code>. By doing this, we are making a <strong>contract</strong> with the API clients, so that they can always expect the <code>id</code> to be there and to be an <code>int</code> (it will never be <code>None</code>).</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Having the return model ensure that a value is always available and always <code>int</code> (not <code>None</code>) is very useful for the API clients, they can write much simpler code having this certainty.</p> <p>Also, <strong>automatically generated clients</strong> will have simpler interfaces, so that the developers communicating with your API can have a much better time working with your API. ðŸ˜Ž</p> </div> <p>All the fields in <code>HeroPublic</code> are the same as in <code>HeroBase</code>, with <code>id</code> declared as <code>int</code> (not <code>None</code>):</p> <ul> <li><code>id</code></li> <li><code>name</code></li> <li><code>age</code></li> </ul> <div class="tabbed-set tabbed-alternate" data-tabs="34:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_34_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="35:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_35_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="36:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_36_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_36_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_36_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_36_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_36_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h4 id="herocreate-the-data-model-to-create-a-hero">
<code>HeroCreate</code> - the <em>data model</em> to create a hero</h4> <p>Now we create a <code>HeroCreate</code> model, this is the one that will <strong>validate</strong> the data from the clients.</p> <p>It has the same fields as <code>HeroBase</code>, and it also has <code>secret_name</code>.</p> <p>Now, when the clients <strong>create a new hero</strong>, they will send the <code>secret_name</code>, it will be stored in the database, but those secret names won't be returned in the API to the clients.</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>This is how you would handle <strong>passwords</strong>. Receive them, but don't return them in the API.</p> <p>You would also <strong>hash</strong> the values of the passwords before storing them, <strong>never store them in plain text</strong>.</p> </div> <p>The fields of <code>HeroCreate</code> are:</p> <ul> <li><code>name</code></li> <li><code>age</code></li> <li><code>secret_name</code></li> </ul> <div class="tabbed-set tabbed-alternate" data-tabs="37:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_37_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="38:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_38_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="39:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_39_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_39_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_39_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_39_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_39_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h4 id="heroupdate-the-data-model-to-update-a-hero">
<code>HeroUpdate</code> - the <em>data model</em> to update a hero</h4> <p>We didn't have a way to <strong>update a hero</strong> in the previous version of the app, but now with <strong>multiple models</strong>, we can do it. ðŸŽ‰</p> <p>The <code>HeroUpdate</code> <em>data model</em> is somewhat special, it has <strong>all the same fields</strong> that would be needed to create a new hero, but all the fields are <strong>optional</strong> (they all have a default value). This way, when you update a hero, you can send just the fields that you want to update.</p> <p>Because all the <strong>fields actually change</strong> (the type now includes <code>None</code> and they now have a default value of <code>None</code>), we need to <strong>re-declare</strong> them.</p> <p>We don't really need to inherit from <code>HeroBase</code> because we are re-declaring all the fields. I'll leave it inheriting just for consistency, but this is not necessary. It's more a matter of personal taste. ðŸ¤·</p> <p>The fields of <code>HeroUpdate</code> are:</p> <ul> <li><code>name</code></li> <li><code>age</code></li> <li><code>secret_name</code></li> </ul> <div class="tabbed-set tabbed-alternate" data-tabs="40:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_40_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="41:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_41_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="42:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_42_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_42_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_42_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_42_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_42_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h3 id="create-with-herocreate-and-return-a-heropublic">Create with <code>HeroCreate</code> and return a <code>HeroPublic</code>
</h3> <p>Now that we have <strong>multiple models</strong>, we can update the parts of the app that use them.</p> <p>We receive in the request a <code>HeroCreate</code> <em>data model</em>, and from it, we create a <code>Hero</code> <em>table model</em>.</p> <p>This new <em>table model</em> <code>Hero</code> will have the fields sent by the client, and will also have an <code>id</code> generated by the database.</p> <p>Then we return the same <em>table model</em> <code>Hero</code> as is from the function. But as we declare the <code>response_model</code> with the <code>HeroPublic</code> <em>data model</em>, <strong>FastAPI</strong> will use <code>HeroPublic</code> to validate and serialize the data.</p> <div class="tabbed-set tabbed-alternate" data-tabs="43:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_43_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="44:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_44_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="45:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_45_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_45_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_45_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_45_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_45_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Now we use <code>response_model=HeroPublic</code> instead of the <strong>return type annotation</strong> <code>-&gt; HeroPublic</code> because the value that we are returning is actually <em>not</em> a <code>HeroPublic</code>.</p> <p>If we had declared <code>-&gt; HeroPublic</code>, your editor and linter would complain (rightfully so) that you are returning a <code>Hero</code> instead of a <code>HeroPublic</code>.</p> <p>By declaring it in <code>response_model</code> we are telling <strong>FastAPI</strong> to do its thing, without interfering with the type annotations and the help from your editor and other tools.</p> </div> <h3 id="read-heroes-with-heropublic">Read Heroes with <code>HeroPublic</code>
</h3> <p>We can do the same as before to <strong>read</strong> <code>Hero</code>s, again, we use <code>response_model=list[HeroPublic]</code> to ensure that the data is validated and serialized correctly.</p> <div class="tabbed-set tabbed-alternate" data-tabs="46:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_46_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="47:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_47_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="48:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_48_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_48_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_48_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_48_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_48_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h3 id="read-one-hero-with-heropublic">Read One Hero with <code>HeroPublic</code>
</h3> <p>We can <strong>read</strong> a single hero:</p> <div class="tabbed-set tabbed-alternate" data-tabs="49:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_49_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="50:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_50_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="51:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_51_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_51_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_51_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_51_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_51_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h3 id="update-a-hero-with-heroupdate">Update a Hero with <code>HeroUpdate</code>
</h3> <p>We can <strong>update a hero</strong>. For this we use an HTTP <code>PATCH</code> operation.</p> <p>And in the code, we get a <code>dict</code> with all the data sent by the client, <strong>only the data sent by the client</strong>, excluding any values that would be there just for being the default values. To do it we use <code>exclude_unset=True</code>. This is the main trick. ðŸª„</p> <p>Then we use <code>hero_db.sqlmodel_update(hero_data)</code> to update the <code>hero_db</code> with the data from <code>hero_data</code>.</p> <div class="tabbed-set tabbed-alternate" data-tabs="52:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_52_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db

# Code below omitted ðŸ‘‡
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="53:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_53_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="54:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_54_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_54_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_54_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_54_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_54_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h3 id="delete-a-hero-again">Delete a Hero Again</h3> <p><strong>Deleting</strong> a hero stays pretty much the same.</p> <p>We won't satisfy the desire to refactor everything in this one. ðŸ˜…</p> <div class="tabbed-set tabbed-alternate" data-tabs="55:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_55_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python"># Code above omitted ðŸ‘†

@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> <details> <summary>ðŸ‘€ Full file preview</summary> <div class="tabbed-set tabbed-alternate" data-tabs="56:1"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_56_1">Python 3.10+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <details> <summary>ðŸ¤“ Other versions and variants</summary> <div class="tabbed-set tabbed-alternate" data-tabs="57:5"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_57_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_57_2">Python 3.8+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select
from typing_extensions import Annotated


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]
app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_57_3">Python 3.10+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_57_4">Python 3.9+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_57_5">Python 3.8+ - non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from typing import List, Union

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: Union[int, None] = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: Union[int, None] = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: Union[str, None] = None
    age: Union[int, None] = None
    secret_name: Union[str, None] = None


sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)


def create_db_and_tables():
    SQLModel.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session


app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()


@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: Session = Depends(get_session)):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero


@app.get("/heroes/", response_model=List[HeroPublic])
def read_heroes(
    session: Session = Depends(get_session),
    offset: int = 0,
    limit: int = Query(default=100, le=100),
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes


@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero


@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(
    hero_id: int, hero: HeroUpdate, session: Session = Depends(get_session)
):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db


@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: Session = Depends(get_session)):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}
</pre></div> </div> </div> </div> </details> <h3 id="run-the-app-again">Run the App Again</h3> <p>You can run the app again:</p> <div class="termy"> <div class="highlight"><pre class="language-python" data-language="python">$ fastapi dev main.py

&lt;span style="color: green;"&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
</pre></div> </div> <p>If you go to the <code>/docs</code> API UI, you will see that it is now updated, and it won't expect to receive the <code>id</code> from the client when creating a hero, etc.</p> <div class="screenshot"> <img src="data:image/png;base64,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"> </div> <h2 id="recap">Recap</h2> <p>You can use <a href="https://sqlmodel.tiangolo.com/" class="external-link" target="_blank"><strong>SQLModel</strong></a> to interact with a SQL database and simplify the code with <em>data models</em> and <em>table models</em>.</p> <p>You can learn a lot more at the <strong>SQLModel</strong> docs, there's a longer mini <a href="https://sqlmodel.tiangolo.com/tutorial/fastapi/" class="external-link" target="_blank">tutorial on using SQLModel with <strong>FastAPI</strong></a>. ðŸš€</p> <form class="md-feedback" name="feedback" hidden> <fieldset> <legend class="md-feedback__title"> Was this page helpful? </legend> <div class="md-feedback__inner">  <div class="md-feedback__note"> <div data-md-value="1" hidden> Thanks for your feedback! </div> <div data-md-value="0" hidden> Thanks for your feedback! </div> </div> </div> </fieldset> </form><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2018 SebastiÃ¡n RamÃ­rez<br>Licensed under the MIT License.<br>
    <a href="https://fastapi.tiangolo.com/tutorial/sql-databases/" class="_attribution-link">https://fastapi.tiangolo.com/tutorial/sql-databases/</a>
  </p>
</div>
