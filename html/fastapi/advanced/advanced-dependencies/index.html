<h1 id="advanced-dependencies">Advanced Dependencies</h1> <h2 id="parameterized-dependencies">Parameterized dependencies</h2> <p>All the dependencies we have seen are a fixed function or class.</p> <p>But there could be cases where you want to be able to set parameters on the dependency, without having to declare many different functions or classes.</p> <p>Let's imagine that we want to have a dependency that checks if the query parameter <code>q</code> contains some fixed content.</p> <p>But we want to be able to parameterize that fixed content.</p> <h2 id="a-callable-instance">A "callable" instance</h2> <p>In Python there's a way to make an instance of a class a "callable".</p> <p>Not the class itself (which is already a callable), but an instance of that class.</p> <p>To do that, we declare a method <code>__call__</code>:</p> <div class="tabbed-set tabbed-alternate" data-tabs="1:3"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_1_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_1_2">Python 3.6+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI
from typing_extensions import Annotated

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_1_3">Python 3.6+ non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: bool = Depends(checker)):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> </div> </div> <p>In this case, this <code>__call__</code> is what <strong>FastAPI</strong> will use to check for additional parameters and sub-dependencies, and this is what will be called to pass a value to the parameter in your <em>path operation function</em> later.</p> <h2 id="parameterize-the-instance">Parameterize the instance</h2> <p>And now, we can use <code>__init__</code> to declare the parameters of the instance that we can use to "parameterize" the dependency:</p> <div class="tabbed-set tabbed-alternate" data-tabs="2:3"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_2_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_2_2">Python 3.6+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI
from typing_extensions import Annotated

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_2_3">Python 3.6+ non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: bool = Depends(checker)):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> </div> </div> <p>In this case, <strong>FastAPI</strong> won't ever touch or care about <code>__init__</code>, we will use it directly in our code.</p> <h2 id="create-an-instance">Create an instance</h2> <p>We could create an instance of this class with:</p> <div class="tabbed-set tabbed-alternate" data-tabs="3:3"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_3_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_3_2">Python 3.6+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI
from typing_extensions import Annotated

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_3_3">Python 3.6+ non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: bool = Depends(checker)):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> </div> </div> <p>And that way we are able to "parameterize" our dependency, that now has <code>"bar"</code> inside of it, as the attribute <code>checker.fixed_content</code>.</p> <h2 id="use-the-instance-as-a-dependency">Use the instance as a dependency</h2> <p>Then, we could use this <code>checker</code> in a <code>Depends(checker)</code>, instead of <code>Depends(FixedContentQueryChecker)</code>, because the dependency is the instance, <code>checker</code>, not the class itself.</p> <p>And when solving the dependency, <strong>FastAPI</strong> will call this <code>checker</code> like:</p> <div class="highlight"><pre class="language-python" data-language="python">checker(q="somequery")
</pre></div> <p>...and pass whatever that returns as the value of the dependency in our <em>path operation function</em> as the parameter <code>fixed_content_included</code>:</p> <div class="tabbed-set tabbed-alternate" data-tabs="4:3"> <div class="tabbed-content"> <div class="tabbed-block">
<label for="__tabbed_4_1">Python 3.9+</label> <div class="highlight"><pre class="language-python" data-language="python">from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_4_2">Python 3.6+</label> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI
from typing_extensions import Annotated

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> <div class="tabbed-block">
<label for="__tabbed_4_3">Python 3.6+ non-Annotated</label> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>Prefer to use the <code>Annotated</code> version if possible.</p> </div> <div class="highlight"><pre class="language-python" data-language="python">from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: bool = Depends(checker)):
    return {"fixed_content_in_query": fixed_content_included}
</pre></div> </div> </div> </div> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>All this might seem contrived. And it might not be very clear how is it useful yet.</p> <p>These examples are intentionally simple, but show how it all works.</p> <p>In the chapters about security, there are utility functions that are implemented in this same way.</p> <p>If you understood all this, you already know how those utility tools for security work underneath.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2018 Sebastián Ramírez<br>Licensed under the MIT License.<br>
    <a href="https://fastapi.tiangolo.com/advanced/advanced-dependencies/" class="_attribution-link">https://fastapi.tiangolo.com/advanced/advanced-dependencies/</a>
  </p>
</div>
