<h1 id="guide:Using Dependencies Guide">Using Dependencies Guide</h1>   <ul> <li><a class="reference internal" href="#introduction" id="id4">Introduction</a></li> <li>
<p><a class="reference internal" href="#using-pre-built-packages-with-find-package" id="id5">Using Pre-built Packages With <code>find_package()</code></a></p> <ul> <li><a class="reference internal" href="#config-file-packages" id="id6">Config-file packages</a></li> <li><a class="reference internal" href="#find-module-files" id="id7">Find Module Files</a></li> <li><a class="reference internal" href="#imported-targets" id="id8">Imported Targets</a></li> </ul> </li> <li><a class="reference internal" href="#downloading-and-building-from-source-with-fetchcontent" id="id9">Downloading And Building From Source With <code>FetchContent</code></a></li> <li><a class="reference internal" href="#fetchcontent-and-find-package-integration" id="id10"><code>FetchContent</code> And <code>find_package()</code> Integration</a></li> <li><a class="reference internal" href="#dependency-providers" id="id11">Dependency Providers</a></li> </ul>
   <h2>Introduction</h2> <p>Projects will frequently depend on other projects, assets, and artifacts. CMake provides a number of ways to incorporate such things into the build. Projects and users have the flexibility to choose between methods that best suit their needs.</p> <p>The primary methods of bringing dependencies into the build are the <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-0-command:find_package"><code>find_package()</code></a> command and the <a class="reference internal" href="../../module/fetchcontent.html#module:FetchContent" title="FetchContent" id="index-0-module:FetchContent"><code>FetchContent</code></a> module. The <a class="reference internal" href="../../module/findpkgconfig.html#module:FindPkgConfig" title="FindPkgConfig" id="index-0-module:FindPkgConfig"><code>FindPkgConfig</code></a> module is also sometimes used, although it lacks some of the integration of the other two and is not discussed any further in this guide.</p> <p>Dependencies can also be made available by a custom <a class="reference internal" href="../../command/cmake_language.html#dependency-providers"><span class="std std-ref">dependency provider</span></a>. This might be a third party package manager, or it might be custom code implemented by the developer. Dependency providers co-operate with the primary methods mentioned above to extend their flexibility.</p>   <h2 id="prebuilt-find-package">Using Pre-built Packages With <code>find_package()</code>
</h2> <p>A package needed by the project may already be built and available at some location on the user's system. That package might have also been built by CMake, or it could have used a different build system entirely. It might even just be a collection of files that didn't need to be built at all. CMake provides the <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-1-command:find_package"><code>find_package()</code></a> command for these scenarios. It searches well-known locations, along with additional hints and paths provided by the project or user. It also supports package components and packages being optional. Result variables are provided to allow the project to customize its own behavior according to whether the package or specific components were found.</p> <p>In most cases, projects should generally use the <a class="reference internal" href="../../command/find_package.html#basic-signature"><span class="std std-ref">Basic Signature</span></a>. Most of the time, this will involve just the package name, maybe a version constraint, and the <code>REQUIRED</code> keyword if the dependency is not optional. A set of package components may also be specified.</p> <div class="literal-block-wrapper docutils container" id="id1"> <div class="code-block-caption"><span class="caption-text">Examples of <code>find_package()</code> basic signature</span></div> <pre data-language="cmake">find_package(Catch2)
find_package(GTest REQUIRED)
find_package(Boost 1.79 COMPONENTS date_time)
</pre> </div> <p>The <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-2-command:find_package"><code>find_package()</code></a> command supports two main methods for carrying out the search:</p> <dl class="simple"> <dt><strong>Config mode</strong></dt>
<dd>
<p>With this method, the command looks for files that are typically provided by the package itself. This is the more reliable method of the two, since the package details should always be in sync with the package.</p> </dd> <dt><strong>Module mode</strong></dt>
<dd>
<p>Not all packages are CMake-aware. Many don't provide the files needed to support config mode. For such cases, a Find module file can be provided separately, either by the project or by CMake. A Find module is typically a heuristic implementation which knows what the package normally provides and how to present that package to the project. Since Find modules are usually distributed separately from the package, they are not as reliable. They are typically maintained separately, and they are likely to follow different release schedules, so they can easily become out-of-date.</p> </dd> </dl> <p>Depending on the arguments used, <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-3-command:find_package"><code>find_package()</code></a> may use one or both of the above methods. By restricting the options to just the basic signature, both config mode and module mode can be used to satisfy the dependency. The presence of other options may restrict the call to using only one of the two methods, potentially reducing the command's ability to find the dependency. See the <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-4-command:find_package"><code>find_package()</code></a> documentation for full details about this complex topic.</p> <p>For both search methods, the user can also set cache variables on the <a class="reference internal" href="../../manual/cmake.1.html#manual:cmake(1)" title="cmake(1)" id="index-0-manual:cmake(1)"><code>cmake(1)</code></a> command line or in the <a class="reference internal" href="../../manual/ccmake.1.html#manual:ccmake(1)" title="ccmake(1)" id="index-0-manual:ccmake(1)"><code>ccmake(1)</code></a> or <a class="reference internal" href="../../manual/cmake-gui.1.html#manual:cmake-gui(1)" title="cmake-gui(1)" id="index-0-manual:cmake-gui(1)"><code>cmake-gui(1)</code></a> UI tools to influence and override where to find packages. See the <a class="reference internal" href="../user-interaction/index.html#setting-build-variables"><span class="std std-ref">User Interaction Guide</span></a> for more on how to set cache variables.</p>  <h3 id="libraries-providing-config-file-packages">Config-file packages</h3> <p>The preferred way for a third party to provide executables, libraries, headers, and other files for use with CMake is to provide <a class="reference internal" href="../../manual/cmake-packages.7.html#config-file-packages"><span class="std std-ref">config files</span></a>. These are text files shipped with the package, which define CMake targets, variables, commands, and so on. The config file is an ordinary CMake script, which is read in by the <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-5-command:find_package"><code>find_package()</code></a> command.</p> <p>The config files can usually be found in a directory whose name matches the pattern <code>lib/cmake/&lt;PackageName&gt;</code>, although they may be in other locations instead (see <a class="reference internal" href="../../command/find_package.html#search-procedure"><span class="std std-ref">Config Mode Search Procedure</span></a>). The <code>&lt;PackageName&gt;</code> is usually the first argument to the <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-6-command:find_package"><code>find_package()</code></a> command, and it may even be the only argument. Alternative names can also be specified with the <code>NAMES</code> option:</p> <div class="literal-block-wrapper docutils container" id="id2"> <div class="code-block-caption"><span class="caption-text">Providing alternative names when finding a package</span></div> <pre data-language="cmake">find_package(SomeThing
  NAMES
    SameThingOtherName   # Another name for the package
    SomeThing            # Also still look for its canonical name
)
</pre> </div> <p>The config file must be named either <code>&lt;PackageName&gt;Config.cmake</code> or <code>&lt;LowercasePackageName&gt;-config.cmake</code> (the former is used for the remainder of this guide, but both are supported). This file is the entry point to the package for CMake. A separate optional file named <code>&lt;PackageName&gt;ConfigVersion.cmake</code> or <code>&lt;LowercasePackageName&gt;-config-version.cmake</code> may also exist in the same directory. This file is used by CMake to determine whether the version of the package satisfies any version constraint included in the call to <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-7-command:find_package"><code>find_package()</code></a>. It is optional to specify a version when calling <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-8-command:find_package"><code>find_package()</code></a>, even if a <code>&lt;PackageName&gt;ConfigVersion.cmake</code> file is present.</p> <p>If the <code>&lt;PackageName&gt;Config.cmake</code> file is found and any version constraint is satisfied, the <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-9-command:find_package"><code>find_package()</code></a> command considers the package to be found, and the entire package is assumed to be complete as designed.</p> <p>There may be additional files providing CMake commands or <a class="reference internal" href="../../manual/cmake-buildsystem.7.html#imported-targets"><span class="std std-ref">Imported Targets</span></a> for you to use. CMake does not enforce any naming convention for these files. They are related to the primary <code>&lt;PackageName&gt;Config.cmake</code> file by use of the CMake <a class="reference internal" href="../../command/include.html#command:include" title="include" id="index-0-command:include"><code>include()</code></a> command. The <code>&lt;PackageName&gt;Config.cmake</code> file would typically include these for you, so they won't usually require any additional step other than the call to <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-10-command:find_package"><code>find_package()</code></a>.</p> <p>If the location of the package is in a <a class="reference internal" href="../../command/find_package.html#search-procedure"><span class="std std-ref">directory known to CMake</span></a>, the <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-11-command:find_package"><code>find_package()</code></a> call should succeed. The directories known to CMake are platform-specific. For example, packages installed on Linux with a standard system package manager will be found in the <code>/usr</code> prefix automatically. Packages installed in <code>Program Files</code> on Windows will similarly be found automatically.</p> <p>Packages will not be found automatically without help if they are in locations not known to CMake, such as <code>/opt/mylib</code> or <code>$HOME/dev/prefix</code>. This is a normal situation, and CMake provides several ways for users to specify where to find such libraries.</p> <p>The <a class="reference internal" href="../../variable/cmake_prefix_path.html#variable:CMAKE_PREFIX_PATH" title="CMAKE_PREFIX_PATH" id="index-0-variable:CMAKE_PREFIX_PATH"><code>CMAKE_PREFIX_PATH</code></a> variable may be <a class="reference internal" href="../user-interaction/index.html#setting-build-variables"><span class="std std-ref">set when invoking CMake</span></a>. It is treated as a list of base paths in which to search for <a class="reference internal" href="../../manual/cmake-packages.7.html#config-file-packages"><span class="std std-ref">config files</span></a>. A package installed in <code>/opt/somepackage</code> will typically install config files such as <code>/opt/somepackage/lib/cmake/somePackage/SomePackageConfig.cmake</code>. In that case, <code>/opt/somepackage</code> should be added to <a class="reference internal" href="../../variable/cmake_prefix_path.html#variable:CMAKE_PREFIX_PATH" title="CMAKE_PREFIX_PATH" id="index-1-variable:CMAKE_PREFIX_PATH"><code>CMAKE_PREFIX_PATH</code></a>.</p> <p>The environment variable <code>CMAKE_PREFIX_PATH</code> may also be populated with prefixes to search for packages. Like the <code>PATH</code> environment variable, this is a list, but it needs to use the platform-specific environment variable list item separator (<code>:</code> on Unix and <code>;</code> on Windows).</p> <p>The <a class="reference internal" href="../../variable/cmake_prefix_path.html#variable:CMAKE_PREFIX_PATH" title="CMAKE_PREFIX_PATH" id="index-2-variable:CMAKE_PREFIX_PATH"><code>CMAKE_PREFIX_PATH</code></a> variable provides convenience in cases where multiple prefixes need to be specified, or when multiple packages are available under the same prefix. Paths to packages may also be specified by setting variables matching <code>&lt;PackageName&gt;_DIR</code>, such as <code>SomePackage_DIR</code>. Note that this is not a prefix, but should be a full path to a directory containing a config-style package file, such as <code>/opt/somepackage/lib/cmake/SomePackage</code> in the above example. See the <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-12-command:find_package"><code>find_package()</code></a> documentation for other CMake variables and environment variables that can affect the search.</p>   <h3 id="libraries-not-providing-config-file-packages">Find Module Files</h3> <p>Packages which do not provide config files can still be found with the <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-13-command:find_package"><code>find_package()</code></a> command, if a <code>FindSomePackage.cmake</code> file is available. These Find module files are different to config files in that:</p> <ol class="arabic simple"> <li>Find module files should not be provided by the package itself.</li> <li>The availability of a <code>Find&lt;PackageName&gt;.cmake</code> file does not indicate the availability of the package, or any particular part of the package.</li> <li>CMake does not search the locations specified in the <a class="reference internal" href="../../variable/cmake_prefix_path.html#variable:CMAKE_PREFIX_PATH" title="CMAKE_PREFIX_PATH" id="index-3-variable:CMAKE_PREFIX_PATH"><code>CMAKE_PREFIX_PATH</code></a> variable for <code>Find&lt;PackageName&gt;.cmake</code> files. Instead, CMake searches for such files in the locations given by the <a class="reference internal" href="../../variable/cmake_module_path.html#variable:CMAKE_MODULE_PATH" title="CMAKE_MODULE_PATH" id="index-0-variable:CMAKE_MODULE_PATH"><code>CMAKE_MODULE_PATH</code></a> variable. It is common for users to set the <a class="reference internal" href="../../variable/cmake_module_path.html#variable:CMAKE_MODULE_PATH" title="CMAKE_MODULE_PATH" id="index-1-variable:CMAKE_MODULE_PATH"><code>CMAKE_MODULE_PATH</code></a> when running CMake, and it is common for CMake projects to append to <a class="reference internal" href="../../variable/cmake_module_path.html#variable:CMAKE_MODULE_PATH" title="CMAKE_MODULE_PATH" id="index-2-variable:CMAKE_MODULE_PATH"><code>CMAKE_MODULE_PATH</code></a> to allow use of local Find module files.</li> <li>CMake ships <code>Find&lt;PackageName&gt;.cmake</code> files for some <a class="reference internal" href="../../manual/cmake-modules.7.html#manual:cmake-modules(7)" title="cmake-modules(7)" id="index-0-manual:cmake-modules(7)"><code>third party packages</code></a>. These files are a maintenance burden for CMake, and it is not unusual for these to fall behind the latest releases of the packages they are associated with. In general, new Find modules are not added to CMake any more. Projects should encourage the upstream packages to provide a config file where possible. If that is unsuccessful, the project should provide its own Find module for the package.</li> </ol> <p>See <a class="reference internal" href="../../manual/cmake-developer.7.html#find-modules"><span class="std std-ref">Find Modules</span></a> for a detailed discussion of how to write a Find module file.</p>   <h3 id="imported-targets-from-packages">Imported Targets</h3> <p>Both config files and Find module files can define <a class="reference internal" href="../../manual/cmake-buildsystem.7.html#imported-targets"><span class="std std-ref">Imported Targets</span></a>. These will typically have names of the form <code>SomePrefix::ThingName</code>. Where these are available, the project should prefer to use them instead of any CMake variables that may also be provided. Such targets typically carry usage requirements and apply things like header search paths, compiler definitions, etc. automatically to other targets that link to them (e.g. using <a class="reference internal" href="../../command/target_link_libraries.html#command:target_link_libraries" title="target_link_libraries" id="index-0-command:target_link_libraries"><code>target_link_libraries()</code></a>). This is both more robust and more convenient than trying to apply the same things manually using variables. Check the documentation for the package or Find module to see what imported targets it defines, if any.</p> <p>Imported targets should also encapsulate any configuration-specific paths. This includes the location of binaries (libraries, executables), compiler flags, and any other configuration-dependent quantities. Find modules may be less reliable in providing these details than config files.</p> <p>A complete example which finds a third party package and uses a library from it might look like the following:</p> <pre data-language="cmake">cmake_minimum_required(VERSION 3.10)
project(MyExeProject VERSION 1.0.0)

# Make project-provided Find modules available
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")

find_package(SomePackage REQUIRED)
add_executable(MyExe main.cpp)
target_link_libraries(MyExe PRIVATE SomePrefix::LibName)
</pre> <p>Note that the above call to <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-14-command:find_package"><code>find_package()</code></a> could be resolved by a config file or a Find module. It uses only the basic arguments supported by the <a class="reference internal" href="../../command/find_package.html#basic-signature"><span class="std std-ref">Basic Signature</span></a>. A <code>FindSomePackage.cmake</code> file in the <code>${CMAKE_CURRENT_SOURCE_DIR}/cmake</code> directory would allow the <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-15-command:find_package"><code>find_package()</code></a> command to succeed using module mode, for example. If no such module file is present, the system would be searched for a config file.</p>    <h2>Downloading And Building From Source With <code>FetchContent</code>
</h2> <p>Dependencies do not necessarily have to be pre-built in order to use them with CMake. They can be built from sources as part of the main project. The <a class="reference internal" href="../../module/fetchcontent.html#module:FetchContent" title="FetchContent" id="index-1-module:FetchContent"><code>FetchContent</code></a> module provides functionality to download content (typically sources, but can be anything) and add it to the main project if the dependency also uses CMake. The dependency's sources will be built along with the rest of the project, just as though the sources were part of the project's own sources.</p> <p>The general pattern is that the project should first declare all the dependencies it wants to use, then ask for them to be made available. The following demonstrates the principle (see <a class="reference internal" href="../../module/fetchcontent.html#fetch-content-examples"><span class="std std-ref">Examples</span></a> for more):</p> <pre data-language="cmake">include(FetchContent)
FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG        703bd9caab50b139428cea1aaff9974ebee5742e # release-1.10.0
)
FetchContent_Declare(
  Catch2
  GIT_REPOSITORY https://github.com/catchorg/Catch2.git
  GIT_TAG        605a34765aa5d5ecbf476b4598a862ada971b0cc # v3.0.1
)
FetchContent_MakeAvailable(googletest Catch2)
</pre> <p>Various download methods are supported, including downloading and extracting archives from a URL (a range of archive formats are supported), and a number of repository formats including Git, Subversion, and Mercurial. Custom download, update, and patch commands can also be used to support arbitrary use cases.</p> <p>When a dependency is added to the project with <a class="reference internal" href="../../module/fetchcontent.html#module:FetchContent" title="FetchContent" id="index-2-module:FetchContent"><code>FetchContent</code></a>, the project links to the dependency's targets just like any other target from the project. If the dependency provides namespaced targets of the form <code>SomePrefix::ThingName</code>, the project should link to those rather than to any non-namespaced targets. See the next section for why this is recommended.</p> <p>Not all dependencies can be brought into the project this way. Some dependencies define targets whose names clash with other targets from the project or other dependencies. Concrete executable and library targets created by <a class="reference internal" href="../../command/add_executable.html#command:add_executable" title="add_executable" id="index-0-command:add_executable"><code>add_executable()</code></a> and <a class="reference internal" href="../../command/add_library.html#command:add_library" title="add_library" id="index-0-command:add_library"><code>add_library()</code></a> are global, so each one must be unique across the whole build. If a dependency would add a clashing target name, it cannot be brought directly into the build with this method.</p>   <h2>
<code>FetchContent</code> And <code>find_package()</code> Integration</h2> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.24.</span></p> </div> <p>Some dependencies support being added by either <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-16-command:find_package"><code>find_package()</code></a> or <a class="reference internal" href="../../module/fetchcontent.html#module:FetchContent" title="FetchContent" id="index-3-module:FetchContent"><code>FetchContent</code></a>. Such dependencies must ensure they define the same namespaced targets in both installed and built-from-source scenarios. A consuming project then links to those namespaced targets and can handle both scenarios transparently, as long as the project does not use anything else that isn't provided by both methods.</p> <p>The project can indicate it is happy to accept a dependency by either method using the <code>FIND_PACKAGE_ARGS</code> option to <a class="reference internal" href="../../module/fetchcontent.html#command:fetchcontent_declare" title="fetchcontent_declare" id="index-0-command:fetchcontent_declare"><code>FetchContent_Declare()</code></a>. This allows <a class="reference internal" href="../../module/fetchcontent.html#command:fetchcontent_makeavailable" title="fetchcontent_makeavailable" id="index-0-command:fetchcontent_makeavailable"><code>FetchContent_MakeAvailable()</code></a> to try satisfying the dependency with a call to <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-17-command:find_package"><code>find_package()</code></a> first, using the arguments after the <code>FIND_PACKAGE_ARGS</code> keyword, if any. If that doesn't find the dependency, it is built from source as described previously instead.</p> <pre data-language="cmake">include(FetchContent)
FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG        703bd9caab50b139428cea1aaff9974ebee5742e # release-1.10.0
  FIND_PACKAGE_ARGS NAMES GTest
)
FetchContent_MakeAvailable(googletest)

add_executable(ThingUnitTest thing_ut.cpp)
target_link_libraries(ThingUnitTest GTest::gtest_main)
</pre> <p>The above example calls <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-18-command:find_package"><code>find_package(googletest NAMES GTest)</code></a> first. CMake provides a <a class="reference internal" href="../../module/findgtest.html#module:FindGTest" title="FindGTest" id="index-0-module:FindGTest"><code>FindGTest</code></a> module, so if that finds a GTest package installed somewhere, it will make it available, and the dependency will not be built from source. If no GTest package is found, it <em>will</em> be built from source. In either case, the <code>GTest::gtest_main</code> target is expected to be defined, so we link our unit test executable to that target.</p> <p>High-level control is also available through the <a class="reference internal" href="../../module/fetchcontent.html#variable:FETCHCONTENT_TRY_FIND_PACKAGE_MODE" title="FETCHCONTENT_TRY_FIND_PACKAGE_MODE" id="index-0-variable:FETCHCONTENT_TRY_FIND_PACKAGE_MODE"><code>FETCHCONTENT_TRY_FIND_PACKAGE_MODE</code></a> variable. This can be set to <code>NEVER</code> to disable all redirection to <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-19-command:find_package"><code>find_package()</code></a>. It can be set to <code>ALWAYS</code> to try <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-20-command:find_package"><code>find_package()</code></a> even if <code>FIND_PACKAGE_ARGS</code> was not specified (this should be used with caution).</p> <p>The project might also decide that a particular dependency must be built from source. This might be needed if a patched or unreleased version of the dependency is required, or to satisfy some policy that requires all dependencies to be built from source. The project can enforce this by adding the <code>OVERRIDE_FIND_PACKAGE</code> keyword to <a class="reference internal" href="../../module/fetchcontent.html#command:fetchcontent_declare" title="fetchcontent_declare" id="index-1-command:fetchcontent_declare"><code>FetchContent_Declare()</code></a>. A call to <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-21-command:find_package"><code>find_package()</code></a> for that dependency will then be redirected to <a class="reference internal" href="../../module/fetchcontent.html#command:fetchcontent_makeavailable" title="fetchcontent_makeavailable" id="index-1-command:fetchcontent_makeavailable"><code>FetchContent_MakeAvailable()</code></a> instead.</p> <pre data-language="cmake">include(FetchContent)
FetchContent_Declare(
  Catch2
  URL https://intranet.mycomp.com/vendored/Catch2_2.13.4_patched.tgz
  URL_HASH MD5=abc123...
  OVERRIDE_FIND_PACKAGE
)

# The following is automatically redirected to FetchContent_MakeAvailable(Catch2)
find_package(Catch2)
</pre> <p>For more advanced use cases, see the <a class="reference internal" href="../../variable/cmake_find_package_redirects_dir.html#variable:CMAKE_FIND_PACKAGE_REDIRECTS_DIR" title="CMAKE_FIND_PACKAGE_REDIRECTS_DIR" id="index-0-variable:CMAKE_FIND_PACKAGE_REDIRECTS_DIR"><code>CMAKE_FIND_PACKAGE_REDIRECTS_DIR</code></a> variable.</p>   <h2 id="dependency-providers-overview">Dependency Providers</h2> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.24.</span></p> </div> <p>The preceding section discussed techniques that projects can use to specify their dependencies. Ideally, the project shouldn't really care where a dependency comes from, as long as it provides the things it expects (often just some imported targets). The project says what it needs and may also specify where to get it from, in the absence of any other details, so that it can still be built out-of-the-box.</p> <p>The developer, on the other hand, may be much more interested in controlling <em>how</em> a dependency is provided to the project. You might want to use a particular version of a package that you built yourself. You might want to use a third party package manager. You might want to redirect some requests to a different URL on a system you control for security or performance reasons. CMake supports these sort of scenarios through <a class="reference internal" href="../../command/cmake_language.html#dependency-providers"><span class="std std-ref">Dependency Providers</span></a>.</p> <p>A dependency provider can be set to intercept <a class="reference internal" href="../../command/find_package.html#command:find_package" title="find_package" id="index-22-command:find_package"><code>find_package()</code></a> and <a class="reference internal" href="../../module/fetchcontent.html#command:fetchcontent_makeavailable" title="fetchcontent_makeavailable" id="index-2-command:fetchcontent_makeavailable"><code>FetchContent_MakeAvailable()</code></a> calls. The provider is given an opportunity to satisfy such requests before falling back to the built-in implementation if the provider doesn't fulfill it.</p> <p>Only one dependency provider can be set, and it can only be set at a very specific point early in the CMake run. The <a class="reference internal" href="../../variable/cmake_project_top_level_includes.html#variable:CMAKE_PROJECT_TOP_LEVEL_INCLUDES" title="CMAKE_PROJECT_TOP_LEVEL_INCLUDES" id="index-0-variable:CMAKE_PROJECT_TOP_LEVEL_INCLUDES"><code>CMAKE_PROJECT_TOP_LEVEL_INCLUDES</code></a> variable lists CMake files that will be read while processing the first <a class="reference internal" href="../../command/project.html#command:project" title="project" id="index-0-command:project"><code>project()</code></a> call (and only that call). This is the only time a dependency provider may be set. At most, one single provider is expected to be used throughout the whole project.</p> <p>For some scenarios, the user wouldn't need to know the details of how the dependency provider is set. A third party may provide a file that can be added to <a class="reference internal" href="../../variable/cmake_project_top_level_includes.html#variable:CMAKE_PROJECT_TOP_LEVEL_INCLUDES" title="CMAKE_PROJECT_TOP_LEVEL_INCLUDES" id="index-1-variable:CMAKE_PROJECT_TOP_LEVEL_INCLUDES"><code>CMAKE_PROJECT_TOP_LEVEL_INCLUDES</code></a>, which will set up the dependency provider on the user's behalf. This is the recommended approach for package managers. The developer can use such a file like so:</p> <pre data-language="none">cmake -DCMAKE_PROJECT_TOP_LEVEL_INCLUDES=/path/to/package_manager/setup.cmake ...
</pre> <p>For details on how to implement your own custom dependency provider, see the <a class="reference internal" href="../../command/cmake_language.html#set-dependency-provider" title="cmake_language(set_dependency_provider)" id="index-0-command:cmake_language"><code>cmake_language(SET_DEPENDENCY_PROVIDER)</code></a> command.</p>   <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2000&ndash;2024 Kitware, Inc. and Contributors<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html" class="_attribution-link">https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html</a>
  </p>
</div>
