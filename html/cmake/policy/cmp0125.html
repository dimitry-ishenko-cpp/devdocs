<h1 id="policy:CMP0125">CMP0125</h1> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.21.</span></p> </div> <p>The <a class="reference internal" href="../command/find_file.html#command:find_file" title="find_file" id="index-0-command:find_file"><code>find_file()</code></a>, <a class="reference internal" href="../command/find_path.html#command:find_path" title="find_path" id="index-0-command:find_path"><code>find_path()</code></a>, <a class="reference internal" href="../command/find_library.html#command:find_library" title="find_library" id="index-0-command:find_library"><code>find_library()</code></a> and <a class="reference internal" href="../command/find_program.html#command:find_program" title="find_program" id="index-0-command:find_program"><code>find_program()</code></a> commands cache their result in the variable specified by their first argument. Prior to CMake 3.21, if a cache variable of that name already existed before the call but the cache variable had no type, any non-cache variable of the same name would be discarded and the cache variable was always used (see also <a class="reference internal" href="cmp0126.html#policy:CMP0126" title="CMP0126" id="index-0-policy:CMP0126"><code>CMP0126</code></a> for a different but similar behavior). This contradicts the convention that a non-cache variable should take precedence over a cache variable of the same name. Such a situation can arise if a user sets a cache variable on the command line without specifying a type, such as <code>cmake -DMYVAR=blah ...</code> instead of <code>cmake -DMYVAR:FILEPATH=blah</code>.</p> <p>Related to the above, if a cache variable of the specified name already exists and it <em>does</em> have a type, the various <code>find_...()</code> commands would return that value unchanged. In particular, if it contained a relative path, it would not be converted to an absolute path in this situation.</p> <p>When policy <code>CMP0125</code> is set to <code>OLD</code> or is unset, the behavior is as described above. When it is set to <code>NEW</code>, the behavior is as follows:</p> <ul class="simple"> <li>If a non-cache variable of the specified name exists when the <code>find_...()</code> command is called, its value will be used regardless of whether a cache variable of the same name already exists or not. A cache variable will not be created in this case if no such cache variable existed before. If a cache variable of the specified name did already exist, the cache will be updated to match the non-cache variable.</li> <li>The various <code>find...()</code> commands will always provide an absolute path in the result variable, except where a relative path provided by a cache or non-cache variable cannot be resolved to an existing path.</li> </ul> <p>This policy was introduced in CMake version 3.21. Use the <a class="reference internal" href="../command/cmake_policy.html#command:cmake_policy" title="cmake_policy" id="index-0-command:cmake_policy"><code>cmake_policy()</code></a> command to set it to <code>OLD</code> or <code>NEW</code> explicitly. Unlike many policies, CMake version 3.26.0-rc3 does <em>not</em> warn when the policy is not set and simply uses <code>OLD</code> behavior.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <code>OLD</code> behavior of a policy is <a class="reference internal" href="../manual/cmake-policies.7.html#manual:cmake-policies(7)" title="cmake-policies(7)" id="index-0-manual:cmake-policies(7)"><code>deprecated by definition</code></a> and may be removed in a future version of CMake.</p> </div>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2000&ndash;2023 Kitware, Inc. and Contributors<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://cmake.org/cmake/help/v3.26/policy/CMP0125.html" class="_attribution-link">https://cmake.org/cmake/help/v3.26/policy/CMP0125.html</a>
  </p>
</div>
