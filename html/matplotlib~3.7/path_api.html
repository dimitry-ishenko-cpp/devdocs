<h1 id="matplotlib-path">matplotlib.path</h1> <p>A module for dealing with the polylines used throughout Matplotlib.</p> <p>The primary class for polyline handling in Matplotlib is <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>. Almost all vector drawing makes use of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>s somewhere in the drawing pipeline.</p> <p>Whilst a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance itself cannot be drawn, some <a class="reference internal" href="artist_api.html#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> subclasses, such as <a class="reference internal" href="_as_gen/matplotlib.patches.pathpatch.html#matplotlib.patches.PathPatch" title="matplotlib.patches.PathPatch"><code>PathPatch</code></a> and <a class="reference internal" href="collections_api.html#matplotlib.collections.PathCollection" title="matplotlib.collections.PathCollection"><code>PathCollection</code></a>, can be used for convenient <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> visualisation.</p> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.path.Path"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.path.</span><span class="sig-name descname">Path</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span></em>, <em class="sig-param"><span class="n">codes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">_interpolation_steps</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">closed</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L24-L1045"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code>object</code></a></p> <p>A series of possibly disconnected, possibly closed, line and curve segments.</p> <p>The underlying storage is made up of two parallel numpy arrays:</p> <ul class="simple"> <li>
<em>vertices</em>: an Nx2 float array of vertices</li> <li>
<em>codes</em>: an N-length uint8 array of path codes, or None</li> </ul> <p>These two arrays always have the same length in the first dimension. For example, to represent a cubic curve, you must provide three vertices and three <code>CURVE4</code> codes.</p> <p>The code types are:</p> <ul class="simple"> <li>
<dl class="simple"> <dt>
<code>STOP</code><span class="classifier">1 vertex (ignored)</span>
</dt>
<dd>
<p>A marker for the end of the entire path (currently not required and ignored)</p> </dd> </dl> </li> <li>
<dl class="simple"> <dt>
<code>MOVETO</code><span class="classifier">1 vertex</span>
</dt>
<dd>
<p>Pick up the pen and move to the given vertex.</p> </dd> </dl> </li> <li>
<dl class="simple"> <dt>
<code>LINETO</code><span class="classifier">1 vertex</span>
</dt>
<dd>
<p>Draw a line from the current position to the given vertex.</p> </dd> </dl> </li> <li>
<dl class="simple"> <dt>
<code>CURVE3</code><span class="classifier">1 control point, 1 endpoint</span>
</dt>
<dd>
<p>Draw a quadratic Bézier curve from the current position, with the given control point, to the given end point.</p> </dd> </dl> </li> <li>
<dl class="simple"> <dt>
<code>CURVE4</code><span class="classifier">2 control points, 1 endpoint</span>
</dt>
<dd>
<p>Draw a cubic Bézier curve from the current position, with the given control points, to the given end point.</p> </dd> </dl> </li> <li>
<dl class="simple"> <dt>
<code>CLOSEPOLY</code><span class="classifier">1 vertex (ignored)</span>
</dt>
<dd>
<p>Draw a line segment to the start point of the current polyline.</p> </dd> </dl> </li> </ul> <p>If <em>codes</em> is None, it is interpreted as a <code>MOVETO</code> followed by a series of <code>LINETO</code>.</p> <p>Users of Path objects should not access the vertices and codes arrays directly. Instead, they should use <a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code>iter_segments</code></a> or <a class="reference internal" href="#matplotlib.path.Path.cleaned" title="matplotlib.path.Path.cleaned"><code>cleaned</code></a> to get the vertex/code pairs. This helps, in particular, to consistently handle the case of <em>codes</em> being None.</p> <p>Some behavior of Path objects can be controlled by rcParams. See the rcParams whose keys start with 'path.'.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The vertices and codes arrays should be treated as immutable -- there are a number of optimizations and assumptions made up front in the constructor that will not change when the data changes.</p> </div> <p>Create a new path with the given vertices and codes.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>vertices</strong><span class="classifier">(N, 2) array-like</span>
</dt>
<dd>
<p>The path vertices, as an array, masked array or sequence of pairs. Masked values, if any, will be converted to NaNs, which are then handled correctly by the Agg PathIterator and other consumers of path data, such as <a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code>iter_segments()</code></a>.</p> </dd> <dt>
<strong>codes</strong><span class="classifier">array-like or None, optional</span>
</dt>
<dd>
<p>N-length array of integers representing the codes of the path. If not None, codes must be the same length as vertices. If None, <em>vertices</em> will be treated as a series of line segments.</p> </dd> <dt>
<strong>_interpolation_steps</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>Used as a hint to certain projections, such as Polar, that this path should be linearly interpolated immediately before drawing. This attribute is primarily an implementation detail and is not intended for public use.</p> </dd> <dt>
<strong>closed</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>If <em>codes</em> is None and closed is True, vertices will be treated as line segments of a closed polygon. Note that the last vertex will then be ignored (as the corresponding code will be set to CLOSEPOLY).</p> </dd> <dt>
<strong>readonly</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>Makes the path behave in an immutable way and sets the vertices and codes as read-only arrays.</p> </dd> </dl> </dd> </dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.path.Path.CLOSEPOLY"> <span class="sig-name descname">CLOSEPOLY</span><em class="property"><span class="p">=</span>79</em>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.path.Path.CURVE3"> <span class="sig-name descname">CURVE3</span><em class="property"><span class="p">=</span>3</em>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.path.Path.CURVE4"> <span class="sig-name descname">CURVE4</span><em class="property"><span class="p">=</span>4</em>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.path.Path.LINETO"> <span class="sig-name descname">LINETO</span><em class="property"><span class="p">=</span>2</em>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.path.Path.MOVETO"> <span class="sig-name descname">MOVETO</span><em class="property"><span class="p">=</span>1</em>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.path.Path.NUM_VERTICES_FOR_CODE"> <span class="sig-name descname">NUM_VERTICES_FOR_CODE</span><em class="property"><span class="p">=</span>{0: 1, 1: 1, 2: 1, 3: 2, 4: 3, 79: 1}</em>
</dt> <dd>
<p>A dictionary mapping Path codes to the number of vertices that the code expects.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.path.Path.STOP"> <span class="sig-name descname">STOP</span><em class="property"><span class="p">=</span>0</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.arc"> <em class="property">classmethod</em><span class="sig-name descname">arc</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta1</span></em>, <em class="sig-param"><span class="n">theta2</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">is_wedge</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L924-L1001"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> for the unit circle arc from angles <em>theta1</em> to <em>theta2</em> (in degrees).</p> <p><em>theta2</em> is unwrapped to produce the shortest arc within 360 degrees. That is, if <em>theta2</em> &gt; <em>theta1</em> + 360, the arc will be from <em>theta1</em> to <em>theta2</em> - 360 and not a full circle plus some extra overlap.</p> <p>If <em>n</em> is provided, it is the number of spline segments to make. If <em>n</em> is not provided, the number of spline segments is determined based on the delta between <em>theta1</em> and <em>theta2</em>.</p>  <p>Masionobe, L. 2003. <a class="reference external" href="https://web.archive.org/web/20190318044212/http://www.spaceroots.org/documents/ellipse/index.html">Drawing an elliptical arc using polylines, quadratic or cubic Bezier curves</a>.</p>  </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.circle"> <em class="property">classmethod</em><span class="sig-name descname">circle</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">(0.0, 0.0)</span></em>, <em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L812-L878"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> representing a circle of a given radius and center.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>center</strong><span class="classifier">(float, float), default: (0, 0)</span>
</dt>
<dd>
<p>The center of the circle.</p> </dd> <dt>
<strong>radius</strong><span class="classifier">float, default: 1</span>
</dt>
<dd>
<p>The radius of the circle.</p> </dd> <dt>
<strong>readonly</strong><span class="classifier">bool</span>
</dt>
<dd>
<p>Whether the created path should have the "readonly" argument set when creating the Path instance.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The circle is approximated using 8 cubic Bézier curves, as described in</p>  <p>Lancaster, Don. <a class="reference external" href="https://www.tinaja.com/glib/ellipse4.pdf">Approximating a Circle or an Ellipse Using Four Bezier Cubic Splines</a>.</p>  </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.cleaned"> <span class="sig-name descname">cleaned</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">remove_nans</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">clip</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">simplify</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">curves</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">stroke_width</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">snap</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sketch</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L466-L483"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a new Path with vertices and codes cleaned according to the parameters.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code>Path.iter_segments</code></a></dt>
<dd>
<p>for details of the keyword arguments.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.clip_to_bbox"> <span class="sig-name descname">clip_to_bbox</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">bbox</span></em>, <em class="sig-param"><span class="n">inside</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L1033-L1045"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Clip the path to the given bounding box.</p> <p>The path must be made up of one or more closed polygons. This algorithm will not behave correctly for unclosed paths.</p> <p>If <em>inside</em> is <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.11)"><code>True</code></a>, clip to the inside of the box, otherwise to the outside of the box.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.path.Path.code_type"> <span class="sig-name descname">code_type</span>
</dt> <dd>
<p>alias of <code>uint8</code></p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.path.Path.codes"> <em class="property">property</em><span class="sig-name descname">codes</span>
</dt> <dd>
<p>The list of codes in the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> as a 1D numpy array. Each code is one of <a class="reference internal" href="#matplotlib.path.Path.STOP" title="matplotlib.path.Path.STOP"><code>STOP</code></a>, <a class="reference internal" href="#matplotlib.path.Path.MOVETO" title="matplotlib.path.Path.MOVETO"><code>MOVETO</code></a>, <a class="reference internal" href="#matplotlib.path.Path.LINETO" title="matplotlib.path.Path.LINETO"><code>LINETO</code></a>, <a class="reference internal" href="#matplotlib.path.Path.CURVE3" title="matplotlib.path.Path.CURVE3"><code>CURVE3</code></a>, <a class="reference internal" href="#matplotlib.path.Path.CURVE4" title="matplotlib.path.Path.CURVE4"><code>CURVE4</code></a> or <a class="reference internal" href="#matplotlib.path.Path.CLOSEPOLY" title="matplotlib.path.Path.CLOSEPOLY"><code>CLOSEPOLY</code></a>. For codes that correspond to more than one vertex (<a class="reference internal" href="#matplotlib.path.Path.CURVE3" title="matplotlib.path.Path.CURVE3"><code>CURVE3</code></a> and <a class="reference internal" href="#matplotlib.path.Path.CURVE4" title="matplotlib.path.Path.CURVE4"><code>CURVE4</code></a>), that code will be repeated so that the length of <a class="reference internal" href="#matplotlib.path.Path.vertices" title="matplotlib.path.Path.vertices"><code>vertices</code></a> and <a class="reference internal" href="#matplotlib.path.Path.codes" title="matplotlib.path.Path.codes"><code>codes</code></a> is always the same.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.contains_path"> <span class="sig-name descname">contains_path</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L592-L601"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether this (closed) path completely contains the given path.</p> <p>If <em>transform</em> is not <code>None</code>, the path will be transformed before checking for containment.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.contains_point"> <span class="sig-name descname">contains_point</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">point</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L498-L546"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the area enclosed by the path contains the given point.</p> <p>The path is always treated as closed; i.e. if the last code is not CLOSEPOLY an implicit segment connecting the last vertex to the first vertex is assumed.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>point</strong><span class="classifier">(float, float)</span>
</dt>
<dd>
<p>The point (x, y) to check.</p> </dd> <dt>
<strong>transform</strong><span class="classifier"><a class="reference internal" href="transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a>, optional</span>
</dt>
<dd>
<p>If not <code>None</code>, <em>point</em> will be compared to <code>self</code> transformed by <em>transform</em>; i.e. for a correct check, <em>transform</em> should transform the path into the coordinate system of <em>point</em>.</p> </dd> <dt>
<strong>radius</strong><span class="classifier">float, default: 0</span>
</dt>
<dd>
<p>Additional margin on the path in coordinates of <em>point</em>. The path is extended tangentially by <em>radius/2</em>; i.e. if you would draw the path with a linewidth of <em>radius</em>, all points on the line would still be considered to be contained in the area. Conversely, negative values shrink the area: Points on the imaginary line will be considered outside the area.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>bool</dt>
 </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The current algorithm has some limitations:</p> <ul class="simple"> <li>The result is undefined for points exactly at the boundary (i.e. at the path shifted by <em>radius/2</em>).</li> <li>The result is undefined if there is no enclosed area, i.e. all vertices are on a straight line.</li> <li>If bounding lines start to cross each other due to <em>radius</em> shift, the result is not guaranteed to be correct.</li> </ul> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.contains_points"> <span class="sig-name descname">contains_points</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L548-L590"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the area enclosed by the path contains the given points.</p> <p>The path is always treated as closed; i.e. if the last code is not CLOSEPOLY an implicit segment connecting the last vertex to the first vertex is assumed.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>points</strong><span class="classifier">(N, 2) array</span>
</dt>
<dd>
<p>The points to check. Columns contain x and y values.</p> </dd> <dt>
<strong>transform</strong><span class="classifier"><a class="reference internal" href="transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a>, optional</span>
</dt>
<dd>
<p>If not <code>None</code>, <em>points</em> will be compared to <code>self</code> transformed by <em>transform</em>; i.e. for a correct check, <em>transform</em> should transform the path into the coordinate system of <em>points</em>.</p> </dd> <dt>
<strong>radius</strong><span class="classifier">float, default: 0</span>
</dt>
<dd>
<p>Additional margin on the path in coordinates of <em>points</em>. The path is extended tangentially by <em>radius/2</em>; i.e. if you would draw the path with a linewidth of <em>radius</em>, all points on the line would still be considered to be contained in the area. Conversely, negative values shrink the area: Points on the imaginary line will be considered outside the area.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>length-N bool array</dt>
 </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The current algorithm has some limitations:</p> <ul class="simple"> <li>The result is undefined for points exactly at the boundary (i.e. at the path shifted by <em>radius/2</em>).</li> <li>The result is undefined if there is no enclosed area, i.e. all vertices are on a straight line.</li> <li>If bounding lines start to cross each other due to <em>radius</em> shift, the result is not guaranteed to be correct.</li> </ul> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.copy"> <span class="sig-name descname">copy</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L274-L279"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a shallow copy of the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, which will share the vertices and codes with the source <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.deepcopy"> <span class="sig-name descname">deepcopy</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">memo</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L281-L289"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a deepcopy of the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>. The <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> will not be readonly, even if the source <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> is.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.get_extents"> <span class="sig-name descname">get_extents</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L603-L642"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get Bbox of the path.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>transform</strong><span class="classifier">matplotlib.transforms.Transform, optional</span>
</dt>
<dd>
<p>Transform to apply to path before computing extents, if any.</p> </dd> <dt><strong>**kwargs</strong></dt>
<dd>
<p>Forwarded to <a class="reference internal" href="#matplotlib.path.Path.iter_bezier" title="matplotlib.path.Path.iter_bezier"><code>iter_bezier</code></a>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>matplotlib.transforms.Bbox</dt>
<dd>
<p>The extents of the path Bbox([[xmin, ymin], [xmax, ymax]])</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.hatch"> <em class="property">static</em><span class="sig-name descname">hatch</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">hatchpattern</span></em>, <em class="sig-param"><span class="n">density</span><span class="o">=</span><span class="default_value">6</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L1021-L1031"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Given a hatch specifier, <em>hatchpattern</em>, generates a Path that can be used in a repeated hatching pattern. <em>density</em> is the number of lines per unit square.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.interpolated"> <span class="sig-name descname">interpolated</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">steps</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L665-L682"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a new path resampled to length N x steps.</p> <p>Codes other than LINETO are not handled correctly.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.intersects_bbox"> <span class="sig-name descname">intersects_bbox</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">bbox</span></em>, <em class="sig-param"><span class="n">filled</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L653-L663"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether this path intersects a given <a class="reference internal" href="transformations.html#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <p>If <em>filled</em> is True, then this also returns True if the path completely encloses the <a class="reference internal" href="transformations.html#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> (i.e., the path is treated as filled).</p> <p>The bounding box is always considered filled.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.intersects_path"> <span class="sig-name descname">intersects_path</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">filled</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L644-L651"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether if this path intersects another given path.</p> <p>If <em>filled</em> is True, then this also returns True if one path completely encloses the other (i.e., the paths are treated as filled).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.iter_bezier"> <span class="sig-name descname">iter_bezier</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L419-L464"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Iterate over each Bézier curve (lines included) in a Path.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt><strong>**kwargs</strong></dt>
<dd>
<p>Forwarded to <a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code>iter_segments</code></a>.</p> </dd> </dl> </dd> <dt class="field-even">Yields<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>B</strong><span class="classifier">matplotlib.bezier.BezierSegment</span>
</dt>
<dd>
<p>The Bézier curves that make up the current path. Note in particular that freestanding points are Bézier curves of order 0, and lines are Bézier curves of order 1 (with two control points).</p> </dd> <dt>
<strong>code</strong><span class="classifier">Path.code_type</span>
</dt>
<dd>
<p>The code describing what kind of curve is being returned. Path.MOVETO, Path.LINETO, Path.CURVE3, Path.CURVE4 correspond to Bézier curves with 1, 2, 3, and 4 control points (respectively). Path.CLOSEPOLY is a Path.LINETO with the control points correctly chosen based on the start/end points of the current stroke.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.iter_segments"> <span class="sig-name descname">iter_segments</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">remove_nans</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">clip</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">snap</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">stroke_width</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">simplify</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">curves</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">sketch</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L353-L417"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Iterate over all curve segments in the path.</p> <p>Each iteration returns a pair <code>(vertices, code)</code>, where <code>vertices</code> is a sequence of 1-3 coordinate pairs, and <code>code</code> is a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> code.</p> <p>Additionally, this method can provide a number of standard cleanups and conversions to the path.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>transform</strong><span class="classifier">None or <a class="reference internal" href="transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a></span>
</dt>
<dd>
<p>If not None, the given affine transformation will be applied to the path.</p> </dd> <dt>
<strong>remove_nans</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>Whether to remove all NaNs from the path and skip over them using MOVETO commands.</p> </dd> <dt>
<strong>clip</strong><span class="classifier">None or (float, float, float, float), optional</span>
</dt>
<dd>
<p>If not None, must be a four-tuple (x1, y1, x2, y2) defining a rectangle in which to clip the path.</p> </dd> <dt>
<strong>snap</strong><span class="classifier">None or bool, optional</span>
</dt>
<dd>
<p>If True, snap all nodes to pixels; if False, don't snap them. If None, snap if the path contains only segments parallel to the x or y axes, and no more than 1024 of them.</p> </dd> <dt>
<strong>stroke_width</strong><span class="classifier">float, optional</span>
</dt>
<dd>
<p>The width of the stroke being drawn (used for path snapping).</p> </dd> <dt>
<strong>simplify</strong><span class="classifier">None or bool, optional</span>
</dt>
<dd>
<p>Whether to simplify the path by removing vertices that do not affect its appearance. If None, use the <a class="reference internal" href="#matplotlib.path.Path.should_simplify" title="matplotlib.path.Path.should_simplify"><code>should_simplify</code></a> attribute. See also <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=path.simplify#matplotlibrc-sample"><span class="std std-ref">rcParams["path.simplify"]</span></a></code> (default: <code>True</code>) and <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=path.simplify_threshold#matplotlibrc-sample"><span class="std std-ref">rcParams["path.simplify_threshold"]</span></a></code> (default: <code>0.111111111111</code>).</p> </dd> <dt>
<strong>curves</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>If True, curve segments will be returned as curve segments. If False, all curves will be converted to line segments.</p> </dd> <dt>
<strong>sketch</strong><span class="classifier">None or sequence, optional</span>
</dt>
<dd>
<p>If not None, must be a 3-tuple of the form (scale, length, randomness), representing the sketch parameters.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.make_compound_path"> <em class="property">classmethod</em><span class="sig-name descname">make_compound_path</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L321-L345"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Make a compound path from a list of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> objects. Blindly removes all <a class="reference internal" href="#matplotlib.path.Path.STOP" title="matplotlib.path.Path.STOP"><code>Path.STOP</code></a> control points.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.make_compound_path_from_polys"> <em class="property">classmethod</em><span class="sig-name descname">make_compound_path_from_polys</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">XY</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L293-L319"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Make a compound <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> object to draw a number of polygons with equal numbers of sides.</p> <p>(<a class="reference download internal" download="" href="https://matplotlib.org/stable/_downloads/e44134d2fdd50b66bb9fe932e3555cdd/histogram_path.py"><code>Source code</code></a>, <a class="reference download internal" download="" href="https://matplotlib.org/stable/_downloads/9d2e557c43c766afe81e0c6cddfcc4ae/histogram_path_00_00.png"><code>png</code></a>)</p> <figure class="align-default"> <img alt="../_images/histogram_path_00_00.png" class="plot-directive" src="data:image/png;base64,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"> </figure> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>XY</strong><span class="classifier">(numpolys, numsides, 2) array</span>
</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.path.Path.readonly"> <em class="property">property</em><span class="sig-name descname">readonly</span>
</dt> <dd>
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.11)"><code>True</code></a> if the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> is read-only.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.path.Path.should_simplify"> <em class="property">property</em><span class="sig-name descname">should_simplify</span>
</dt> <dd>
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.11)"><code>True</code></a> if the vertices array should be simplified.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.path.Path.simplify_threshold"> <em class="property">property</em><span class="sig-name descname">simplify_threshold</span>
</dt> <dd>
<p>The fraction of a pixel difference below which vertices will be simplified out.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.to_polygons"> <span class="sig-name descname">to_polygons</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">width</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">height</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">closed_only</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L684-L726"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert this path to a list of polygons or polylines. Each polygon/polyline is an Nx2 array of vertices. In other words, each polygon has no <code>MOVETO</code> instructions or curves. This is useful for displaying in backends that do not support compound paths or Bézier curves.</p> <p>If <em>width</em> and <em>height</em> are both non-zero then the lines will be simplified so that vertices outside of (0, 0), (width, height) will be clipped.</p> <p>If <em>closed_only</em> is <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.11)"><code>True</code></a> (default), only closed polygons, with the last point being the same as the first point, will be returned. Any unclosed polylines in the path will be explicitly closed. If <em>closed_only</em> is <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.11)"><code>False</code></a>, any unclosed polygons in the path will be returned as unclosed polygons, and the closed polygons will be returned explicitly closed by setting the last point to the same as the first point.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.transformed"> <span class="sig-name descname">transformed</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">transform</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L485-L496"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a transformed copy of the path.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="transformations.html#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>matplotlib.transforms.TransformedPath</code></a></dt>
<dd>
<p>A specialized path class that will cache the transformed result and automatically update when the transform changes.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.unit_circle"> <em class="property">classmethod</em><span class="sig-name descname">unit_circle</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L800-L810"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the readonly <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> of the unit circle.</p> <p>For most cases, <a class="reference internal" href="#matplotlib.path.Path.circle" title="matplotlib.path.Path.circle"><code>Path.circle()</code></a> will be what you want.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.unit_circle_righthalf"> <em class="property">classmethod</em><span class="sig-name descname">unit_circle_righthalf</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L882-L922"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> of the right half of a unit circle.</p> <p>See <a class="reference internal" href="#matplotlib.path.Path.circle" title="matplotlib.path.Path.circle"><code>Path.circle</code></a> for the reference on the approximation used.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.unit_rectangle"> <em class="property">classmethod</em><span class="sig-name descname">unit_rectangle</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L730-L738"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance of the unit rectangle from (0, 0) to (1, 1).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.unit_regular_asterisk"> <em class="property">classmethod</em><span class="sig-name descname">unit_regular_asterisk</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">numVertices</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L790-L796"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> for a unit regular asterisk with the given numVertices and radius of 1.0, centered at (0, 0).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.unit_regular_polygon"> <em class="property">classmethod</em><span class="sig-name descname">unit_regular_polygon</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">numVertices</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L742-L762"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance for a unit regular polygon with the given <em>numVertices</em> such that the circumscribing circle has radius 1.0, centered at (0, 0).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.unit_regular_star"> <em class="property">classmethod</em><span class="sig-name descname">unit_regular_star</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">numVertices</span></em>, <em class="sig-param"><span class="n">innerCircle</span><span class="o">=</span><span class="default_value">0.5</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L766-L788"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> for a unit regular star with the given numVertices and radius of 1.0, centered at (0, 0).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.path.Path.vertices"> <em class="property">property</em><span class="sig-name descname">vertices</span>
</dt> <dd>
<p>The list of vertices in the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> as an Nx2 numpy array.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.path.Path.wedge"> <em class="property">classmethod</em><span class="sig-name descname">wedge</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta1</span></em>, <em class="sig-param"><span class="n">theta2</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L1003-L1019"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> for the unit circle wedge from angles <em>theta1</em> to <em>theta2</em> (in degrees).</p> <p><em>theta2</em> is unwrapped to produce the shortest wedge within 360 degrees. That is, if <em>theta2</em> &gt; <em>theta1</em> + 360, the wedge will be from <em>theta1</em> to <em>theta2</em> - 360 and not a full circle plus some extra overlap.</p> <p>If <em>n</em> is provided, it is the number of spline segments to make. If <em>n</em> is not provided, the number of spline segments is determined based on the delta between <em>theta1</em> and <em>theta2</em>.</p> <p>See <a class="reference internal" href="#matplotlib.path.Path.arc" title="matplotlib.path.Path.arc"><code>Path.arc</code></a> for the reference on the approximation used.</p> </dd>
</dl> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.path.get_path_collection_extents"> <span class="sig-prename descclassname">matplotlib.path.</span><span class="sig-name descname">get_path_collection_extents</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">master_transform</span></em>, <em class="sig-param"><span class="n">paths</span></em>, <em class="sig-param"><span class="n">transforms</span></em>, <em class="sig-param"><span class="n">offsets</span></em>, <em class="sig-param"><span class="n">offset_transform</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/path.py#L1048-L1080"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Given a sequence of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>s, <a class="reference internal" href="transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>s objects, and offsets, as found in a <a class="reference internal" href="collections_api.html#matplotlib.collections.PathCollection" title="matplotlib.collections.PathCollection"><code>PathCollection</code></a>, returns the bounding box that encapsulates all of them.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>master_transform</strong><span class="classifier"><a class="reference internal" href="transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a></span>
</dt>
<dd>
<p>Global transformation applied to all paths.</p> </dd> <dt>
<strong>paths</strong><span class="classifier">list of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a></span>
</dt>
 <dt>
<strong>transforms</strong><span class="classifier">list of <a class="reference internal" href="transformations.html#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a></span>
</dt>
 <dt>
<strong>offsets</strong><span class="classifier">(N, 2) array-like</span>
</dt>
 <dt>
<strong>offset_transform</strong><span class="classifier"><a class="reference internal" href="transformations.html#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a></span>
</dt>
<dd>
<p>Transform applied to the offsets before offsetting the path.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The way that <em>paths</em>, <em>transforms</em> and <em>offsets</em> are combined follows the same method as for collections: Each is iterated over independently, so if you have 3 paths, 2 transforms and 1 offset, their combinations are as follows:</p>  <p>(A, A, A), (B, B, A), (C, A, A)</p>  </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2023 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/stable/api/path_api.html" class="_attribution-link">https://matplotlib.org/stable/api/path_api.html</a>
  </p>
</div>
