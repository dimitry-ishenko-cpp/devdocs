<h1>matplotlib.pyplot.quiver</h1> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.pyplot.quiver"> <span class="sig-prename descclassname">matplotlib.pyplot.</span><span class="sig-name descname">quiver</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/pyplot.py#L2841-L2847"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Plot a 2D field of arrows.</p> <p>Call signature:</p> <pre data-language="python">quiver([X, Y], U, V, [C], **kwargs)
</pre> <p><em>X</em>, <em>Y</em> define the arrow locations, <em>U</em>, <em>V</em> define the arrow directions, and <em>C</em> optionally sets the color.</p> <p><strong>Arrow length</strong></p> <p>The default settings auto-scales the length of the arrows to a reasonable size. To change this behavior see the <em>scale</em> and <em>scale_units</em> parameters.</p> <p><strong>Arrow shape</strong></p> <p>The arrow shape is determined by <em>width</em>, <em>headwidth</em>, <em>headlength</em> and <em>headaxislength</em>. See the notes below.</p> <p><strong>Arrow styling</strong></p> <p>Each arrow is internally represented by a filled polygon with a default edge linewidth of 0. As a result, an arrow is rather a filled area, not a line with a head, and <a class="reference internal" href="../collections_api.html#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><code>PolyCollection</code></a> properties like <em>linewidth</em>, <em>edgecolor</em>, <em>facecolor</em>, etc. act accordingly.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>X, Y</strong><span class="classifier">1D or 2D array-like, optional</span>
</dt>
<dd>
<p>The x and y coordinates of the arrow locations.</p> <p>If not given, they will be generated as a uniform integer meshgrid based on the dimensions of <em>U</em> and <em>V</em>.</p> <p>If <em>X</em> and <em>Y</em> are 1D but <em>U</em>, <em>V</em> are 2D, <em>X</em>, <em>Y</em> are expanded to 2D using <code>X, Y = np.meshgrid(X, Y)</code>. In this case <code>len(X)</code> and <code>len(Y)</code> must match the column and row dimensions of <em>U</em> and <em>V</em>.</p> </dd> <dt>
<strong>U, V</strong><span class="classifier">1D or 2D array-like</span>
</dt>
<dd>
<p>The x and y direction components of the arrow vectors. The interpretation of these components (in data or in screen space) depends on <em>angles</em>.</p> <p><em>U</em> and <em>V</em> must have the same number of elements, matching the number of arrow locations in <em>X</em>, <em>Y</em>. <em>U</em> and <em>V</em> may be masked. Locations masked in any of <em>U</em>, <em>V</em>, and <em>C</em> will not be drawn.</p> </dd> <dt>
<strong>C</strong><span class="classifier">1D or 2D array-like, optional</span>
</dt>
<dd>
<p>Numeric data that defines the arrow colors by colormapping via <em>norm</em> and <em>cmap</em>.</p> <p>This does not support explicit colors. If you want to set colors directly, use <em>color</em> instead. The size of <em>C</em> must match the number of arrow locations.</p> </dd> <dt>
<strong>angles</strong><span class="classifier">{'uv', 'xy'} or array-like, default: 'uv'</span>
</dt>
<dd>
<p>Method for determining the angle of the arrows.</p> <ul> <li>
<p>'uv': Arrow direction in screen coordinates. Use this if the arrows symbolize a quantity that is not based on <em>X</em>, <em>Y</em> data coordinates.</p> <p>If <em>U</em> == <em>V</em> the orientation of the arrow on the plot is 45 degrees counter-clockwise from the horizontal axis (positive to the right).</p> </li> <li>'xy': Arrow direction in data coordinates, i.e. the arrows point from (x, y) to (x+u, y+v). Use this e.g. for plotting a gradient field.</li> <li>
<p>Arbitrary angles may be specified explicitly as an array of values in degrees, counter-clockwise from the horizontal axis.</p> <p>In this case <em>U</em>, <em>V</em> is only used to determine the length of the arrows.</p> </li> </ul> <p>Note: inverting a data axis will correspondingly invert the arrows only with <code>angles='xy'</code>.</p> </dd> <dt>
<strong>pivot</strong><span class="classifier">{'tail', 'mid', 'middle', 'tip'}, default: 'tail'</span>
</dt>
<dd>
<p>The part of the arrow that is anchored to the <em>X</em>, <em>Y</em> grid. The arrow rotates about this point.</p> <p>'mid' is a synonym for 'middle'.</p> </dd> <dt>
<strong>scale</strong><span class="classifier">float, optional</span>
</dt>
<dd>
<p>Scales the length of the arrow inversely.</p> <p>Number of data units per arrow length unit, e.g., m/s per plot width; a smaller scale parameter makes the arrow longer. Default is <em>None</em>.</p> <p>If <em>None</em>, a simple autoscaling algorithm is used, based on the average vector length and the number of vectors. The arrow length unit is given by the <em>scale_units</em> parameter.</p> </dd> <dt>
<strong>scale_units</strong><span class="classifier">{'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, optional</span>
</dt>
<dd>
<p>If the <em>scale</em> kwarg is <em>None</em>, the arrow length unit. Default is <em>None</em>.</p> <p>e.g. <em>scale_units</em> is 'inches', <em>scale</em> is 2.0, and <code>(u, v) = (1, 0)</code>, then the vector will be 0.5 inches long.</p> <p>If <em>scale_units</em> is 'width' or 'height', then the vector will be half the width/height of the axes.</p> <p>If <em>scale_units</em> is 'x' then the vector will be 0.5 x-axis units. To plot vectors in the x-y plane, with u and v having the same units as x and y, use <code>angles='xy', scale_units='xy', scale=1</code>.</p> </dd> <dt>
<strong>units</strong><span class="classifier">{'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, default: 'width'</span>
</dt>
<dd>
<p>Affects the arrow size (except for the length). In particular, the shaft <em>width</em> is measured in multiples of this unit.</p> <p>Supported values are:</p> <ul class="simple"> <li>'width', 'height': The width or height of the Axes.</li> <li>'dots', 'inches': Pixels or inches based on the figure dpi.</li> <li>'x', 'y', 'xy': <em>X</em>, <em>Y</em> or <span class="math notranslate nohighlight">\(\sqrt{X^2 + Y^2}\)</span> in data units.</li> </ul> <p>The following table summarizes how these values affect the visible arrow size under zooming and figure size changes:</p> <table class="table"> <thead> <tr>
<th class="head"><p>units</p></th> <th class="head"><p>zoom</p></th> <th class="head"><p>figure size change</p></th> </tr> </thead>  <tr>
<td><p>'x', 'y', 'xy'</p></td> <td><p>arrow size scales</p></td> <td><p>—</p></td> </tr> <tr>
<td><p>'width', 'height'</p></td> <td><p>—</p></td> <td><p>arrow size scales</p></td> </tr> <tr>
<td><p>'dots', 'inches'</p></td> <td><p>—</p></td> <td><p>—</p></td> </tr>  </table> </dd> <dt>
<strong>width</strong><span class="classifier">float, optional</span>
</dt>
<dd>
<p>Shaft width in arrow units. All head parameters are relative to <em>width</em>.</p> <p>The default depends on choice of <em>units</em> above, and number of vectors; a typical starting value is about 0.005 times the width of the plot.</p> </dd> <dt>
<strong>headwidth</strong><span class="classifier">float, default: 3</span>
</dt>
<dd>
<p>Head width as multiple of shaft <em>width</em>. See the notes below.</p> </dd> <dt>
<strong>headlength</strong><span class="classifier">float, default: 5</span>
</dt>
<dd>
<p>Head length as multiple of shaft <em>width</em>. See the notes below.</p> </dd> <dt>
<strong>headaxislength</strong><span class="classifier">float, default: 4.5</span>
</dt>
<dd>
<p>Head length at shaft intersection as multiple of shaft <em>width</em>. See the notes below.</p> </dd> <dt>
<strong>minshaft</strong><span class="classifier">float, default: 1</span>
</dt>
<dd>
<p>Length below which arrow scales, in units of head length. Do not set this to less than 1, or small arrows will look terrible!</p> </dd> <dt>
<strong>minlength</strong><span class="classifier">float, default: 1</span>
</dt>
<dd>
<p>Minimum length as a multiple of shaft width; if an arrow length is less than this, plot a dot (hexagon) of this diameter instead.</p> </dd> <dt>
<strong>color</strong><span class="classifier">color or color sequence, optional</span>
</dt>
<dd>
<p>Explicit color(s) for the arrows. If <em>C</em> has been set, <em>color</em> has no effect.</p> <p>This is a synonym for the <a class="reference internal" href="../collections_api.html#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><code>PolyCollection</code></a> <em>facecolor</em> parameter.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt><a class="reference internal" href="matplotlib.quiver.quiver.html#matplotlib.quiver.Quiver" title="matplotlib.quiver.Quiver"><code>Quiver</code></a></dt>
 </dl> </dd> <dt class="field-odd">Other Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>data</strong><span class="classifier">indexable object, optional</span>
</dt>
<dd>
<p>If given, all parameters also accept a string <code>s</code>, which is interpreted as <code>data[s]</code> (unless this raises an exception).</p> </dd> <dt>
<strong>**kwargs</strong><span class="classifier"><a class="reference internal" href="../collections_api.html#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><code>PolyCollection</code></a> properties, optional</span>
</dt>
<dd>
<p>All other keyword arguments are passed on to <a class="reference internal" href="../collections_api.html#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><code>PolyCollection</code></a>:</p> <table class="property-table table"> <thead> <tr>
<th class="head"><p>Property</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_agg_filter.html#matplotlib.artist.Artist.set_agg_filter" title="matplotlib.artist.Artist.set_agg_filter"><code>agg_filter</code></a></p></td> <td><p>a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array and two offsets from the bottom left corner of the image</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_alpha" title="matplotlib.collections.Collection.set_alpha"><code>alpha</code></a></p></td> <td><p>array-like or scalar or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_animated.html#matplotlib.artist.Artist.set_animated" title="matplotlib.artist.Artist.set_animated"><code>animated</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_antialiased" title="matplotlib.collections.Collection.set_antialiased"><code>antialiased</code></a> or aa or antialiaseds</p></td> <td><p>bool or list of bools</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../cm_api.html#matplotlib.cm.ScalarMappable.set_array" title="matplotlib.cm.ScalarMappable.set_array"><code>array</code></a></p></td> <td><p>array-like or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_capstyle" title="matplotlib.collections.Collection.set_capstyle"><code>capstyle</code></a></p></td> <td><p><a class="reference internal" href="../_enums_api.html#matplotlib._enums.CapStyle" title="matplotlib._enums.CapStyle"><code>CapStyle</code></a> or {'butt', 'projecting', 'round'}</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../cm_api.html#matplotlib.cm.ScalarMappable.set_clim" title="matplotlib.cm.ScalarMappable.set_clim"><code>clim</code></a></p></td> <td><p>(vmin: float, vmax: float)</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_clip_box.html#matplotlib.artist.Artist.set_clip_box" title="matplotlib.artist.Artist.set_clip_box"><code>clip_box</code></a></p></td> <td><p><a class="reference internal" href="../transformations.html#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_clip_on.html#matplotlib.artist.Artist.set_clip_on" title="matplotlib.artist.Artist.set_clip_on"><code>clip_on</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_clip_path.html#matplotlib.artist.Artist.set_clip_path" title="matplotlib.artist.Artist.set_clip_path"><code>clip_path</code></a></p></td> <td><p>Patch or (Path, Transform) or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../cm_api.html#matplotlib.cm.ScalarMappable.set_cmap" title="matplotlib.cm.ScalarMappable.set_cmap"><code>cmap</code></a></p></td> <td><p><a class="reference internal" href="matplotlib.colors.colormap.html#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>Colormap</code></a> or str or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_color" title="matplotlib.collections.Collection.set_color"><code>color</code></a></p></td> <td><p>color or list of RGBA tuples</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>edgecolor</code></a> or ec or edgecolors</p></td> <td><p>color or list of colors or 'face'</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_facecolor" title="matplotlib.collections.Collection.set_facecolor"><code>facecolor</code></a> or facecolors or fc</p></td> <td><p>color or list of colors</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_figure.html#matplotlib.artist.Artist.set_figure" title="matplotlib.artist.Artist.set_figure"><code>figure</code></a></p></td> <td><p><a class="reference internal" href="../figure_api.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_gid.html#matplotlib.artist.Artist.set_gid" title="matplotlib.artist.Artist.set_gid"><code>gid</code></a></p></td> <td><p>str</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_hatch" title="matplotlib.collections.Collection.set_hatch"><code>hatch</code></a></p></td> <td><p>{'/', '\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_in_layout.html#matplotlib.artist.Artist.set_in_layout" title="matplotlib.artist.Artist.set_in_layout"><code>in_layout</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_joinstyle" title="matplotlib.collections.Collection.set_joinstyle"><code>joinstyle</code></a></p></td> <td><p><a class="reference internal" href="../_enums_api.html#matplotlib._enums.JoinStyle" title="matplotlib._enums.JoinStyle"><code>JoinStyle</code></a> or {'miter', 'round', 'bevel'}</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_label.html#matplotlib.artist.Artist.set_label" title="matplotlib.artist.Artist.set_label"><code>label</code></a></p></td> <td><p>object</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_linestyle" title="matplotlib.collections.Collection.set_linestyle"><code>linestyle</code></a> or dashes or linestyles or ls</p></td> <td><p>str or tuple or list thereof</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_linewidth" title="matplotlib.collections.Collection.set_linewidth"><code>linewidth</code></a> or linewidths or lw</p></td> <td><p>float or list of floats</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_mouseover.html#matplotlib.artist.Artist.set_mouseover" title="matplotlib.artist.Artist.set_mouseover"><code>mouseover</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../cm_api.html#matplotlib.cm.ScalarMappable.set_norm" title="matplotlib.cm.ScalarMappable.set_norm"><code>norm</code></a></p></td> <td><p><a class="reference internal" href="matplotlib.colors.normalize.html#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> or str or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_offset_transform" title="matplotlib.collections.Collection.set_offset_transform"><code>offset_transform</code></a> or transOffset</p></td> <td><p>unknown</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_offsets" title="matplotlib.collections.Collection.set_offsets"><code>offsets</code></a></p></td> <td><p>(N, 2) or (2,) array-like</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_path_effects.html#matplotlib.artist.Artist.set_path_effects" title="matplotlib.artist.Artist.set_path_effects"><code>path_effects</code></a></p></td> <td><p><a class="reference internal" href="../patheffects_api.html#matplotlib.patheffects.AbstractPathEffect" title="matplotlib.patheffects.AbstractPathEffect"><code>AbstractPathEffect</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.PolyCollection.set_verts" title="matplotlib.collections.PolyCollection.set_verts"><code>paths</code></a></p></td> <td><p>list of array-like</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_picker.html#matplotlib.artist.Artist.set_picker" title="matplotlib.artist.Artist.set_picker"><code>picker</code></a></p></td> <td><p>None or bool or float or callable</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_pickradius" title="matplotlib.collections.Collection.set_pickradius"><code>pickradius</code></a></p></td> <td><p>unknown</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_rasterized.html#matplotlib.artist.Artist.set_rasterized" title="matplotlib.artist.Artist.set_rasterized"><code>rasterized</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><code>sizes</code></p></td> <td><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><code>numpy.ndarray</code></a> or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_sketch_params.html#matplotlib.artist.Artist.set_sketch_params" title="matplotlib.artist.Artist.set_sketch_params"><code>sketch_params</code></a></p></td> <td><p>(scale: float, length: float, randomness: float)</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_snap.html#matplotlib.artist.Artist.set_snap" title="matplotlib.artist.Artist.set_snap"><code>snap</code></a></p></td> <td><p>bool or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_transform.html#matplotlib.artist.Artist.set_transform" title="matplotlib.artist.Artist.set_transform"><code>transform</code></a></p></td> <td><p><a class="reference internal" href="../transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_url.html#matplotlib.artist.Artist.set_url" title="matplotlib.artist.Artist.set_url"><code>url</code></a></p></td> <td><p>str</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_urls" title="matplotlib.collections.Collection.set_urls"><code>urls</code></a></p></td> <td><p>list of str or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.PolyCollection.set_verts" title="matplotlib.collections.PolyCollection.set_verts"><code>verts</code></a></p></td> <td><p>list of array-like</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.PolyCollection.set_verts_and_codes" title="matplotlib.collections.PolyCollection.set_verts_and_codes"><code>verts_and_codes</code></a></p></td> <td><p>unknown</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_visible.html#matplotlib.artist.Artist.set_visible" title="matplotlib.artist.Artist.set_visible"><code>visible</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_zorder.html#matplotlib.artist.Artist.set_zorder" title="matplotlib.artist.Artist.set_zorder"><code>zorder</code></a></p></td> <td><p>float</p></td> </tr>  </table> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="matplotlib.axes.axes.quiverkey.html#matplotlib.axes.Axes.quiverkey" title="matplotlib.axes.Axes.quiverkey"><code>Axes.quiverkey</code></a></dt>
<dd>
<p>Add a key to a quiver plot.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p><strong>Arrow shape</strong></p> <p>The arrow is drawn as a polygon using the nodes as shown below. The values <em>headwidth</em>, <em>headlength</em>, and <em>headaxislength</em> are in units of <em>width</em>.</p> <a class="reference internal image-reference" href="https://matplotlib.org/stable/_images/quiver_sizes.svg"><img alt="../../_images/quiver_sizes.svg" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMTI0LjYwOTgzbW0iCiAgIGhlaWdodD0iNjYuNjQ5NzQybW0iCiAgIHZpZXdCb3g9IjAgMCAxMjQuNjA5ODQgNjYuNjQ5NzQyIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmc4IgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjkyLjQgKDVkYTY4OWMzMTMsIDIwMTktMDEtMTQpIgogICBzb2RpcG9kaTpkb2NuYW1lPSJxdWl2ZXJfc2l6ZXMuc3ZnIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzMiIgLz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMi44IgogICAgIGlua3NjYXBlOmN4PSIyMDYuNjIxOTgiCiAgICAgaW5rc2NhcGU6Y3k9IjE4Mi41MzQ4MiIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0ibW0iCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBmaXQtbWFyZ2luLXRvcD0iNCIKICAgICBmaXQtbWFyZ2luLWJvdHRvbT0iNCIKICAgICBmaXQtbWFyZ2luLXJpZ2h0PSIxIgogICAgIGZpdC1tYXJnaW4tbGVmdD0iMSIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjI4NDIiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTMwNyIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMzI2IgogICAgIGlua3NjYXBlOndpbmRvdy15PSI4OCIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIwIiAvPgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTUiPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkViZW5lIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIgogICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yNi40ODk1LC0xNS4xMDAwNDMpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojYTlhOWE5O2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjI2NDU4MzMycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNDkuMjQ3NzY5LDI5Ljg5ODA2NyBoIDU1LjAwMDAwMSBsIC01LjAwMDAwMiwtMTAgNTAuMDAwMDAyLDE1IC01MC4wMDAwMDIsMTUgNS4wMDAwMDIsLTEwIEggNDkuMjQ3NzY5IFoiCiAgICAgICBpZD0icGF0aDgzMCIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjY2NjY2NjIiAvPgogICAgPHRleHQKICAgICAgIHhtbDpzcGFjZT0icHJlc2VydmUiCiAgICAgICBzdHlsZT0iZm9udC1zdHlsZTpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZTo1LjY0NDQ0NDQ3cHg7bGluZS1oZWlnaHQ6MS4yNTtmb250LWZhbWlseTpzYW5zLXNlcmlmO2xldHRlci1zcGFjaW5nOjBweDt3b3JkLXNwYWNpbmc6MHB4O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MC4yNjQ1ODMzMiIKICAgICAgIHg9IjI3LjQ5Nzc2OCIKICAgICAgIHk9IjM2Ljc2MzM5MyIKICAgICAgIGlkPSJ0ZXh0ODM0Ij48dHNwYW4KICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgaWQ9InRzcGFuODMyIgogICAgICAgICB4PSIyNy40OTc3NjgiCiAgICAgICAgIHk9IjM2Ljc2MzM5MyIKICAgICAgICAgc3R5bGU9ImZvbnQtc2l6ZTo1LjY0NDQ0NDQ3cHg7c3Ryb2tlLXdpZHRoOjAuMjY0NTgzMzIiPndpZHRoPC90c3Bhbj48L3RleHQ+CiAgICA8ZwogICAgICAgaWQ9ImcxMTU3IgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNzg2ODI5MywwLjEzNDQ5MDY4KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIGlkPSJwYXRoODM2IgogICAgICAgICBkPSJNIDQzLjM5NjM5MiwzOC4wMTY3NjcgViAzMS4zNzg4OTQiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuNjAwMDAwMDI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIgLz4KICAgICAgPHBhdGgKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMS40Nzg4NzMxLC0wLjMzMDcyODgxLC01NS41MTUwNzcpIgogICAgICAgICBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXk9Ii0wLjIyOTA5ODYiCiAgICAgICAgIGQ9Im0gNDQuNTIwNzM2LDU5LjA5MjAzIC0wLjc5MzYxNywwIC0wLjc5MzYxNiwwIDAuMzk2ODA4LC0wLjY4NzI5MyAwLjM5NjgwOCwtMC42ODcyOTIgMC4zOTY4MDksMC42ODcyOTIgeiIKICAgICAgICAgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIKICAgICAgICAgaW5rc2NhcGU6cm91bmRlZD0iMCIKICAgICAgICAgaW5rc2NhcGU6ZmxhdHNpZGVkPSJmYWxzZSIKICAgICAgICAgc29kaXBvZGk6YXJnMj0iMS41NzA3OTYzIgogICAgICAgICBzb2RpcG9kaTphcmcxPSIwLjUyMzU5ODc4IgogICAgICAgICBzb2RpcG9kaTpyMj0iMC40NTgxOTQ3NiIKICAgICAgICAgc29kaXBvZGk6cjE9IjAuOTE2Mzg5NTIiCiAgICAgICAgIHNvZGlwb2RpOmN5PSI1OC42MzM4MzUiCiAgICAgICAgIHNvZGlwb2RpOmN4PSI0My43MjcxMTkiCiAgICAgICAgIHNvZGlwb2RpOnNpZGVzPSIzIgogICAgICAgICBpZD0icGF0aDgzOCIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MC40Nzg3NzQ1NTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjU4NTgyMDkzIgogICAgICAgICBzb2RpcG9kaTp0eXBlPSJzdGFyIiAvPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXg9IjEuMTg3Njk5ZS0wNiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC41LC0xLjI4MDc0MTcsMC44NjYwMjU0LDAuNzM5NDM2NTUsLTI5Ljg0ODk4NCw1MS42Mjk0NzkpIgogICAgICAgICBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXk9IjAuMjI5MDk2OTMiCiAgICAgICAgIGQ9Im0gNDUuMTU4NTczLDU5LjQyMDU1MSAtMC43OTM2MTcsMCAtMC43OTM2MTcsMCAwLjM5NjgwOSwtMC42ODcyOTIgMC4zOTY4MDgsLTAuNjg3MjkyIDAuMzk2ODA4LDAuNjg3MjkyIHoiCiAgICAgICAgIGlua3NjYXBlOnJhbmRvbWl6ZWQ9IjAiCiAgICAgICAgIGlua3NjYXBlOnJvdW5kZWQ9IjAiCiAgICAgICAgIGlua3NjYXBlOmZsYXRzaWRlZD0iZmFsc2UiCiAgICAgICAgIHNvZGlwb2RpOmFyZzI9IjEuNTcwNzk2MyIKICAgICAgICAgc29kaXBvZGk6YXJnMT0iMC41MjM1OTg3OCIKICAgICAgICAgc29kaXBvZGk6cjI9IjAuNDU4MTk0NzkiCiAgICAgICAgIHNvZGlwb2RpOnIxPSIwLjkxNjM4OTUyIgogICAgICAgICBzb2RpcG9kaTpjeT0iNTguOTYyMzU3IgogICAgICAgICBzb2RpcG9kaTpjeD0iNDQuMzY0OTU2IgogICAgICAgICBzb2RpcG9kaTpzaWRlcz0iMyIKICAgICAgICAgaWQ9InBhdGg4MzgtMyIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MC40Nzg3NzQ1NTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjU4NTgyMDkzIgogICAgICAgICBzb2RpcG9kaTp0eXBlPSJzdGFyIiAvPgogICAgPC9nPgogICAgPGcKICAgICAgIGlkPSJnODYwLTgiCiAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLDEsLTEuNDc4ODczMSwwLDIzNC42MDQ1NSwxMS45MzUwODEpIj4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGg4MzYtNyIKICAgICAgICAgZD0iTSA0My43MjcxMjEsODYuOTU5MDMzIFYgNTguNzU2ODgzIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjQ5MzM4NDg0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOnRyYW5zZm9ybS1jZW50ZXIteT0iLTAuMjI5MDk4NiIKICAgICAgICAgZD0ibSA0NC41MjA3MzYsNTkuMDkyMDMgLTAuNzkzNjE3LDAgLTAuNzkzNjE2LDAgMC4zOTY4MDgsLTAuNjg3MjkzIDAuMzk2ODA4LC0wLjY4NzI5MiAwLjM5NjgwOSwwLjY4NzI5MiB6IgogICAgICAgICBpbmtzY2FwZTpyYW5kb21pemVkPSIwIgogICAgICAgICBpbmtzY2FwZTpyb3VuZGVkPSIwIgogICAgICAgICBpbmtzY2FwZTpmbGF0c2lkZWQ9ImZhbHNlIgogICAgICAgICBzb2RpcG9kaTphcmcyPSIxLjU3MDc5NjMiCiAgICAgICAgIHNvZGlwb2RpOmFyZzE9IjAuNTIzNTk4NzgiCiAgICAgICAgIHNvZGlwb2RpOnIyPSIwLjQ1ODE5NDc2IgogICAgICAgICBzb2RpcG9kaTpyMT0iMC45MTYzODk1MiIKICAgICAgICAgc29kaXBvZGk6Y3k9IjU4LjYzMzgzNSIKICAgICAgICAgc29kaXBvZGk6Y3g9IjQzLjcyNzExOSIKICAgICAgICAgc29kaXBvZGk6c2lkZXM9IjMiCiAgICAgICAgIGlkPSJwYXRoODM4LTkiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjAuNDc4Nzc0NTU7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MC41ODU4MjA5MyIKICAgICAgICAgc29kaXBvZGk6dHlwZT0ic3RhciIgLz4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci14PSIxLjE4NzY5OWUtMDYiCiAgICAgICAgIHRyYW5zZm9ybT0icm90YXRlKC02MCw2OC40NTg2ODEsNzMuNjA5MzgxKSIKICAgICAgICAgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSIwLjIyOTA5NjkzIgogICAgICAgICBkPSJtIDQ1LjE1ODU3Myw1OS40MjA1NTEgLTAuNzkzNjE3LDAgLTAuNzkzNjE3LDAgMC4zOTY4MDksLTAuNjg3MjkyIDAuMzk2ODA4LC0wLjY4NzI5MiAwLjM5NjgwOCwwLjY4NzI5MiB6IgogICAgICAgICBpbmtzY2FwZTpyYW5kb21pemVkPSIwIgogICAgICAgICBpbmtzY2FwZTpyb3VuZGVkPSIwIgogICAgICAgICBpbmtzY2FwZTpmbGF0c2lkZWQ9ImZhbHNlIgogICAgICAgICBzb2RpcG9kaTphcmcyPSIxLjU3MDc5NjMiCiAgICAgICAgIHNvZGlwb2RpOmFyZzE9IjAuNTIzNTk4NzgiCiAgICAgICAgIHNvZGlwb2RpOnIyPSIwLjQ1ODE5NDc5IgogICAgICAgICBzb2RpcG9kaTpyMT0iMC45MTYzODk1MiIKICAgICAgICAgc29kaXBvZGk6Y3k9IjU4Ljk2MjM1NyIKICAgICAgICAgc29kaXBvZGk6Y3g9IjQ0LjM2NDk1NiIKICAgICAgICAgc29kaXBvZGk6c2lkZXM9IjMiCiAgICAgICAgIGlkPSJwYXRoODM4LTMtMiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MC40Nzg3NzQ1NTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjU4NTgyMDkzIgogICAgICAgICBzb2RpcG9kaTp0eXBlPSJzdGFyIiAvPgogICAgPC9nPgogICAgPGcKICAgICAgIGlkPSJnODYwLTgtMCIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsMSwtMS40Njc3MzI4LDAsMjMzLjc3ODE1LDE2LjI4MTgwOCkiCiAgICAgICBzdHlsZT0ic3Ryb2tlLXdpZHRoOjEuMDAzNzg3ODgiPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBpZD0icGF0aDgzNi03LTIiCiAgICAgICAgIGQ9Ik0gNDMuNzI3MTIxLDkwLjY4ODE4MiBWIDU4Ljc1Njg4MSIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC40OTUyNTM3MTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIiAvPgogICAgICA8cGF0aAogICAgICAgICBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXk9Ii0wLjIyOTA5ODYiCiAgICAgICAgIGQ9Im0gNDQuNTIwNzM2LDU5LjA5MjAzIC0wLjc5MzYxNywwIC0wLjc5MzYxNiwwIDAuMzk2ODA4LC0wLjY4NzI5MyAwLjM5NjgwOCwtMC42ODcyOTIgMC4zOTY4MDksMC42ODcyOTIgeiIKICAgICAgICAgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIKICAgICAgICAgaW5rc2NhcGU6cm91bmRlZD0iMCIKICAgICAgICAgaW5rc2NhcGU6ZmxhdHNpZGVkPSJmYWxzZSIKICAgICAgICAgc29kaXBvZGk6YXJnMj0iMS41NzA3OTYzIgogICAgICAgICBzb2RpcG9kaTphcmcxPSIwLjUyMzU5ODc4IgogICAgICAgICBzb2RpcG9kaTpyMj0iMC40NTgxOTQ3NiIKICAgICAgICAgc29kaXBvZGk6cjE9IjAuOTE2Mzg5NTIiCiAgICAgICAgIHNvZGlwb2RpOmN5PSI1OC42MzM4MzUiCiAgICAgICAgIHNvZGlwb2RpOmN4PSI0My43MjcxMTkiCiAgICAgICAgIHNvZGlwb2RpOnNpZGVzPSIzIgogICAgICAgICBpZD0icGF0aDgzOC05LTMiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjAuNDgwNTg4MTE7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MC41ODU4MjA5MyIKICAgICAgICAgc29kaXBvZGk6dHlwZT0ic3RhciIgLz4KICAgICAgPHBhdGgKICAgICAgICAgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci14PSIxLjE4NzY5OWUtMDYiCiAgICAgICAgIHRyYW5zZm9ybT0icm90YXRlKC02MCw3MS41NTc0NzEsNzUuMzk4NDcxKSIKICAgICAgICAgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSIwLjIyOTA5NjkzIgogICAgICAgICBkPSJtIDQ1LjE1ODU3Myw1OS40MjA1NTEgLTAuNzkzNjE3LDAgLTAuNzkzNjE3LDAgMC4zOTY4MDksLTAuNjg3MjkyIDAuMzk2ODA4LC0wLjY4NzI5MiAwLjM5NjgwOCwwLjY4NzI5MiB6IgogICAgICAgICBpbmtzY2FwZTpyYW5kb21pemVkPSIwIgogICAgICAgICBpbmtzY2FwZTpyb3VuZGVkPSIwIgogICAgICAgICBpbmtzY2FwZTpmbGF0c2lkZWQ9ImZhbHNlIgogICAgICAgICBzb2RpcG9kaTphcmcyPSIxLjU3MDc5NjMiCiAgICAgICAgIHNvZGlwb2RpOmFyZzE9IjAuNTIzNTk4NzgiCiAgICAgICAgIHNvZGlwb2RpOnIyPSIwLjQ1ODE5NDc5IgogICAgICAgICBzb2RpcG9kaTpyMT0iMC45MTYzODk1MiIKICAgICAgICAgc29kaXBvZGk6Y3k9IjU4Ljk2MjM1NyIKICAgICAgICAgc29kaXBvZGk6Y3g9IjQ0LjM2NDk1NiIKICAgICAgICAgc29kaXBvZGk6c2lkZXM9IjMiCiAgICAgICAgIGlkPSJwYXRoODM4LTMtMi03IgogICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjQ4MDU4ODExO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjAuNTg1ODIwOTMiCiAgICAgICAgIHNvZGlwb2RpOnR5cGU9InN0YXIiIC8+CiAgICA8L2c+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4yNjQ1ODMzMjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6MS4wNTgzMzMyNywgMC41MjkxNjY2MztzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDk5LjI0Nzc2Niw0OS44OTgwNjcgViA2MS44MDQzMTQiCiAgICAgICBpZD0icGF0aDEwNDEiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjY0NTgzMzI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5OjEuMDU4MzMzMjcsIDAuNTI5MTY2NjI7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAxMDQuMjQ3NzcsMzkuODk4MDY2IFYgNTYuNzE4MDAzIgogICAgICAgaWQ9InBhdGgxMDQxLTUiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjY0NTgzMzI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5OjEuMDU4MzMzMjYsIDAuNTI5MTY2NjI7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAxNDkuMjQ3NzcsMzQuODk4MDY1IFYgNzEuOTA1OTgyIgogICAgICAgaWQ9InBhdGgxMDQxLTUtOSIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8dGV4dAogICAgICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgICAgIHN0eWxlPSJmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjcuMDU1NTU1MzRweDtsaW5lLWhlaWdodDoxLjI1O2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7bGV0dGVyLXNwYWNpbmc6MHB4O3dvcmQtc3BhY2luZzowcHg7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjI2NDU4MzMyIgogICAgICAgeD0iMTA4LjAzNDAxIgogICAgICAgeT0iNTIuOTg2ODM1IgogICAgICAgaWQ9InRleHQ4MzQtMiI+PHRzcGFuCiAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgIGlkPSJ0c3BhbjgzMi0yIgogICAgICAgICB4PSIxMDguMDM0MDEiCiAgICAgICAgIHk9IjUyLjk4NjgzNSIKICAgICAgICAgc3R5bGU9ImZvbnQtc2l6ZTo1LjY0NDQ0NDQ3cHg7c3Ryb2tlLXdpZHRoOjAuMjY0NTgzMzIiPmhlYWRheGlzbGVuZ3RoPC90c3Bhbj48L3RleHQ+CiAgICA8dGV4dAogICAgICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgICAgIHN0eWxlPSJmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjcuMDU1NTU1MzRweDtsaW5lLWhlaWdodDoxLjI1O2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7bGV0dGVyLXNwYWNpbmc6MHB4O3dvcmQtc3BhY2luZzowcHg7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjI2NDU4MzMyIgogICAgICAgeD0iMTExLjM5MDM3IgogICAgICAgeT0iNjUuODE1MDAyIgogICAgICAgaWQ9InRleHQ4MzQtMi04Ij48dHNwYW4KICAgICAgICAgc29kaXBvZGk6cm9sZT0ibGluZSIKICAgICAgICAgaWQ9InRzcGFuODMyLTItOSIKICAgICAgICAgeD0iMTExLjM5MDM3IgogICAgICAgICB5PSI2NS44MTUwMDIiCiAgICAgICAgIHN0eWxlPSJmb250LXNpemU6NS42NDQ0NDQ0N3B4O3N0cm9rZS13aWR0aDowLjI2NDU4MzMyIj5oZWFkbGVuZ3RoPC90c3Bhbj48L3RleHQ+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4yNjQ1ODMzMjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6MS4wNTgzMzMyMywgMC41MjkxNjY2MjtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDQ5LjI0Nzc2NywzOS44OTgwNjYgaCAtNy4wMTYxOCIKICAgICAgIGlkPSJwYXRoMTA0MS03IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjI2NDU4MzMyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheToxLjA1ODMzMzI0LCAwLjUyOTE2NjYzO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNDkuMjQ3NzY5LDI5Ljg5ODA2NyBoIC03LjAxNjE4IgogICAgICAgaWQ9InBhdGgxMDQxLTctNiIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcxMTU3LTEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0OS4yMTMxNzIsMTAuMTM0NDkxKSI+CiAgICAgIDxnCiAgICAgICAgIGlkPSJnMTE5MiI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjYwMDAwMDAyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgICAgZD0iTSA0My4zOTYzOTMsMzguMDE2NzcxIFYgMTEuNTAwNzI2IgogICAgICAgICAgIGlkPSJwYXRoODM2LTIiCiAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgICAgICA8cGF0aAogICAgICAgICAgIHNvZGlwb2RpOnR5cGU9InN0YXIiCiAgICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MC40Nzg3NzQ1NTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjU4NTgyMDkzIgogICAgICAgICAgIGlkPSJwYXRoODM4LTkzIgogICAgICAgICAgIHNvZGlwb2RpOnNpZGVzPSIzIgogICAgICAgICAgIHNvZGlwb2RpOmN4PSI0My43MjcxMTkiCiAgICAgICAgICAgc29kaXBvZGk6Y3k9IjU4LjYzMzgzNSIKICAgICAgICAgICBzb2RpcG9kaTpyMT0iMC45MTYzODk1MiIKICAgICAgICAgICBzb2RpcG9kaTpyMj0iMC40NTgxOTQ3NiIKICAgICAgICAgICBzb2RpcG9kaTphcmcxPSIwLjUyMzU5ODc4IgogICAgICAgICAgIHNvZGlwb2RpOmFyZzI9IjEuNTcwNzk2MyIKICAgICAgICAgICBpbmtzY2FwZTpmbGF0c2lkZWQ9ImZhbHNlIgogICAgICAgICAgIGlua3NjYXBlOnJvdW5kZWQ9IjAiCiAgICAgICAgICAgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIKICAgICAgICAgICBkPSJtIDQ0LjUyMDczNiw1OS4wOTIwMyAtMC43OTM2MTcsMCAtMC43OTM2MTYsMCAwLjM5NjgwOCwtMC42ODcyOTMgMC4zOTY4MDgsLTAuNjg3MjkyIDAuMzk2ODA5LDAuNjg3MjkyIHoiCiAgICAgICAgICAgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSItMC4yMjkwOTg2IgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEuNDc4ODczMSwtMC4zMzA3Mjg4MSwtNzUuNTQ3ODE1KSIgLz4KICAgICAgICA8cGF0aAogICAgICAgICAgIHNvZGlwb2RpOnR5cGU9InN0YXIiCiAgICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MC40Nzg3NzQ1NTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjU4NTgyMDkzIgogICAgICAgICAgIGlkPSJwYXRoODM4LTMtMSIKICAgICAgICAgICBzb2RpcG9kaTpzaWRlcz0iMyIKICAgICAgICAgICBzb2RpcG9kaTpjeD0iNDQuMzY0OTU2IgogICAgICAgICAgIHNvZGlwb2RpOmN5PSI1OC45NjIzNTciCiAgICAgICAgICAgc29kaXBvZGk6cjE9IjAuOTE2Mzg5NTIiCiAgICAgICAgICAgc29kaXBvZGk6cjI9IjAuNDU4MTk0NzkiCiAgICAgICAgICAgc29kaXBvZGk6YXJnMT0iMC41MjM1OTg3OCIKICAgICAgICAgICBzb2RpcG9kaTphcmcyPSIxLjU3MDc5NjMiCiAgICAgICAgICAgaW5rc2NhcGU6ZmxhdHNpZGVkPSJmYWxzZSIKICAgICAgICAgICBpbmtzY2FwZTpyb3VuZGVkPSIwIgogICAgICAgICAgIGlua3NjYXBlOnJhbmRvbWl6ZWQ9IjAiCiAgICAgICAgICAgZD0ibSA0NS4xNTg1NzMsNTkuNDIwNTUxIC0wLjc5MzYxNywwIC0wLjc5MzYxNywwIDAuMzk2ODA5LC0wLjY4NzI5MiAwLjM5NjgwOCwtMC42ODcyOTIgMC4zOTY4MDgsMC42ODcyOTIgeiIKICAgICAgICAgICBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXk9IjAuMjI5MDk2OTMiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC41LC0xLjI4MDc0MTcsMC44NjYwMjU0LDAuNzM5NDM2NTUsLTI5Ljg0ODk4NCw1MS42Mjk0NzkpIgogICAgICAgICAgIGlua3NjYXBlOnRyYW5zZm9ybS1jZW50ZXIteD0iMS4xODc2OTllLTA2IiAvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4yNjQ1ODMzMjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6MS4wNTgzMzMyNCwgMC41MjkxNjY2MztzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDk5LjI0Nzc2OCw0OS44OTgwNjcgSCA5Mi4yMzE1ODkiCiAgICAgICBpZD0icGF0aDEwNDEtNy05IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjI2NDU4MzMyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheToxLjA1ODMzMzI1LCAwLjUyOTE2NjYzO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gOTkuMjQ3NzY4LDE5Ljg5ODA2NyBoIC03LjAxNjE4IgogICAgICAgaWQ9InBhdGgxMDQxLTctNi00IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDx0ZXh0CiAgICAgICB4bWw6c3BhY2U9InByZXNlcnZlIgogICAgICAgc3R5bGU9ImZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6NS42NDQ0NDQ0N3B4O2xpbmUtaGVpZ2h0OjEuMjU7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjtsZXR0ZXItc3BhY2luZzowcHg7d29yZC1zcGFjaW5nOjBweDtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjAuMjY0NTgzMzIiCiAgICAgICB4PSI2My44OTk4MjIiCiAgICAgICB5PSIyNi42ODU2IgogICAgICAgaWQ9InRleHQ4MzQtNyI+PHRzcGFuCiAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgIGlkPSJ0c3BhbjgzMi04IgogICAgICAgICB4PSI2My44OTk4MjIiCiAgICAgICAgIHk9IjI2LjY4NTYiCiAgICAgICAgIHN0eWxlPSJmb250LXNpemU6NS42NDQ0NDQ0N3B4O3N0cm9rZS13aWR0aDowLjI2NDU4MzMyIj5oZWFkd2lkdGg8L3RzcGFuPjwvdGV4dD4KICAgIDxnCiAgICAgICBpZD0iZzg2MC04LTAtNCIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAsMSwtMS40Njc3MzI4LDAsMjMzLjc3ODE1LDI3LjAyMTcwNCkiCiAgICAgICBzdHlsZT0ic3Ryb2tlLXdpZHRoOjEuMDAzNzg3ODgiPgogICAgICA8ZwogICAgICAgICBpZD0iZzEyNTQiPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC40OTUyNTM3MTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICAgIGQ9Ik0gNDMuNzI3MTIxLDEyNC41Nzc3NSBWIDU4Ljc1Njg3OSIKICAgICAgICAgICBpZD0icGF0aDgzNi03LTItNSIKICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgc29kaXBvZGk6dHlwZT0ic3RhciIKICAgICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjQ4MDU4ODExO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjAuNTg1ODIwOTMiCiAgICAgICAgICAgaWQ9InBhdGg4MzgtOS0zLTAiCiAgICAgICAgICAgc29kaXBvZGk6c2lkZXM9IjMiCiAgICAgICAgICAgc29kaXBvZGk6Y3g9IjQzLjcyNzExOSIKICAgICAgICAgICBzb2RpcG9kaTpjeT0iNTguNjMzODM1IgogICAgICAgICAgIHNvZGlwb2RpOnIxPSIwLjkxNjM4OTUyIgogICAgICAgICAgIHNvZGlwb2RpOnIyPSIwLjQ1ODE5NDc2IgogICAgICAgICAgIHNvZGlwb2RpOmFyZzE9IjAuNTIzNTk4NzgiCiAgICAgICAgICAgc29kaXBvZGk6YXJnMj0iMS41NzA3OTYzIgogICAgICAgICAgIGlua3NjYXBlOmZsYXRzaWRlZD0iZmFsc2UiCiAgICAgICAgICAgaW5rc2NhcGU6cm91bmRlZD0iMCIKICAgICAgICAgICBpbmtzY2FwZTpyYW5kb21pemVkPSIwIgogICAgICAgICAgIGQ9Im0gNDQuNTIwNzM2LDU5LjA5MjAzIC0wLjc5MzYxNywwIC0wLjc5MzYxNiwwIDAuMzk2ODA4LC0wLjY4NzI5MyAwLjM5NjgwOCwtMC42ODcyOTIgMC4zOTY4MDksMC42ODcyOTIgeiIKICAgICAgICAgICBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXk9Ii0wLjIyOTA5ODYiIC8+CiAgICAgICAgPHBhdGgKICAgICAgICAgICBzb2RpcG9kaTp0eXBlPSJzdGFyIgogICAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjAuNDgwNTg4MTE7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MC41ODU4MjA5MyIKICAgICAgICAgICBpZD0icGF0aDgzOC0zLTItNy0zIgogICAgICAgICAgIHNvZGlwb2RpOnNpZGVzPSIzIgogICAgICAgICAgIHNvZGlwb2RpOmN4PSI0NC4zNjQ5NTYiCiAgICAgICAgICAgc29kaXBvZGk6Y3k9IjU4Ljk2MjM1NyIKICAgICAgICAgICBzb2RpcG9kaTpyMT0iMC45MTYzODk1MiIKICAgICAgICAgICBzb2RpcG9kaTpyMj0iMC40NTgxOTQ3OSIKICAgICAgICAgICBzb2RpcG9kaTphcmcxPSIwLjUyMzU5ODc4IgogICAgICAgICAgIHNvZGlwb2RpOmFyZzI9IjEuNTcwNzk2MyIKICAgICAgICAgICBpbmtzY2FwZTpmbGF0c2lkZWQ9ImZhbHNlIgogICAgICAgICAgIGlua3NjYXBlOnJvdW5kZWQ9IjAiCiAgICAgICAgICAgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIKICAgICAgICAgICBkPSJtIDQ1LjE1ODU3Myw1OS40MjA1NTEgLTAuNzkzNjE3LDAgLTAuNzkzNjE3LDAgMC4zOTY4MDksLTAuNjg3MjkyIDAuMzk2ODA4LC0wLjY4NzI5MiAwLjM5NjgwOCwwLjY4NzI5MiB6IgogICAgICAgICAgIGlua3NjYXBlOnRyYW5zZm9ybS1jZW50ZXIteT0iMC4yMjkwOTY5MyIKICAgICAgICAgICB0cmFuc2Zvcm09InJvdGF0ZSgtNjAsMTAwLjk5NjQsOTIuMzk1MDQ1KSIKICAgICAgICAgICBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXg9IjEuMTg3Njk5ZS0wNiIgLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjY0NTgzMzU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5OjEuMDU4MzMzMjksIDAuNTI5MTY2NjM7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSA0OS4yNDc3NjQsMzkuODk4MDY3IFYgNzIuMzA5NTIzIgogICAgICAgaWQ9InBhdGgxMDQxLTYiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPHRleHQKICAgICAgIHhtbDpzcGFjZT0icHJlc2VydmUiCiAgICAgICBzdHlsZT0iZm9udC1zdHlsZTpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZTo1LjY0NDQ0NDQ3cHg7bGluZS1oZWlnaHQ6MS4yNTtmb250LWZhbWlseTpzYW5zLXNlcmlmO2xldHRlci1zcGFjaW5nOjBweDt3b3JkLXNwYWNpbmc6MHB4O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MC4yNjQ1ODMzMiIKICAgICAgIHg9IjkzLjIyOTQwOCIKICAgICAgIHk9Ijc2LjU3ODQ1MyIKICAgICAgIGlkPSJ0ZXh0ODM0LTctMSI+PHRzcGFuCiAgICAgICAgIHNvZGlwb2RpOnJvbGU9ImxpbmUiCiAgICAgICAgIGlkPSJ0c3BhbjgzMi04LTAiCiAgICAgICAgIHg9IjkzLjIyOTQwOCIKICAgICAgICAgeT0iNzYuNTc4NDUzIgogICAgICAgICBzdHlsZT0iZm9udC1zaXplOjUuNjQ0NDQ0NDdweDtzdHJva2Utd2lkdGg6MC4yNjQ1ODMzMiI+bGVuZ3RoPC90c3Bhbj48L3RleHQ+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0iZmlsbDojMTE1NTdjO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjI2NDU4MzMyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheToxLjA1ODMzMzI2LCAwLjUyOTE2NjYzO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MC41ODU4MjA5MyIKICAgICAgIGlkPSJwYXRoMTI3NCIKICAgICAgIGN4PSI0OS4yNjI1NjYiCiAgICAgICBjeT0iMjkuODk2MzYiCiAgICAgICByPSIwLjg1MDQ0NjQiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0iZmlsbDojMTE1NTdjO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjI2NDU4MzMyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheToxLjA1ODMzMzI3LCAwLjUyOTE2NjYzO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MC41ODU4MjA5MyIKICAgICAgIGlkPSJwYXRoMTI3NC02IgogICAgICAgY3g9IjQ5LjI2MjU2NiIKICAgICAgIGN5PSIzOS43NDczNjQiCiAgICAgICByPSIwLjg1MDQ0NjQiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0iZmlsbDojMTE1NTdjO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjI2NDU4MzMyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheToxLjA1ODMzMzI3LCAwLjUyOTE2NjYzO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MC41ODU4MjA5MyIKICAgICAgIGlkPSJwYXRoMTI3NC0zIgogICAgICAgY3g9Ijk5LjI1MzYxNiIKICAgICAgIGN5PSIxOS45NTA0ODkiCiAgICAgICByPSIwLjg1MDQ0NjQiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0iZmlsbDojMTE1NTdjO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjI2NDU4MzMyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheToxLjA1ODMzMzI4LCAwLjUyOTE2NjYzO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MC41ODU4MjA5MyIKICAgICAgIGlkPSJwYXRoMTI3NC0zLTIiCiAgICAgICBjeD0iOTkuMjUzNjMyIgogICAgICAgY3k9IjQ5Ljg4MDk1MSIKICAgICAgIHI9IjAuODUwNDQ2NCIgLz4KICAgIDxjaXJjbGUKICAgICAgIHN0eWxlPSJmaWxsOiMxMTU1N2M7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjAuMjY0NTgzMzI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5OjEuMDU4MzMzMjcsIDAuNTI5MTY2NjM7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eTowLjU4NTgyMDkzIgogICAgICAgaWQ9InBhdGgxMjc0LTAiCiAgICAgICBjeD0iMTA0LjE5ODExIgogICAgICAgY3k9IjI5Ljc5MTYyNiIKICAgICAgIHI9IjAuODUwNDQ2NCIgLz4KICAgIDxjaXJjbGUKICAgICAgIHN0eWxlPSJmaWxsOiMxMTU1N2M7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjAuMjY0NTgzMzI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5OjEuMDU4MzMzMjgsIDAuNTI5MTY2NjM7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eTowLjU4NTgyMDkzIgogICAgICAgaWQ9InBhdGgxMjc0LTYtNiIKICAgICAgIGN4PSIxMDQuMTk4MTEiCiAgICAgICBjeT0iMzkuNjQyNjMyIgogICAgICAgcj0iMC44NTA0NDY0IiAvPgogICAgPGNpcmNsZQogICAgICAgc3R5bGU9ImZpbGw6IzExNTU3YztmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MC4yNjQ1ODMzMjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6MS4wNTgzMzMyOCwgMC41MjkxNjY2MztzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjAuNTg1ODIwOTMiCiAgICAgICBpZD0icGF0aDEyNzQtMy0xIgogICAgICAgY3g9IjE0OS4yNDg4OSIKICAgICAgIGN5PSIzNC44Nzg0MjkiCiAgICAgICByPSIwLjg1MDQ0NjQiIC8+CiAgPC9nPgo8L3N2Zz4K" width="500px"></a> <p>The defaults give a slightly swept-back arrow. Here are some guidelines how to get other head shapes:</p> <ul class="simple"> <li>To make the head a triangle, make <em>headaxislength</em> the same as <em>headlength</em>.</li> <li>To make the arrow more pointed, reduce <em>headwidth</em> or increase <em>headlength</em> and <em>headaxislength</em>.</li> <li>To make the head smaller relative to the shaft, scale down all the head parameters proportionally.</li> <li>To remove the head completely, set all <em>head</em> parameters to 0.</li> <li>To get a diamond-shaped head, make <em>headaxislength</em> larger than <em>headlength</em>.</li> <li>Warning: For <em>headaxislength</em> &lt; (<em>headlength</em> / <em>headwidth</em>), the "headaxis" nodes (i.e. the ones connecting the head with the shaft) will protrude out of the head in forward direction so that the arrow head looks broken.</li> </ul> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2023 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.quiver.html" class="_attribution-link">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.quiver.html</a>
  </p>
</div>
