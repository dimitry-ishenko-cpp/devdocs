<h1>matplotlib.pyplot.tricontour</h1> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.pyplot.tricontour"> <span class="sig-prename descclassname">matplotlib.pyplot.</span><span class="sig-name descname">tricontour</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/pyplot.py#L3006-L3010"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw contour lines on an unstructured triangular grid.</p> <p>Call signatures:</p> <pre data-language="python">tricontour(triangulation, z, [levels], ...)
tricontour(x, y, z, [levels], *, [triangles=triangles], [mask=mask], ...)
</pre> <p>The triangular grid can be specified either by passing a <a class="reference internal" href="../tri_api.html#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a> object as the first parameter, or by passing the points <em>x</em>, <em>y</em> and optionally the <em>triangles</em> and a <em>mask</em>. See <a class="reference internal" href="../tri_api.html#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a> for an explanation of these parameters. If neither of <em>triangulation</em> or <em>triangles</em> are given, the triangulation is calculated on the fly.</p> <p>It is possible to pass <em>triangles</em> positionally, i.e. <code>tricontour(x, y, triangles, z, ...)</code>. However, this is discouraged. For more clarity, pass <em>triangles</em> via keyword argument.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>triangulation</strong><span class="classifier"><a class="reference internal" href="../tri_api.html#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a>, optional</span>
</dt>
<dd>
<p>An already created triangular grid.</p> </dd> <dt><strong>x, y, triangles, mask</strong></dt>
<dd>
<p>Parameters defining the triangular grid. See <a class="reference internal" href="../tri_api.html#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a>. This is mutually exclusive with specifying <em>triangulation</em>.</p> </dd> <dt>
<strong>z</strong><span class="classifier">array-like</span>
</dt>
<dd>
<p>The height values over which the contour is drawn. Color-mapping is controlled by <em>cmap</em>, <em>norm</em>, <em>vmin</em>, and <em>vmax</em>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>All values in <em>z</em> must be finite. Hence, nan and inf values must either be removed or <a class="reference internal" href="../tri_api.html#matplotlib.tri.Triangulation.set_mask" title="matplotlib.tri.Triangulation.set_mask"><code>set_mask</code></a> be used.</p> </div> </dd> <dt>
<strong>levels</strong><span class="classifier">int or array-like, optional</span>
</dt>
<dd>
<p>Determines the number and positions of the contour lines / regions.</p> <p>If an int <em>n</em>, use <a class="reference internal" href="../ticker_api.html#matplotlib.ticker.MaxNLocator" title="matplotlib.ticker.MaxNLocator"><code>MaxNLocator</code></a>, which tries to automatically choose no more than <em>n+1</em> "nice" contour levels between between minimum and maximum numeric values of <em>Z</em>.</p> <p>If array-like, draw contour lines at the specified levels. The values must be in increasing order.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt><a class="reference internal" href="../tri_api.html#matplotlib.tri.TriContourSet" title="matplotlib.tri.TriContourSet"><code>TriContourSet</code></a></dt>
 </dl> </dd> <dt class="field-odd">Other Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>colors</strong><span class="classifier">color string or sequence of colors, optional</span>
</dt>
<dd>
<p>The colors of the levels, i.e., the contour lines.</p> <p>The sequence is cycled for the levels in ascending order. If the sequence is shorter than the number of levels, it is repeated.</p> <p>As a shortcut, single color strings may be used in place of one-element lists, i.e. <code>'red'</code> instead of <code>['red']</code> to color all levels with the same color. This shortcut does only work for color strings, not for other ways of specifying colors.</p> <p>By default (value <em>None</em>), the colormap specified by <em>cmap</em> will be used.</p> </dd> <dt>
<strong>alpha</strong><span class="classifier">float, default: 1</span>
</dt>
<dd>
<p>The alpha blending value, between 0 (transparent) and 1 (opaque).</p> </dd> <dt>
<strong>cmap</strong><span class="classifier">str or <a class="reference internal" href="matplotlib.colors.colormap.html#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>Colormap</code></a>, default: <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=image.cmap#matplotlibrc-sample"><span class="std std-ref">rcParams["image.cmap"]</span></a></code> (default: <code>'viridis'</code>)</span>
</dt>
<dd>
<p>The Colormap instance or registered colormap name used to map scalar data to colors.</p> <p>This parameter is ignored if <em>colors</em> is set.</p> </dd> <dt>
<strong>norm</strong><span class="classifier">str or <a class="reference internal" href="matplotlib.colors.normalize.html#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a>, optional</span>
</dt>
<dd>
<p>The normalization method used to scale scalar data to the [0, 1] range before mapping to colors using <em>cmap</em>. By default, a linear scaling is used, mapping the lowest value to 0 and the highest to 1.</p> <p>If given, this can be one of the following:</p> <ul class="simple"> <li>An instance of <a class="reference internal" href="matplotlib.colors.normalize.html#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> or one of its subclasses (see <a class="reference internal" href="https://matplotlib.org/stable/tutorials/colors/colormapnorms.html"><span class="doc">Colormap Normalization</span></a>).</li> <li>A scale name, i.e. one of "linear", "log", "symlog", "logit", etc. For a list of available scales, call <a class="reference internal" href="../scale_api.html#matplotlib.scale.get_scale_names" title="matplotlib.scale.get_scale_names"><code>matplotlib.scale.get_scale_names()</code></a>. In that case, a suitable <a class="reference internal" href="matplotlib.colors.normalize.html#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> subclass is dynamically generated and instantiated.</li> </ul> <p>This parameter is ignored if <em>colors</em> is set.</p> </dd> <dt>
<strong>vmin, vmax</strong><span class="classifier">float, optional</span>
</dt>
<dd>
<p>When using scalar data and no explicit <em>norm</em>, <em>vmin</em> and <em>vmax</em> define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. It is an error to use <em>vmin</em>/<em>vmax</em> when a <em>norm</em> instance is given (but using a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><code>str</code></a> <em>norm</em> name together with <em>vmin</em>/<em>vmax</em> is acceptable).</p> <p>If <em>vmin</em> or <em>vmax</em> are not given, the default color scaling is based on <em>levels</em>.</p> <p>This parameter is ignored if <em>colors</em> is set.</p> </dd> <dt>
<strong>origin</strong><span class="classifier">{<em>None</em>, 'upper', 'lower', 'image'}, default: None</span>
</dt>
<dd>
<p>Determines the orientation and exact position of <em>z</em> by specifying the position of <code>z[0, 0]</code>. This is only relevant, if <em>X</em>, <em>Y</em> are not given.</p> <ul class="simple"> <li>
<em>None</em>: <code>z[0, 0]</code> is at X=0, Y=0 in the lower left corner.</li> <li>'lower': <code>z[0, 0]</code> is at X=0.5, Y=0.5 in the lower left corner.</li> <li>'upper': <code>z[0, 0]</code> is at X=N+0.5, Y=0.5 in the upper left corner.</li> <li>'image': Use the value from <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=image.origin#matplotlibrc-sample"><span class="std std-ref">rcParams["image.origin"]</span></a></code> (default: <code>'upper'</code>).</li> </ul> </dd> <dt>
<strong>extent</strong><span class="classifier">(x0, x1, y0, y1), optional</span>
</dt>
<dd>
<p>If <em>origin</em> is not <em>None</em>, then <em>extent</em> is interpreted as in <a class="reference internal" href="matplotlib.pyplot.imshow.html#matplotlib.pyplot.imshow" title="matplotlib.pyplot.imshow"><code>imshow</code></a>: it gives the outer pixel boundaries. In this case, the position of z[0, 0] is the center of the pixel, not a corner. If <em>origin</em> is <em>None</em>, then (<em>x0</em>, <em>y0</em>) is the position of z[0, 0], and (<em>x1</em>, <em>y1</em>) is the position of z[-1, -1].</p> <p>This argument is ignored if <em>X</em> and <em>Y</em> are specified in the call to contour.</p> </dd> <dt>
<strong>locator</strong><span class="classifier">ticker.Locator subclass, optional</span>
</dt>
<dd>
<p>The locator is used to determine the contour levels if they are not given explicitly via <em>levels</em>. Defaults to <a class="reference internal" href="../ticker_api.html#matplotlib.ticker.MaxNLocator" title="matplotlib.ticker.MaxNLocator"><code>MaxNLocator</code></a>.</p> </dd> <dt>
<strong>extend</strong><span class="classifier">{'neither', 'both', 'min', 'max'}, default: 'neither'</span>
</dt>
<dd>
<p>Determines the <code>tricontour</code>-coloring of values that are outside the <em>levels</em> range.</p> <p>If 'neither', values outside the <em>levels</em> range are not colored. If 'min', 'max' or 'both', color the values below, above or below and above the <em>levels</em> range.</p> <p>Values below <code>min(levels)</code> and above <code>max(levels)</code> are mapped to the under/over values of the <a class="reference internal" href="matplotlib.colors.colormap.html#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>Colormap</code></a>. Note that most colormaps do not have dedicated colors for these by default, so that the over and under values are the edge values of the colormap. You may want to set these values explicitly using <a class="reference internal" href="matplotlib.colors.colormap.html#matplotlib.colors.Colormap.set_under" title="matplotlib.colors.Colormap.set_under"><code>Colormap.set_under</code></a> and <a class="reference internal" href="matplotlib.colors.colormap.html#matplotlib.colors.Colormap.set_over" title="matplotlib.colors.Colormap.set_over"><code>Colormap.set_over</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>An existing <a class="reference internal" href="../tri_api.html#matplotlib.tri.TriContourSet" title="matplotlib.tri.TriContourSet"><code>TriContourSet</code></a> does not get notified if properties of its colormap are changed. Therefore, an explicit call to <a class="reference internal" href="../contour_api.html#matplotlib.contour.ContourSet.changed" title="matplotlib.contour.ContourSet.changed"><code>ContourSet.changed()</code></a> is needed after modifying the colormap. The explicit call can be left out, if a colorbar is assigned to the <a class="reference internal" href="../tri_api.html#matplotlib.tri.TriContourSet" title="matplotlib.tri.TriContourSet"><code>TriContourSet</code></a> because it internally calls <a class="reference internal" href="../contour_api.html#matplotlib.contour.ContourSet.changed" title="matplotlib.contour.ContourSet.changed"><code>ContourSet.changed()</code></a>.</p> </div> </dd> <dt>
<strong>xunits, yunits</strong><span class="classifier">registered units, optional</span>
</dt>
<dd>
<p>Override axis units by specifying an instance of a <a class="reference internal" href="../units_api.html#matplotlib.units.ConversionInterface" title="matplotlib.units.ConversionInterface"><code>matplotlib.units.ConversionInterface</code></a>.</p> </dd> <dt>
<strong>antialiased</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>Enable antialiasing, overriding the defaults. For filled contours, the default is <em>True</em>. For line contours, it is taken from <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=lines.antialiased#matplotlibrc-sample"><span class="std std-ref">rcParams["lines.antialiased"]</span></a></code> (default: <code>True</code>).</p> </dd> <dt>
<strong>linewidths</strong><span class="classifier">float or array-like, default: <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=contour.linewidth#matplotlibrc-sample"><span class="std std-ref">rcParams["contour.linewidth"]</span></a></code> (default: <code>None</code>)</span>
</dt>
<dd>
<p>The line width of the contour lines.</p> <p>If a number, all levels will be plotted with this linewidth.</p> <p>If a sequence, the levels in ascending order will be plotted with the linewidths in the order specified.</p> <p>If None, this falls back to <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=lines.linewidth#matplotlibrc-sample"><span class="std std-ref">rcParams["lines.linewidth"]</span></a></code> (default: <code>1.5</code>).</p> </dd> <dt>
<strong>linestyles</strong><span class="classifier">{<em>None</em>, 'solid', 'dashed', 'dashdot', 'dotted'}, optional</span>
</dt>
<dd>
<p>If <em>linestyles</em> is <em>None</em>, the default is 'solid' unless the lines are monochrome. In that case, negative contours will take their linestyle from <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=contour.negative_linestyle#matplotlibrc-sample"><span class="std std-ref">rcParams["contour.negative_linestyle"]</span></a></code> (default: <code>'dashed'</code>) setting.</p> <p><em>linestyles</em> can also be an iterable of the above strings specifying a set of linestyles to be used. If this iterable is shorter than the number of contour levels it will be repeated as necessary.</p> </dd> </dl> </dd> </dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2023 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.tricontour.html" class="_attribution-link">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.tricontour.html</a>
  </p>
</div>
