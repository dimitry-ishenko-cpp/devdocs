<h1> Class Query  </h1> <div class="description"> <p>This class represents a Relational database SQL Query. A query can be of different types like select, update, insert and delete. Exposes the methods for dynamically constructing each query part, execute it and transform it to a specific SQL dialect.</p> </div> <div class="info"> <b>Namespace:</b> <a href="namespace-cake.database.html">Cake\Database</a><br> </div> <div class="section"> <h2>Constants</h2> <ul class="member-summary constants"> <li class="clearfix">  <div class="attributes col-md-2 col-sm-2 p0"> <code>string</code> </div> <div class="name col-md-10 col-sm-10"> <b>JOIN_TYPE_INNER</b>   </div> <div class="col-md-10 col-md-offset-2"> <pre data-language="php">'INNER'</pre> </div>  </li> <li class="clearfix">  <div class="attributes col-md-2 col-sm-2 p0"> <code>string</code> </div> <div class="name col-md-10 col-sm-10"> <b>JOIN_TYPE_LEFT</b>   </div> <div class="col-md-10 col-md-offset-2"> <pre data-language="php">'LEFT'</pre> </div>  </li> <li class="clearfix">  <div class="attributes col-md-2 col-sm-2 p0"> <code>string</code> </div> <div class="name col-md-10 col-sm-10"> <b>JOIN_TYPE_RIGHT</b>   </div> <div class="col-md-10 col-md-offset-2"> <pre data-language="php">'RIGHT'</pre> </div>  </li> </ul> </div> <div class="section"> <h2>Property Summary</h2> <ul class="member-summary properties"> <li class="clearfix"> <div class="name"> <a href="#%24_connection">$_connection</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>Cake\Database\Connection</code></div> <div class="description"> <p>Connection instance to be used to execute this query.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_deleteParts">$_deleteParts</a> <span class="attributes"> <span class="label">protected</span> <span class="label">deprecated</span> </span> </div> <div class="property-type"><code>array&lt;string&gt;</code></div> <div class="description"> <p>The list of query clauses to traverse for generating a DELETE statement</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_dirty">$_dirty</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>bool</code></div> <div class="description"> <p>Indicates whether internal state of this query was changed, this is used to discard internal cached objects such as the transformed query or the reference to the executed statement.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_functionsBuilder">$_functionsBuilder</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>Cake\Database\FunctionsBuilder|null</code></div> <div class="description"> <p>Instance of functions builder object used for generating arbitrary SQL functions.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_insertParts">$_insertParts</a> <span class="attributes"> <span class="label">protected</span> <span class="label">deprecated</span> </span> </div> <div class="property-type"><code>array&lt;string&gt;</code></div> <div class="description"> <p>The list of query clauses to traverse for generating an INSERT statement</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_iterator">$_iterator</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>Cake\Database\StatementInterface|null</code></div> <div class="description"> <p>Statement object resulting from executing this query.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_parts">$_parts</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>array&lt;string, mixed&gt;</code></div> <div class="description"> <p>List of SQL parts that will be used to build this query.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_resultDecorators">$_resultDecorators</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>array&lt;callable&gt;</code></div> <div class="description"> <p>A list of callback functions to be called to alter each row from resulting statement upon retrieval. Each one of the callback function will receive the row array as first argument.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_selectParts">$_selectParts</a> <span class="attributes"> <span class="label">protected</span> <span class="label">deprecated</span> </span> </div> <div class="property-type"><code>array&lt;string&gt;</code></div> <div class="description"> <p>The list of query clauses to traverse for generating a SELECT statement</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_selectTypeMap">$_selectTypeMap</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>Cake\Database\TypeMap|null</code></div> <div class="description"> <p>The Type map for fields in the select clause</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_type">$_type</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>string</code></div> <div class="description"> <p>Type of this query (select, insert, update, delete).</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_typeMap">$_typeMap</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>Cake\Database\TypeMap|null</code></div>  </li> <li class="clearfix"> <div class="name"> <a href="#%24_updateParts">$_updateParts</a> <span class="attributes"> <span class="label">protected</span> <span class="label">deprecated</span> </span> </div> <div class="property-type"><code>array&lt;string&gt;</code></div> <div class="description"> <p>The list of query clauses to traverse for generating an UPDATE statement</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_useBufferedResults">$_useBufferedResults</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>bool</code></div> <div class="description"> <p>Boolean for tracking whether buffered results are enabled.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24_valueBinder">$_valueBinder</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>Cake\Database\ValueBinder|null</code></div> <div class="description"> <p>The object responsible for generating query placeholders and temporarily store values associated to each of those.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24typeCastEnabled">$typeCastEnabled</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>bool</code></div> <div class="description"> <p>Tracking flag to disable casting</p> </div> </li> </ul> </div> <div class="section"> <h2>Method Summary</h2> <ul class="member-summary"> <li class="clearfix"> <h5 class="function-name"> <a href="#__clone()">__clone()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Handles clearing iterator and cloning all expressions and value binders.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#__construct()">__construct()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Constructor.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#__debugInfo()">__debugInfo()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns an array that can be used to describe the internal state of this object.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#__toString()">__toString()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns string representation of this query (complete SQL statement).</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#_conjugate()">_conjugate()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Helper function used to build conditions by composing QueryExpression objects.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#_decorateStatement()">_decorateStatement()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Auxiliary function used to wrap the original statement from the driver with any registered callbacks.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#_dirty()">_dirty()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Marks a query as dirty, removing any preprocessed information from in memory caching.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#_expressionsVisitor()">_expressionsVisitor()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Query parts traversal method used by traverseExpressions()</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#_makeJoin()">_makeJoin()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Returns an array that can be passed to the join method describing a single join clause</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#andHaving()">andHaving()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Connects any previously defined set of conditions to the provided list using the AND operator in the HAVING clause. This method operates in exactly the same way as the method <code>andWhere()</code> does. Please refer to its documentation for an insight on how to using each parameter.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#andWhere()">andWhere()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Connects any previously defined set of conditions to the provided list using the AND operator. This function accepts the conditions list in the same format as the method <code>where</code> does, hence you can use arrays, expression objects callback functions or strings.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#bind()">bind()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Associates a query placeholder to a value and a type.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#clause()">clause()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns any data that was stored in the specified clause. This is useful for modifying any internal part of the query and it is used by the SQL dialects to transform the query accordingly before it is executed. The valid clauses that can be retrieved are: delete, update, set, insert, values, select, distinct, from, join, set, where, group, having, order, limit, offset and union.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#decorateResults()">decorateResults()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Registers a callback to be executed for each result that is fetched from the result set, the callback function will receive as first parameter an array with the raw data from the database for every row that is fetched and must return the row with any possible modifications.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#delete()">delete()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Create a delete query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#disableBufferedResults()">disableBufferedResults()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Disables buffered results.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#disableResultsCasting()">disableResultsCasting()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Disables result casting.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#distinct()">distinct()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a <code>DISTINCT</code> clause to the query to remove duplicates from the result set. This clause can only be used for select statements.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#enableBufferedResults()">enableBufferedResults()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Enables/Disables buffered results.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#enableResultsCasting()">enableResultsCasting()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Enables result casting.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#epilog()">epilog()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>A string or expression that will be appended to the generated query</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#execute()">execute()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Compiles the SQL representation of this query and executes it using the configured connection object. Returns the resulting statement object.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#expr()">expr()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new QueryExpression object. This is a handy function when building complex queries using a fluent interface. You can also override this function in subclasses to use a more specialized QueryExpression class if required.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#from()">from()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a single or multiple tables to be used in the FROM clause for this query. Tables can be passed as an array of strings, array of expression objects, a single expression or a single string.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#func()">func()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns an instance of a functions builder object that can be used for generating arbitrary SQL functions.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#getConnection()">getConnection()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Gets the connection instance to be used for executing and transforming this query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#getDefaultTypes()">getDefaultTypes()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Gets default types of current type map.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#getIterator()">getIterator()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Executes this query and returns a results iterator. This function is required for implementing the IteratorAggregate interface and allows the query to be iterated without having to call execute() manually, thus making it look like a result set instead of the query itself.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#getSelectTypeMap()">getSelectTypeMap()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Gets the TypeMap class where the types for each of the fields in the select clause are stored.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#getTypeMap()">getTypeMap()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the existing type map.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#getValueBinder()">getValueBinder()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the currently used ValueBinder instance.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#group()">group()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a single or multiple fields to be used in the GROUP BY clause for this query. Fields can be passed as an array of strings, array of expression objects, a single expression or a single string.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#having()">having()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a condition or set of conditions to be used in the <code>HAVING</code> clause for this query. This method operates in exactly the same way as the method <code>where()</code> does. Please refer to its documentation for an insight on how to using each parameter.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#identifier()">identifier()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Creates an expression that refers to an identifier. Identifiers are used to refer to field names and allow the SQL compiler to apply quotes or escape the identifier.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#innerJoin()">innerJoin()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a single <code>INNER JOIN</code> clause to the query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#insert()">insert()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Create an insert query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#into()">into()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Set the table name for insert queries.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#isBufferedResultsEnabled()">isBufferedResultsEnabled()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns whether buffered results are enabled/disabled.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#isResultsCastingEnabled()">isResultsCastingEnabled()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns whether result casting is enabled/disabled.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#join()">join()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a single or multiple tables to be used as JOIN clauses to this query. Tables can be passed as an array of strings, an array describing the join parts, an array with multiple join descriptions, or a single string.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#leftJoin()">leftJoin()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a single <code>LEFT JOIN</code> clause to the query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#limit()">limit()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Sets the number of records that should be retrieved from database, accepts an integer or an expression object that evaluates to an integer. In some databases, this operation might not be supported or will require the query to be transformed in order to limit the result set size.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#modifier()">modifier()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a single or multiple <code>SELECT</code> modifiers to be used in the <code>SELECT</code>.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#newExpr()">newExpr()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new QueryExpression object. This is a handy function when building complex queries using a fluent interface. You can also override this function in subclasses to use a more specialized QueryExpression class if required.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#offset()">offset()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Sets the number of records that should be skipped from the original result set This is commonly used for paginating large results. Accepts an integer or an expression object that evaluates to an integer.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#order()">order()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a single or multiple fields to be used in the ORDER clause for this query. Fields can be passed as an array of strings, array of expression objects, a single expression or a single string.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#orderAsc()">orderAsc()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Add an ORDER BY clause with an ASC direction.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#orderDesc()">orderDesc()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Add an ORDER BY clause with a DESC direction.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#page()">page()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Set the page of results you want.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#removeJoin()">removeJoin()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Remove a join if it has been defined.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#rightJoin()">rightJoin()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a single <code>RIGHT JOIN</code> clause to the query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#rowCountAndClose()">rowCountAndClose()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Executes the SQL of this query and immediately closes the statement before returning the row count of records changed.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#select()">select()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds new fields to be returned by a <code>SELECT</code> statement when this query is executed. Fields can be passed as an array of strings, array of expression objects, a single expression or a single string.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#set()">set()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Set one or many fields to update.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#setConnection()">setConnection()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Sets the connection instance to be used for executing and transforming this query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#setDefaultTypes()">setDefaultTypes()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Overwrite the default type mappings for fields in the implementing object.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#setSelectTypeMap()">setSelectTypeMap()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Sets the TypeMap class where the types for each of the fields in the select clause are stored.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#setTypeMap()">setTypeMap()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Creates a new TypeMap if $typeMap is an array, otherwise exchanges it for the given one.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#setValueBinder()">setValueBinder()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Overwrite the current value binder</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#sql()">sql()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the SQL representation of this object.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#traverse()">traverse()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Will iterate over every specified part. Traversing functions can aggregate results using variables in the closure or instance variables. This function is commonly used as a way for traversing all query parts that are going to be used for constructing a query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#traverseExpressions()">traverseExpressions()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>This function works similar to the traverse() function, with the difference that it does a full depth traversal of the entire expression tree. This will execute the provided callback function for each ExpressionInterface object that is stored inside this query at any nesting depth in any part of the query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#traverseParts()">traverseParts()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Will iterate over the provided parts.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#type()">type()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the type of this query (select, insert, update, delete)</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#union()">union()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a complete query to be used in conjunction with an UNION operator with this query. This is used to combine the result set of this query with the one that will be returned by the passed query. You can add as many queries as you required by calling multiple times this method with different queries.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#unionAll()">unionAll()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a complete query to be used in conjunction with the UNION ALL operator with this query. This is used to combine the result set of this query with the one that will be returned by the passed query. You can add as many queries as you required by calling multiple times this method with different queries.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#update()">update()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Create an update query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#values()">values()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Set the values for an insert query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#where()">where()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a condition or set of conditions to be used in the WHERE clause for this query. Conditions can be expressed as an array of fields as keys with comparison operators in it, the values for the array will be used for comparing the field to such literal. Finally, conditions can be expressed as a single string or an array of strings.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#whereInList()">whereInList()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds an IN condition or set of conditions to be used in the WHERE clause for this query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#whereNotInList()">whereNotInList()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a NOT IN condition or set of conditions to be used in the WHERE clause for this query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#whereNotInListOrNull()">whereNotInListOrNull()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a NOT IN condition or set of conditions to be used in the WHERE clause for this query. This also allows the field to be null with a IS NULL condition since the null value would cause the NOT IN condition to always fail.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#whereNotNull()">whereNotNull()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Convenience method that adds a NOT NULL condition to the query</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#whereNull()">whereNull()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Convenience method that adds a IS NULL condition to the query</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#window()">window()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a named window expression.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#with()">with()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a new common table expression (CTE) to the query.</p> </div> </li> </ul> <div class="section"> <h2>Method Detail</h2> <div class="method-detail">  <h3 class="method-name" id="__clone()"> __clone()   <span class="label">public</span> </h3> <pre data-language="php">__clone(): void</pre> <div class="description detailed"> <p>Handles clearing iterator and cloning all expressions and value binders.</p> <h4>Returns</h4> <div class="list"> <code>void</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="__construct()"> __construct()   <span class="label">public</span> </h3> <pre data-language="php">__construct(Cake\Database\Connection $connection)</pre> <div class="description detailed"> <p>Constructor.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\Connection</code> <var>$connection</var> </dt> <dd><p>The connection object to be used for transforming and executing this query</p></dd> </dl> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="__debugInfo()"> __debugInfo()   <span class="label">public</span> </h3> <pre data-language="php">__debugInfo(): array&lt;string, mixed&gt;</pre> <div class="description detailed"> <p>Returns an array that can be used to describe the internal state of this object.</p> <h4>Returns</h4> <div class="list"> <code>array&lt;string, mixed&gt;</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="__toString()"> __toString()   <span class="label">public</span> </h3> <pre data-language="php">__toString(): string</pre> <div class="description detailed"> <p>Returns string representation of this query (complete SQL statement).</p> <h4>Returns</h4> <div class="list"> <code>string</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="_conjugate()"> _conjugate()   <span class="label">protected</span> </h3> <pre data-language="php">_conjugate(string $part, Cake\Database\ExpressionInterfaceClosure|array|string|null $append, string $conjunction, array&lt;string, string&gt; $types): void</pre> <div class="description detailed"> <p>Helper function used to build conditions by composing QueryExpression objects.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$part</var> </dt> <dd><p>Name of the query part to append the new part to</p></dd> <dt> <code>Cake\Database\ExpressionInterfaceClosure|array|string|null</code> <var>$append</var> </dt> <dd><p>Expression or builder function to append. to append.</p></dd> <dt> <code>string</code> <var>$conjunction</var> </dt> <dd><p>type of conjunction to be used to operate part</p></dd> <dt> <code>array&lt;string, string&gt;</code> <var>$types</var> </dt> <dd><p>Associative array of type names used to bind values to query</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>void</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="_decorateStatement()"> _decorateStatement()   <span class="label">protected</span> </h3> <pre data-language="php">_decorateStatement(Cake\Database\StatementInterface $statement): Cake\Database\Statement\CallbackStatementCake\Database\StatementInterface</pre> <div class="description detailed"> <p>Auxiliary function used to wrap the original statement from the driver with any registered callbacks.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\StatementInterface</code> <var>$statement</var> </dt> <dd><p>to be decorated</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>Cake\Database\Statement\CallbackStatementCake\Database\StatementInterface</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="_dirty()"> _dirty()   <span class="label">protected</span> </h3> <pre data-language="php">_dirty(): void</pre> <div class="description detailed"> <p>Marks a query as dirty, removing any preprocessed information from in memory caching.</p> <h4>Returns</h4> <div class="list"> <code>void</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="_expressionsVisitor()"> _expressionsVisitor()   <span class="label">protected</span> </h3> <pre data-language="php">_expressionsVisitor(Cake\Database\ExpressionInterface|arrayCake\Database\ExpressionInterface&gt; $expression, Closure $callback): void</pre> <div class="description detailed"> <p>Query parts traversal method used by traverseExpressions()</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|arrayCake\Database\ExpressionInterface&gt;</code> <var>$expression</var> </dt> <dd><p>Query expression or array of expressions.</p></dd> <dt> <code>Closure</code> <var>$callback</var> </dt> <dd><p>The callback to be executed for each ExpressionInterface found inside this query.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>void</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="_makeJoin()"> _makeJoin()   <span class="label">protected</span> </h3> <pre data-language="php">_makeJoin(array&lt;string, mixed&gt;|string $table, Cake\Database\ExpressionInterface|array|string $conditions, string $type): array</pre> <div class="description detailed"> <p>Returns an array that can be passed to the join method describing a single join clause</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array&lt;string, mixed&gt;|string</code> <var>$table</var> </dt> <dd><p>The table to join with</p></dd> <dt> <code>Cake\Database\ExpressionInterface|array|string</code> <var>$conditions</var> </dt> <dd><p>The conditions to use for joining.</p></dd> <dt> <code>string</code> <var>$type</var> </dt> <dd><p>the join type to use</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>array</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="andHaving()"> andHaving()   <span class="label">public</span> </h3> <pre data-language="php">andHaving(Cake\Database\ExpressionInterfaceClosure|array|string $conditions, array&lt;string, string&gt; $types = []): $this</pre> <div class="description detailed"> <p>Connects any previously defined set of conditions to the provided list using the AND operator in the HAVING clause. This method operates in exactly the same way as the method <code>andWhere()</code> does. Please refer to its documentation for an insight on how to using each parameter.</p> <p>Having fields are not suitable for use with user supplied data as they are not sanitized by the query builder.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterfaceClosure|array|string</code> <var>$conditions</var> </dt> <dd><p>The AND conditions for HAVING.</p></dd> <dt> <code>array&lt;string, string&gt;</code> <var>$types</var> <span class="label">optional</span> </dt> <dd><p>Associative array of type names used to bind values to query</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>See Also</h4> <div class="list"> \Cake\Database\Query::andWhere() </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="andWhere()"> andWhere()   <span class="label">public</span> </h3> <pre data-language="php">andWhere(Cake\Database\ExpressionInterfaceClosure|array|string $conditions, array&lt;string, string&gt; $types = []): $this</pre> <div class="description detailed"> <p>Connects any previously defined set of conditions to the provided list using the AND operator. This function accepts the conditions list in the same format as the method <code>where</code> does, hence you can use arrays, expression objects callback functions or strings.</p> <p>It is important to notice that when calling this function, any previous set of conditions defined for this query will be treated as a single argument for the AND operator. This function will not only operate the most recently defined condition, but all the conditions as a whole.</p> <p>When using an array for defining conditions, creating constraints form each array entry will use the same logic as with the <code>where()</code> function. This means that each array entry will be joined to the other using the AND operator, unless you nest the conditions in the array using other operator.</p> <h3>Examples:</h3> <pre data-language="php">$query-&gt;where(['title' =&gt; 'Hello World')-&gt;andWhere(['author_id' =&gt; 1]);</pre> <p>Will produce:</p> <p><code>WHERE title = 'Hello World' AND author_id = 1</code></p> <pre data-language="php">$query
  -&gt;where(['OR' =&gt; ['published' =&gt; false, 'published is NULL']])
  -&gt;andWhere(['author_id' =&gt; 1, 'comments_count &gt;' =&gt; 10])</pre> <p>Produces:</p> <p><code>WHERE (published = 0 OR published IS NULL) AND author_id = 1 AND comments_count &gt; 10</code></p> <pre data-language="php">$query
  -&gt;where(['title' =&gt; 'Foo'])
  -&gt;andWhere(function ($exp, $query) {
    return $exp
      -&gt;or(['author_id' =&gt; 1])
      -&gt;add(['author_id' =&gt; 2]);
  });</pre> <p>Generates the following conditions:</p> <p><code>WHERE (title = 'Foo') AND (author_id = 1 OR author_id = 2)</code></p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterfaceClosure|array|string</code> <var>$conditions</var> </dt> <dd><p>The conditions to add with AND.</p></dd> <dt> <code>array&lt;string, string&gt;</code> <var>$types</var> <span class="label">optional</span> </dt> <dd><p>Associative array of type names used to bind values to query</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>See Also</h4> <div class="list"> \Cake\Database\Query::where()<br> \Cake\Database\TypeFactory </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="bind()"> bind()   <span class="label">public</span> </h3> <pre data-language="php">bind(string|int $param, mixed $value, string|int|null $type = null): $this</pre> <div class="description detailed"> <p>Associates a query placeholder to a value and a type.</p> <pre data-language="php">$query-&gt;bind(':id', 1, 'integer');</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string|int</code> <var>$param</var> </dt> <dd><p>placeholder to be replaced with quoted version of $value</p></dd> <dt> <code>mixed</code> <var>$value</var> </dt> <dd><p>The value to be bound</p></dd> <dt> <code>string|int|null</code> <var>$type</var> <span class="label">optional</span> </dt> <dd><p>the mapped type name, used for casting when sending to database</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="clause()"> clause()   <span class="label">public</span> </h3> <pre data-language="php">clause(string $name): mixed</pre> <div class="description detailed"> <p>Returns any data that was stored in the specified clause. This is useful for modifying any internal part of the query and it is used by the SQL dialects to transform the query accordingly before it is executed. The valid clauses that can be retrieved are: delete, update, set, insert, values, select, distinct, from, join, set, where, group, having, order, limit, offset and union.</p> <p>The return value for each of those parts may vary. Some clauses use QueryExpression to internally store their state, some use arrays and others may use booleans or integers. This is summary of the return types for each clause.</p> <ul> <li>update: string The name of the table to update</li> <li>set: QueryExpression</li> <li>insert: array, will return an array containing the table + columns.</li> <li>values: ValuesExpression</li> <li>select: array, will return empty array when no fields are set</li> <li>distinct: boolean</li> <li>from: array of tables</li> <li>join: array</li> <li>set: array</li> <li>where: QueryExpression, returns null when not set</li> <li>group: array</li> <li>having: QueryExpression, returns null when not set</li> <li>order: OrderByExpression, returns null when not set</li> <li>limit: integer or QueryExpression, null when not set</li> <li>offset: integer or QueryExpression, null when not set</li> <li>union: array</li> </ul> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$name</var> </dt> <dd><p>name of the clause to be returned</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>mixed</code><br> </div> <h4>Throws</h4> <div class="list"> <code>InvalidArgumentException</code><br> When the named clause does not exist. </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="decorateResults()"> decorateResults()   <span class="label">public</span> </h3> <pre data-language="php">decorateResults(callable|null $callback, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Registers a callback to be executed for each result that is fetched from the result set, the callback function will receive as first parameter an array with the raw data from the database for every row that is fetched and must return the row with any possible modifications.</p> <p>Callbacks will be executed lazily, if only 3 rows are fetched for database it will called 3 times, event though there might be more rows to be fetched in the cursor.</p> <p>Callbacks are stacked in the order they are registered, if you wish to reset the stack the call this function with the second parameter set to true.</p> <p>If you wish to remove all decorators from the stack, set the first parameter to null and the second to true.</p> <h3>Example</h3> <pre data-language="php">$query-&gt;decorateResults(function ($row) {
  $row['order_total'] = $row['subtotal'] + ($row['subtotal'] * $row['tax']);
   return $row;
});</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|null</code> <var>$callback</var> </dt> <dd><p>The callback to invoke when results are fetched.</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>Whether this should append or replace all existing decorators.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="delete()"> delete()   <span class="label">public</span> </h3> <pre data-language="php">delete(string|null $table = null): $this</pre> <div class="description detailed"> <p>Create a delete query.</p> <p>Can be combined with from(), where() and other methods to create delete queries with specific conditions.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string|null</code> <var>$table</var> <span class="label">optional</span> </dt> <dd><p>The table to use when deleting.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="disableBufferedResults()"> disableBufferedResults()   <span class="label">public</span> </h3> <pre data-language="php">disableBufferedResults(): $this</pre> <div class="description detailed"> <p>Disables buffered results.</p> <p>Disabling buffering will consume less memory as fetched results are not remembered for future iterations.</p> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="disableResultsCasting()"> disableResultsCasting()   <span class="label">public</span> </h3> <pre data-language="php">disableResultsCasting(): $this</pre> <div class="description detailed"> <p>Disables result casting.</p> <p>When disabled, the fields will be returned as received from the database driver (which in most environments means they are being returned as strings), which can improve performance with larger datasets.</p> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="distinct()"> distinct()   <span class="label">public</span> </h3> <pre data-language="php">distinct(Cake\Database\ExpressionInterface|array|string|bool $on = [], bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a <code>DISTINCT</code> clause to the query to remove duplicates from the result set. This clause can only be used for select statements.</p> <p>If you wish to filter duplicates based of those rows sharing a particular field or set of fields, you may pass an array of fields to filter on. Beware that this option might not be fully supported in all database systems.</p> <h3>Examples:</h3> <pre data-language="php">// Filters products with the same name and city
$query-&gt;select(['name', 'city'])-&gt;from('products')-&gt;distinct();

// Filters products in the same city
$query-&gt;distinct(['city']);
$query-&gt;distinct('city');

// Filter products with the same name
$query-&gt;distinct(['name'], true);
$query-&gt;distinct('name', true);</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|array|string|bool</code> <var>$on</var> <span class="label">optional</span> </dt> <dd><p>Enable/disable distinct class or list of fields to be filtered on</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset fields with passed list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="enableBufferedResults()"> enableBufferedResults()   <span class="label">public</span> </h3> <pre data-language="php">enableBufferedResults(bool $enable = true): $this</pre> <div class="description detailed"> <p>Enables/Disables buffered results.</p> <p>When enabled the results returned by this Query will be buffered. This enables you to iterate a result set multiple times, or both cache and iterate it.</p> <p>When disabled it will consume less memory as fetched results are not remembered for future iterations.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>bool</code> <var>$enable</var> <span class="label">optional</span> </dt> <dd><p>Whether to enable buffering</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="enableResultsCasting()"> enableResultsCasting()   <span class="label">public</span> </h3> <pre data-language="php">enableResultsCasting(): $this</pre> <div class="description detailed"> <p>Enables result casting.</p> <p>When enabled, the fields in the results returned by this Query will be cast to their corresponding PHP data type.</p> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="epilog()"> epilog()   <span class="label">public</span> </h3> <pre data-language="php">epilog(Cake\Database\ExpressionInterface|string|null $expression = null): $this</pre> <div class="description detailed"> <p>A string or expression that will be appended to the generated query</p> <h3>Examples:</h3> <pre data-language="php">$query-&gt;select('id')-&gt;where(['author_id' =&gt; 1])-&gt;epilog('FOR UPDATE');
$query
 -&gt;insert('articles', ['title'])
 -&gt;values(['author_id' =&gt; 1])
 -&gt;epilog('RETURNING id');</pre> <p>Epliog content is raw SQL and not suitable for use with user supplied data.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|string|null</code> <var>$expression</var> <span class="label">optional</span> </dt> <dd><p>The expression to be appended</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="execute()"> execute()   <span class="label">public</span> </h3> <pre data-language="php">execute(): Cake\Database\StatementInterface</pre> <div class="description detailed"> <p>Compiles the SQL representation of this query and executes it using the configured connection object. Returns the resulting statement object.</p> <p>Executing a query internally executes several steps, the first one is letting the connection transform this object to fit its particular dialect, this might result in generating a different Query object that will be the one to actually be executed. Immediately after, literal values are passed to the connection so they are bound to the query in a safe way. Finally, the resulting statement is decorated with custom objects to execute callbacks for each row retrieved if necessary.</p> <p>Resulting statement is traversable, so it can be used in any loop as you would with an array.</p> <p>This method can be overridden in query subclasses to decorate behavior around query execution.</p> <h4>Returns</h4> <div class="list"> <code>Cake\Database\StatementInterface</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="expr()"> expr()   <span class="label">public</span> </h3> <pre data-language="php">expr(Cake\Database\ExpressionInterface|array|string|null $rawExpression = null): Cake\Database\Expression\QueryExpression</pre> <div class="description detailed"> <p>Returns a new QueryExpression object. This is a handy function when building complex queries using a fluent interface. You can also override this function in subclasses to use a more specialized QueryExpression class if required.</p> <p>You can optionally pass a single raw SQL string or an array or expressions in any format accepted by \Cake\Database\Expression\QueryExpression:</p> <pre data-language="php">$expression = $query-&gt;expr(); // Returns an empty expression object
$expression = $query-&gt;expr('Table.column = Table2.column'); // Return a raw SQL expression</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|array|string|null</code> <var>$rawExpression</var> <span class="label">optional</span> </dt> <dd><p>A string, array or anything you want wrapped in an expression object</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>Cake\Database\Expression\QueryExpression</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="from()"> from()   <span class="label">public</span> </h3> <pre data-language="php">from(array|string $tables = [], bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a single or multiple tables to be used in the FROM clause for this query. Tables can be passed as an array of strings, array of expression objects, a single expression or a single string.</p> <p>If an array is passed, keys will be used to alias tables using the value as the real field to be aliased. It is possible to alias strings, ExpressionInterface objects or even other Query objects.</p> <p>By default this function will append any passed argument to the list of tables to be selected from, unless the second argument is set to true.</p> <p>This method can be used for select, update and delete statements.</p> <h3>Examples:</h3> <pre data-language="php">$query-&gt;from(['p' =&gt; 'posts']); // Produces FROM posts p
$query-&gt;from('authors'); // Appends authors: FROM posts p, authors
$query-&gt;from(['products'], true); // Resets the list: FROM products
$query-&gt;from(['sub' =&gt; $countQuery]); // FROM (SELECT ...) sub</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array|string</code> <var>$tables</var> <span class="label">optional</span> </dt> <dd><p>tables to be added to the list. This argument, can be passed as an array of strings, array of expression objects, or a single string. See the examples above for the valid call types.</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset tables with passed list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="func()"> func()   <span class="label">public</span> </h3> <pre data-language="php">func(): Cake\Database\FunctionsBuilder</pre> <div class="description detailed"> <p>Returns an instance of a functions builder object that can be used for generating arbitrary SQL functions.</p> <h3>Example:</h3> <pre data-language="php">$query-&gt;func()-&gt;count('*');
$query-&gt;func()-&gt;dateDiff(['2012-01-05', '2012-01-02'])</pre> <h4>Returns</h4> <div class="list"> <code>Cake\Database\FunctionsBuilder</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="getConnection()"> getConnection()   <span class="label">public</span> </h3> <pre data-language="php">getConnection(): Cake\Database\Connection</pre> <div class="description detailed"> <p>Gets the connection instance to be used for executing and transforming this query.</p> <h4>Returns</h4> <div class="list"> <code>Cake\Database\Connection</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="getDefaultTypes()"> getDefaultTypes()   <span class="label">public</span> </h3> <pre data-language="php">getDefaultTypes(): array&lt;int|string, string&gt;</pre> <div class="description detailed"> <p>Gets default types of current type map.</p> <h4>Returns</h4> <div class="list"> <code>array&lt;int|string, string&gt;</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="getIterator()"> getIterator()   <span class="label">public</span> </h3> <pre data-language="php">getIterator(): Cake\Database\StatementInterface</pre> <div class="description detailed"> <p>Executes this query and returns a results iterator. This function is required for implementing the IteratorAggregate interface and allows the query to be iterated without having to call execute() manually, thus making it look like a result set instead of the query itself.</p> <h4>Returns</h4> <div class="list"> <code>Cake\Database\StatementInterface</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="getSelectTypeMap()"> getSelectTypeMap()   <span class="label">public</span> </h3> <pre data-language="php">getSelectTypeMap(): Cake\Database\TypeMap</pre> <div class="description detailed"> <p>Gets the TypeMap class where the types for each of the fields in the select clause are stored.</p> <h4>Returns</h4> <div class="list"> <code>Cake\Database\TypeMap</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="getTypeMap()"> getTypeMap()   <span class="label">public</span> </h3> <pre data-language="php">getTypeMap(): Cake\Database\TypeMap</pre> <div class="description detailed"> <p>Returns the existing type map.</p> <h4>Returns</h4> <div class="list"> <code>Cake\Database\TypeMap</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="getValueBinder()"> getValueBinder()   <span class="label">public</span> </h3> <pre data-language="php">getValueBinder(): Cake\Database\ValueBinder</pre> <div class="description detailed"> <p>Returns the currently used ValueBinder instance.</p> <p>A ValueBinder is responsible for generating query placeholders and temporarily associate values to those placeholders so that they can be passed correctly to the statement object.</p> <h4>Returns</h4> <div class="list"> <code>Cake\Database\ValueBinder</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="group()"> group()   <span class="label">public</span> </h3> <pre data-language="php">group(Cake\Database\ExpressionInterface|array|string $fields, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a single or multiple fields to be used in the GROUP BY clause for this query. Fields can be passed as an array of strings, array of expression objects, a single expression or a single string.</p> <p>By default this function will append any passed argument to the list of fields to be grouped, unless the second argument is set to true.</p> <h3>Examples:</h3> <pre data-language="php">// Produces GROUP BY id, title
$query-&gt;group(['id', 'title']);

// Produces GROUP BY title
$query-&gt;group('title');</pre> <p>Group fields are not suitable for use with user supplied data as they are not sanitized by the query builder.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|array|string</code> <var>$fields</var> </dt> <dd><p>fields to be added to the list</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset fields with passed list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="having()"> having()   <span class="label">public</span> </h3> <pre data-language="php">having(Cake\Database\ExpressionInterfaceClosure|array|string|null $conditions = null, array&lt;string, string&gt; $types = [], bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a condition or set of conditions to be used in the <code>HAVING</code> clause for this query. This method operates in exactly the same way as the method <code>where()</code> does. Please refer to its documentation for an insight on how to using each parameter.</p> <p>Having fields are not suitable for use with user supplied data as they are not sanitized by the query builder.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterfaceClosure|array|string|null</code> <var>$conditions</var> <span class="label">optional</span> </dt> <dd><p>The having conditions.</p></dd> <dt> <code>array&lt;string, string&gt;</code> <var>$types</var> <span class="label">optional</span> </dt> <dd><p>Associative array of type names used to bind values to query</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset conditions with passed list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>See Also</h4> <div class="list"> \Cake\Database\Query::where() </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="identifier()"> identifier()   <span class="label">public</span> </h3> <pre data-language="php">identifier(string $identifier): Cake\Database\ExpressionInterface</pre> <div class="description detailed"> <p>Creates an expression that refers to an identifier. Identifiers are used to refer to field names and allow the SQL compiler to apply quotes or escape the identifier.</p> <p>The value is used as is, and you might be required to use aliases or include the table reference in the identifier. Do not use this method to inject SQL methods or logical statements.</p> <h3>Example</h3> <pre data-language="php">$query-&gt;newExpr()-&gt;lte('count', $query-&gt;identifier('total'));</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$identifier</var> </dt> <dd><p>The identifier for an expression</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>Cake\Database\ExpressionInterface</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="innerJoin()"> innerJoin()   <span class="label">public</span> </h3> <pre data-language="php">innerJoin(array&lt;string, mixed&gt;|string $table, Cake\Database\ExpressionInterface|array|string $conditions = [], array&lt;string, string&gt; $types = []): $this</pre> <div class="description detailed"> <p>Adds a single <code>INNER JOIN</code> clause to the query.</p> <p>This is a shorthand method for building joins via <code>join()</code>.</p> <p>The arguments of this method are identical to the <code>leftJoin()</code> shorthand, please refer to that method's description for further details.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array&lt;string, mixed&gt;|string</code> <var>$table</var> </dt> <dd><p>The table to join with</p></dd> <dt> <code>Cake\Database\ExpressionInterface|array|string</code> <var>$conditions</var> <span class="label">optional</span> </dt> <dd><p>The conditions to use for joining.</p></dd> <dt> <code>array&lt;string, string&gt;</code> <var>$types</var> <span class="label">optional</span> </dt> <dd><p>a list of types associated to the conditions used for converting values to the corresponding database representation.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="insert()"> insert()   <span class="label">public</span> </h3> <pre data-language="php">insert(array $columns, array&lt;int|string, string&gt; $types = []): $this</pre> <div class="description detailed"> <p>Create an insert query.</p> <p>Note calling this method will reset any data previously set with Query::values().</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array</code> <var>$columns</var> </dt> <dd><p>The columns to insert into.</p></dd> <dt> <code>array&lt;int|string, string&gt;</code> <var>$types</var> <span class="label">optional</span> </dt> <dd><p>A map between columns &amp; their datatypes.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>Throws</h4> <div class="list"> <code>RuntimeException</code><br> When there are 0 columns. </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="into()"> into()   <span class="label">public</span> </h3> <pre data-language="php">into(string $table): $this</pre> <div class="description detailed"> <p>Set the table name for insert queries.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$table</var> </dt> <dd><p>The table name to insert into.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="isBufferedResultsEnabled()"> isBufferedResultsEnabled()   <span class="label">public</span> </h3> <pre data-language="php">isBufferedResultsEnabled(): bool</pre> <div class="description detailed"> <p>Returns whether buffered results are enabled/disabled.</p> <p>When enabled the results returned by this Query will be buffered. This enables you to iterate a result set multiple times, or both cache and iterate it.</p> <p>When disabled it will consume less memory as fetched results are not remembered for future iterations.</p> <h4>Returns</h4> <div class="list"> <code>bool</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="isResultsCastingEnabled()"> isResultsCastingEnabled()   <span class="label">public</span> </h3> <pre data-language="php">isResultsCastingEnabled(): bool</pre> <div class="description detailed"> <p>Returns whether result casting is enabled/disabled.</p> <p>When enabled, the fields in the results returned by this Query will be casted to their corresponding PHP data type.</p> <p>When disabled, the fields will be returned as received from the database driver (which in most environments means they are being returned as strings), which can improve performance with larger datasets.</p> <h4>Returns</h4> <div class="list"> <code>bool</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="join()"> join()   <span class="label">public</span> </h3> <pre data-language="php">join(array&lt;string, mixed&gt;|string $tables, array&lt;string, string&gt; $types = [], bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a single or multiple tables to be used as JOIN clauses to this query. Tables can be passed as an array of strings, an array describing the join parts, an array with multiple join descriptions, or a single string.</p> <p>By default this function will append any passed argument to the list of tables to be joined, unless the third argument is set to true.</p> <p>When no join type is specified an <code>INNER JOIN</code> is used by default: <code>$query-&gt;join(['authors'])</code> will produce <code>INNER JOIN authors ON 1 = 1</code></p> <p>It is also possible to alias joins using the array key: <code>$query-&gt;join(['a' =&gt; 'authors'])</code> will produce <code>INNER JOIN authors a ON 1 = 1</code></p> <p>A join can be fully described and aliased using the array notation:</p> <pre data-language="php">$query-&gt;join([
    'a' =&gt; [
        'table' =&gt; 'authors',
        'type' =&gt; 'LEFT',
        'conditions' =&gt; 'a.id = b.author_id'
    ]
]);
// Produces LEFT JOIN authors a ON a.id = b.author_id</pre> <p>You can even specify multiple joins in an array, including the full description:</p> <pre data-language="php">$query-&gt;join([
    'a' =&gt; [
        'table' =&gt; 'authors',
        'type' =&gt; 'LEFT',
        'conditions' =&gt; 'a.id = b.author_id'
    ],
    'p' =&gt; [
        'table' =&gt; 'publishers',
        'type' =&gt; 'INNER',
        'conditions' =&gt; 'p.id = b.publisher_id AND p.name = "Cake Software Foundation"'
    ]
]);
// LEFT JOIN authors a ON a.id = b.author_id
// INNER JOIN publishers p ON p.id = b.publisher_id AND p.name = "Cake Software Foundation"</pre> <h3>Using conditions and types</h3> <p>Conditions can be expressed, as in the examples above, using a string for comparing columns, or string with already quoted literal values. Additionally it is possible to use conditions expressed in arrays or expression objects.</p> <p>When using arrays for expressing conditions, it is often desirable to convert the literal values to the correct database representation. This is achieved using the second parameter of this function.</p> <pre data-language="php">$query-&gt;join(['a' =&gt; [
    'table' =&gt; 'articles',
    'conditions' =&gt; [
        'a.posted &gt;=' =&gt; new DateTime('-3 days'),
        'a.published' =&gt; true,
        'a.author_id = authors.id'
    ]
]], ['a.posted' =&gt; 'datetime', 'a.published' =&gt; 'boolean'])</pre> <h3>Overwriting joins</h3> <p>When creating aliased joins using the array notation, you can override previous join definitions by using the same alias in consequent calls to this function or you can replace all previously defined joins with another list if the third parameter for this function is set to true.</p> <pre data-language="php">$query-&gt;join(['alias' =&gt; 'table']); // joins table with as alias
$query-&gt;join(['alias' =&gt; 'another_table']); // joins another_table with as alias
$query-&gt;join(['something' =&gt; 'different_table'], [], true); // resets joins list</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array&lt;string, mixed&gt;|string</code> <var>$tables</var> </dt> <dd><p>list of tables to be joined in the query</p></dd> <dt> <code>array&lt;string, string&gt;</code> <var>$types</var> <span class="label">optional</span> </dt> <dd><p>Associative array of type names used to bind values to query</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset joins with passed list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>See Also</h4> <div class="list"> \Cake\Database\TypeFactory </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="leftJoin()"> leftJoin()   <span class="label">public</span> </h3> <pre data-language="php">leftJoin(array&lt;string, mixed&gt;|string $table, Cake\Database\ExpressionInterface|array|string $conditions = [], array $types = []): $this</pre> <div class="description detailed"> <p>Adds a single <code>LEFT JOIN</code> clause to the query.</p> <p>This is a shorthand method for building joins via <code>join()</code>.</p> <p>The table name can be passed as a string, or as an array in case it needs to be aliased:</p> <pre data-language="php">// LEFT JOIN authors ON authors.id = posts.author_id
$query-&gt;leftJoin('authors', 'authors.id = posts.author_id');

// LEFT JOIN authors a ON a.id = posts.author_id
$query-&gt;leftJoin(['a' =&gt; 'authors'], 'a.id = posts.author_id');</pre> <p>Conditions can be passed as strings, arrays, or expression objects. When using arrays it is possible to combine them with the <code>$types</code> parameter in order to define how to convert the values:</p> <pre data-language="php">$query-&gt;leftJoin(['a' =&gt; 'articles'], [
     'a.posted &gt;=' =&gt; new DateTime('-3 days'),
     'a.published' =&gt; true,
     'a.author_id = authors.id'
], ['a.posted' =&gt; 'datetime', 'a.published' =&gt; 'boolean']);</pre> <p>See <code>join()</code> for further details on conditions and types.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array&lt;string, mixed&gt;|string</code> <var>$table</var> </dt> <dd><p>The table to join with</p></dd> <dt> <code>Cake\Database\ExpressionInterface|array|string</code> <var>$conditions</var> <span class="label">optional</span> </dt> <dd><p>The conditions to use for joining.</p></dd> <dt> <code>array</code> <var>$types</var> <span class="label">optional</span> </dt> <dd><p>a list of types associated to the conditions used for converting values to the corresponding database representation.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="limit()"> limit()   <span class="label">public</span> </h3> <pre data-language="php">limit(Cake\Database\ExpressionInterface|int|null $limit): $this</pre> <div class="description detailed"> <p>Sets the number of records that should be retrieved from database, accepts an integer or an expression object that evaluates to an integer. In some databases, this operation might not be supported or will require the query to be transformed in order to limit the result set size.</p> <h3>Examples</h3> <pre data-language="php">$query-&gt;limit(10) // generates LIMIT 10
$query-&gt;limit($query-&gt;newExpr()-&gt;add(['1 + 1'])); // LIMIT (1 + 1)</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|int|null</code> <var>$limit</var> </dt> <dd><p>number of records to be returned</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="modifier()"> modifier()   <span class="label">public</span> </h3> <pre data-language="php">modifier(Cake\Database\ExpressionInterface|array|string $modifiers, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a single or multiple <code>SELECT</code> modifiers to be used in the <code>SELECT</code>.</p> <p>By default this function will append any passed argument to the list of modifiers to be applied, unless the second argument is set to true.</p> <h3>Example:</h3> <pre data-language="php">// Ignore cache query in MySQL
$query-&gt;select(['name', 'city'])-&gt;from('products')-&gt;modifier('SQL_NO_CACHE');
// It will produce the SQL: SELECT SQL_NO_CACHE name, city FROM products

// Or with multiple modifiers
$query-&gt;select(['name', 'city'])-&gt;from('products')-&gt;modifier(['HIGH_PRIORITY', 'SQL_NO_CACHE']);
// It will produce the SQL: SELECT HIGH_PRIORITY SQL_NO_CACHE name, city FROM products</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|array|string</code> <var>$modifiers</var> </dt> <dd><p>modifiers to be applied to the query</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset order with field list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="newExpr()"> newExpr()   <span class="label">public</span> </h3> <pre data-language="php">newExpr(Cake\Database\ExpressionInterface|array|string|null $rawExpression = null): Cake\Database\Expression\QueryExpression</pre> <div class="description detailed"> <p>Returns a new QueryExpression object. This is a handy function when building complex queries using a fluent interface. You can also override this function in subclasses to use a more specialized QueryExpression class if required.</p> <p>You can optionally pass a single raw SQL string or an array or expressions in any format accepted by \Cake\Database\Expression\QueryExpression:</p> <pre data-language="php">$expression = $query-&gt;expr(); // Returns an empty expression object
$expression = $query-&gt;expr('Table.column = Table2.column'); // Return a raw SQL expression</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|array|string|null</code> <var>$rawExpression</var> <span class="label">optional</span> </dt> <dd><p>A string, array or anything you want wrapped in an expression object</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>Cake\Database\Expression\QueryExpression</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="offset()"> offset()   <span class="label">public</span> </h3> <pre data-language="php">offset(Cake\Database\ExpressionInterface|int|null $offset): $this</pre> <div class="description detailed"> <p>Sets the number of records that should be skipped from the original result set This is commonly used for paginating large results. Accepts an integer or an expression object that evaluates to an integer.</p> <p>In some databases, this operation might not be supported or will require the query to be transformed in order to limit the result set size.</p> <h3>Examples</h3> <pre data-language="php">$query-&gt;offset(10) // generates OFFSET 10
$query-&gt;offset($query-&gt;newExpr()-&gt;add(['1 + 1'])); // OFFSET (1 + 1)</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|int|null</code> <var>$offset</var> </dt> <dd><p>number of records to be skipped</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="order()"> order()   <span class="label">public</span> </h3> <pre data-language="php">order(Cake\Database\ExpressionInterfaceClosure|array|string $fields, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a single or multiple fields to be used in the ORDER clause for this query. Fields can be passed as an array of strings, array of expression objects, a single expression or a single string.</p> <p>If an array is passed, keys will be used as the field itself and the value will represent the order in which such field should be ordered. When called multiple times with the same fields as key, the last order definition will prevail over the others.</p> <p>By default this function will append any passed argument to the list of fields to be selected, unless the second argument is set to true.</p> <h3>Examples:</h3> <pre data-language="php">$query-&gt;order(['title' =&gt; 'DESC', 'author_id' =&gt; 'ASC']);</pre> <p>Produces:</p> <p><code>ORDER BY title DESC, author_id ASC</code></p> <pre data-language="php">$query
    -&gt;order(['title' =&gt; $query-&gt;newExpr('DESC NULLS FIRST')])
    -&gt;order('author_id');</pre> <p>Will generate:</p> <p><code>ORDER BY title DESC NULLS FIRST, author_id</code></p> <pre data-language="php">$expression = $query-&gt;newExpr()-&gt;add(['id % 2 = 0']);
$query-&gt;order($expression)-&gt;order(['title' =&gt; 'ASC']);</pre> <p>and</p> <pre data-language="php">$query-&gt;order(function ($exp, $query) {
    return [$exp-&gt;add(['id % 2 = 0']), 'title' =&gt; 'ASC'];
});</pre> <p>Will both become:</p> <p><code>ORDER BY (id %2 = 0), title ASC</code></p> <p>Order fields/directions are not sanitized by the query builder. You should use an allowed list of fields/directions when passing in user-supplied data to <code>order()</code>.</p> <p>If you need to set complex expressions as order conditions, you should use <code>orderAsc()</code> or <code>orderDesc()</code>.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterfaceClosure|array|string</code> <var>$fields</var> </dt> <dd><p>fields to be added to the list</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset order with field list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="orderAsc()"> orderAsc()   <span class="label">public</span> </h3> <pre data-language="php">orderAsc(Cake\Database\ExpressionInterfaceClosure|string $field, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Add an ORDER BY clause with an ASC direction.</p> <p>This method allows you to set complex expressions as order conditions unlike order()</p> <p>Order fields are not suitable for use with user supplied data as they are not sanitized by the query builder.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterfaceClosure|string</code> <var>$field</var> </dt> <dd><p>The field to order on.</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>Whether to reset the order clauses.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="orderDesc()"> orderDesc()   <span class="label">public</span> </h3> <pre data-language="php">orderDesc(Cake\Database\ExpressionInterfaceClosure|string $field, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Add an ORDER BY clause with a DESC direction.</p> <p>This method allows you to set complex expressions as order conditions unlike order()</p> <p>Order fields are not suitable for use with user supplied data as they are not sanitized by the query builder.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterfaceClosure|string</code> <var>$field</var> </dt> <dd><p>The field to order on.</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>Whether to reset the order clauses.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="page()"> page()   <span class="label">public</span> </h3> <pre data-language="php">page(int $num, int|null $limit = null): $this</pre> <div class="description detailed"> <p>Set the page of results you want.</p> <p>This method provides an easier to use interface to set the limit + offset in the record set you want as results. If empty the limit will default to the existing limit clause, and if that too is empty, then <code>25</code> will be used.</p> <p>Pages must start at 1.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>int</code> <var>$num</var> </dt> <dd><p>The page number you want.</p></dd> <dt> <code>int|null</code> <var>$limit</var> <span class="label">optional</span> </dt> <dd><p>The number of rows you want in the page. If null the current limit clause will be used.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>Throws</h4> <div class="list"> <code>InvalidArgumentException</code><br> If page number &lt; 1. </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="removeJoin()"> removeJoin()   <span class="label">public</span> </h3> <pre data-language="php">removeJoin(string $name): $this</pre> <div class="description detailed"> <p>Remove a join if it has been defined.</p> <p>Useful when you are redefining joins or want to re-order the join clauses.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$name</var> </dt> <dd><p>The alias/name of the join to remove.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="rightJoin()"> rightJoin()   <span class="label">public</span> </h3> <pre data-language="php">rightJoin(array&lt;string, mixed&gt;|string $table, Cake\Database\ExpressionInterface|array|string $conditions = [], array $types = []): $this</pre> <div class="description detailed"> <p>Adds a single <code>RIGHT JOIN</code> clause to the query.</p> <p>This is a shorthand method for building joins via <code>join()</code>.</p> <p>The arguments of this method are identical to the <code>leftJoin()</code> shorthand, please refer to that methods description for further details.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array&lt;string, mixed&gt;|string</code> <var>$table</var> </dt> <dd><p>The table to join with</p></dd> <dt> <code>Cake\Database\ExpressionInterface|array|string</code> <var>$conditions</var> <span class="label">optional</span> </dt> <dd><p>The conditions to use for joining.</p></dd> <dt> <code>array</code> <var>$types</var> <span class="label">optional</span> </dt> <dd><p>a list of types associated to the conditions used for converting values to the corresponding database representation.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="rowCountAndClose()"> rowCountAndClose()   <span class="label">public</span> </h3> <pre data-language="php">rowCountAndClose(): int</pre> <div class="description detailed"> <p>Executes the SQL of this query and immediately closes the statement before returning the row count of records changed.</p> <p>This method can be used with UPDATE and DELETE queries, but is not recommended for SELECT queries and is not used to count records.</p> <h2>Example</h2> <pre data-language="php">$rowCount = $query-&gt;update('articles')
                -&gt;set(['published'=&gt;true])
                -&gt;where(['published'=&gt;false])
                -&gt;rowCountAndClose();</pre> <p>The above example will change the published column to true for all false records, and return the number of records that were updated.</p> <h4>Returns</h4> <div class="list"> <code>int</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="select()"> select()   <span class="label">public</span> </h3> <pre data-language="php">select(Cake\Database\ExpressionInterface|callable|array|string $fields = [], bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds new fields to be returned by a <code>SELECT</code> statement when this query is executed. Fields can be passed as an array of strings, array of expression objects, a single expression or a single string.</p> <p>If an array is passed, keys will be used to alias fields using the value as the real field to be aliased. It is possible to alias strings, Expression objects or even other Query objects.</p> <p>If a callable function is passed, the returning array of the function will be used as the list of fields.</p> <p>By default this function will append any passed argument to the list of fields to be selected, unless the second argument is set to true.</p> <h3>Examples:</h3> <pre data-language="php">$query-&gt;select(['id', 'title']); // Produces SELECT id, title
$query-&gt;select(['author' =&gt; 'author_id']); // Appends author: SELECT id, title, author_id as author
$query-&gt;select('id', true); // Resets the list: SELECT id
$query-&gt;select(['total' =&gt; $countQuery]); // SELECT id, (SELECT ...) AS total
$query-&gt;select(function ($query) {
    return ['article_id', 'total' =&gt; $query-&gt;count('*')];
})</pre> <p>By default no fields are selected, if you have an instance of <code>Cake\ORM\Query</code> and try to append fields you should also call <code>Cake\ORM\Query::enableAutoFields()</code> to select the default fields from the table.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|callable|array|string</code> <var>$fields</var> <span class="label">optional</span> </dt> <dd><p>fields to be added to the list.</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset fields with passed list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="set()"> set()   <span class="label">public</span> </h3> <pre data-language="php">set(Cake\Database\Expression\QueryExpressionClosure|array|string $key, mixed $value = null, array&lt;string, string&gt;|string $types = []): $this</pre> <div class="description detailed"> <p>Set one or many fields to update.</p> <h3>Examples</h3> <p>Passing a string:</p> <pre data-language="php">$query-&gt;update('articles')-&gt;set('title', 'The Title');</pre> <p>Passing an array:</p> <pre data-language="php">$query-&gt;update('articles')-&gt;set(['title' =&gt; 'The Title'], ['title' =&gt; 'string']);</pre> <p>Passing a callable:</p> <pre data-language="php">$query-&gt;update('articles')-&gt;set(function ($exp) {
  return $exp-&gt;eq('title', 'The title', 'string');
});</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\Expression\QueryExpressionClosure|array|string</code> <var>$key</var> </dt> <dd>
<p>The column name or array of keys</p> <ul> <li>values to set. This can also be a QueryExpression containing a SQL fragment. It can also be a Closure, that is required to return an expression object.</li> </ul>
</dd> <dt> <code>mixed</code> <var>$value</var> <span class="label">optional</span> </dt> <dd><p>The value to update $key to. Can be null if $key is an array or QueryExpression. When $key is an array, this parameter will be used as $types instead.</p></dd> <dt> <code>array&lt;string, string&gt;|string</code> <var>$types</var> <span class="label">optional</span> </dt> <dd><p>The column types to treat data as.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="setConnection()"> setConnection()   <span class="label">public</span> </h3> <pre data-language="php">setConnection(Cake\Database\Connection $connection): $this</pre> <div class="description detailed"> <p>Sets the connection instance to be used for executing and transforming this query.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\Connection</code> <var>$connection</var> </dt> <dd><p>Connection instance</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="setDefaultTypes()"> setDefaultTypes()   <span class="label">public</span> </h3> <pre data-language="php">setDefaultTypes(array&lt;int|string, string&gt; $types): $this</pre> <div class="description detailed"> <p>Overwrite the default type mappings for fields in the implementing object.</p> <p>This method is useful if you need to set type mappings that are shared across multiple functions/expressions in a query.</p> <p>To add a default without overwriting existing ones use <code>getTypeMap()-&gt;addDefaults()</code></p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array&lt;int|string, string&gt;</code> <var>$types</var> </dt> <dd><p>The array of types to set.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>See Also</h4> <div class="list"> \Cake\Database\TypeMap::setDefaults() </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="setSelectTypeMap()"> setSelectTypeMap()   <span class="label">public</span> </h3> <pre data-language="php">setSelectTypeMap(Cake\Database\TypeMap $typeMap): $this</pre> <div class="description detailed"> <p>Sets the TypeMap class where the types for each of the fields in the select clause are stored.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\TypeMap</code> <var>$typeMap</var> </dt> <dd><p>The map object to use</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="setTypeMap()"> setTypeMap()   <span class="label">public</span> </h3> <pre data-language="php">setTypeMap(Cake\Database\TypeMap|array $typeMap): $this</pre> <div class="description detailed"> <p>Creates a new TypeMap if $typeMap is an array, otherwise exchanges it for the given one.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\TypeMap|array</code> <var>$typeMap</var> </dt> <dd><p>Creates a TypeMap if array, otherwise sets the given TypeMap</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="setValueBinder()"> setValueBinder()   <span class="label">public</span> </h3> <pre data-language="php">setValueBinder(Cake\Database\ValueBinder|null $binder): $this</pre> <div class="description detailed"> <p>Overwrite the current value binder</p> <p>A ValueBinder is responsible for generating query placeholders and temporarily associate values to those placeholders so that they can be passed correctly to the statement object.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ValueBinder|null</code> <var>$binder</var> </dt> <dd><p>The binder or null to disable binding.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="sql()"> sql()   <span class="label">public</span> </h3> <pre data-language="php">sql(Cake\Database\ValueBinder|null $binder = null): string</pre> <div class="description detailed"> <p>Returns the SQL representation of this object.</p> <p>This function will compile this query to make it compatible with the SQL dialect that is used by the connection, This process might add, remove or alter any query part or internal expression to make it executable in the target platform.</p> <p>The resulting query may have placeholders that will be replaced with the actual values when the query is executed, hence it is most suitable to use with prepared statements.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ValueBinder|null</code> <var>$binder</var> <span class="label">optional</span> </dt> <dd><p>Value binder that generates parameter placeholders</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>string</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="traverse()"> traverse()   <span class="label">public</span> </h3> <pre data-language="php">traverse(callable $callback): $this</pre> <div class="description detailed"> <p>Will iterate over every specified part. Traversing functions can aggregate results using variables in the closure or instance variables. This function is commonly used as a way for traversing all query parts that are going to be used for constructing a query.</p> <p>The callback will receive 2 parameters, the first one is the value of the query part that is being iterated and the second the name of such part.</p> <h3>Example</h3> <pre data-language="php">$query-&gt;select(['title'])-&gt;from('articles')-&gt;traverse(function ($value, $clause) {
    if ($clause === 'select') {
        var_dump($value);
    }
});</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable</code> <var>$callback</var> </dt> <dd><p>A function or callable to be executed for each part</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="traverseExpressions()"> traverseExpressions()   <span class="label">public</span> </h3> <pre data-language="php">traverseExpressions(callable $callback): $this</pre> <div class="description detailed"> <p>This function works similar to the traverse() function, with the difference that it does a full depth traversal of the entire expression tree. This will execute the provided callback function for each ExpressionInterface object that is stored inside this query at any nesting depth in any part of the query.</p> <p>Callback will receive as first parameter the currently visited expression.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable</code> <var>$callback</var> </dt> <dd><p>the function to be executed for each ExpressionInterface found inside this query.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="traverseParts()"> traverseParts()   <span class="label">public</span> </h3> <pre data-language="php">traverseParts(callable $visitor, array&lt;string&gt; $parts): $this</pre> <div class="description detailed"> <p>Will iterate over the provided parts.</p> <p>Traversing functions can aggregate results using variables in the closure or instance variables. This method can be used to traverse a subset of query parts in order to render a SQL query.</p> <p>The callback will receive 2 parameters, the first one is the value of the query part that is being iterated and the second the name of such part.</p> <h3>Example</h3> <pre data-language="php">$query-&gt;select(['title'])-&gt;from('articles')-&gt;traverse(function ($value, $clause) {
    if ($clause === 'select') {
        var_dump($value);
    }
}, ['select', 'from']);</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable</code> <var>$visitor</var> </dt> <dd><p>A function or callable to be executed for each part</p></dd> <dt> <code>array&lt;string&gt;</code> <var>$parts</var> </dt> <dd><p>The list of query parts to traverse</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="type()"> type()   <span class="label">public</span> </h3> <pre data-language="php">type(): string</pre> <div class="description detailed"> <p>Returns the type of this query (select, insert, update, delete)</p> <h4>Returns</h4> <div class="list"> <code>string</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="union()"> union()   <span class="label">public</span> </h3> <pre data-language="php">union(Cake\Database\Query|string $query, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a complete query to be used in conjunction with an UNION operator with this query. This is used to combine the result set of this query with the one that will be returned by the passed query. You can add as many queries as you required by calling multiple times this method with different queries.</p> <p>By default, the UNION operator will remove duplicate rows, if you wish to include every row for all queries, use unionAll().</p> <h3>Examples</h3> <pre data-language="php">$union = (new Query($conn))-&gt;select(['id', 'title'])-&gt;from(['a' =&gt; 'articles']);
$query-&gt;select(['id', 'name'])-&gt;from(['d' =&gt; 'things'])-&gt;union($union);</pre> <p>Will produce:</p> <p><code>SELECT id, name FROM things d UNION SELECT id, title FROM articles a</code></p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\Query|string</code> <var>$query</var> </dt> <dd><p>full SQL query to be used in UNION operator</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset the list of queries to be operated or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="unionAll()"> unionAll()   <span class="label">public</span> </h3> <pre data-language="php">unionAll(Cake\Database\Query|string $query, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a complete query to be used in conjunction with the UNION ALL operator with this query. This is used to combine the result set of this query with the one that will be returned by the passed query. You can add as many queries as you required by calling multiple times this method with different queries.</p> <p>Unlike UNION, UNION ALL will not remove duplicate rows.</p> <pre data-language="php">$union = (new Query($conn))-&gt;select(['id', 'title'])-&gt;from(['a' =&gt; 'articles']);
$query-&gt;select(['id', 'name'])-&gt;from(['d' =&gt; 'things'])-&gt;unionAll($union);</pre> <p>Will produce:</p> <p><code>SELECT id, name FROM things d UNION ALL SELECT id, title FROM articles a</code></p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\Query|string</code> <var>$query</var> </dt> <dd><p>full SQL query to be used in UNION operator</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset the list of queries to be operated or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="update()"> update()   <span class="label">public</span> </h3> <pre data-language="php">update(Cake\Database\ExpressionInterface|string $table): $this</pre> <div class="description detailed"> <p>Create an update query.</p> <p>Can be combined with set() and where() methods to create update queries.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|string</code> <var>$table</var> </dt> <dd><p>The table you want to update.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="values()"> values()   <span class="label">public</span> </h3> <pre data-language="php">values(Cake\Database\Expression\ValuesExpressionCake\Database\Query|array $data): $this</pre> <div class="description detailed"> <p>Set the values for an insert query.</p> <p>Multi inserts can be performed by calling values() more than one time, or by providing an array of value sets. Additionally $data can be a Query instance to insert data from another SELECT statement.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\Expression\ValuesExpressionCake\Database\Query|array</code> <var>$data</var> </dt> <dd><p>The data to insert.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>Throws</h4> <div class="list"> <code>Cake\Database\Exception\DatabaseException</code><br> if you try to set values before declaring columns. Or if you try to set values on non-insert queries. </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="where()"> where()   <span class="label">public</span> </h3> <pre data-language="php">where(Cake\Database\ExpressionInterfaceClosure|array|string|null $conditions = null, array&lt;string, string&gt; $types = [], bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a condition or set of conditions to be used in the WHERE clause for this query. Conditions can be expressed as an array of fields as keys with comparison operators in it, the values for the array will be used for comparing the field to such literal. Finally, conditions can be expressed as a single string or an array of strings.</p> <p>When using arrays, each entry will be joined to the rest of the conditions using an <code>AND</code> operator. Consecutive calls to this function will also join the new conditions specified using the AND operator. Additionally, values can be expressed using expression objects which can include other query objects.</p> <p>Any conditions created with this methods can be used with any <code>SELECT</code>, <code>UPDATE</code> and <code>DELETE</code> type of queries.</p> <h3>Conditions using operators:</h3> <pre data-language="php">$query-&gt;where([
    'posted &gt;=' =&gt; new DateTime('3 days ago'),
    'title LIKE' =&gt; 'Hello W%',
    'author_id' =&gt; 1,
], ['posted' =&gt; 'datetime']);</pre> <p>The previous example produces:</p> <p><code>WHERE posted &gt;= 2012-01-27 AND title LIKE 'Hello W%' AND author_id = 1</code></p> <p>Second parameter is used to specify what type is expected for each passed key. Valid types can be used from the mapped with Database\Type class.</p> <h3>Nesting conditions with conjunctions:</h3> <pre data-language="php">$query-&gt;where([
    'author_id !=' =&gt; 1,
    'OR' =&gt; ['published' =&gt; true, 'posted &lt;' =&gt; new DateTime('now')],
    'NOT' =&gt; ['title' =&gt; 'Hello']
], ['published' =&gt; boolean, 'posted' =&gt; 'datetime']</pre> <p>The previous example produces:</p> <p><code>WHERE author_id = 1 AND (published = 1 OR posted &lt; '2012-02-01') AND NOT (title = 'Hello')</code></p> <p>You can nest conditions using conjunctions as much as you like. Sometimes, you may want to define 2 different options for the same key, in that case, you can wrap each condition inside a new array:</p> <p><code>$query-&gt;where(['OR' =&gt; [['published' =&gt; false], ['published' =&gt; true]])</code></p> <p>Would result in:</p> <p><code>WHERE (published = false) OR (published = true)</code></p> <p>Keep in mind that every time you call where() with the third param set to false (default), it will join the passed conditions to the previous stored list using the <code>AND</code> operator. Also, using the same array key twice in consecutive calls to this method will not override the previous value.</p> <h3>Using expressions objects:</h3> <pre data-language="php">$exp = $query-&gt;newExpr()-&gt;add(['id !=' =&gt; 100, 'author_id' != 1])-&gt;tieWith('OR');
$query-&gt;where(['published' =&gt; true], ['published' =&gt; 'boolean'])-&gt;where($exp);</pre> <p>The previous example produces:</p> <p><code>WHERE (id != 100 OR author_id != 1) AND published = 1</code></p> <p>Other Query objects that be used as conditions for any field.</p> <h3>Adding conditions in multiple steps:</h3> <p>You can use callable functions to construct complex expressions, functions receive as first argument a new QueryExpression object and this query instance as second argument. Functions must return an expression object, that will be added the list of conditions for the query using the <code>AND</code> operator.</p> <pre data-language="php">$query
  -&gt;where(['title !=' =&gt; 'Hello World'])
  -&gt;where(function ($exp, $query) {
    $or = $exp-&gt;or(['id' =&gt; 1]);
    $and = $exp-&gt;and(['id &gt;' =&gt; 2, 'id &lt;' =&gt; 10]);
   return $or-&gt;add($and);
  });</pre> <ul> <li>The previous example produces:</li> </ul> <p><code>WHERE title != 'Hello World' AND (id = 1 OR (id &gt; 2 AND id &lt; 10))</code></p> <h3>Conditions as strings:</h3> <pre data-language="php">$query-&gt;where(['articles.author_id = authors.id', 'modified IS NULL']);</pre> <p>The previous example produces:</p> <p><code>WHERE articles.author_id = authors.id AND modified IS NULL</code></p> <p>Please note that when using the array notation or the expression objects, all <em>values</em> will be correctly quoted and transformed to the correspondent database data type automatically for you, thus securing your application from SQL injections. The keys however, are not treated as unsafe input, and should be validated/sanitized.</p> <p>If you use string conditions make sure that your values are correctly quoted. The safest thing you can do is to never use string conditions.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterfaceClosure|array|string|null</code> <var>$conditions</var> <span class="label">optional</span> </dt> <dd><p>The conditions to filter on.</p></dd> <dt> <code>array&lt;string, string&gt;</code> <var>$types</var> <span class="label">optional</span> </dt> <dd><p>Associative array of type names used to bind values to query</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset conditions with passed list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>See Also</h4> <div class="list"> \Cake\Database\TypeFactory<br> \Cake\Database\Expression\QueryExpression </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="whereInList()"> whereInList()   <span class="label">public</span> </h3> <pre data-language="php">whereInList(string $field, array $values, array&lt;string, mixed&gt; $options = []): $this</pre> <div class="description detailed"> <p>Adds an IN condition or set of conditions to be used in the WHERE clause for this query.</p> <p>This method does allow empty inputs in contrast to where() if you set 'allowEmpty' to true. Be careful about using it without proper sanity checks.</p> <p>Options:</p> <ul> <li>
<code>types</code> - Associative array of type names used to bind values to query</li> <li>
<code>allowEmpty</code> - Allow empty array.</li> </ul> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$field</var> </dt> <dd><p>Field</p></dd> <dt> <code>array</code> <var>$values</var> </dt> <dd><p>Array of values</p></dd> <dt> <code>array&lt;string, mixed&gt;</code> <var>$options</var> <span class="label">optional</span> </dt> <dd><p>Options</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="whereNotInList()"> whereNotInList()   <span class="label">public</span> </h3> <pre data-language="php">whereNotInList(string $field, array $values, array&lt;string, mixed&gt; $options = []): $this</pre> <div class="description detailed"> <p>Adds a NOT IN condition or set of conditions to be used in the WHERE clause for this query.</p> <p>This method does allow empty inputs in contrast to where() if you set 'allowEmpty' to true. Be careful about using it without proper sanity checks.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$field</var> </dt> <dd><p>Field</p></dd> <dt> <code>array</code> <var>$values</var> </dt> <dd><p>Array of values</p></dd> <dt> <code>array&lt;string, mixed&gt;</code> <var>$options</var> <span class="label">optional</span> </dt> <dd><p>Options</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="whereNotInListOrNull()"> whereNotInListOrNull()   <span class="label">public</span> </h3> <pre data-language="php">whereNotInListOrNull(string $field, array $values, array&lt;string, mixed&gt; $options = []): $this</pre> <div class="description detailed"> <p>Adds a NOT IN condition or set of conditions to be used in the WHERE clause for this query. This also allows the field to be null with a IS NULL condition since the null value would cause the NOT IN condition to always fail.</p> <p>This method does allow empty inputs in contrast to where() if you set 'allowEmpty' to true. Be careful about using it without proper sanity checks.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$field</var> </dt> <dd><p>Field</p></dd> <dt> <code>array</code> <var>$values</var> </dt> <dd><p>Array of values</p></dd> <dt> <code>array&lt;string, mixed&gt;</code> <var>$options</var> <span class="label">optional</span> </dt> <dd><p>Options</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="whereNotNull()"> whereNotNull()   <span class="label">public</span> </h3> <pre data-language="php">whereNotNull(Cake\Database\ExpressionInterface|array|string $fields): $this</pre> <div class="description detailed"> <p>Convenience method that adds a NOT NULL condition to the query</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|array|string</code> <var>$fields</var> </dt> <dd><p>A single field or expressions or a list of them that should be not null.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="whereNull()"> whereNull()   <span class="label">public</span> </h3> <pre data-language="php">whereNull(Cake\Database\ExpressionInterface|array|string $fields): $this</pre> <div class="description detailed"> <p>Convenience method that adds a IS NULL condition to the query</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|array|string</code> <var>$fields</var> </dt> <dd><p>A single field or expressions or a list of them that should be null.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="window()"> window()   <span class="label">public</span> </h3> <pre data-language="php">window(string $name, Cake\Database\Expression\WindowExpressionClosure $window, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a named window expression.</p> <p>You are responsible for adding windows in the order your database requires.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$name</var> </dt> <dd><p>Window name</p></dd> <dt> <code>Cake\Database\Expression\WindowExpressionClosure</code> <var>$window</var> </dt> <dd><p>Window expression</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>Clear all previous query window expressions</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="with()"> with()   <span class="label">public</span> </h3> <pre data-language="php">with(Cake\Database\Expression\CommonTableExpressionClosure $cte, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a new common table expression (CTE) to the query.</p> <h3>Examples:</h3> <p>Common table expressions can either be passed as preconstructed expression objects:</p> <pre data-language="php">$cte = new \Cake\Database\Expression\CommonTableExpression(
    'cte',
    $connection
        -&gt;newQuery()
        -&gt;select('*')
        -&gt;from('articles')
);

$query-&gt;with($cte);</pre> <p>or returned from a closure, which will receive a new common table expression object as the first argument, and a new blank query object as the second argument:</p> <pre data-language="php">$query-&gt;with(function (
    \Cake\Database\Expression\CommonTableExpression $cte,
    \Cake\Database\Query $query
 ) {
    $cteQuery = $query
        -&gt;select('*')
        -&gt;from('articles');

return $cte
        -&gt;name('cte')
        -&gt;query($cteQuery);
});</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\Expression\CommonTableExpressionClosure</code> <var>$cte</var> </dt> <dd><p>The CTE to add.</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>Whether to reset the list of CTEs.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> </div> <div class="section"> <h2>Property Detail</h2> <div class="property-detail">  <h3 class="property-name" id="$_connection"> <var>$_connection</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>Connection instance to be used to execute this query.</p> <h4>Type</h4> <div class="list"> <code>Cake\Database\Connection</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_deleteParts"> <var>$_deleteParts</var>   <span class="label">protected</span> <span class="label">deprecated</span> </h3> <div class="description detailed"> <p>The list of query clauses to traverse for generating a DELETE statement</p> <h4>Type</h4> <div class="list"> <code>array&lt;string&gt;</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_dirty"> <var>$_dirty</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>Indicates whether internal state of this query was changed, this is used to discard internal cached objects such as the transformed query or the reference to the executed statement.</p> <h4>Type</h4> <div class="list"> <code>bool</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_functionsBuilder"> <var>$_functionsBuilder</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>Instance of functions builder object used for generating arbitrary SQL functions.</p> <h4>Type</h4> <div class="list"> <code>Cake\Database\FunctionsBuilder|null</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_insertParts"> <var>$_insertParts</var>   <span class="label">protected</span> <span class="label">deprecated</span> </h3> <div class="description detailed"> <p>The list of query clauses to traverse for generating an INSERT statement</p> <h4>Type</h4> <div class="list"> <code>array&lt;string&gt;</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_iterator"> <var>$_iterator</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>Statement object resulting from executing this query.</p> <h4>Type</h4> <div class="list"> <code>Cake\Database\StatementInterface|null</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_parts"> <var>$_parts</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>List of SQL parts that will be used to build this query.</p> <h4>Type</h4> <div class="list"> <code>array&lt;string, mixed&gt;</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_resultDecorators"> <var>$_resultDecorators</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>A list of callback functions to be called to alter each row from resulting statement upon retrieval. Each one of the callback function will receive the row array as first argument.</p> <h4>Type</h4> <div class="list"> <code>array&lt;callable&gt;</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_selectParts"> <var>$_selectParts</var>   <span class="label">protected</span> <span class="label">deprecated</span> </h3> <div class="description detailed"> <p>The list of query clauses to traverse for generating a SELECT statement</p> <h4>Type</h4> <div class="list"> <code>array&lt;string&gt;</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_selectTypeMap"> <var>$_selectTypeMap</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>The Type map for fields in the select clause</p> <h4>Type</h4> <div class="list"> <code>Cake\Database\TypeMap|null</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_type"> <var>$_type</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>Type of this query (select, insert, update, delete).</p> <h4>Type</h4> <div class="list"> <code>string</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_typeMap"> <var>$_typeMap</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <h4>Type</h4> <div class="list"> <code>Cake\Database\TypeMap|null</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_updateParts"> <var>$_updateParts</var>   <span class="label">protected</span> <span class="label">deprecated</span> </h3> <div class="description detailed"> <p>The list of query clauses to traverse for generating an UPDATE statement</p> <h4>Type</h4> <div class="list"> <code>array&lt;string&gt;</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_useBufferedResults"> <var>$_useBufferedResults</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>Boolean for tracking whether buffered results are enabled.</p> <h4>Type</h4> <div class="list"> <code>bool</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$_valueBinder"> <var>$_valueBinder</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>The object responsible for generating query placeholders and temporarily store values associated to each of those.</p> <h4>Type</h4> <div class="list"> <code>Cake\Database\ValueBinder|null</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$typeCastEnabled"> <var>$typeCastEnabled</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>Tracking flag to disable casting</p> <h4>Type</h4> <div class="list"> <code>bool</code><br> </div> </div> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;present The Cake Software Foundation, Inc.<br>Licensed under the MIT License.<br>CakePHP is a registered trademark of Cake Software Foundation, Inc.<br>We are not endorsed by or affiliated with CakePHP.<br>
    <a href="https://api.cakephp.org/4.4/class-Cake.Database.Query.html" class="_attribution-link">https://api.cakephp.org/4.4/class-Cake.Database.Query.html</a>
  </p>
</div>
