<h1> Class CaseStatementExpression  </h1> <div class="description"> <p>Represents a SQL case statement with a fluid API</p> </div> <div class="info"> <b>Namespace:</b> <a href="namespace-cake.database.expression.html">Cake\Database\Expression</a><br> </div> <div class="section"> <h2>Property Summary</h2> <ul class="member-summary properties"> <li class="clearfix"> <div class="name"> <a href="#%24_typeMap">$_typeMap</a> <span class="attributes"> <span class="label">public</span> <span class="label annotation">@property</span> </span> </div> <div class="property-type"><code>Cake\Database\TypeMap</code></div> <div class="description"> <p>The type map to use when using an array of conditions for the <code>WHEN</code> value.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24else">$else</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>Cake\Database\ExpressionInterface|object|scalar|null</code></div> <div class="description"> <p>The else part result value.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24elseType">$elseType</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>string|null</code></div> <div class="description"> <p>The else part result type.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24isSimpleVariant">$isSimpleVariant</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>bool</code></div> <div class="description"> <p>Whether this is a simple case expression.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24returnType">$returnType</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>string|null</code></div> <div class="description"> <p>The return type.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24validClauseNames">$validClauseNames</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>array&lt;string&gt;</code></div> <div class="description"> <p>The names of the clauses that are valid for use with the <code>clause()</code> method.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24value">$value</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>Cake\Database\ExpressionInterface|object|scalar|null</code></div> <div class="description"> <p>The case value.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24valueType">$valueType</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>string|null</code></div> <div class="description"> <p>The case value type.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24when">$when</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>arrayCake\Database\Expression\WhenThenExpression&gt;</code></div> <div class="description"> <p>The <code>WHEN ... THEN ...</code> expressions.</p> </div> </li> <li class="clearfix"> <div class="name"> <a href="#%24whenBuffer">$whenBuffer</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>array|null</code></div> <div class="description"> <p>Buffer that holds values and types for use with <code>then()</code>.</p> </div> </li> </ul> </div> <div class="section"> <h2>Method Summary</h2> <ul class="member-summary"> <li class="clearfix"> <h5 class="function-name"> <a href="#__clone()">__clone()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Clones the inner expression objects.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#__construct()">__construct()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Constructor.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#_castToExpression()">_castToExpression()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Conditionally converts the passed value to an ExpressionInterface object if the type class implements the ExpressionTypeInterface. Otherwise, returns the value unmodified.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#_requiresToExpressionCasting()">_requiresToExpressionCasting()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Returns an array with the types that require values to be casted to expressions, out of the list of type names passed as parameter.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#clause()">clause()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the available data for the given clause.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#compileNullableValue()">compileNullableValue()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Compiles a nullable value to SQL.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#else()">else()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Sets the <code>ELSE</code> result value.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#getDefaultTypes()">getDefaultTypes()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Gets default types of current type map.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#getReturnType()">getReturnType()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the abstract type that this expression will return.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#getTypeMap()">getTypeMap()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the existing type map.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#inferType()">inferType()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Infers the abstract type for the given value.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#setDefaultTypes()">setDefaultTypes()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Overwrite the default type mappings for fields in the implementing object.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#setReturnType()">setReturnType()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Sets the abstract type that this expression will return.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#setTypeMap()">setTypeMap()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Creates a new TypeMap if $typeMap is an array, otherwise exchanges it for the given one.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#sql()">sql()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Converts the Node into a SQL string fragment.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#then()">then()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Sets the <code>THEN</code> result value for the last <code>WHEN ... THEN ...</code> statement that was opened using <code>when()</code>.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#traverse()">traverse()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Iterates over each part of the expression recursively for every level of the expressions tree and executes the $callback callable passing as first parameter the instance of the expression currently being iterated.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#when()">when()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Sets the <code>WHEN</code> value for a <code>WHEN ... THEN ...</code> expression, or a self-contained expression that holds both the value for <code>WHEN</code> and the value for <code>THEN</code>.</p> </div> </li> </ul> <div class="section"> <h2>Method Detail</h2> <div class="method-detail">  <h3 class="method-name" id="__clone()"> __clone()   <span class="label">public</span> </h3> <pre data-language="php">__clone(): void</pre> <div class="description detailed"> <p>Clones the inner expression objects.</p> <h4>Returns</h4> <div class="list"> <code>void</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="__construct()"> __construct()   <span class="label">public</span> </h3> <pre data-language="php">__construct(Cake\Database\ExpressionInterface|object|scalar|null $value = null, string|null $type = null)</pre> <div class="description detailed"> <p>Constructor.</p> <p>When a value is set, the syntax generated is <code>CASE case_value WHEN when_value ... END</code> (simple case), where the <code>when_value</code>'s are compared against the <code>case_value</code>.</p> <p>When no value is set, the syntax generated is <code>CASE WHEN when_conditions ... END</code> (searched case), where the conditions hold the comparisons.</p> <p>Note that <code>null</code> is a valid case value, and thus should only be passed if you actually want to create the simple case expression variant!</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|object|scalar|null</code> <var>$value</var> <span class="label">optional</span> </dt> <dd><p>The case value.</p></dd> <dt> <code>string|null</code> <var>$type</var> <span class="label">optional</span> </dt> <dd><p>The case value type. If no type is provided, the type will be tried to be inferred from the value.</p></dd> </dl> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="_castToExpression()"> _castToExpression()   <span class="label">protected</span> </h3> <pre data-language="php">_castToExpression(mixed $value, string|null $type = null): mixed</pre> <div class="description detailed"> <p>Conditionally converts the passed value to an ExpressionInterface object if the type class implements the ExpressionTypeInterface. Otherwise, returns the value unmodified.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>mixed</code> <var>$value</var> </dt> <dd><p>The value to convert to ExpressionInterface</p></dd> <dt> <code>string|null</code> <var>$type</var> <span class="label">optional</span> </dt> <dd><p>The type name</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>mixed</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="_requiresToExpressionCasting()"> _requiresToExpressionCasting()   <span class="label">protected</span> </h3> <pre data-language="php">_requiresToExpressionCasting(array $types): array</pre> <div class="description detailed"> <p>Returns an array with the types that require values to be casted to expressions, out of the list of type names passed as parameter.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array</code> <var>$types</var> </dt> <dd><p>List of type names</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>array</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="clause()"> clause()   <span class="label">public</span> </h3> <pre data-language="php">clause(string $clause): Cake\Database\ExpressionInterface|object|arrayCake\Database\Expression\WhenThenExpression&gt;|scalar|null</pre> <div class="description detailed"> <p>Returns the available data for the given clause.</p> <h3>Available clauses</h3> <p>The following clause names are available:</p> <ul> <li>
<code>value</code>: The case value for a <code>CASE case_value WHEN ...</code> expression.</li> <li>
<code>when</code>: An array of <code>WHEN ... THEN ...</code> expressions.</li> <li>
<code>else</code>: The <code>ELSE</code> result value.</li> </ul> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$clause</var> </dt> <dd><p>The name of the clause to obtain.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>Cake\Database\ExpressionInterface|object|arrayCake\Database\Expression\WhenThenExpression&gt;|scalar|null</code><br> </div> <h4>Throws</h4> <div class="list"> <code>InvalidArgumentException</code><br> In case the given clause name is invalid. </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="compileNullableValue()"> compileNullableValue()   <span class="label">protected</span> </h3> <pre data-language="php">compileNullableValue(Cake\Database\ValueBinder $binder, Cake\Database\ExpressionInterface|object|scalar|null $value, string|null $type = null): string</pre> <div class="description detailed"> <p>Compiles a nullable value to SQL.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ValueBinder</code> <var>$binder</var> </dt> <dd><p>The value binder to use.</p></dd> <dt> <code>Cake\Database\ExpressionInterface|object|scalar|null</code> <var>$value</var> </dt> <dd><p>The value to compile.</p></dd> <dt> <code>string|null</code> <var>$type</var> <span class="label">optional</span> </dt> <dd><p>The value type.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>string</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="else()"> else()   <span class="label">public</span> </h3> <pre data-language="php">else(Cake\Database\ExpressionInterface|object|scalar|null $result, string|null $type = null): $this</pre> <div class="description detailed"> <p>Sets the <code>ELSE</code> result value.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|object|scalar|null</code> <var>$result</var> </dt> <dd><p>The result value.</p></dd> <dt> <code>string|null</code> <var>$type</var> <span class="label">optional</span> </dt> <dd><p>The result type. If no type is provided, the type will be tried to be inferred from the value.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>Throws</h4> <div class="list"> <code>LogicException</code><br> In case a closing `then()` call is required before calling this method.<br> <code>InvalidArgumentException</code><br> In case the `$result` argument is neither a scalar value, nor an object, an instance of `\Cake\Database\ExpressionInterface`, or `null`. </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="getDefaultTypes()"> getDefaultTypes()   <span class="label">public</span> </h3> <pre data-language="php">getDefaultTypes(): array&lt;int|string, string&gt;</pre> <div class="description detailed"> <p>Gets default types of current type map.</p> <h4>Returns</h4> <div class="list"> <code>array&lt;int|string, string&gt;</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="getReturnType()"> getReturnType()   <span class="label">public</span> </h3> <pre data-language="php">getReturnType(): string</pre> <div class="description detailed"> <p>Returns the abstract type that this expression will return.</p> <p>If no type has been explicitly set via <code>setReturnType()</code>, this method will try to obtain the type from the result types of the <code>then()</code> and <code>else()</code>calls. All types must be identical in order for this to work, otherwise the type will default to <code>string</code>.</p> <h4>Returns</h4> <div class="list"> <code>string</code><br> </div> <h4>See Also</h4> <div class="list"> CaseStatementExpression::then() </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="getTypeMap()"> getTypeMap()   <span class="label">public</span> </h3> <pre data-language="php">getTypeMap(): Cake\Database\TypeMap</pre> <div class="description detailed"> <p>Returns the existing type map.</p> <h4>Returns</h4> <div class="list"> <code>Cake\Database\TypeMap</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="inferType()"> inferType()   <span class="label">protected</span> </h3> <pre data-language="php">inferType(mixed $value): string|null</pre> <div class="description detailed"> <p>Infers the abstract type for the given value.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>mixed</code> <var>$value</var> </dt> <dd><p>The value for which to infer the type.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>string|null</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="setDefaultTypes()"> setDefaultTypes()   <span class="label">public</span> </h3> <pre data-language="php">setDefaultTypes(array&lt;int|string, string&gt; $types): $this</pre> <div class="description detailed"> <p>Overwrite the default type mappings for fields in the implementing object.</p> <p>This method is useful if you need to set type mappings that are shared across multiple functions/expressions in a query.</p> <p>To add a default without overwriting existing ones use <code>getTypeMap()-&gt;addDefaults()</code></p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array&lt;int|string, string&gt;</code> <var>$types</var> </dt> <dd><p>The array of types to set.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>See Also</h4> <div class="list"> \Cake\Database\TypeMap::setDefaults() </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="setReturnType()"> setReturnType()   <span class="label">public</span> </h3> <pre data-language="php">setReturnType(string $type): $this</pre> <div class="description detailed"> <p>Sets the abstract type that this expression will return.</p> <p>If no type is being explicitly set via this method, then the <code>getReturnType()</code> method will try to infer the type from the result types of the <code>then()</code> and <code>else()</code>calls.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$type</var> </dt> <dd><p>The type name to use.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="setTypeMap()"> setTypeMap()   <span class="label">public</span> </h3> <pre data-language="php">setTypeMap(Cake\Database\TypeMap|array $typeMap): $this</pre> <div class="description detailed"> <p>Creates a new TypeMap if $typeMap is an array, otherwise exchanges it for the given one.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\TypeMap|array</code> <var>$typeMap</var> </dt> <dd><p>Creates a TypeMap if array, otherwise sets the given TypeMap</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="sql()"> sql()   <span class="label">public</span> </h3> <pre data-language="php">sql(Cake\Database\ValueBinder $binder): string</pre> <div class="description detailed"> <p>Converts the Node into a SQL string fragment.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ValueBinder</code> <var>$binder</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>string</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="then()"> then()   <span class="label">public</span> </h3> <pre data-language="php">then(Cake\Database\ExpressionInterface|object|scalar|null $result, string|null $type = null): $this</pre> <div class="description detailed"> <p>Sets the <code>THEN</code> result value for the last <code>WHEN ... THEN ...</code> statement that was opened using <code>when()</code>.</p> <h3>Order based syntax</h3> <p>This method can only be invoked in case <code>when()</code> was previously used with a value other than a closure or an instance of <code>\Cake\Database\Expression\WhenThenExpression</code>:</p> <pre data-language="php">$case
    -&gt;when(['Table.column' =&gt; true])
    -&gt;then('Yes')
    -&gt;when(['Table.column' =&gt; false])
    -&gt;then('No')
    -&gt;else('Maybe');</pre> <p>The following would all fail with an exception:</p> <pre data-language="php">$case
    -&gt;when(['Table.column' =&gt; true])
    -&gt;when(['Table.column' =&gt; false])
    // ...</pre> <pre data-language="php">$case
    -&gt;when(['Table.column' =&gt; true])
    -&gt;else('Maybe')
    // ...</pre> <pre data-language="php">$case
    -&gt;then('Yes')
    // ...</pre> <pre data-language="php">$case
    -&gt;when(['Table.column' =&gt; true])
    -&gt;then('Yes')
    -&gt;then('No')
    // ...</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|object|scalar|null</code> <var>$result</var> </dt> <dd><p>The result value.</p></dd> <dt> <code>string|null</code> <var>$type</var> <span class="label">optional</span> </dt> <dd><p>The result type. If no type is provided, the type will be tried to be inferred from the value.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>Throws</h4> <div class="list"> <code>LogicException</code><br> In case `when()` wasn't previously called with a value other than a closure or an instance of `\Cake\Database\Expression\WhenThenExpression`. </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="traverse()"> traverse()   <span class="label">public</span> </h3> <pre data-language="php">traverse(Closure $callback): $this</pre> <div class="description detailed"> <p>Iterates over each part of the expression recursively for every level of the expressions tree and executes the $callback callable passing as first parameter the instance of the expression currently being iterated.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Closure</code> <var>$callback</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="when()"> when()   <span class="label">public</span> </h3> <pre data-language="php">when(Cake\Database\ExpressionInterfaceClosure|object|array|scalar $when, array&lt;string, string&gt;|string|null $type = null): $this</pre> <div class="description detailed"> <p>Sets the <code>WHEN</code> value for a <code>WHEN ... THEN ...</code> expression, or a self-contained expression that holds both the value for <code>WHEN</code> and the value for <code>THEN</code>.</p> <h3>Order based syntax</h3> <p>When passing a value other than a self-contained <code>\Cake\Database\Expression\WhenThenExpression</code>, instance, the <code>WHEN ... THEN ...</code> statement must be closed off with a call to <code>then()</code> before invoking <code>when()</code> again or <code>else()</code>:</p> <pre data-language="php">$queryExpression
    -&gt;case($query-&gt;identifier('Table.column'))
    -&gt;when(true)
    -&gt;then('Yes')
    -&gt;when(false)
    -&gt;then('No')
    -&gt;else('Maybe');</pre> <h3>Self-contained expressions</h3> <p>When passing an instance of <code>\Cake\Database\Expression\WhenThenExpression</code>, being it directly, or via a callable, then there is no need to close using <code>then()</code> on this object, instead the statement will be closed on the <code>\Cake\Database\Expression\WhenThenExpression</code> object using <code>\Cake\Database\Expression\WhenThenExpression::then()</code>.</p> <p>Callables will receive an instance of <code>\Cake\Database\Expression\WhenThenExpression</code>, and must return one, being it the same object, or a custom one:</p> <pre data-language="php">$queryExpression
    -&gt;case()
    -&gt;when(function (\Cake\Database\Expression\WhenThenExpression $whenThen) {
        return $whenThen
            -&gt;when(['Table.column' =&gt; true])
            -&gt;then('Yes');
    })
    -&gt;when(function (\Cake\Database\Expression\WhenThenExpression $whenThen) {
        return $whenThen
            -&gt;when(['Table.column' =&gt; false])
            -&gt;then('No');
    })
    -&gt;else('Maybe');</pre> <h3>Type handling</h3> <p>The types provided via the <code>$type</code> argument will be merged with the type map set for this expression. When using callables for <code>$when</code>, the <code>\Cake\Database\Expression\WhenThenExpression</code> instance received by the callables will inherit that type map, however the types passed here will <em>not</em> be merged in case of using callables, instead the types must be passed in <code>\Cake\Database\Expression\WhenThenExpression::when()</code>:</p> <pre data-language="php">$queryExpression
    -&gt;case()
    -&gt;when(function (\Cake\Database\Expression\WhenThenExpression $whenThen) {
        return $whenThen
            -&gt;when(['unmapped_column' =&gt; true], ['unmapped_column' =&gt; 'bool'])
            -&gt;then('Yes');
    })
    -&gt;when(function (\Cake\Database\Expression\WhenThenExpression $whenThen) {
        return $whenThen
            -&gt;when(['unmapped_column' =&gt; false], ['unmapped_column' =&gt; 'bool'])
            -&gt;then('No');
    })
    -&gt;else('Maybe');</pre> <h3>User data safety</h3> <p>When passing user data, be aware that allowing a user defined array to be passed, is a potential SQL injection vulnerability, as it allows for raw SQL to slip in!</p> <p>The following is <em>unsafe</em> usage that must be avoided:</p> <pre data-language="php">$case
     -&gt;when($userData)</pre> <p>A safe variant for the above would be to define a single type for the value:</p> <pre data-language="php">$case
     -&gt;when($userData, 'integer')</pre> <p>This way an exception would be triggered when an array is passed for the value, thus preventing raw SQL from slipping in, and all other types of values would be forced to be bound as an integer.</p> <p>Another way to safely pass user data is when using a conditions array, and passing user data only on the value side of the array entries, which will cause them to be bound:</p> <pre data-language="php">$case
     -&gt;when([
         'Table.column' =&gt; $userData,
     ])</pre> <p>Lastly, data can also be bound manually:</p> <pre data-language="php">$query
     -&gt;select([
         'val' =&gt; $query-&gt;newExpr()
             -&gt;case()
             -&gt;when($query-&gt;newExpr(':userData'))
             -&gt;then(123)
     ])
     -&gt;bind(':userData', $userData, 'integer')</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterfaceClosure|object|array|scalar</code> <var>$when</var> </dt> <dd><p>The <code>WHEN</code> value. When using an array of conditions, it must be compatible with <code>\Cake\Database\Query::where()</code>. Note that this argument is <em>not</em> completely safe for use with user data, as a user supplied array would allow for raw SQL to slip in! If you plan to use user data, either pass a single type for the <code>$type</code> argument (which forces the <code>$when</code> value to be a non-array, and then always binds the data), use a conditions array where the user data is only passed on the value side of the array entries, or custom bindings!</p></dd> <dt> <code>array&lt;string, string&gt;|string|null</code> <var>$type</var> <span class="label">optional</span> </dt> <dd><p>The when value type. Either an associative array when using array style conditions, or else a string. If no type is provided, the type will be tried to be inferred from the value.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>Throws</h4> <div class="list"> <code>LogicException</code><br> In case this a closing `then()` call is required before calling this method.<br> <code>LogicException</code><br> In case the callable doesn't return an instance of `\Cake\Database\Expression\WhenThenExpression`. </div> </div> </div> </div> <div class="section"> <h2>Property Detail</h2> <div class="property-detail">  <h3 class="property-name" id="$_typeMap"> <var>$_typeMap</var>   <span class="label">public</span> <span class="label annotation">@property</span> </h3> <div class="description detailed"> <p>The type map to use when using an array of conditions for the <code>WHEN</code> value.</p> <h4>Type</h4> <div class="list"> <code>Cake\Database\TypeMap</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$else"> <var>$else</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>The else part result value.</p> <h4>Type</h4> <div class="list"> <code>Cake\Database\ExpressionInterface|object|scalar|null</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$elseType"> <var>$elseType</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>The else part result type.</p> <h4>Type</h4> <div class="list"> <code>string|null</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$isSimpleVariant"> <var>$isSimpleVariant</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>Whether this is a simple case expression.</p> <h4>Type</h4> <div class="list"> <code>bool</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$returnType"> <var>$returnType</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>The return type.</p> <h4>Type</h4> <div class="list"> <code>string|null</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$validClauseNames"> <var>$validClauseNames</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>The names of the clauses that are valid for use with the <code>clause()</code> method.</p> <h4>Type</h4> <div class="list"> <code>array&lt;string&gt;</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$value"> <var>$value</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>The case value.</p> <h4>Type</h4> <div class="list"> <code>Cake\Database\ExpressionInterface|object|scalar|null</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$valueType"> <var>$valueType</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>The case value type.</p> <h4>Type</h4> <div class="list"> <code>string|null</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$when"> <var>$when</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>The <code>WHEN ... THEN ...</code> expressions.</p> <h4>Type</h4> <div class="list"> <code>arrayCake\Database\Expression\WhenThenExpression&gt;</code><br> </div> </div> </div> <div class="property-detail">  <h3 class="property-name" id="$whenBuffer"> <var>$whenBuffer</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>Buffer that holds values and types for use with <code>then()</code>.</p> <h4>Type</h4> <div class="list"> <code>array|null</code><br> </div> </div> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;present The Cake Software Foundation, Inc.<br>Licensed under the MIT License.<br>CakePHP is a registered trademark of Cake Software Foundation, Inc.<br>We are not endorsed by or affiliated with CakePHP.<br>
    <a href="https://api.cakephp.org/4.4/class-Cake.Database.Expression.CaseStatementExpression.html" class="_attribution-link">https://api.cakephp.org/4.4/class-Cake.Database.Expression.CaseStatementExpression.html</a>
  </p>
</div>
