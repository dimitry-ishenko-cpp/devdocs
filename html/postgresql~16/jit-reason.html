<h1>32.1. What Is JIT compilation? </h1>    <div class="toc"> <dl class="toc"> <dt><a href="jit-reason.html#JIT-ACCELERATED-OPERATIONS">32.1.1. JIT Accelerated Operations</a></dt> <dt><a href="jit-reason.html#JIT-INLINING">32.1.2. Inlining</a></dt> <dt><a href="jit-reason.html#JIT-OPTIMIZATION">32.1.3. Optimization</a></dt> </dl> </div> <p>Just-in-Time (JIT) compilation is the process of turning some form of interpreted program evaluation into a native program, and doing so at run time. For example, instead of using general-purpose code that can evaluate arbitrary SQL expressions to evaluate a particular SQL predicate like <code class="literal">WHERE a.col = 3</code>, it is possible to generate a function that is specific to that expression and can be natively executed by the CPU, yielding a speedup.</p> <p>PostgreSQL has builtin support to perform JIT compilation using <a class="ulink" href="https://llvm.org/" target="_top">LLVM</a> when PostgreSQL is built with <a class="link" href="https://www.postgresql.org/docs/16/install-make.html#CONFIGURE-WITH-LLVM"><code class="literal">--with-llvm</code></a>.</p> <p>See <code class="filename">src/backend/jit/README</code> for further details.</p> <div class="sect2" id="JIT-ACCELERATED-OPERATIONS">    <h2 class="title">32.1.1. JIT Accelerated Operations </h2>    <p>Currently PostgreSQL's JIT implementation has support for accelerating expression evaluation and tuple deforming. Several other operations could be accelerated in the future.</p> <p>Expression evaluation is used to evaluate <code class="literal">WHERE</code> clauses, target lists, aggregates and projections. It can be accelerated by generating code specific to each case.</p> <p>Tuple deforming is the process of transforming an on-disk tuple (see <a class="xref" href="storage-page-layout.html#STORAGE-TUPLE-LAYOUT" title="73.6.1. Table Row Layout">Section 73.6.1</a>) into its in-memory representation. It can be accelerated by creating a function specific to the table layout and the number of columns to be extracted.</p> </div> <div class="sect2" id="JIT-INLINING">    <h2 class="title">32.1.2. Inlining </h2>    <p>PostgreSQL is very extensible and allows new data types, functions, operators and other database objects to be defined; see <a class="xref" href="https://www.postgresql.org/docs/16/extend.html" title="Chapter 38. Extending SQL">Chapter 38</a>. In fact the built-in objects are implemented using nearly the same mechanisms. This extensibility implies some overhead, for example due to function calls (see <a class="xref" href="https://www.postgresql.org/docs/16/xfunc.html" title="38.3. User-Defined Functions">Section 38.3</a>). To reduce that overhead, JIT compilation can inline the bodies of small functions into the expressions using them. That allows a significant percentage of the overhead to be optimized away.</p> </div> <div class="sect2" id="JIT-OPTIMIZATION">    <h2 class="title">32.1.3. Optimization </h2>    <p>LLVM has support for optimizing generated code. Some of the optimizations are cheap enough to be performed whenever JIT is used, while others are only beneficial for longer-running queries. See <a class="ulink" href="https://llvm.org/docs/Passes.html#transform-passes" target="_top">https://llvm.org/docs/Passes.html#transform-passes</a> for more details about optimizations.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996&ndash;2023 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/16/jit-reason.html" class="_attribution-link">https://www.postgresql.org/docs/16/jit-reason.html</a>
  </p>
</div>
