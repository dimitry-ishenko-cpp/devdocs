<h1>8.1. Numeric Types </h1>    <div class="toc"> <dl class="toc"> <dt><a href="datatype-numeric.html#DATATYPE-INT">8.1.1. Integer Types</a></dt> <dt><a href="datatype-numeric.html#DATATYPE-NUMERIC-DECIMAL">8.1.2. Arbitrary Precision Numbers</a></dt> <dt><a href="datatype-numeric.html#DATATYPE-FLOAT">8.1.3. Floating-Point Types</a></dt> <dt><a href="datatype-numeric.html#DATATYPE-SERIAL">8.1.4. Serial Types</a></dt> </dl> </div> <p>Numeric types consist of two-, four-, and eight-byte integers, four- and eight-byte floating-point numbers, and selectable-precision decimals. <a class="xref" href="datatype-numeric.html#DATATYPE-NUMERIC-TABLE" title="Table 8.2. Numeric Types">Table 8.2</a> lists the available types.</p> <div class="table" id="DATATYPE-NUMERIC-TABLE"> <p class="title"><strong>Table 8.2. Numeric Types</strong></p> <div class="table-contents"> <table class="table" summary="Numeric Types"> <colgroup> <col class="col1"> <col class="col2"> <col class="col3"> <col class="col4"> </colgroup> <thead> <tr> <th>Name</th> <th>Storage Size</th> <th>Description</th> <th>Range</th> </tr> </thead> <tbody> <tr> <td><code class="type" id="smallint">smallint</code></td> <td>2 bytes</td> <td>small-range integer</td> <td>-32768 to +32767</td> </tr> <tr> <td><code class="type" id="integer">integer</code></td> <td>4 bytes</td> <td>typical choice for integer</td> <td>-2147483648 to +2147483647</td> </tr> <tr> <td><code class="type" id="bigint">bigint</code></td> <td>8 bytes</td> <td>large-range integer</td> <td>-9223372036854775808 to +9223372036854775807</td> </tr> <tr> <td><code class="type" id="decimal">decimal</code></td> <td>variable</td> <td>user-specified precision, exact</td> <td>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</td> </tr> <tr> <td><code class="type" id="numeric">numeric</code></td> <td>variable</td> <td>user-specified precision, exact</td> <td>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</td> </tr> <tr> <td><code class="type" id="real">real</code></td> <td>4 bytes</td> <td>variable-precision, inexact</td> <td>6 decimal digits precision</td> </tr> <tr> <td><code class="type" id="double32precision">double precision</code></td> <td>8 bytes</td> <td>variable-precision, inexact</td> <td>15 decimal digits precision</td> </tr> <tr> <td><code class="type" id="smallserial">smallserial</code></td> <td>2 bytes</td> <td>small autoincrementing integer</td> <td>1 to 32767</td> </tr> <tr> <td><code class="type" id="serial">serial</code></td> <td>4 bytes</td> <td>autoincrementing integer</td> <td>1 to 2147483647</td> </tr> <tr> <td><code class="type" id="bigserial">bigserial</code></td> <td>8 bytes</td> <td>large autoincrementing integer</td> <td>1 to 9223372036854775807</td> </tr> </tbody> </table> </div> </div> <p>The syntax of constants for the numeric types is described in <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS" title="4.1.2. Constants">Section 4.1.2</a>. The numeric types have a full set of corresponding arithmetic operators and functions. Refer to <a class="xref" href="https://www.postgresql.org/docs/16/functions.html" title="Chapter 9. Functions and Operators">Chapter 9</a> for more information. The following sections describe the types in detail.</p> <div class="sect2" id="id-1.5.7.9.6.7">    <h2 class="title">8.1.1. Integer Types </h2>    <p>The types <code class="type">smallint</code>, <code class="type">integer</code>, and <code class="type">bigint</code> store whole numbers, that is, numbers without fractional components, of various ranges. Attempts to store values outside of the allowed range will result in an error.</p> <p>The type <code class="type">integer</code> is the common choice, as it offers the best balance between range, storage size, and performance. The <code class="type">smallint</code> type is generally only used if disk space is at a premium. The <code class="type">bigint</code> type is designed to be used when the range of the <code class="type">integer</code> type is insufficient.</p> <p>SQL only specifies the integer types <code class="type">integer</code> (or <code class="type">int</code>), <code class="type">smallint</code>, and <code class="type">bigint</code>. The type names <code class="type">int2</code>, <code class="type">int4</code>, and <code class="type">int8</code> are extensions, which are also used by some other SQL database systems.</p> </div> <div class="sect2" id="id-1.5.7.9.7.15">    <h2 class="title">8.1.2. Arbitrary Precision Numbers </h2>    <p>The type <code class="type">numeric</code> can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with <code class="type">numeric</code> values yield exact results where possible, e.g., addition, subtraction, multiplication. However, calculations on <code class="type">numeric</code> values are very slow compared to the integer types, or to the floating-point types described in the next section.</p> <p>We use the following terms below: The <em class="firstterm">precision</em> of a <code class="type">numeric</code> is the total count of significant digits in the whole number, that is, the number of digits to both sides of the decimal point. The <em class="firstterm">scale</em> of a <code class="type">numeric</code> is the count of decimal digits in the fractional part, to the right of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4. Integers can be considered to have a scale of zero.</p> <p>Both the maximum precision and the maximum scale of a <code class="type">numeric</code> column can be configured. To declare a column of type <code class="type">numeric</code> use the syntax:</p> <pre data-language="sql">
NUMERIC(precision, scale)
</pre> <p>The precision must be positive, while the scale may be positive or negative (see below). Alternatively:</p> <pre data-language="sql">
NUMERIC(precision)
</pre> <p>selects a scale of 0. Specifying:</p> <pre data-language="sql">
NUMERIC
</pre> <p>without any precision or scale creates an <span class="quote">“<span class="quote">unconstrained numeric</span>”</span> column in which numeric values of any length can be stored, up to the implementation limits. A column of this kind will not coerce input values to any particular scale, whereas <code class="type">numeric</code> columns with a declared scale will coerce input values to that scale. (The SQL standard requires a default scale of 0, i.e., coercion to integer precision. We find this a bit useless. If you're concerned about portability, always specify the precision and scale explicitly.)</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>The maximum precision that can be explicitly specified in a <code class="type">numeric</code> type declaration is 1000. An unconstrained <code class="type">numeric</code> column is subject to the limits described in <a class="xref" href="datatype-numeric.html#DATATYPE-NUMERIC-TABLE" title="Table 8.2. Numeric Types">Table 8.2</a>.</p> </blockquote> <p>If the scale of a value to be stored is greater than the declared scale of the column, the system will round the value to the specified number of fractional digits. Then, if the number of digits to the left of the decimal point exceeds the declared precision minus the declared scale, an error is raised. For example, a column declared as</p> <pre data-language="sql">
NUMERIC(3, 1)
</pre> <p>will round values to 1 decimal place and can store values between -99.9 and 99.9, inclusive.</p> <p>Beginning in PostgreSQL 15, it is allowed to declare a <code class="type">numeric</code> column with a negative scale. Then values will be rounded to the left of the decimal point. The precision still represents the maximum number of non-rounded digits. Thus, a column declared as</p> <pre data-language="sql">
NUMERIC(2, -3)
</pre> <p>will round values to the nearest thousand and can store values between -99000 and 99000, inclusive. It is also allowed to declare a scale larger than the declared precision. Such a column can only hold fractional values, and it requires the number of zero digits just to the right of the decimal point to be at least the declared scale minus the declared precision. For example, a column declared as</p> <pre data-language="sql">
NUMERIC(3, 5)
</pre> <p>will round values to 5 decimal places and can store values between -0.00999 and 0.00999, inclusive.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>PostgreSQL permits the scale in a <code class="type">numeric</code> type declaration to be any value in the range -1000 to 1000. However, the SQL standard requires the scale to be in the range 0 to <code>precision</code>. Using scales outside that range may not be portable to other database systems.</p> </blockquote> <p>Numeric values are physically stored without any extra leading or trailing zeroes. Thus, the declared precision and scale of a column are maximums, not fixed allocations. (In this sense the <code class="type">numeric</code> type is more akin to <code class="type">varchar(n)</code> than to <code class="type">char(n)</code>.) The actual storage requirement is two bytes for each group of four decimal digits, plus three to eight bytes overhead.</p> <p>In addition to ordinary numeric values, the <code class="type">numeric</code> type has several special values:</p> <div class="literallayout"> <p> <code class="literal">Infinity</code> <code class="literal">-Infinity</code> <code class="literal">NaN</code></p> </div> <p>These are adapted from the IEEE 754 standard, and represent <span class="quote">“<span class="quote">infinity</span>”</span>, <span class="quote">“<span class="quote">negative infinity</span>”</span>, and <span class="quote">“<span class="quote">not-a-number</span>”</span>, respectively. When writing these values as constants in an SQL command, you must put quotes around them, for example <code class="literal">UPDATE table SET x = '-Infinity'</code>. On input, these strings are recognized in a case-insensitive manner. The infinity values can alternatively be spelled <code class="literal">inf</code> and <code class="literal">-inf</code>.</p> <p>The infinity values behave as per mathematical expectations. For example, <code class="literal">Infinity</code> plus any finite value equals <code class="literal">Infinity</code>, as does <code class="literal">Infinity</code> plus <code class="literal">Infinity</code>; but <code class="literal">Infinity</code> minus <code class="literal">Infinity</code> yields <code class="literal">NaN</code> (not a number), because it has no well-defined interpretation. Note that an infinity can only be stored in an unconstrained <code class="type">numeric</code> column, because it notionally exceeds any finite precision limit.</p> <p>The <code class="literal">NaN</code> (not a number) value is used to represent undefined calculational results. In general, any operation with a <code class="literal">NaN</code> input yields another <code class="literal">NaN</code>. The only exception is when the operation's other inputs are such that the same output would be obtained if the <code class="literal">NaN</code> were to be replaced by any finite or infinite numeric value; then, that output value is used for <code class="literal">NaN</code> too. (An example of this principle is that <code class="literal">NaN</code> raised to the zero power yields one.)</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>In most implementations of the <span class="quote">“<span class="quote">not-a-number</span>”</span> concept, <code class="literal">NaN</code> is not considered equal to any other numeric value (including <code class="literal">NaN</code>). In order to allow <code class="type">numeric</code> values to be sorted and used in tree-based indexes, PostgreSQL treats <code class="literal">NaN</code> values as equal, and greater than all non-<code class="literal">NaN</code> values.</p> </blockquote> <p>The types <code class="type">decimal</code> and <code class="type">numeric</code> are equivalent. Both types are part of the SQL standard.</p> <p>When rounding values, the <code class="type">numeric</code> type rounds ties away from zero, while (on most machines) the <code class="type">real</code> and <code class="type">double precision</code> types round ties to the nearest even number. For example:</p> <pre data-language="sql">
SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
</pre> </div> <div class="sect2" id="id-1.5.7.9.8.16">    <h2 class="title">8.1.3. Floating-Point Types </h2>    <p>The data types <code class="type">real</code> and <code class="type">double precision</code> are inexact, variable-precision numeric types. On all currently supported platforms, these types are implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent that the underlying processor, operating system, and compiler support it.</p> <p>Inexact means that some values cannot be converted exactly to the internal format and are stored as approximations, so that storing and retrieving a value might show slight discrepancies. Managing these errors and how they propagate through calculations is the subject of an entire branch of mathematics and computer science and will not be discussed here, except for the following points:</p>  <ul> <li> <p>If you require exact storage and calculations (such as for monetary amounts), use the <code class="type">numeric</code> type instead.</p> </li> <li> <p>If you want to do complicated calculations with these types for anything important, especially if you rely on certain behavior in boundary cases (infinity, underflow), you should evaluate the implementation carefully.</p> </li> <li> <p>Comparing two floating-point values for equality might not always work as expected.</p> </li> </ul>  <p>On all currently supported platforms, the <code class="type">real</code> type has a range of around 1E-37 to 1E+37 with a precision of at least 6 decimal digits. The <code class="type">double precision</code> type has a range of around 1E-307 to 1E+308 with a precision of at least 15 digits. Values that are too large or too small will cause an error. Rounding might take place if the precision of an input number is too high. Numbers too close to zero that are not representable as distinct from zero will cause an underflow error.</p> <p>By default, floating point values are output in text form in their shortest precise decimal representation; the decimal value produced is closer to the true stored binary value than to any other value representable in the same binary precision. (However, the output value is currently never <span class="emphasis"><em>exactly</em></span> midway between two representable values, in order to avoid a widespread bug where input routines do not properly respect the round-to-nearest-even rule.) This value will use at most 17 significant decimal digits for <code class="type">float8</code> values, and at most 9 digits for <code class="type">float4</code> values.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>This shortest-precise output format is much faster to generate than the historical rounded format.</p> </blockquote> <p>For compatibility with output generated by older versions of PostgreSQL, and to allow the output precision to be reduced, the <a class="xref" href="runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS">extra_float_digits</a> parameter can be used to select rounded decimal output instead. Setting a value of 0 restores the previous default of rounding the value to 6 (for <code class="type">float4</code>) or 15 (for <code class="type">float8</code>) significant decimal digits. Setting a negative value reduces the number of digits further; for example -2 would round output to 4 or 13 digits respectively.</p> <p>Any value of <a class="xref" href="runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS">extra_float_digits</a> greater than 0 selects the shortest-precise format.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>Applications that wanted precise values have historically had to set <a class="xref" href="runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS">extra_float_digits</a> to 3 to obtain them. For maximum compatibility between versions, they should continue to do so.</p> </blockquote> <p>In addition to ordinary numeric values, the floating-point types have several special values:</p> <div class="literallayout"> <p> <code class="literal">Infinity</code> <code class="literal">-Infinity</code> <code class="literal">NaN</code></p> </div> <p>These represent the IEEE 754 special values <span class="quote">“<span class="quote">infinity</span>”</span>, <span class="quote">“<span class="quote">negative infinity</span>”</span>, and <span class="quote">“<span class="quote">not-a-number</span>”</span>, respectively. When writing these values as constants in an SQL command, you must put quotes around them, for example <code class="literal">UPDATE table SET x = '-Infinity'</code>. On input, these strings are recognized in a case-insensitive manner. The infinity values can alternatively be spelled <code class="literal">inf</code> and <code class="literal">-inf</code>.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>IEEE 754 specifies that <code class="literal">NaN</code> should not compare equal to any other floating-point value (including <code class="literal">NaN</code>). In order to allow floating-point values to be sorted and used in tree-based indexes, PostgreSQL treats <code class="literal">NaN</code> values as equal, and greater than all non-<code class="literal">NaN</code> values.</p> </blockquote> <p>PostgreSQL also supports the SQL-standard notations <code class="type">float</code> and <code class="type">float(p)</code> for specifying inexact numeric types. Here, <code>p</code> specifies the minimum acceptable precision in <span class="emphasis"><em>binary</em></span> digits. PostgreSQL accepts <code class="type">float(1)</code> to <code class="type">float(24)</code> as selecting the <code class="type">real</code> type, while <code class="type">float(25)</code> to <code class="type">float(53)</code> select <code class="type">double precision</code>. Values of <code>p</code> outside the allowed range draw an error. <code class="type">float</code> with no precision specified is taken to mean <code class="type">double precision</code>.</p> </div> <div class="sect2" id="id-1.5.7.9.9.9">    <h2 class="title">8.1.4. Serial Types </h2>    <blockquote class="note"> <h3 class="title">Note</h3> <p>This section describes a PostgreSQL-specific way to create an autoincrementing column. Another way is to use the SQL-standard identity column feature, described at <a class="xref" href="sql-createtable.html" title="CREATE TABLE">CREATE TABLE</a>.</p> </blockquote> <p>The data types <code class="type">smallserial</code>, <code class="type">serial</code> and <code class="type">bigserial</code> are not true types, but merely a notational convenience for creating unique identifier columns (similar to the <code class="literal">AUTO_INCREMENT</code> property supported by some other databases). In the current implementation, specifying:</p> <pre data-language="sql">
CREATE TABLE tablename (
    colname SERIAL
);
</pre> <p>is equivalent to specifying:</p> <pre data-language="sql">
CREATE SEQUENCE tablename_colname_seq AS integer;
CREATE TABLE tablename (
    colname integer NOT NULL DEFAULT nextval('tablename_colname_seq')
);
ALTER SEQUENCE tablename_colname_seq OWNED BY tablename.colname;
</pre> <p>Thus, we have created an integer column and arranged for its default values to be assigned from a sequence generator. A <code class="literal">NOT NULL</code> constraint is applied to ensure that a null value cannot be inserted. (In most cases you would also want to attach a <code class="literal">UNIQUE</code> or <code class="literal">PRIMARY KEY</code> constraint to prevent duplicate values from being inserted by accident, but this is not automatic.) Lastly, the sequence is marked as <span class="quote">“<span class="quote">owned by</span>”</span> the column, so that it will be dropped if the column or table is dropped.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>Because <code class="type">smallserial</code>, <code class="type">serial</code> and <code class="type">bigserial</code> are implemented using sequences, there may be "holes" or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still "used up" even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See <code class="literal">nextval()</code> in <a class="xref" href="functions-sequence.html" title="9.17. Sequence Manipulation Functions">Section 9.17</a> for details.</p> </blockquote> <p>To insert the next value of the sequence into the <code class="type">serial</code> column, specify that the <code class="type">serial</code> column should be assigned its default value. This can be done either by excluding the column from the list of columns in the <code class="command">INSERT</code> statement, or through the use of the <code class="literal">DEFAULT</code> key word.</p> <p>The type names <code class="type">serial</code> and <code class="type">serial4</code> are equivalent: both create <code class="type">integer</code> columns. The type names <code class="type">bigserial</code> and <code class="type">serial8</code> work the same way, except that they create a <code class="type">bigint</code> column. <code class="type">bigserial</code> should be used if you anticipate the use of more than 2<sup>31</sup> identifiers over the lifetime of the table. The type names <code class="type">smallserial</code> and <code class="type">serial2</code> also work the same way, except that they create a <code class="type">smallint</code> column.</p> <p>The sequence created for a <code class="type">serial</code> column is automatically dropped when the owning column is dropped. You can drop the sequence without dropping the column, but this will force removal of the column default expression.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996&ndash;2023 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/16/datatype-numeric.html" class="_attribution-link">https://www.postgresql.org/docs/16/datatype-numeric.html</a>
  </p>
</div>
