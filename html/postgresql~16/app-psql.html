<h1>psql</h1> <p>psql — PostgreSQL interactive terminal</p>   <h2>Synopsis</h2> <div class="cmdsynopsis"> <p id="id-1.9.4.20.4.1"><code class="command">psql</code> [<code>option</code>...] [<code>dbname</code> [<code>username</code>]]</p> </div>  <div class="refsect1" id="id-1.9.4.20.5"> <h2>Description</h2> <p>psql is a terminal-based front-end to PostgreSQL. It enables you to type in queries interactively, issue them to PostgreSQL, and see the query results. Alternatively, input can be from a file or from command line arguments. In addition, psql provides a number of meta-commands and various shell-like features to facilitate writing scripts and automating a wide variety of tasks.</p> </div> <div class="refsect1" id="R1-APP-PSQL-3"> <h2>Options</h2> <div class="variablelist"> <dl class="variablelist"> <dt id="APP-PSQL-OPTION-ECHO-ALL">
<code class="option">-a</code><code class="option">--echo-all</code> </dt> <dd> <p>Print all nonempty input lines to standard output as they are read. (This does not apply to lines read interactively.) This is equivalent to setting the variable <code class="varname">ECHO</code> to <code class="literal">all</code>.</p> </dd> <dt id="APP-PSQL-OPTION-NO-ALIGN">
<code class="option">-A</code><code class="option">--no-align</code> </dt> <dd> <p>Switches to unaligned output mode. (The default output mode is <code class="literal">aligned</code>.) This is equivalent to <code class="command">\pset format unaligned</code>.</p> </dd> <dt id="APP-PSQL-OPTION-ECHO-ERRORS">
<code class="option">-b</code><code class="option">--echo-errors</code> </dt> <dd> <p>Print failed SQL commands to standard error output. This is equivalent to setting the variable <code class="varname">ECHO</code> to <code class="literal">errors</code>.</p> </dd> <dt id="APP-PSQL-OPTION-COMMAND">
<code class="option">-c command</code><code class="option">--command=command</code> </dt> <dd> <p>Specifies that psql is to execute the given command string, <code>command</code>. This option can be repeated and combined in any order with the <code class="option">-f</code> option. When either <code class="option">-c</code> or <code class="option">-f</code> is specified, psql does not read commands from standard input; instead it terminates after processing all the <code class="option">-c</code> and <code class="option">-f</code> options in sequence.</p> <p><code>command</code> must be either a command string that is completely parsable by the server (i.e., it contains no psql-specific features), or a single backslash command. Thus you cannot mix SQL and psql meta-commands within a <code class="option">-c</code> option. To achieve that, you could use repeated <code class="option">-c</code> options or pipe the string into psql, for example:</p> <pre data-language="sql">
psql -c '\x' -c 'SELECT * FROM foo;'
</pre> <p>or</p> <pre data-language="sql">
echo '\x \\ SELECT * FROM foo;' | psql
</pre> <p>(<code class="literal">\\</code> is the separator meta-command.)</p> <p>Each SQL command string passed to <code class="option">-c</code> is sent to the server as a single request. Because of this, the server executes it as a single transaction even if the string contains multiple SQL commands, unless there are explicit <code class="command">BEGIN</code>/<code class="command">COMMIT</code> commands included in the string to divide it into multiple transactions. (See <a class="xref" href="https://www.postgresql.org/docs/16/protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT" title="55.2.2.1. Multiple Statements in a Simple Query">Section 55.2.2.1</a> for more details about how the server handles multi-query strings.)</p> <p>If having several commands executed in one transaction is not desired, use repeated <code class="option">-c</code> commands or feed multiple commands to psql's standard input, either using echo as illustrated above, or via a shell here-document, for example:</p> <pre data-language="sql">
psql &lt;&lt;EOF
\x
SELECT * FROM foo;
EOF
</pre> </dd> <dt id="APP-PSQL-OPTION-CSV">
<code class="option">--csv</code> </dt> <dd> <p>Switches to CSV (Comma-Separated Values) output mode. This is equivalent to <code class="command">\pset format csv</code>.</p> </dd> <dt id="APP-PSQL-OPTION-DBNAME">
<code class="option">-d dbname</code><code class="option">--dbname=dbname</code> </dt> <dd> <p>Specifies the name of the database to connect to. This is equivalent to specifying <code>dbname</code> as the first non-option argument on the command line. The <code>dbname</code> can be a <a class="link" href="https://www.postgresql.org/docs/16/libpq-connect.html#LIBPQ-CONNSTRING" title="34.1.1. Connection Strings">connection string</a>. If so, connection string parameters will override any conflicting command line options.</p> </dd> <dt id="APP-PSQL-OPTION-ECHO-QUERIES">
<code class="option">-e</code><code class="option">--echo-queries</code> </dt> <dd> <p>Copy all SQL commands sent to the server to standard output as well. This is equivalent to setting the variable <code class="varname">ECHO</code> to <code class="literal">queries</code>.</p> </dd> <dt id="APP-PSQL-OPTION-ECHO-HIDDEN">
<code class="option">-E</code><code class="option">--echo-hidden</code> </dt> <dd> <p>Echo the actual queries generated by <code class="command">\d</code> and other backslash commands. You can use this to study psql's internal operations. This is equivalent to setting the variable <code class="varname">ECHO_HIDDEN</code> to <code class="literal">on</code>.</p> </dd> <dt id="APP-PSQL-OPTION-FILE">
<code class="option">-f filename</code><code class="option">--file=filename</code> </dt> <dd> <p>Read commands from the file <code>filename</code>, rather than standard input. This option can be repeated and combined in any order with the <code class="option">-c</code> option. When either <code class="option">-c</code> or <code class="option">-f</code> is specified, psql does not read commands from standard input; instead it terminates after processing all the <code class="option">-c</code> and <code class="option">-f</code> options in sequence. Except for that, this option is largely equivalent to the meta-command <code class="command">\i</code>.</p> <p>If <code>filename</code> is <code class="literal">-</code> (hyphen), then standard input is read until an EOF indication or <code class="command">\q</code> meta-command. This can be used to intersperse interactive input with input from files. Note however that Readline is not used in this case (much as if <code class="option">-n</code> had been specified).</p> <p>Using this option is subtly different from writing <code class="literal">psql &lt; filename</code>. In general, both will do what you expect, but using <code class="literal">-f</code> enables some nice features such as error messages with line numbers. There is also a slight chance that using this option will reduce the start-up overhead. On the other hand, the variant using the shell's input redirection is (in theory) guaranteed to yield exactly the same output you would have received had you entered everything by hand.</p> </dd> <dt id="APP-PSQL-OPTION-FIELD-SEPARATOR">
<code class="option">-F separator</code><code class="option">--field-separator=separator</code> </dt> <dd> <p>Use <code>separator</code> as the field separator for unaligned output. This is equivalent to <code class="command">\pset fieldsep</code> or <code class="command">\f</code>.</p> </dd> <dt id="APP-PSQL-OPTION-FIELD-HOST">
<code class="option">-h hostname</code><code class="option">--host=hostname</code> </dt> <dd> <p>Specifies the host name of the machine on which the server is running. If the value begins with a slash, it is used as the directory for the Unix-domain socket.</p> </dd> <dt id="APP-PSQL-OPTION-HTML">
<code class="option">-H</code><code class="option">--html</code> </dt> <dd> <p>Switches to HTML output mode. This is equivalent to <code class="command">\pset format html</code> or the <code class="command">\H</code> command.</p> </dd> <dt id="APP-PSQL-OPTION-LIST">
<code class="option">-l</code><code class="option">--list</code> </dt> <dd> <p>List all available databases, then exit. Other non-connection options are ignored. This is similar to the meta-command <code class="command">\list</code>.</p> <p>When this option is used, psql will connect to the database <code class="literal">postgres</code>, unless a different database is named on the command line (option <code class="option">-d</code> or non-option argument, possibly via a service entry, but not via an environment variable).</p> </dd> <dt id="APP-PSQL-OPTION-LOG-FILE">
<code class="option">-L filename</code><code class="option">--log-file=filename</code> </dt> <dd> <p>Write all query output into file <code>filename</code>, in addition to the normal output destination.</p> </dd> <dt id="APP-PSQL-OPTION-NO-READLINE">
<code class="option">-n</code><code class="option">--no-readline</code> </dt> <dd> <p>Do not use Readline for line editing and do not use the command history (see <a class="xref" href="app-psql.html#APP-PSQL-READLINE" title="Command-Line Editing">the section called “Command-Line Editing”</a> below).</p> </dd> <dt id="APP-PSQL-OPTION-OUTPUT">
<code class="option">-o filename</code><code class="option">--output=filename</code> </dt> <dd> <p>Put all query output into file <code>filename</code>. This is equivalent to the command <code class="command">\o</code>.</p> </dd> <dt id="APP-PSQL-OPTION-PORT">
<code class="option">-p port</code><code class="option">--port=port</code> </dt> <dd> <p>Specifies the TCP port or the local Unix-domain socket file extension on which the server is listening for connections. Defaults to the value of the <code class="envar">PGPORT</code> environment variable or, if not set, to the port specified at compile time, usually 5432.</p> </dd> <dt id="APP-PSQL-OPTION-PSET">
<code class="option">-P assignment</code><code class="option">--pset=assignment</code> </dt> <dd> <p>Specifies printing options, in the style of <code class="command">\pset</code>. Note that here you have to separate name and value with an equal sign instead of a space. For example, to set the output format to LaTeX, you could write <code class="literal">-P format=latex</code>.</p> </dd> <dt id="APP-PSQL-OPTION-QUIET">
<code class="option">-q</code><code class="option">--quiet</code> </dt> <dd> <p>Specifies that psql should do its work quietly. By default, it prints welcome messages and various informational output. If this option is used, none of this happens. This is useful with the <code class="option">-c</code> option. This is equivalent to setting the variable <code class="varname">QUIET</code> to <code class="literal">on</code>.</p> </dd> <dt id="APP-PSQL-OPTION-RECORD-SEPARATOR">
<code class="option">-R separator</code><code class="option">--record-separator=separator</code> </dt> <dd> <p>Use <code>separator</code> as the record separator for unaligned output. This is equivalent to <code class="command">\pset recordsep</code>.</p> </dd> <dt id="APP-PSQL-OPTION-SINGLE-STEP">
<code class="option">-s</code><code class="option">--single-step</code> </dt> <dd> <p>Run in single-step mode. That means the user is prompted before each command is sent to the server, with the option to cancel execution as well. Use this to debug scripts.</p> </dd> <dt id="APP-PSQL-OPTION-SINGLE-LINE">
<code class="option">-S</code><code class="option">--single-line</code> </dt> <dd> <p>Runs in single-line mode where a newline terminates an SQL command, as a semicolon does.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>This mode is provided for those who insist on it, but you are not necessarily encouraged to use it. In particular, if you mix SQL and meta-commands on a line the order of execution might not always be clear to the inexperienced user.</p> </blockquote> </dd> <dt id="APP-PSQL-OPTION-TUPLES-ONLY">
<code class="option">-t</code><code class="option">--tuples-only</code> </dt> <dd> <p>Turn off printing of column names and result row count footers, etc. This is equivalent to <code class="command">\t</code> or <code class="command">\pset tuples_only</code>.</p> </dd> <dt id="APP-PSQL-OPTION-TABLE-ATTR">
<code class="option">-T table_options</code><code class="option">--table-attr=table_options</code> </dt> <dd> <p>Specifies options to be placed within the HTML <code class="sgmltag-element">table</code> tag. See <code class="command">\pset tableattr</code> for details.</p> </dd> <dt id="APP-PSQL-OPTION-USERNAME">
<code class="option">-U username</code><code class="option">--username=username</code> </dt> <dd> <p>Connect to the database as the user <code>username</code> instead of the default. (You must have permission to do so, of course.)</p> </dd> <dt id="APP-PSQL-OPTION-VARIABLE">
<code class="option">-v assignment</code><code class="option">--set=assignment</code><code class="option">--variable=assignment</code> </dt> <dd> <p>Perform a variable assignment, like the <code class="command">\set</code> meta-command. Note that you must separate name and value, if any, by an equal sign on the command line. To unset a variable, leave off the equal sign. To set a variable with an empty value, use the equal sign but leave off the value. These assignments are done during command line processing, so variables that reflect connection state will get overwritten later.</p> </dd> <dt id="APP-PSQL-OPTION-VERSION">
<code class="option">-V</code><code class="option">--version</code> </dt> <dd> <p>Print the psql version and exit.</p> </dd> <dt id="APP-PSQL-OPTION-NO-PASSWORD">
<code class="option">-w</code><code class="option">--no-password</code> </dt> <dd> <p>Never issue a password prompt. If the server requires password authentication and a password is not available from other sources such as a <code class="filename">.pgpass</code> file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</p> <p>Note that this option will remain set for the entire session, and so it affects uses of the meta-command <code class="command">\connect</code> as well as the initial connection attempt.</p> </dd> <dt id="APP-PSQL-OPTION-PASSWORD">
<code class="option">-W</code><code class="option">--password</code> </dt> <dd> <p>Force psql to prompt for a password before connecting to a database, even if the password will not be used.</p> <p>If the server requires password authentication and a password is not available from other sources such as a <code class="filename">.pgpass</code> file, psql will prompt for a password in any case. However, psql will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing <code class="option">-W</code> to avoid the extra connection attempt.</p> <p>Note that this option will remain set for the entire session, and so it affects uses of the meta-command <code class="command">\connect</code> as well as the initial connection attempt.</p> </dd> <dt id="APP-PSQL-OPTION-EXPANDED">
<code class="option">-x</code><code class="option">--expanded</code> </dt> <dd> <p>Turn on the expanded table formatting mode. This is equivalent to <code class="command">\x</code> or <code class="command">\pset expanded</code>.</p> </dd> <dt id="APP-PSQL-OPTION-NO-PSQLRC">
<code class="option">-X,</code><code class="option">--no-psqlrc</code> </dt> <dd> <p>Do not read the start-up file (neither the system-wide <code class="filename">psqlrc</code> file nor the user's <code class="filename">~/.psqlrc</code> file).</p> </dd> <dt id="APP-PSQL-OPTION-FIELD-SEPARATOR-ZERO">
<code class="option">-z</code><code class="option">--field-separator-zero</code> </dt> <dd> <p>Set the field separator for unaligned output to a zero byte. This is equivalent to <code class="command">\pset fieldsep_zero</code>.</p> </dd> <dt id="APP-PSQL-OPTION-RECORD-SEPARATOR-ZERO">
<code class="option">-0</code><code class="option">--record-separator-zero</code> </dt> <dd> <p>Set the record separator for unaligned output to a zero byte. This is useful for interfacing, for example, with <code class="literal">xargs -0</code>. This is equivalent to <code class="command">\pset recordsep_zero</code>.</p> </dd> <dt id="APP-PSQL-OPTION-SINGLE-TRANSACTION">
<code class="option">-1</code><code class="option">--single-transaction</code> </dt> <dd> <p>This option can only be used in combination with one or more <code class="option">-c</code> and/or <code class="option">-f</code> options. It causes psql to issue a <code class="command">BEGIN</code> command before the first such option and a <code class="command">COMMIT</code> command after the last one, thereby wrapping all the commands into a single transaction. If any of the commands fails and the variable <code class="varname">ON_ERROR_STOP</code> was set, a <code class="command">ROLLBACK</code> command is sent instead. This ensures that either all the commands complete successfully, or no changes are applied.</p> <p>If the commands themselves contain <code class="command">BEGIN</code>, <code class="command">COMMIT</code>, or <code class="command">ROLLBACK</code>, this option will not have the desired effects. Also, if an individual command cannot be executed inside a transaction block, specifying this option will cause the whole transaction to fail.</p> </dd> <dt id="APP-PSQL-OPTION-HELP">
<code class="option">-?</code><code class="option">--help[=topic]</code> </dt> <dd> <p>Show help about psql and exit. The optional <code>topic</code> parameter (defaulting to <code class="literal">options</code>) selects which part of psql is explained: <code class="literal">commands</code> describes psql's backslash commands; <code class="literal">options</code> describes the command-line options that can be passed to psql; and <code class="literal">variables</code> shows help about psql configuration variables.</p> </dd> </dl> </div> </div> <div class="refsect1" id="id-1.9.4.20.7"> <h2>Exit Status</h2> <p>psql returns 0 to the shell if it finished normally, 1 if a fatal error of its own occurs (e.g., out of memory, file not found), 2 if the connection to the server went bad and the session was not interactive, and 3 if an error occurred in a script and the variable <code class="varname">ON_ERROR_STOP</code> was set.</p> </div> <div class="refsect1" id="id-1.9.4.20.8"> <h2>Usage</h2> <div class="refsect2" id="R2-APP-PSQL-CONNECTING"> <h3>Connecting to a Database</h3> <p>psql is a regular PostgreSQL client application. In order to connect to a database you need to know the name of your target database, the host name and port number of the server, and what database user name you want to connect as. psql can be told about those parameters via command line options, namely <code class="option">-d</code>, <code class="option">-h</code>, <code class="option">-p</code>, and <code class="option">-U</code> respectively. If an argument is found that does not belong to any option it will be interpreted as the database name (or the database user name, if the database name is already given). Not all of these options are required; there are useful defaults. If you omit the host name, psql will connect via a Unix-domain socket to a server on the local host, or via TCP/IP to <code class="literal">localhost</code> on Windows. The default port number is determined at compile time. Since the database server uses the same default, you will not have to specify the port in most cases. The default database user name is your operating-system user name. Once the database user name is determined, it is used as the default database name. Note that you cannot just connect to any database under any database user name. Your database administrator should have informed you about your access rights.</p> <p>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables <code class="envar">PGDATABASE</code>, <code class="envar">PGHOST</code>, <code class="envar">PGPORT</code> and/or <code class="envar">PGUSER</code> to appropriate values. (For additional environment variables, see <a class="xref" href="https://www.postgresql.org/docs/16/libpq-envars.html" title="34.15. Environment Variables">Section 34.15</a>.) It is also convenient to have a <code class="filename">~/.pgpass</code> file to avoid regularly having to type in passwords. See <a class="xref" href="https://www.postgresql.org/docs/16/libpq-pgpass.html" title="34.16. The Password File">Section 34.16</a> for more information.</p> <p>An alternative way to specify connection parameters is in a <em class="parameter"><code>conninfo</code></em> string or a URI, which is used instead of a database name. This mechanism give you very wide control over the connection. For example:</p> <pre data-language="sql">
$ <strong class="userinput">psql "service=myservice sslmode=require"</strong>
$ <strong class="userinput">psql postgresql://dbmaster:5433/mydb?sslmode=require</strong>
</pre> <p>This way you can also use LDAP for connection parameter lookup as described in <a class="xref" href="https://www.postgresql.org/docs/16/libpq-ldap.html" title="34.18. LDAP Lookup of Connection Parameters">Section 34.18</a>. See <a class="xref" href="https://www.postgresql.org/docs/16/libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="34.1.2. Parameter Key Words">Section 34.1.2</a> for more information on all the available connection options.</p> <p>If the connection could not be made for any reason (e.g., insufficient privileges, server is not running on the targeted host, etc.), psql will return an error and terminate.</p> <p>If both standard input and standard output are a terminal, then psql sets the client encoding to <span class="quote">“<span class="quote">auto</span>”</span>, which will detect the appropriate client encoding from the locale settings (<code class="envar">LC_CTYPE</code> environment variable on Unix systems). If this doesn't work out as expected, the client encoding can be overridden using the environment variable <code class="envar">PGCLIENTENCODING</code>.</p> </div> <div class="refsect2" id="R2-APP-PSQL-4"> <h3>Entering SQL Commands</h3> <p>In normal operation, psql provides a prompt with the name of the database to which psql is currently connected, followed by the string <code class="literal">=&gt;</code>. For example:</p> <pre data-language="sql">
$ <strong class="userinput">psql testdb</strong>
psql (16.1)
Type "help" for help.

testdb=&gt;
</pre> <p>At the prompt, the user can type in SQL commands. Ordinarily, input lines are sent to the server when a command-terminating semicolon is reached. An end of line does not terminate a command. Thus commands can be spread over several lines for clarity. If the command was sent and executed without error, the results of the command are displayed on the screen.</p> <p>If untrusted users have access to a database that has not adopted a <a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.9.6. Usage Patterns">secure schema usage pattern</a>, begin your session by removing publicly-writable schemas from <code class="varname">search_path</code>. One can add <code class="literal">options=-csearch_path=</code> to the connection string or issue <code class="literal">SELECT pg_catalog.set_config('search_path', '', false)</code> before other SQL commands. This consideration is not specific to psql; it applies to every interface for executing arbitrary SQL commands.</p> <p>Whenever a command is executed, psql also polls for asynchronous notification events generated by <a class="link" href="sql-listen.html" title="LISTEN"><code class="command">LISTEN</code></a> and <a class="link" href="sql-notify.html" title="NOTIFY"><code class="command">NOTIFY</code></a>.</p> <p>While C-style block comments are passed to the server for processing and removal, SQL-standard comments are removed by psql.</p> </div> <div class="refsect2" id="APP-PSQL-META-COMMANDS"> <h3>Meta-Commands</h3> <p>Anything you enter in psql that begins with an unquoted backslash is a psql meta-command that is processed by psql itself. These commands make psql more useful for administration or scripting. Meta-commands are often called slash or backslash commands.</p> <p>The format of a psql command is the backslash, followed immediately by a command verb, then any arguments. The arguments are separated from the command verb and each other by any number of whitespace characters.</p> <p>To include whitespace in an argument you can quote it with single quotes. To include a single quote in an argument, write two single quotes within single-quoted text. Anything contained in single quotes is furthermore subject to C-like substitutions for <code class="literal">\n</code> (new line), <code class="literal">\t</code> (tab), <code class="literal">\b</code> (backspace), <code class="literal">\r</code> (carriage return), <code class="literal">\f</code> (form feed), <code class="literal">\</code><code>digits</code> (octal), and <code class="literal">\x</code><code>digits</code> (hexadecimal). A backslash preceding any other character within single-quoted text quotes that single character, whatever it is.</p> <p>If an unquoted colon (<code class="literal">:</code>) followed by a psql variable name appears within an argument, it is replaced by the variable's value, as described in <a class="xref" href="app-psql.html#APP-PSQL-INTERPOLATION" title="SQL Interpolation">SQL Interpolation</a> below. The forms <code class="literal">:'variable_name'</code> and <code class="literal">:"variable_name"</code> described there work as well. The <code class="literal">:{?variable_name}</code> syntax allows testing whether a variable is defined. It is substituted by TRUE or FALSE. Escaping the colon with a backslash protects it from substitution.</p> <p>Within an argument, text that is enclosed in backquotes (<code class="literal">`</code>) is taken as a command line that is passed to the shell. The output of the command (with any trailing newline removed) replaces the backquoted text. Within the text enclosed in backquotes, no special quoting or other processing occurs, except that appearances of <code class="literal">:variable_name</code> where <code>variable_name</code> is a psql variable name are replaced by the variable's value. Also, appearances of <code class="literal">:'variable_name'</code> are replaced by the variable's value suitably quoted to become a single shell command argument. (The latter form is almost always preferable, unless you are very sure of what is in the variable.) Because carriage return and line feed characters cannot be safely quoted on all platforms, the <code class="literal">:'variable_name'</code> form prints an error message and does not substitute the variable value when such characters appear in the value.</p> <p>Some commands take an SQL identifier (such as a table name) as argument. These arguments follow the syntax rules of SQL: Unquoted letters are forced to lowercase, while double quotes (<code class="literal">"</code>) protect letters from case conversion and allow incorporation of whitespace into the identifier. Within double quotes, paired double quotes reduce to a single double quote in the resulting name. For example, <code class="literal">FOO"BAR"BAZ</code> is interpreted as <code class="literal">fooBARbaz</code>, and <code class="literal">"A weird"" name"</code> becomes <code class="literal">A weird" name</code>.</p> <p>Parsing for arguments stops at the end of the line, or when another unquoted backslash is found. An unquoted backslash is taken as the beginning of a new meta-command. The special sequence <code class="literal">\\</code> (two backslashes) marks the end of arguments and continues parsing SQL commands, if any. That way SQL and psql commands can be freely mixed on a line. But in any case, the arguments of a meta-command cannot continue beyond the end of the line.</p> <p>Many of the meta-commands act on the <em class="firstterm">current query buffer</em>. This is simply a buffer holding whatever SQL command text has been typed but not yet sent to the server for execution. This will include previous input lines as well as any text appearing before the meta-command on the same line.</p> <p>The following meta-commands are defined:</p> <div class="variablelist"> <dl class="variablelist"> <dt id="APP-PSQL-META-COMMAND-A">
<code class="literal">\a</code> </dt> <dd> <p>If the current table output format is unaligned, it is switched to aligned. If it is not unaligned, it is set to unaligned. This command is kept for backwards compatibility. See <code class="command">\pset</code> for a more general solution.</p> </dd> <dt id="APP-PSQL-META-COMMAND-BIND">
<code class="literal">\bind</code> [ <code>parameter</code> ] ... </dt> <dd> <p>Sets query parameters for the next query execution, with the specified parameters passed for any parameter placeholders (<code class="literal">$1</code> etc.).</p> <p>Example:</p> <pre data-language="sql">
INSERT INTO tbl1 VALUES ($1, $2) \bind 'first value' 'second value' \g
</pre> <p>This also works for query-execution commands besides <code class="literal">\g</code>, such as <code class="literal">\gx</code> and <code class="literal">\gset</code>.</p> <p>This command causes the extended query protocol (see <a class="xref" href="https://www.postgresql.org/docs/16/protocol-overview.html#PROTOCOL-QUERY-CONCEPTS" title="55.1.2. Extended Query Overview">Section 55.1.2</a>) to be used, unlike normal psql operation, which uses the simple query protocol. So this command can be useful to test the extended query protocol from psql. (The extended query protocol is used even if the query has no parameters and this command specifies zero parameters.) This command affects only the next query executed; all subsequent queries will use the simple query protocol by default.</p> </dd> <dt id="APP-PSQL-META-COMMAND-C-LC">
<code class="literal">\c</code> or <code class="literal">\connect [ -reuse-previous=on|off ] [ dbname [ username ] [ host ] [ port ] | conninfo ]</code> </dt> <dd> <p>Establishes a new connection to a PostgreSQL server. The connection parameters to use can be specified either using a positional syntax (one or more of database name, user, host, and port), or using a <code>conninfo</code> connection string as detailed in <a class="xref" href="https://www.postgresql.org/docs/16/libpq-connect.html#LIBPQ-CONNSTRING" title="34.1.1. Connection Strings">Section 34.1.1</a>. If no arguments are given, a new connection is made using the same parameters as before.</p> <p>Specifying any of <code>dbname</code>, <code>username</code>, <code>host</code> or <code>port</code> as <code class="literal">-</code> is equivalent to omitting that parameter.</p> <p>The new connection can re-use connection parameters from the previous connection; not only database name, user, host, and port, but other settings such as <code>sslmode</code>. By default, parameters are re-used in the positional syntax, but not when a <code>conninfo</code> string is given. Passing a first argument of <code class="literal">-reuse-previous=on</code> or <code class="literal">-reuse-previous=off</code> overrides that default. If parameters are re-used, then any parameter not explicitly specified as a positional parameter or in the <code>conninfo</code> string is taken from the existing connection's parameters. An exception is that if the <code>host</code> setting is changed from its previous value using the positional syntax, any <code>hostaddr</code> setting present in the existing connection's parameters is dropped. Also, any password used for the existing connection will be re-used only if the user, host, and port settings are not changed. When the command neither specifies nor reuses a particular parameter, the libpq default is used.</p> <p>If the new connection is successfully made, the previous connection is closed. If the connection attempt fails (wrong user name, access denied, etc.), the previous connection will be kept if psql is in interactive mode. But when executing a non-interactive script, the old connection is closed and an error is reported. That may or may not terminate the script; if it does not, all database-accessing commands will fail until another <code class="literal">\connect</code> command is successfully executed. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand. Note that whenever a <code class="literal">\connect</code> command attempts to re-use parameters, the values re-used are those of the last successful connection, not of any failed attempts made subsequently. However, in the case of a non-interactive <code class="literal">\connect</code> failure, no parameters are allowed to be re-used later, since the script would likely be expecting the values from the failed <code class="literal">\connect</code> to be re-used.</p> <p>Examples:</p> <pre data-language="sql">
=&gt; \c mydb myuser host.dom 6432
=&gt; \c service=foo
=&gt; \c "host=localhost port=5432 dbname=mydb connect_timeout=10 sslmode=disable"
=&gt; \c -reuse-previous=on sslmode=require    -- changes only sslmode
=&gt; \c postgresql://tom@localhost/mydb?application_name=myapp
</pre> </dd> <dt id="APP-PSQL-META-COMMAND-C-UC">
<code class="literal">\C [ title ]</code> </dt> <dd> <p>Sets the title of any tables being printed as the result of a query or unset any such title. This command is equivalent to <code class="literal">\pset title title</code>. (The name of this command derives from <span class="quote">“<span class="quote">caption</span>”</span>, as it was previously only used to set the caption in an HTML table.)</p> </dd> <dt id="APP-PSQL-META-COMMAND-CD">
<code class="literal">\cd [ directory ]</code> </dt> <dd> <p>Changes the current working directory to <code>directory</code>. Without argument, changes to the current user's home directory.</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>To print your current working directory, use <code class="literal">\! pwd</code>.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-CONNINFO">
<code class="literal">\conninfo</code> </dt> <dd> <p>Outputs information about the current database connection.</p> </dd> <dt id="APP-PSQL-META-COMMANDS-COPY">
<code class="literal">\copy { table [ ( column_list ) ] } from { 'filename' | program 'command' | stdin | pstdin } [ [ with ] ( option [, ...] ) ] [ where condition ]</code><code class="literal">\copy { table [ ( column_list ) ] | ( query ) } to { 'filename' | program 'command' | stdout | pstdout } [ [ with ] ( option [, ...] ) ]</code> </dt> <dd> <p>Performs a frontend (client) copy. This is an operation that runs an SQL <a class="link" href="sql-copy.html" title="COPY"><code class="command">COPY</code></a> command, but instead of the server reading or writing the specified file, psql reads or writes the file and routes the data between the server and the local file system. This means that file accessibility and privileges are those of the local user, not the server, and no SQL superuser privileges are required.</p> <p>When <code class="literal">program</code> is specified, <code>command</code> is executed by psql and the data passed from or to <code>command</code> is routed between the server and the client. Again, the execution privileges are those of the local user, not the server, and no SQL superuser privileges are required.</p> <p>For <code class="literal">\copy ... from stdin</code>, data rows are read from the same source that issued the command, continuing until <code class="literal">\.</code> is read or the stream reaches EOF. This option is useful for populating tables in-line within an SQL script file. For <code class="literal">\copy ... to stdout</code>, output is sent to the same place as psql command output, and the <code class="literal">COPY count</code> command status is not printed (since it might be confused with a data row). To read/write psql's standard input or output regardless of the current command source or <code class="literal">\o</code> option, write <code class="literal">from pstdin</code> or <code class="literal">to pstdout</code>.</p> <p>The syntax of this command is similar to that of the SQL <a class="link" href="sql-copy.html" title="COPY"><code class="command">COPY</code></a> command. All options other than the data source/destination are as specified for <code class="command">COPY</code>. Because of this, special parsing rules apply to the <code class="command">\copy</code> meta-command. Unlike most other meta-commands, the entire remainder of the line is always taken to be the arguments of <code class="command">\copy</code>, and neither variable interpolation nor backquote expansion are performed in the arguments.</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>Another way to obtain the same result as <code class="literal">\copy ... to</code> is to use the SQL <code class="literal">COPY ... TO STDOUT</code> command and terminate it with <code class="literal">\g filename</code> or <code class="literal">\g |program</code>. Unlike <code class="literal">\copy</code>, this method allows the command to span multiple lines; also, variable interpolation and backquote expansion can be used.</p> </blockquote> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>These operations are not as efficient as the SQL <code class="command">COPY</code> command with a file or program data source or destination, because all data must pass through the client/server connection. For large amounts of data the SQL command might be preferable. Also, because of this pass-through method, <code class="literal">\copy ... from</code> in CSV mode will erroneously treat a <code class="literal">\.</code> data value alone on a line as an end-of-input marker.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-COPYRIGHT">
<code class="literal">\copyright</code> </dt> <dd> <p>Shows the copyright and distribution terms of PostgreSQL.</p> </dd> <dt id="APP-PSQL-META-COMMANDS-CROSSTABVIEW">
<code class="literal">\crosstabview [ colV [ colH [ colD [ sortcolH ] ] ] ]</code> </dt> <dd> <p>Executes the current query buffer (like <code class="literal">\g</code>) and shows the results in a crosstab grid. The query must return at least three columns. The output column identified by <code>colV</code> becomes a vertical header and the output column identified by <code>colH</code> becomes a horizontal header. <code>colD</code> identifies the output column to display within the grid. <code>sortcolH</code> identifies an optional sort column for the horizontal header.</p> <p>Each column specification can be a column number (starting at 1) or a column name. The usual SQL case folding and quoting rules apply to column names. If omitted, <code>colV</code> is taken as column 1 and <code>colH</code> as column 2. <code>colH</code> must differ from <code>colV</code>. If <code>colD</code> is not specified, then there must be exactly three columns in the query result, and the column that is neither <code>colV</code> nor <code>colH</code> is taken to be <code>colD</code>.</p> <p>The vertical header, displayed as the leftmost column, contains the values found in column <code>colV</code>, in the same order as in the query results, but with duplicates removed.</p> <p>The horizontal header, displayed as the first row, contains the values found in column <code>colH</code>, with duplicates removed. By default, these appear in the same order as in the query results. But if the optional <code>sortcolH</code> argument is given, it identifies a column whose values must be integer numbers, and the values from <code>colH</code> will appear in the horizontal header sorted according to the corresponding <code>sortcolH</code> values.</p> <p>Inside the crosstab grid, for each distinct value <code class="literal">x</code> of <code>colH</code> and each distinct value <code class="literal">y</code> of <code>colV</code>, the cell located at the intersection <code class="literal">(x,y)</code> contains the value of the <code class="literal">colD</code> column in the query result row for which the value of <code>colH</code> is <code class="literal">x</code> and the value of <code>colV</code> is <code class="literal">y</code>. If there is no such row, the cell is empty. If there are multiple such rows, an error is reported.</p> </dd> <dt id="APP-PSQL-META-COMMAND-D">
<code class="literal">\d[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>For each relation (table, view, materialized view, index, sequence, or foreign table) or composite type matching the <code>pattern</code>, show all columns, their types, the tablespace (if not the default) and any special attributes such as <code class="literal">NOT NULL</code> or defaults. Associated indexes, constraints, rules, and triggers are also shown. For foreign tables, the associated foreign server is shown as well. (<span class="quote">“<span class="quote">Matching the pattern</span>”</span> is defined in <a class="xref" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">Patterns</a> below.)</p> <p>For some types of relation, <code class="literal">\d</code> shows additional information for each column: column values for sequences, indexed expressions for indexes, and foreign data wrapper options for foreign tables.</p> <p>The command form <code class="literal">\d+</code> is identical, except that more information is displayed: any comments associated with the columns of the table are shown, as is the presence of OIDs in the table, the view definition if the relation is a view, a non-default <a class="link" href="sql-altertable.html#SQL-ALTERTABLE-REPLICA-IDENTITY">replica identity</a> setting and the <a class="link" href="sql-create-access-method.html" title="CREATE ACCESS METHOD">access method</a> name if the relation has an access method.</p> <p>By default, only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>If <code class="command">\d</code> is used without a <code>pattern</code> argument, it is equivalent to <code class="command">\dtvmsE</code> which will show a list of all visible tables, views, materialized views, sequences and foreign tables. This is purely a convenience measure.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-DA-LC">
<code class="literal">\da[S] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists aggregate functions, together with their return type and the data types they operate on. If <code>pattern</code> is specified, only aggregates whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DA-UC">
<code class="literal">\dA[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists access methods. If <code>pattern</code> is specified, only access methods whose names match the pattern are shown. If <code class="literal">+</code> is appended to the command name, each access method is listed with its associated handler function and description.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DAC">
<code class="literal">\dAc[+] [<a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">access-method-pattern</a> [<a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">input-type-pattern</a>]]</code> </dt> <dd> <p>Lists operator classes (see <a class="xref" href="https://www.postgresql.org/docs/16/xindex.html#XINDEX-OPCLASS" title="38.16.1. Index Methods and Operator Classes">Section 38.16.1</a>). If <code>access-method-pattern</code> is specified, only operator classes associated with access methods whose names match that pattern are listed. If <code>input-type-pattern</code> is specified, only operator classes associated with input types whose names match that pattern are listed. If <code class="literal">+</code> is appended to the command name, each operator class is listed with its associated operator family and owner.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DAF">
<code class="literal">\dAf[+] [<a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">access-method-pattern</a> [<a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">input-type-pattern</a>]]</code> </dt> <dd> <p>Lists operator families (see <a class="xref" href="https://www.postgresql.org/docs/16/xindex.html#XINDEX-OPFAMILY" title="38.16.5. Operator Classes and Operator Families">Section 38.16.5</a>). If <code>access-method-pattern</code> is specified, only operator families associated with access methods whose names match that pattern are listed. If <code>input-type-pattern</code> is specified, only operator families associated with input types whose names match that pattern are listed. If <code class="literal">+</code> is appended to the command name, each operator family is listed with its owner.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DAO">
<code class="literal">\dAo[+] [<a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">access-method-pattern</a> [<a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">operator-family-pattern</a>]]</code> </dt> <dd> <p>Lists operators associated with operator families (see <a class="xref" href="https://www.postgresql.org/docs/16/xindex.html#XINDEX-STRATEGIES" title="38.16.2. Index Method Strategies">Section 38.16.2</a>). If <code>access-method-pattern</code> is specified, only members of operator families associated with access methods whose names match that pattern are listed. If <code>operator-family-pattern</code> is specified, only members of operator families whose names match that pattern are listed. If <code class="literal">+</code> is appended to the command name, each operator is listed with its sort operator family (if it is an ordering operator).</p> </dd> <dt id="APP-PSQL-META-COMMAND-DAP">
<code class="literal">\dAp[+] [<a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">access-method-pattern</a> [<a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">operator-family-pattern</a>]]</code> </dt> <dd> <p>Lists support functions associated with operator families (see <a class="xref" href="https://www.postgresql.org/docs/16/xindex.html#XINDEX-SUPPORT" title="38.16.3. Index Method Support Routines">Section 38.16.3</a>). If <code>access-method-pattern</code> is specified, only functions of operator families associated with access methods whose names match that pattern are listed. If <code>operator-family-pattern</code> is specified, only functions of operator families whose names match that pattern are listed. If <code class="literal">+</code> is appended to the command name, functions are displayed verbosely, with their actual parameter lists.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DB">
<code class="literal">\db[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists tablespaces. If <code>pattern</code> is specified, only tablespaces whose names match the pattern are shown. If <code class="literal">+</code> is appended to the command name, each tablespace is listed with its associated options, on-disk size, permissions and description.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DC-LC">
<code class="literal">\dc[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists conversions between character-set encodings. If <code>pattern</code> is specified, only conversions whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects. If <code class="literal">+</code> is appended to the command name, each object is listed with its associated description.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DCONFIG">
<code class="literal">\dconfig[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists server configuration parameters and their values. If <code>pattern</code> is specified, only parameters whose names match the pattern are listed. Without a <code>pattern</code>, only parameters that are set to non-default values are listed. (Use <code class="literal">\dconfig *</code> to see all parameters.) If <code class="literal">+</code> is appended to the command name, each parameter is listed with its data type, context in which the parameter can be set, and access privileges (if non-default access privileges have been granted).</p> </dd> <dt id="APP-PSQL-META-COMMAND-DC-UC">
<code class="literal">\dC[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists type casts. If <code>pattern</code> is specified, only casts whose source or target types match the pattern are listed. If <code class="literal">+</code> is appended to the command name, each object is listed with its associated description.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DD-LC">
<code class="literal">\dd[S] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Shows the descriptions of objects of type <code class="literal">constraint</code>, <code class="literal">operator class</code>, <code class="literal">operator family</code>, <code class="literal">rule</code>, and <code class="literal">trigger</code>. All other comments may be viewed by the respective backslash commands for those object types.</p> <p><code class="literal">\dd</code> displays descriptions for objects matching the <code>pattern</code>, or of visible objects of the appropriate type if no argument is given. But in either case, only objects that have a description are listed. By default, only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects.</p> <p>Descriptions for objects can be created with the <a class="link" href="sql-comment.html" title="COMMENT"><code class="command">COMMENT</code></a> SQL command.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DD-UC">
<code class="literal">\dD[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists domains. If <code>pattern</code> is specified, only domains whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects. If <code class="literal">+</code> is appended to the command name, each object is listed with its associated permissions and description.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DDP">
<code class="literal">\ddp [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists default access privilege settings. An entry is shown for each role (and schema, if applicable) for which the default privilege settings have been changed from the built-in defaults. If <code>pattern</code> is specified, only entries whose role name or schema name matches the pattern are listed.</p> <p>The <a class="link" href="sql-alterdefaultprivileges.html" title="ALTER DEFAULT PRIVILEGES"><code class="command">ALTER DEFAULT PRIVILEGES</code></a> command is used to set default access privileges. The meaning of the privilege display is explained in <a class="xref" href="ddl-priv.html" title="5.7. Privileges">Section 5.7</a>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DE">
<code class="literal">\dE[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code><code class="literal">\di[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code><code class="literal">\dm[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code><code class="literal">\ds[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code><code class="literal">\dt[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code><code class="literal">\dv[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>In this group of commands, the letters <code class="literal">E</code>, <code class="literal">i</code>, <code class="literal">m</code>, <code class="literal">s</code>, <code class="literal">t</code>, and <code class="literal">v</code> stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, <code class="literal">\dti</code> lists tables and indexes. If <code class="literal">+</code> is appended to the command name, each object is listed with its persistence status (permanent, temporary, or unlogged), physical size on disk, and associated description if any. If <code>pattern</code> is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DES">
<code class="literal">\des[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists foreign servers (mnemonic: <span class="quote">“<span class="quote">external servers</span>”</span>). If <code>pattern</code> is specified, only those servers whose name matches the pattern are listed. If the form <code class="literal">\des+</code> is used, a full description of each server is shown, including the server's access privileges, type, version, options, and description.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DET">
<code class="literal">\det[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists foreign tables (mnemonic: <span class="quote">“<span class="quote">external tables</span>”</span>). If <code>pattern</code> is specified, only entries whose table name or schema name matches the pattern are listed. If the form <code class="literal">\det+</code> is used, generic options and the foreign table description are also displayed.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DEU">
<code class="literal">\deu[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists user mappings (mnemonic: <span class="quote">“<span class="quote">external users</span>”</span>). If <code>pattern</code> is specified, only those mappings whose user names match the pattern are listed. If the form <code class="literal">\deu+</code> is used, additional information about each mapping is shown.</p> <blockquote class="caution"> <h3 class="title">Caution</h3> <p><code class="literal">\deu+</code> might also display the user name and password of the remote user, so care should be taken not to disclose them.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-DEW">
<code class="literal">\dew[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists foreign-data wrappers (mnemonic: <span class="quote">“<span class="quote">external wrappers</span>”</span>). If <code>pattern</code> is specified, only those foreign-data wrappers whose name matches the pattern are listed. If the form <code class="literal">\dew+</code> is used, the access privileges, options, and description of the foreign-data wrapper are also shown.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DF-LC">
<code class="literal">\df[anptwS+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> [ arg_pattern ... ] ]</code> </dt> <dd> <p>Lists functions, together with their result data types, argument data types, and function types, which are classified as <span class="quote">“<span class="quote">agg</span>”</span> (aggregate), <span class="quote">“<span class="quote">normal</span>”</span>, <span class="quote">“<span class="quote">procedure</span>”</span>, <span class="quote">“<span class="quote">trigger</span>”</span>, or <span class="quote">“<span class="quote">window</span>”</span>. To display only functions of specific type(s), add the corresponding letters <code class="literal">a</code>, <code class="literal">n</code>, <code class="literal">p</code>, <code class="literal">t</code>, or <code class="literal">w</code> to the command. If <code>pattern</code> is specified, only functions whose names match the pattern are shown. Any additional arguments are type-name patterns, which are matched to the type names of the first, second, and so on arguments of the function. (Matching functions can have more arguments than what you specify. To prevent that, write a dash <code class="literal">-</code> as the last <code>arg_pattern</code>.) By default, only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects. If the form <code class="literal">\df+</code> is used, additional information about each function is shown, including volatility, parallel safety, owner, security classification, access privileges, language, internal name (for C and internal functions only), and description. Source code for a specific function can be seen using <code class="literal">\sf</code>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DF-UC">
<code class="literal">\dF[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists text search configurations. If <code>pattern</code> is specified, only configurations whose names match the pattern are shown. If the form <code class="literal">\dF+</code> is used, a full description of each configuration is shown, including the underlying text search parser and the dictionary list for each parser token type.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DFD">
<code class="literal">\dFd[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists text search dictionaries. If <code>pattern</code> is specified, only dictionaries whose names match the pattern are shown. If the form <code class="literal">\dFd+</code> is used, additional information is shown about each selected dictionary, including the underlying text search template and the option values.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DFP">
<code class="literal">\dFp[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists text search parsers. If <code>pattern</code> is specified, only parsers whose names match the pattern are shown. If the form <code class="literal">\dFp+</code> is used, a full description of each parser is shown, including the underlying functions and the list of recognized token types.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DFT">
<code class="literal">\dFt[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists text search templates. If <code>pattern</code> is specified, only templates whose names match the pattern are shown. If the form <code class="literal">\dFt+</code> is used, additional information is shown about each template, including the underlying function names.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DG">
<code class="literal">\dg[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists database roles. (Since the concepts of <span class="quote">“<span class="quote">users</span>”</span> and <span class="quote">“<span class="quote">groups</span>”</span> have been unified into <span class="quote">“<span class="quote">roles</span>”</span>, this command is now equivalent to <code class="literal">\du</code>.) By default, only user-created roles are shown; supply the <code class="literal">S</code> modifier to include system roles. If <code>pattern</code> is specified, only those roles whose names match the pattern are listed. If the form <code class="literal">\dg+</code> is used, additional information is shown about each role; currently this adds the comment for each role.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DL-LC">
<code class="literal">\dl[+]</code> </dt> <dd> <p>This is an alias for <code class="command">\lo_list</code>, which shows a list of large objects. If <code class="literal">+</code> is appended to the command name, each large object is listed with its associated permissions, if any.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DL-UC">
<code class="literal">\dL[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists procedural languages. If <code>pattern</code> is specified, only languages whose names match the pattern are listed. By default, only user-created languages are shown; supply the <code class="literal">S</code> modifier to include system objects. If <code class="literal">+</code> is appended to the command name, each language is listed with its call handler, validator, access privileges, and whether it is a system object.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DN">
<code class="literal">\dn[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists schemas (namespaces). If <code>pattern</code> is specified, only schemas whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects. If <code class="literal">+</code> is appended to the command name, each object is listed with its associated permissions and description, if any.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DO-LC">
<code class="literal">\do[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> [ arg_pattern [ arg_pattern ] ] ]</code> </dt> <dd> <p>Lists operators with their operand and result types. If <code>pattern</code> is specified, only operators whose names match the pattern are listed. If one <code>arg_pattern</code> is specified, only prefix operators whose right argument's type name matches that pattern are listed. If two <code>arg_pattern</code>s are specified, only binary operators whose argument type names match those patterns are listed. (Alternatively, write <code class="literal">-</code> for the unused argument of a unary operator.) By default, only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects. If <code class="literal">+</code> is appended to the command name, additional information about each operator is shown, currently just the name of the underlying function.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DO-UC">
<code class="literal">\dO[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists collations. If <code>pattern</code> is specified, only collations whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects. If <code class="literal">+</code> is appended to the command name, each collation is listed with its associated description, if any. Note that only collations usable with the current database's encoding are shown, so the results may vary in different databases of the same installation.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DP-LC">
<code class="literal">\dp[S] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists tables, views and sequences with their associated access privileges. If <code>pattern</code> is specified, only tables, views and sequences whose names match the pattern are listed. By default only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects.</p> <p>The <a class="link" href="sql-grant.html" title="GRANT"><code class="command">GRANT</code></a> and <a class="link" href="sql-revoke.html" title="REVOKE"><code class="command">REVOKE</code></a> commands are used to set access privileges. The meaning of the privilege display is explained in <a class="xref" href="ddl-priv.html" title="5.7. Privileges">Section 5.7</a>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DP-UC">
<code class="literal">\dP[itn+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists partitioned relations. If <code>pattern</code> is specified, only entries whose name matches the pattern are listed. The modifiers <code class="literal">t</code> (tables) and <code class="literal">i</code> (indexes) can be appended to the command, filtering the kind of relations to list. By default, partitioned tables and indexes are listed.</p> <p>If the modifier <code class="literal">n</code> (<span class="quote">“<span class="quote">nested</span>”</span>) is used, or a pattern is specified, then non-root partitioned relations are included, and a column is shown displaying the parent of each partitioned relation.</p> <p>If <code class="literal">+</code> is appended to the command name, the sum of the sizes of each relation's partitions is also displayed, along with the relation's description. If <code class="literal">n</code> is combined with <code class="literal">+</code>, two sizes are shown: one including the total size of directly-attached leaf partitions, and another showing the total size of all partitions, including indirectly attached sub-partitions.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DRDS">
<code class="literal">\drds [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">role-pattern</a> [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">database-pattern</a> ] ]</code> </dt> <dd> <p>Lists defined configuration settings. These settings can be role-specific, database-specific, or both. <code>role-pattern</code> and <code>database-pattern</code> are used to select specific roles and databases to list, respectively. If omitted, or if <code class="literal">*</code> is specified, all settings are listed, including those not role-specific or database-specific, respectively.</p> <p>The <a class="link" href="sql-alterrole.html" title="ALTER ROLE"><code class="command">ALTER ROLE</code></a> and <a class="link" href="sql-alterdatabase.html" title="ALTER DATABASE"><code class="command">ALTER DATABASE</code></a> commands are used to define per-role and per-database configuration settings.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DRG">
<code class="literal">\drg[S] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists information about each granted role membership, including assigned options (<code class="literal">ADMIN</code>, <code class="literal">INHERIT</code> and/or <code class="literal">SET</code>) and grantor. See the <a class="link" href="sql-grant.html" title="GRANT"><code class="command">GRANT</code></a> command for information about role memberships.</p> <p>By default, only grants to user-created roles are shown; supply the <code class="literal">S</code> modifier to include system roles. If <code>pattern</code> is specified, only grants to those roles whose names match the pattern are listed.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DRP">
<code class="literal">\dRp[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists replication publications. If <code>pattern</code> is specified, only those publications whose names match the pattern are listed. If <code class="literal">+</code> is appended to the command name, the tables and schemas associated with each publication are shown as well.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DRS">
<code class="literal">\dRs[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists replication subscriptions. If <code>pattern</code> is specified, only those subscriptions whose names match the pattern are listed. If <code class="literal">+</code> is appended to the command name, additional properties of the subscriptions are shown.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DT">
<code class="literal">\dT[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists data types. If <code>pattern</code> is specified, only types whose names match the pattern are listed. If <code class="literal">+</code> is appended to the command name, each type is listed with its internal name and size, its allowed values if it is an <code class="type">enum</code> type, and its associated permissions. By default, only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DU">
<code class="literal">\du[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists database roles. (Since the concepts of <span class="quote">“<span class="quote">users</span>”</span> and <span class="quote">“<span class="quote">groups</span>”</span> have been unified into <span class="quote">“<span class="quote">roles</span>”</span>, this command is now equivalent to <code class="literal">\dg</code>.) By default, only user-created roles are shown; supply the <code class="literal">S</code> modifier to include system roles. If <code>pattern</code> is specified, only those roles whose names match the pattern are listed. If the form <code class="literal">\du+</code> is used, additional information is shown about each role; currently this adds the comment for each role.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DX-LC">
<code class="literal">\dx[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists installed extensions. If <code>pattern</code> is specified, only those extensions whose names match the pattern are listed. If the form <code class="literal">\dx+</code> is used, all the objects belonging to each matching extension are listed.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DX-UC">
<code class="literal">\dX [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists extended statistics. If <code>pattern</code> is specified, only those extended statistics whose names match the pattern are listed.</p> <p>The status of each kind of extended statistics is shown in a column named after its statistic kind (e.g. Ndistinct). <code class="literal">defined</code> means that it was requested when creating the statistics, and NULL means it wasn't requested. You can use <code class="structname">pg_stats_ext</code> if you'd like to know whether <a class="link" href="sql-analyze.html" title="ANALYZE"><code class="command">ANALYZE</code></a> was run and statistics are available to the planner.</p> </dd> <dt id="APP-PSQL-META-COMMAND-DY">
<code class="literal">\dy[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists event triggers. If <code>pattern</code> is specified, only those event triggers whose names match the pattern are listed. If <code class="literal">+</code> is appended to the command name, each object is listed with its associated description.</p> </dd> <dt id="APP-PSQL-META-COMMAND-EDIT">
<code class="literal">\e</code> or <code class="literal">\edit</code> <code class="literal">[ filename ] [ line_number ]</code> </dt> <dd> <p>If <code>filename</code> is specified, the file is edited; after the editor exits, the file's content is copied into the current query buffer. If no <code>filename</code> is given, the current query buffer is copied to a temporary file which is then edited in the same fashion. Or, if the current query buffer is empty, the most recently executed query is copied to a temporary file and edited in the same fashion.</p> <p>If you edit a file or the previous query, and you quit the editor without modifying the file, the query buffer is cleared. Otherwise, the new contents of the query buffer are re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed and removed from the query buffer. Whatever remains in the query buffer is redisplayed. Type semicolon or <code class="literal">\g</code> to send it, or <code class="literal">\r</code> to cancel it by clearing the query buffer.</p> <p>Treating the buffer as a single line primarily affects meta-commands: whatever is in the buffer after a meta-command will be taken as argument(s) to the meta-command, even if it spans multiple lines. (Thus you cannot make meta-command-using scripts this way. Use <code class="command">\i</code> for that.)</p> <p>If a line number is specified, psql will position the cursor on the specified line of the file or query buffer. Note that if a single all-digits argument is given, psql assumes it is a line number, not a file name.</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>See <a class="xref" href="app-psql.html#APP-PSQL-ENVIRONMENT" title="Environment">Environment</a>, below, for how to configure and customize your editor.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-ECHO">
<code class="literal">\echo text [ ... ]</code> </dt> <dd> <p>Prints the evaluated arguments to standard output, separated by spaces and followed by a newline. This can be useful to intersperse information in the output of scripts. For example:</p> <pre data-language="sql">
=&gt; <strong class="userinput">\echo `date`</strong>
Tue Oct 26 21:40:57 CEST 1999
</pre> <p>If the first argument is an unquoted <code class="literal">-n</code> the trailing newline is not written (nor is the first argument).</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>If you use the <code class="command">\o</code> command to redirect your query output you might wish to use <code class="command">\qecho</code> instead of this command. See also <code class="command">\warn</code>.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-EF">
<code class="literal">\ef [ function_description [ line_number ] ]</code> </dt> <dd> <p>This command fetches and edits the definition of the named function or procedure, in the form of a <code class="command">CREATE OR REPLACE FUNCTION</code> or <code class="command">CREATE OR REPLACE PROCEDURE</code> command. Editing is done in the same way as for <code class="literal">\edit</code>. If you quit the editor without saving, the statement is discarded. If you save and exit the editor, the updated command is executed immediately if you added a semicolon to it. Otherwise it is redisplayed; type semicolon or <code class="literal">\g</code> to send it, or <code class="literal">\r</code> to cancel.</p> <p>The target function can be specified by name alone, or by name and arguments, for example <code class="literal">foo(integer, text)</code>. The argument types must be given if there is more than one function of the same name.</p> <p>If no function is specified, a blank <code class="command">CREATE FUNCTION</code> template is presented for editing.</p> <p>If a line number is specified, psql will position the cursor on the specified line of the function body. (Note that the function body typically does not begin on the first line of the file.)</p> <p>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of <code class="command">\ef</code>, and neither variable interpolation nor backquote expansion are performed in the arguments.</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>See <a class="xref" href="app-psql.html#APP-PSQL-ENVIRONMENT" title="Environment">Environment</a>, below, for how to configure and customize your editor.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-ENCODING">
<code class="literal">\encoding [ encoding ]</code> </dt> <dd> <p>Sets the client character set encoding. Without an argument, this command shows the current encoding.</p> </dd> <dt id="APP-PSQL-META-COMMAND-ERRVERBOSE">
<code class="literal">\errverbose</code> </dt> <dd> <p>Repeats the most recent server error message at maximum verbosity, as though <code class="varname">VERBOSITY</code> were set to <code class="literal">verbose</code> and <code class="varname">SHOW_CONTEXT</code> were set to <code class="literal">always</code>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-EV">
<code class="literal">\ev [ view_name [ line_number ] ]</code> </dt> <dd> <p>This command fetches and edits the definition of the named view, in the form of a <code class="command">CREATE OR REPLACE VIEW</code> command. Editing is done in the same way as for <code class="literal">\edit</code>. If you quit the editor without saving, the statement is discarded. If you save and exit the editor, the updated command is executed immediately if you added a semicolon to it. Otherwise it is redisplayed; type semicolon or <code class="literal">\g</code> to send it, or <code class="literal">\r</code> to cancel.</p> <p>If no view is specified, a blank <code class="command">CREATE VIEW</code> template is presented for editing.</p> <p>If a line number is specified, psql will position the cursor on the specified line of the view definition.</p> <p>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of <code class="command">\ev</code>, and neither variable interpolation nor backquote expansion are performed in the arguments.</p> </dd> <dt id="APP-PSQL-META-COMMAND-F">
<code class="literal">\f [ string ]</code> </dt> <dd> <p>Sets the field separator for unaligned query output. The default is the vertical bar (<code class="literal">|</code>). It is equivalent to <code class="command">\pset fieldsep</code>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-G">
<code class="literal">\g [ (option=value [...]) ] [ filename ]</code><code class="literal">\g [ (option=value [...]) ] [ |command ]</code> </dt> <dd> <p>Sends the current query buffer to the server for execution.</p> <p>If parentheses appear after <code class="literal">\g</code>, they surround a space-separated list of <code>option</code><code class="literal">=</code><code>value</code> formatting-option clauses, which are interpreted in the same way as <code class="literal">\pset</code> <code>option</code> <code>value</code> commands, but take effect only for the duration of this query. In this list, spaces are not allowed around <code class="literal">=</code> signs, but are required between option clauses. If <code class="literal">=</code><code>value</code> is omitted, the named <code>option</code> is changed in the same way as for <code class="literal">\pset</code> <code>option</code> with no explicit <code>value</code>.</p> <p>If a <code>filename</code> or <code class="literal">|</code><code>command</code> argument is given, the query's output is written to the named file or piped to the given shell command, instead of displaying it as usual. The file or command is written to only if the query successfully returns zero or more tuples, not if the query fails or is a non-data-returning SQL command.</p> <p>If the current query buffer is empty, the most recently sent query is re-executed instead. Except for that behavior, <code class="literal">\g</code> without any arguments is essentially equivalent to a semicolon. With arguments, <code class="literal">\g</code> provides a <span class="quote">“<span class="quote">one-shot</span>”</span> alternative to the <code class="command">\o</code> command, and additionally allows one-shot adjustments of the output formatting options normally set by <code class="literal">\pset</code>.</p> <p>When the last argument begins with <code class="literal">|</code>, the entire remainder of the line is taken to be the <code>command</code> to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</p> </dd> <dt id="APP-PSQL-META-COMMAND-GDESC">
<code class="literal">\gdesc</code> </dt> <dd> <p>Shows the description (that is, the column names and data types) of the result of the current query buffer. The query is not actually executed; however, if it contains some type of syntax error, that error will be reported in the normal way.</p> <p>If the current query buffer is empty, the most recently sent query is described instead.</p> </dd> <dt id="APP-PSQL-META-COMMAND-GETENV">
<code class="literal">\getenv psql_var env_var</code> </dt> <dd> <p>Gets the value of the environment variable <code>env_var</code> and assigns it to the psql variable <code>psql_var</code>. If <code>env_var</code> is not defined in the psql process's environment, <code>psql_var</code> is not changed. Example:</p> <pre data-language="sql">
=&gt; <strong class="userinput">\getenv home HOME</strong>
=&gt; <strong class="userinput">\echo :home</strong>
/home/postgres
</pre> </dd> <dt id="APP-PSQL-META-COMMAND-GEXEC">
<code class="literal">\gexec</code> </dt> <dd> <p>Sends the current query buffer to the server, then treats each column of each row of the query's output (if any) as an SQL statement to be executed. For example, to create an index on each column of <code class="structname">my_table</code>:</p> <pre data-language="sql">
=&gt; <strong class="userinput">SELECT format('create index on my_table(%I)', attname)</strong>
-&gt; <strong class="userinput">FROM pg_attribute</strong>
-&gt; <strong class="userinput">WHERE attrelid = 'my_table'::regclass AND attnum &gt; 0</strong>
-&gt; <strong class="userinput">ORDER BY attnum</strong>
-&gt; <strong class="userinput">\gexec</strong>
CREATE INDEX
CREATE INDEX
CREATE INDEX
CREATE INDEX
</pre> <p>The generated queries are executed in the order in which the rows are returned, and left-to-right within each row if there is more than one column. NULL fields are ignored. The generated queries are sent literally to the server for processing, so they cannot be psql meta-commands nor contain psql variable references. If any individual query fails, execution of the remaining queries continues unless <code class="varname">ON_ERROR_STOP</code> is set. Execution of each query is subject to <code class="varname">ECHO</code> processing. (Setting <code class="varname">ECHO</code> to <code class="literal">all</code> or <code class="literal">queries</code> is often advisable when using <code class="command">\gexec</code>.) Query logging, single-step mode, timing, and other query execution features apply to each generated query as well.</p> <p>If the current query buffer is empty, the most recently sent query is re-executed instead.</p> </dd> <dt id="APP-PSQL-META-COMMAND-GSET">
<code class="literal">\gset [ prefix ]</code> </dt> <dd> <p>Sends the current query buffer to the server and stores the query's output into psql variables (see <a class="xref" href="app-psql.html#APP-PSQL-VARIABLES" title="Variables">Variables</a> below). The query to be executed must return exactly one row. Each column of the row is stored into a separate variable, named the same as the column. For example:</p> <pre data-language="sql">
=&gt; <strong class="userinput">SELECT 'hello' AS var1, 10 AS var2</strong>
-&gt; <strong class="userinput">\gset</strong>
=&gt; <strong class="userinput">\echo :var1 :var2</strong>
hello 10
</pre> <p>If you specify a <code>prefix</code>, that string is prepended to the query's column names to create the variable names to use:</p> <pre data-language="sql">
=&gt; <strong class="userinput">SELECT 'hello' AS var1, 10 AS var2</strong>
-&gt; <strong class="userinput">\gset result_</strong>
=&gt; <strong class="userinput">\echo :result_var1 :result_var2</strong>
hello 10
</pre> <p>If a column result is NULL, the corresponding variable is unset rather than being set.</p> <p>If the query fails or does not return one row, no variables are changed.</p> <p>If the current query buffer is empty, the most recently sent query is re-executed instead.</p> </dd> <dt id="APP-PSQL-META-COMMAND-GX">
<code class="literal">\gx [ (option=value [...]) ] [ filename ]</code><code class="literal">\gx [ (option=value [...]) ] [ |command ]</code> </dt> <dd> <p><code class="literal">\gx</code> is equivalent to <code class="literal">\g</code>, except that it forces expanded output mode for this query, as if <code class="literal">expanded=on</code> were included in the list of <code class="literal">\pset</code> options. See also <code class="literal">\x</code>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-HELP">
<code class="literal">\h</code> or <code class="literal">\help</code> <code class="literal">[ command ]</code> </dt> <dd> <p>Gives syntax help on the specified SQL command. If <code>command</code> is not specified, then psql will list all the commands for which syntax help is available. If <code>command</code> is an asterisk (<code class="literal">*</code>), then syntax help on all SQL commands is shown.</p> <p>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of <code class="command">\help</code>, and neither variable interpolation nor backquote expansion are performed in the arguments.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>To simplify typing, commands that consists of several words do not have to be quoted. Thus it is fine to type <strong class="userinput"><code>\help alter table</code></strong>.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-HTML">
<code class="literal">\H</code> or <code class="literal">\html</code> </dt> <dd> <p>Turns on HTML query output format. If the HTML format is already on, it is switched back to the default aligned text format. This command is for compatibility and convenience, but see <code class="command">\pset</code> about setting other output options.</p> </dd> <dt id="APP-PSQL-META-COMMAND-INCLUDE">
<code class="literal">\i</code> or <code class="literal">\include</code> <code>filename</code> </dt> <dd> <p>Reads input from the file <code>filename</code> and executes it as though it had been typed on the keyboard.</p> <p>If <code>filename</code> is <code class="literal">-</code> (hyphen), then standard input is read until an EOF indication or <code class="command">\q</code> meta-command. This can be used to intersperse interactive input with input from files. Note that Readline behavior will be used only if it is active at the outermost level.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>If you want to see the lines on the screen as they are read you must set the variable <code class="varname">ECHO</code> to <code class="literal">all</code>.</p> </blockquote> </dd> <dt id="PSQL-METACOMMAND-IF">
<code class="literal">\if</code> <code>expression</code><code class="literal">\elif</code> <code>expression</code><code class="literal">\else</code><code class="literal">\endif</code> </dt> <dd> <p>This group of commands implements nestable conditional blocks. A conditional block must begin with an <code class="command">\if</code> and end with an <code class="command">\endif</code>. In between there may be any number of <code class="command">\elif</code> clauses, which may optionally be followed by a single <code class="command">\else</code> clause. Ordinary queries and other types of backslash commands may (and usually do) appear between the commands forming a conditional block.</p> <p>The <code class="command">\if</code> and <code class="command">\elif</code> commands read their argument(s) and evaluate them as a Boolean expression. If the expression yields <code class="literal">true</code> then processing continues normally; otherwise, lines are skipped until a matching <code class="command">\elif</code>, <code class="command">\else</code>, or <code class="command">\endif</code> is reached. Once an <code class="command">\if</code> or <code class="command">\elif</code> test has succeeded, the arguments of later <code class="command">\elif</code> commands in the same block are not evaluated but are treated as false. Lines following an <code class="command">\else</code> are processed only if no earlier matching <code class="command">\if</code> or <code class="command">\elif</code> succeeded.</p> <p>The <code>expression</code> argument of an <code class="command">\if</code> or <code class="command">\elif</code> command is subject to variable interpolation and backquote expansion, just like any other backslash command argument. After that it is evaluated like the value of an on/off option variable. So a valid value is any unambiguous case-insensitive match for one of: <code class="literal">true</code>, <code class="literal">false</code>, <code class="literal">1</code>, <code class="literal">0</code>, <code class="literal">on</code>, <code class="literal">off</code>, <code class="literal">yes</code>, <code class="literal">no</code>. For example, <code class="literal">t</code>, <code class="literal">T</code>, and <code class="literal">tR</code> will all be considered to be <code class="literal">true</code>.</p> <p>Expressions that do not properly evaluate to true or false will generate a warning and be treated as false.</p> <p>Lines being skipped are parsed normally to identify queries and backslash commands, but queries are not sent to the server, and backslash commands other than conditionals (<code class="command">\if</code>, <code class="command">\elif</code>, <code class="command">\else</code>, <code class="command">\endif</code>) are ignored. Conditional commands are checked only for valid nesting. Variable references in skipped lines are not expanded, and backquote expansion is not performed either.</p> <p>All the backslash commands of a given conditional block must appear in the same source file. If EOF is reached on the main input file or an <code class="command">\include</code>-ed file before all local <code class="command">\if</code>-blocks have been closed, then psql will raise an error.</p> <p>Here is an example:</p> <pre data-language="sql">
-- check for the existence of two separate records in the database and store
-- the results in separate psql variables
SELECT
    EXISTS(SELECT 1 FROM customer WHERE customer_id = 123) as is_customer,
    EXISTS(SELECT 1 FROM employee WHERE employee_id = 456) as is_employee
\gset
\if :is_customer
    SELECT * FROM customer WHERE customer_id = 123;
\elif :is_employee
    \echo 'is not a customer but is an employee'
    SELECT * FROM employee WHERE employee_id = 456;
\else
    \if yes
        \echo 'not a customer or employee'
    \else
        \echo 'this will never print'
    \endif
\endif
</pre> </dd> <dt id="APP-PSQL-META-COMMAND-INCLUDE-RELATIVE">
<code class="literal">\ir</code> or <code class="literal">\include_relative</code> <code>filename</code> </dt> <dd> <p>The <code class="literal">\ir</code> command is similar to <code class="literal">\i</code>, but resolves relative file names differently. When executing in interactive mode, the two commands behave identically. However, when invoked from a script, <code class="literal">\ir</code> interprets file names relative to the directory in which the script is located, rather than the current working directory.</p> </dd> <dt id="APP-PSQL-META-COMMAND-LIST">
<code class="literal">\l[+]</code> or <code class="literal">\list[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>List the databases in the server and show their names, owners, character set encodings, and access privileges. If <code>pattern</code> is specified, only databases whose names match the pattern are listed. If <code class="literal">+</code> is appended to the command name, database sizes, default tablespaces, and descriptions are also displayed. (Size information is only available for databases that the current user can connect to.)</p> </dd> <dt id="APP-PSQL-META-COMMAND-LO-EXPORT">
<code class="literal">\lo_export loid filename</code> </dt> <dd> <p>Reads the large object with OID <code>loid</code> from the database and writes it to <code>filename</code>. Note that this is subtly different from the server function <code class="function">lo_export</code>, which acts with the permissions of the user that the database server runs as and on the server's file system.</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>Use <code class="command">\lo_list</code> to find out the large object's OID.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-LO-IMPORT">
<code class="literal">\lo_import filename [ comment ]</code> </dt> <dd> <p>Stores the file into a PostgreSQL large object. Optionally, it associates the given comment with the object. Example:</p> <pre data-language="sql">
foo=&gt; <strong class="userinput">\lo_import '/home/peter/pictures/photo.xcf' 'a picture of me'</strong>
lo_import 152801
</pre> <p>The response indicates that the large object received object ID 152801, which can be used to access the newly-created large object in the future. For the sake of readability, it is recommended to always associate a human-readable comment with every object. Both OIDs and comments can be viewed with the <code class="command">\lo_list</code> command.</p> <p>Note that this command is subtly different from the server-side <code class="function">lo_import</code> because it acts as the local user on the local file system, rather than the server's user and file system.</p> </dd> <dt id="APP-PSQL-META-COMMAND-LO-LIST">
<code class="literal">\lo_list[+]</code> </dt> <dd> <p>Shows a list of all PostgreSQL large objects currently stored in the database, along with any comments provided for them. If <code class="literal">+</code> is appended to the command name, each large object is listed with its associated permissions, if any.</p> </dd> <dt id="APP-PSQL-META-COMMAND-LO-UNLINK">
<code class="literal">\lo_unlink loid</code> </dt> <dd> <p>Deletes the large object with OID <code>loid</code> from the database.</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>Use <code class="command">\lo_list</code> to find out the large object's OID.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-OUT">
<code class="literal">\o</code> or <code class="literal">\out [ filename ]</code><code class="literal">\o</code> or <code class="literal">\out [ |command ]</code> </dt> <dd> <p>Arranges to save future query results to the file <code>filename</code> or pipe future results to the shell command <code>command</code>. If no argument is specified, the query output is reset to the standard output.</p> <p>If the argument begins with <code class="literal">|</code>, then the entire remainder of the line is taken to be the <code>command</code> to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</p> <p><span class="quote">“<span class="quote">Query results</span>”</span> includes all tables, command responses, and notices obtained from the database server, as well as output of various backslash commands that query the database (such as <code class="command">\d</code>); but not error messages.</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>To intersperse text output in between query results, use <code class="command">\qecho</code>.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-PRINT">
<code class="literal">\p</code> or <code class="literal">\print</code> </dt> <dd> <p>Print the current query buffer to the standard output. If the current query buffer is empty, the most recently executed query is printed instead.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PASSWORD">
<code class="literal">\password [ username ]</code> </dt> <dd> <p>Changes the password of the specified user (by default, the current user). This command prompts for the new password, encrypts it, and sends it to the server as an <code class="command">ALTER ROLE</code> command. This makes sure that the new password does not appear in cleartext in the command history, the server log, or elsewhere.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PROMPT">
<code class="literal">\prompt [ text ] name</code> </dt> <dd> <p>Prompts the user to supply text, which is assigned to the variable <code>name</code>. An optional prompt string, <code>text</code>, can be specified. (For multiword prompts, surround the text with single quotes.)</p> <p>By default, <code class="literal">\prompt</code> uses the terminal for input and output. However, if the <code class="option">-f</code> command line switch was used, <code class="literal">\prompt</code> uses standard input and standard output.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET">
<code class="literal">\pset [ option [ value ] ]</code> </dt> <dd> <p>This command sets options affecting the output of query result tables. <code>option</code> indicates which option is to be set. The semantics of <code>value</code> vary depending on the selected option. For some options, omitting <code>value</code> causes the option to be toggled or unset, as described under the particular option. If no such behavior is mentioned, then omitting <code>value</code> just results in the current setting being displayed.</p> <p><code class="command">\pset</code> without any arguments displays the current status of all printing options.</p> <p>Adjustable printing options are:</p> <div class="variablelist"> <dl class="variablelist"> <dt id="APP-PSQL-META-COMMAND-PSET-BORDER">
<code class="literal">border</code> </dt> <dd> <p>The <code>value</code> must be a number. In general, the higher the number the more borders and lines the tables will have, but details depend on the particular format. In HTML format, this will translate directly into the <code class="literal">border=...</code> attribute. In most other formats only values 0 (no border), 1 (internal dividing lines), and 2 (table frame) make sense, and values above 2 will be treated the same as <code class="literal">border = 2</code>. The <code class="literal">latex</code> and <code class="literal">latex-longtable</code> formats additionally allow a value of 3 to add dividing lines between data rows.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-COLUMNS">
<code class="literal">columns</code> </dt> <dd> <p>Sets the target width for the <code class="literal">wrapped</code> format, and also the width limit for determining whether output is wide enough to require the pager or switch to the vertical display in expanded auto mode. Zero (the default) causes the target width to be controlled by the environment variable <code class="envar">COLUMNS</code>, or the detected screen width if <code class="envar">COLUMNS</code> is not set. In addition, if <code class="literal">columns</code> is zero then the <code class="literal">wrapped</code> format only affects screen output. If <code class="literal">columns</code> is nonzero then file and pipe output is wrapped to that width as well.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-CSV-FIELDSEP">
<code class="literal">csv_fieldsep</code> </dt> <dd> <p>Specifies the field separator to be used in CSV output format. If the separator character appears in a field's value, that field is output within double quotes, following standard CSV rules. The default is a comma.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-EXPANDED">
<code class="literal">expanded</code> (or <code class="literal">x</code>) </dt> <dd> <p>If <code>value</code> is specified it must be either <code class="literal">on</code> or <code class="literal">off</code>, which will enable or disable expanded mode, or <code class="literal">auto</code>. If <code>value</code> is omitted the command toggles between the on and off settings. When expanded mode is enabled, query results are displayed in two columns, with the column name on the left and the data on the right. This mode is useful if the data wouldn't fit on the screen in the normal <span class="quote">“<span class="quote">horizontal</span>”</span> mode. In the auto setting, the expanded mode is used whenever the query output has more than one column and is wider than the screen; otherwise, the regular mode is used. The auto setting is only effective in the aligned and wrapped formats. In other formats, it always behaves as if the expanded mode is off.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-FIELDSEP">
<code class="literal">fieldsep</code> </dt> <dd> <p>Specifies the field separator to be used in unaligned output format. That way one can create, for example, tab-separated output, which other programs might prefer. To set a tab as field separator, type <code class="literal">\pset fieldsep '\t'</code>. The default field separator is <code class="literal">'|'</code> (a vertical bar).</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-FIELDSEP-ZERO">
<code class="literal">fieldsep_zero</code> </dt> <dd> <p>Sets the field separator to use in unaligned output format to a zero byte.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-FOOTER">
<code class="literal">footer</code> </dt> <dd> <p>If <code>value</code> is specified it must be either <code class="literal">on</code> or <code class="literal">off</code> which will enable or disable display of the table footer (the <code class="literal">(n rows)</code> count). If <code>value</code> is omitted the command toggles footer display on or off.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-FORMAT">
<code class="literal">format</code> </dt> <dd> <p>Sets the output format to one of <code class="literal">aligned</code>, <code class="literal">asciidoc</code>, <code class="literal">csv</code>, <code class="literal">html</code>, <code class="literal">latex</code>, <code class="literal">latex-longtable</code>, <code class="literal">troff-ms</code>, <code class="literal">unaligned</code>, or <code class="literal">wrapped</code>. Unique abbreviations are allowed.</p> <p><code class="literal">aligned</code> format is the standard, human-readable, nicely formatted text output; this is the default.</p> <p><code class="literal">unaligned</code> format writes all columns of a row on one line, separated by the currently active field separator. This is useful for creating output that might be intended to be read in by other programs, for example, tab-separated or comma-separated format. However, the field separator character is not treated specially if it appears in a column's value; so CSV format may be better suited for such purposes.</p> <p id="id-1.9.4.20.8.4.10.1.78.2.3.1.8.2.4.2"><code class="literal">csv</code> format  writes column values separated by commas, applying the quoting rules described in <a class="ulink" href="https://tools.ietf.org/html/rfc4180" target="_top">RFC 4180</a>. This output is compatible with the CSV format of the server's <code class="command">COPY</code> command. A header line with column names is generated unless the <code class="literal">tuples_only</code> parameter is <code class="literal">on</code>. Titles and footers are not printed. Each row is terminated by the system-dependent end-of-line character, which is typically a single newline (<code class="literal">\n</code>) for Unix-like systems or a carriage return and newline sequence (<code class="literal">\r\n</code>) for Microsoft Windows. Field separator characters other than comma can be selected with <code class="command">\pset csv_fieldsep</code>.</p> <p><code class="literal">wrapped</code> format is like <code class="literal">aligned</code> but wraps wide data values across lines to make the output fit in the target column width. The target width is determined as described under the <code class="literal">columns</code> option. Note that psql will not attempt to wrap column header titles; therefore, <code class="literal">wrapped</code> format behaves the same as <code class="literal">aligned</code> if the total width needed for column headers exceeds the target.</p> <p>The <code class="literal">asciidoc</code>, <code class="literal">html</code>, <code class="literal">latex</code>, <code class="literal">latex-longtable</code>, and <code class="literal">troff-ms</code> formats put out tables that are intended to be included in documents using the respective mark-up language. They are not complete documents! This might not be necessary in HTML, but in LaTeX you must have a complete document wrapper. The <code class="literal">latex</code> format uses LaTeX's <code class="literal">tabular</code> environment. The <code class="literal">latex-longtable</code> format requires the LaTeX <code class="literal">longtable</code> and <code class="literal">booktabs</code> packages.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-LINESTYLE">
<code class="literal">linestyle</code> </dt> <dd> <p>Sets the border line drawing style to one of <code class="literal">ascii</code>, <code class="literal">old-ascii</code>, or <code class="literal">unicode</code>. Unique abbreviations are allowed. (That would mean one letter is enough.) The default setting is <code class="literal">ascii</code>. This option only affects the <code class="literal">aligned</code> and <code class="literal">wrapped</code> output formats.</p> <p><code class="literal">ascii</code> style uses plain ASCII characters. Newlines in data are shown using a <code class="literal">+</code> symbol in the right-hand margin. When the <code class="literal">wrapped</code> format wraps data from one line to the next without a newline character, a dot (<code class="literal">.</code>) is shown in the right-hand margin of the first line, and again in the left-hand margin of the following line.</p> <p><code class="literal">old-ascii</code> style uses plain ASCII characters, using the formatting style used in PostgreSQL 8.4 and earlier. Newlines in data are shown using a <code class="literal">:</code> symbol in place of the left-hand column separator. When the data is wrapped from one line to the next without a newline character, a <code class="literal">;</code> symbol is used in place of the left-hand column separator.</p> <p><code class="literal">unicode</code> style uses Unicode box-drawing characters. Newlines in data are shown using a carriage return symbol in the right-hand margin. When the data is wrapped from one line to the next without a newline character, an ellipsis symbol is shown in the right-hand margin of the first line, and again in the left-hand margin of the following line.</p> <p>When the <code class="literal">border</code> setting is greater than zero, the <code class="literal">linestyle</code> option also determines the characters with which the border lines are drawn. Plain ASCII characters work everywhere, but Unicode characters look nicer on displays that recognize them.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-NULL">
<code class="literal">null</code> </dt> <dd> <p>Sets the string to be printed in place of a null value. The default is to print nothing, which can easily be mistaken for an empty string. For example, one might prefer <code class="literal">\pset null '(null)'</code>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-NUMERICLOCALE">
<code class="literal">numericlocale</code> </dt> <dd> <p>If <code>value</code> is specified it must be either <code class="literal">on</code> or <code class="literal">off</code> which will enable or disable display of a locale-specific character to separate groups of digits to the left of the decimal marker. If <code>value</code> is omitted the command toggles between regular and locale-specific numeric output.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-PAGER">
<code class="literal">pager</code> </dt> <dd> <p>Controls use of a pager program for query and psql help output. When the <code class="literal">pager</code> option is <code class="literal">off</code>, the pager program is not used. When the <code class="literal">pager</code> option is <code class="literal">on</code>, the pager is used when appropriate, i.e., when the output is to a terminal and will not fit on the screen. The <code class="literal">pager</code> option can also be set to <code class="literal">always</code>, which causes the pager to be used for all terminal output regardless of whether it fits on the screen. <code class="literal">\pset pager</code> without a <code>value</code> toggles pager use on and off.</p> <p>If the environment variable <code class="envar">PSQL_PAGER</code> or <code class="envar">PAGER</code> is set, output to be paged is piped to the specified program. Otherwise a platform-dependent default program (such as <code class="filename">more</code>) is used.</p> <p>When using the <code class="literal">\watch</code> command to execute a query repeatedly, the environment variable <code class="envar">PSQL_WATCH_PAGER</code> is used to find the pager program instead, on Unix systems. This is configured separately because it may confuse traditional pagers, but can be used to send output to tools that understand psql's output format (such as <code class="filename">pspg --stream</code>).</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-PAGER-MIN-LINES">
<code class="literal">pager_min_lines</code> </dt> <dd> <p>If <code class="literal">pager_min_lines</code> is set to a number greater than the page height, the pager program will not be called unless there are at least this many lines of output to show. The default setting is 0.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-RECORDSEP">
<code class="literal">recordsep</code> </dt> <dd> <p>Specifies the record (line) separator to use in unaligned output format. The default is a newline character.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-RECORDSEP-ZERO">
<code class="literal">recordsep_zero</code> </dt> <dd> <p>Sets the record separator to use in unaligned output format to a zero byte.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-TABLEATTR">
<code class="literal">tableattr</code> (or <code class="literal">T</code>) </dt> <dd> <p>In HTML format, this specifies attributes to be placed inside the <code class="sgmltag-element">table</code> tag. This could for example be <code class="literal">cellpadding</code> or <code class="literal">bgcolor</code>. Note that you probably don't want to specify <code class="literal">border</code> here, as that is already taken care of by <code class="literal">\pset border</code>. If no <code>value</code> is given, the table attributes are unset.</p> <p>In <code class="literal">latex-longtable</code> format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g., <code class="literal">'0.2 0.2 0.6'</code>. Unspecified output columns use the last specified value.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-TITLE">
<code class="literal">title</code> (or <code class="literal">C</code>) </dt> <dd> <p>Sets the table title for any subsequently printed tables. This can be used to give your output descriptive tags. If no <code>value</code> is given, the title is unset.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-TUPLES-ONLY">
<code class="literal">tuples_only</code> (or <code class="literal">t</code>) </dt> <dd> <p>If <code>value</code> is specified it must be either <code class="literal">on</code> or <code class="literal">off</code> which will enable or disable tuples-only mode. If <code>value</code> is omitted the command toggles between regular and tuples-only output. Regular output includes extra information such as column headers, titles, and various footers. In tuples-only mode, only actual table data is shown.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-UNICODE-BORDER-LINESTYLE">
<code class="literal">unicode_border_linestyle</code> </dt> <dd> <p>Sets the border drawing style for the <code class="literal">unicode</code> line style to one of <code class="literal">single</code> or <code class="literal">double</code>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-UNICODE-COLUMN-LINESTYLE">
<code class="literal">unicode_column_linestyle</code> </dt> <dd> <p>Sets the column drawing style for the <code class="literal">unicode</code> line style to one of <code class="literal">single</code> or <code class="literal">double</code>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-UNICODE-HEADER-LINESTYLE">
<code class="literal">unicode_header_linestyle</code> </dt> <dd> <p>Sets the header drawing style for the <code class="literal">unicode</code> line style to one of <code class="literal">single</code> or <code class="literal">double</code>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-PSET-XHEADER-WIDTH">
<code class="literal">xheader_width</code> </dt> <dd> <p>Sets the maximum width of the header for expanded output to one of <code class="literal">full</code> (the default value), <code class="literal">column</code>, <code class="literal">page</code>, or an <code>integer value</code>.</p> <p><code class="literal">full</code>: the expanded header is not truncated, and will be as wide as the widest output line.</p> <p><code class="literal">column</code>: truncate the header line to the width of the first column.</p> <p><code class="literal">page</code>: truncate the header line to the terminal width.</p> <p><code>integer value</code>: specify the exact maximum width of the header line.</p> </dd> </dl> </div> <p>Illustrations of how these different formats look can be seen in <a class="xref" href="app-psql.html#APP-PSQL-EXAMPLES" title="Examples">Examples</a>, below.</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>There are various shortcut commands for <code class="command">\pset</code>. See <code class="command">\a</code>, <code class="command">\C</code>, <code class="command">\f</code>, <code class="command">\H</code>, <code class="command">\t</code>, <code class="command">\T</code>, and <code class="command">\x</code>.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-QUIT">
<code class="literal">\q</code> or <code class="literal">\quit</code> </dt> <dd> <p>Quits the psql program. In a script file, only execution of that script is terminated.</p> </dd> <dt id="APP-PSQL-META-COMMAND-QECHO">
<code class="literal">\qecho text [ ... ]</code> </dt> <dd> <p>This command is identical to <code class="command">\echo</code> except that the output will be written to the query output channel, as set by <code class="command">\o</code>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-RESET">
<code class="literal">\r</code> or <code class="literal">\reset</code> </dt> <dd> <p>Resets (clears) the query buffer.</p> </dd> <dt id="APP-PSQL-META-COMMAND-S">
<code class="literal">\s [ filename ]</code> </dt> <dd> <p>Print psql's command line history to <code>filename</code>. If <code>filename</code> is omitted, the history is written to the standard output (using the pager if appropriate). This command is not available if psql was built without Readline support.</p> </dd> <dt id="APP-PSQL-META-COMMAND-SET">
<code class="literal">\set [ name [ value [ ... ] ] ]</code> </dt> <dd> <p>Sets the psql variable <code>name</code> to <code>value</code>, or if more than one value is given, to the concatenation of all of them. If only one argument is given, the variable is set to an empty-string value. To unset a variable, use the <code class="command">\unset</code> command.</p> <p><code class="command">\set</code> without any arguments displays the names and values of all currently-set psql variables.</p> <p>Valid variable names can contain letters, digits, and underscores. See <a class="xref" href="app-psql.html#APP-PSQL-VARIABLES" title="Variables">Variables</a> below for details. Variable names are case-sensitive.</p> <p>Certain variables are special, in that they control psql's behavior or are automatically set to reflect connection state. These variables are documented in <a class="xref" href="app-psql.html#APP-PSQL-VARIABLES" title="Variables">Variables</a>, below.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>This command is unrelated to the SQL command <a class="link" href="sql-set.html" title="SET"><code class="command">SET</code></a>.</p> </blockquote> </dd> <dt id="APP-PSQL-META-COMMAND-SETENV">
<code class="literal">\setenv name [ value ]</code> </dt> <dd> <p>Sets the environment variable <code>name</code> to <code>value</code>, or if the <code>value</code> is not supplied, unsets the environment variable. Example:</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">\setenv PAGER less</strong>
testdb=&gt; <strong class="userinput">\setenv LESS -imx4F</strong>
</pre> </dd> <dt id="APP-PSQL-META-COMMAND-SF">
<code class="literal">\sf[+] function_description</code> </dt> <dd> <p>This command fetches and shows the definition of the named function or procedure, in the form of a <code class="command">CREATE OR REPLACE FUNCTION</code> or <code class="command">CREATE OR REPLACE PROCEDURE</code> command. The definition is printed to the current query output channel, as set by <code class="command">\o</code>.</p> <p>The target function can be specified by name alone, or by name and arguments, for example <code class="literal">foo(integer, text)</code>. The argument types must be given if there is more than one function of the same name.</p> <p>If <code class="literal">+</code> is appended to the command name, then the output lines are numbered, with the first line of the function body being line 1.</p> <p>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of <code class="command">\sf</code>, and neither variable interpolation nor backquote expansion are performed in the arguments.</p> </dd> <dt id="APP-PSQL-META-COMMAND-SV">
<code class="literal">\sv[+] view_name</code> </dt> <dd> <p>This command fetches and shows the definition of the named view, in the form of a <code class="command">CREATE OR REPLACE VIEW</code> command. The definition is printed to the current query output channel, as set by <code class="command">\o</code>.</p> <p>If <code class="literal">+</code> is appended to the command name, then the output lines are numbered from 1.</p> <p>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of <code class="command">\sv</code>, and neither variable interpolation nor backquote expansion are performed in the arguments.</p> </dd> <dt id="APP-PSQL-META-COMMAND-T-LC">
<code class="literal">\t</code> </dt> <dd> <p>Toggles the display of output column name headings and row count footer. This command is equivalent to <code class="literal">\pset tuples_only</code> and is provided for convenience.</p> </dd> <dt id="APP-PSQL-META-COMMAND-T-UC">
<code class="literal">\T table_options</code> </dt> <dd> <p>Specifies attributes to be placed within the <code class="sgmltag-element">table</code> tag in HTML output format. This command is equivalent to <code class="literal">\pset tableattr table_options</code>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-TIMING">
<code class="literal">\timing [ on | off ]</code> </dt> <dd> <p>With a parameter, turns displaying of how long each SQL statement takes on or off. Without a parameter, toggles the display between on and off. The display is in milliseconds; intervals longer than 1 second are also shown in minutes:seconds format, with hours and days fields added if needed.</p> </dd> <dt id="APP-PSQL-META-COMMAND-UNSET">
<code class="literal">\unset name</code> </dt> <dd> <p>Unsets (deletes) the psql variable <code>name</code>.</p> <p>Most variables that control psql's behavior cannot be unset; instead, an <code class="literal">\unset</code> command is interpreted as setting them to their default values. See <a class="xref" href="app-psql.html#APP-PSQL-VARIABLES" title="Variables">Variables</a> below.</p> </dd> <dt id="APP-PSQL-META-COMMAND-WRITE">
<code class="literal">\w</code> or <code class="literal">\write</code> <code>filename</code><code class="literal">\w</code> or <code class="literal">\write</code> <code class="literal">|</code><code>command</code> </dt> <dd> <p>Writes the current query buffer to the file <code>filename</code> or pipes it to the shell command <code>command</code>. If the current query buffer is empty, the most recently executed query is written instead.</p> <p>If the argument begins with <code class="literal">|</code>, then the entire remainder of the line is taken to be the <code>command</code> to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</p> </dd> <dt id="APP-PSQL-META-COMMAND-WARN">
<code class="literal">\warn text [ ... ]</code> </dt> <dd> <p>This command is identical to <code class="command">\echo</code> except that the output will be written to psql's standard error channel, rather than standard output.</p> </dd> <dt id="APP-PSQL-META-COMMAND-WATCH">
<code class="literal">\watch [ i[nterval]=seconds ] [ c[ount]=times ] [ seconds ]</code> </dt> <dd> <p>Repeatedly execute the current query buffer (as <code class="literal">\g</code> does) until interrupted, or the query fails, or the execution count limit (if given) is reached. Wait the specified number of seconds (default 2) between executions. For backwards compatibility, <code>seconds</code> can be specified with or without an <code class="literal">interval=</code> prefix. Each query result is displayed with a header that includes the <code class="literal">\pset title</code> string (if any), the time as of query start, and the delay interval.</p> <p>If the current query buffer is empty, the most recently sent query is re-executed instead.</p> </dd> <dt id="APP-PSQL-META-COMMAND-X">
<code class="literal">\x [ on | off | auto ]</code> </dt> <dd> <p>Sets or toggles expanded table formatting mode. As such it is equivalent to <code class="literal">\pset expanded</code>.</p> </dd> <dt id="APP-PSQL-META-COMMAND-Z">
<code class="literal">\z[S] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="Patterns">pattern</a> ]</code> </dt> <dd> <p>Lists tables, views and sequences with their associated access privileges. If a <code>pattern</code> is specified, only tables, views and sequences whose names match the pattern are listed. By default only user-created objects are shown; supply a pattern or the <code class="literal">S</code> modifier to include system objects.</p> <p>This is an alias for <code class="command">\dp</code> (<span class="quote">“<span class="quote">display privileges</span>”</span>).</p> </dd> <dt id="APP-PSQL-META-COMMAND-EXCLAMATION-MARK">
<code class="literal">\! [ command ]</code> </dt> <dd> <p>With no argument, escapes to a sub-shell; psql resumes when the sub-shell exits. With an argument, executes the shell command <code>command</code>.</p> <p>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of <code class="command">\!</code>, and neither variable interpolation nor backquote expansion are performed in the arguments. The rest of the line is simply passed literally to the shell.</p> </dd> <dt id="APP-PSQL-META-COMMAND-QUESTION-MARK">
<code class="literal">\? [ topic ]</code> </dt> <dd> <p>Shows help information. The optional <code>topic</code> parameter (defaulting to <code class="literal">commands</code>) selects which part of psql is explained: <code class="literal">commands</code> describes psql's backslash commands; <code class="literal">options</code> describes the command-line options that can be passed to psql; and <code class="literal">variables</code> shows help about psql configuration variables.</p> </dd> <dt id="APP-PSQL-META-COMMAND-SEMICOLON">
<code class="literal">\;</code> </dt> <dd> <p>Backslash-semicolon is not a meta-command in the same way as the preceding commands; rather, it simply causes a semicolon to be added to the query buffer without any further processing.</p> <p>Normally, psql will dispatch an SQL command to the server as soon as it reaches the command-ending semicolon, even if more input remains on the current line. Thus for example entering</p> <pre data-language="sql">
select 1; select 2; select 3;
</pre> <p>will result in the three SQL commands being individually sent to the server, with each one's results being displayed before continuing to the next command. However, a semicolon entered as <code class="literal">\;</code> will not trigger command processing, so that the command before it and the one after are effectively combined and sent to the server in one request. So for example</p> <pre data-language="sql">
select 1\; select 2\; select 3;
</pre> <p>results in sending the three SQL commands to the server in a single request, when the non-backslashed semicolon is reached. The server executes such a request as a single transaction, unless there are explicit <code class="command">BEGIN</code>/<code class="command">COMMIT</code> commands included in the string to divide it into multiple transactions. (See <a class="xref" href="https://www.postgresql.org/docs/16/protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT" title="55.2.2.1. Multiple Statements in a Simple Query">Section 55.2.2.1</a> for more details about how the server handles multi-query strings.)</p> </dd> </dl> </div> <div class="refsect3" id="id-1.9.4.20.8.4.11.2"> <h4>Patterns</h4> <p>The various <code class="literal">\d</code> commands accept a <code>pattern</code> parameter to specify the object name(s) to be displayed. In the simplest case, a pattern is just the exact name of the object. The characters within a pattern are normally folded to lower case, just as in SQL names; for example, <code class="literal">\dt FOO</code> will display the table named <code class="literal">foo</code>. As in SQL names, placing double quotes around a pattern stops folding to lower case. Should you need to include an actual double quote character in a pattern, write it as a pair of double quotes within a double-quote sequence; again this is in accord with the rules for SQL quoted identifiers. For example, <code class="literal">\dt "FOO""BAR"</code> will display the table named <code class="literal">FOO"BAR</code> (not <code class="literal">foo"bar</code>). Unlike the normal rules for SQL names, you can put double quotes around just part of a pattern, for instance <code class="literal">\dt FOO"FOO"BAR</code> will display the table named <code class="literal">fooFOObar</code>.</p> <p>Whenever the <code>pattern</code> parameter is omitted completely, the <code class="literal">\d</code> commands display all objects that are visible in the current schema search path — this is equivalent to using <code class="literal">*</code> as the pattern. (An object is said to be <em class="firstterm">visible</em> if its containing schema is in the search path and no object of the same kind and name appears earlier in the search path. This is equivalent to the statement that the object can be referenced by name without explicit schema qualification.) To see all objects in the database regardless of visibility, use <code class="literal">*.*</code> as the pattern.</p> <p>Within a pattern, <code class="literal">*</code> matches any sequence of characters (including no characters) and <code class="literal">?</code> matches any single character. (This notation is comparable to Unix shell file name patterns.) For example, <code class="literal">\dt int*</code> displays tables whose names begin with <code class="literal">int</code>. But within double quotes, <code class="literal">*</code> and <code class="literal">?</code> lose these special meanings and are just matched literally.</p> <p>A relation pattern that contains a dot (<code class="literal">.</code>) is interpreted as a schema name pattern followed by an object name pattern. For example, <code class="literal">\dt foo*.*bar*</code> displays all tables whose table name includes <code class="literal">bar</code> that are in schemas whose schema name starts with <code class="literal">foo</code>. When no dot appears, then the pattern matches only objects that are visible in the current schema search path. Again, a dot within double quotes loses its special meaning and is matched literally. A relation pattern that contains two dots (<code class="literal">.</code>) is interpreted as a database name followed by a schema name pattern followed by an object name pattern. The database name portion will not be treated as a pattern and must match the name of the currently connected database, else an error will be raised.</p> <p>A schema pattern that contains a dot (<code class="literal">.</code>) is interpreted as a database name followed by a schema name pattern. For example, <code class="literal">\dn mydb.*foo*</code> displays all schemas whose schema name includes <code class="literal">foo</code>. The database name portion will not be treated as a pattern and must match the name of the currently connected database, else an error will be raised.</p> <p>Advanced users can use regular-expression notations such as character classes, for example <code class="literal">[0-9]</code> to match any digit. All regular expression special characters work as specified in <a class="xref" href="functions-matching.html#FUNCTIONS-POSIX-REGEXP" title="9.7.3. POSIX Regular Expressions">Section 9.7.3</a>, except for <code class="literal">.</code> which is taken as a separator as mentioned above, <code class="literal">*</code> which is translated to the regular-expression notation <code class="literal">.*</code>, <code class="literal">?</code> which is translated to <code class="literal">.</code>, and <code class="literal">$</code> which is matched literally. You can emulate these pattern characters at need by writing <code class="literal">?</code> for <code class="literal">.</code>, <code class="literal">(R+|)</code> for <code class="literal">R*</code>, or <code class="literal">(R|)</code> for <code class="literal">R?</code>. <code class="literal">$</code> is not needed as a regular-expression character since the pattern must match the whole name, unlike the usual interpretation of regular expressions (in other words, <code class="literal">$</code> is automatically appended to your pattern). Write <code class="literal">*</code> at the beginning and/or end if you don't wish the pattern to be anchored. Note that within double quotes, all regular expression special characters lose their special meanings and are matched literally. Also, the regular expression special characters are matched literally in operator name patterns (i.e., the argument of <code class="literal">\do</code>).</p> </div> </div> <div class="refsect2" id="id-1.9.4.20.8.5"> <h3>Advanced Features</h3> <div class="refsect3" id="APP-PSQL-VARIABLES"> <h4>Variables</h4> <p>psql provides variable substitution features similar to common Unix command shells. Variables are simply name/value pairs, where the value can be any string of any length. The name must consist of letters (including non-Latin letters), digits, and underscores.</p> <p>To set a variable, use the psql meta-command <code class="command">\set</code>. For example,</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">\set foo bar</strong>
</pre> <p>sets the variable <code class="literal">foo</code> to the value <code class="literal">bar</code>. To retrieve the content of the variable, precede the name with a colon, for example:</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">\echo :foo</strong>
bar
</pre> <p>This works in both regular SQL commands and meta-commands; there is more detail in <a class="xref" href="app-psql.html#APP-PSQL-INTERPOLATION" title="SQL Interpolation">SQL Interpolation</a>, below.</p> <p>If you call <code class="command">\set</code> without a second argument, the variable is set to an empty-string value. To unset (i.e., delete) a variable, use the command <code class="command">\unset</code>. To show the values of all variables, call <code class="command">\set</code> without any argument.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>The arguments of <code class="command">\set</code> are subject to the same substitution rules as with other commands. Thus you can construct interesting references such as <code class="literal">\set :foo 'something'</code> and get <span class="quote">“<span class="quote">soft links</span>”</span> or <span class="quote">“<span class="quote">variable variables</span>”</span> of Perl or PHP fame, respectively. Unfortunately (or fortunately?), there is no way to do anything useful with these constructs. On the other hand, <code class="literal">\set bar :foo</code> is a perfectly valid way to copy a variable.</p> </blockquote> <p>A number of these variables are treated specially by psql. They represent certain option settings that can be changed at run time by altering the value of the variable, or in some cases represent changeable state of psql. By convention, all specially treated variables' names consist of all upper-case ASCII letters (and possibly digits and underscores). To ensure maximum compatibility in the future, avoid using such variable names for your own purposes.</p> <p>Variables that control psql's behavior generally cannot be unset or set to invalid values. An <code class="literal">\unset</code> command is allowed but is interpreted as setting the variable to its default value. A <code class="literal">\set</code> command without a second argument is interpreted as setting the variable to <code class="literal">on</code>, for control variables that accept that value, and is rejected for others. Also, control variables that accept the values <code class="literal">on</code> and <code class="literal">off</code> will also accept other common spellings of Boolean values, such as <code class="literal">true</code> and <code class="literal">false</code>.</p> <p>The specially treated variables are:</p> <div class="variablelist"> <dl class="variablelist"> <dt id="APP-PSQL-VARIABLES-AUTOCOMMIT">
<code class="varname">AUTOCOMMIT</code>  </dt> <dd> <p>When <code class="literal">on</code> (the default), each SQL command is automatically committed upon successful completion. To postpone commit in this mode, you must enter a <code class="command">BEGIN</code> or <code class="command">START TRANSACTION</code> SQL command. When <code class="literal">off</code> or unset, SQL commands are not committed until you explicitly issue <code class="command">COMMIT</code> or <code class="command">END</code>. The autocommit-off mode works by issuing an implicit <code class="command">BEGIN</code> for you, just before any command that is not already in a transaction block and is not itself a <code class="command">BEGIN</code> or other transaction-control command, nor a command that cannot be executed inside a transaction block (such as <code class="command">VACUUM</code>).</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>In autocommit-off mode, you must explicitly abandon any failed transaction by entering <code class="command">ABORT</code> or <code class="command">ROLLBACK</code>. Also keep in mind that if you exit the session without committing, your work will be lost.</p> </blockquote> <blockquote class="note"> <h3 class="title">Note</h3> <p>The autocommit-on mode is PostgreSQL's traditional behavior, but autocommit-off is closer to the SQL spec. If you prefer autocommit-off, you might wish to set it in the system-wide <code class="filename">psqlrc</code> file or your <code class="filename">~/.psqlrc</code> file.</p> </blockquote> </dd> <dt id="APP-PSQL-VARIABLES-COMP-KEYWORD-CASE">
<code class="varname">COMP_KEYWORD_CASE</code> </dt> <dd> <p>Determines which letter case to use when completing an SQL key word. If set to <code class="literal">lower</code> or <code class="literal">upper</code>, the completed word will be in lower or upper case, respectively. If set to <code class="literal">preserve-lower</code> or <code class="literal">preserve-upper</code> (the default), the completed word will be in the case of the word already entered, but words being completed without anything entered will be in lower or upper case, respectively.</p> </dd> <dt id="APP-PSQL-VARIABLES-DBNAME">
<code class="varname">DBNAME</code> </dt> <dd> <p>The name of the database you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</p> </dd> <dt id="APP-PSQL-VARIABLES-ECHO">
<code class="varname">ECHO</code> </dt> <dd> <p>If set to <code class="literal">all</code>, all nonempty input lines are printed to standard output as they are read. (This does not apply to lines read interactively.) To select this behavior on program start-up, use the switch <code class="option">-a</code>. If set to <code class="literal">queries</code>, psql prints each query to standard output as it is sent to the server. The switch to select this behavior is <code class="option">-e</code>. If set to <code class="literal">errors</code>, then only failed queries are displayed on standard error output. The switch for this behavior is <code class="option">-b</code>. If set to <code class="literal">none</code> (the default), then no queries are displayed.</p> </dd> <dt id="APP-PSQL-VARIABLES-ECHO-HIDDEN">
<code class="varname">ECHO_HIDDEN</code> </dt> <dd> <p>When this variable is set to <code class="literal">on</code> and a backslash command queries the database, the query is first shown. This feature helps you to study PostgreSQL internals and provide similar functionality in your own programs. (To select this behavior on program start-up, use the switch <code class="option">-E</code>.) If you set this variable to the value <code class="literal">noexec</code>, the queries are just shown but are not actually sent to the server and executed. The default value is <code class="literal">off</code>.</p> </dd> <dt id="APP-PSQL-VARIABLES-ENCODING">
<code class="varname">ENCODING</code> </dt> <dd> <p>The current client character set encoding. This is set every time you connect to a database (including program start-up), and when you change the encoding with <code class="literal">\encoding</code>, but it can be changed or unset.</p> </dd> <dt id="APP-PSQL-VARIABLES-ERROR">
<code class="varname">ERROR</code> </dt> <dd> <p><code class="literal">true</code> if the last SQL query failed, <code class="literal">false</code> if it succeeded. See also <code class="varname">SQLSTATE</code>.</p> </dd> <dt id="APP-PSQL-VARIABLES-FETCH-COUNT">
<code class="varname">FETCH_COUNT</code> </dt> <dd> <p>If this variable is set to an integer value greater than zero, the results of <code class="command">SELECT</code> queries are fetched and displayed in groups of that many rows, rather than the default behavior of collecting the entire result set before display. Therefore only a limited amount of memory is used, regardless of the size of the result set. Settings of 100 to 1000 are commonly used when enabling this feature. Keep in mind that when using this feature, a query might fail after having already displayed some rows.</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>Although you can use any output format with this feature, the default <code class="literal">aligned</code> format tends to look bad because each group of <code class="varname">FETCH_COUNT</code> rows will be formatted separately, leading to varying column widths across the row groups. The other output formats work better.</p> </blockquote> </dd> <dt id="APP-PSQL-VARIABLES-HIDE-TABLEAM">
<code class="varname">HIDE_TABLEAM</code> </dt> <dd> <p>If this variable is set to <code class="literal">true</code>, a table's access method details are not displayed. This is mainly useful for regression tests.</p> </dd> <dt id="APP-PSQL-VARIABLES-HIDE-TOAST-COMPRESSION">
<code class="varname">HIDE_TOAST_COMPRESSION</code> </dt> <dd> <p>If this variable is set to <code class="literal">true</code>, column compression method details are not displayed. This is mainly useful for regression tests.</p> </dd> <dt id="APP-PSQL-VARIABLES-HISTCONTROL">
<code class="varname">HISTCONTROL</code> </dt> <dd> <p>If this variable is set to <code class="literal">ignorespace</code>, lines which begin with a space are not entered into the history list. If set to a value of <code class="literal">ignoredups</code>, lines matching the previous history line are not entered. A value of <code class="literal">ignoreboth</code> combines the two options. If set to <code class="literal">none</code> (the default), all lines read in interactive mode are saved on the history list.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>This feature was shamelessly plagiarized from Bash.</p> </blockquote> </dd> <dt id="APP-PSQL-VARIABLES-HISTFILE">
<code class="varname">HISTFILE</code> </dt> <dd> <p>The file name that will be used to store the history list. If unset, the file name is taken from the <code class="envar">PSQL_HISTORY</code> environment variable. If that is not set either, the default is <code class="filename">~/.psql_history</code>, or <code class="filename">%APPDATA%\postgresql\psql_history</code> on Windows. For example, putting:</p> <pre data-language="sql">
\set HISTFILE ~/.psql_history-:DBNAME
</pre> <p>in <code class="filename">~/.psqlrc</code> will cause psql to maintain a separate history for each database.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>This feature was shamelessly plagiarized from Bash.</p> </blockquote> </dd> <dt id="APP-PSQL-VARIABLES-HISTSIZE">
<code class="varname">HISTSIZE</code> </dt> <dd> <p>The maximum number of commands to store in the command history (default 500). If set to a negative value, no limit is applied.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>This feature was shamelessly plagiarized from Bash.</p> </blockquote> </dd> <dt id="APP-PSQL-VARIABLES-HOST">
<code class="varname">HOST</code> </dt> <dd> <p>The database server host you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</p> </dd> <dt id="APP-PSQL-VARIABLES-IGNOREEOF">
<code class="varname">IGNOREEOF</code> </dt> <dd> <p>If set to 1 or less, sending an EOF character (usually <span class="keycap"><strong>Control</strong></span>+<span class="keycap"><strong>D</strong></span>) to an interactive session of psql will terminate the application. If set to a larger numeric value, that many consecutive EOF characters must be typed to make an interactive session terminate. If the variable is set to a non-numeric value, it is interpreted as 10. The default is 0.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>This feature was shamelessly plagiarized from Bash.</p> </blockquote> </dd> <dt id="APP-PSQL-VARIABLES-LASTOID">
<code class="varname">LASTOID</code> </dt> <dd> <p>The value of the last affected OID, as returned from an <code class="command">INSERT</code> or <code class="command">\lo_import</code> command. This variable is only guaranteed to be valid until after the result of the next SQL command has been displayed. PostgreSQL servers since version 12 do not support OID system columns anymore, thus LASTOID will always be 0 following <code class="command">INSERT</code> when targeting such servers.</p> </dd> <dt id="APP-PSQL-VARIABLES-LAST-ERROR-MESSAGE">
<code class="varname">LAST_ERROR_MESSAGE</code><code class="varname">LAST_ERROR_SQLSTATE</code> </dt> <dd> <p>The primary error message and associated SQLSTATE code for the most recent failed query in the current psql session, or an empty string and <code class="literal">00000</code> if no error has occurred in the current session.</p> </dd> <dt id="APP-PSQL-VARIABLES-ON-ERROR-ROLLBACK">
<code class="varname">ON_ERROR_ROLLBACK</code>  </dt> <dd> <p>When set to <code class="literal">on</code>, if a statement in a transaction block generates an error, the error is ignored and the transaction continues. When set to <code class="literal">interactive</code>, such errors are only ignored in interactive sessions, and not when reading script files. When set to <code class="literal">off</code> (the default), a statement in a transaction block that generates an error aborts the entire transaction. The error rollback mode works by issuing an implicit <code class="command">SAVEPOINT</code> for you, just before each command that is in a transaction block, and then rolling back to the savepoint if the command fails.</p> </dd> <dt id="APP-PSQL-VARIABLES-ON-ERROR-STOP">
<code class="varname">ON_ERROR_STOP</code> </dt> <dd> <p>By default, command processing continues after an error. When this variable is set to <code class="literal">on</code>, processing will instead stop immediately. In interactive mode, psql will return to the command prompt; otherwise, psql will exit, returning error code 3 to distinguish this case from fatal error conditions, which are reported using error code 1. In either case, any currently running scripts (the top-level script, if any, and any other scripts which it may have in invoked) will be terminated immediately. If the top-level command string contained multiple SQL commands, processing will stop with the current command.</p> </dd> <dt id="APP-PSQL-VARIABLES-PORT">
<code class="varname">PORT</code> </dt> <dd> <p>The database server port to which you are currently connected. This is set every time you connect to a database (including program start-up), but can be changed or unset.</p> </dd> <dt id="APP-PSQL-VARIABLES-PROMPT">
<code class="varname">PROMPT1</code><code class="varname">PROMPT2</code><code class="varname">PROMPT3</code> </dt> <dd> <p>These specify what the prompts psql issues should look like. See <a class="xref" href="app-psql.html#APP-PSQL-PROMPTING" title="Prompting">Prompting</a> below.</p> </dd> <dt id="APP-PSQL-VARIABLES-QUIET">
<code class="varname">QUIET</code> </dt> <dd> <p>Setting this variable to <code class="literal">on</code> is equivalent to the command line option <code class="option">-q</code>. It is probably not too useful in interactive mode.</p> </dd> <dt id="APP-PSQL-VARIABLES-ROW-COUNT">
<code class="varname">ROW_COUNT</code> </dt> <dd> <p>The number of rows returned or affected by the last SQL query, or 0 if the query failed or did not report a row count.</p> </dd> <dt id="APP-PSQL-VARIABLES-SERVER-VERSION-NAME">
<code class="varname">SERVER_VERSION_NAME</code><code class="varname">SERVER_VERSION_NUM</code> </dt> <dd> <p>The server's version number as a string, for example <code class="literal">9.6.2</code>, <code class="literal">10.1</code> or <code class="literal">11beta1</code>, and in numeric form, for example <code class="literal">90602</code> or <code class="literal">100001</code>. These are set every time you connect to a database (including program start-up), but can be changed or unset.</p> </dd> <dt id="APP-PSQL-VARIABLES-SHELL-ERROR">
<code class="varname">SHELL_ERROR</code> </dt> <dd> <p><code class="literal">true</code> if the last shell command failed, <code class="literal">false</code> if it succeeded. This applies to shell commands invoked via the <code class="literal">\!</code>, <code class="literal">\g</code>, <code class="literal">\o</code>, <code class="literal">\w</code>, and <code class="literal">\copy</code> meta-commands, as well as backquote (<code class="literal">`</code>) expansion. Note that for <code class="literal">\o</code>, this variable is updated when the output pipe is closed by the next <code class="literal">\o</code> command. See also <code class="varname">SHELL_EXIT_CODE</code>.</p> </dd> <dt id="APP-PSQL-VARIABLES-SHELL-EXIT-CODE">
<code class="varname">SHELL_EXIT_CODE</code> </dt> <dd> <p>The exit status returned by the last shell command. 0–127 represent program exit codes, 128–255 indicate termination by a signal, and -1 indicates failure to launch a program or to collect its exit status. This applies to shell commands invoked via the <code class="literal">\!</code>, <code class="literal">\g</code>, <code class="literal">\o</code>, <code class="literal">\w</code>, and <code class="literal">\copy</code> meta-commands, as well as backquote (<code class="literal">`</code>) expansion. Note that for <code class="literal">\o</code>, this variable is updated when the output pipe is closed by the next <code class="literal">\o</code> command. See also <code class="varname">SHELL_ERROR</code>.</p> </dd> <dt id="APP-PSQL-VARIABLES-SHOW-ALL-RESULTS">
<code class="varname">SHOW_ALL_RESULTS</code> </dt> <dd> <p>When this variable is set to <code class="literal">off</code>, only the last result of a combined query (<code class="literal">\;</code>) is shown instead of all of them. The default is <code class="literal">on</code>. The off behavior is for compatibility with older versions of psql.</p> </dd> <dt id="APP-PSQL-VARIABLES-SHOW-CONTEXT">
<code class="varname">SHOW_CONTEXT</code> </dt> <dd> <p>This variable can be set to the values <code class="literal">never</code>, <code class="literal">errors</code>, or <code class="literal">always</code> to control whether <code class="literal">CONTEXT</code> fields are displayed in messages from the server. The default is <code class="literal">errors</code> (meaning that context will be shown in error messages, but not in notice or warning messages). This setting has no effect when <code class="varname">VERBOSITY</code> is set to <code class="literal">terse</code> or <code class="literal">sqlstate</code>. (See also <code class="command">\errverbose</code>, for use when you want a verbose version of the error you just got.)</p> </dd> <dt id="APP-PSQL-VARIABLES-SINGLELINE">
<code class="varname">SINGLELINE</code> </dt> <dd> <p>Setting this variable to <code class="literal">on</code> is equivalent to the command line option <code class="option">-S</code>.</p> </dd> <dt id="APP-PSQL-VARIABLES-SINGLESTEP">
<code class="varname">SINGLESTEP</code> </dt> <dd> <p>Setting this variable to <code class="literal">on</code> is equivalent to the command line option <code class="option">-s</code>.</p> </dd> <dt id="APP-PSQL-VARIABLES-SQLSTATE">
<code class="varname">SQLSTATE</code> </dt> <dd> <p>The error code (see <a class="xref" href="errcodes-appendix.html" title="Appendix A. PostgreSQL Error Codes">Appendix A</a>) associated with the last SQL query's failure, or <code class="literal">00000</code> if it succeeded.</p> </dd> <dt id="APP-PSQL-VARIABLES-USER">
<code class="varname">USER</code> </dt> <dd> <p>The database user you are currently connected as. This is set every time you connect to a database (including program start-up), but can be changed or unset.</p> </dd> <dt id="APP-PSQL-VARIABLES-VERBOSITY">
<code class="varname">VERBOSITY</code> </dt> <dd> <p>This variable can be set to the values <code class="literal">default</code>, <code class="literal">verbose</code>, <code class="literal">terse</code>, or <code class="literal">sqlstate</code> to control the verbosity of error reports. (See also <code class="command">\errverbose</code>, for use when you want a verbose version of the error you just got.)</p> </dd> <dt id="APP-PSQL-VARIABLES-VERSION">
<code class="varname">VERSION</code><code class="varname">VERSION_NAME</code><code class="varname">VERSION_NUM</code> </dt> <dd> <p>These variables are set at program start-up to reflect psql's version, respectively as a verbose string, a short string (e.g., <code class="literal">9.6.2</code>, <code class="literal">10.1</code>, or <code class="literal">11beta1</code>), and a number (e.g., <code class="literal">90602</code> or <code class="literal">100001</code>). They can be changed or unset.</p> </dd> </dl> </div> </div> <div class="refsect3" id="APP-PSQL-INTERPOLATION"> <h4>SQL Interpolation</h4> <p>A key feature of psql variables is that you can substitute (<span class="quote">“<span class="quote">interpolate</span>”</span>) them into regular SQL statements, as well as the arguments of meta-commands. Furthermore, psql provides facilities for ensuring that variable values used as SQL literals and identifiers are properly quoted. The syntax for interpolating a value without any quoting is to prepend the variable name with a colon (<code class="literal">:</code>). For example,</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">\set foo 'my_table'</strong>
testdb=&gt; <strong class="userinput">SELECT * FROM :foo;</strong>
</pre> <p>would query the table <code class="literal">my_table</code>. Note that this may be unsafe: the value of the variable is copied literally, so it can contain unbalanced quotes, or even backslash commands. You must make sure that it makes sense where you put it.</p> <p>When a value is to be used as an SQL literal or identifier, it is safest to arrange for it to be quoted. To quote the value of a variable as an SQL literal, write a colon followed by the variable name in single quotes. To quote the value as an SQL identifier, write a colon followed by the variable name in double quotes. These constructs deal correctly with quotes and other special characters embedded within the variable value. The previous example would be more safely written this way:</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">\set foo 'my_table'</strong>
testdb=&gt; <strong class="userinput">SELECT * FROM :"foo";</strong>
</pre> <p>Variable interpolation will not be performed within quoted SQL literals and identifiers. Therefore, a construction such as <code class="literal">':foo'</code> doesn't work to produce a quoted literal from a variable's value (and it would be unsafe if it did work, since it wouldn't correctly handle quotes embedded in the value).</p> <p>One example use of this mechanism is to copy the contents of a file into a table column. First load the file into a variable and then interpolate the variable's value as a quoted string:</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">\set content `cat my_file.txt`</strong>
testdb=&gt; <strong class="userinput">INSERT INTO my_table VALUES (:'content');</strong>
</pre> <p>(Note that this still won't work if <code class="filename">my_file.txt</code> contains NUL bytes. psql does not support embedded NUL bytes in variable values.)</p> <p>Since colons can legally appear in SQL commands, an apparent attempt at interpolation (that is, <code class="literal">:name</code>, <code class="literal">:'name'</code>, or <code class="literal">:"name"</code>) is not replaced unless the named variable is currently set. In any case, you can escape a colon with a backslash to protect it from substitution.</p> <p>The <code class="literal">:{?name}</code> special syntax returns TRUE or FALSE depending on whether the variable exists or not, and is thus always substituted, unless the colon is backslash-escaped.</p> <p>The colon syntax for variables is standard SQL for embedded query languages, such as ECPG. The colon syntaxes for array slices and type casts are PostgreSQL extensions, which can sometimes conflict with the standard usage. The colon-quote syntax for escaping a variable's value as an SQL literal or identifier is a psql extension.</p> </div> <div class="refsect3" id="APP-PSQL-PROMPTING"> <h4>Prompting</h4> <p>The prompts psql issues can be customized to your preference. The three variables <code class="varname">PROMPT1</code>, <code class="varname">PROMPT2</code>, and <code class="varname">PROMPT3</code> contain strings and special escape sequences that describe the appearance of the prompt. Prompt 1 is the normal prompt that is issued when psql requests a new command. Prompt 2 is issued when more input is expected during command entry, for example because the command was not terminated with a semicolon or a quote was not closed. Prompt 3 is issued when you are running an SQL <code class="command">COPY FROM STDIN</code> command and you need to type in a row value on the terminal.</p> <p>The value of the selected prompt variable is printed literally, except where a percent sign (<code class="literal">%</code>) is encountered. Depending on the next character, certain other text is substituted instead. Defined substitutions are:</p> <div class="variablelist"> <dl class="variablelist"> <dt id="APP-PSQL-PROMPTING-M-UC">
<code class="literal">%M</code> </dt> <dd> <p>The full host name (with domain name) of the database server, or <code class="literal">[local]</code> if the connection is over a Unix domain socket, or <code class="literal">[local:/dir/name]</code>, if the Unix domain socket is not at the compiled in default location.</p> </dd> <dt id="APP-PSQL-PROMPTING-M-LC">
<code class="literal">%m</code> </dt> <dd> <p>The host name of the database server, truncated at the first dot, or <code class="literal">[local]</code> if the connection is over a Unix domain socket.</p> </dd> <dt id="APP-PSQL-PROMPTING-GT">
<code class="literal">%&gt;</code> </dt> <dd> <p>The port number at which the database server is listening.</p> </dd> <dt id="APP-PSQL-PROMPTING-N">
<code class="literal">%n</code> </dt> <dd> <p>The database session user name. (The expansion of this value might change during a database session as the result of the command <code class="command">SET SESSION AUTHORIZATION</code>.)</p> </dd> <dt id="APP-PSQL-PROMPTING-SLASH">
<code class="literal">%/</code> </dt> <dd> <p>The name of the current database.</p> </dd> <dt id="APP-PSQL-PROMPTING-TILDE">
<code class="literal">%~</code> </dt> <dd> <p>Like <code class="literal">%/</code>, but the output is <code class="literal">~</code> (tilde) if the database is your default database.</p> </dd> <dt id="APP-PSQL-PROMPTING-NUMBERSIGN">
<code class="literal">%#</code> </dt> <dd> <p>If the session user is a database superuser, then a <code class="literal">#</code>, otherwise a <code class="literal">&gt;</code>. (The expansion of this value might change during a database session as the result of the command <code class="command">SET SESSION AUTHORIZATION</code>.)</p> </dd> <dt id="APP-PSQL-PROMPTING-P">
<code class="literal">%p</code> </dt> <dd> <p>The process ID of the backend currently connected to.</p> </dd> <dt id="APP-PSQL-PROMPTING-R">
<code class="literal">%R</code> </dt> <dd> <p>In prompt 1 normally <code class="literal">=</code>, but <code class="literal">@</code> if the session is in an inactive branch of a conditional block, or <code class="literal">^</code> if in single-line mode, or <code class="literal">!</code> if the session is disconnected from the database (which can happen if <code class="command">\connect</code> fails). In prompt 2 <code class="literal">%R</code> is replaced by a character that depends on why psql expects more input: <code class="literal">-</code> if the command simply wasn't terminated yet, but <code class="literal">*</code> if there is an unfinished <code class="literal">/* ... */</code> comment, a single quote if there is an unfinished quoted string, a double quote if there is an unfinished quoted identifier, a dollar sign if there is an unfinished dollar-quoted string, or <code class="literal">(</code> if there is an unmatched left parenthesis. In prompt 3 <code class="literal">%R</code> doesn't produce anything.</p> </dd> <dt id="APP-PSQL-PROMPTING-X">
<code class="literal">%x</code> </dt> <dd> <p>Transaction status: an empty string when not in a transaction block, or <code class="literal">*</code> when in a transaction block, or <code class="literal">!</code> when in a failed transaction block, or <code class="literal">?</code> when the transaction state is indeterminate (for example, because there is no connection).</p> </dd> <dt id="APP-PSQL-PROMPTING-L">
<code class="literal">%l</code> </dt> <dd> <p>The line number inside the current statement, starting from <code class="literal">1</code>.</p> </dd> <dt id="APP-PSQL-PROMPTING-DIGITS">
<code class="literal">%</code><code>digits</code> </dt> <dd> <p>The character with the indicated octal code is substituted.</p> </dd> <dt id="APP-PSQL-PROMPTING-NAME">
<code class="literal">%:</code><code>name</code><code class="literal">:</code> </dt> <dd> <p>The value of the psql variable <code>name</code>. See <a class="xref" href="app-psql.html#APP-PSQL-VARIABLES" title="Variables">Variables</a>, above, for details.</p> </dd> <dt id="APP-PSQL-PROMPTING-COMMAND">
<code class="literal">%`</code><code>command</code><code class="literal">`</code> </dt> <dd> <p>The output of <code>command</code>, similar to ordinary <span class="quote">“<span class="quote">back-tick</span>”</span> substitution.</p> </dd> <dt id="APP-PSQL-PROMPTING-SQUARE-BRACKETS">
<code class="literal">%[</code> ... <code class="literal">%]</code> </dt> <dd> <p>Prompts can contain terminal control characters which, for example, change the color, background, or style of the prompt text, or change the title of the terminal window. In order for the line editing features of Readline to work properly, these non-printing control characters must be designated as invisible by surrounding them with <code class="literal">%[</code> and <code class="literal">%]</code>. Multiple pairs of these can occur within the prompt. For example:</p> <pre data-language="sql">
testdb=&gt; \set PROMPT1 '%[%033[1;33;40m%]%n@%/%R%[%033[0m%]%# '
</pre> <p>results in a boldfaced (<code class="literal">1;</code>) yellow-on-black (<code class="literal">33;40</code>) prompt on VT100-compatible, color-capable terminals.</p> </dd> <dt id="APP-PSQL-PROMPTING-W">
<code class="literal">%w</code> </dt> <dd> <p>Whitespace of the same width as the most recent output of <code class="varname">PROMPT1</code>. This can be used as a <code class="varname">PROMPT2</code> setting, so that multi-line statements are aligned with the first line, but there is no visible secondary prompt.</p> </dd> </dl> </div> <p>To insert a percent sign into your prompt, write <code class="literal">%%</code>. The default prompts are <code class="literal">'%/%R%x%# '</code> for prompts 1 and 2, and <code class="literal">'&gt;&gt; '</code> for prompt 3.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>This feature was shamelessly plagiarized from tcsh.</p> </blockquote> </div> <div class="refsect3" id="id-1.9.4.20.8.5.5.3"> <h4>Command-Line Editing</h4> <p>psql uses the Readline or libedit library, if available, for convenient line editing and retrieval. The command history is automatically saved when psql exits and is reloaded when psql starts up. Type up-arrow or control-P to retrieve previous lines.</p> <p>You can also use tab completion to fill in partially-typed keywords and SQL object names in many (by no means all) contexts. For example, at the start of a command, typing <code class="literal">ins</code> and pressing TAB will fill in <code class="literal">insert into</code> . Then, typing a few characters of a table or schema name and pressing <code class="literal">TAB</code> will fill in the unfinished name, or offer a menu of possible completions when there's more than one. (Depending on the library in use, you may need to press <code class="literal">TAB</code> more than once to get a menu.)</p> <p>Tab completion for SQL object names requires sending queries to the server to find possible matches. In some contexts this can interfere with other operations. For example, after <code class="command">BEGIN</code> it will be too late to issue <code class="command">SET TRANSACTION ISOLATION LEVEL</code> if a tab-completion query is issued in between. If you do not want tab completion at all, you can turn it off permanently by putting this in a file named <code class="filename">.inputrc</code> in your home directory:</p> <pre data-language="sql">
$if psql
set disable-completion on
$endif
</pre> <p>(This is not a psql but a Readline feature. Read its documentation for further details.)</p> <p>The <code class="option">-n</code> (<code class="option">--no-readline</code>) command line option can also be useful to disable use of Readline for a single run of psql. This prevents tab completion, use or recording of command line history, and editing of multi-line commands. It is particularly useful when you need to copy-and-paste text that contains <code class="literal">TAB</code> characters.</p> </div> </div> </div> <div class="refsect1" id="APP-PSQL-ENVIRONMENT"> <h2>Environment</h2> <div class="variablelist"> <dl class="variablelist"> <dt id="APP-PSQL-ENVIRONMENT-COLUMNS">
<code class="envar">COLUMNS</code> </dt> <dd> <p>If <code class="literal">\pset columns</code> is zero, controls the width for the <code class="literal">wrapped</code> format and width for determining if wide output requires the pager or should be switched to the vertical format in expanded auto mode.</p> </dd> <dt id="APP-PSQL-ENVIRONMENT-PGDATABASE">
<code class="envar">PGDATABASE</code><code class="envar">PGHOST</code><code class="envar">PGPORT</code><code class="envar">PGUSER</code> </dt> <dd> <p>Default connection parameters (see <a class="xref" href="https://www.postgresql.org/docs/16/libpq-envars.html" title="34.15. Environment Variables">Section 34.15</a>).</p> </dd> <dt id="APP-PSQL-ENVIRONMENT-PG-COLOR">
<code class="envar">PG_COLOR</code> </dt> <dd> <p>Specifies whether to use color in diagnostic messages. Possible values are <code class="literal">always</code>, <code class="literal">auto</code> and <code class="literal">never</code>.</p> </dd> <dt id="APP-PSQL-ENVIRONMENT-PSQL-EDITOR">
<code class="envar">PSQL_EDITOR</code><code class="envar">EDITOR</code><code class="envar">VISUAL</code> </dt> <dd> <p>Editor used by the <code class="command">\e</code>, <code class="command">\ef</code>, and <code class="command">\ev</code> commands. These variables are examined in the order listed; the first that is set is used. If none of them is set, the default is to use <code class="filename">vi</code> on Unix systems or <code class="filename">notepad.exe</code> on Windows systems.</p> </dd> <dt id="APP-PSQL-ENVIRONMENT-PSQL-EDITOR-LINENUMBER-ARG">
<code class="envar">PSQL_EDITOR_LINENUMBER_ARG</code> </dt> <dd> <p>When <code class="command">\e</code>, <code class="command">\ef</code>, or <code class="command">\ev</code> is used with a line number argument, this variable specifies the command-line argument used to pass the starting line number to the user's editor. For editors such as Emacs or vi, this is a plus sign. Include a trailing space in the value of the variable if there needs to be space between the option name and the line number. Examples:</p> <pre data-language="sql">
PSQL_EDITOR_LINENUMBER_ARG='+'
PSQL_EDITOR_LINENUMBER_ARG='--line '
</pre> <p>The default is <code class="literal">+</code> on Unix systems (corresponding to the default editor <code class="filename">vi</code>, and useful for many other common editors); but there is no default on Windows systems.</p> </dd> <dt id="APP-PSQL-ENVIRONMENT-PSQL-HISTORY">
<code class="envar">PSQL_HISTORY</code> </dt> <dd> <p>Alternative location for the command history file. Tilde (<code class="literal">~</code>) expansion is performed.</p> </dd> <dt id="APP-PSQL-ENVIRONMENT-PAGER">
<code class="envar">PSQL_PAGER</code><code class="envar">PAGER</code> </dt> <dd> <p>If a query's results do not fit on the screen, they are piped through this command. Typical values are <code class="literal">more</code> or <code class="literal">less</code>. Use of the pager can be disabled by setting <code class="envar">PSQL_PAGER</code> or <code class="envar">PAGER</code> to an empty string, or by adjusting the pager-related options of the <code class="command">\pset</code> command. These variables are examined in the order listed; the first that is set is used. If neither of them is set, the default is to use <code class="literal">more</code> on most platforms, but <code class="literal">less</code> on Cygwin.</p> </dd> <dt id="APP-PSQL-ENVIRONMENT-PSQL-WATCH-PAGER">
<code class="envar">PSQL_WATCH_PAGER</code> </dt> <dd> <p>When a query is executed repeatedly with the <code class="command">\watch</code> command, a pager is not used by default. This behavior can be changed by setting <code class="envar">PSQL_WATCH_PAGER</code> to a pager command, on Unix systems. The <code class="literal">pspg</code> pager (not part of PostgreSQL but available in many open source software distributions) can display the output of <code class="command">\watch</code> if started with the option <code class="literal">--stream</code>.</p> </dd> <dt id="APP-PSQL-ENVIRONMENT-PSQLRC">
<code class="envar">PSQLRC</code> </dt> <dd> <p>Alternative location of the user's <code class="filename">.psqlrc</code> file. Tilde (<code class="literal">~</code>) expansion is performed.</p> </dd> <dt id="APP-PSQL-ENVIRONMENT-SHELL">
<code class="envar">SHELL</code> </dt> <dd> <p>Command executed by the <code class="command">\!</code> command.</p> </dd> <dt id="APP-PSQL-ENVIRONMENT-TMPDIR">
<code class="envar">TMPDIR</code> </dt> <dd> <p>Directory for storing temporary files. The default is <code class="filename">/tmp</code>.</p> </dd> </dl> </div> <p>This utility, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see <a class="xref" href="https://www.postgresql.org/docs/16/libpq-envars.html" title="34.15. Environment Variables">Section 34.15</a>).</p> </div> <div class="refsect1" id="id-1.9.4.20.10"> <h2>Files</h2> <div class="variablelist"> <dl class="variablelist"> <dt id="APP-PSQL-FILES-PSQLRC">
<code class="filename">psqlrc</code> and <code class="filename">~/.psqlrc</code> </dt> <dd> <p>Unless it is passed an <code class="option">-X</code> option, psql attempts to read and execute commands from the system-wide startup file (<code class="filename">psqlrc</code>) and then the user's personal startup file (<code class="filename">~/.psqlrc</code>), after connecting to the database but before accepting normal commands. These files can be used to set up the client and/or the server to taste, typically with <code class="command">\set</code> and <code class="command">SET</code> commands.</p> <p>The system-wide startup file is named <code class="filename">psqlrc</code>. By default it is sought in the installation's <span class="quote">“<span class="quote">system configuration</span>”</span> directory, which is most reliably identified by running <code class="literal">pg_config --sysconfdir</code>. Typically this directory will be <code class="filename">../etc/</code> relative to the directory containing the PostgreSQL executables. The directory to look in can be set explicitly via the <code class="envar">PGSYSCONFDIR</code> environment variable.</p> <p>The user's personal startup file is named <code class="filename">.psqlrc</code> and is sought in the invoking user's home directory. On Windows the personal startup file is instead named <code class="filename">%APPDATA%\postgresql\psqlrc.conf</code>. In either case, this default file path can be overridden by setting the <code class="envar">PSQLRC</code> environment variable.</p> <p>Both the system-wide startup file and the user's personal startup file can be made psql-version-specific by appending a dash and the PostgreSQL major or minor release identifier to the file name, for example <code class="filename">~/.psqlrc-16</code> or <code class="filename">~/.psqlrc-16.1</code>. The most specific version-matching file will be read in preference to a non-version-specific file. These version suffixes are added after determining the file path as explained above.</p> </dd> <dt id="APP-PSQL-FILES-PSQL-HISTORY">
<code class="filename">.psql_history</code> </dt> <dd> <p>The command-line history is stored in the file <code class="filename">~/.psql_history</code>, or <code class="filename">%APPDATA%\postgresql\psql_history</code> on Windows.</p> <p>The location of the history file can be set explicitly via the <code class="varname">HISTFILE</code> psql variable or the <code class="envar">PSQL_HISTORY</code> environment variable.</p> </dd> </dl> </div> </div> <div class="refsect1" id="id-1.9.4.20.11"> <h2>Notes</h2>  <ul> <li> <p>psql works best with servers of the same or an older major version. Backslash commands are particularly likely to fail if the server is of a newer version than psql itself. However, backslash commands of the <code class="literal">\d</code> family should work with servers of versions back to 9.2, though not necessarily with servers newer than psql itself. The general functionality of running SQL commands and displaying query results should also work with servers of a newer major version, but this cannot be guaranteed in all cases.</p> <p>If you want to use psql to connect to several servers of different major versions, it is recommended that you use the newest version of psql. Alternatively, you can keep around a copy of psql from each major version and be sure to use the version that matches the respective server. But in practice, this additional complication should not be necessary.</p> </li> <li> <p>Before PostgreSQL 9.6, the <code class="option">-c</code> option implied <code class="option">-X</code> (<code class="option">--no-psqlrc</code>); this is no longer the case.</p> </li> <li> <p>Before PostgreSQL 8.4, psql allowed the first argument of a single-letter backslash command to start directly after the command, without intervening whitespace. Now, some whitespace is required.</p> </li> </ul>  </div> <div class="refsect1" id="id-1.9.4.20.12"> <h2>Notes for Windows Users</h2> <p>psql is built as a <span class="quote">“<span class="quote">console application</span>”</span>. Since the Windows console windows use a different encoding than the rest of the system, you must take special care when using 8-bit characters within psql. If psql detects a problematic console code page, it will warn you at startup. To change the console code page, two things are necessary:</p>  <ul> <li> <p>Set the code page by entering <strong class="userinput"><code>cmd.exe /c chcp 1252</code></strong>. (1252 is a code page that is appropriate for German; replace it with your value.) If you are using Cygwin, you can put this command in <code class="filename">/etc/profile</code>.</p> </li> <li> <p>Set the console font to <code class="literal">Lucida Console</code>, because the raster font does not work with the ANSI code page.</p> </li> </ul>  </div> <div class="refsect1" id="APP-PSQL-EXAMPLES"> <h2>Examples</h2> <p>The first example shows how to spread a command over several lines of input. Notice the changing prompt:</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">CREATE TABLE my_table (</strong>
testdb(&gt; <strong class="userinput"> first integer not null default 0,</strong>
testdb(&gt; <strong class="userinput"> second text)</strong>
testdb-&gt; <strong class="userinput">;</strong>
CREATE TABLE
</pre> <p>Now look at the table definition again:</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">\d my_table</strong>
              Table "public.my_table"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 first  | integer |           | not null | 0
 second | text    |           |          |
</pre> <p>Now we change the prompt to something more interesting:</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">\set PROMPT1 '%n@%m %~%R%# '</strong>
peter@localhost testdb=&gt;
</pre> <p>Let's assume you have filled the table with data and want to take a look at it:</p> <pre data-language="sql">
peter@localhost testdb=&gt; SELECT * FROM my_table;
 first | second
-------+--------
     1 | one
     2 | two
     3 | three
     4 | four
(4 rows)
</pre> <p>You can display tables in different ways by using the <code class="command">\pset</code> command:</p> <pre data-language="sql">
peter@localhost testdb=&gt; <strong class="userinput">\pset border 2</strong>
Border style is 2.
peter@localhost testdb=&gt; <strong class="userinput">SELECT * FROM my_table;</strong>
+-------+--------+
| first | second |
+-------+--------+
|     1 | one    |
|     2 | two    |
|     3 | three  |
|     4 | four   |
+-------+--------+
(4 rows)

peter@localhost testdb=&gt; <strong class="userinput">\pset border 0</strong>
Border style is 0.
peter@localhost testdb=&gt; <strong class="userinput">SELECT * FROM my_table;</strong>
first second
----- ------
    1 one
    2 two
    3 three
    4 four
(4 rows)

peter@localhost testdb=&gt; <strong class="userinput">\pset border 1</strong>
Border style is 1.
peter@localhost testdb=&gt; <strong class="userinput">\pset format csv</strong>
Output format is csv.
peter@localhost testdb=&gt; <strong class="userinput">\pset tuples_only</strong>
Tuples only is on.
peter@localhost testdb=&gt; <strong class="userinput">SELECT second, first FROM my_table;</strong>
one,1
two,2
three,3
four,4
peter@localhost testdb=&gt; <strong class="userinput">\pset format unaligned</strong>
Output format is unaligned.
peter@localhost testdb=&gt; <strong class="userinput">\pset fieldsep '\t'</strong>
Field separator is "    ".
peter@localhost testdb=&gt; <strong class="userinput">SELECT second, first FROM my_table;</strong>
one     1
two     2
three   3
four    4
</pre> <p>Alternatively, use the short commands:</p> <pre data-language="sql">
peter@localhost testdb=&gt; <strong class="userinput">\a \t \x</strong>
Output format is aligned.
Tuples only is off.
Expanded display is on.
peter@localhost testdb=&gt; <strong class="userinput">SELECT * FROM my_table;</strong>
-[ RECORD 1 ]-
first  | 1
second | one
-[ RECORD 2 ]-
first  | 2
second | two
-[ RECORD 3 ]-
first  | 3
second | three
-[ RECORD 4 ]-
first  | 4
second | four
</pre> <p>Also, these output format options can be set for just one query by using <code class="literal">\g</code>:</p> <pre data-language="sql">
peter@localhost testdb=&gt; <strong class="userinput">SELECT * FROM my_table</strong>
peter@localhost testdb-&gt; <strong class="userinput">\g (format=aligned tuples_only=off expanded=on)</strong>
-[ RECORD 1 ]-
first  | 1
second | one
-[ RECORD 2 ]-
first  | 2
second | two
-[ RECORD 3 ]-
first  | 3
second | three
-[ RECORD 4 ]-
first  | 4
second | four
</pre> <p>Here is an example of using the <code class="command">\df</code> command to find only functions with names matching <code class="literal">int*pl</code> and whose second argument is of type <code class="type">bigint</code>:</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">\df int*pl * bigint</strong>
                          List of functions
   Schema   |  Name   | Result data type | Argument data types | Type
------------+---------+------------------+---------------------+------
 pg_catalog | int28pl | bigint           | smallint, bigint    | func
 pg_catalog | int48pl | bigint           | integer, bigint     | func
 pg_catalog | int8pl  | bigint           | bigint, bigint      | func
(3 rows)
</pre> <p>When suitable, query results can be shown in a crosstab representation with the <code class="command">\crosstabview</code> command:</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">SELECT first, second, first &gt; 2 AS gt2 FROM my_table;</strong>
 first | second | gt2
-------+--------+-----
     1 | one    | f
     2 | two    | f
     3 | three  | t
     4 | four   | t
(4 rows)

testdb=&gt; <strong class="userinput">\crosstabview first second</strong>
 first | one | two | three | four
-------+-----+-----+-------+------
     1 | f   |     |       |
     2 |     | f   |       |
     3 |     |     | t     |
     4 |     |     |       | t
(4 rows)
</pre> <p>This second example shows a multiplication table with rows sorted in reverse numerical order and columns with an independent, ascending numerical order.</p> <pre data-language="sql">
testdb=&gt; <strong class="userinput">SELECT t1.first as "A", t2.first+100 AS "B", t1.first*(t2.first+100) as "AxB",</strong>
testdb(&gt; <strong class="userinput">row_number() over(order by t2.first) AS ord</strong>
testdb(&gt; <strong class="userinput">FROM my_table t1 CROSS JOIN my_table t2 ORDER BY 1 DESC</strong>
testdb(&gt; <strong class="userinput">\crosstabview "A" "B" "AxB" ord</strong>
 A | 101 | 102 | 103 | 104
---+-----+-----+-----+-----
 4 | 404 | 408 | 412 | 416
 3 | 303 | 306 | 309 | 312
 2 | 202 | 204 | 206 | 208
 1 | 101 | 102 | 103 | 104
(4 rows)
</pre> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996&ndash;2023 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/16/app-psql.html" class="_attribution-link">https://www.postgresql.org/docs/16/app-psql.html</a>
  </p>
</div>
