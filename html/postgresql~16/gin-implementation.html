<h1>70.4. Implementation </h1>    <div class="toc"> <dl class="toc"> <dt><a href="gin-implementation.html#GIN-FAST-UPDATE">70.4.1. GIN Fast Update Technique</a></dt> <dt><a href="gin-implementation.html#GIN-PARTIAL-MATCH">70.4.2. Partial Match Algorithm</a></dt> </dl> </div> <p>Internally, a GIN index contains a B-tree index constructed over keys, where each key is an element of one or more indexed items (a member of an array, for example) and where each tuple in a leaf page contains either a pointer to a B-tree of heap pointers (a <span class="quote">“<span class="quote">posting tree</span>”</span>), or a simple list of heap pointers (a <span class="quote">“<span class="quote">posting list</span>”</span>) when the list is small enough to fit into a single index tuple along with the key value. <a class="xref" href="gin-implementation.html#GIN-INTERNALS-FIGURE" title="Figure 70.1. GIN Internals">Figure 70.1</a> illustrates these components of a GIN index.</p> <p>As of PostgreSQL 9.1, null key values can be included in the index. Also, placeholder nulls are included in the index for indexed items that are null or contain no keys according to <code class="function">extractValue</code>. This allows searches that should find empty items to do so.</p> <p>Multicolumn GIN indexes are implemented by building a single B-tree over composite values (column number, key value). The key values for different columns can be of different types.</p> <div class="figure col-xl-8 col-lg-10 col-md-12" id="GIN-INTERNALS-FIGURE"> <p class="title"><strong>Figure 70.1. GIN Internals</strong></p>  </div> <div class="sect2" id="GIN-FAST-UPDATE">    <h2 class="title">70.4.1. GIN Fast Update Technique </h2>    <p>Updating a GIN index tends to be slow because of the intrinsic nature of inverted indexes: inserting or updating one heap row can cause many inserts into the index (one for each key extracted from the indexed item). GIN is capable of postponing much of this work by inserting new tuples into a temporary, unsorted list of pending entries. When the table is vacuumed or autoanalyzed, or when <code class="function">gin_clean_pending_list</code> function is called, or if the pending list becomes larger than <a class="xref" href="runtime-config-client.html#GUC-GIN-PENDING-LIST-LIMIT">gin_pending_list_limit</a>, the entries are moved to the main GIN data structure using the same bulk insert techniques used during initial index creation. This greatly improves GIN index update speed, even counting the additional vacuum overhead. Moreover the overhead work can be done by a background process instead of in foreground query processing.</p> <p>The main disadvantage of this approach is that searches must scan the list of pending entries in addition to searching the regular index, and so a large list of pending entries will slow searches significantly. Another disadvantage is that, while most updates are fast, an update that causes the pending list to become <span class="quote">“<span class="quote">too large</span>”</span> will incur an immediate cleanup cycle and thus be much slower than other updates. Proper use of autovacuum can minimize both of these problems.</p> <p>If consistent response time is more important than update speed, use of pending entries can be disabled by turning off the <code class="literal">fastupdate</code> storage parameter for a GIN index. See <a class="xref" href="sql-createindex.html" title="CREATE INDEX">CREATE INDEX</a> for details.</p> </div> <div class="sect2" id="GIN-PARTIAL-MATCH">    <h2 class="title">70.4.2. Partial Match Algorithm </h2>    <p>GIN can support <span class="quote">“<span class="quote">partial match</span>”</span> queries, in which the query does not determine an exact match for one or more keys, but the possible matches fall within a reasonably narrow range of key values (within the key sorting order determined by the <code class="function">compare</code> support method). The <code class="function">extractQuery</code> method, instead of returning a key value to be matched exactly, returns a key value that is the lower bound of the range to be searched, and sets the <code class="literal">pmatch</code> flag true. The key range is then scanned using the <code class="function">comparePartial</code> method. <code class="function">comparePartial</code> must return zero for a matching index key, less than zero for a non-match that is still within the range to be searched, or greater than zero if the index key is past the range that could match.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996&ndash;2023 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/16/gin-implementation.html" class="_attribution-link">https://www.postgresql.org/docs/16/gin-implementation.html</a>
  </p>
</div>
