<h1 title="Interface SymbolLookup" class="title">Interface SymbolLookup</h1> <section class="class-description" id="class-description"> <dl class="notes"> <dt>Functional Interface:</dt> <dd>This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference.</dd> </dl>  <pre class="lang-java" data-language="java">@FunctionalInterface public interface SymbolLookup</pre> <div class="preview-block" id="preview-java.lang.foreign.SymbolLookup">
<span class="preview-label"><code>SymbolLookup</code> is a preview API of the Java platform.</span> <div class="preview-comment">Programs can only use <code>SymbolLookup</code> when preview features are enabled.</div> <div class="preview-comment">Preview features may be removed in a future release, or upgraded to permanent features of the Java platform.</div> </div> <div class="block">A <em>symbol lookup</em> retrieves the address of a symbol in one or more libraries. A symbol is a named entity, such as a function or a global variable. <p> A symbol lookup is created with respect to a particular library (or libraries). Subsequently, the <a href="#find(java.lang.String)"><code>find(String)</code></a> method takes the name of a symbol and returns the address of the symbol in that library. </p>
<p> The address of a symbol is modelled as a zero-length <a href="memorysegment.html" title="interface in java.lang.foreign">memory segment</a><sup><a href="memorysegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>. The segment can be used in different ways: </p>
<ul> <li>It can be passed to a <a href="linker.html" title="interface in java.lang.foreign"><code>Linker</code></a><sup><a href="linker.html#preview-java.lang.foreign.Linker">PREVIEW</a></sup> to create a downcall method handle, which can then be used to call the foreign function at the segment's address.</li> <li>It can be passed to an existing <a href="linker.html#downcallHandle(java.lang.foreign.FunctionDescriptor,java.lang.foreign.Linker.Option...)">downcall method handle</a><sup><a href="linker.html#preview-java.lang.foreign.Linker">PREVIEW</a></sup>, as an argument to the underlying foreign function.</li> <li>It can be <a href="memorysegment.html#set(java.lang.foreign.AddressLayout,long,java.lang.foreign.MemorySegment)">stored</a><sup><a href="memorysegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> inside another memory segment.</li> <li>It can be used to access the region of memory backing a global variable (this requires <a href="memorysegment.html#reinterpret(long)">resizing</a><sup><a href="memorysegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> the segment first).</li> </ul> <h2 id="obtaining">Obtaining a symbol lookup</h2> The factory methods <a href="#libraryLookup(java.lang.String,java.lang.foreign.Arena)"><code>libraryLookup(String, Arena)</code></a> and <a href="#libraryLookup(java.nio.file.Path,java.lang.foreign.Arena)"><code>libraryLookup(Path, Arena)</code></a> create a symbol lookup for a library known to the operating system. The library is specified by either its name or a path. The library is loaded if not already loaded. The symbol lookup, which is known as a <em>library lookup</em>, and its lifetime is controlled by an <a href="arena.html" title="interface in java.lang.foreign">arena</a><sup><a href="arena.html#preview-java.lang.foreign.Arena">PREVIEW</a></sup>. For instance, if the provided arena is a confined arena, the library associated with the symbol lookup is unloaded when the confined arena is <a href="arena.html#close()">closed</a><sup><a href="arena.html#preview-java.lang.foreign.Arena">PREVIEW</a></sup>: <div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java"> try (Arena arena = Arena.ofConfined()) {
     SymbolLookup libGL = SymbolLookup.libraryLookup("libGL.so", arena); // libGL.so loaded here
     MemorySegment glGetString = libGL.find("glGetString").orElseThrow();
     ...
 } //  libGL.so unloaded here
</code></pre> </div> <p> If a library was previously loaded through JNI, i.e., by <a href="../system.html#load(java.lang.String)"><code>System.load(String)</code></a> or <a href="../system.html#loadLibrary(java.lang.String)"><code>System.loadLibrary(String)</code></a>, then the library was also associated with a particular class loader. The factory method <a href="#loaderLookup()"><code>loaderLookup()</code></a> creates a symbol lookup for all the libraries associated with the caller's class loader: </p>
<div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java">System.loadLibrary("GL"); // libGL.so loaded here
...
SymbolLookup libGL = SymbolLookup.loaderLookup();
MemorySegment glGetString = libGL.find("glGetString").orElseThrow();
</code></pre> </div> This symbol lookup, which is known as a <em>loader lookup</em>, is dynamic with respect to the libraries associated with the class loader. If other libraries are subsequently loaded through JNI and associated with the class loader, then the loader lookup will expose their symbols automatically. <p> Note that a loader lookup only exposes symbols in libraries that were previously loaded through JNI, i.e., by <a href="../system.html#load(java.lang.String)"><code>System.load(String)</code></a> or <a href="../system.html#loadLibrary(java.lang.String)"><code>System.loadLibrary(String)</code></a>. A loader lookup does not expose symbols in libraries that were loaded in the course of creating a library lookup: </p>
<div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java"> libraryLookup("libGL.so", arena).find("glGetString").isPresent(); // true
 loaderLookup().find("glGetString").isPresent(); // false
</code></pre> </div> Note also that a library lookup for library <code>L</code> exposes symbols in <code>L</code> even if <code>L</code> was previously loaded through JNI (the association with a class loader is immaterial to the library lookup): <div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java"> System.loadLibrary("GL"); // libGL.so loaded here
 libraryLookup("libGL.so", arena).find("glGetString").isPresent(); // true
</code></pre> </div> <p> Finally, each <a href="linker.html" title="interface in java.lang.foreign"><code>Linker</code></a><sup><a href="linker.html#preview-java.lang.foreign.Linker">PREVIEW</a></sup> provides a symbol lookup for libraries that are commonly used on the OS and processor combination supported by that <a href="linker.html" title="interface in java.lang.foreign"><code>Linker</code></a><sup><a href="linker.html#preview-java.lang.foreign.Linker">PREVIEW</a></sup>. This symbol lookup, which is known as a <em>default lookup</em>, helps clients to quickly find addresses of well-known symbols. For example, a <a href="linker.html" title="interface in java.lang.foreign"><code>Linker</code></a><sup><a href="linker.html#preview-java.lang.foreign.Linker">PREVIEW</a></sup> for Linux/x64 might choose to expose symbols in <code>libc</code> through the default lookup: </p>
<div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java"> Linker nativeLinker = Linker.nativeLinker();
 SymbolLookup stdlib = nativeLinker.defaultLookup();
 MemorySegment malloc = stdlib.find("malloc").orElseThrow();
</code></pre> </div> </div> </section> <section class="summary"> <section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                   <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code><a href="../../util/optional.html" title="class in java.util">Optional</a><wbr>&lt;<a href="memorysegment.html" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="memorysegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>&gt;</wbr></code></td>
<td><code><a href="#find(java.lang.String)" class="member-name-link">find</a><wbr>(<a href="../string.html" title="class in java.lang">String</a> name)</wbr></code></td>
<td> <div class="block">Returns the address of the symbol with the given name.</div> </td>
</tr>
<tr>
<td><code>static <a href="symbollookup.html" title="interface in java.lang.foreign">SymbolLookup</a><sup><a href="#preview-java.lang.foreign.SymbolLookup">PREVIEW</a></sup></code></td>
<td><code><a href="#libraryLookup(java.lang.String,java.lang.foreign.Arena)" class="member-name-link">libraryLookup</a><wbr>(<a href="../string.html" title="class in java.lang">String</a> name,
 <a href="arena.html" title="interface in java.lang.foreign">Arena</a><sup><a href="arena.html#preview-java.lang.foreign.Arena">PREVIEW</a></sup> arena)</wbr></code></td>
<td> <div class="block">Loads a library with the given name (if not already loaded) and creates a symbol lookup for symbols in that library.</div> </td>
</tr>
<tr>
<td><code>static <a href="symbollookup.html" title="interface in java.lang.foreign">SymbolLookup</a><sup><a href="#preview-java.lang.foreign.SymbolLookup">PREVIEW</a></sup></code></td>
<td><code><a href="#libraryLookup(java.nio.file.Path,java.lang.foreign.Arena)" class="member-name-link">libraryLookup</a><wbr>(<a href="../../nio/file/path.html" title="interface in java.nio.file">Path</a> path,
 <a href="arena.html" title="interface in java.lang.foreign">Arena</a><sup><a href="arena.html#preview-java.lang.foreign.Arena">PREVIEW</a></sup> arena)</wbr></code></td>
<td> <div class="block">Loads a library from the given path (if not already loaded) and creates a symbol lookup for symbols in that library.</div> </td>
</tr>
<tr>
<td><code>static <a href="symbollookup.html" title="interface in java.lang.foreign">SymbolLookup</a><sup><a href="#preview-java.lang.foreign.SymbolLookup">PREVIEW</a></sup></code></td>
<td><code><a href="#loaderLookup()" class="member-name-link">loaderLookup</a>()</code></td>
<td> <div class="block">Returns a symbol lookup for symbols in the libraries associated with the caller's class loader.</div> </td>
</tr>
<tr>
<td><code>default <a href="symbollookup.html" title="interface in java.lang.foreign">SymbolLookup</a><sup><a href="#preview-java.lang.foreign.SymbolLookup">PREVIEW</a></sup></code></td>
<td><code><a href="#or(java.lang.foreign.SymbolLookup)" class="member-name-link">or</a><wbr>(<a href="symbollookup.html" title="interface in java.lang.foreign">SymbolLookup</a><sup><a href="#preview-java.lang.foreign.SymbolLookup">PREVIEW</a></sup> other)</wbr></code></td>
<td> <div class="block">Returns a composed symbol lookup that returns result of finding the symbol with this lookup if found, otherwise returns the result of finding the symbol with the other lookup.</div> </td>
</tr>
</table> </div> </div> </section> </section> <section class="details"> <section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="find(java.lang.String)"> <h3>find</h3> <pre class="lang-java" data-language="java">Optional&lt;MemorySegmentPREVIEW&gt; find(String name)</pre> <div class="block">Returns the address of the symbol with the given name.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>name</code> - the symbol name.</dd> <dt>Returns:</dt> <dd>a zero-length memory segment whose address indicates the address of the symbol, if found.</dd> </dl> </section><section class="detail" id="or(java.lang.foreign.SymbolLookup)"> <h3>or</h3> <pre class="lang-java" data-language="java">default SymbolLookupPREVIEW or(SymbolLookupPREVIEW other)</pre> <div class="block">Returns a composed symbol lookup that returns result of finding the symbol with this lookup if found, otherwise returns the result of finding the symbol with the other lookup.</div> <dl class="notes"> <dt>API Note:</dt> <dd>This method could be used to chain multiple symbol lookups together, e.g. so that symbols could be retrieved, in order, from multiple libraries: <div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java"> var lookup = SymbolLookup.libraryLookup("foo", arena)
         .or(SymbolLookup.libraryLookup("bar", arena))
         .or(SymbolLookup.loaderLookup());
</code></pre> </div> The above code creates a symbol lookup that first searches for symbols in the "foo" library. If no symbol is found in "foo" then "bar" is searched. Finally, if a symbol is not found in neither "foo" nor "bar", the <a href="#loaderLookup()">loader lookup</a> is used.</dd> <dt>Parameters:</dt> <dd>
<code>other</code> - the symbol lookup that should be used to look for symbols not found in this lookup.</dd> <dt>Returns:</dt> <dd>a composed symbol lookup that returns result of finding the symbol with this lookup if found, otherwise returns the result of finding the symbol with the other lookup</dd> </dl> </section><section class="detail" id="loaderLookup()"> <h3>loaderLookup</h3> <pre class="lang-java" data-language="java">static SymbolLookupPREVIEW loaderLookup()</pre> <div class="block">Returns a symbol lookup for symbols in the libraries associated with the caller's class loader. <p> A library is associated with a class loader <code>CL</code> when the library is loaded via an invocation of <a href="../system.html#load(java.lang.String)"><code>System.load(String)</code></a> or <a href="../system.html#loadLibrary(java.lang.String)"><code>System.loadLibrary(String)</code></a> from code in a class defined by <code>CL</code>. If that code makes further invocations of <a href="../system.html#load(java.lang.String)"><code>System.load(String)</code></a> or <a href="../system.html#loadLibrary(java.lang.String)"><code>System.loadLibrary(String)</code></a>, then more libraries are loaded and associated with <code>CL</code>. The symbol lookup returned by this method is always current: it reflects all the libraries associated with the relevant class loader, even if they were loaded after this method returned. </p>
<p> Libraries associated with a class loader are unloaded when the class loader becomes <a href="../ref/package.html#reachability">unreachable</a>. The symbol lookup returned by this method is associated with a fresh <a href="memorysegment.scope.html" title="interface in java.lang.foreign">scope</a><sup><a href="memorysegment.scope.html#preview-java.lang.foreign.MemorySegment.Scope">PREVIEW</a></sup> which keeps the caller's class loader reachable. Therefore, libraries associated with the caller's class loader are kept loaded (and their symbols available) as long as a loader lookup for that class loader, or any of the segments obtained by it, is reachable. </p>
<p> In cases where this method is called from a context where there is no caller frame on the stack (e.g. when called directly from a JNI attached thread), the caller's class loader defaults to the <a href="../classloader.html#getSystemClassLoader()">system class loader</a>.</p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>a symbol lookup for symbols in the libraries associated with the caller's class loader.</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="../system.html#load(java.lang.String)"><code>System.load(String)</code></a></li> <li><a href="../system.html#loadLibrary(java.lang.String)"><code>System.loadLibrary(String)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="libraryLookup(java.lang.String,java.lang.foreign.Arena)"> <h3>libraryLookup</h3> <pre class="lang-java" data-language="java">static SymbolLookupPREVIEW libraryLookup(String name, ArenaPREVIEW arena)</pre> <div class="block">Loads a library with the given name (if not already loaded) and creates a symbol lookup for symbols in that library. The lifetime of the returned library lookup is controlled by the provided arena. For instance, if the provided arena is a confined arena, the library associated with the returned lookup will be unloaded when the provided confined arena is <a href="arena.html#close()">closed</a><sup><a href="arena.html#preview-java.lang.foreign.Arena">PREVIEW</a></sup>. <p> This method is <a href="package-summary.html#restricted"><em>restricted</em></a>. Restricted methods are unsafe, and, if used incorrectly, their use might crash the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on restricted methods, and use safe and supported functionalities, where possible.</p>
</div> <dl class="notes"> <dt>Implementation Note:</dt> <dd>The process of resolving a library name is OS-specific. For instance, in a POSIX-compliant OS, the library name is resolved according to the specification of the <code>dlopen</code> function for that OS. In Windows, the library name is resolved according to the specification of the <code>LoadLibrary</code> function.</dd> <dt>Parameters:</dt> <dd>
<code>name</code> - the name of the library in which symbols should be looked up.</dd> <dd>
<code>arena</code> - the arena associated with symbols obtained from the returned lookup.</dd> <dt>Returns:</dt> <dd>a new symbol lookup suitable to find symbols in a library with the given name.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception.html" title="class in java.lang">IllegalStateException</a></code> - if <code>arena.scope().isAlive() == false</code>
</dd> <dd>
<code><a href="../wrongthreadexception.html" title="class in java.lang">WrongThreadException</a></code> - if <code>arena</code> is a confined arena, and this method is called from a thread <code>T</code>, other than the arena's owner thread.</dd> <dd>
<code><a href="../illegalargumentexception.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>name</code> does not identify a valid library.</dd> <dd>
<code><a href="../illegalcallerexception.html" title="class in java.lang">IllegalCallerException</a></code> - If the caller is in a module that does not have native access enabled.</dd> </dl> </section><section class="detail" id="libraryLookup(java.nio.file.Path,java.lang.foreign.Arena)"> <h3>libraryLookup</h3> <pre class="lang-java" data-language="java">static SymbolLookupPREVIEW libraryLookup(Path path, ArenaPREVIEW arena)</pre> <div class="block">Loads a library from the given path (if not already loaded) and creates a symbol lookup for symbols in that library. The lifetime of the returned library lookup is controlled by the provided arena. For instance, if the provided arena is a confined arena, the library associated with the returned lookup will be unloaded when the provided confined arena is <a href="arena.html#close()">closed</a><sup><a href="arena.html#preview-java.lang.foreign.Arena">PREVIEW</a></sup>. <p> This method is <a href="package-summary.html#restricted"><em>restricted</em></a>. Restricted methods are unsafe, and, if used incorrectly, their use might crash the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on restricted methods, and use safe and supported functionalities, where possible.</p>
</div> <dl class="notes"> <dt>Implementation Note:</dt> <dd>On Linux, the functionalities provided by this factory method and the returned symbol lookup are implemented using the <code>dlopen</code>, <code>dlsym</code> and <code>dlclose</code> functions.</dd> <dt>Parameters:</dt> <dd>
<code>path</code> - the path of the library in which symbols should be looked up.</dd> <dd>
<code>arena</code> - the arena associated with symbols obtained from the returned lookup.</dd> <dt>Returns:</dt> <dd>a new symbol lookup suitable to find symbols in a library with the given path.</dd> <dt>Throws:</dt> <dd>
<code><a href="../illegalstateexception.html" title="class in java.lang">IllegalStateException</a></code> - if <code>arena.scope().isAlive() == false</code>
</dd> <dd>
<code><a href="../wrongthreadexception.html" title="class in java.lang">WrongThreadException</a></code> - if <code>arena</code> is a confined arena, and this method is called from a thread <code>T</code>, other than the arena's owner thread.</dd> <dd>
<code><a href="../illegalargumentexception.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>path</code> does not point to a valid library.</dd> <dd>
<code><a href="../illegalcallerexception.html" title="class in java.lang">IllegalCallerException</a></code> - If the caller is in a module that does not have native access enabled.</dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2023, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/foreign/SymbolLookup.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/foreign/SymbolLookup.html</a>
  </p>
</div>
