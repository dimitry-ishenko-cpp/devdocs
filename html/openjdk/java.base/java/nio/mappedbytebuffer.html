<h1 title="Class MappedByteBuffer" class="title">Class MappedByteBuffer</h1> <div class="inheritance" title="Inheritance Tree">
<a href="../lang/object.html" title="class in java.lang">java.lang.Object</a> <div class="inheritance">
<a href="buffer.html" title="class in java.nio">java.nio.Buffer</a> <div class="inheritance">
<a href="bytebuffer.html" title="class in java.nio">java.nio.ByteBuffer</a> <div class="inheritance">java.nio.MappedByteBuffer</div> </div> </div> </div> <section class="class-description" id="class-description"> <dl class="notes"> <dt>All Implemented Interfaces:</dt> <dd><code><a href="../lang/comparable.html" title="interface in java.lang">Comparable</a>&lt;<a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a>&gt;</code></dd> </dl>  <pre class="lang-java" data-language="java">public abstract sealed class MappedByteBuffer extends ByteBuffer</pre> <div class="block">A direct byte buffer whose content is a memory-mapped region of a file. <p> Mapped byte buffers are created via the <a href="channels/filechannel.html#map(java.nio.channels.FileChannel.MapMode,long,long)"><code>FileChannel.map</code></a> method. This class extends the <a href="bytebuffer.html" title="class in java.nio"><code>ByteBuffer</code></a> class with operations that are specific to memory-mapped file regions. </p>
<p> A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected. </p>
<p> The content of a mapped byte buffer can change at any time, for example if the content of the corresponding region of the mapped file is changed by this program or another. Whether or not such changes occur, and when they occur, is operating-system dependent and therefore unspecified. </p>
<p> All or part of a mapped byte buffer may become inaccessible at any time, for example if the mapped file is truncated. An attempt to access an inaccessible region of a mapped byte buffer will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time. It is therefore strongly recommended that appropriate precautions be taken to avoid the manipulation of a mapped file by this program, or by a concurrently running program, except to read or write the file's content. </p>
<p> Mapped byte buffers otherwise behave no differently than ordinary direct byte buffers. </p>
</div> <dl class="notes"> <dt>Since:</dt> <dd>1.4</dd> </dl> </section> <section class="summary"> <section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                                                 <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code>final <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#clear()" class="member-name-link">clear</a>()</code></td>
<td> <div class="block">Clears this buffer.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#compact()" class="member-name-link">compact</a>()</code></td>
<td> <div class="block">Compacts this buffer <i>(optional operation)</i>.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#duplicate()" class="member-name-link">duplicate</a>()</code></td>
<td> <div class="block">Creates a new byte buffer that shares this buffer's content.</div> </td>
</tr>
<tr>
<td><code>final <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#flip()" class="member-name-link">flip</a>()</code></td>
<td> <div class="block">Flips this buffer.</div> </td>
</tr>
<tr>
<td><code>final <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#force()" class="member-name-link">force</a>()</code></td>
<td> <div class="block">Forces any changes made to this buffer's content to be written to the storage device containing the mapped file.</div> </td>
</tr>
<tr>
<td><code>final <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#force(int,int)" class="member-name-link">force</a><wbr>(int index,
 int length)</wbr></code></td>
<td> <div class="block">Forces any changes made to a region of this buffer's content to be written to the storage device containing the mapped file.</div> </td>
</tr>
<tr>
<td><code>final boolean</code></td>
<td><code><a href="#isLoaded()" class="member-name-link">isLoaded</a>()</code></td>
<td> <div class="block">Tells whether or not this buffer's content is resident in physical memory.</div> </td>
</tr>
<tr>
<td><code>final <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#limit(int)" class="member-name-link">limit</a><wbr>(int newLimit)</wbr></code></td>
<td> <div class="block">Sets this buffer's limit.</div> </td>
</tr>
<tr>
<td><code>final <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#load()" class="member-name-link">load</a>()</code></td>
<td> <div class="block">Loads this buffer's content into physical memory.</div> </td>
</tr>
<tr>
<td><code>final <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#mark()" class="member-name-link">mark</a>()</code></td>
<td> <div class="block">Sets this buffer's mark at its position.</div> </td>
</tr>
<tr>
<td><code>final <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#position(int)" class="member-name-link">position</a><wbr>(int newPosition)</wbr></code></td>
<td> <div class="block">Sets this buffer's position.</div> </td>
</tr>
<tr>
<td><code>final <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#reset()" class="member-name-link">reset</a>()</code></td>
<td> <div class="block">Resets this buffer's position to the previously-marked position.</div> </td>
</tr>
<tr>
<td><code>final <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#rewind()" class="member-name-link">rewind</a>()</code></td>
<td> <div class="block">Rewinds this buffer.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#slice()" class="member-name-link">slice</a>()</code></td>
<td> <div class="block">Creates a new byte buffer whose content is a shared subsequence of this buffer's content.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="mappedbytebuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td>
<td><code><a href="#slice(int,int)" class="member-name-link">slice</a><wbr>(int index,
 int length)</wbr></code></td>
<td> <div class="block">Creates a new byte buffer whose content is a shared subsequence of this buffer's content.</div> </td>
</tr>
</table> </div> </div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.nio.ByteBuffer">Methods declared in class java.nio.<a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a>
</h3> <code><a href="bytebuffer.html#alignedSlice(int)">alignedSlice</a>, <a href="bytebuffer.html#alignmentOffset(int,int)">alignmentOffset</a>, <a href="bytebuffer.html#allocate(int)">allocate</a>, <a href="bytebuffer.html#allocateDirect(int)">allocateDirect</a>, <a href="bytebuffer.html#array()">array</a>, <a href="bytebuffer.html#arrayOffset()">arrayOffset</a>, <a href="bytebuffer.html#asCharBuffer()">asCharBuffer</a>, <a href="bytebuffer.html#asDoubleBuffer()">asDoubleBuffer</a>, <a href="bytebuffer.html#asFloatBuffer()">asFloatBuffer</a>, <a href="bytebuffer.html#asIntBuffer()">asIntBuffer</a>, <a href="bytebuffer.html#asLongBuffer()">asLongBuffer</a>, <a href="bytebuffer.html#asReadOnlyBuffer()">asReadOnlyBuffer</a>, <a href="bytebuffer.html#asShortBuffer()">asShortBuffer</a>, <a href="bytebuffer.html#compareTo(java.nio.ByteBuffer)">compareTo</a>, <a href="bytebuffer.html#equals(java.lang.Object)">equals</a>, <a href="bytebuffer.html#get()">get</a>, <a href="bytebuffer.html#get(byte%5B%5D)">get</a>, <a href="bytebuffer.html#get(byte%5B%5D,int,int)">get</a>, <a href="bytebuffer.html#get(int)">get</a>, <a href="bytebuffer.html#get(int,byte%5B%5D)">get</a>, <a href="bytebuffer.html#get(int,byte%5B%5D,int,int)">get</a>, <a href="bytebuffer.html#getChar()">getChar</a>, <a href="bytebuffer.html#getChar(int)">getChar</a>, <a href="bytebuffer.html#getDouble()">getDouble</a>, <a href="bytebuffer.html#getDouble(int)">getDouble</a>, <a href="bytebuffer.html#getFloat()">getFloat</a>, <a href="bytebuffer.html#getFloat(int)">getFloat</a>, <a href="bytebuffer.html#getInt()">getInt</a>, <a href="bytebuffer.html#getInt(int)">getInt</a>, <a href="bytebuffer.html#getLong()">getLong</a>, <a href="bytebuffer.html#getLong(int)">getLong</a>, <a href="bytebuffer.html#getShort()">getShort</a>, <a href="bytebuffer.html#getShort(int)">getShort</a>, <a href="bytebuffer.html#hasArray()">hasArray</a>, <a href="bytebuffer.html#hashCode()">hashCode</a>, <a href="bytebuffer.html#isDirect()">isDirect</a>, <a href="bytebuffer.html#mismatch(java.nio.ByteBuffer)">mismatch</a>, <a href="bytebuffer.html#order()">order</a>, <a href="bytebuffer.html#order(java.nio.ByteOrder)">order</a>, <a href="bytebuffer.html#put(byte)">put</a>, <a href="bytebuffer.html#put(byte%5B%5D)">put</a>, <a href="bytebuffer.html#put(byte%5B%5D,int,int)">put</a>, <a href="bytebuffer.html#put(int,byte)">put</a>, <a href="bytebuffer.html#put(int,byte%5B%5D)">put</a>, <a href="bytebuffer.html#put(int,byte%5B%5D,int,int)">put</a>, <a href="bytebuffer.html#put(int,java.nio.ByteBuffer,int,int)">put</a>, <a href="bytebuffer.html#put(java.nio.ByteBuffer)">put</a>, <a href="bytebuffer.html#putChar(char)">putChar</a>, <a href="bytebuffer.html#putChar(int,char)">putChar</a>, <a href="bytebuffer.html#putDouble(double)">putDouble</a>, <a href="bytebuffer.html#putDouble(int,double)">putDouble</a>, <a href="bytebuffer.html#putFloat(float)">putFloat</a>, <a href="bytebuffer.html#putFloat(int,float)">putFloat</a>, <a href="bytebuffer.html#putInt(int)">putInt</a>, <a href="bytebuffer.html#putInt(int,int)">putInt</a>, <a href="bytebuffer.html#putLong(int,long)">putLong</a>, <a href="bytebuffer.html#putLong(long)">putLong</a>, <a href="bytebuffer.html#putShort(int,short)">putShort</a>, <a href="bytebuffer.html#putShort(short)">putShort</a>, <a href="bytebuffer.html#toString()">toString</a>, <a href="bytebuffer.html#wrap(byte%5B%5D)">wrap</a>, <a href="bytebuffer.html#wrap(byte%5B%5D,int,int)">wrap</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.nio.Buffer">Methods declared in class java.nio.<a href="buffer.html" title="class in java.nio">Buffer</a>
</h3> <code><a href="buffer.html#capacity()">capacity</a>, <a href="buffer.html#hasRemaining()">hasRemaining</a>, <a href="buffer.html#isReadOnly()">isReadOnly</a>, <a href="buffer.html#limit()">limit</a>, <a href="buffer.html#position()">position</a>, <a href="buffer.html#remaining()">remaining</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class java.lang.<a href="../lang/object.html" title="class in java.lang">Object</a>
</h3> <code><a href="../lang/object.html#clone()">clone</a>, <a href="../lang/object.html#finalize()">finalize</a>, <a href="../lang/object.html#getClass()">getClass</a>, <a href="../lang/object.html#notify()">notify</a>, <a href="../lang/object.html#notifyAll()">notifyAll</a>, <a href="../lang/object.html#wait()">wait</a>, <a href="../lang/object.html#wait(long)">wait</a>, <a href="../lang/object.html#wait(long,int)">wait</a></code>
</div> </section> </section> <section class="details"> <section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="isLoaded()"> <h3>isLoaded</h3> <pre class="lang-java" data-language="java">public final boolean isLoaded()</pre> <div class="block">Tells whether or not this buffer's content is resident in physical memory. <p> A return value of <code>true</code> implies that it is highly likely that all of the data in this buffer is resident in physical memory and may therefore be accessed without incurring any virtual-memory page faults or I/O operations. A return value of <code>false</code> does not necessarily imply that the buffer's content is not resident in physical memory. </p>
<p> The returned value is a hint, rather than a guarantee, because the underlying operating system may have paged out some of the buffer's data by the time that an invocation of this method returns. </p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if it is likely that this buffer's content is resident in physical memory</dd> </dl> </section><section class="detail" id="load()"> <h3>load</h3> <pre class="lang-java" data-language="java">public final MappedByteBuffer load()</pre> <div class="block">Loads this buffer's content into physical memory. <p> This method makes a best effort to ensure that, when it returns, this buffer's content is resident in physical memory. Invoking this method may cause some number of page faults and I/O operations to occur. </p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>This buffer</dd> </dl> </section><section class="detail" id="force()"> <h3>force</h3> <pre class="lang-java" data-language="java">public final MappedByteBuffer force()</pre> <div class="block">Forces any changes made to this buffer's content to be written to the storage device containing the mapped file. The region starts at index zero in this buffer and is <code>capacity()</code> bytes. An invocation of this method behaves in exactly the same way as the invocation <a href="#force(int,int)"><code>force(0,capacity())</code></a>. <p> If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device. </p>
<p> If the file does not reside on a local device then no such guarantee is made. </p>
<p> If this buffer was not mapped in read/write mode (<a href="channels/filechannel.mapmode.html#READ_WRITE"><code>FileChannel.MapMode.READ_WRITE</code></a>) then invoking this method may have no effect. In particular, the method has no effect for buffers mapped in read-only or private mapping modes. This method may or may not have an effect for implementation-specific mapping modes. </p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>This buffer</dd> <dt>Throws:</dt> <dd>
<code><a href="../io/uncheckedioexception.html" title="class in java.io">UncheckedIOException</a></code> - If an I/O error occurs writing the buffer's content to the storage device containing the mapped file</dd> </dl> </section><section class="detail" id="force(int,int)"> <h3>force</h3> <pre class="lang-java" data-language="java">public final MappedByteBuffer force(int index, int length)</pre> <div class="block">Forces any changes made to a region of this buffer's content to be written to the storage device containing the mapped file. The region starts at the given <code>index</code> in this buffer and is <code>length</code> bytes. <p> If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the selected region buffer since it was created, or since this method was last invoked, will have been written to that device. The force operation is free to write bytes that lie outside the specified region, for example to ensure that data blocks of some device-specific granularity are transferred in their entirety. </p>
<p> If the file does not reside on a local device then no such guarantee is made. </p>
<p> If this buffer was not mapped in read/write mode (<a href="channels/filechannel.mapmode.html#READ_WRITE"><code>FileChannel.MapMode.READ_WRITE</code></a>) then invoking this method may have no effect. In particular, the method has no effect for buffers mapped in read-only or private mapping modes. This method may or may not have an effect for implementation-specific mapping modes. </p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>index</code> - The index of the first byte in the buffer region that is to be written back to storage; must be non-negative and less than <code>capacity()</code>
</dd> <dd>
<code>length</code> - The length of the region in bytes; must be non-negative and no larger than <code>capacity() - index</code>
</dd> <dt>Returns:</dt> <dd>This buffer</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if the preconditions on the index and length do not hold.</dd> <dd>
<code><a href="../io/uncheckedioexception.html" title="class in java.io">UncheckedIOException</a></code> - If an I/O error occurs writing the buffer's content to the storage device containing the mapped file</dd> <dt>Since:</dt> <dd>13</dd> </dl> </section><section class="detail" id="position(int)"> <h3>position</h3> <pre class="lang-java" data-language="java">public final MappedByteBuffer position(int newPosition)</pre> <div class="block">Sets this buffer's position. If the mark is defined and larger than the new position then it is discarded.</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="bytebuffer.html#position(int)">position</a></code> in class <code><a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>newPosition</code> - The new position value; must be non-negative and no larger than the current limit</dd> <dt>Returns:</dt> <dd>This buffer</dd> <dt>Since:</dt> <dd>9</dd> </dl> </section><section class="detail" id="limit(int)"> <h3>limit</h3> <pre class="lang-java" data-language="java">public final MappedByteBuffer limit(int newLimit)</pre> <div class="block">Sets this buffer's limit. If the position is larger than the new limit then it is set to the new limit. If the mark is defined and larger than the new limit then it is discarded.</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="bytebuffer.html#limit(int)">limit</a></code> in class <code><a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>newLimit</code> - The new limit value; must be non-negative and no larger than this buffer's capacity</dd> <dt>Returns:</dt> <dd>This buffer</dd> <dt>Since:</dt> <dd>9</dd> </dl> </section><section class="detail" id="mark()"> <h3>mark</h3> <pre class="lang-java" data-language="java">public final MappedByteBuffer mark()</pre> <div class="block">Sets this buffer's mark at its position.</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="bytebuffer.html#mark()">mark</a></code> in class <code><a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a></code>
</dd> <dt>Returns:</dt> <dd>This buffer</dd> <dt>Since:</dt> <dd>9</dd> </dl> </section><section class="detail" id="reset()"> <h3>reset</h3> <pre class="lang-java" data-language="java">public final MappedByteBuffer reset()</pre> <div class="block">Resets this buffer's position to the previously-marked position. <p> Invoking this method neither changes nor discards the mark's value. </p>
</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="bytebuffer.html#reset()">reset</a></code> in class <code><a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a></code>
</dd> <dt>Returns:</dt> <dd>This buffer</dd> <dt>Since:</dt> <dd>9</dd> </dl> </section><section class="detail" id="clear()"> <h3>clear</h3> <pre class="lang-java" data-language="java">public final MappedByteBuffer clear()</pre> <div class="block">Clears this buffer. The position is set to zero, the limit is set to the capacity, and the mark is discarded. <p> Invoke this method before using a sequence of channel-read or <i>put</i> operations to fill this buffer. For example: </p>
<div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java">    buf.clear();     // Prepare buffer for reading
    in.read(buf);    // Read data
</code></pre> </div> <p> This method does not actually erase the data in the buffer, but it is named as if it did because it will most often be used in situations in which that might as well be the case. </p>
</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="bytebuffer.html#clear()">clear</a></code> in class <code><a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a></code>
</dd> <dt>Returns:</dt> <dd>This buffer</dd> <dt>Since:</dt> <dd>9</dd> </dl> </section><section class="detail" id="flip()"> <h3>flip</h3> <pre class="lang-java" data-language="java">public final MappedByteBuffer flip()</pre> <div class="block">Flips this buffer. The limit is set to the current position and then the position is set to zero. If the mark is defined then it is discarded. <p> After a sequence of channel-read or <i>put</i> operations, invoke this method to prepare for a sequence of channel-write or relative <i>get</i> operations. For example: </p>
<div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java">    buf.put(magic);    // Prepend header
    in.read(buf);      // Read data into rest of buffer
    buf.flip();        // Flip buffer
    out.write(buf);    // Write header + data to channel
</code></pre> </div> <p> This method is often used in conjunction with the <a href="bytebuffer.html#compact()"><code>compact</code></a> method when transferring data from one place to another. </p>
</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="bytebuffer.html#flip()">flip</a></code> in class <code><a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a></code>
</dd> <dt>Returns:</dt> <dd>This buffer</dd> <dt>Since:</dt> <dd>9</dd> </dl> </section><section class="detail" id="rewind()"> <h3>rewind</h3> <pre class="lang-java" data-language="java">public final MappedByteBuffer rewind()</pre> <div class="block">Rewinds this buffer. The position is set to zero and the mark is discarded. <p> Invoke this method before a sequence of channel-write or <i>get</i> operations, assuming that the limit has already been set appropriately. For example: </p>
<div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java">    out.write(buf);    // Write remaining data
    buf.rewind();      // Rewind buffer
    buf.get(array);    // Copy data into array
</code></pre> </div> </div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="bytebuffer.html#rewind()">rewind</a></code> in class <code><a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a></code>
</dd> <dt>Returns:</dt> <dd>This buffer</dd> <dt>Since:</dt> <dd>9</dd> </dl> </section><section class="detail" id="slice()"> <h3>slice</h3> <pre class="lang-java" data-language="java">public abstract MappedByteBuffer slice()</pre> <div class="block">Creates a new byte buffer whose content is a shared subsequence of this buffer's content. <p> The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. </p>
<p> The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, its mark will be undefined, and its byte order will be <a href="byteorder.html#BIG_ENDIAN"><code>BIG_ENDIAN</code></a>. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only. </p> <p> Reading bytes into physical memory by invoking <code>load()</code> on the returned buffer, or writing bytes to the storage device by invoking <code>force()</code> on the returned buffer, will only act on the sub-range of this buffer that the returned buffer represents, namely <code>[position(),limit())</code>.</p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="bytebuffer.html#slice()">slice</a></code> in class <code><a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a></code>
</dd> <dt>Returns:</dt> <dd>The new byte buffer</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="bytebuffer.html#alignedSlice(int)"><code>ByteBuffer.alignedSlice(int)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="slice(int,int)"> <h3>slice</h3> <pre class="lang-java" data-language="java">public abstract MappedByteBuffer slice(int index, int length)</pre> <div class="block">Creates a new byte buffer whose content is a shared subsequence of this buffer's content. <p> The content of the new buffer will start at position <code>index</code> in this buffer, and will contain <code>length</code> elements. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. </p>
<p> The new buffer's position will be zero, its capacity and its limit will be <code>length</code>, its mark will be undefined, and its byte order will be <a href="byteorder.html#BIG_ENDIAN"><code>BIG_ENDIAN</code></a>. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only. </p> <p> Reading bytes into physical memory by invoking <code>load()</code> on the returned buffer, or writing bytes to the storage device by invoking <code>force()</code> on the returned buffer, will only act on the sub-range of this buffer that the returned buffer represents, namely <code>[index,index+length)</code>, where <code>index</code> and <code>length</code> are assumed to satisfy the preconditions.</p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="bytebuffer.html#slice(int,int)">slice</a></code> in class <code><a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>index</code> - The position in this buffer at which the content of the new buffer will start; must be non-negative and no larger than <a href="buffer.html#limit()"><code>limit()</code></a>
</dd> <dd>
<code>length</code> - The number of elements the new buffer will contain; must be non-negative and no larger than <code>limit() - index</code>
</dd> <dt>Returns:</dt> <dd>The new buffer</dd> </dl> </section><section class="detail" id="duplicate()"> <h3>duplicate</h3> <pre class="lang-java" data-language="java">public abstract MappedByteBuffer duplicate()</pre> <div class="block">Creates a new byte buffer that shares this buffer's content. <p> The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent. </p>
<p> The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer, and its byte order will be <a href="byteorder.html#BIG_ENDIAN"><code>BIG_ENDIAN</code></a>. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only. </p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="bytebuffer.html#duplicate()">duplicate</a></code> in class <code><a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a></code>
</dd> <dt>Returns:</dt> <dd>The new byte buffer</dd> </dl> </section><section class="detail" id="compact()"> <h3>compact</h3> <pre class="lang-java" data-language="java">public abstract MappedByteBuffer compact()</pre> <div class="block">Compacts this buffer <i>(optional operation)</i>. <p> The bytes between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index <i>p</i> = <code>position()</code> is copied to index zero, the byte at index <i>p</i> + 1 is copied to index one, and so forth until the byte at index <code>limit()</code> - 1 is copied to index <i>n</i> = <code>limit()</code> - <code>1</code> - <i>p</i>. The buffer's position is then set to <i>n+1</i> and its limit is set to its capacity. The mark, if defined, is discarded. </p>
<p> The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative <i>put</i> method. </p> <p> Invoke this method after writing data from a buffer in case the write was incomplete. The following loop, for example, copies bytes from one channel to another via the buffer <code>buf</code>: </p>
<div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java">    buf.clear();          // Prepare buffer for use
    while (in.read(buf) &gt;= 0 || buf.position != 0) {
        buf.flip();
        out.write(buf);
        buf.compact();    // In case of partial write
    }
</code></pre> </div> </div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="bytebuffer.html#compact()">compact</a></code> in class <code><a href="bytebuffer.html" title="class in java.nio">ByteBuffer</a></code>
</dd> <dt>Returns:</dt> <dd>This buffer</dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2023, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/MappedByteBuffer.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/MappedByteBuffer.html</a>
  </p>
</div>
