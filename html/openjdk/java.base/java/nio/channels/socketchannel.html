<h1 title="Class SocketChannel" class="title">Class SocketChannel</h1> <div class="inheritance" title="Inheritance Tree">
<a href="../../lang/object.html" title="class in java.lang">java.lang.Object</a> <div class="inheritance">
<a href="spi/abstractinterruptiblechannel.html" title="class in java.nio.channels.spi">java.nio.channels.spi.AbstractInterruptibleChannel</a> <div class="inheritance">
<a href="selectablechannel.html" title="class in java.nio.channels">java.nio.channels.SelectableChannel</a> <div class="inheritance">
<a href="spi/abstractselectablechannel.html" title="class in java.nio.channels.spi">java.nio.channels.spi.AbstractSelectableChannel</a> <div class="inheritance">java.nio.channels.SocketChannel</div> </div> </div> </div> </div> <section class="class-description" id="class-description"> <dl class="notes"> <dt>All Implemented Interfaces:</dt> <dd>
<code><a href="../../io/closeable.html" title="interface in java.io">Closeable</a></code>, <code><a href="../../lang/autocloseable.html" title="interface in java.lang">AutoCloseable</a></code>, <code><a href="bytechannel.html" title="interface in java.nio.channels">ByteChannel</a></code>, <code><a href="channel.html" title="interface in java.nio.channels">Channel</a></code>, <code><a href="gatheringbytechannel.html" title="interface in java.nio.channels">GatheringByteChannel</a></code>, <code><a href="interruptiblechannel.html" title="interface in java.nio.channels">InterruptibleChannel</a></code>, <code><a href="networkchannel.html" title="interface in java.nio.channels">NetworkChannel</a></code>, <code><a href="readablebytechannel.html" title="interface in java.nio.channels">ReadableByteChannel</a></code>, <code><a href="scatteringbytechannel.html" title="interface in java.nio.channels">ScatteringByteChannel</a></code>, <code><a href="writablebytechannel.html" title="interface in java.nio.channels">WritableByteChannel</a></code>
</dd> </dl>  <pre class="lang-java" data-language="java">public abstract class SocketChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel</pre> <div class="block">A selectable channel for stream-oriented connecting sockets. <p> A socket channel is created by invoking one of the <code>open</code> methods of this class. The no-arg <a href="#open()"><code>open</code></a> method opens a socket channel for an <i>Internet protocol</i> socket. The <a href="#open(java.net.ProtocolFamily)"><code>open(ProtocolFamily)</code></a> method is used to open a socket channel for a socket of a specified protocol family. It is not possible to create a channel for an arbitrary, pre-existing socket. A newly-created socket channel is open but not yet connected. An attempt to invoke an I/O operation upon an unconnected channel will cause a <a href="notyetconnectedexception.html" title="class in java.nio.channels"><code>NotYetConnectedException</code></a> to be thrown. A socket channel can be connected by invoking its <a href="#connect(java.net.SocketAddress)"><code>connect</code></a> method; once connected, a socket channel remains connected until it is closed. Whether or not a socket channel is connected may be determined by invoking its <a href="#isConnected()"><code>isConnected</code></a> method. </p>
<p> Socket channels support <i>non-blocking connection:</i> A socket channel may be created and the process of establishing the link to the remote socket may be initiated via the <a href="#connect(java.net.SocketAddress)"><code>connect</code></a> method for later completion by the <a href="#finishConnect()"><code>finishConnect</code></a> method. Whether or not a connection operation is in progress may be determined by invoking the <a href="#isConnectionPending()"><code>isConnectionPending</code></a> method. </p>
<p> Socket channels support <i>asynchronous shutdown</i>, which is similar to the asynchronous close operation specified in the <a href="channel.html" title="interface in java.nio.channels"><code>Channel</code></a> class. If the input side of a socket is shut down by one thread while another thread is blocked in a read operation on the socket's channel, then the read operation in the blocked thread will complete without reading any bytes and will return <code>-1</code>. If the output side of a socket is shut down by one thread while another thread is blocked in a write operation on the socket's channel, then the blocked thread will receive an <a href="asynchronouscloseexception.html" title="class in java.nio.channels"><code>AsynchronousCloseException</code></a>. </p>
<p> Socket options are configured using the <a href="#setOption(java.net.SocketOption,T)"><code>setOption</code></a> method. Socket channels for <i>Internet protocol</i> sockets support following options: </p>
<blockquote> <table class="striped"> <caption style="display:none">Socket options</caption> <thead> <tr> <th scope="col">Option Name</th> <th scope="col">Description</th> </tr> </thead> <tbody> <tr> <th scope="row"> <a href="../../net/standardsocketoptions.html#SO_SNDBUF"><code>SO_SNDBUF</code></a> </th> <td> The size of the socket send buffer </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions.html#SO_RCVBUF"><code>SO_RCVBUF</code></a> </th> <td> The size of the socket receive buffer </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions.html#SO_KEEPALIVE"><code>SO_KEEPALIVE</code></a> </th> <td> Keep connection alive </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions.html#SO_REUSEADDR"><code>SO_REUSEADDR</code></a> </th> <td> Re-use address </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions.html#SO_LINGER"><code>SO_LINGER</code></a> </th> <td> Linger on close if data is present (when configured in blocking mode only) </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions.html#TCP_NODELAY"><code>TCP_NODELAY</code></a> </th> <td> Disable the Nagle algorithm </td> </tr> </tbody> </table> </blockquote> <p> Socket channels for <i>Unix domain</i> sockets support: </p>
<blockquote> <table class="striped"> <caption style="display:none">Socket options</caption> <thead> <tr> <th scope="col">Option Name</th> <th scope="col">Description</th> </tr> </thead> <tbody> <tr> <th scope="row"> <a href="../../net/standardsocketoptions.html#SO_SNDBUF"><code>SO_SNDBUF</code></a> </th> <td> The size of the socket send buffer </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions.html#SO_RCVBUF"><code>SO_RCVBUF</code></a> </th> <td> The size of the socket receive buffer </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions.html#SO_LINGER"><code>SO_LINGER</code></a> </th> <td> Linger on close if data is present (when configured in blocking mode only) </td> </tr> </tbody> </table> </blockquote> <p> Additional (implementation specific) options may also be supported. </p>
<p> Socket channels are safe for use by multiple concurrent threads. They support concurrent reading and writing, though at most one thread may be reading and at most one thread may be writing at any given time. The <a href="#connect(java.net.SocketAddress)"><code>connect</code></a> and <a href="#finishConnect()"><code>finishConnect</code></a> methods are mutually synchronized against each other, and an attempt to initiate a read or write operation while an invocation of one of these methods is in progress will block until that invocation is complete. </p>
</div> <dl class="notes"> <dt>Since:</dt> <dd>1.4</dd> </dl> </section> <section class="summary"> <section class="constructor-summary" id="constructor-summary"> <h2>Constructor Summary</h2>  <table class="summary-table three-column-summary">     <div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E(java.nio.channels.spi.SelectorProvider)" class="member-name-link">SocketChannel</a><wbr>(<a href="spi/selectorprovider.html" title="class in java.nio.channels.spi">SelectorProvider</a> provider)</wbr></code></div>  <tr>
<th>Modifier</th>
<th>Constructor</th>
<th>Description</th>
</tr>
<tr>
<td><code>protected </code></td>
<td> <div class="block">Initializes a new instance of this class.</div> </td>
</tr>
</table> </section><section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                                                                   <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code>abstract <a href="socketchannel.html" title="class in java.nio.channels">SocketChannel</a></code></td>
<td><code><a href="#bind(java.net.SocketAddress)" class="member-name-link">bind</a><wbr>(<a href="../../net/socketaddress.html" title="class in java.net">SocketAddress</a> local)</wbr></code></td>
<td> <div class="block">Binds the channel's socket to a local address.</div> </td>
</tr>
<tr>
<td><code>abstract boolean</code></td>
<td><code><a href="#connect(java.net.SocketAddress)" class="member-name-link">connect</a><wbr>(<a href="../../net/socketaddress.html" title="class in java.net">SocketAddress</a> remote)</wbr></code></td>
<td> <div class="block">Connects this channel's socket.</div> </td>
</tr>
<tr>
<td><code>abstract boolean</code></td>
<td><code><a href="#finishConnect()" class="member-name-link">finishConnect</a>()</code></td>
<td> <div class="block">Finishes the process of connecting a socket channel.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="../../net/socketaddress.html" title="class in java.net">SocketAddress</a></code></td>
<td><code><a href="#getLocalAddress()" class="member-name-link">getLocalAddress</a>()</code></td>
<td> <div class="block">Returns the socket address that this channel's socket is bound to.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="../../net/socketaddress.html" title="class in java.net">SocketAddress</a></code></td>
<td><code><a href="#getRemoteAddress()" class="member-name-link">getRemoteAddress</a>()</code></td>
<td> <div class="block">Returns the remote address to which this channel's socket is connected.</div> </td>
</tr>
<tr>
<td><code>abstract boolean</code></td>
<td><code><a href="#isConnected()" class="member-name-link">isConnected</a>()</code></td>
<td> <div class="block">Tells whether or not this channel's network socket is connected.</div> </td>
</tr>
<tr>
<td><code>abstract boolean</code></td>
<td><code><a href="#isConnectionPending()" class="member-name-link">isConnectionPending</a>()</code></td>
<td> <div class="block">Tells whether or not a connection operation is in progress on this channel.</div> </td>
</tr>
<tr>
<td><code>static <a href="socketchannel.html" title="class in java.nio.channels">SocketChannel</a></code></td>
<td><code><a href="#open()" class="member-name-link">open</a>()</code></td>
<td> <div class="block">Opens a socket channel for an <i>Internet protocol</i> socket.</div> </td>
</tr>
<tr>
<td><code>static <a href="socketchannel.html" title="class in java.nio.channels">SocketChannel</a></code></td>
<td><code><a href="#open(java.net.ProtocolFamily)" class="member-name-link">open</a><wbr>(<a href="../../net/protocolfamily.html" title="interface in java.net">ProtocolFamily</a> family)</wbr></code></td>
<td> <div class="block">Opens a socket channel.</div> </td>
</tr>
<tr>
<td><code>static <a href="socketchannel.html" title="class in java.nio.channels">SocketChannel</a></code></td>
<td><code><a href="#open(java.net.SocketAddress)" class="member-name-link">open</a><wbr>(<a href="../../net/socketaddress.html" title="class in java.net">SocketAddress</a> remote)</wbr></code></td>
<td> <div class="block">Opens a socket channel and connects it to a remote address.</div> </td>
</tr>
<tr>
<td><code>abstract int</code></td>
<td><code><a href="#read(java.nio.ByteBuffer)" class="member-name-link">read</a><wbr>(<a href="../bytebuffer.html" title="class in java.nio">ByteBuffer</a> dst)</wbr></code></td>
<td> <div class="block">Reads a sequence of bytes from this channel into the given buffer.</div> </td>
</tr>
<tr>
<td><code>final long</code></td>
<td><code><a href="#read(java.nio.ByteBuffer%5B%5D)" class="member-name-link">read</a><wbr>(<a href="../bytebuffer.html" title="class in java.nio">ByteBuffer</a>[] dsts)</wbr></code></td>
<td> <div class="block">Reads a sequence of bytes from this channel into the given buffers.</div> </td>
</tr>
<tr>
<td><code>abstract long</code></td>
<td><code><a href="#read(java.nio.ByteBuffer%5B%5D,int,int)" class="member-name-link">read</a><wbr>(<a href="../bytebuffer.html" title="class in java.nio">ByteBuffer</a>[] dsts,
 int offset,
 int length)</wbr></code></td>
<td> <div class="block">Reads a sequence of bytes from this channel into a subsequence of the given buffers.</div> </td>
</tr>
<tr>
<td><code>abstract &lt;T&gt; <a href="socketchannel.html" title="class in java.nio.channels">SocketChannel</a></code></td>
<td><code><a href="#setOption(java.net.SocketOption,T)" class="member-name-link">setOption</a><wbr>(<a href="../../net/socketoption.html" title="interface in java.net">SocketOption</a>&lt;T&gt; name,
 T value)</wbr></code></td>
<td> <div class="block">Sets the value of a socket option.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="socketchannel.html" title="class in java.nio.channels">SocketChannel</a></code></td>
<td><code><a href="#shutdownInput()" class="member-name-link">shutdownInput</a>()</code></td>
<td> <div class="block">Shutdown the connection for reading without closing the channel.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="socketchannel.html" title="class in java.nio.channels">SocketChannel</a></code></td>
<td><code><a href="#shutdownOutput()" class="member-name-link">shutdownOutput</a>()</code></td>
<td> <div class="block">Shutdown the connection for writing without closing the channel.</div> </td>
</tr>
<tr>
<td><code>abstract <a href="../../net/socket.html" title="class in java.net">Socket</a></code></td>
<td><code><a href="#socket()" class="member-name-link">socket</a>()</code></td>
<td> <div class="block">Retrieves a socket associated with this channel.</div> </td>
</tr>
<tr>
<td><code>final int</code></td>
<td><code><a href="#validOps()" class="member-name-link">validOps</a>()</code></td>
<td> <div class="block">Returns an operation set identifying this channel's supported operations.</div> </td>
</tr>
<tr>
<td><code>abstract int</code></td>
<td><code><a href="#write(java.nio.ByteBuffer)" class="member-name-link">write</a><wbr>(<a href="../bytebuffer.html" title="class in java.nio">ByteBuffer</a> src)</wbr></code></td>
<td> <div class="block">Writes a sequence of bytes to this channel from the given buffer.</div> </td>
</tr>
<tr>
<td><code>final long</code></td>
<td><code><a href="#write(java.nio.ByteBuffer%5B%5D)" class="member-name-link">write</a><wbr>(<a href="../bytebuffer.html" title="class in java.nio">ByteBuffer</a>[] srcs)</wbr></code></td>
<td> <div class="block">Writes a sequence of bytes to this channel from the given buffers.</div> </td>
</tr>
<tr>
<td><code>abstract long</code></td>
<td><code><a href="#write(java.nio.ByteBuffer%5B%5D,int,int)" class="member-name-link">write</a><wbr>(<a href="../bytebuffer.html" title="class in java.nio">ByteBuffer</a>[] srcs,
 int offset,
 int length)</wbr></code></td>
<td> <div class="block">Writes a sequence of bytes to this channel from a subsequence of the given buffers.</div> </td>
</tr>
</table> </div> </div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.nio.channels.spi.AbstractSelectableChannel">Methods declared in class java.nio.channels.spi.<a href="spi/abstractselectablechannel.html" title="class in java.nio.channels.spi">AbstractSelectableChannel</a>
</h3> <code><a href="spi/abstractselectablechannel.html#blockingLock()">blockingLock</a>, <a href="spi/abstractselectablechannel.html#configureBlocking(boolean)">configureBlocking</a>, <a href="spi/abstractselectablechannel.html#implCloseChannel()">implCloseChannel</a>, <a href="spi/abstractselectablechannel.html#implCloseSelectableChannel()">implCloseSelectableChannel</a>, <a href="spi/abstractselectablechannel.html#implConfigureBlocking(boolean)">implConfigureBlocking</a>, <a href="spi/abstractselectablechannel.html#isBlocking()">isBlocking</a>, <a href="spi/abstractselectablechannel.html#isRegistered()">isRegistered</a>, <a href="spi/abstractselectablechannel.html#keyFor(java.nio.channels.Selector)">keyFor</a>, <a href="spi/abstractselectablechannel.html#provider()">provider</a>, <a href="spi/abstractselectablechannel.html#register(java.nio.channels.Selector,int,java.lang.Object)">register</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.nio.channels.SelectableChannel">Methods declared in class java.nio.channels.<a href="selectablechannel.html" title="class in java.nio.channels">SelectableChannel</a>
</h3> <code><a href="selectablechannel.html#register(java.nio.channels.Selector,int)">register</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.nio.channels.spi.AbstractInterruptibleChannel">Methods declared in class java.nio.channels.spi.<a href="spi/abstractinterruptiblechannel.html" title="class in java.nio.channels.spi">AbstractInterruptibleChannel</a>
</h3> <code><a href="spi/abstractinterruptiblechannel.html#begin()">begin</a>, <a href="spi/abstractinterruptiblechannel.html#close()">close</a>, <a href="spi/abstractinterruptiblechannel.html#end(boolean)">end</a>, <a href="spi/abstractinterruptiblechannel.html#isOpen()">isOpen</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class java.lang.<a href="../../lang/object.html" title="class in java.lang">Object</a>
</h3> <code><a href="../../lang/object.html#clone()">clone</a>, <a href="../../lang/object.html#equals(java.lang.Object)">equals</a>, <a href="../../lang/object.html#finalize()">finalize</a>, <a href="../../lang/object.html#getClass()">getClass</a>, <a href="../../lang/object.html#hashCode()">hashCode</a>, <a href="../../lang/object.html#notify()">notify</a>, <a href="../../lang/object.html#notifyAll()">notifyAll</a>, <a href="../../lang/object.html#toString()">toString</a>, <a href="../../lang/object.html#wait()">wait</a>, <a href="../../lang/object.html#wait(long)">wait</a>, <a href="../../lang/object.html#wait(long,int)">wait</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.nio.channels.Channel">Methods declared in interface java.nio.channels.<a href="channel.html" title="interface in java.nio.channels">Channel</a>
</h3> <code><a href="channel.html#isOpen()">isOpen</a></code>
</div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.nio.channels.NetworkChannel">Methods declared in interface java.nio.channels.<a href="networkchannel.html" title="interface in java.nio.channels">NetworkChannel</a>
</h3> <code><a href="networkchannel.html#getOption(java.net.SocketOption)">getOption</a>, <a href="networkchannel.html#supportedOptions()">supportedOptions</a></code>
</div> </section> </section> <section class="details"> <section class="constructor-details" id="constructor-detail"> <h2>Constructor Details</h2>  </section><section class="detail" id="&lt;init&gt;(java.nio.channels.spi.SelectorProvider)"> <h3>SocketChannel</h3> <pre class="lang-java" data-language="java">protected SocketChannel(SelectorProvider provider)</pre> <div class="block">Initializes a new instance of this class.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>provider</code> - The provider that created this channel</dd> </dl> </section><section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="open()"> <h3>open</h3> <pre class="lang-java" data-language="java">public static SocketChannel open() throws IOException</pre> <div class="block">Opens a socket channel for an <i>Internet protocol</i> socket. <p> The new channel is created by invoking the <a href="spi/selectorprovider.html#openSocketChannel()"><code>openSocketChannel</code></a> method of the system-wide default <a href="spi/selectorprovider.html" title="class in java.nio.channels.spi"><code>SelectorProvider</code></a> object. </p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>A new socket channel</dd> <dt>Throws:</dt> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If an I/O error occurs</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li>
<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/net/doc-files/net-properties.html#Ipv4IPv6"> java.net.preferIPv4Stack</a> system property</li> </ul> </dd> </dl> </section><section class="detail" id="open(java.net.ProtocolFamily)"> <h3>open</h3> <pre class="lang-java" data-language="java">public static SocketChannel open(ProtocolFamily family) throws IOException</pre> <div class="block">Opens a socket channel. The <code>family</code> parameter specifies the <a href="../../net/protocolfamily.html" title="interface in java.net"><code>protocol family</code></a> of the channel's socket. <p> The new channel is created by invoking the <a href="spi/selectorprovider.html#openSocketChannel(java.net.ProtocolFamily)"><code>openSocketChannel(ProtocolFamily)</code></a> method of the system-wide default. <a href="spi/selectorprovider.html" title="class in java.nio.channels.spi"><code>SelectorProvider</code></a> object.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>family</code> - The protocol family</dd> <dt>Returns:</dt> <dd>A new socket channel</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/unsupportedoperationexception.html" title="class in java.lang">UnsupportedOperationException</a></code> - If the specified protocol family is not supported. For example, suppose the parameter is specified as <a href="../../net/standardprotocolfamily.html#INET6"><code>StandardProtocolFamily.INET6</code></a> but IPv6 is not enabled on the platform.</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If an I/O error occurs</dd> <dt>Since:</dt> <dd>15</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li>
<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/net/doc-files/net-properties.html#Ipv4IPv6"> java.net.preferIPv4Stack</a> system property</li> </ul> </dd> </dl> </section><section class="detail" id="open(java.net.SocketAddress)"> <h3>open</h3> <pre class="lang-java" data-language="java">public static SocketChannel open(SocketAddress remote) throws IOException</pre> <div class="block">Opens a socket channel and connects it to a remote address. <p> If the remote address is an <a href="../../net/inetsocketaddress.html" title="class in java.net"><code>InetSocketAddress</code></a> then this method works as if by invoking the <a href="#open()"><code>open()</code></a> method, invoking the <a href="#connect(java.net.SocketAddress)"><code>connect</code></a> method upon the resulting socket channel, passing it <code>remote</code>, and then returning that channel. </p>
<p> If the remote address is a <a href="../../net/unixdomainsocketaddress.html" title="class in java.net"><code>UnixDomainSocketAddress</code></a> then this works by invoking the <a href="#open(java.net.ProtocolFamily)"><code>open(ProtocolFamily)</code></a> method with <a href="../../net/standardprotocolfamily.html#UNIX"><code>StandardProtocolFamily.UNIX</code></a> as parameter, invoking the <a href="#connect(java.net.SocketAddress)"><code>connect</code></a> method upon the resulting socket channel, passing it <code>remote</code>, then returning that channel. </p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>remote</code> - The remote address to which the new channel is to be connected</dd> <dt>Returns:</dt> <dd>A new, and connected, socket channel</dd> <dt>Throws:</dt> <dd>
<code><a href="asynchronouscloseexception.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - If another thread closes this channel while the connect operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the connect operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="unresolvedaddressexception.html" title="class in java.nio.channels">UnresolvedAddressException</a></code> - If the given remote address is an InetSocketAddress that is not fully resolved</dd> <dd>
<code><a href="unsupportedaddresstypeexception.html" title="class in java.nio.channels">UnsupportedAddressTypeException</a></code> - If the type of the given remote address is not supported</dd> <dd>
<code><a href="../../lang/securityexception.html" title="class in java.lang">SecurityException</a></code> - If a security manager has been installed and it does not permit access to the given remote endpoint</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li>
<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/net/doc-files/net-properties.html#Ipv4IPv6"> java.net.preferIPv4Stack</a> system property</li> </ul> </dd> </dl> </section><section class="detail" id="validOps()"> <h3>validOps</h3> <pre class="lang-java" data-language="java">public final int validOps()</pre> <div class="block">Returns an operation set identifying this channel's supported operations. <p> Socket channels support connecting, reading, and writing, so this method returns <code>(</code><a href="selectionkey.html#OP_CONNECT"><code>SelectionKey.OP_CONNECT</code></a> <code>|</code> <a href="selectionkey.html#OP_READ"><code>SelectionKey.OP_READ</code></a> <code>|</code> <a href="selectionkey.html#OP_WRITE"><code>SelectionKey.OP_WRITE</code></a><code>)</code>.</p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="selectablechannel.html#validOps()">validOps</a></code> in class <code><a href="selectablechannel.html" title="class in java.nio.channels">SelectableChannel</a></code>
</dd> <dt>Returns:</dt> <dd>The valid-operation set</dd> </dl> </section><section class="detail" id="bind(java.net.SocketAddress)"> <h3>bind</h3> <pre class="lang-java" data-language="java">public abstract SocketChannel bind(SocketAddress local) throws IOException</pre> <div class="block">Binds the channel's socket to a local address. <p> This method is used to establish an association between the socket and a local address. For <i>Internet Protocol</i> sockets, once an association is established then the socket remains bound until the channel is closed. If the <code>local</code> parameter has the value <code>
 null</code> then the socket will be bound to an address that is assigned automatically.</p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="networkchannel.html#bind(java.net.SocketAddress)">bind</a></code> in interface <code><a href="networkchannel.html" title="interface in java.nio.channels">NetworkChannel</a></code>
</dd> <dt>API Note:</dt> <dd>Binding a socket channel to a <i>Unix Domain</i> socket creates a file corresponding to the file path in the <a href="../../net/unixdomainsocketaddress.html" title="class in java.net"><code>UnixDomainSocketAddress</code></a>. This file persists after the channel is closed, and must be removed before another socket can bind to the same name. If a socket channel to a Unix Domain socket is <i>implicitly</i> bound by connecting it without calling bind first, then its socket is <a href="../../net/unixdomainsocketaddress.html#unnamed">unnamed</a> with no corresponding socket file in the file-system. If a socket channel to a Unix Domain socket is <i>automatically</i> bound by calling <code>
 bind(null)</code> this results in an unnamed socket also.</dd> <dt>Implementation Note:</dt> <dd>Each platform enforces an implementation specific maximum length for the name of a <i>Unix Domain</i> socket. This limitation is enforced when a channel is bound. The maximum length is typically close to and generally not less than 100 bytes.</dd> <dt>Parameters:</dt> <dd>
<code>local</code> - The address to bind the socket, or <code>null</code> to bind the socket to an automatically assigned socket address</dd> <dt>Returns:</dt> <dd>This channel</dd> <dt>Throws:</dt> <dd>
<code><a href="connectionpendingexception.html" title="class in java.nio.channels">ConnectionPendingException</a></code> - If a non-blocking connect operation is already in progress on this channel</dd> <dd>
<code><a href="alreadyboundexception.html" title="class in java.nio.channels">AlreadyBoundException</a></code> - If the socket is already bound</dd> <dd>
<code><a href="unsupportedaddresstypeexception.html" title="class in java.nio.channels">UnsupportedAddressTypeException</a></code> - If the type of the given address is not supported</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If the channel is closed</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> <dd>
<code><a href="../../lang/securityexception.html" title="class in java.lang">SecurityException</a></code> - If a security manager has been installed and its <a href="../../lang/securitymanager.html#checkListen(int)"><code>checkListen</code></a> method denies the operation for an <i>Internet protocol</i> socket address, or for a <i>Unix domain</i> socket address if it denies <a href="../../net/netpermission.html" title="class in java.net"><code>NetPermission</code></a><code>("accessUnixDomainSocket")</code>.</dd> <dt>Since:</dt> <dd>1.7</dd> <dt>See Also:</dt> <dd> <ul class="tag-list-long"> <li><a href="networkchannel.html#getLocalAddress()"><code>NetworkChannel.getLocalAddress()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="setOption(java.net.SocketOption,T)"> <h3 id="setOption(java.net.SocketOption,java.lang.Object)">setOption</h3> <pre class="lang-java" data-language="java">public abstract &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value) throws IOException</pre> <div class="block"><span class="description-from-type-label">Description copied from interface: <code><a href="networkchannel.html#setOption(java.net.SocketOption,T)">NetworkChannel</a></code></span></div> <div class="block">Sets the value of a socket option.</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="networkchannel.html#setOption(java.net.SocketOption,T)">setOption</a></code> in interface <code><a href="networkchannel.html" title="interface in java.nio.channels">NetworkChannel</a></code>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - The type of the socket option value</dd> <dt>Parameters:</dt> <dd>
<code>name</code> - The socket option</dd> <dd>
<code>value</code> - The value of the socket option. A value of <code>null</code> may be a valid value for some socket options.</dd> <dt>Returns:</dt> <dd>This channel</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/unsupportedoperationexception.html" title="class in java.lang">UnsupportedOperationException</a></code> - If the socket option is not supported by this channel</dd> <dd>
<code><a href="../../lang/illegalargumentexception.html" title="class in java.lang">IllegalArgumentException</a></code> - If the value is not a valid value for this socket option</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If an I/O error occurs</dd> <dt>Since:</dt> <dd>1.7</dd> <dt>See Also:</dt> <dd> <ul class="tag-list"> <li><a href="../../net/standardsocketoptions.html" title="class in java.net"><code>StandardSocketOptions</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="shutdownInput()"> <h3>shutdownInput</h3> <pre class="lang-java" data-language="java">public abstract SocketChannel shutdownInput() throws IOException</pre> <div class="block">Shutdown the connection for reading without closing the channel. <p> Once shutdown for reading then further reads on the channel will return <code>-1</code>, the end-of-stream indication. If the input side of the connection is already shutdown then invoking this method has no effect.</p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>The channel</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception.html" title="class in java.nio.channels">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> <dt>Since:</dt> <dd>1.7</dd> </dl> </section><section class="detail" id="shutdownOutput()"> <h3>shutdownOutput</h3> <pre class="lang-java" data-language="java">public abstract SocketChannel shutdownOutput() throws IOException</pre> <div class="block">Shutdown the connection for writing without closing the channel. <p> Once shutdown for writing then further attempts to write to the channel will throw <a href="closedchannelexception.html" title="class in java.nio.channels"><code>ClosedChannelException</code></a>. If the output side of the connection is already shutdown then invoking this method has no effect.</p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>The channel</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception.html" title="class in java.nio.channels">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> <dt>Since:</dt> <dd>1.7</dd> </dl> </section><section class="detail" id="socket()"> <h3>socket</h3> <pre class="lang-java" data-language="java">public abstract Socket socket()</pre> <div class="block">Retrieves a socket associated with this channel.</div> <dl class="notes"> <dt>Returns:</dt> <dd>A socket associated with this channel</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/unsupportedoperationexception.html" title="class in java.lang">UnsupportedOperationException</a></code> - If the channel's socket is not an <i>Internet protocol</i> socket</dd> </dl> </section><section class="detail" id="isConnected()"> <h3>isConnected</h3> <pre class="lang-java" data-language="java">public abstract boolean isConnected()</pre> <div class="block">Tells whether or not this channel's network socket is connected.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if, and only if, this channel's network socket is <a href="spi/abstractinterruptiblechannel.html#isOpen()"><code>open</code></a> and connected</dd> </dl> </section><section class="detail" id="isConnectionPending()"> <h3>isConnectionPending</h3> <pre class="lang-java" data-language="java">public abstract boolean isConnectionPending()</pre> <div class="block">Tells whether or not a connection operation is in progress on this channel.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if, and only if, a connection operation has been initiated on this channel but not yet completed by invoking the <a href="#finishConnect()"><code>finishConnect</code></a> method</dd> </dl> </section><section class="detail" id="connect(java.net.SocketAddress)"> <h3>connect</h3> <pre class="lang-java" data-language="java">public abstract boolean connect(SocketAddress remote) throws IOException</pre> <div class="block">Connects this channel's socket. <p> If this channel is in non-blocking mode then an invocation of this method initiates a non-blocking connection operation. If the connection is established immediately, as can happen with a local connection, then this method returns <code>true</code>. Otherwise this method returns <code>false</code> and the connection operation must later be completed by invoking the <a href="#finishConnect()"><code>finishConnect</code></a> method. </p>
<p> If this channel is in blocking mode then an invocation of this method will block until the connection is established or an I/O error occurs. </p>
<p> For channels to <i>Internet protocol</i> sockets, this method performs exactly the same security checks as the <a href="../../net/socket.html" title="class in java.net"><code>Socket</code></a> class. That is, if a security manager has been installed then this method verifies that its <a href="../../lang/securitymanager.html#checkConnect(java.lang.String,int)"><code>checkConnect</code></a> method permits connecting to the address and port number of the given remote endpoint. </p>
<p> For channels to <i>Unix Domain</i> sockets, this method checks <a href="../../net/netpermission.html" title="class in java.net"><code>NetPermission</code></a><code>
 ("accessUnixDomainSocket")</code> with the security manager's <a href="../../lang/securitymanager.html#checkPermission(java.security.Permission)"><code>checkPermission</code></a> method. </p>
<p> This method may be invoked at any time. If a read or write operation upon this channel is invoked while an invocation of this method is in progress then that operation will first block until this invocation is complete. If a connection attempt is initiated but fails, that is, if an invocation of this method throws a checked exception, then the channel will be closed. </p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>remote</code> - The remote address to which this channel is to be connected</dd> <dt>Returns:</dt> <dd>
<code>true</code> if a connection was established, <code>false</code> if this channel is in non-blocking mode and the connection operation is in progress</dd> <dt>Throws:</dt> <dd>
<code><a href="alreadyconnectedexception.html" title="class in java.nio.channels">AlreadyConnectedException</a></code> - If this channel is already connected</dd> <dd>
<code><a href="connectionpendingexception.html" title="class in java.nio.channels">ConnectionPendingException</a></code> - If a non-blocking connection operation is already in progress on this channel</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - If another thread closes this channel while the connect operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the connect operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="unresolvedaddressexception.html" title="class in java.nio.channels">UnresolvedAddressException</a></code> - If the given remote address is an InetSocketAddress that is not fully resolved</dd> <dd>
<code><a href="unsupportedaddresstypeexception.html" title="class in java.nio.channels">UnsupportedAddressTypeException</a></code> - If the type of the given remote address is not supported</dd> <dd>
<code><a href="../../lang/securityexception.html" title="class in java.lang">SecurityException</a></code> - If a security manager has been installed and it does not permit access to the given remote endpoint</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> </dl> </section><section class="detail" id="finishConnect()"> <h3>finishConnect</h3> <pre class="lang-java" data-language="java">public abstract boolean finishConnect() throws IOException</pre> <div class="block">Finishes the process of connecting a socket channel. <p> A non-blocking connection operation is initiated by placing a socket channel in non-blocking mode and then invoking its <a href="#connect(java.net.SocketAddress)"><code>connect</code></a> method. Once the connection is established, or the attempt has failed, the socket channel will become connectable and this method may be invoked to complete the connection sequence. If the connection operation failed then invoking this method will cause an appropriate <a href="../../io/ioexception.html" title="class in java.io"><code>IOException</code></a> to be thrown. </p>
<p> If this channel is already connected then this method will not block and will immediately return <code>true</code>. If this channel is in non-blocking mode then this method will return <code>false</code> if the connection process is not yet complete. If this channel is in blocking mode then this method will block until the connection either completes or fails, and will always either return <code>true</code> or throw a checked exception describing the failure. </p>
<p> This method may be invoked at any time. If a read or write operation upon this channel is invoked while an invocation of this method is in progress then that operation will first block until this invocation is complete. If a connection attempt fails, that is, if an invocation of this method throws a checked exception, then the channel will be closed. </p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if, and only if, this channel's socket is now connected</dd> <dt>Throws:</dt> <dd>
<code><a href="noconnectionpendingexception.html" title="class in java.nio.channels">NoConnectionPendingException</a></code> - If this channel is not connected and a connection operation has not been initiated</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - If another thread closes this channel while the connect operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the connect operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> </dl> </section><section class="detail" id="getRemoteAddress()"> <h3>getRemoteAddress</h3> <pre class="lang-java" data-language="java">public abstract SocketAddress getRemoteAddress() throws IOException</pre> <div class="block">Returns the remote address to which this channel's socket is connected. <p> Where the channel's socket is bound and connected to an <i>Internet Protocol</i> socket address then the return value is of type <a href="../../net/inetsocketaddress.html" title="class in java.net"><code>InetSocketAddress</code></a>. </p>
<p> Where the channel's socket is bound and connected to a <i>Unix Domain</i> socket address, the returned address is a <a href="../../net/unixdomainsocketaddress.html" title="class in java.net"><code>UnixDomainSocketAddress</code></a>.</p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>The remote address; <code>null</code> if the channel's socket is not connected</dd> <dt>Throws:</dt> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If the channel is closed</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If an I/O error occurs</dd> <dt>Since:</dt> <dd>1.7</dd> </dl> </section><section class="detail" id="read(java.nio.ByteBuffer)"> <h3>read</h3> <pre class="lang-java" data-language="java">public abstract int read(ByteBuffer dst) throws IOException</pre> <div class="block"><span class="description-from-type-label">Description copied from interface: <code><a href="readablebytechannel.html#read(java.nio.ByteBuffer)">ReadableByteChannel</a></code></span></div> <div class="block">Reads a sequence of bytes from this channel into the given buffer. <p> An attempt is made to read up to <i>r</i> bytes from the channel, where <i>r</i> is the number of bytes remaining in the buffer, that is, <code>dst.remaining()</code>, at the moment this method is invoked. </p>
<p> Suppose that a byte sequence of length <i>n</i> is read, where <code>0</code> <code>&lt;=</code> <i>n</i> <code>&lt;=</code> <i>r</i>. This byte sequence will be transferred into the buffer so that the first byte in the sequence is at index <i>p</i> and the last byte is at index <i>p</i> <code>+</code> <i>n</i> <code>-</code> <code>1</code>, where <i>p</i> is the buffer's position at the moment this method is invoked. Upon return the buffer's position will be equal to <i>p</i> <code>+</code> <i>n</i>; its limit will not have changed. </p>
<p> A read operation might not fill the buffer, and in fact it might not read any bytes at all. Whether or not it does so depends upon the nature and state of the channel. A socket channel in non-blocking mode, for example, cannot read any more bytes than are immediately available from the socket's input buffer; similarly, a file channel cannot read any more bytes than remain in the file. It is guaranteed, however, that if a channel is in blocking mode and there is at least one byte remaining in the buffer then this method will block until at least one byte is read. </p>
<p> This method may be invoked at any time. If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete. </p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="readablebytechannel.html#read(java.nio.ByteBuffer)">read</a></code> in interface <code><a href="readablebytechannel.html" title="interface in java.nio.channels">ReadableByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>dst</code> - The buffer into which bytes are to be transferred</dd> <dt>Returns:</dt> <dd>The number of bytes read, possibly zero, or <code>-1</code> if the channel has reached end-of-stream</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception.html" title="class in java.nio.channels">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - If another thread closes this channel while the read operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the read operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> </dl> </section><section class="detail" id="read(java.nio.ByteBuffer[],int,int)"> <h3>read</h3> <pre class="lang-java" data-language="java">public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException</pre> <div class="block"><span class="description-from-type-label">Description copied from interface: <code><a href="scatteringbytechannel.html#read(java.nio.ByteBuffer%5B%5D,int,int)">ScatteringByteChannel</a></code></span></div> <div class="block">Reads a sequence of bytes from this channel into a subsequence of the given buffers. <p> An invocation of this method attempts to read up to <i>r</i> bytes from this channel, where <i>r</i> is the total number of bytes remaining the specified subsequence of the given buffer array, that is, </p>
<div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java">    dsts[offset].remaining()
        + dsts[offset+1].remaining()
        + ... + dsts[offset+length-1].remaining()
</code></pre> </div> at the moment that this method is invoked. <p> Suppose that a byte sequence of length <i>n</i> is read, where <code>0</code> <code>&lt;=</code> <i>n</i> <code>&lt;=</code> <i>r</i>. Up to the first <code>dsts[offset].remaining()</code> bytes of this sequence are transferred into buffer <code>dsts[offset]</code>, up to the next <code>dsts[offset+1].remaining()</code> bytes are transferred into buffer <code>dsts[offset+1]</code>, and so forth, until the entire byte sequence is transferred into the given buffers. As many bytes as possible are transferred into each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer's limit. </p>
<p> This method may be invoked at any time. If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete. </p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="scatteringbytechannel.html#read(java.nio.ByteBuffer%5B%5D,int,int)">read</a></code> in interface <code><a href="scatteringbytechannel.html" title="interface in java.nio.channels">ScatteringByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>dsts</code> - The buffers into which bytes are to be transferred</dd> <dd>
<code>offset</code> - The offset within the buffer array of the first buffer into which bytes are to be transferred; must be non-negative and no larger than <code>dsts.length</code>
</dd> <dd>
<code>length</code> - The maximum number of buffers to be accessed; must be non-negative and no larger than <code>dsts.length</code> - <code>offset</code>
</dd> <dt>Returns:</dt> <dd>The number of bytes read, possibly zero, or <code>-1</code> if the channel has reached end-of-stream</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception.html" title="class in java.nio.channels">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - If another thread closes this channel while the read operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the read operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> </dl> </section><section class="detail" id="read(java.nio.ByteBuffer[])"> <h3>read</h3> <pre class="lang-java" data-language="java">public final long read(ByteBuffer[] dsts) throws IOException</pre> <div class="block"><span class="description-from-type-label">Description copied from interface: <code><a href="scatteringbytechannel.html#read(java.nio.ByteBuffer%5B%5D)">ScatteringByteChannel</a></code></span></div> <div class="block">Reads a sequence of bytes from this channel into the given buffers. <p> An invocation of this method of the form <code>c.read(dsts)</code> behaves in exactly the same manner as the invocation </p>
<div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java">    c.read(dsts, 0, dsts.length);
</code></pre> </div> </div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="scatteringbytechannel.html#read(java.nio.ByteBuffer%5B%5D)">read</a></code> in interface <code><a href="scatteringbytechannel.html" title="interface in java.nio.channels">ScatteringByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>dsts</code> - The buffers into which bytes are to be transferred</dd> <dt>Returns:</dt> <dd>The number of bytes read, possibly zero, or <code>-1</code> if the channel has reached end-of-stream</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception.html" title="class in java.nio.channels">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - If another thread closes this channel while the read operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the read operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> </dl> </section><section class="detail" id="write(java.nio.ByteBuffer)"> <h3>write</h3> <pre class="lang-java" data-language="java">public abstract int write(ByteBuffer src) throws IOException</pre> <div class="block"><span class="description-from-type-label">Description copied from interface: <code><a href="writablebytechannel.html#write(java.nio.ByteBuffer)">WritableByteChannel</a></code></span></div> <div class="block">Writes a sequence of bytes to this channel from the given buffer. <p> An attempt is made to write up to <i>r</i> bytes to the channel, where <i>r</i> is the number of bytes remaining in the buffer, that is, <code>src.remaining()</code>, at the moment this method is invoked. </p>
<p> Suppose that a byte sequence of length <i>n</i> is written, where <code>0</code> <code>&lt;=</code> <i>n</i> <code>&lt;=</code> <i>r</i>. This byte sequence will be transferred from the buffer starting at index <i>p</i>, where <i>p</i> is the buffer's position at the moment this method is invoked; the index of the last byte written will be <i>p</i> <code>+</code> <i>n</i> <code>-</code> <code>1</code>. Upon return the buffer's position will be equal to <i>p</i> <code>+</code> <i>n</i>; its limit will not have changed. </p>
<p> Unless otherwise specified, a write operation will return only after writing all of the <i>r</i> requested bytes. Some types of channels, depending upon their state, may write only some of the bytes or possibly none at all. A socket channel in non-blocking mode, for example, cannot write any more bytes than are free in the socket's output buffer. </p>
<p> This method may be invoked at any time. If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete. </p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="writablebytechannel.html#write(java.nio.ByteBuffer)">write</a></code> in interface <code><a href="writablebytechannel.html" title="interface in java.nio.channels">WritableByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>src</code> - The buffer from which bytes are to be retrieved</dd> <dt>Returns:</dt> <dd>The number of bytes written, possibly zero</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception.html" title="class in java.nio.channels">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - If another thread closes this channel while the write operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the write operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> </dl> </section><section class="detail" id="write(java.nio.ByteBuffer[],int,int)"> <h3>write</h3> <pre class="lang-java" data-language="java">public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException</pre> <div class="block"><span class="description-from-type-label">Description copied from interface: <code><a href="gatheringbytechannel.html#write(java.nio.ByteBuffer%5B%5D,int,int)">GatheringByteChannel</a></code></span></div> <div class="block">Writes a sequence of bytes to this channel from a subsequence of the given buffers. <p> An attempt is made to write up to <i>r</i> bytes to this channel, where <i>r</i> is the total number of bytes remaining in the specified subsequence of the given buffer array, that is, </p>
<div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java">    srcs[offset].remaining()
        + srcs[offset+1].remaining()
        + ... + srcs[offset+length-1].remaining()
</code></pre> </div> at the moment that this method is invoked. <p> Suppose that a byte sequence of length <i>n</i> is written, where <code>0</code> <code>&lt;=</code> <i>n</i> <code>&lt;=</code> <i>r</i>. Up to the first <code>srcs[offset].remaining()</code> bytes of this sequence are written from buffer <code>srcs[offset]</code>, up to the next <code>srcs[offset+1].remaining()</code> bytes are written from buffer <code>srcs[offset+1]</code>, and so forth, until the entire byte sequence is written. As many bytes as possible are written from each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer's limit. </p>
<p> Unless otherwise specified, a write operation will return only after writing all of the <i>r</i> requested bytes. Some types of channels, depending upon their state, may write only some of the bytes or possibly none at all. A socket channel in non-blocking mode, for example, cannot write any more bytes than are free in the socket's output buffer. </p>
<p> This method may be invoked at any time. If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete. </p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="gatheringbytechannel.html#write(java.nio.ByteBuffer%5B%5D,int,int)">write</a></code> in interface <code><a href="gatheringbytechannel.html" title="interface in java.nio.channels">GatheringByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>srcs</code> - The buffers from which bytes are to be retrieved</dd> <dd>
<code>offset</code> - The offset within the buffer array of the first buffer from which bytes are to be retrieved; must be non-negative and no larger than <code>srcs.length</code>
</dd> <dd>
<code>length</code> - The maximum number of buffers to be accessed; must be non-negative and no larger than <code>srcs.length</code> - <code>offset</code>
</dd> <dt>Returns:</dt> <dd>The number of bytes written, possibly zero</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception.html" title="class in java.nio.channels">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - If another thread closes this channel while the write operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the write operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> </dl> </section><section class="detail" id="write(java.nio.ByteBuffer[])"> <h3>write</h3> <pre class="lang-java" data-language="java">public final long write(ByteBuffer[] srcs) throws IOException</pre> <div class="block"><span class="description-from-type-label">Description copied from interface: <code><a href="gatheringbytechannel.html#write(java.nio.ByteBuffer%5B%5D)">GatheringByteChannel</a></code></span></div> <div class="block">Writes a sequence of bytes to this channel from the given buffers. <p> An invocation of this method of the form <code>c.write(srcs)</code> behaves in exactly the same manner as the invocation </p>
<div class="snippet-container"> <pre class="lang-java" data-language="java"><code class="language-java">    c.write(srcs, 0, srcs.length);
</code></pre> </div> </div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="gatheringbytechannel.html#write(java.nio.ByteBuffer%5B%5D)">write</a></code> in interface <code><a href="gatheringbytechannel.html" title="interface in java.nio.channels">GatheringByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>srcs</code> - The buffers from which bytes are to be retrieved</dd> <dt>Returns:</dt> <dd>The number of bytes written, possibly zero</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception.html" title="class in java.nio.channels">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - If another thread closes this channel while the write operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the write operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If some other I/O error occurs</dd> </dl> </section><section class="detail" id="getLocalAddress()"> <h3>getLocalAddress</h3> <pre class="lang-java" data-language="java">public abstract SocketAddress getLocalAddress() throws IOException</pre> <div class="block">Returns the socket address that this channel's socket is bound to. <p> Where the channel is <a href="networkchannel.html#bind(java.net.SocketAddress)"><code>bound</code></a> to an Internet Protocol socket address then the return value from this method is of type <a href="../../net/inetsocketaddress.html" title="class in java.net"><code>InetSocketAddress</code></a>. If there is a security manager set, its <code>checkConnect</code> method is called with the local address and <code>-1</code> as its arguments to see if the operation is allowed. If the operation is not allowed, a <code>SocketAddress</code> representing the <a href="../../net/inetaddress.html#getLoopbackAddress()"><code>loopback</code></a> address and the local port of the channel's socket is returned. </p>
<p> Where the channel is bound to a Unix Domain socket address, the socket address is a <a href="../../net/unixdomainsocketaddress.html" title="class in java.net"><code>UnixDomainSocketAddress</code></a>. If there is a security manager set, its <a href="../../lang/securitymanager.html#checkPermission(java.security.Permission)"><code>checkPermission</code></a> method is called with <a href="../../net/netpermission.html" title="class in java.net"><code>NetPermission</code></a><code>
 ("accessUnixDomainSocket")</code>. If the operation is not allowed an unnamed <a href="../../net/unixdomainsocketaddress.html" title="class in java.net"><code>UnixDomainSocketAddress</code></a> is returned.</p>
</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="networkchannel.html#getLocalAddress()">getLocalAddress</a></code> in interface <code><a href="networkchannel.html" title="interface in java.nio.channels">NetworkChannel</a></code>
</dd> <dt>Returns:</dt> <dd>The <code>SocketAddress</code> that the socket is bound to, or the <code>SocketAddress</code> representing the loopback address or empty path if denied by the security manager, or <code>null</code> if the channel's socket is not bound</dd> <dt>Throws:</dt> <dd>
<code><a href="closedchannelexception.html" title="class in java.nio.channels">ClosedChannelException</a></code> - If the channel is closed</dd> <dd>
<code><a href="../../io/ioexception.html" title="class in java.io">IOException</a></code> - If an I/O error occurs</dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2023, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/channels/SocketChannel.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/channels/SocketChannel.html</a>
  </p>
</div>
