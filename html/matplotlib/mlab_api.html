<h1 id="matplotlib-mlab">matplotlib.mlab</h1> <p>Numerical Python functions written for compatibility with MATLAB commands with the same names. Most numerical Python functions can be found in the <a class="reference external" href="https://numpy.org">NumPy</a> and <a class="reference external" href="https://www.scipy.org">SciPy</a> libraries. What remains here is code for performing spectral computations and kernel density estimations.</p> <section id="spectral-functions"> <h2>Spectral functions</h2> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><code>cohere</code></a></dt>
<dd>
<p>Coherence (normalized cross spectral density)</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code>csd</code></a></dt>
<dd>
<p>Cross spectral density using Welch's average periodogram</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend</code></a></dt>
<dd>
<p>Remove the mean or best fit line from an array</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a></dt>
<dd>
<p>Power spectral density using Welch's average periodogram</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a></dt>
<dd>
<p>Spectrogram (spectrum over segments of time)</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a></dt>
<dd>
<p>Return the complex-valued frequency spectrum of a signal</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a></dt>
<dd>
<p>Return the magnitude of the frequency spectrum of a signal</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a></dt>
<dd>
<p>Return the angle (wrapped phase) of the frequency spectrum of a signal</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a></dt>
<dd>
<p>Return the phase (unwrapped angle) of the frequency spectrum of a signal</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a></dt>
<dd>
<p>Remove the mean from a line.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a></dt>
<dd>
<p>Remove the best fit line from a line.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a></dt>
<dd>
<p>Return the original line.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.stride_windows" title="matplotlib.mlab.stride_windows"><code>stride_windows</code></a></dt>
<dd>
<p>Get all windows in an array in a memory-efficient manner</p> </dd> </dl> </section> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.mlab.GaussianKDE"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">GaussianKDE</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset</span></em>, <em class="sig-param"><span class="n">bw_method</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L843-L987"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><code>object</code></a></p> <p>Representation of a kernel-density estimate using Gaussian kernels.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>dataset</strong><span class="classifier">array-like</span>
</dt>
<dd>
<p>Datapoints to estimate from. In case of univariate data this is a 1-D array, otherwise a 2D array with shape (# of dims, # of data).</p> </dd> <dt>
<strong>bw_method</strong><span class="classifier">str, scalar or callable, optional</span>
</dt>
<dd>
<p>The method used to calculate the estimator bandwidth. This can be 'scott', 'silverman', a scalar constant or a callable. If a scalar, this will be used directly as <code>kde.factor</code>. If a callable, it should take a <a class="reference internal" href="#matplotlib.mlab.GaussianKDE" title="matplotlib.mlab.GaussianKDE"><code>GaussianKDE</code></a> instance as only parameter and return a scalar. If None (default), 'scott' is used.</p> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>dataset</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>The dataset passed to the constructor.</p> </dd> <dt>
<strong>dim</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of dimensions.</p> </dd> <dt>
<strong>num_dp</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of datapoints.</p> </dd> <dt>
<strong>factor</strong><span class="classifier">float</span>
</dt>
<dd>
<p>The bandwidth factor, obtained from <code>kde.covariance_factor</code>, with which the covariance matrix is multiplied.</p> </dd> <dt>
<strong>covariance</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>The covariance matrix of <em>dataset</em>, scaled by the calculated bandwidth (<code>kde.factor</code>).</p> </dd> <dt>
<strong>inv_cov</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>The inverse of <em>covariance</em>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Methods</h4> <table class="table">  <tr>
<td><p><strong>kde.evaluate(points)</strong></p></td> <td><p>(ndarray) Evaluate the estimated pdf on a provided set of points.</p></td> </tr> <tr>
<td><p><strong>kde(points)</strong></p></td> <td><p>(ndarray) Same as kde.evaluate(points)</p></td> </tr>  </table> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.mlab.GaussianKDE.covariance_factor"> <span class="sig-name descname">covariance_factor</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L928-L929"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.mlab.GaussianKDE.evaluate"> <span class="sig-name descname">evaluate</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L938-L985"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Evaluate the estimated pdf on a set of points.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>points</strong><span class="classifier">(# of dimensions, # of points)-array</span>
</dt>
<dd>
<p>Alternatively, a (# of dimensions,) vector can be passed in and treated as a single point.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>(# of points,)-array</dt>
<dd>
<p>The values at each point.</p> </dd> </dl> </dd> <dt class="field-odd">Raises<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>ValueError</strong><span class="classifier">if the dimensionality of the input points is different</span>
</dt>
<dd>
<p>than the dimensionality of the KDE.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.mlab.GaussianKDE.scotts_factor"> <span class="sig-name descname">scotts_factor</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L928-L929"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.mlab.GaussianKDE.silverman_factor"> <span class="sig-name descname">silverman_factor</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L931-L933"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.angle_spectrum"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">angle_spectrum</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Compute the angle of the frequency spectrum (wrapped phase spectrum) of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>x</strong><span class="classifier">1-D array or sequence</span>
</dt>
<dd>
<p>Array or sequence containing the data</p> </dd> <dt>
<strong>Fs</strong><span class="classifier">float, default: 2</span>
</dt>
<dd>
<p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p> </dd> <dt>
<strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a></span>
</dt>
<dd>
<p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.24)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.24)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.24)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.10.1)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.10.1)"><code>scipy.signal.get_window</code></a>, etc. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span>
</dt>
<dd>
<p>Which sides of the spectrum to return. 'default' is one-sided for real data and two-sided for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<strong>pad_to</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html#numpy.fft.fft" title="(in NumPy v1.24)"><code>fft</code></a>. The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>spectrum</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The angle of the frequency spectrum (wrapped phase spectrum).</p> </dd> <dt>
<strong>freqs</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The frequencies corresponding to the elements in <em>spectrum</em>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a></dt>
<dd>
<p>Returns the power spectral density.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a></dt>
<dd>
<p>Returns the complex-valued frequency spectrum.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a></dt>
<dd>
<p>Returns the absolute value of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a></dt>
<dd>
<p>Returns the angle of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a></dt>
<dd>
<p>Returns the phase (unwrapped angle) of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a></dt>
<dd>
<p>Can return the complex spectrum of segments within the signal.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.cohere"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">cohere</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">NFFT=256</span></em>, <em class="sig-param"><span class="n">Fs=2</span></em>, <em class="sig-param"><span class="n">detrend=&lt;function detrend_none&gt;</span></em>, <em class="sig-param"><span class="n">window=&lt;function window_hanning&gt;</span></em>, <em class="sig-param"><span class="n">noverlap=0</span></em>, <em class="sig-param"><span class="n">pad_to=None</span></em>, <em class="sig-param"><span class="n">sides='default'</span></em>, <em class="sig-param"><span class="n">scale_by_freq=None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L793-L840"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>The coherence between <em>x</em> and <em>y</em>. Coherence is the normalized cross spectral density:</p> <div class="math notranslate nohighlight"> \[C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}\]</div> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt><strong>x, y</strong></dt>
<dd>
<p>Array or sequence containing the data</p> </dd> <dt>
<strong>Fs</strong><span class="classifier">float, default: 2</span>
</dt>
<dd>
<p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p> </dd> <dt>
<strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a></span>
</dt>
<dd>
<p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.24)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.24)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.24)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.10.1)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.10.1)"><code>scipy.signal.get_window</code></a>, etc. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span>
</dt>
<dd>
<p>Which sides of the spectrum to return. 'default' is one-sided for real data and two-sided for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<strong>pad_to</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html#numpy.fft.fft" title="(in NumPy v1.24)"><code>fft</code></a>. The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p> </dd> <dt>
<strong>NFFT</strong><span class="classifier">int, default: 256</span>
</dt>
<dd>
<p>The number of data points used in each block for the FFT. A power 2 is most efficient. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect; use <em>pad_to</em> for this instead.</p> </dd> <dt>
<strong>detrend</strong><span class="classifier">{'none', 'mean', 'linear'} or callable, default: 'none'</span>
</dt>
<dd>
<p>The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in Matplotlib it is a function. The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code>mlab</code></a> module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>, but you can use a custom function as well. You can also use a string to choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>. 'mean' calls <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>.</p> </dd> <dt>
<strong>scale_by_freq</strong><span class="classifier">bool, default: True</span>
</dt>
<dd>
<p>Whether the resulting density values should be scaled by the scaling frequency, which gives density in units of 1/Hz. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p> </dd> <dt>
<strong>noverlap</strong><span class="classifier">int, default: 0 (no overlap)</span>
</dt>
<dd>
<p>The number of points of overlap between segments.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>Cxy</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The coherence vector.</p> </dd> <dt>
<strong>freqs</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The frequencies for the elements in <em>Cxy</em>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd()</code></a>, <a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code>csd()</code></a>
</dt>
<dd>
<p>For information about the methods used to compute <span class="math notranslate nohighlight">\(P_{xy}\)</span>, <span class="math notranslate nohighlight">\(P_{xx}\)</span> and <span class="math notranslate nohighlight">\(P_{yy}\)</span>.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.complex_spectrum"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">complex_spectrum</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Compute the complex-valued frequency spectrum of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>x</strong><span class="classifier">1-D array or sequence</span>
</dt>
<dd>
<p>Array or sequence containing the data</p> </dd> <dt>
<strong>Fs</strong><span class="classifier">float, default: 2</span>
</dt>
<dd>
<p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p> </dd> <dt>
<strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a></span>
</dt>
<dd>
<p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.24)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.24)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.24)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.10.1)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.10.1)"><code>scipy.signal.get_window</code></a>, etc. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span>
</dt>
<dd>
<p>Which sides of the spectrum to return. 'default' is one-sided for real data and two-sided for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<strong>pad_to</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html#numpy.fft.fft" title="(in NumPy v1.24)"><code>fft</code></a>. The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>spectrum</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The complex-valued frequency spectrum.</p> </dd> <dt>
<strong>freqs</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The frequencies corresponding to the elements in <em>spectrum</em>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a></dt>
<dd>
<p>Returns the power spectral density.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a></dt>
<dd>
<p>Returns the complex-valued frequency spectrum.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a></dt>
<dd>
<p>Returns the absolute value of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a></dt>
<dd>
<p>Returns the angle of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a></dt>
<dd>
<p>Returns the phase (unwrapped angle) of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a></dt>
<dd>
<p>Can return the complex spectrum of segments within the signal.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.csd"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">csd</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">NFFT</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">detrend</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">noverlap</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale_by_freq</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L590-L651"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the cross-spectral density.</p> <p>The cross spectral density <span class="math notranslate nohighlight">\(P_{xy}\)</span> by Welch's average periodogram method. The vectors <em>x</em> and <em>y</em> are divided into <em>NFFT</em> length segments. Each segment is detrended by function <em>detrend</em> and windowed by function <em>window</em>. <em>noverlap</em> gives the length of the overlap between segments. The product of the direct FFTs of <em>x</em> and <em>y</em> are averaged over each segment to compute <span class="math notranslate nohighlight">\(P_{xy}\)</span>, with a scaling to correct for power loss due to windowing.</p> <p>If len(<em>x</em>) &lt; <em>NFFT</em> or len(<em>y</em>) &lt; <em>NFFT</em>, they will be zero padded to <em>NFFT</em>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>x, y</strong><span class="classifier">1-D arrays or sequences</span>
</dt>
<dd>
<p>Arrays or sequences containing the data</p> </dd> <dt>
<strong>Fs</strong><span class="classifier">float, default: 2</span>
</dt>
<dd>
<p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p> </dd> <dt>
<strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a></span>
</dt>
<dd>
<p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.24)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.24)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.24)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.10.1)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.10.1)"><code>scipy.signal.get_window</code></a>, etc. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span>
</dt>
<dd>
<p>Which sides of the spectrum to return. 'default' is one-sided for real data and two-sided for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<strong>pad_to</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html#numpy.fft.fft" title="(in NumPy v1.24)"><code>fft</code></a>. The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p> </dd> <dt>
<strong>NFFT</strong><span class="classifier">int, default: 256</span>
</dt>
<dd>
<p>The number of data points used in each block for the FFT. A power 2 is most efficient. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect; use <em>pad_to</em> for this instead.</p> </dd> <dt>
<strong>detrend</strong><span class="classifier">{'none', 'mean', 'linear'} or callable, default: 'none'</span>
</dt>
<dd>
<p>The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in Matplotlib it is a function. The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code>mlab</code></a> module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>, but you can use a custom function as well. You can also use a string to choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>. 'mean' calls <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>.</p> </dd> <dt>
<strong>scale_by_freq</strong><span class="classifier">bool, default: True</span>
</dt>
<dd>
<p>Whether the resulting density values should be scaled by the scaling frequency, which gives density in units of 1/Hz. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p> </dd> <dt>
<strong>noverlap</strong><span class="classifier">int, default: 0 (no overlap)</span>
</dt>
<dd>
<p>The number of points of overlap between segments.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>Pxy</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The values for the cross spectrum <span class="math notranslate nohighlight">\(P_{xy}\)</span> before scaling (real valued)</p> </dd> <dt>
<strong>freqs</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The frequencies corresponding to the elements in <em>Pxy</em></p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a></dt>
<dd>
<p>equivalent to setting <code>y = x</code>.</p> </dd> </dl> </div> <h4 class="rubric">References</h4> <p>Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John Wiley &amp; Sons (1986)</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.detrend"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">detrend</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">key</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L83-L129"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return <em>x</em> with its trend removed.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x</strong><span class="classifier">array or sequence</span>
</dt>
<dd>
<p>Array or sequence containing the data.</p> </dd> <dt>
<strong>key</strong><span class="classifier">{'default', 'constant', 'mean', 'linear', 'none'} or function</span>
</dt>
<dd>
<p>The detrending algorithm to use. 'default', 'mean', and 'constant' are the same as <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>. 'linear' is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>. 'none' is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>. The default is 'mean'. See the corresponding functions for more details regarding the algorithms. Can also be a function that carries out the detrend operation.</p> </dd> <dt>
<strong>axis</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The axis along which to do the detrending.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a></dt>
<dd>
<p>Implementation of the 'mean' algorithm.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a></dt>
<dd>
<p>Implementation of the 'linear' algorithm.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a></dt>
<dd>
<p>Implementation of the 'none' algorithm.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.detrend_linear"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">detrend_linear</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L182-L213"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return <em>x</em> minus best fit line; 'linear' detrending.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>y</strong><span class="classifier">0-D or 1-D array or sequence</span>
</dt>
<dd>
<p>Array or sequence containing the data</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a></dt>
<dd>
<p>Another detrend algorithm.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a></dt>
<dd>
<p>Another detrend algorithm.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend</code></a></dt>
<dd>
<p>A wrapper around all the detrend algorithms.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.detrend_mean"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">detrend_mean</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L132-L157"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return <em>x</em> minus the mean(<em>x</em>).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x</strong><span class="classifier">array or sequence</span>
</dt>
<dd>
<p>Array or sequence containing the data Can have any dimensionality</p> </dd> <dt>
<strong>axis</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The axis along which to take the mean. See <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.mean.html#numpy.mean" title="(in NumPy v1.24)"><code>numpy.mean</code></a> for a description of this argument.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a></dt>
<dd>
<p>Another detrend algorithm.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a></dt>
<dd>
<p>Another detrend algorithm.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend</code></a></dt>
<dd>
<p>A wrapper around all the detrend algorithms.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.detrend_none"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">detrend_none</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L160-L179"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return <em>x</em>: no detrending.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x</strong><span class="classifier">any object</span>
</dt>
<dd>
<p>An object containing the data</p> </dd> <dt>
<strong>axis</strong><span class="classifier">int</span>
</dt>
<dd>
<p>This parameter is ignored. It is included for compatibility with detrend_mean</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a></dt>
<dd>
<p>Another detrend algorithm.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a></dt>
<dd>
<p>Another detrend algorithm.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend</code></a></dt>
<dd>
<p>A wrapper around all the detrend algorithms.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.magnitude_spectrum"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">magnitude_spectrum</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Compute the magnitude (absolute value) of the frequency spectrum of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>x</strong><span class="classifier">1-D array or sequence</span>
</dt>
<dd>
<p>Array or sequence containing the data</p> </dd> <dt>
<strong>Fs</strong><span class="classifier">float, default: 2</span>
</dt>
<dd>
<p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p> </dd> <dt>
<strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a></span>
</dt>
<dd>
<p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.24)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.24)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.24)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.10.1)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.10.1)"><code>scipy.signal.get_window</code></a>, etc. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span>
</dt>
<dd>
<p>Which sides of the spectrum to return. 'default' is one-sided for real data and two-sided for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<strong>pad_to</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html#numpy.fft.fft" title="(in NumPy v1.24)"><code>fft</code></a>. The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>spectrum</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The magnitude (absolute value) of the frequency spectrum.</p> </dd> <dt>
<strong>freqs</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The frequencies corresponding to the elements in <em>spectrum</em>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a></dt>
<dd>
<p>Returns the power spectral density.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a></dt>
<dd>
<p>Returns the complex-valued frequency spectrum.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a></dt>
<dd>
<p>Returns the absolute value of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a></dt>
<dd>
<p>Returns the angle of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a></dt>
<dd>
<p>Returns the phase (unwrapped angle) of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a></dt>
<dd>
<p>Can return the complex spectrum of segments within the signal.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.phase_spectrum"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">phase_spectrum</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Compute the phase of the frequency spectrum (unwrapped phase spectrum) of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>x</strong><span class="classifier">1-D array or sequence</span>
</dt>
<dd>
<p>Array or sequence containing the data</p> </dd> <dt>
<strong>Fs</strong><span class="classifier">float, default: 2</span>
</dt>
<dd>
<p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p> </dd> <dt>
<strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a></span>
</dt>
<dd>
<p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.24)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.24)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.24)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.10.1)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.10.1)"><code>scipy.signal.get_window</code></a>, etc. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span>
</dt>
<dd>
<p>Which sides of the spectrum to return. 'default' is one-sided for real data and two-sided for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<strong>pad_to</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html#numpy.fft.fft" title="(in NumPy v1.24)"><code>fft</code></a>. The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>spectrum</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The phase of the frequency spectrum (unwrapped phase spectrum).</p> </dd> <dt>
<strong>freqs</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The frequencies corresponding to the elements in <em>spectrum</em>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a></dt>
<dd>
<p>Returns the power spectral density.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a></dt>
<dd>
<p>Returns the complex-valued frequency spectrum.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a></dt>
<dd>
<p>Returns the absolute value of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a></dt>
<dd>
<p>Returns the angle of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a></dt>
<dd>
<p>Returns the phase (unwrapped angle) of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a></dt>
<dd>
<p>Can return the complex spectrum of segments within the signal.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.psd"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">psd</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">NFFT</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">detrend</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">noverlap</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale_by_freq</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L534-L587"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the power spectral density.</p> <p>The power spectral density <span class="math notranslate nohighlight">\(P_{xx}\)</span> by Welch's average periodogram method. The vector <em>x</em> is divided into <em>NFFT</em> length segments. Each segment is detrended by function <em>detrend</em> and windowed by function <em>window</em>. <em>noverlap</em> gives the length of the overlap between segments. The <span class="math notranslate nohighlight">\(|\mathrm{fft}(i)|^2\)</span> of each segment <span class="math notranslate nohighlight">\(i\)</span> are averaged to compute <span class="math notranslate nohighlight">\(P_{xx}\)</span>.</p> <p>If len(<em>x</em>) &lt; <em>NFFT</em>, it will be zero padded to <em>NFFT</em>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>x</strong><span class="classifier">1-D array or sequence</span>
</dt>
<dd>
<p>Array or sequence containing the data</p> </dd> <dt>
<strong>Fs</strong><span class="classifier">float, default: 2</span>
</dt>
<dd>
<p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p> </dd> <dt>
<strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a></span>
</dt>
<dd>
<p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.24)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.24)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.24)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.10.1)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.10.1)"><code>scipy.signal.get_window</code></a>, etc. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span>
</dt>
<dd>
<p>Which sides of the spectrum to return. 'default' is one-sided for real data and two-sided for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<strong>pad_to</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html#numpy.fft.fft" title="(in NumPy v1.24)"><code>fft</code></a>. The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p> </dd> <dt>
<strong>NFFT</strong><span class="classifier">int, default: 256</span>
</dt>
<dd>
<p>The number of data points used in each block for the FFT. A power 2 is most efficient. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect; use <em>pad_to</em> for this instead.</p> </dd> <dt>
<strong>detrend</strong><span class="classifier">{'none', 'mean', 'linear'} or callable, default: 'none'</span>
</dt>
<dd>
<p>The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in Matplotlib it is a function. The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code>mlab</code></a> module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>, but you can use a custom function as well. You can also use a string to choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>. 'mean' calls <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>.</p> </dd> <dt>
<strong>scale_by_freq</strong><span class="classifier">bool, default: True</span>
</dt>
<dd>
<p>Whether the resulting density values should be scaled by the scaling frequency, which gives density in units of 1/Hz. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p> </dd> <dt>
<strong>noverlap</strong><span class="classifier">int, default: 0 (no overlap)</span>
</dt>
<dd>
<p>The number of points of overlap between segments.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>Pxx</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The values for the power spectrum <span class="math notranslate nohighlight">\(P_{xx}\)</span> (real valued)</p> </dd> <dt>
<strong>freqs</strong><span class="classifier">1-D array</span>
</dt>
<dd>
<p>The frequencies corresponding to the elements in <em>Pxx</em></p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a></dt>
<dd>
<p><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a> differs in the default overlap; in not returning the mean of the segment periodograms; and in returning the times of the segments.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a></dt>
<dd>
<p>returns the magnitude spectrum.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code>csd</code></a></dt>
<dd>
<p>returns the spectral density between two signals.</p> </dd> </dl> </div> <h4 class="rubric">References</h4> <p>Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John Wiley &amp; Sons (1986)</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.specgram"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">specgram</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">NFFT</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">detrend</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">noverlap</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale_by_freq</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L710-L790"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute a spectrogram.</p> <p>Compute and plot a spectrogram of data in <em>x</em>. Data are split into <em>NFFT</em> length segments and the spectrum of each section is computed. The windowing function <em>window</em> is applied to each segment, and the amount of overlap of each segment is specified with <em>noverlap</em>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>x</strong><span class="classifier">array-like</span>
</dt>
<dd>
<p>1-D array or sequence.</p> </dd> <dt>
<strong>Fs</strong><span class="classifier">float, default: 2</span>
</dt>
<dd>
<p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p> </dd> <dt>
<strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a></span>
</dt>
<dd>
<p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.24)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.24)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.24)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.10.1)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.10.1)"><code>scipy.signal.get_window</code></a>, etc. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span>
</dt>
<dd>
<p>Which sides of the spectrum to return. 'default' is one-sided for real data and two-sided for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<strong>pad_to</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html#numpy.fft.fft" title="(in NumPy v1.24)"><code>fft</code></a>. The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p> </dd> <dt>
<strong>NFFT</strong><span class="classifier">int, default: 256</span>
</dt>
<dd>
<p>The number of data points used in each block for the FFT. A power 2 is most efficient. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect; use <em>pad_to</em> for this instead.</p> </dd> <dt>
<strong>detrend</strong><span class="classifier">{'none', 'mean', 'linear'} or callable, default: 'none'</span>
</dt>
<dd>
<p>The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in Matplotlib it is a function. The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code>mlab</code></a> module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>, but you can use a custom function as well. You can also use a string to choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>. 'mean' calls <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>.</p> </dd> <dt>
<strong>scale_by_freq</strong><span class="classifier">bool, default: True</span>
</dt>
<dd>
<p>Whether the resulting density values should be scaled by the scaling frequency, which gives density in units of 1/Hz. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p> </dd> <dt>
<strong>noverlap</strong><span class="classifier">int, default: 128</span>
</dt>
<dd>
<p>The number of points of overlap between blocks.</p> </dd> <dt>
<strong>mode</strong><span class="classifier">str, default: 'psd'</span>
</dt>
<dd>
<dl class="simple"> <dt>What sort of spectrum to use:</dt>
<dd>
<dl class="simple"> <dt>'psd'</dt>
<dd>
<p>Returns the power spectral density.</p> </dd> <dt>'complex'</dt>
<dd>
<p>Returns the complex-valued frequency spectrum.</p> </dd> <dt>'magnitude'</dt>
<dd>
<p>Returns the magnitude spectrum.</p> </dd> <dt>'angle'</dt>
<dd>
<p>Returns the phase spectrum without unwrapping.</p> </dd> <dt>'phase'</dt>
<dd>
<p>Returns the phase spectrum with unwrapping.</p> </dd> </dl> </dd> </dl> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>spectrum</strong><span class="classifier">array-like</span>
</dt>
<dd>
<p>2D array, columns are the periodograms of successive segments.</p> </dd> <dt>
<strong>freqs</strong><span class="classifier">array-like</span>
</dt>
<dd>
<p>1-D array, frequencies corresponding to the rows in <em>spectrum</em>.</p> </dd> <dt>
<strong>t</strong><span class="classifier">array-like</span>
</dt>
<dd>
<p>1-D array, the times corresponding to midpoints of segments (i.e the columns in <em>spectrum</em>).</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a></dt>
<dd>
<p>differs in the overlap and in the return values.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a></dt>
<dd>
<p>similar, but with complex valued frequencies.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a></dt>
<dd>
<p>similar single segment when <em>mode</em> is 'magnitude'.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a></dt>
<dd>
<p>similar to single segment when <em>mode</em> is 'angle'.</p> </dd> <dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a></dt>
<dd>
<p>similar to single segment when <em>mode</em> is 'phase'.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p><em>detrend</em> and <em>scale_by_freq</em> only apply when <em>mode</em> is set to 'psd'.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.stride_windows"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">stride_windows</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">noverlap</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L216-L250"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>] Get all windows of <em>x</em> with length <em>n</em> as a single array, using strides to avoid data duplication.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>It is not safe to write to the output array. Multiple elements may point to the same piece of memory, so modifying one value may change others.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x</strong><span class="classifier">1D array or sequence</span>
</dt>
<dd>
<p>Array or sequence containing the data.</p> </dd> <dt>
<strong>n</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The number of data points in each window.</p> </dd> <dt>
<strong>noverlap</strong><span class="classifier">int, default: 0 (no overlap)</span>
</dt>
<dd>
<p>The overlap between adjacent windows.</p> </dd> <dt>
<strong>axis</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The axis along which the windows will run.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.6.</span></p> </div> <h4 class="rubric">References</h4> <p><a class="reference external" href="https://stackoverflow.com/a/6811241">stackoverflow: Rolling window for 1D arrays in Numpy?</a> <a class="reference external" href="https://stackoverflow.com/a/4947453">stackoverflow: Using strides for an efficient moving average filter</a></p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.window_hanning"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">window_hanning</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L61-L69"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return <em>x</em> times the Hanning (or Hann) window of len(<em>x</em>).</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a></dt>
<dd>
<p>Another window algorithm.</p> </dd> </dl> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.mlab.window_none"> <span class="sig-prename descclassname">matplotlib.mlab.</span><span class="sig-name descname">window_none</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/mlab.py#L72-L80"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>No window function; simply return <em>x</em>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a></dt>
<dd>
<p>Another window algorithm.</p> </dd> </dl> </div> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2023 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/stable/api/mlab_api.html" class="_attribution-link">https://matplotlib.org/stable/api/mlab_api.html</a>
  </p>
</div>
