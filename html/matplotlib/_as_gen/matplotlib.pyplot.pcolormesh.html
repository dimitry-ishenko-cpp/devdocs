<h1>matplotlib.pyplot.pcolormesh</h1> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.pyplot.pcolormesh"> <span class="sig-prename descclassname">matplotlib.pyplot.</span><span class="sig-name descname">pcolormesh</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">norm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cmap</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vmin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vmax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shading</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">antialiased</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.7.1/lib/matplotlib/pyplot.py#L2768-L2778"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a pseudocolor plot with a non-regular rectangular grid.</p> <p>Call signature:</p> <pre data-language="python">pcolormesh([X, Y,] C, **kwargs)
</pre> <p><em>X</em> and <em>Y</em> can be used to specify the corners of the quadrilaterals.</p> <div class="admonition hint"> <p class="admonition-title">Hint</p> <p><a class="reference internal" href="matplotlib.axes.axes.pcolormesh.html#matplotlib.axes.Axes.pcolormesh" title="matplotlib.axes.Axes.pcolormesh"><code>pcolormesh</code></a> is similar to <a class="reference internal" href="matplotlib.axes.axes.pcolor.html#matplotlib.axes.Axes.pcolor" title="matplotlib.axes.Axes.pcolor"><code>pcolor</code></a>. It is much faster and preferred in most cases. For a detailed discussion on the differences see <a class="reference internal" href="#differences-pcolor-pcolormesh"><span class="std std-ref">Differences between pcolor() and pcolormesh()</span></a>.</p> </div> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>C</strong><span class="classifier">array-like</span>
</dt>
<dd>
<p>The mesh data. Supported array shapes are:</p> <ul class="simple"> <li>(M, N) or M*N: a mesh with scalar data. The values are mapped to colors using normalization and a colormap. See parameters <em>norm</em>, <em>cmap</em>, <em>vmin</em>, <em>vmax</em>.</li> <li>(M, N, 3): an image with RGB values (0-1 float or 0-255 int).</li> <li>(M, N, 4): an image with RGBA values (0-1 float or 0-255 int), i.e. including transparency.</li> </ul> <p>The first two dimensions (M, N) define the rows and columns of the mesh data.</p> </dd> <dt>
<strong>X, Y</strong><span class="classifier">array-like, optional</span>
</dt>
<dd>
<p>The coordinates of the corners of quadrilaterals of a pcolormesh:</p> <pre data-language="python">(X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
                      ●╶───╴●
                      │     │
                      ●╶───╴●
    (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
</pre> <p>Note that the column index corresponds to the x-coordinate, and the row index corresponds to y. For details, see the <a class="reference internal" href="#axes-pcolormesh-grid-orientation"><span class="std std-ref">Notes</span></a> section below.</p> <p>If <code>shading='flat'</code> the dimensions of <em>X</em> and <em>Y</em> should be one greater than those of <em>C</em>, and the quadrilateral is colored due to the value at <code>C[i, j]</code>. If <em>X</em>, <em>Y</em> and <em>C</em> have equal dimensions, a warning will be raised and the last row and column of <em>C</em> will be ignored.</p> <p>If <code>shading='nearest'</code> or <code>'gouraud'</code>, the dimensions of <em>X</em> and <em>Y</em> should be the same as those of <em>C</em> (if not, a ValueError will be raised). For <code>'nearest'</code> the color <code>C[i, j]</code> is centered on <code>(X[i, j], Y[i, j])</code>. For <code>'gouraud'</code>, a smooth interpolation is caried out between the quadrilateral corners.</p> <p>If <em>X</em> and/or <em>Y</em> are 1-D arrays or column vectors they will be expanded as needed into the appropriate 2D arrays, making a rectangular grid.</p> </dd> <dt>
<strong>cmap</strong><span class="classifier">str or <a class="reference internal" href="matplotlib.colors.colormap.html#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>Colormap</code></a>, default: <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=image.cmap#matplotlibrc-sample"><span class="std std-ref">rcParams["image.cmap"]</span></a></code> (default: <code>'viridis'</code>)</span>
</dt>
<dd>
<p>The Colormap instance or registered colormap name used to map scalar data to colors.</p> </dd> <dt>
<strong>norm</strong><span class="classifier">str or <a class="reference internal" href="matplotlib.colors.normalize.html#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a>, optional</span>
</dt>
<dd>
<p>The normalization method used to scale scalar data to the [0, 1] range before mapping to colors using <em>cmap</em>. By default, a linear scaling is used, mapping the lowest value to 0 and the highest to 1.</p> <p>If given, this can be one of the following:</p> <ul class="simple"> <li>An instance of <a class="reference internal" href="matplotlib.colors.normalize.html#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> or one of its subclasses (see <a class="reference internal" href="https://matplotlib.org/stable/tutorials/colors/colormapnorms.html"><span class="doc">Colormap Normalization</span></a>).</li> <li>A scale name, i.e. one of "linear", "log", "symlog", "logit", etc. For a list of available scales, call <a class="reference internal" href="../scale_api.html#matplotlib.scale.get_scale_names" title="matplotlib.scale.get_scale_names"><code>matplotlib.scale.get_scale_names()</code></a>. In that case, a suitable <a class="reference internal" href="matplotlib.colors.normalize.html#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> subclass is dynamically generated and instantiated.</li> </ul> </dd> <dt>
<strong>vmin, vmax</strong><span class="classifier">float, optional</span>
</dt>
<dd>
<p>When using scalar data and no explicit <em>norm</em>, <em>vmin</em> and <em>vmax</em> define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. It is an error to use <em>vmin</em>/<em>vmax</em> when a <em>norm</em> instance is given (but using a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><code>str</code></a> <em>norm</em> name together with <em>vmin</em>/<em>vmax</em> is acceptable).</p> </dd> <dt>
<strong>edgecolors</strong><span class="classifier">{'none', None, 'face', color, color sequence}, optional</span>
</dt>
<dd>
<p>The color of the edges. Defaults to 'none'. Possible values:</p> <ul class="simple"> <li>'none' or '': No edge.</li> <li>
<em>None</em>: <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=patch.edgecolor#matplotlibrc-sample"><span class="std std-ref">rcParams["patch.edgecolor"]</span></a></code> (default: <code>'black'</code>) will be used. Note that currently <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=patch.force_edgecolor#matplotlibrc-sample"><span class="std std-ref">rcParams["patch.force_edgecolor"]</span></a></code> (default: <code>False</code>) has to be True for this to work.</li> <li>'face': Use the adjacent face color.</li> <li>A color or sequence of colors will set the edge color.</li> </ul> <p>The singular form <em>edgecolor</em> works as an alias.</p> </dd> <dt>
<strong>alpha</strong><span class="classifier">float, default: None</span>
</dt>
<dd>
<p>The alpha blending value, between 0 (transparent) and 1 (opaque).</p> </dd> <dt>
<strong>shading</strong><span class="classifier">{'flat', 'nearest', 'gouraud', 'auto'}, optional</span>
</dt>
<dd>
<p>The fill style for the quadrilateral; defaults to <code><a class="reference internal" href="https://matplotlib.org/stable/tutorials/introductory/customizing.html?highlight=pcolor.shading#matplotlibrc-sample"><span class="std std-ref">rcParams["pcolor.shading"]</span></a></code> (default: <code>'auto'</code>). Possible values:</p> <ul class="simple"> <li>'flat': A solid color is used for each quad. The color of the quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by <code>C[i, j]</code>. The dimensions of <em>X</em> and <em>Y</em> should be one greater than those of <em>C</em>; if they are the same as <em>C</em>, then a deprecation warning is raised, and the last row and column of <em>C</em> are dropped.</li> <li>'nearest': Each grid point will have a color centered on it, extending halfway between the adjacent grid centers. The dimensions of <em>X</em> and <em>Y</em> must be the same as <em>C</em>.</li> <li>'gouraud': Each quad will be Gouraud shaded: The color of the corners (i', j') are given by <code>C[i', j']</code>. The color values of the area in between is interpolated from the corner values. The dimensions of <em>X</em> and <em>Y</em> must be the same as <em>C</em>. When Gouraud shading is used, <em>edgecolors</em> is ignored.</li> <li>'auto': Choose 'flat' if dimensions of <em>X</em> and <em>Y</em> are one larger than <em>C</em>. Choose 'nearest' if dimensions are the same.</li> </ul> <p>See <a class="reference internal" href="https://matplotlib.org/stable/gallery/images_contours_and_fields/pcolormesh_grids.html"><span class="doc">pcolormesh grids and shading</span></a> for more description.</p> </dd> <dt>
<strong>snap</strong><span class="classifier">bool, default: False</span>
</dt>
<dd>
<p>Whether to snap the mesh to pixel boundaries.</p> </dd> <dt>
<strong>rasterized</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>Rasterize the pcolormesh when drawing vector graphics. This can speed up rendering and produce smaller files for large data sets. See also <a class="reference internal" href="https://matplotlib.org/stable/gallery/misc/rasterization_demo.html"><span class="doc">Rasterization for vector graphics</span></a>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt><a class="reference internal" href="../collections_api.html#matplotlib.collections.QuadMesh" title="matplotlib.collections.QuadMesh"><code>matplotlib.collections.QuadMesh</code></a></dt>
 </dl> </dd> <dt class="field-odd">Other Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>data</strong><span class="classifier">indexable object, optional</span>
</dt>
<dd>
<p>If given, all parameters also accept a string <code>s</code>, which is interpreted as <code>data[s]</code> (unless this raises an exception).</p> </dd> <dt><strong>**kwargs</strong></dt>
<dd>
<p>Additionally, the following arguments are allowed. They are passed along to the <a class="reference internal" href="../collections_api.html#matplotlib.collections.QuadMesh" title="matplotlib.collections.QuadMesh"><code>QuadMesh</code></a> constructor:</p> <table class="property-table table"> <thead> <tr>
<th class="head"><p>Property</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_agg_filter.html#matplotlib.artist.Artist.set_agg_filter" title="matplotlib.artist.Artist.set_agg_filter"><code>agg_filter</code></a></p></td> <td><p>a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array and two offsets from the bottom left corner of the image</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_alpha" title="matplotlib.collections.Collection.set_alpha"><code>alpha</code></a></p></td> <td><p>array-like or scalar or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_animated.html#matplotlib.artist.Artist.set_animated" title="matplotlib.artist.Artist.set_animated"><code>animated</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_antialiased" title="matplotlib.collections.Collection.set_antialiased"><code>antialiased</code></a> or aa or antialiaseds</p></td> <td><p>bool or list of bools</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.QuadMesh.set_array" title="matplotlib.collections.QuadMesh.set_array"><code>array</code></a></p></td> <td><p>array-like</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_capstyle" title="matplotlib.collections.Collection.set_capstyle"><code>capstyle</code></a></p></td> <td><p><a class="reference internal" href="../_enums_api.html#matplotlib._enums.CapStyle" title="matplotlib._enums.CapStyle"><code>CapStyle</code></a> or {'butt', 'projecting', 'round'}</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../cm_api.html#matplotlib.cm.ScalarMappable.set_clim" title="matplotlib.cm.ScalarMappable.set_clim"><code>clim</code></a></p></td> <td><p>(vmin: float, vmax: float)</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_clip_box.html#matplotlib.artist.Artist.set_clip_box" title="matplotlib.artist.Artist.set_clip_box"><code>clip_box</code></a></p></td> <td><p><a class="reference internal" href="../transformations.html#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_clip_on.html#matplotlib.artist.Artist.set_clip_on" title="matplotlib.artist.Artist.set_clip_on"><code>clip_on</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_clip_path.html#matplotlib.artist.Artist.set_clip_path" title="matplotlib.artist.Artist.set_clip_path"><code>clip_path</code></a></p></td> <td><p>Patch or (Path, Transform) or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../cm_api.html#matplotlib.cm.ScalarMappable.set_cmap" title="matplotlib.cm.ScalarMappable.set_cmap"><code>cmap</code></a></p></td> <td><p><a class="reference internal" href="matplotlib.colors.colormap.html#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>Colormap</code></a> or str or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_color" title="matplotlib.collections.Collection.set_color"><code>color</code></a></p></td> <td><p>color or list of RGBA tuples</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>edgecolor</code></a> or ec or edgecolors</p></td> <td><p>color or list of colors or 'face'</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_facecolor" title="matplotlib.collections.Collection.set_facecolor"><code>facecolor</code></a> or facecolors or fc</p></td> <td><p>color or list of colors</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_figure.html#matplotlib.artist.Artist.set_figure" title="matplotlib.artist.Artist.set_figure"><code>figure</code></a></p></td> <td><p><a class="reference internal" href="../figure_api.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_gid.html#matplotlib.artist.Artist.set_gid" title="matplotlib.artist.Artist.set_gid"><code>gid</code></a></p></td> <td><p>str</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_hatch" title="matplotlib.collections.Collection.set_hatch"><code>hatch</code></a></p></td> <td><p>{'/', '\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_in_layout.html#matplotlib.artist.Artist.set_in_layout" title="matplotlib.artist.Artist.set_in_layout"><code>in_layout</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_joinstyle" title="matplotlib.collections.Collection.set_joinstyle"><code>joinstyle</code></a></p></td> <td><p><a class="reference internal" href="../_enums_api.html#matplotlib._enums.JoinStyle" title="matplotlib._enums.JoinStyle"><code>JoinStyle</code></a> or {'miter', 'round', 'bevel'}</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_label.html#matplotlib.artist.Artist.set_label" title="matplotlib.artist.Artist.set_label"><code>label</code></a></p></td> <td><p>object</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_linestyle" title="matplotlib.collections.Collection.set_linestyle"><code>linestyle</code></a> or dashes or linestyles or ls</p></td> <td><p>str or tuple or list thereof</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_linewidth" title="matplotlib.collections.Collection.set_linewidth"><code>linewidth</code></a> or linewidths or lw</p></td> <td><p>float or list of floats</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_mouseover.html#matplotlib.artist.Artist.set_mouseover" title="matplotlib.artist.Artist.set_mouseover"><code>mouseover</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../cm_api.html#matplotlib.cm.ScalarMappable.set_norm" title="matplotlib.cm.ScalarMappable.set_norm"><code>norm</code></a></p></td> <td><p><a class="reference internal" href="matplotlib.colors.normalize.html#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> or str or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_offset_transform" title="matplotlib.collections.Collection.set_offset_transform"><code>offset_transform</code></a> or transOffset</p></td> <td><p>unknown</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_offsets" title="matplotlib.collections.Collection.set_offsets"><code>offsets</code></a></p></td> <td><p>(N, 2) or (2,) array-like</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_path_effects.html#matplotlib.artist.Artist.set_path_effects" title="matplotlib.artist.Artist.set_path_effects"><code>path_effects</code></a></p></td> <td><p><a class="reference internal" href="../patheffects_api.html#matplotlib.patheffects.AbstractPathEffect" title="matplotlib.patheffects.AbstractPathEffect"><code>AbstractPathEffect</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_picker.html#matplotlib.artist.Artist.set_picker" title="matplotlib.artist.Artist.set_picker"><code>picker</code></a></p></td> <td><p>None or bool or float or callable</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_pickradius" title="matplotlib.collections.Collection.set_pickradius"><code>pickradius</code></a></p></td> <td><p>unknown</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_rasterized.html#matplotlib.artist.Artist.set_rasterized" title="matplotlib.artist.Artist.set_rasterized"><code>rasterized</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_sketch_params.html#matplotlib.artist.Artist.set_sketch_params" title="matplotlib.artist.Artist.set_sketch_params"><code>sketch_params</code></a></p></td> <td><p>(scale: float, length: float, randomness: float)</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_snap.html#matplotlib.artist.Artist.set_snap" title="matplotlib.artist.Artist.set_snap"><code>snap</code></a></p></td> <td><p>bool or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_transform.html#matplotlib.artist.Artist.set_transform" title="matplotlib.artist.Artist.set_transform"><code>transform</code></a></p></td> <td><p><a class="reference internal" href="../transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_url.html#matplotlib.artist.Artist.set_url" title="matplotlib.artist.Artist.set_url"><code>url</code></a></p></td> <td><p>str</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api.html#matplotlib.collections.Collection.set_urls" title="matplotlib.collections.Collection.set_urls"><code>urls</code></a></p></td> <td><p>list of str or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_visible.html#matplotlib.artist.Artist.set_visible" title="matplotlib.artist.Artist.set_visible"><code>visible</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_zorder.html#matplotlib.artist.Artist.set_zorder" title="matplotlib.artist.Artist.set_zorder"><code>zorder</code></a></p></td> <td><p>float</p></td> </tr>  </table> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="matplotlib.pyplot.pcolor.html#matplotlib.pyplot.pcolor" title="matplotlib.pyplot.pcolor"><code>pcolor</code></a></dt>
<dd>
<p>An alternative implementation with slightly different features. For a detailed discussion on the differences see <a class="reference internal" href="#differences-pcolor-pcolormesh"><span class="std std-ref">Differences between pcolor() and pcolormesh()</span></a>.</p> </dd> <dt><a class="reference internal" href="matplotlib.pyplot.imshow.html#matplotlib.pyplot.imshow" title="matplotlib.pyplot.imshow"><code>imshow</code></a></dt>
<dd>
<p>If <em>X</em> and <em>Y</em> are each equidistant, <a class="reference internal" href="matplotlib.axes.axes.imshow.html#matplotlib.axes.Axes.imshow" title="matplotlib.axes.Axes.imshow"><code>imshow</code></a> can be a faster alternative.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p><strong>Masked arrays</strong></p> <p><em>C</em> may be a masked array. If <code>C[i, j]</code> is masked, the corresponding quadrilateral will be transparent. Masking of <em>X</em> and <em>Y</em> is not supported. Use <a class="reference internal" href="matplotlib.axes.axes.pcolor.html#matplotlib.axes.Axes.pcolor" title="matplotlib.axes.Axes.pcolor"><code>pcolor</code></a> if you need this functionality.</p> <p id="axes-pcolormesh-grid-orientation"><strong>Grid orientation</strong></p> <p>The grid orientation follows the standard matrix convention: An array <em>C</em> with shape (nrows, ncolumns) is plotted with the column number as <em>X</em> and the row number as <em>Y</em>.</p> <p id="differences-pcolor-pcolormesh"><strong>Differences between pcolor() and pcolormesh()</strong></p> <p>Both methods are used to create a pseudocolor plot of a 2D array using quadrilaterals.</p> <p>The main difference lies in the created object and internal data handling: While <a class="reference internal" href="matplotlib.axes.axes.pcolor.html#matplotlib.axes.Axes.pcolor" title="matplotlib.axes.Axes.pcolor"><code>pcolor</code></a> returns a <a class="reference internal" href="../collections_api.html#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><code>PolyCollection</code></a>, <a class="reference internal" href="matplotlib.axes.axes.pcolormesh.html#matplotlib.axes.Axes.pcolormesh" title="matplotlib.axes.Axes.pcolormesh"><code>pcolormesh</code></a> returns a <a class="reference internal" href="../collections_api.html#matplotlib.collections.QuadMesh" title="matplotlib.collections.QuadMesh"><code>QuadMesh</code></a>. The latter is more specialized for the given purpose and thus is faster. It should almost always be preferred.</p> <p>There is also a slight difference in the handling of masked arrays. Both <a class="reference internal" href="matplotlib.axes.axes.pcolor.html#matplotlib.axes.Axes.pcolor" title="matplotlib.axes.Axes.pcolor"><code>pcolor</code></a> and <a class="reference internal" href="matplotlib.axes.axes.pcolormesh.html#matplotlib.axes.Axes.pcolormesh" title="matplotlib.axes.Axes.pcolormesh"><code>pcolormesh</code></a> support masked arrays for <em>C</em>. However, only <a class="reference internal" href="matplotlib.axes.axes.pcolor.html#matplotlib.axes.Axes.pcolor" title="matplotlib.axes.Axes.pcolor"><code>pcolor</code></a> supports masked arrays for <em>X</em> and <em>Y</em>. The reason lies in the internal handling of the masked values. <a class="reference internal" href="matplotlib.axes.axes.pcolor.html#matplotlib.axes.Axes.pcolor" title="matplotlib.axes.Axes.pcolor"><code>pcolor</code></a> leaves out the respective polygons from the PolyCollection. <a class="reference internal" href="matplotlib.axes.axes.pcolormesh.html#matplotlib.axes.Axes.pcolormesh" title="matplotlib.axes.Axes.pcolormesh"><code>pcolormesh</code></a> sets the facecolor of the masked elements to transparent. You can see the difference when using edgecolors. While all edges are drawn irrespective of masking in a QuadMesh, the edge between two adjacent masked quadrilaterals in <a class="reference internal" href="matplotlib.axes.axes.pcolor.html#matplotlib.axes.Axes.pcolor" title="matplotlib.axes.Axes.pcolor"><code>pcolor</code></a> is not drawn as the corresponding polygons do not exist in the PolyCollection.</p> <p>Another difference is the support of Gouraud shading in <a class="reference internal" href="matplotlib.axes.axes.pcolormesh.html#matplotlib.axes.Axes.pcolormesh" title="matplotlib.axes.Axes.pcolormesh"><code>pcolormesh</code></a>, which is not available with <a class="reference internal" href="matplotlib.axes.axes.pcolor.html#matplotlib.axes.Axes.pcolor" title="matplotlib.axes.Axes.pcolor"><code>pcolor</code></a>.</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2023 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.pcolormesh.html" class="_attribution-link">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.pcolormesh.html</a>
  </p>
</div>
