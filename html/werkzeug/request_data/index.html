<h1>Dealing with Request Data</h1> <p>The most important rule about web development is “Do not trust the user”. This is especially true for incoming request data on the input stream. With WSGI this is actually a bit harder than you would expect. Because of that Werkzeug wraps the request stream for you to save you from the most prominent problems with it.</p> <section id="missing-eof-marker-on-input-stream"> <h2>Missing EOF Marker on Input Stream</h2> <p>The input stream has no end-of-file marker. If you would call the <code>read()</code> method on the <code>wsgi.input</code> stream you would cause your application to hang on conforming servers. This is actually intentional however painful. Werkzeug solves that problem by wrapping the input stream in a special <code>LimitedStream</code>. The input stream is exposed on the request objects as <code>stream</code>. This one is either an empty stream (if the form data was parsed) or a limited stream with the contents of the input stream.</p> </section> <section id="when-does-werkzeug-parse"> <h2>When does Werkzeug Parse?</h2> <p>Werkzeug parses the incoming data under the following situations:</p> <ul class="simple"> <li>you access either <code>form</code>, <code>files</code>, or <code>stream</code> and the request method was <code>POST</code> or <code>PUT</code>.</li> <li>if you call <code>parse_form_data()</code>.</li> </ul> <p>These calls are not interchangeable. If you invoke <code>parse_form_data()</code> you must not use the request object or at least not the attributes that trigger the parsing process.</p> <p>This is also true if you read from the <code>wsgi.input</code> stream before the parsing.</p> <p><strong>General rule:</strong> Leave the WSGI input stream alone. Especially in WSGI middlewares. Use either the parsing functions or the request object. Do not mix multiple WSGI utility libraries for form data parsing or anything else that works on the input stream.</p> </section> <section id="how-does-it-parse"> <h2>How does it Parse?</h2> <p>The standard Werkzeug parsing behavior handles three cases:</p> <ul class="simple"> <li>input content type was <code>multipart/form-data</code>. In this situation the <code>stream</code> will be empty and <code>form</code> will contain the regular <code>POST</code> / <code>PUT</code> data, <code>files</code> will contain the uploaded files as <code>FileStorage</code> objects.</li> <li>input content type was <code>application/x-www-form-urlencoded</code>. Then the <code>stream</code> will be empty and <code>form</code> will contain the regular <code>POST</code> / <code>PUT</code> data and <code>files</code> will be empty.</li> <li>the input content type was neither of them, <code>stream</code> points to a <code>LimitedStream</code> with the input data for further processing.</li> </ul> <p>Special note on the <code>get_data</code> method: Calling this loads the full request data into memory. This is only safe to do if the <code>max_content_length</code> is set. Also you can <em>either</em> read the stream <em>or</em> call <code>get_data()</code>.</p> </section> <section id="limiting-request-data"> <h2>Limiting Request Data</h2> <p>The <code>Request</code> class provides a few attributes to control how much data is processed from the request body. This can help mitigate DoS attacks that craft the request in such a way that the server uses too many resources to handle it. Each of these limits will raise a <a class="reference internal" href="../exceptions/index.html#werkzeug.exceptions.RequestEntityTooLarge" title="werkzeug.exceptions.RequestEntityTooLarge"><code>RequestEntityTooLarge</code></a> if they are exceeded.</p> <ul class="simple"> <li>
<code>max_content_length</code> - Stop reading request data after this number of bytes. It’s better to configure this in the WSGI server or HTTP server, rather than the WSGI application.</li> <li>
<code>max_form_memory_size</code> - Stop reading request data if any non-file form field is larger than this number of bytes. While file parts can be moved to disk, regular form field data is stored in memory only and could fill up memory. The default is 500kB.</li> <li>
<code>max_form_parts</code> Stop reading request data if more than this number of parts are sent in multipart form data. This is useful to stop a very large number of very small parts, especially file parts. The default is 1000.</li> </ul> <p>Each of these values can be set on the <code>Request</code> class to affect the default for all requests, or on a <code>request</code> instance to change the behavior for a specific request. For example, a small limit can be set by default, and a large limit can be set on an endpoint that accepts video uploads. These values should be tuned to the specific needs of your application and endpoints.</p> <p>Using Werkzeug to set these limits is only one layer of protection. WSGI servers and HTTPS servers should set their own limits on size and timeouts. The operating system or container manager should set limits on memory and processing time for server processes.</p> <p>If a 413 Content Too Large error is returned before the entire request is read, clients may show a “connection reset” failure instead of the 413 error. This is based on how the WSGI/HTTP server and client handle connections, it’s not something the WSGI application (Werkzeug) has control over.</p> </section> <section id="how-to-extend-parsing"> <h2>How to extend Parsing?</h2> <p>Modern web applications transmit a lot more than multipart form data or url encoded data. To extend the capabilities, subclass <code>Request</code> or <code>Request</code> and add or extend methods.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://werkzeug.palletsprojects.com/en/latest/request_data/" class="_attribution-link">https://werkzeug.palletsprojects.com/en/latest/request_data/</a>
  </p>
</div>
