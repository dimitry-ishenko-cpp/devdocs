<h1 class="devsite-page-title" tabindex="-1"> tf.compat.v1.variable_scope </h1> <devsite-feature-tooltip ack-key="AckCollectionsBookmarkTooltipDismiss" analytics-category="Site-Wide Custom Events" analytics-action-show="Callout Profile displayed" analytics-action-close="Callout Profile dismissed" analytics-label="Create Collection Callout" class="devsite-page-bookmark-tooltip nocontent" dismiss-button="true" id="devsite-collections-dropdown" dismiss-button-text="Dismiss" close-button-text="Got it">    </devsite-feature-tooltip> <div class="devsite-page-title-meta"><devsite-view-release-notes></devsite-view-release-notes></div>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.compat.v1.variable_scope"> <meta itemprop="path" content="Stable"> <meta itemprop="property" content="__enter__"> <meta itemprop="property" content="__exit__"> <meta itemprop="property" content="__init__"> </div>   <p>A context manager for defining ops that creates variables (layers).</p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.compat.v1.variable_scope(
    name_or_scope,
    default_name=None,
    values=None,
    initializer=None,
    regularizer=None,
    caching_device=None,
    partitioner=None,
    custom_getter=None,
    reuse=None,
    dtype=None,
    use_resource=None,
    constraint=None,
    auxiliary_name_scope=True
)
</pre></devsite-code> <p><section><devsite-expandable expanded> <h2 class="showalways" id="migrate-to-tf2" data-text="Migrate to TF2" tabindex="-1">Migrate to TF2</h2></devsite-expandable></section></p> <aside class="caution"><strong>Caution:</strong><span> This API was designed for TensorFlow v1. Continue reading for details on how to migrate from this API to a native TensorFlow v2 equivalent. See the <a href="https://www.tensorflow.org/guide/migrate">TensorFlow v1 to TensorFlow v2 migration guide</a> for instructions on how to migrate the rest of your code.</span></aside> <p>Although it is a legacy <a href="../v1.html"><code translate="no" dir="ltr">compat.v1</code></a> api, <a href="variable_scope.html"><code translate="no" dir="ltr">tf.compat.v1.variable_scope</code></a> is mostly compatible with eager execution and <a href="../../function.html"><code translate="no" dir="ltr">tf.function</code></a> as long as you combine it with the <code translate="no" dir="ltr">tf.compat.v1.keras.utils.track_tf1_style_variables</code> decorator (though it will behave as if reuse is always set to <code translate="no" dir="ltr">AUTO_REUSE</code>.)</p> <p>See the <a href="https://www.tensorflow.org/guide/migrate/model_mapping">model migration guide</a> for more info on migrating code that relies on <code translate="no" dir="ltr">variable_scope</code>-based variable reuse.</p> <p>When you use it with eager execution enabled but without <code translate="no" dir="ltr">tf.compat.v1.keras.utils.track_tf1_style_variables</code>, <a href="variable_scope.html"><code translate="no" dir="ltr">tf.compat.v1.variable_scope</code></a> will still be able to prefix the names of variables created within the scope but it will not enable variable reuse or error-raising checks around variable reuse (<code translate="no" dir="ltr">get_variable</code> calls within it would always create new variables).</p> <p>Once you have switched away from <code translate="no" dir="ltr">get_variable</code>-based variable reuse mechanisms, to switch to TF2 APIs you can just use <a href="../../name_scope.html"><code translate="no" dir="ltr">tf.name_scope</code></a> to prefix variable names.</p>  <h2 id="description" data-text="Description" tabindex="-1">Description</h2> <h3 id="used-in-the-notebooks" data-text="Used in the notebooks" tabindex="-1">Used in the notebooks</h3> <table class="vertical-rules"> <thead> <tr> <th>Used in the guide</th> <th>Used in the tutorials</th> </tr> </thead> <tbody> <tr> <td> <ul> <li><a href="https://www.tensorflow.org/guide/migrate/model_mapping">Use TF1.x models in TF2 workflows</a></li> <li><a href="https://www.tensorflow.org/guide/migrate/migrating_checkpoints">Migrating model checkpoints</a></li> </ul> </td> <td> <ul> <li><a href="https://www.tensorflow.org/probability/examples/HLM_TFP_R_Stan">Linear Mixed-Effect Regression in {TF Probability, R, Stan}</a></li> <li><a href="https://www.tensorflow.org/tfx/tutorials/tfx/neural_structured_learning">Graph-based Neural Structured Learning in TFX</a></li> </ul> </td> </tr> </tbody> </table> <p>This context manager validates that the (optional) <code translate="no" dir="ltr">values</code> are from the same graph, ensures that graph is the default graph, and pushes a name scope and a variable scope.</p> <p>If <code translate="no" dir="ltr">name_or_scope</code> is not None, it is used as is. If <code translate="no" dir="ltr">name_or_scope</code> is None, then <code translate="no" dir="ltr">default_name</code> is used. In that case, if the same name has been previously used in the same scope, it will be made unique by appending <code translate="no" dir="ltr">_N</code> to it.</p> <p>Variable scope allows you to create new variables and to share already created ones while providing checks to not create or share by accident. For details, see the <a href="https://tensorflow.org/guide/variables">Variable Scope How To</a>, here we present only a few basic examples.</p> <p>The Variable Scope works as expected when the Eager Execution is Disabled.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.compat.v1.disable_eager_execution()
</pre></devsite-code> <p>Simple example of how to create a new variable:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">with tf.compat.v1.variable_scope("foo"):
    with tf.compat.v1.variable_scope("bar"):
        v = tf.compat.v1.get_variable("v", [1])
        assert v.name == "foo/bar/v:0"
</pre></devsite-code> <p>Simple example of how to reenter a premade variable scope safely:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">with tf.compat.v1.variable_scope("foo") as vs:
  pass

# Re-enter the variable scope.
with tf.compat.v1.variable_scope(vs,
                       auxiliary_name_scope=False) as vs1:
  # Restore the original name_scope.
  with tf.name_scope(vs1.original_name_scope):
      v = tf.compat.v1.get_variable("v", [1])
      assert v.name == "foo/v:0"
      c = tf.constant([1], name="c")
      assert c.name == "foo/c:0"
</pre></devsite-code> <p>Keep in mind that the counters for <code translate="no" dir="ltr">default_name</code> are discarded once the parent scope is exited. Therefore when the code re-enters the scope (for instance by saving it), all nested default_name counters will be restarted.</p> <h4 id="for_instance" data-text="For instance:" tabindex="-1">For instance:</h4> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">with tf.compat.v1.variable_scope("foo") as vs:
  with tf.compat.v1.variable_scope(None, default_name="bar"):
    v = tf.compat.v1.get_variable("a", [1])
    assert v.name == "foo/bar/a:0", v.name
  with tf.compat.v1.variable_scope(None, default_name="bar"):
    v = tf.compat.v1.get_variable("b", [1])
    assert v.name == "foo/bar_1/b:0"

with tf.compat.v1.variable_scope(vs):
  with tf.compat.v1.variable_scope(None, default_name="bar"):
    v = tf.compat.v1.get_variable("c", [1])
    assert v.name == "foo/bar/c:0"   # Uses bar instead of bar_2!
</pre></devsite-code> <p>Basic example of sharing a variable AUTO_REUSE:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def foo():
  with tf.compat.v1.variable_scope("foo", reuse=tf.compat.v1.AUTO_REUSE):
    v = tf.compat.v1.get_variable("v", [1])
  return v

v1 = foo()  # Creates v.
v2 = foo()  # Gets the same, existing v.
assert v1 == v2
</pre></devsite-code> <p>Basic example of sharing a variable with reuse=True:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">with tf.compat.v1.variable_scope("foo"):
    v = tf.compat.v1.get_variable("v", [1])
with tf.compat.v1.variable_scope("foo", reuse=True):
    v1 = tf.compat.v1.get_variable("v", [1])
assert v1 == v
</pre></devsite-code> <p>Sharing a variable by capturing a scope and setting reuse:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">with tf.compat.v1.variable_scope("foo") as scope:
    v = tf.compat.v1.get_variable("v", [1])
    scope.reuse_variables()
    v1 = tf.compat.v1.get_variable("v", [1])
assert v1 == v
</pre></devsite-code> <p>To prevent accidental sharing of variables, we raise an exception when getting an existing variable in a non-reusing scope.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">with tf.compat.v1.variable_scope("foo"):
    v = tf.compat.v1.get_variable("v", [1])
    v1 = tf.compat.v1.get_variable("v", [1])
    #  Raises ValueError("... v already exists ...").
</pre></devsite-code> <p>Similarly, we raise an exception when trying to get a variable that does not exist in reuse mode.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">with tf.compat.v1.variable_scope("foo", reuse=True):
    v = tf.compat.v1.get_variable("v", [1])
    #  Raises ValueError("... v does not exists ...").
</pre></devsite-code> <p>Note that the <code translate="no" dir="ltr">reuse</code> flag is inherited: if we open a reusing scope, then all its sub-scopes become reusing as well.</p> <p>A note about name scoping: Setting <code translate="no" dir="ltr">reuse</code> does not impact the naming of other ops such as mult. See related discussion on <a href="https://github.com/tensorflow/tensorflow/issues/6189">github#6189</a></p> <p>Note that up to and including version 1.0, it was allowed (though explicitly discouraged) to pass False to the reuse argument, yielding undocumented behaviour slightly different from None. Starting at 1.1.0 passing None and False as reuse has exactly the same effect.</p> <p>A note about using variable scopes in multi-threaded environment: Variable scopes are thread local, so one thread will not see another thread's current scope. Also, when using <code translate="no" dir="ltr">default_name</code>, unique scopes names are also generated only on a per thread basis. If the same name was used within a different thread, that doesn't prevent a new thread from creating the same scope. However, the underlying variable store is shared across threads (within the same graph). As such, if another thread tries to create a new variable with the same name as a variable created by a previous thread, it will fail unless reuse is True.</p> <p>Further, each thread starts with an empty variable scope. So if you wish to preserve name prefixes from a scope from the main thread, you should capture the main thread's scope and re-enter it in each thread. For e.g.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">main_thread_scope = variable_scope.get_variable_scope()

# Thread's target function:
def thread_target_fn(captured_scope):
  with variable_scope.variable_scope(captured_scope):
    # .... regular code for this thread


thread = threading.Thread(target=thread_target_fn, args=(main_thread_scope,))
</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name_or_scope</code> </td> <td> <code translate="no" dir="ltr">string</code> or <code translate="no" dir="ltr">VariableScope</code>: the scope to open. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">default_name</code> </td> <td> The default name to use if the <code translate="no" dir="ltr">name_or_scope</code> argument is <code translate="no" dir="ltr">None</code>, this name will be uniquified. If name_or_scope is provided it won't be used and therefore it is not required and can be None. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">values</code> </td> <td> The list of <code translate="no" dir="ltr">Tensor</code> arguments that are passed to the op function. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">initializer</code> </td> <td> default initializer for variables within this scope. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">regularizer</code> </td> <td> default regularizer for variables within this scope. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">caching_device</code> </td> <td> default caching device for variables within this scope. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">partitioner</code> </td> <td> default partitioner for variables within this scope. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">custom_getter</code> </td> <td> default custom getter for variables within this scope. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">reuse</code> </td> <td> <code translate="no" dir="ltr">True</code>, None, or tf.compat.v1.AUTO_REUSE; if <code translate="no" dir="ltr">True</code>, we go into reuse mode for this scope as well as all sub-scopes; if tf.compat.v1.AUTO_REUSE, we create variables if they do not exist, and return them otherwise; if None, we inherit the parent scope's reuse flag. When eager execution is enabled, new variables are always created unless an EagerVariableStore or template is currently active. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> type of variables created in this scope (defaults to the type in the passed scope, or inherited from parent scope). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">use_resource</code> </td> <td> If False, all variables will be regular Variables. If True, experimental ResourceVariables with well-defined semantics will be used instead. Defaults to False (will later change to True). When eager execution is enabled this argument is always forced to be True. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">constraint</code> </td> <td> An optional projection function to be applied to the variable after being updated by an <code translate="no" dir="ltr">Optimizer</code> (e.g. used to implement norm constraints or value constraints for layer weights). The function must take as input the unprojected Tensor representing the value of the variable and return the Tensor for the projected value (which must have the same shape). Constraints are not safe to use when doing asynchronous distributed training. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">auxiliary_name_scope</code> </td> <td> If <code translate="no" dir="ltr">True</code>, we create an auxiliary name scope with the scope. If <code translate="no" dir="ltr">False</code>, we don't create it. Note that the argument is not inherited, and it only takes effect for once when creating. You should only use it for re-entering a premade variable scope. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> when trying to reuse within a create scope, or create within a reuse scope. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> when the types of some arguments are not appropriate. </td> </tr> </table> <h2 id="methods" data-text="Methods" tabindex="-1">Methods</h2> <h3 id="__enter__" data-text="__enter__" tabindex="-1"><code translate="no" dir="ltr">__enter__</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/variable_scope.py#L2370-L2394">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">__enter__()
</pre></devsite-code> <h3 id="__exit__" data-text="__exit__" tabindex="-1"><code translate="no" dir="ltr">__exit__</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/variable_scope.py#L2515-L2527">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">__exit__(
    type_arg, value_arg, traceback_arg
)
</pre></devsite-code>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/compat/v1/variable_scope" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/compat/v1/variable_scope</a>
  </p>
</div>
