<h1 class="devsite-page-title">tf.compat.v1.train.shuffle_batch_join</h1> <devsite-bookmark></devsite-bookmark>       <p>Create batches by randomly shuffling tensors. (deprecated)</p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.compat.v1.train.shuffle_batch_join(
    tensors_list,
    batch_size,
    capacity,
    min_after_dequeue,
    seed=None,
    enqueue_many=False,
    shapes=None,
    allow_smaller_final_batch=False,
    shared_name=None,
    name=None
)
</pre>  <aside class="deprecated"><strong>Deprecated:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Queue-based input pipelines have been replaced by <a href="../../../data.html"><code translate="no" dir="ltr">tf.data</code></a>. Use <code translate="no" dir="ltr">tf.data.Dataset.interleave(...).shuffle(min_after_dequeue).batch(batch_size)</code>.</span></aside> <p>The <code translate="no" dir="ltr">tensors_list</code> argument is a list of tuples of tensors, or a list of dictionaries of tensors. Each element in the list is treated similarly to the <code translate="no" dir="ltr">tensors</code> argument of <a href="shuffle_batch.html"><code translate="no" dir="ltr">tf.compat.v1.train.shuffle_batch()</code></a>.</p> <p>This version enqueues a different list of tensors in different threads. It adds the following to the current <code translate="no" dir="ltr">Graph</code>:</p> <ul> <li>A shuffling queue into which tensors from <code translate="no" dir="ltr">tensors_list</code> are enqueued.</li> <li>A <code translate="no" dir="ltr">dequeue_many</code> operation to create batches from the queue.</li> <li>A <code translate="no" dir="ltr">QueueRunner</code> to <code translate="no" dir="ltr">QUEUE_RUNNER</code> collection, to enqueue the tensors from <code translate="no" dir="ltr">tensors_list</code>.</li> </ul> <p><code translate="no" dir="ltr">len(tensors_list)</code> threads will be started, with thread <code translate="no" dir="ltr">i</code> enqueuing the tensors from <code translate="no" dir="ltr">tensors_list[i]</code>. <code translate="no" dir="ltr">tensors_list[i1][j]</code> must match <code translate="no" dir="ltr">tensors_list[i2][j]</code> in type and shape, except in the first dimension if <code translate="no" dir="ltr">enqueue_many</code> is true.</p> <p>If <code translate="no" dir="ltr">enqueue_many</code> is <code translate="no" dir="ltr">False</code>, each <code translate="no" dir="ltr">tensors_list[i]</code> is assumed to represent a single example. An input tensor with shape <code translate="no" dir="ltr">[x, y, z]</code> will be output as a tensor with shape <code translate="no" dir="ltr">[batch_size, x, y, z]</code>.</p> <p>If <code translate="no" dir="ltr">enqueue_many</code> is <code translate="no" dir="ltr">True</code>, <code translate="no" dir="ltr">tensors_list[i]</code> is assumed to represent a batch of examples, where the first dimension is indexed by example, and all members of <code translate="no" dir="ltr">tensors_list[i]</code> should have the same size in the first dimension. If an input tensor has shape <code translate="no" dir="ltr">[*, x, y, z]</code>, the output will have shape <code translate="no" dir="ltr">[batch_size, x, y, z]</code>.</p> <p>The <code translate="no" dir="ltr">capacity</code> argument controls the how long the prefetching is allowed to grow the queues.</p> <p>The returned operation is a dequeue operation and will throw <a href="../../../errors/outofrangeerror.html"><code translate="no" dir="ltr">tf.errors.OutOfRangeError</code></a> if the input queue is exhausted. If this operation is feeding another input queue, its queue runner will catch this exception, however, if this operation is used in your main thread you are responsible for catching this yourself.</p> <p>If <code translate="no" dir="ltr">allow_smaller_final_batch</code> is <code translate="no" dir="ltr">True</code>, a smaller batch value than <code translate="no" dir="ltr">batch_size</code> is returned when the queue is closed and there are not enough elements to fill the batch, otherwise the pending elements are discarded. In addition, all output tensors' static shapes, as accessed via the <code translate="no" dir="ltr">shape</code> property will have a first <code translate="no" dir="ltr">Dimension</code> value of <code translate="no" dir="ltr">None</code>, and operations that depend on fixed batch_size would fail.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">tensors_list</code> </td> <td> A list of tuples or dictionaries of tensors to enqueue. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">batch_size</code> </td> <td> An integer. The new batch size pulled from the queue. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">capacity</code> </td> <td> An integer. The maximum number of elements in the queue. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">min_after_dequeue</code> </td> <td> Minimum number elements in the queue after a dequeue, used to ensure a level of mixing of elements. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">seed</code> </td> <td> Seed for the random shuffling within the queue. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">enqueue_many</code> </td> <td> Whether each tensor in <code translate="no" dir="ltr">tensor_list_list</code> is a single example. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shapes</code> </td> <td> (Optional) The shapes for each example. Defaults to the inferred shapes for <code translate="no" dir="ltr">tensors_list[i]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">allow_smaller_final_batch</code> </td> <td> (Optional) Boolean. If <code translate="no" dir="ltr">True</code>, allow the final batch to be smaller if there are insufficient items left in the queue. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shared_name</code> </td> <td> (optional). If set, this queue will be shared under the given name across multiple sessions. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional) A name for the operations. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A list or dictionary of tensors with the same number and types as <code translate="no" dir="ltr">tensors_list[i]</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If the <code translate="no" dir="ltr">shapes</code> are not specified, and cannot be inferred from the elements of <code translate="no" dir="ltr">tensors_list</code>. </td> </tr> </table> <p><section><devsite-expandable expanded> <h2 class="showalways" id="eager-compatibility" data-text="eager compatibility">eager compatibility</h2></devsite-expandable></section></p> <p>Input pipelines based on Queues are not supported when eager execution is enabled. Please use the <a href="../../../data.html"><code translate="no" dir="ltr">tf.data</code></a> API to ingest data under eager execution.</p>   <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/compat/v1/train/shuffle_batch_join" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/compat/v1/train/shuffle_batch_join</a>
  </p>
</div>
