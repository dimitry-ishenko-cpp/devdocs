<h1 class="devsite-page-title">tf.nn.isotonic_regression</h1> <devsite-bookmark></devsite-bookmark>   <p><devsite-mathjax config="TeX-AMS-MML_SVG"></devsite-mathjax> </p>    <p>Solves isotonic regression problems along the given axis.</p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.nn.isotonic_regression(
    inputs, decreasing=True, axis=-1
)
</pre>  <p>For each vector x, the problem solved is</p> <p>\[\argmin_{y_1 &gt;= y_2 &gt;= ... &gt;= y_n} \sum_i (x_i - y_i)^2.\]</p> <p>As the solution is component-wise constant, a second tensor is returned that encodes the segments. The problems are solved over the given axis.</p> <p>Consider the following example, where we solve a batch of two problems. The first input is [3, 1, 2], while the second <a href="as%20the%20axis%20is%201.html">1, 3, 4</a>.</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; x = tf.constant([[3, 1, 2], [1, 3, 4]], dtype=tf.float32)
&gt;&gt;&gt; y, segments = tf.nn.isotonic_regression(x, axis=1)
&gt;&gt;&gt; y  # The solution.
&lt;tf.Tensor: shape=(2, 3), dtype=float32, numpy=
array([[3.       , 1.5      , 1.5      ],
       [2.6666667, 2.6666667, 2.6666667]], dtype=float32)&gt;
</pre> <p>Note that the first solution has two blocks [2] and [1.5, 1.5]. The second solution is constant, and thus has a single segment. These segments are exactly what the second returned tensor encodes:</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
segments
&lt;tf.Tensor: shape=(2, 3), dtype=int32, numpy=
array([[0, 1, 1],
       [0, 0, 0]], dtype=int32)&gt;
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">inputs</code> </td> <td> A tensor holding the inputs. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">decreasing</code> </td> <td> If set to False, the inequalities in the optimizing constrained are flipped. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">axis</code> </td> <td> The axis along which the problems should be solved. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">output</code> </td> <td> The solutions, same shape as type as the input. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">segments</code> </td> <td> An int32 tensor, same shape as the input indicating the segments that have the same value. Specifically, those positions that have the same value correspond to the same segment. These values start at zero, and are monotonously increasing for each solution. </td> </tr> </table>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/nn/isotonic_regression" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/nn/isotonic_regression</a>
  </p>
</div>
