<h1 class="devsite-page-title" tabindex="-1"> tf.gather </h1> <devsite-feature-tooltip ack-key="AckCollectionsBookmarkTooltipDismiss" analytics-category="Site-Wide Custom Events" analytics-action-show="Callout Profile displayed" analytics-action-close="Callout Profile dismissed" analytics-label="Create Collection Callout" class="devsite-page-bookmark-tooltip nocontent" dismiss-button="true" id="devsite-collections-dropdown" dismiss-button-text="Dismiss" close-button-text="Got it">    </devsite-feature-tooltip> <div class="devsite-page-title-meta"><devsite-view-release-notes></devsite-view-release-notes></div>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.gather"> <meta itemprop="path" content="Stable"> </div>   <p>Gather slices from params axis <code translate="no" dir="ltr">axis</code> according to indices. (deprecated arguments)</p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.gather(
    params, indices, validate_indices=None, axis=None, batch_dims=0, name=None
)
</pre></devsite-code> <h3 id="used-in-the-notebooks" data-text="Used in the notebooks" tabindex="-1">Used in the notebooks</h3> <table class="vertical-rules"> <thead> <tr> <th>Used in the guide</th> <th>Used in the tutorials</th> </tr> </thead> <tbody> <tr> <td> <ul> <li><a href="https://www.tensorflow.org/guide/intro_to_graphs">Introduction to graphs and tf.function</a></li> <li><a href="https://www.tensorflow.org/guide/tensor_slicing">Introduction to tensor slicing</a></li> <li><a href="https://www.tensorflow.org/guide/extension_type">Extension types</a></li> <li><a href="https://www.tensorflow.org/text/guide/bert_preprocessing_guide">BERT Preprocessing with TF Text</a></li> <li><a href="https://www.tensorflow.org/text/guide/subwords_tokenizer">Subword tokenizers</a></li> </ul> </td> <td> <ul> <li><a href="https://www.tensorflow.org/tutorials/audio/simple_audio">Simple audio recognition: Recognizing keywords</a></li> <li><a href="https://www.tensorflow.org/tutorials/images/segmentation">Image segmentation</a></li> <li><a href="https://www.tensorflow.org/probability/examples/Multilevel_Modeling_Primer">Multilevel Modeling Primer in TensorFlow Probability</a></li> <li><a href="https://www.tensorflow.org/hub/tutorials/movinet">MoViNet for streaming action recognition</a></li> <li><a href="https://www.tensorflow.org/federated/tutorials/sparse_federated_learning">Client-efficient large-model federated learning via `federated_select` and sparse aggregation</a></li> </ul> </td> </tr> </tbody> </table> <aside class="deprecated"><strong>Deprecated:</strong><span> SOME ARGUMENTS ARE DEPRECATED: <code translate="no" dir="ltr">(validate_indices)</code>. They will be removed in a future version. Instructions for updating: The <code translate="no" dir="ltr">validate_indices</code> argument has no effect. Indices are always validated on CPU and never validated on GPU.</span></aside> <p>Gather slices from <code translate="no" dir="ltr">params</code> axis <code translate="no" dir="ltr">axis</code> according to <code translate="no" dir="ltr">indices</code>. <code translate="no" dir="ltr">indices</code> must be an integer tensor of any dimension (often 1-D).</p> <p><a href="tensor.html#__getitem__"><code translate="no" dir="ltr">Tensor.<strong>getitem</strong></code></a> works for scalars, <a href="../tf.html#newaxis"><code translate="no" dir="ltr">tf.newaxis</code></a>, and <a href="https://numpy.org/doc/stable/reference/arrays.indexing.html#basic-slicing-and-indexing">python slices</a></p> <p><a href="gather.html"><code translate="no" dir="ltr">tf.gather</code></a> extends indexing to handle tensors of indices.</p> <p>In the simplest case it's identical to scalar indexing:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">params = tf.constant(['p0', 'p1', 'p2', 'p3', 'p4', 'p5'])
params[3].numpy()
b'p3'
tf.gather(params, 3).numpy()
b'p3'</pre></devsite-code> <p>The most common case is to pass a single axis tensor of indices (this can't be expressed as a python slice because the indices are not sequential):</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">indices = [2, 0, 2, 5]
tf.gather(params, indices).numpy()
array([b'p2', b'p0', b'p2', b'p5'], dtype=object)</pre></devsite-code> <div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"> <img style="width:100%" src="data:image/png;base64,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" alt> </div> <p>The indices can have any shape. When the <code translate="no" dir="ltr">params</code> has 1 axis, the output shape is equal to the input shape:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.gather(params, [[2, 0], [2, 5]]).numpy()
array([[b'p2', b'p0'],
       [b'p2', b'p5']], dtype=object)</pre></devsite-code> <p>The <code translate="no" dir="ltr">params</code> may also have any shape. <code translate="no" dir="ltr">gather</code> can select slices across any axis depending on the <code translate="no" dir="ltr">axis</code> argument (which defaults to 0). Below it is used to gather first rows, then columns from a matrix:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">params = tf.constant([[0, 1.0, 2.0],
                      [10.0, 11.0, 12.0],
                      [20.0, 21.0, 22.0],
                      [30.0, 31.0, 32.0]])
tf.gather(params, indices=[3,1]).numpy()
array([[30., 31., 32.],
       [10., 11., 12.]], dtype=float32)
tf.gather(params, indices=[2,1], axis=1).numpy()
array([[ 2.,  1.],
       [12., 11.],
       [22., 21.],
       [32., 31.]], dtype=float32)</pre></devsite-code> <p>More generally: The output shape has the same shape as the input, with the indexed-axis replaced by the shape of the indices.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def result_shape(p_shape, i_shape, axis=0):
  return p_shape[:axis] + i_shape + p_shape[axis+1:]

result_shape([1, 2, 3], [], axis=1)
[1, 3]
result_shape([1, 2, 3], [7], axis=1)
[1, 7, 3]
result_shape([1, 2, 3], [7, 5], axis=1)
[1, 7, 5, 3]</pre></devsite-code> <p>Here are some examples:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">params.shape.as_list()
[4, 3]
indices = tf.constant([[0, 2]])
tf.gather(params, indices=indices, axis=0).shape.as_list()
[1, 2, 3]
tf.gather(params, indices=indices, axis=1).shape.as_list()
[4, 1, 2]</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">params = tf.random.normal(shape=(5, 6, 7, 8))
indices = tf.random.uniform(shape=(10, 11), maxval=7, dtype=tf.int32)
result = tf.gather(params, indices, axis=2)
result.shape.as_list()
[5, 6, 10, 11, 8]</pre></devsite-code> <p>This is because each index takes a slice from <code translate="no" dir="ltr">params</code>, and places it at the corresponding location in the output. For the above example</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># For any location in indices
a, b = 0, 1
tf.reduce_all(
    # the corresponding slice of the result
    result[:, :, a, b, :] ==
    # is equal to the slice of `params` along `axis` at the index.
    params[:, :, indices[a, b], :]
).numpy()
True</pre></devsite-code> <h3 id="batching" data-text="Batching:" tabindex="-1">Batching:</h3> <p>The <code translate="no" dir="ltr">batch_dims</code> argument lets you gather different items from each element of a batch.</p> <p>Using <code translate="no" dir="ltr">batch_dims=1</code> is equivalent to having an outer loop over the first axis of <code translate="no" dir="ltr">params</code> and <code translate="no" dir="ltr">indices</code>:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">params = tf.constant([
    [0, 0, 1, 0, 2],
    [3, 0, 0, 0, 4],
    [0, 5, 0, 6, 0]])
indices = tf.constant([
    [2, 4],
    [0, 4],
    [1, 3]])</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.gather(params, indices, axis=1, batch_dims=1).numpy()
array([[1, 2],
       [3, 4],
       [5, 6]], dtype=int32)</pre></devsite-code> <h4 id="this_is_equivalent_to" data-text="This is equivalent to:" tabindex="-1">This is equivalent to:</h4> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def manually_batched_gather(params, indices, axis):
  batch_dims=1
  result = []
  for p,i in zip(params, indices):
    r = tf.gather(p, i, axis=axis-batch_dims)
    result.append(r)
  return tf.stack(result)
manually_batched_gather(params, indices, axis=1).numpy()
array([[1, 2],
       [3, 4],
       [5, 6]], dtype=int32)</pre></devsite-code> <p>Higher values of <code translate="no" dir="ltr">batch_dims</code> are equivalent to multiple nested loops over the outer axes of <code translate="no" dir="ltr">params</code> and <code translate="no" dir="ltr">indices</code>. So the overall shape function is</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def batched_result_shape(p_shape, i_shape, axis=0, batch_dims=0):
  return p_shape[:axis] + i_shape[batch_dims:] + p_shape[axis+1:]

batched_result_shape(
    p_shape=params.shape.as_list(),
    i_shape=indices.shape.as_list(),
    axis=1,
    batch_dims=1)
[3, 2]</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.gather(params, indices, axis=1, batch_dims=1).shape.as_list()
[3, 2]</pre></devsite-code> <p>This comes up naturally if you need to use the indices of an operation like <a href="argsort.html"><code translate="no" dir="ltr">tf.argsort</code></a>, or <a href="math/top_k.html"><code translate="no" dir="ltr">tf.math.top_k</code></a> where the last dimension of the indices indexes into the last dimension of input, at the corresponding location. In this case you can use <code translate="no" dir="ltr">tf.gather(values, indices, batch_dims=-1)</code>.</p> <h4 id="see_also" data-text="See also:" tabindex="-1">See also:</h4> <ul> <li>
<a href="tensor.html#__getitem__"><code translate="no" dir="ltr">tf.Tensor.<strong>getitem</strong></code></a>: The direct tensor index operation (<code translate="no" dir="ltr">t[]</code>), handles scalars and python-slices <code translate="no" dir="ltr">tensor[..., 7, 1:-1]</code>
</li> <li>
<code translate="no" dir="ltr">tf.scatter</code>: A collection of operations similar to <code translate="no" dir="ltr">__setitem__</code> (<code translate="no" dir="ltr">t[i] = x</code>)</li> <li>
<a href="gather_nd.html"><code translate="no" dir="ltr">tf.gather_nd</code></a>: An operation similar to <a href="gather.html"><code translate="no" dir="ltr">tf.gather</code></a> but gathers across multiple axis at once (it can gather elements of a matrix instead of rows or columns)</li> <li>
<a href="boolean_mask.html"><code translate="no" dir="ltr">tf.boolean_mask</code></a>, <a href="where.html"><code translate="no" dir="ltr">tf.where</code></a>: Binary indexing.</li> <li>
<a href="slice.html"><code translate="no" dir="ltr">tf.slice</code></a> and <a href="strided_slice.html"><code translate="no" dir="ltr">tf.strided_slice</code></a>: For lower level access to the implementation of <code translate="no" dir="ltr">__getitem__</code>'s python-slice handling (<code translate="no" dir="ltr">t[1:-1:2]</code>)</li> </ul>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">params</code> </td> <td> The <code translate="no" dir="ltr">Tensor</code> from which to gather values. Must be at least rank <code translate="no" dir="ltr">axis + 1</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">indices</code> </td> <td> The index <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>. The values must be in range <code translate="no" dir="ltr">[0, params.shape[axis])</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate_indices</code> </td> <td> Deprecated, does nothing. Indices are always validated on CPU, never validated on GPU. <aside class="caution"><strong>Caution:</strong><span> On CPU, if an out of bound index is found, an error is raised. On GPU, if an out of bound index is found, a 0 is stored in the corresponding output value. </span></aside>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">axis</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>. The <code translate="no" dir="ltr">axis</code> in <code translate="no" dir="ltr">params</code> to gather <code translate="no" dir="ltr">indices</code> from. Must be greater than or equal to <code translate="no" dir="ltr">batch_dims</code>. Defaults to the first non-batch dimension. Supports negative indexes. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">batch_dims</code> </td> <td> An <code translate="no" dir="ltr">integer</code>. The number of batch dimensions. Must be less than or equal to <code translate="no" dir="ltr">rank(indices)</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. Has the same type as <code translate="no" dir="ltr">params</code>. </td> </tr> 
</table>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/gather" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/gather</a>
  </p>
</div>
