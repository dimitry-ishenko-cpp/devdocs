<h1 class="devsite-page-title">tf.keras.layers.LSTMCell</h1> <devsite-bookmark></devsite-bookmark>      <table class="tfo-notebook-buttons tfo-api nocontent" align="left">  <td> <a target="_blank" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/rnn/lstm.py#L44-L343">  View source on GitHub </a> </td> </table> <p>Cell class for the LSTM layer.</p> <p>Inherits From: <a href="layer.html"><code translate="no" dir="ltr">Layer</code></a>, <a href="../../module.html"><code translate="no" dir="ltr">Module</code></a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.keras.layers.LSTMCell(
    units,
    activation='tanh',
    recurrent_activation='sigmoid',
    use_bias=True,
    kernel_initializer='glorot_uniform',
    recurrent_initializer='orthogonal',
    bias_initializer='zeros',
    unit_forget_bias=True,
    kernel_regularizer=None,
    recurrent_regularizer=None,
    bias_regularizer=None,
    kernel_constraint=None,
    recurrent_constraint=None,
    bias_constraint=None,
    dropout=0.0,
    recurrent_dropout=0.0,
    **kwargs
)
</pre>  <p>See <a href="https://www.tensorflow.org/guide/keras/rnn">the Keras RNN API guide</a> for details about the usage of RNN API.</p> <p>This class processes one step within the whole time sequence input, whereas <code translate="no" dir="ltr">tf.keras.layer.LSTM</code> processes the whole sequence.</p> <h4 id="for_example" data-text="For example:">For example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
inputs = tf.random.normal([32, 10, 8])
rnn = tf.keras.layers.RNN(tf.keras.layers.LSTMCell(4))
output = rnn(inputs)
print(output.shape)
(32, 4)
rnn = tf.keras.layers.RNN(
   tf.keras.layers.LSTMCell(4),
   return_sequences=True,
   return_state=True)
whole_seq_output, final_memory_state, final_carry_state = rnn(inputs)
print(whole_seq_output.shape)
(32, 10, 4)
print(final_memory_state.shape)
(32, 4)
print(final_carry_state.shape)
(32, 4)
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">units</code> </td> <td> Positive integer, dimensionality of the output space. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">activation</code> </td> <td> Activation function to use. Default: hyperbolic tangent (<code translate="no" dir="ltr">tanh</code>). If you pass <code translate="no" dir="ltr">None</code>, no activation is applied (ie. "linear" activation: <code translate="no" dir="ltr">a(x) = x</code>). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">recurrent_activation</code> </td> <td> Activation function to use for the recurrent step. Default: sigmoid (<code translate="no" dir="ltr">sigmoid</code>). If you pass <code translate="no" dir="ltr">None</code>, no activation is applied (ie. "linear" activation: <code translate="no" dir="ltr">a(x) = x</code>). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">use_bias</code> </td> <td> Boolean, (default <code translate="no" dir="ltr">True</code>), whether the layer uses a bias vector. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">kernel_initializer</code> </td> <td> Initializer for the <code translate="no" dir="ltr">kernel</code> weights matrix, used for the linear transformation of the inputs. Default: <code translate="no" dir="ltr">glorot_uniform</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">recurrent_initializer</code> </td> <td> Initializer for the <code translate="no" dir="ltr">recurrent_kernel</code> weights matrix, used for the linear transformation of the recurrent state. Default: <code translate="no" dir="ltr">orthogonal</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">bias_initializer</code> </td> <td> Initializer for the bias vector. Default: <code translate="no" dir="ltr">zeros</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">unit_forget_bias</code> </td> <td> Boolean (default <code translate="no" dir="ltr">True</code>). If True, add 1 to the bias of the forget gate at initialization. Setting it to true will also force <code translate="no" dir="ltr">bias_initializer="zeros"</code>. This is recommended in <a href="http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf">Jozefowicz et al.</a> </td> </tr>
<tr> <td> <code translate="no" dir="ltr">kernel_regularizer</code> </td> <td> Regularizer function applied to the <code translate="no" dir="ltr">kernel</code> weights matrix. Default: <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">recurrent_regularizer</code> </td> <td> Regularizer function applied to the <code translate="no" dir="ltr">recurrent_kernel</code> weights matrix. Default: <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">bias_regularizer</code> </td> <td> Regularizer function applied to the bias vector. Default: <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">kernel_constraint</code> </td> <td> Constraint function applied to the <code translate="no" dir="ltr">kernel</code> weights matrix. Default: <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">recurrent_constraint</code> </td> <td> Constraint function applied to the <code translate="no" dir="ltr">recurrent_kernel</code> weights matrix. Default: <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">bias_constraint</code> </td> <td> Constraint function applied to the bias vector. Default: <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dropout</code> </td> <td> Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. Default: 0. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">recurrent_dropout</code> </td> <td> Float between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state. Default: 0. </td> </tr> </table> <h4 id="call_arguments" data-text="Call arguments:">Call arguments:</h4> <ul> <li>
<b><code translate="no" dir="ltr">inputs</code></b>: A 2D tensor, with shape of <code translate="no" dir="ltr">[batch, feature]</code>.</li> <li>
<b><code translate="no" dir="ltr">states</code></b>: List of 2 tensors that corresponding to the cell's units. Both of them have shape <code translate="no" dir="ltr">[batch, units]</code>, the first tensor is the memory state from previous time step, the second tensor is the carry state from previous time step. For timestep 0, the initial state provided by user will be feed to cell.</li> <li>
<b><code translate="no" dir="ltr">training</code></b>: Python boolean indicating whether the layer should behave in training mode or in inference mode. Only relevant when <code translate="no" dir="ltr">dropout</code> or <code translate="no" dir="ltr">recurrent_dropout</code> is used.</li> </ul> <h2 id="methods" data-text="Methods">Methods</h2> <h3 id="get_dropout_mask_for_cell" data-text="get_dropout_mask_for_cell"><code translate="no" dir="ltr">get_dropout_mask_for_cell</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/rnn/dropout_rnn_cell_mixin.py#L106-L125">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_dropout_mask_for_cell(
    inputs, training, count=1
)
</pre> <p>Get the dropout mask for RNN cell's input.</p> <p>It will create mask based on context if there isn't any existing cached mask. If a new mask is generated, it will update the cache in the cell.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">inputs</code> </td> <td> The input tensor whose shape will be used to generate dropout mask. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">training</code> </td> <td> Boolean tensor, whether its in training mode, dropout will be ignored in non-training mode. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">count</code> </td> <td> Int, how many dropout mask will be generated. It is useful for cell that has internal weights fused together. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> List of mask tensor, generated or cached mask based on context. </td> </tr> 
</table> <h3 id="get_initial_state" data-text="get_initial_state"><code translate="no" dir="ltr">get_initial_state</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/rnn/lstm.py#L341-L343">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_initial_state(
    inputs=None, batch_size=None, dtype=None
)
</pre> <h3 id="get_recurrent_dropout_mask_for_cell" data-text="get_recurrent_dropout_mask_for_cell"><code translate="no" dir="ltr">get_recurrent_dropout_mask_for_cell</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/rnn/dropout_rnn_cell_mixin.py#L127-L146">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_recurrent_dropout_mask_for_cell(
    inputs, training, count=1
)
</pre> <p>Get the recurrent dropout mask for RNN cell.</p> <p>It will create mask based on context if there isn't any existing cached mask. If a new mask is generated, it will update the cache in the cell.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">inputs</code> </td> <td> The input tensor whose shape will be used to generate dropout mask. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">training</code> </td> <td> Boolean tensor, whether its in training mode, dropout will be ignored in non-training mode. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">count</code> </td> <td> Int, how many dropout mask will be generated. It is useful for cell that has internal weights fused together. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> List of mask tensor, generated or cached mask based on context. </td> </tr> 
</table> <h3 id="reset_dropout_mask" data-text="reset_dropout_mask"><code translate="no" dir="ltr">reset_dropout_mask</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/rnn/dropout_rnn_cell_mixin.py#L68-L77">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
reset_dropout_mask()
</pre> <p>Reset the cached dropout masks if any.</p> <p>This is important for the RNN layer to invoke this in it <code translate="no" dir="ltr">call()</code> method so that the cached mask is cleared before calling the <code translate="no" dir="ltr">cell.call()</code>. The mask should be cached across the timestep within the same batch, but shouldn't be cached between batches. Otherwise it will introduce unreasonable bias against certain index of data within the batch.</p> <h3 id="reset_recurrent_dropout_mask" data-text="reset_recurrent_dropout_mask"><code translate="no" dir="ltr">reset_recurrent_dropout_mask</code></h3> <p><a target="_blank" class="external" href="https://github.com/keras-team/keras/tree/v2.9.0/keras/layers/rnn/dropout_rnn_cell_mixin.py#L79-L88">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
reset_recurrent_dropout_mask()
</pre> <p>Reset the cached recurrent dropout masks if any.</p> <p>This is important for the RNN layer to invoke this in it call() method so that the cached mask is cleared before calling the cell.call(). The mask should be cached across the timestep within the same batch, but shouldn't be cached between batches. Otherwise it will introduce unreasonable bias against certain index of data within the batch.</p>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/layers/LSTMCell" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/layers/LSTMCell</a>
  </p>
</div>
