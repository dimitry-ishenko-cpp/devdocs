<h1 class="devsite-page-title" tabindex="-1"> tf.distribute.experimental.TerminationConfig </h1> <devsite-feature-tooltip ack-key="AckCollectionsBookmarkTooltipDismiss" analytics-category="Site-Wide Custom Events" analytics-action-show="Callout Profile displayed" analytics-action-close="Callout Profile dismissed" analytics-label="Create Collection Callout" class="devsite-page-bookmark-tooltip nocontent" dismiss-button="true" id="devsite-collections-dropdown" dismiss-button-text="Dismiss" close-button-text="Got it">    </devsite-feature-tooltip> <div class="devsite-page-title-meta"><devsite-view-release-notes></devsite-view-release-notes></div>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.distribute.experimental.TerminationConfig"> <meta itemprop="path" content="Stable"> <meta itemprop="property" content="__init__"> </div>   <p>Customization of <code translate="no" dir="ltr">PreemptionCheckpointHandler</code> for various platforms.</p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.distribute.experimental.TerminationConfig(
    termination_watcher_fn=None, exit_fn=None, grace_period=None, save_fn=None
)
</pre></devsite-code>  <p>A <code translate="no" dir="ltr">TerminationConfig</code> can be created and passed to a <a href="preemptioncheckpointhandler.html"><code translate="no" dir="ltr">tf.distribute.experimental.PreemptionCheckpointHandler</code></a> to provide customization based on the platform. It can deliver three pieces of information:</p> <ul> <li>How to decide if there is a termination event soon</li> </ul> <p>The form of termination notification and how to fetch it vary across platforms. Thus <code translate="no" dir="ltr">PreemptionCheckpointHandler</code> may take a user-defined function, <code translate="no" dir="ltr">termination_watcher_fn</code>, and execute it repeatedly to check for termination notification. <code translate="no" dir="ltr">termination_watcher_fn</code> should be a function that returns <code translate="no" dir="ltr">True</code> if a termination notification is available and <code translate="no" dir="ltr">False</code> otherwise. The function should be lightweight and non-blocking so that resources can be cleaned up properly if no termination signal is ever raised until training finishes.</p> <ul> <li>How to exit the program</li> </ul> <p>A user can configure this through the <code translate="no" dir="ltr">exit_fn</code>, which <code translate="no" dir="ltr">PreemptionCheckpointHandler</code> executes after saving the checkpoint to exit the training program gracefully. For <a href="../multiworkermirroredstrategy.html"><code translate="no" dir="ltr">tf.distribute.MultiWorkerMirroredStrategy</code></a>, a restart is necessary to reset the program's state. However, having a customized <code translate="no" dir="ltr">exit_fn</code> may facilitate the restart and smoothen the training experience. How so? Maybe the platform has an agreement to a <code translate="no" dir="ltr">RESTART_CODE</code> recognized as a program auto-restart signal, or maybe the user has a coordinating script that starts up the training, in which they can configure the program to auto-restart if it ever exits with this <code translate="no" dir="ltr">RESTART_CODE</code>. In both cases, configuring the <code translate="no" dir="ltr">exit_fn</code> to be <code translate="no" dir="ltr">sys.exit(RESTART_CODE)</code> makes the training seamless.</p> <ul> <li>How long does <code translate="no" dir="ltr">PreemptionCheckpointHandler</code> have from receiving a termination event notice till the actual termination</li> </ul> <p>Some platforms have a gap time as long as one hour or so. In these cases, there is the option to utilize this gap time for training as much as possible before saving a checkpoint and exiting. This can be achieved by passing the <code translate="no" dir="ltr">grace_period</code> argument a nonzero value. Note, for a user with a grace period that is not multiple times longer than their checkpoint writing time (e.g., three times or more), we advise not to configure this argument, in which case <code translate="no" dir="ltr">PreemptionCheckpointHandler</code> will directly save a checkpoint and exit.</p> <p><strong>The default behavior</strong>:</p> <ul> <li>
<p>For Google Borg Platform:</p> <ul> <li>Automatically know how to detect preemption signal</li> <li>Exit with a platform-recognized restart code</li> <li>Save a checkpoint and exit immediately</li> </ul>
</li> <li>
<p>For Google Cloud Platform:</p> <ul> <li>Automatically know how to detect maintenance signal.</li> <li>Exit with a code (User may configure this)</li> <li>Automatically utilized the extended training period before save and exit</li> </ul>
</li> <li>
<p>For Other platform:</p> <ul> <li>If <code translate="no" dir="ltr">termination_watcher_fn</code> is <code translate="no" dir="ltr">None</code>, we will treat <code translate="no" dir="ltr">signal.SIGTERM</code> as a termination signal.</li> <li>If <code translate="no" dir="ltr">exit_fn</code> is not configured, we exit the program with an arbitrary code.</li> <li>If <code translate="no" dir="ltr">grace_period</code> is not configured, we will wrap up the current training step, save a checkpoint, and exit the program as soon as we receive the termination signal.</li> </ul>
</li> </ul>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">termination_watcher_fn</code> </td> <td> a function to execute repeatedly that returns <code translate="no" dir="ltr">True</code> if a preemption signal is available and False otherwise. The function cannot block until a preemption signal is available, which prevents proper cleanup of the program. A change is <strong>NOT</strong> recommended for users on Google Borg or Google Cloud Platform. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">exit_fn</code> </td> <td> a function to execute after a checkpoint is saved and before the preemption happens. Usually, it should be in the form of <code translate="no" dir="ltr">lambda: sys.exit(RESTART_CODE)</code>, where <code translate="no" dir="ltr">RESTART_CODE</code> varies by platform. A change is <strong>NOT</strong> recommended for users on Google Borg. Users on Google Cloud Platform may configure it to use a customized <code translate="no" dir="ltr">RESTART_CODE</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">grace_period</code> </td> <td> the length of time between receiving a preemption signal and the actual preemption. A change is <strong>NOT</strong> recommended for users on Google Borg, Google Cloud Platform, or users with a short grace period. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">save_fn</code> </td> <td> an optional function letting you configure how to save a checkpoint. This is useful if you'd like to pass extra argument to <a href="../../train/checkpointmanager.html#save"><code translate="no" dir="ltr">tf.train.CheckpointManager.save</code></a> or <a href="../../train/checkpoint.html#save"><code translate="no" dir="ltr">tf.train.Checkpoint.save</code></a>. By default, if not configured, the API will save checkpoint without extra arguments. </td> </tr> </table>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/distribute/experimental/TerminationConfig" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/distribute/experimental/TerminationConfig</a>
  </p>
</div>
