<h1 class="devsite-page-title">tf.types.experimental.GenericFunction</h1> <devsite-bookmark></devsite-bookmark>       <p>Base class for polymorphic graph functions.</p> <p>Inherits From: <a href="callable.html"><code translate="no" dir="ltr">Callable</code></a></p>  <p>Graph functions are Python callable objects that dispatch calls to a TensorFlow graph. Polymorphic graph functions can be backed by multiple TF graphs, and automatically select the appropriate specialization based on the type of input they were called with. They may also create specializations on the fly if necessary, for example by tracing.</p> <p>Also see <a href="../../function.html"><code translate="no" dir="ltr">tf.function</code></a>.</p> <h2 id="methods" data-text="Methods">Methods</h2> <h3 id="experimental_get_compiler_ir" data-text="experimental_get_compiler_ir"><code translate="no" dir="ltr">experimental_get_compiler_ir</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/types/core.py#L175-L237">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
experimental_get_compiler_ir(
    *args, **kwargs
)
</pre> <p>Returns compiler IR for the compiled function.</p> <p>This API is intended <em>only</em> for debugging as there are no guarantees on backwards compatibility of returned IR or the allowed values of <code translate="no" dir="ltr">stage</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">*args</code> </td> <td> Arguments used for compilation; same arguments as used for calling the function. Need to be eager tensors. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">**kwargs</code> </td> <td> Keyword arguments used for compilation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> Function callable with the following kwargs: <ul> <li>
<code translate="no" dir="ltr">stage</code> at which the compiler IR should be serialized. Allowed values are: <ul> <li>
<code translate="no" dir="ltr">hlo</code>: HLO output after conversion from TF (<a href="https://www.tensorflow.org/xla/operation_semantics">https://www.tensorflow.org/xla/operation_semantics</a>).</li> <li>
<code translate="no" dir="ltr">hlo_serialized</code>: Like stage=<code translate="no" dir="ltr">hlo</code>, but the output is a serialized HLO module proto (a bytes object).</li> <li>
<code translate="no" dir="ltr">optimized_hlo</code>: HLO after compiler optimizations.</li> <li>
<code translate="no" dir="ltr">optimized_hlo_serialized</code>: Like stage=<code translate="no" dir="ltr">optimized_hlo</code>, but the output is a serialized HLO module proto (a bytes object).</li> <li>
<code translate="no" dir="ltr">optimized_hlo_dot</code>: optimized HLO in DOT format suitable for Graphviz.</li> </ul>
</li> <li>
<code translate="no" dir="ltr">device_name</code> can be either None, in which case the preferred device is used for compilation, or a device name. It can be a full device name, or a partial one, e.g., <code translate="no" dir="ltr">/device:CPU:0</code>.</li> </ul> <p>For example, for</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">@tf.function(jit_compile=True)
def f(x):
  return x + 1

f.experimental_get_compiler_ir(tf.random.normal([10, 10])(stage='hlo')
</pre> <p>the output is:</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">HloModule a_inference_f_13__.9

ENTRY %a_inference_f_13__.9 (arg0.1: f32[10,10]) -&gt; f32[10,10] {
  %arg0.1 = f32[10,10]{1,0} parameter(0), parameter_replication={false}
  %reshape.2 = f32[10,10]{1,0} reshape(f32[10,10]{1,0} %arg0.1)
  %constant.3 = f32[] constant(1)
  %broadcast.4 = f32[10,10]{1,0} broadcast(f32[] %constant.3)
  %add.5 = f32[10,10]{1,0} add(f32[10,10]{1,0} %reshape.2,
                               f32[10,10]{1,0} %broadcast.4)
  %reshape.6 = f32[10,10]{1,0} reshape(f32[10,10]{1,0} %add.5)
  %tuple.7 = (f32[10,10]{1,0}) tuple(f32[10,10]{1,0} %reshape.6)
  ROOT %get-tuple-element.8 = f32[10,10]{1,0}
    get-tuple-element((f32[10,10]{1,0}) %tuple.7), index=0
}
</pre> 
</td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If an invalid <code translate="no" dir="ltr">stage</code> is selected or if applied to a function which is not compiled (<code translate="no" dir="ltr">jit_compile=True</code> is not set). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> When called with input in graph mode. </td> </tr> </table> <h3 id="get_concrete_function" data-text="get_concrete_function"><code translate="no" dir="ltr">get_concrete_function</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/types/core.py#L128-L173">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_concrete_function(
    *args, **kwargs
) -&gt; tf.types.experimental.ConcreteFunction
</pre> <p>Returns a <code translate="no" dir="ltr">ConcreteFunction</code> specialized to input types.</p> <p>The arguments specified by <code translate="no" dir="ltr">args</code> and <code translate="no" dir="ltr">kwargs</code> follow normal function call rules. The returned <code translate="no" dir="ltr">ConcreteFunction</code> has the same set of positional and keyword arguments as <code translate="no" dir="ltr">self</code>, but their types are compatible to the types specified by <code translate="no" dir="ltr">args</code> and <code translate="no" dir="ltr">kwargs</code> (though not neccessarily equal).</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
@tf.function
def f(x):
  return x
f_concrete = f.get_concrete_function(tf.constant(1.0))
f_concrete = f.get_concrete_function(x=tf.constant(1.0))
</pre> <p>Unlike normal calls, <code translate="no" dir="ltr">get_concrete_function</code> allow type specifiers instead of TensorFlow objects, so for example <a href="../../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>s may be replaced with <a href="../../tensorspec.html"><code translate="no" dir="ltr">tf.TensorSpec</code></a>s.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
@tf.function
def f(x):
  return x
f_concrete = f.get_concrete_function(tf.TensorSpec([], tf.float64))
</pre> <p>If the function definition allows only one specialization, <code translate="no" dir="ltr">args</code> and <code translate="no" dir="ltr">kwargs</code> may be omitted altogether.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
@tf.function(input_signature=[tf.TensorSpec(None, tf.float32)])
def f(x):
  return x
f_concrete = f.get_concrete_function()
</pre> <p>The returned <code translate="no" dir="ltr">ConcreteFunction</code> can be called normally:</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
f_concrete(tf.constant(1.0))
&lt;tf.Tensor: shape=(), dtype=float32, numpy=1.0&gt;
f_concrete(x=tf.constant(1.0))
&lt;tf.Tensor: shape=(), dtype=float32, numpy=1.0&gt;
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">*args</code> </td> <td> inputs to specialize on. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">**kwargs</code> </td> <td> inputs to specialize on. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">ConcreteFunction</code>. </td> </tr> 
</table> <h3 id="__call__" data-text="__call__"><code translate="no" dir="ltr">__call__</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/types/core.py#L87-L102">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__call__(
    *args, **kwargs
)
</pre> <p>Executes this callable.</p> <p>This behaves like a regular op - in eager mode, it immediately starts execution, returning results. In graph mode, it creates ops which return symbolic TensorFlow values (like <a href="../../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, <a href="../../data/dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a>, etc.). For example, <a href="../../function.html"><code translate="no" dir="ltr">tf.function</code></a> callables typically generate a <a href="../../raw_ops/partitionedcall.html"><code translate="no" dir="ltr">tf.raw_ops.PartitionedCall</code></a> op, but not always - the exact operations being generated are an internal implementation detail.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">*args</code> </td> <td> positional argument for this call </td> </tr>
<tr> <td> <code translate="no" dir="ltr">**kwargs</code> </td> <td> keyword arguments for this call </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> The execution results. </td> </tr> 
</table>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/types/experimental/GenericFunction" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/types/experimental/GenericFunction</a>
  </p>
</div>
