<h1 class="devsite-page-title">tf.linalg.LinearOperatorBlockLowerTriangular</h1> <devsite-bookmark></devsite-bookmark>       <p>Combines <code translate="no" dir="ltr">LinearOperators</code> into a blockwise lower-triangular matrix.</p> <p>Inherits From: <a href="linearoperator.html"><code translate="no" dir="ltr">LinearOperator</code></a>, <a href="../module.html"><code translate="no" dir="ltr">Module</code></a></p> <section class="expandable"> <h4 class="showalways" id="view-aliases" data-text="View aliases">View aliases</h4> <p> <b>Compat aliases for migration</b> </p>
<p>See <a href="https://www.tensorflow.org/guide/migrate">Migration guide</a> for more details.</p> <p><a href="https://www.tensorflow.org/api_docs/python/tf/linalg/LinearOperatorBlockLowerTriangular"><code translate="no" dir="ltr">tf.compat.v1.linalg.LinearOperatorBlockLowerTriangular</code></a></p> </section> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.linalg.LinearOperatorBlockLowerTriangular(
    operators,
    is_non_singular=None,
    is_self_adjoint=None,
    is_positive_definite=None,
    is_square=None,
    name='LinearOperatorBlockLowerTriangular'
)
</pre>  <p>This operator is initialized with a nested list of linear operators, which are combined into a new <code translate="no" dir="ltr">LinearOperator</code> whose underlying matrix representation is square and has each operator on or below the main diagonal, and zero's elsewhere. Each element of the outer list is a list of <code translate="no" dir="ltr">LinearOperators</code> corresponding to a row-partition of the blockwise structure. The number of <code translate="no" dir="ltr">LinearOperator</code>s in row-partion <code translate="no" dir="ltr">i</code> must be equal to <code translate="no" dir="ltr">i</code>.</p> <p>For example, a blockwise <code translate="no" dir="ltr">3 x 3</code> <code translate="no" dir="ltr">LinearOperatorBlockLowerTriangular</code> is initialized with the list <code translate="no" dir="ltr">[[op_00], [op_10, op_11], [op_20, op_21, op_22]]</code>, where the <code translate="no" dir="ltr">op_ij</code>, <code translate="no" dir="ltr">i &lt; 3, j &lt;= i</code>, are <code translate="no" dir="ltr">LinearOperator</code> instances. The <code translate="no" dir="ltr">LinearOperatorBlockLowerTriangular</code> behaves as the following blockwise matrix, where <code translate="no" dir="ltr">0</code> represents appropriately-sized [batch] matrices of zeros:</p> <pre class="devsite-click-to-copy" translate="no" dir="ltr" data-language="cpp">[[op_00,     0,     0],
 [op_10, op_11,     0],
 [op_20, op_21, op_22]]
</pre> <p>Each <code translate="no" dir="ltr">op_jj</code> on the diagonal is required to represent a square matrix, and hence will have shape <code translate="no" dir="ltr">batch_shape_j + [M_j, M_j]</code>. <code translate="no" dir="ltr">LinearOperator</code>s in row <code translate="no" dir="ltr">j</code> of the blockwise structure must have <code translate="no" dir="ltr">range_dimension</code> equal to that of <code translate="no" dir="ltr">op_jj</code>, and <code translate="no" dir="ltr">LinearOperators</code> in column <code translate="no" dir="ltr">j</code> must have <code translate="no" dir="ltr">domain_dimension</code> equal to that of <code translate="no" dir="ltr">op_jj</code>.</p> <p>If each <code translate="no" dir="ltr">op_jj</code> on the diagonal has shape <code translate="no" dir="ltr">batch_shape_j + [M_j, M_j]</code>, then the combined operator has shape <code translate="no" dir="ltr">broadcast_batch_shape + [sum M_j, sum M_j]</code>, where <code translate="no" dir="ltr">broadcast_batch_shape</code> is the mutual broadcast of <code translate="no" dir="ltr">batch_shape_j</code>, <code translate="no" dir="ltr">j = 0, 1, ..., J</code>, assuming the intermediate batch shapes broadcast. Even if the combined shape is well defined, the combined operator's methods may fail due to lack of broadcasting ability in the defining operators' methods.</p> <p>For example, to create a 4 x 4 linear operator combined of three 2 x 2 operators:</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; operator_0 = tf.linalg.LinearOperatorFullMatrix([[1., 2.], [3., 4.]])
&gt;&gt;&gt; operator_1 = tf.linalg.LinearOperatorFullMatrix([[1., 0.], [0., 1.]])
&gt;&gt;&gt; operator_2 = tf.linalg.LinearOperatorLowerTriangular([[5., 6.], [7., 8]])
&gt;&gt;&gt; operator = LinearOperatorBlockLowerTriangular(
...   [[operator_0], [operator_1, operator_2]])
</pre> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
operator.to_dense()
&lt;tf.Tensor: shape=(4, 4), dtype=float32, numpy=
array([[1., 2., 0., 0.],
       [3., 4., 0., 0.],
       [1., 0., 5., 0.],
       [0., 1., 7., 8.]], dtype=float32)&gt;
</pre> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
operator.shape
TensorShape([4, 4])
</pre> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
operator.log_abs_determinant()
&lt;tf.Tensor: shape=(), dtype=float32, numpy=4.3820267&gt;
</pre> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
x0 = [[1., 6.], [-3., 4.]]
x1 = [[0., 2.], [4., 0.]]
x = tf.concat([x0, x1], 0)  # Shape [2, 4] Tensor
operator.matmul(x)
&lt;tf.Tensor: shape=(4, 2), dtype=float32, numpy=
array([[-5., 14.],
       [-9., 34.],
       [ 1., 16.],
       [29., 18.]], dtype=float32)&gt;
</pre> <p>The above <code translate="no" dir="ltr">matmul</code> is equivalent to:</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; tf.concat([operator_0.matmul(x0),
...   operator_1.matmul(x0) + operator_2.matmul(x1)], axis=0)
&lt;tf.Tensor: shape=(4, 2), dtype=float32, numpy=
array([[-5., 14.],
       [-9., 34.],
       [ 1., 16.],
       [29., 18.]], dtype=float32)&gt;
</pre> <h4 id="shape_compatibility" data-text="Shape compatibility">Shape compatibility</h4> <p>This operator acts on [batch] matrix with compatible shape. <code translate="no" dir="ltr">x</code> is a batch matrix with compatible shape for <code translate="no" dir="ltr">matmul</code> and <code translate="no" dir="ltr">solve</code> if</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">operator.shape = [B1,...,Bb] + [M, N],  with b &gt;= 0
x.shape =        [B1,...,Bb] + [N, R],  with R &gt;= 0.
</pre> <h4 id="for_example" data-text="For example:">For example:</h4> <p>Create a [2, 3] batch of 4 x 4 linear operators:</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; matrix_44 = tf.random.normal(shape=[2, 3, 4, 4])
&gt;&gt;&gt; operator_44 = tf.linalg.LinearOperatorFullMatrix(matrix_44)
</pre> <p>Create a [1, 3] batch of 5 x 4 linear operators:</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; matrix_54 = tf.random.normal(shape=[1, 3, 5, 4])
&gt;&gt;&gt; operator_54 = tf.linalg.LinearOperatorFullMatrix(matrix_54)
</pre> <p>Create a [1, 3] batch of 5 x 5 linear operators:</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; matrix_55 = tf.random.normal(shape=[1, 3, 5, 5])
&gt;&gt;&gt; operator_55 = tf.linalg.LinearOperatorFullMatrix(matrix_55)
</pre> <p>Combine to create a [2, 3] batch of 9 x 9 operators:</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; operator_99 = LinearOperatorBlockLowerTriangular(
...   [[operator_44], [operator_54, operator_55]])
&gt;&gt;&gt; operator_99.shape
TensorShape([2, 3, 9, 9])
</pre> <p>Create a shape [2, 1, 9] batch of vectors and apply the operator to it.</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; x = tf.random.normal(shape=[2, 1, 9])
&gt;&gt;&gt; y = operator_99.matvec(x)
&gt;&gt;&gt; y.shape
TensorShape([2, 3, 9])
</pre> <p>Create a blockwise list of vectors and apply the operator to it. A blockwise list is returned.</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; x4 = tf.random.normal(shape=[2, 1, 4])
&gt;&gt;&gt; x5 = tf.random.normal(shape=[2, 3, 5])
&gt;&gt;&gt; y_blockwise = operator_99.matvec([x4, x5])
&gt;&gt;&gt; y_blockwise[0].shape
TensorShape([2, 3, 4])
&gt;&gt;&gt; y_blockwise[1].shape
TensorShape([2, 3, 5])
</pre> <h4 id="performance" data-text="Performance">Performance</h4> <p>Suppose <code translate="no" dir="ltr">operator</code> is a <code translate="no" dir="ltr">LinearOperatorBlockLowerTriangular</code> consisting of <code translate="no" dir="ltr">D</code> row-partitions and <code translate="no" dir="ltr">D</code> column-partitions, such that the total number of operators is <code translate="no" dir="ltr">N = D * (D + 1) // 2</code>.</p> <ul> <li>
<code translate="no" dir="ltr">operator.matmul</code> has complexity equal to the sum of the <code translate="no" dir="ltr">matmul</code> complexities of the individual operators.</li> <li>
<code translate="no" dir="ltr">operator.solve</code> has complexity equal to the sum of the <code translate="no" dir="ltr">solve</code> complexities of the operators on the diagonal and the <code translate="no" dir="ltr">matmul</code> complexities of the operators off the diagonal.</li> <li>
<code translate="no" dir="ltr">operator.determinant</code> has complexity equal to the sum of the <code translate="no" dir="ltr">determinant</code> complexities of the operators on the diagonal.</li> </ul> <h4 id="matrix_property_hints" data-text="Matrix property hints">Matrix property hints</h4> <p>This <code translate="no" dir="ltr">LinearOperator</code> is initialized with boolean flags of the form <code translate="no" dir="ltr">is_X</code>, for <code translate="no" dir="ltr">X = non_singular, self_adjoint, positive_definite, square</code>. These have the following meaning:</p> <ul> <li>If <code translate="no" dir="ltr">is_X == True</code>, callers should expect the operator to have the property <code translate="no" dir="ltr">X</code>. This is a promise that should be fulfilled, but is <em>not</em> a runtime assert. For example, finite floating point precision may result in these promises being violated.</li> <li>If <code translate="no" dir="ltr">is_X == False</code>, callers should expect the operator to not have <code translate="no" dir="ltr">X</code>.</li> <li>If <code translate="no" dir="ltr">is_X == None</code> (the default), callers should have no expectation either way.</li> </ul>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">operators</code> </td> <td> Iterable of iterables of <code translate="no" dir="ltr">LinearOperator</code> objects, each with the same <code translate="no" dir="ltr">dtype</code>. Each element of <code translate="no" dir="ltr">operators</code> corresponds to a row- partition, in top-to-bottom order. The operators in each row-partition are filled in left-to-right. For example, <code translate="no" dir="ltr">operators = [[op_0], [op_1, op_2], [op_3, op_4, op_5]]</code> creates a <code translate="no" dir="ltr">LinearOperatorBlockLowerTriangular</code> with full block structure <code translate="no" dir="ltr">[[op_0, 0, 0], [op_1, op_2, 0], [op_3, op_4, op_5]]</code>. The number of operators in the <code translate="no" dir="ltr">i</code>th row must be equal to <code translate="no" dir="ltr">i</code>, such that each operator falls on or below the diagonal of the blockwise structure. <code translate="no" dir="ltr">LinearOperator</code>s that fall on the diagonal (the last elements of each row) must be square. The other <code translate="no" dir="ltr">LinearOperator</code>s must have domain dimension equal to the domain dimension of the <code translate="no" dir="ltr">LinearOperator</code>s in the same column-partition, and range dimension equal to the range dimension of the <code translate="no" dir="ltr">LinearOperator</code>s in the same row-partition. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">is_non_singular</code> </td> <td> Expect that this operator is non-singular. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">is_self_adjoint</code> </td> <td> Expect that this operator is equal to its hermitian transpose. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">is_positive_definite</code> </td> <td> Expect that this operator is positive definite, meaning the quadratic form <code translate="no" dir="ltr">x^H A x</code> has positive real part for all nonzero <code translate="no" dir="ltr">x</code>. Note that we do not require the operator to be self-adjoint to be positive-definite. See: <a href="https://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices">https://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices</a> </td> </tr>
<tr> <td> <code translate="no" dir="ltr">is_square</code> </td> <td> Expect that this operator acts like square [batch] matrices. This will raise a <code translate="no" dir="ltr">ValueError</code> if set to <code translate="no" dir="ltr">False</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">LinearOperator</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If all operators do not have the same <code translate="no" dir="ltr">dtype</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">operators</code> is empty, contains an erroneous number of elements, or contains operators with incompatible shapes. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">H</code> </td> <td> Returns the adjoint of the current <code translate="no" dir="ltr">LinearOperator</code>. <p>Given <code translate="no" dir="ltr">A</code> representing this <code translate="no" dir="ltr">LinearOperator</code>, return <code translate="no" dir="ltr">A*</code>. Note that calling <code translate="no" dir="ltr">self.adjoint()</code> and <code translate="no" dir="ltr">self.H</code> are equivalent. </p>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">batch_shape</code> </td> <td> <code translate="no" dir="ltr">TensorShape</code> of batch dimensions of this <code translate="no" dir="ltr">LinearOperator</code>. <p>If this operator acts like the batch matrix <code translate="no" dir="ltr">A</code> with <code translate="no" dir="ltr">A.shape = [B1,...,Bb, M, N]</code>, then this returns <code translate="no" dir="ltr">TensorShape([B1,...,Bb])</code>, equivalent to <code translate="no" dir="ltr">A.shape[:-2]</code> </p>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">domain_dimension</code> </td> <td> Dimension (in the sense of vector spaces) of the domain of this operator. <p>If this operator acts like the batch matrix <code translate="no" dir="ltr">A</code> with <code translate="no" dir="ltr">A.shape = [B1,...,Bb, M, N]</code>, then this returns <code translate="no" dir="ltr">N</code>. </p>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> The <code translate="no" dir="ltr">DType</code> of <code translate="no" dir="ltr">Tensor</code>s handled by this <code translate="no" dir="ltr">LinearOperator</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">graph_parents</code> </td> <td> List of graph dependencies of this <code translate="no" dir="ltr">LinearOperator</code>. (deprecated) <aside class="deprecated"><strong>Deprecated:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Do not call <code translate="no" dir="ltr">graph_parents</code>. </span></aside>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">is_non_singular</code> </td> <td> 
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">is_positive_definite</code> </td> <td> 
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">is_self_adjoint</code> </td> <td> 
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">is_square</code> </td> <td> Return <code translate="no" dir="ltr">True/False</code> depending on if this operator is square. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">operators</code> </td> <td> 
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">parameters</code> </td> <td> Dictionary of parameters used to instantiate this <code translate="no" dir="ltr">LinearOperator</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">range_dimension</code> </td> <td> Dimension (in the sense of vector spaces) of the range of this operator. <p>If this operator acts like the batch matrix <code translate="no" dir="ltr">A</code> with <code translate="no" dir="ltr">A.shape = [B1,...,Bb, M, N]</code>, then this returns <code translate="no" dir="ltr">M</code>. </p>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">shape</code> </td> <td> <code translate="no" dir="ltr">TensorShape</code> of this <code translate="no" dir="ltr">LinearOperator</code>. <p>If this operator acts like the batch matrix <code translate="no" dir="ltr">A</code> with <code translate="no" dir="ltr">A.shape = [B1,...,Bb, M, N]</code>, then this returns <code translate="no" dir="ltr">TensorShape([B1,...,Bb, M, N])</code>, equivalent to <code translate="no" dir="ltr">A.shape</code>. </p>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">tensor_rank</code> </td> <td> Rank (in the sense of tensors) of matrix corresponding to this operator. <p>If this operator acts like the batch matrix <code translate="no" dir="ltr">A</code> with <code translate="no" dir="ltr">A.shape = [B1,...,Bb, M, N]</code>, then this returns <code translate="no" dir="ltr">b + 2</code>. </p>
</td> </tr> </table> <h2 id="methods" data-text="Methods">Methods</h2> <h3 id="add_to_tensor" data-text="add_to_tensor"><code translate="no" dir="ltr">add_to_tensor</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L1079-L1092">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
add_to_tensor(
    x, name='add_to_tensor'
)
</pre> <p>Add matrix represented by this operator to <code translate="no" dir="ltr">x</code>. Equivalent to <code translate="no" dir="ltr">A + x</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> with same <code translate="no" dir="ltr">dtype</code> and shape broadcastable to <code translate="no" dir="ltr">self.shape</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name to give this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> with broadcast shape and same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">self</code>. </td> </tr> 
</table> <h3 id="adjoint" data-text="adjoint"><code translate="no" dir="ltr">adjoint</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L935-L950">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
adjoint(
    name='adjoint'
)
</pre> <p>Returns the adjoint of the current <code translate="no" dir="ltr">LinearOperator</code>.</p> <p>Given <code translate="no" dir="ltr">A</code> representing this <code translate="no" dir="ltr">LinearOperator</code>, return <code translate="no" dir="ltr">A*</code>. Note that calling <code translate="no" dir="ltr">self.adjoint()</code> and <code translate="no" dir="ltr">self.H</code> are equivalent.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">LinearOperator</code> which represents the adjoint of this <code translate="no" dir="ltr">LinearOperator</code>. </td> </tr> 
</table> <h3 id="assert_non_singular" data-text="assert_non_singular"><code translate="no" dir="ltr">assert_non_singular</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L543-L561">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
assert_non_singular(
    name='assert_non_singular'
)
</pre> <p>Returns an <code translate="no" dir="ltr">Op</code> that asserts this operator is non singular.</p> <p>This operator is considered non-singular if</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">ConditionNumber &lt; max{100, range_dimension, domain_dimension} * eps,
eps := np.finfo(self.dtype.as_numpy_dtype).eps
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A string name to prepend to created ops. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An <code translate="no" dir="ltr">Assert</code> <code translate="no" dir="ltr">Op</code>, that, when run, will raise an <code translate="no" dir="ltr">InvalidArgumentError</code> if the operator is singular. </td> </tr> 
</table> <h3 id="assert_positive_definite" data-text="assert_positive_definite"><code translate="no" dir="ltr">assert_positive_definite</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L579-L594">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
assert_positive_definite(
    name='assert_positive_definite'
)
</pre> <p>Returns an <code translate="no" dir="ltr">Op</code> that asserts this operator is positive definite.</p> <p>Here, positive definite means that the quadratic form <code translate="no" dir="ltr">x^H A x</code> has positive real part for all nonzero <code translate="no" dir="ltr">x</code>. Note that we do not require the operator to be self-adjoint to be positive definite.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name to give this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An <code translate="no" dir="ltr">Assert</code> <code translate="no" dir="ltr">Op</code>, that, when run, will raise an <code translate="no" dir="ltr">InvalidArgumentError</code> if the operator is not positive definite. </td> </tr> 
</table> <h3 id="assert_self_adjoint" data-text="assert_self_adjoint"><code translate="no" dir="ltr">assert_self_adjoint</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L606-L620">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
assert_self_adjoint(
    name='assert_self_adjoint'
)
</pre> <p>Returns an <code translate="no" dir="ltr">Op</code> that asserts this operator is self-adjoint.</p> <p>Here we check that this operator is <em>exactly</em> equal to its hermitian transpose.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A string name to prepend to created ops. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An <code translate="no" dir="ltr">Assert</code> <code translate="no" dir="ltr">Op</code>, that, when run, will raise an <code translate="no" dir="ltr">InvalidArgumentError</code> if the operator is not self-adjoint. </td> </tr> 
</table> <h3 id="batch_shape_tensor" data-text="batch_shape_tensor"><code translate="no" dir="ltr">batch_shape_tensor</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L357-L372">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
batch_shape_tensor(
    name='batch_shape_tensor'
)
</pre> <p>Shape of batch dimensions of this operator, determined at runtime.</p> <p>If this operator acts like the batch matrix <code translate="no" dir="ltr">A</code> with <code translate="no" dir="ltr">A.shape = [B1,...,Bb, M, N]</code>, then this returns a <code translate="no" dir="ltr">Tensor</code> holding <code translate="no" dir="ltr">[B1,...,Bb]</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">int32</code> <code translate="no" dir="ltr">Tensor</code> </td> </tr> 
</table> <h3 id="cholesky" data-text="cholesky"><code translate="no" dir="ltr">cholesky</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L980-L1003">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
cholesky(
    name='cholesky'
)
</pre> <p>Returns a Cholesky factor as a <code translate="no" dir="ltr">LinearOperator</code>.</p> <p>Given <code translate="no" dir="ltr">A</code> representing this <code translate="no" dir="ltr">LinearOperator</code>, if <code translate="no" dir="ltr">A</code> is positive definite self-adjoint, return <code translate="no" dir="ltr">L</code>, where <code translate="no" dir="ltr">A = L L^T</code>, i.e. the cholesky decomposition.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">LinearOperator</code> which represents the lower triangular matrix in the Cholesky decomposition. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> When the <code translate="no" dir="ltr">LinearOperator</code> is not hinted to be positive definite and self adjoint. </td> </tr> </table> <h3 id="cond" data-text="cond"><code translate="no" dir="ltr">cond</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L1129-L1139">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
cond(
    name='cond'
)
</pre> <p>Returns the condition number of this linear operator.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> Shape <code translate="no" dir="ltr">[B1,...,Bb]</code> <code translate="no" dir="ltr">Tensor</code> of same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">self</code>. </td> </tr> 
</table> <h3 id="determinant" data-text="determinant"><code translate="no" dir="ltr">determinant</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L739-L756">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
determinant(
    name='det'
)
</pre> <p>Determinant for every batch member.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">Tensor</code> with shape <code translate="no" dir="ltr">self.batch_shape</code> and same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">self</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">NotImplementedError</code> </td> <td> If <code translate="no" dir="ltr">self.is_square</code> is <code translate="no" dir="ltr">False</code>. </td> </tr> </table> <h3 id="diag_part" data-text="diag_part"><code translate="no" dir="ltr">diag_part</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L1030-L1056">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
diag_part(
    name='diag_part'
)
</pre> <p>Efficiently get the [batch] diagonal part of this operator.</p> <p>If this operator has shape <code translate="no" dir="ltr">[B1,...,Bb, M, N]</code>, this returns a <code translate="no" dir="ltr">Tensor</code> <code translate="no" dir="ltr">diagonal</code>, of shape <code translate="no" dir="ltr">[B1,...,Bb, min(M, N)]</code>, where <code translate="no" dir="ltr">diagonal[b1,...,bb, i] = self.to_dense()[b1,...,bb, i, i]</code>.</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">my_operator = LinearOperatorDiag([1., 2.])

# Efficiently get the diagonal
my_operator.diag_part()
==&gt; [1., 2.]

# Equivalent, but inefficient method
tf.linalg.diag_part(my_operator.to_dense())
==&gt; [1., 2.]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">diag_part</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code> of same <code translate="no" dir="ltr">dtype</code> as self. </td> </tr> </table> <h3 id="domain_dimension_tensor" data-text="domain_dimension_tensor"><code translate="no" dir="ltr">domain_dimension_tensor</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L442-L458">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
domain_dimension_tensor(
    name='domain_dimension_tensor'
)
</pre> <p>Dimension (in the sense of vector spaces) of the domain of this operator.</p> <p>Determined at runtime.</p> <p>If this operator acts like the batch matrix <code translate="no" dir="ltr">A</code> with <code translate="no" dir="ltr">A.shape = [B1,...,Bb, M, N]</code>, then this returns <code translate="no" dir="ltr">N</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">int32</code> <code translate="no" dir="ltr">Tensor</code> </td> </tr> 
</table> <h3 id="eigvals" data-text="eigvals"><code translate="no" dir="ltr">eigvals</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L1097-L1114">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
eigvals(
    name='eigvals'
)
</pre> <p>Returns the eigenvalues of this linear operator.</p> <p>If the operator is marked as self-adjoint (via <code translate="no" dir="ltr">is_self_adjoint</code>) this computation can be more efficient.</p> <blockquote class="note">
<strong>Note:</strong><span> This currently only supports self-adjoint operators.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> Shape <code translate="no" dir="ltr">[B1,...,Bb, N]</code> <code translate="no" dir="ltr">Tensor</code> of same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">self</code>. </td> </tr> 
</table> <h3 id="inverse" data-text="inverse"><code translate="no" dir="ltr">inverse</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L955-L978">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
inverse(
    name='inverse'
)
</pre> <p>Returns the Inverse of this <code translate="no" dir="ltr">LinearOperator</code>.</p> <p>Given <code translate="no" dir="ltr">A</code> representing this <code translate="no" dir="ltr">LinearOperator</code>, return a <code translate="no" dir="ltr">LinearOperator</code> representing <code translate="no" dir="ltr">A^-1</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name scope to use for ops added by this method. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">LinearOperator</code> representing inverse of this matrix. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> When the <code translate="no" dir="ltr">LinearOperator</code> is not hinted to be <code translate="no" dir="ltr">non_singular</code>. </td> </tr> </table> <h3 id="log_abs_determinant" data-text="log_abs_determinant"><code translate="no" dir="ltr">log_abs_determinant</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L768-L785">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
log_abs_determinant(
    name='log_abs_det'
)
</pre> <p>Log absolute value of determinant for every batch member.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">Tensor</code> with shape <code translate="no" dir="ltr">self.batch_shape</code> and same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">self</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">NotImplementedError</code> </td> <td> If <code translate="no" dir="ltr">self.is_square</code> is <code translate="no" dir="ltr">False</code>. </td> </tr> </table> <h3 id="matmul" data-text="matmul"><code translate="no" dir="ltr">matmul</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator_block_lower_triangular.py#L398-L460">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
matmul(
    x, adjoint=False, adjoint_arg=False, name='matmul'
)
</pre> <p>Transform [batch] matrix <code translate="no" dir="ltr">x</code> with left multiplication: <code translate="no" dir="ltr">x --&gt; Ax</code>.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Make an operator acting like batch matrix A.  Assume A.shape = [..., M, N]
operator = LinearOperator(...)
operator.shape = [..., M, N]

X = ... # shape [..., N, R], batch matrix, R &gt; 0.

Y = operator.matmul(X)
Y.shape
==&gt; [..., M, R]

Y[..., :, r] = sum_j A[..., :, j] X[j, r]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> <code translate="no" dir="ltr">LinearOperator</code>, <code translate="no" dir="ltr">Tensor</code> with compatible shape and same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">self</code>, or a blockwise iterable of <code translate="no" dir="ltr">LinearOperator</code>s or <code translate="no" dir="ltr">Tensor</code>s. See class docstring for definition of shape compatibility. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">adjoint</code> </td> <td> Python <code translate="no" dir="ltr">bool</code>. If <code translate="no" dir="ltr">True</code>, left multiply by the adjoint: <code translate="no" dir="ltr">A^H x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">adjoint_arg</code> </td> <td> Python <code translate="no" dir="ltr">bool</code>. If <code translate="no" dir="ltr">True</code>, compute <code translate="no" dir="ltr">A x^H</code> where <code translate="no" dir="ltr">x^H</code> is the hermitian transpose (transposition and complex conjugation). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">LinearOperator</code> or <code translate="no" dir="ltr">Tensor</code> with shape <code translate="no" dir="ltr">[..., M, R]</code> and same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">self</code>, or if <code translate="no" dir="ltr">x</code> is blockwise, a list of <code translate="no" dir="ltr">Tensor</code>s with shapes that concatenate to <code translate="no" dir="ltr">[..., M, R]</code>. </td> </tr> 
</table> <h3 id="matvec" data-text="matvec"><code translate="no" dir="ltr">matvec</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator_block_lower_triangular.py#L526-L575">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
matvec(
    x, adjoint=False, name='matvec'
)
</pre> <p>Transform [batch] vector <code translate="no" dir="ltr">x</code> with left multiplication: <code translate="no" dir="ltr">x --&gt; Ax</code>.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Make an operator acting like batch matrix A.  Assume A.shape = [..., M, N]
operator = LinearOperator(...)

X = ... # shape [..., N], batch vector

Y = operator.matvec(X)
Y.shape
==&gt; [..., M]

Y[..., :] = sum_j A[..., :, j] X[..., j]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">x</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> with compatible shape and same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">self</code>, or an iterable of <code translate="no" dir="ltr">Tensor</code>s. <code translate="no" dir="ltr">Tensor</code>s are treated a [batch] vectors, meaning for every set of leading dimensions, the last dimension defines a vector. See class docstring for definition of compatibility. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">adjoint</code> </td> <td> Python <code translate="no" dir="ltr">bool</code>. If <code translate="no" dir="ltr">True</code>, left multiply by the adjoint: <code translate="no" dir="ltr">A^H x</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code> with shape <code translate="no" dir="ltr">[..., M]</code> and same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">self</code>. </td> </tr> 
</table> <h3 id="range_dimension_tensor" data-text="range_dimension_tensor"><code translate="no" dir="ltr">range_dimension_tensor</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L486-L502">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
range_dimension_tensor(
    name='range_dimension_tensor'
)
</pre> <p>Dimension (in the sense of vector spaces) of the range of this operator.</p> <p>Determined at runtime.</p> <p>If this operator acts like the batch matrix <code translate="no" dir="ltr">A</code> with <code translate="no" dir="ltr">A.shape = [B1,...,Bb, M, N]</code>, then this returns <code translate="no" dir="ltr">M</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">int32</code> <code translate="no" dir="ltr">Tensor</code> </td> </tr> 
</table> <h3 id="shape_tensor" data-text="shape_tensor"><code translate="no" dir="ltr">shape_tensor</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L323-L341">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
shape_tensor(
    name='shape_tensor'
)
</pre> <p>Shape of this <code translate="no" dir="ltr">LinearOperator</code>, determined at runtime.</p> <p>If this operator acts like the batch matrix <code translate="no" dir="ltr">A</code> with <code translate="no" dir="ltr">A.shape = [B1,...,Bb, M, N]</code>, then this returns a <code translate="no" dir="ltr">Tensor</code> holding <code translate="no" dir="ltr">[B1,...,Bb, M, N]</code>, equivalent to <a href="../shape.html"><code translate="no" dir="ltr">tf.shape(A)</code></a>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">int32</code> <code translate="no" dir="ltr">Tensor</code> </td> </tr> 
</table> <h3 id="solve" data-text="solve"><code translate="no" dir="ltr">solve</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator_block_lower_triangular.py#L591-L764">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
solve(
    rhs, adjoint=False, adjoint_arg=False, name='solve'
)
</pre> <p>Solve (exact or approx) <code translate="no" dir="ltr">R</code> (batch) systems of equations: <code translate="no" dir="ltr">A X = rhs</code>.</p> <p>The returned <code translate="no" dir="ltr">Tensor</code> will be close to an exact solution if <code translate="no" dir="ltr">A</code> is well conditioned. Otherwise closeness will vary. See class docstring for details.</p> <p>Given the blockwise <code translate="no" dir="ltr">n + 1</code>-by-<code translate="no" dir="ltr">n + 1</code> linear operator:</p> <p>op = [[A_00 0 ... 0 ... 0], [A_10 A_11 ... 0 ... 0], ... [A_k0 A_k1 ... A_kk ... 0], ... [A_n0 A_n1 ... A_nk ... A_nn]]</p> <p>we find <code translate="no" dir="ltr">x = op.solve(y)</code> by observing that</p> <p><code translate="no" dir="ltr">y_k = A_k0.matmul(x_0) + A_k1.matmul(x_1) + ... + A_kk.matmul(x_k)</code></p> <p>and therefore</p> <p><code translate="no" dir="ltr">x_k = A_kk.solve(y_k - A_k0.matmul(x_0) - ... - A_k(k-1).matmul(x_(k-1)))</code></p> <p>where <code translate="no" dir="ltr">x_k</code> and <code translate="no" dir="ltr">y_k</code> are the <code translate="no" dir="ltr">k</code>th blocks obtained by decomposing <code translate="no" dir="ltr">x</code> and <code translate="no" dir="ltr">y</code> along their appropriate axes.</p> <p>We first solve <code translate="no" dir="ltr">x_0 = A_00.solve(y_0)</code>. Proceeding inductively, we solve for <code translate="no" dir="ltr">x_k</code>, <code translate="no" dir="ltr">k = 1..n</code>, given <code translate="no" dir="ltr">x_0..x_(k-1)</code>.</p> <p>The adjoint case is solved similarly, beginning with <code translate="no" dir="ltr">x_n = A_nn.solve(y_n, adjoint=True)</code> and proceeding backwards.</p> <h4 id="examples" data-text="Examples:">Examples:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Make an operator acting like batch matrix A.  Assume A.shape = [..., M, N]
operator = LinearOperator(...)
operator.shape = [..., M, N]

# Solve R &gt; 0 linear systems for every member of the batch.
RHS = ... # shape [..., M, R]

X = operator.solve(RHS)
# X[..., :, r] is the solution to the r'th linear system
# sum_j A[..., :, j] X[..., j, r] = RHS[..., :, r]

operator.matmul(X)
==&gt; RHS
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">rhs</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> with same <code translate="no" dir="ltr">dtype</code> as this operator and compatible shape, or a list of <code translate="no" dir="ltr">Tensor</code>s. <code translate="no" dir="ltr">Tensor</code>s are treated like a [batch] matrices meaning for every set of leading dimensions, the last two dimensions defines a matrix. See class docstring for definition of compatibility. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">adjoint</code> </td> <td> Python <code translate="no" dir="ltr">bool</code>. If <code translate="no" dir="ltr">True</code>, solve the system involving the adjoint of this <code translate="no" dir="ltr">LinearOperator</code>: <code translate="no" dir="ltr">A^H X = rhs</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">adjoint_arg</code> </td> <td> Python <code translate="no" dir="ltr">bool</code>. If <code translate="no" dir="ltr">True</code>, solve <code translate="no" dir="ltr">A X = rhs^H</code> where <code translate="no" dir="ltr">rhs^H</code> is the hermitian transpose (transposition and complex conjugation). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name scope to use for ops added by this method. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">Tensor</code> with shape <code translate="no" dir="ltr">[...,N, R]</code> and same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">rhs</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">NotImplementedError</code> </td> <td> If <code translate="no" dir="ltr">self.is_non_singular</code> or <code translate="no" dir="ltr">is_square</code> is False. </td> </tr> </table> <h3 id="solvevec" data-text="solvevec"><code translate="no" dir="ltr">solvevec</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator_block_lower_triangular.py#L766-L826">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
solvevec(
    rhs, adjoint=False, name='solve'
)
</pre> <p>Solve single equation with best effort: <code translate="no" dir="ltr">A X = rhs</code>.</p> <p>The returned <code translate="no" dir="ltr">Tensor</code> will be close to an exact solution if <code translate="no" dir="ltr">A</code> is well conditioned. Otherwise closeness will vary. See class docstring for details.</p> <h4 id="examples_2" data-text="Examples:">Examples:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Make an operator acting like batch matrix A.  Assume A.shape = [..., M, N]
operator = LinearOperator(...)
operator.shape = [..., M, N]

# Solve one linear system for every member of the batch.
RHS = ... # shape [..., M]

X = operator.solvevec(RHS)
# X is the solution to the linear system
# sum_j A[..., :, j] X[..., j] = RHS[..., :]

operator.matvec(X)
==&gt; RHS
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">rhs</code> </td> <td> <code translate="no" dir="ltr">Tensor</code> with same <code translate="no" dir="ltr">dtype</code> as this operator, or list of <code translate="no" dir="ltr">Tensor</code>s (for blockwise operators). <code translate="no" dir="ltr">Tensor</code>s are treated as [batch] vectors, meaning for every set of leading dimensions, the last dimension defines a vector. See class docstring for definition of compatibility regarding batch dimensions. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">adjoint</code> </td> <td> Python <code translate="no" dir="ltr">bool</code>. If <code translate="no" dir="ltr">True</code>, solve the system involving the adjoint of this <code translate="no" dir="ltr">LinearOperator</code>: <code translate="no" dir="ltr">A^H X = rhs</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name scope to use for ops added by this method. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">Tensor</code> with shape <code translate="no" dir="ltr">[...,N]</code> and same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">rhs</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">NotImplementedError</code> </td> <td> If <code translate="no" dir="ltr">self.is_non_singular</code> or <code translate="no" dir="ltr">is_square</code> is False. </td> </tr> </table> <h3 id="tensor_rank_tensor" data-text="tensor_rank_tensor"><code translate="no" dir="ltr">tensor_rank_tensor</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L401-L415">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tensor_rank_tensor(
    name='tensor_rank_tensor'
)
</pre> <p>Rank (in the sense of tensors) of matrix corresponding to this operator.</p> <p>If this operator acts like the batch matrix <code translate="no" dir="ltr">A</code> with <code translate="no" dir="ltr">A.shape = [B1,...,Bb, M, N]</code>, then this returns <code translate="no" dir="ltr">b + 2</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">int32</code> <code translate="no" dir="ltr">Tensor</code>, determined at runtime. </td> </tr> 
</table> <h3 id="to_dense" data-text="to_dense"><code translate="no" dir="ltr">to_dense</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L1021-L1024">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
to_dense(
    name='to_dense'
)
</pre> <p>Return a dense (batch) matrix representing this operator.</p> <h3 id="trace" data-text="trace"><code translate="no" dir="ltr">trace</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L1061-L1073">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
trace(
    name='trace'
)
</pre> <p>Trace of the linear operator, equal to sum of <code translate="no" dir="ltr">self.diag_part()</code>.</p> <p>If the operator is square, this is also the sum of the eigenvalues.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for this <code translate="no" dir="ltr">Op</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> Shape <code translate="no" dir="ltr">[B1,...,Bb]</code> <code translate="no" dir="ltr">Tensor</code> of same <code translate="no" dir="ltr">dtype</code> as <code translate="no" dir="ltr">self</code>. </td> </tr> 
</table> <h3 id="__matmul__" data-text="__matmul__"><code translate="no" dir="ltr">__matmul__</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/linalg/linear_operator.py#L688-L689">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__matmul__(
    other
)
</pre>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/linalg/LinearOperatorBlockLowerTriangular" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/linalg/LinearOperatorBlockLowerTriangular</a>
  </p>
</div>
