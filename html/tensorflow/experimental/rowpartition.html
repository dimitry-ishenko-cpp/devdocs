<h1 class="devsite-page-title">tf.experimental.RowPartition</h1> <devsite-bookmark></devsite-bookmark>       <p>Partitioning of a sequence of values into contiguous subsequences ("rows").</p> <section class="expandable"> <h4 class="showalways" id="view-aliases" data-text="View aliases">View aliases</h4> <p> <b>Compat aliases for migration</b> </p>
<p>See <a href="https://www.tensorflow.org/guide/migrate">Migration guide</a> for more details.</p> <p><a href="https://www.tensorflow.org/api_docs/python/tf/experimental/RowPartition"><code translate="no" dir="ltr">tf.compat.v1.experimental.RowPartition</code></a></p> </section> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.experimental.RowPartition(
    row_splits,
    row_lengths=None,
    value_rowids=None,
    nrows=None,
    uniform_row_length=None,
    nvals=None,
    internal=False
)
</pre>  <p>A <code translate="no" dir="ltr">RowPartition</code> describes how a sequence with <code translate="no" dir="ltr">nvals</code> items should be divided into <code translate="no" dir="ltr">nrows</code> contiguous subsequences ("rows"). For example, a <code translate="no" dir="ltr">RowPartition</code> could be used to partition the vector <code translate="no" dir="ltr">[1, 2, 3, 4, 5]</code> into subsequences <code translate="no" dir="ltr">[[1, 2], [3], [], [4, 5]]</code>. Note that <code translate="no" dir="ltr">RowPartition</code> stores information about how values are partitioned, but does not include the partitioned values themselves. <a href="../raggedtensor.html"><code translate="no" dir="ltr">tf.RaggedTensor</code></a> is used to pair a <code translate="no" dir="ltr">values</code> tensor with one or more <code translate="no" dir="ltr">RowPartition</code>s, providing a complete encoding for a ragged tensor (i.e. a tensor with variable-length dimensions).</p> <p><code translate="no" dir="ltr">RowPartition</code>s may be defined using several different schemes:</p> <ul> <li><p><code translate="no" dir="ltr">row_lengths</code>: an integer vector with shape <code translate="no" dir="ltr">[nrows]</code>, which specifies the length of each row.</p></li> <li><p><code translate="no" dir="ltr">row_splits</code>: an integer vector with shape <code translate="no" dir="ltr">[nrows+1]</code>, specifying the "split points" between each row.</p></li> <li><p><code translate="no" dir="ltr">row_starts</code>: an integer vector with shape <code translate="no" dir="ltr">[nrows]</code>, which specifies the start offset for each row. Equivalent to <code translate="no" dir="ltr">row_splits[:-1]</code>.</p></li> <li><p><code translate="no" dir="ltr">row_limits</code>: an integer vector with shape <code translate="no" dir="ltr">[nrows]</code>, which specifies the stop offset for each row. Equivalent to <code translate="no" dir="ltr">row_splits[1:]</code>.</p></li> <li><p><code translate="no" dir="ltr">value_rowids</code> is an integer vector with shape <code translate="no" dir="ltr">[nvals]</code>, corresponding one-to-one with sequence values, which specifies the row that each value belongs to. If the partition has empty trailing rows, then <code translate="no" dir="ltr">nrows</code> must also be specified.</p></li> <li><p><code translate="no" dir="ltr">uniform_row_length</code> is an integer scalar, specifying the length of every row. This scheme may only be used if all rows have the same length.</p></li> </ul> <p>For example, the following <code translate="no" dir="ltr">RowPartition</code>s all represent the partitioning of 8 values into 5 sublists as follows: <code translate="no" dir="ltr">[[*, *, *, *], [], [*, *, *], [*], []]</code>.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
p1 = RowPartition.from_row_lengths([4, 0, 3, 1, 0])
p2 = RowPartition.from_row_splits([0, 4, 4, 7, 8, 8])
p3 = RowPartition.from_row_starts([0, 4, 4, 7, 8], nvals=8)
p4 = RowPartition.from_row_limits([4, 4, 7, 8, 8])
p5 = RowPartition.from_value_rowids([0, 0, 0, 0, 2, 2, 2, 3], nrows=5)
</pre> <p>For more information about each scheme, see the documentation for the its factory method. For additional examples, see the documentation on <a href="../raggedtensor.html"><code translate="no" dir="ltr">tf.RaggedTensor</code></a>.</p> <h3 id="precomputed_encodings" data-text="Precomputed Encodings">Precomputed Encodings</h3> <p><code translate="no" dir="ltr">RowPartition</code> always stores at least one encoding of the partitioning, but it can be configured to cache additional encodings as well. This can avoid unnecessary recomputation in eager mode. (In graph mode, optimizations such as common subexpression elimination will typically prevent these unnecessary recomputations.) To check which encodings are precomputed, use <code translate="no" dir="ltr">RowPartition.has_precomputed_&lt;encoding&gt;</code>. To cache an additional encoding, use <code translate="no" dir="ltr">RowPartition.with_precomputed_&lt;encoding&gt;</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">row_splits</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows+1]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_lengths</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows]</code> </td> </tr>
<tr> <td> <code translate="no" dir="ltr">value_rowids</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nvals]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">nrows</code> </td> <td> A 1-D integer scalar tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">uniform_row_length</code> </td> <td> A scalar tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">nvals</code> </td> <td> A scalar tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">internal</code> </td> <td> Private key value, required to ensure that this private constructor is <em>only</em> called from the factory methods. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If a row partitioning tensor has an inappropriate dtype. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If exactly one row partitioning argument was not specified. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If a row partitioning tensor has an inappropriate shape. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If multiple partitioning arguments are specified. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If nrows is specified but value_rowids is not None. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> The <code translate="no" dir="ltr">DType</code> used to encode the row partition (either int32 or int64). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">static_nrows</code> </td> <td> The number of rows in this partition, if statically known. <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">self.row_lengths().shape == [self.static_nrows]
self.row_starts().shape == [self.static_nrows]
self.row_limits().shape == [self.static_nrows]
self.row_splits().shape == [self.static_nrows + 1]
</pre> 
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">static_nvals</code> </td> <td> The number of values in this partition, if statically known. <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">self.value_rowids().shape == [self.static_vals]
</pre> 
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">static_uniform_row_length</code> </td> <td> The number of values in each row of this partition, if statically known. </td> </tr> </table> <h2 id="methods" data-text="Methods">Methods</h2> <h3 id="from_row_lengths" data-text="from_row_lengths"><code translate="no" dir="ltr">from_row_lengths</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L374-L427">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_row_lengths(
    row_lengths, validate=True, dtype=None, dtype_hint=None
)
</pre> <p>Creates a <code translate="no" dir="ltr">RowPartition</code> with rows partitioned by <code translate="no" dir="ltr">row_lengths</code>.</p> <p>This <code translate="no" dir="ltr">RowPartition</code> divides a sequence <code translate="no" dir="ltr">values</code> into rows by indicating the length of each row:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">partitioned_rows = [[values.pop(0) for _ in range(length)]
                    for length in row_lengths]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">row_lengths</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows]</code>. Must be nonnegative. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RowPartition</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> Optional dtype for the RowPartition. If missing, the type is inferred from the type of <code translate="no" dir="ltr">row_lengths</code>, dtype_hint, or tf.int64. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype_hint</code> </td> <td> Optional dtype for the RowPartition, used when dtype is None. In some cases, a caller may not have a dtype in mind when converting to a tensor, so dtype_hint can be used as a soft preference. If the conversion to <code translate="no" dir="ltr">dtype_hint</code> is not possible, this argument has no effect. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RowPartition</code>. </td> </tr> 
</table> <h3 id="from_row_limits" data-text="from_row_limits"><code translate="no" dir="ltr">from_row_limits</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L481-L525">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_row_limits(
    row_limits, validate=True, dtype=None, dtype_hint=None
)
</pre> <p>Creates a <code translate="no" dir="ltr">RowPartition</code> with rows partitioned by <code translate="no" dir="ltr">row_limits</code>.</p> <p>Equivalent to: <code translate="no" dir="ltr">from_row_splits(values, concat([0, row_limits], axis=0))</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">row_limits</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows]</code>. Must be sorted in ascending order. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RowPartition</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> Optional dtype for the RowPartition. If missing, the type is inferred from the type of <code translate="no" dir="ltr">row_limits</code>, dtype_hint, or tf.int64. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype_hint</code> </td> <td> Optional dtype for the RowPartition, used when dtype is None. In some cases, a caller may not have a dtype in mind when converting to a tensor, so dtype_hint can be used as a soft preference. If the conversion to <code translate="no" dir="ltr">dtype_hint</code> is not possible, this argument has no effect. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RowPartition</code>. </td> </tr> 
</table> <h3 id="from_row_splits" data-text="from_row_splits"><code translate="no" dir="ltr">from_row_splits</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L311-L372">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_row_splits(
    row_splits, validate=True, dtype=None, dtype_hint=None
)
</pre> <p>Creates a <code translate="no" dir="ltr">RowPartition</code> with rows partitioned by <code translate="no" dir="ltr">row_splits</code>.</p> <p>This <code translate="no" dir="ltr">RowPartition</code> divides a sequence <code translate="no" dir="ltr">values</code> into rows by indicating where each row begins and ends:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">partitioned_rows = []
for i in range(len(row_splits) - 1):
  row_start = row_splits[i]
  row_end = row_splits[i + 1]
  partitioned_rows.append(values[row_start:row_end])
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">row_splits</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows+1]</code>. Must not be empty, and must be sorted in ascending order. <code translate="no" dir="ltr">row_splits[0]</code> must be zero. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RowPartition</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> Optional dtype for the RowPartition. If missing, the type is inferred from the type of <code translate="no" dir="ltr">row_splits</code>, dtype_hint, or tf.int64. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype_hint</code> </td> <td> Optional dtype for the RowPartition, used when dtype is None. In some cases, a caller may not have a dtype in mind when converting to a tensor, so dtype_hint can be used as a soft preference. If the conversion to <code translate="no" dir="ltr">dtype_hint</code> is not possible, this argument has no effect. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RowPartition</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">row_splits</code> is an empty list. </td> </tr> </table> <h3 id="from_row_starts" data-text="from_row_starts"><code translate="no" dir="ltr">from_row_starts</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L429-L479">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_row_starts(
    row_starts, nvals, validate=True, dtype=None, dtype_hint=None
)
</pre> <p>Creates a <code translate="no" dir="ltr">RowPartition</code> with rows partitioned by <code translate="no" dir="ltr">row_starts</code>.</p> <p>Equivalent to: <code translate="no" dir="ltr">from_row_splits(concat([row_starts, nvals], axis=0))</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">row_starts</code> </td> <td> A 1-D integer tensor with shape <code translate="no" dir="ltr">[nrows]</code>. Must be nonnegative and sorted in ascending order. If <code translate="no" dir="ltr">nrows&gt;0</code>, then <code translate="no" dir="ltr">row_starts[0]</code> must be zero. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">nvals</code> </td> <td> A scalar tensor indicating the number of values. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RowPartition</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> Optional dtype for the RowPartition. If missing, the type is inferred from the type of <code translate="no" dir="ltr">row_starts</code>, dtype_hint, or tf.int64. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype_hint</code> </td> <td> Optional dtype for the RowPartition, used when dtype is None. In some cases, a caller may not have a dtype in mind when converting to a tensor, so dtype_hint can be used as a soft preference. If the conversion to <code translate="no" dir="ltr">dtype_hint</code> is not possible, this argument has no effect. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RowPartition</code>. </td> </tr> 
</table> <h3 id="from_uniform_row_length" data-text="from_uniform_row_length"><code translate="no" dir="ltr">from_uniform_row_length</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L527-L663">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_uniform_row_length(
    uniform_row_length,
    nvals=None,
    nrows=None,
    validate=True,
    dtype=None,
    dtype_hint=None
)
</pre> <p>Creates a <code translate="no" dir="ltr">RowPartition</code> with rows partitioned by <code translate="no" dir="ltr">uniform_row_length</code>.</p> <p>This <code translate="no" dir="ltr">RowPartition</code> divides a sequence <code translate="no" dir="ltr">values</code> into rows that all have the same length:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">partitioned_rows = [[values.pop(0) for _ in range(uniform_row_length)]
         for _ in range(nrows)]
</pre> <p>Note that either or both of nvals and nrows must be specified.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">uniform_row_length</code> </td> <td> A scalar integer tensor. Must be nonnegative. The size of the outer axis of <code translate="no" dir="ltr">values</code> must be evenly divisible by <code translate="no" dir="ltr">uniform_row_length</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">nvals</code> </td> <td> a non-negative scalar integer tensor for the number of values. Must be specified if nrows is not specified. If not specified, defaults to uniform_row_length*nrows </td> </tr>
<tr> <td> <code translate="no" dir="ltr">nrows</code> </td> <td> The number of rows in the constructed RowPartition. If not specified, then it defaults to <code translate="no" dir="ltr">nvals/uniform_row_length</code> (or <code translate="no" dir="ltr">0</code> if <code translate="no" dir="ltr">uniform_row_length==0</code>). <code translate="no" dir="ltr">nrows</code> only needs to be specified if <code translate="no" dir="ltr">uniform_row_length</code> might be zero. <code translate="no" dir="ltr">uniform_row_length*nrows</code> must be <code translate="no" dir="ltr">nvals</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then use assertions to check that the arguments form a valid <code translate="no" dir="ltr">RowPartition</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> Optional dtype for the RowPartition. If missing, the type is inferred from the type of <code translate="no" dir="ltr">uniform_row_length</code>, dtype_hint, or tf.int64. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype_hint</code> </td> <td> Optional dtype for the RowPartition, used when dtype is None. In some cases, a caller may not have a dtype in mind when converting to a tensor, so dtype_hint can be used as a soft preference. If the conversion to <code translate="no" dir="ltr">dtype_hint</code> is not possible, this argument has no effect. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">RowPartition</code>. </td> </tr> 
</table> <h3 id="from_value_rowids" data-text="from_value_rowids"><code translate="no" dir="ltr">from_value_rowids</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L191-L309">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_value_rowids(
    value_rowids, nrows=None, validate=True, dtype=None, dtype_hint=None
)
</pre> <p>Creates a <code translate="no" dir="ltr">RowPartition</code> with rows partitioned by <code translate="no" dir="ltr">value_rowids</code>.</p> <p>This <code translate="no" dir="ltr">RowPartition</code> divides a sequence <code translate="no" dir="ltr">values</code> into rows by specifying which row each value should be added to:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">partitioned_rows = [[] for _ in nrows]
for (value, rowid) in zip(values, value_rowids):
  partitioned_rows[rowid].append(value)
``

&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Args&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;
`value_rowids`
&lt;/td&gt;
&lt;td&gt;
A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order.
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;
&lt;td&gt;
`nrows`
&lt;/td&gt;
&lt;td&gt;
An integer scalar specifying the number of rows.  This should be
specified if the `RowPartition` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or greater than or equal to zero if
`value_rowids` is empty). Defaults to `value_rowids[-1] + 1` (or zero if
`value_rowids` is empty).
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;
&lt;td&gt;
`validate`
&lt;/td&gt;
&lt;td&gt;
If true, then use assertions to check that the arguments form a
valid `RowPartition`.
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;
&lt;td&gt;
`dtype`
&lt;/td&gt;
&lt;td&gt;
Optional dtype for the RowPartition. If missing, the type
is inferred from the type of `value_rowids`, dtype_hint, or tf.int64.
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;
&lt;td&gt;
`dtype_hint`
&lt;/td&gt;
&lt;td&gt;
Optional dtype for the RowPartition, used when dtype
is None. In some cases, a caller may not have a dtype in mind when
converting to a tensor, so dtype_hint can be used as a soft preference.
If the conversion to `dtype_hint` is not possible, this argument has no
effect.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;



&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
A `RowPartition`.
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;



&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Raises&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;
`ValueError`
&lt;/td&gt;
&lt;td&gt;
If `nrows` is incompatible with `value_rowids`.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;


#### Example:

&lt;pre class="devsite-click-to-copy prettyprint lang-py"&gt;
&lt;code class="devsite-terminal" data-terminal-prefix="&amp;gt;&amp;gt;&amp;gt;"&gt;print(RowPartition.from_value_rowids(&lt;/code&gt;
&lt;code class="devsite-terminal" data-terminal-prefix="..."&gt;    value_rowids=[0, 0, 0, 0, 2, 2, 2, 3],&lt;/code&gt;
&lt;code class="devsite-terminal" data-terminal-prefix="..."&gt;    nrows=4))&lt;/code&gt;
&lt;code class="no-select nocode"&gt;tf.RowPartition(row_splits=[0 4 4 7 8])&lt;/code&gt;
&lt;/pre&gt;


&lt;h3 id="is_uniform"&gt;&lt;code&gt;is_uniform&lt;/code&gt;&lt;/h3&gt;

&lt;a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L921-L932"&gt;View source&lt;/a&gt;

&lt;pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link"&gt;
&lt;code&gt;is_uniform()
&lt;/code&gt;&lt;/pre&gt;

Returns true if the partition is known to be uniform statically.

This is based upon the existence of self._uniform_row_length. For example:
RowPartition.from_row_lengths([3,3,3]).is_uniform()==false
RowPartition.from_uniform_row_length(5, nvals=20).is_uniform()==true
RowPartition.from_row_lengths([2,0,2]).is_uniform()==false

&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
Whether a RowPartition is known to be uniform statically.
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;



&lt;h3 id="nrows"&gt;&lt;code&gt;nrows&lt;/code&gt;&lt;/h3&gt;

&lt;a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L777-L789"&gt;View source&lt;/a&gt;

&lt;pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link"&gt;
&lt;code&gt;nrows()
&lt;/code&gt;&lt;/pre&gt;

Returns the number of rows created by this `RowPartition`.


&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
scalar integer Tensor
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;



&lt;h3 id="nvals"&gt;&lt;code&gt;nvals&lt;/code&gt;&lt;/h3&gt;

&lt;a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L762-L775"&gt;View source&lt;/a&gt;

&lt;pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link"&gt;
&lt;code&gt;nvals()
&lt;/code&gt;&lt;/pre&gt;

Returns the number of values partitioned by this `RowPartition`.

If the sequence partitioned by this `RowPartition` is a tensor, then
`nvals` is the size of that tensor's outermost dimension -- i.e.,
`nvals == values.shape[0]`.

&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
scalar integer Tensor
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;



&lt;h3 id="offsets_in_rows"&gt;&lt;code&gt;offsets_in_rows&lt;/code&gt;&lt;/h3&gt;

&lt;a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L903-L919"&gt;View source&lt;/a&gt;

&lt;pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link"&gt;
&lt;code&gt;offsets_in_rows()
&lt;/code&gt;&lt;/pre&gt;

Return the offset of each value.

RowPartition takes an array x and converts it into sublists.
offsets[i] is the index of x[i] in its sublist.
Given a shape, such as:
[*,*,*],[*,*],[],[*,*]
This returns:
0,1,2,0,1,0,1

&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
an offset for every value.
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;



&lt;h3 id="row_lengths"&gt;&lt;code&gt;row_lengths&lt;/code&gt;&lt;/h3&gt;

&lt;a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L829-L840"&gt;View source&lt;/a&gt;

&lt;pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link"&gt;
&lt;code&gt;row_lengths()
&lt;/code&gt;&lt;/pre&gt;

Returns the lengths of rows in this `RowPartition`.


&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
A 1-D integer Tensor with shape `[self.nrows]`.
The returned tensor is nonnegative.
`tf.reduce_sum(self.row_lengths) == self.nvals()`.
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;



&lt;h3 id="row_limits"&gt;&lt;code&gt;row_limits&lt;/code&gt;&lt;/h3&gt;

&lt;a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L816-L827"&gt;View source&lt;/a&gt;

&lt;pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link"&gt;
&lt;code&gt;row_limits()
&lt;/code&gt;&lt;/pre&gt;

Returns the limit indices for rows in this row partition.

These indices specify where the values for each row end.
`partition.row_limits()` is equal to `partition.row_splits()[:-1]`.

&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
A 1-D integer Tensor with shape `[self.nrows]`.
The returned tensor is nonnegative, and is sorted in ascending order.
`self.row_limits()[-1] == self.nvals()`.
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;



&lt;h3 id="row_splits"&gt;&lt;code&gt;row_splits&lt;/code&gt;&lt;/h3&gt;

&lt;a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L733-L746"&gt;View source&lt;/a&gt;

&lt;pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link"&gt;
&lt;code&gt;row_splits()
&lt;/code&gt;&lt;/pre&gt;

Returns the row-split indices for this row partition.

`row_splits` specifies where the values for each row begin and end.
In particular, the values for row `i` are stored in the slice
`values[row_splits[i]:row_splits[i+1]]`.

&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
A 1-D integer `Tensor` with shape `[self.nrows+1]`.
The returned tensor is non-empty, and is sorted in ascending order.
`self.row_splits()[0] == 0`.
`self.row_splits()[-1] == self.nvals()`.
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;



&lt;h3 id="row_starts"&gt;&lt;code&gt;row_starts&lt;/code&gt;&lt;/h3&gt;

&lt;a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L802-L814"&gt;View source&lt;/a&gt;

&lt;pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link"&gt;
&lt;code&gt;row_starts()
&lt;/code&gt;&lt;/pre&gt;

Returns the start indices for rows in this row partition.

These indices specify where the values for each row begin.
`partition.row_starts()` is equal to `partition.row_splits()[:-1]`.

&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
A 1-D integer Tensor with shape `[self.nrows()]`.
The returned tensor is nonnegative, and is sorted in ascending order.
`self.row_starts()[0] == 0`.
`self.row_starts()[-1] &lt;= self.nvals()`.
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;



&lt;h3 id="uniform_row_length"&gt;&lt;code&gt;uniform_row_length&lt;/code&gt;&lt;/h3&gt;

&lt;a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L791-L800"&gt;View source&lt;/a&gt;

&lt;pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link"&gt;
&lt;code&gt;uniform_row_length()
&lt;/code&gt;&lt;/pre&gt;

Returns the length of each row in this partition, if rows are uniform.

If all rows in this `RowPartition` have the same length, then this returns
that length as a scalar integer `Tensor`.  Otherwise, it returns `None`.

&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
scalar Tensor with `type=self.dtype`, or `None`.
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;



&lt;h3 id="value_rowids"&gt;&lt;code&gt;value_rowids&lt;/code&gt;&lt;/h3&gt;

&lt;a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L748-L760"&gt;View source&lt;/a&gt;

&lt;pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link"&gt;
&lt;code&gt;value_rowids()
&lt;/code&gt;&lt;/pre&gt;

Returns the row indices for this row partition.

`value_rowids` specifies the row index fo reach value.  In particular,
`value_rowids[i]` is the row index for `values[i]`.

&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
A 1-D integer `Tensor` with shape `[self.nvals()]`.
The returned tensor is nonnegative, and is sorted in ascending order.
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;



&lt;h3 id="with_dtype"&gt;&lt;code&gt;with_dtype&lt;/code&gt;&lt;/h3&gt;

&lt;a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.9.0/tensorflow/python/ops/ragged/row_partition.py#L963-L986"&gt;View source&lt;/a&gt;

&lt;pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link"&gt;
&lt;code&gt;with_dtype(
    dtype
)
&lt;/code&gt;&lt;/pre&gt;

Returns a copy of this RowPartition with the given encoding dtype.


&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Args&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;
`dtype`
&lt;/td&gt;
&lt;td&gt;
The dtype for encoding tensors, such as `row_splits` and `nrows`.
One of &lt;a href="../../tf.html#int32"&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href="../../tf.html#int64"&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;



&lt;!-- Tabular view --&gt;
 &lt;table class="responsive fixed orange"&gt;
&lt;colgroup&gt;&lt;col width="214px"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tr&gt;&lt;th colspan="2"&gt;Returns&lt;/th&gt;&lt;/tr&gt;
&lt;tr class="alt"&gt;
&lt;td colspan="2"&gt;
A copy of this RowPartition, with the encoding tensors cast to the given
type.
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;
</pre>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/experimental/RowPartition" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/experimental/RowPartition</a>
  </p>
</div>
