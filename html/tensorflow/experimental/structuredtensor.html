<h1 class="devsite-page-title" tabindex="-1"> tf.experimental.StructuredTensor </h1> <devsite-feature-tooltip ack-key="AckCollectionsBookmarkTooltipDismiss" analytics-category="Site-Wide Custom Events" analytics-action-show="Callout Profile displayed" analytics-action-close="Callout Profile dismissed" analytics-label="Create Collection Callout" class="devsite-page-bookmark-tooltip nocontent" dismiss-button="true" id="devsite-collections-dropdown" dismiss-button-text="Dismiss" close-button-text="Got it">    </devsite-feature-tooltip> <div class="devsite-page-title-meta"><devsite-view-release-notes></devsite-view-release-notes></div>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.experimental.StructuredTensor"> <meta itemprop="path" content="Stable"> <meta itemprop="property" content="Spec"> <meta itemprop="property" content="__eq__"> <meta itemprop="property" content="__getitem__"> <meta itemprop="property" content="__init__"> <meta itemprop="property" content="__ne__"> <meta itemprop="property" content="field_names"> <meta itemprop="property" content="field_value"> <meta itemprop="property" content="from_fields"> <meta itemprop="property" content="from_fields_and_rank"> <meta itemprop="property" content="from_pyval"> <meta itemprop="property" content="from_shape"> <meta itemprop="property" content="merge_dims"> <meta itemprop="property" content="nrows"> <meta itemprop="property" content="partition_outer_dimension"> <meta itemprop="property" content="promote"> <meta itemprop="property" content="to_pyval"> <meta itemprop="property" content="with_shape_dtype"> <meta itemprop="property" content="with_updates"> </div>   <p>A multidimensional collection of structures with the same schema.</p> <p>Inherits From: <a href="batchableextensiontype.html"><code translate="no" dir="ltr">BatchableExtensionType</code></a>, <a href="extensiontype.html"><code translate="no" dir="ltr">ExtensionType</code></a></p> <section class="expandable"> <h4 class="showalways" id="view-aliases" data-text="View aliases" tabindex="-1">View aliases</h4> <p> <b>Compat aliases for migration</b> </p>
<p>See <a href="https://www.tensorflow.org/guide/migrate">Migration guide</a> for more details.</p> <p><a href="structuredtensor.html"><code translate="no" dir="ltr">tf.compat.v1.experimental.StructuredTensor</code></a></p> </section> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.experimental.StructuredTensor(
    fields: Mapping[str, _FieldValue],
    ragged_shape: tf.experimental.DynamicRaggedShape
)
</pre></devsite-code>  <p>A <strong><code translate="no" dir="ltr">StructuredTensor</code></strong> is a multi-dimensional collection of <strong><em>structures</em></strong> with the same <strong><em>schema</em></strong>, where:</p> <ul> <li>A <strong><em>schema</em></strong> is a collection of fields, each of which has a name and type.</li> <li>A <strong><em>structure</em></strong> maps each field in the schema to a tensor value (which could be a nested StructuredTensor).</li> </ul> <p>As an important special case, a 1D <code translate="no" dir="ltr">StructuredTensor</code> encodes a 2D table, where columns are heterogeneous <code translate="no" dir="ltr">Tensor</code>s, and rows are the aligned elements in each of those <code translate="no" dir="ltr">Tensor</code>s.</p> <p>Internally, StructuredTensors use a "field-major" encoding: for each leaf field, there is a single tensor that stores the value of that field for all structures in the <code translate="no" dir="ltr">StructuredTensor</code>.</p> <h3 id="examples" data-text="Examples" tabindex="-1">Examples</h3> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># A scalar StructuredTensor describing a single person.
s1 = tf.experimental.StructuredTensor.from_pyval(
    {"age": 82, "nicknames": ["Bob", "Bobby"]})
s1.shape
TensorShape([])
s1["age"]
&lt;tf.Tensor: shape=(), dtype=int32, numpy=82&gt;</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># A vector StructuredTensor describing three people.
s2 = tf.experimental.StructuredTensor.from_pyval([
    {"age": 12, "nicknames": ["Josaphine"]},
    {"age": 82, "nicknames": ["Bob", "Bobby"]},
    {"age": 42, "nicknames": ["Elmo"]}])
s2.shape
TensorShape([3])
s2[0]["age"]
&lt;tf.Tensor: shape=(), dtype=int32, numpy=12&gt;</pre></devsite-code> <h3 id="field_paths" data-text="Field Paths" tabindex="-1">Field Paths</h3> <p>A <em>field path</em> is a tuple of field names, specifying the path to a nested field.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">rank</code> </td> <td> The rank of this StructuredTensor. Guaranteed not to be <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_partitions</code> </td> <td> A tuple of <code translate="no" dir="ltr">RowPartition</code>s defining the shape of this <code translate="no" dir="ltr">StructuredTensor</code>. <p>When <code translate="no" dir="ltr">self.rank &lt;= 1</code>, this tuple will be empty.</p> <p>When <code translate="no" dir="ltr">self.rank &gt; 1</code>, these <code translate="no" dir="ltr">RowPartitions</code> define the shape of the <code translate="no" dir="ltr">StructuredTensor</code> by describing how a flat (1D) list of structures can be repeatedly partitioned to form a higher-dimensional object. In particular, the flat list is first partitioned into sublists using <code translate="no" dir="ltr">row_partitions[-1]</code>, and then those sublists are further partitioned using <code translate="no" dir="ltr">row_partitions[-2]</code>, etc. The following examples show the row partitions used to describe several different <code translate="no" dir="ltr">StructuredTensor</code>, each of which contains 8 copies of the same structure (<code translate="no" dir="ltr">x</code>):</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">x = {'a': 1, 'b': ['foo', 'bar', 'baz']}       # shape = [] (scalar)</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">s1 = [[x, x, x, x], [x, x, x, x]]              # shape = [2, 4]
tf.experimental.StructuredTensor.from_pyval(s1).row_partitions
(tf.RowPartition(row_splits=[0 4 8]),)</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">s2 = [[x, x], [x, x], [x, x], [x, x]]          # shape = [4, 2]
tf.experimental.StructuredTensor.from_pyval(s2).row_partitions
(tf.RowPartition(row_splits=[0 2 4 6 8]),)</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">s3 = [[x, x, x], [], [x, x, x, x], [x]]        # shape = [2, None]
tf.experimental.StructuredTensor.from_pyval(s3).row_partitions
(tf.RowPartition(row_splits=[0 3 3 7 8]),)</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">s4 = [[[x, x], [x, x]], [[x, x], [x, x]]]      # shape = [2, 2, 2]
tf.experimental.StructuredTensor.from_pyval(s4).row_partitions
(tf.RowPartition(row_splits=[0 2 4]),
 tf.RowPartition(row_splits=[0 2 4 6 8]))</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">s5 = [[[x, x], [x]], [[x, x]], [[x, x], [x]]]  # shape = [3, None, None]
tf.experimental.StructuredTensor.from_pyval(s5).row_partitions
(tf.RowPartition(row_splits=[0 2 3 5]),
 tf.RowPartition(row_splits=[0 2 3 5 7 8]))</pre></devsite-code> <p>Note that shapes for nested fields (such as <code translate="no" dir="ltr">x['b']</code> in the above example) are not considered part of the shape of a <code translate="no" dir="ltr">StructuredTensor</code>, and are not included in <code translate="no" dir="ltr">row_partitions</code>.</p> <p>If this <code translate="no" dir="ltr">StructuredTensor</code> has a ragged shape (i.e., if any of the <code translate="no" dir="ltr">row_partitions</code> is not uniform in size), then all fields will be encoded as either <code translate="no" dir="ltr">RaggedTensor</code>s or <code translate="no" dir="ltr">StructuredTensor</code>s with these <code translate="no" dir="ltr">RowPartition</code>s used to define their outermost <code translate="no" dir="ltr">self.rank</code> dimensions. </p>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">shape</code> </td> <td> The static shape of this StructuredTensor. <p>The returned <code translate="no" dir="ltr">TensorShape</code> is guaranteed to have a known rank, but the individual dimension sizes may be unknown. </p>
</td> </tr> </table> <h2 id="child_classes" data-text="Child Classes" tabindex="-1">Child Classes</h2> <p><a href="structuredtensor/spec.html"><code translate="no" dir="ltr">class Spec</code></a></p> <h2 id="methods" data-text="Methods" tabindex="-1">Methods</h2> <h3 id="field_names" data-text="field_names" tabindex="-1"><code translate="no" dir="ltr">field_names</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L681-L683">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">field_names()
</pre></devsite-code> <p>Returns the string field names for this <code translate="no" dir="ltr">StructuredTensor</code>.</p> <h3 id="field_value" data-text="field_value" tabindex="-1"><code translate="no" dir="ltr">field_value</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L685-L717">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">field_value(
    field_name
)
</pre></devsite-code> <p>Returns the tensor value for the specified field or path.</p> <p>If <code translate="no" dir="ltr">field_name</code> is a <code translate="no" dir="ltr">string</code>, then it names a field directly owned by this <code translate="no" dir="ltr">StructuredTensor</code>. If this <code translate="no" dir="ltr">StructuredTensor</code> has shape <code translate="no" dir="ltr">[D1...DN]</code>, then the returned tensor will have shape <code translate="no" dir="ltr">[D1...DN, V1...VM]</code>, where the slice <code translate="no" dir="ltr">result[d1...dN]</code> contains the field value for the structure at <code translate="no" dir="ltr">self[d1...dN]</code>.</p> <p>If <code translate="no" dir="ltr">field_name</code> is a <code translate="no" dir="ltr">tuple</code> of <code translate="no" dir="ltr">string</code>, then it specifies a path to a field owned by nested <code translate="no" dir="ltr">StructuredTensor</code>. In particular, <code translate="no" dir="ltr">struct.field_value((f1, f2, ..., fN))</code> is equivalent to <code translate="no" dir="ltr">struct.field_value(f1).field_value(f2)....field_value(fN)</code></p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">field_name</code> </td> <td> <code translate="no" dir="ltr">string</code> or <code translate="no" dir="ltr">tuple</code> of <code translate="no" dir="ltr">string</code>: The field whose values should be returned. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">Tensor</code>, <code translate="no" dir="ltr">StructuredTensor</code>, or <code translate="no" dir="ltr">RaggedTensor</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">KeyError</code> </td> <td> If the given field_name is not found. </td> </tr> </table> <h3 id="from_fields" data-text="from_fields" tabindex="-1"><code translate="no" dir="ltr">from_fields</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L163-L251">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@classmethod
from_fields(
    fields, shape=(), nrows=None, row_partitions=None, validate=False
)
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">StructuredTensor</code> from a dictionary of fields.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">fields</code> </td> <td> A dictionary mapping from string to <code translate="no" dir="ltr">Tensor</code>, <code translate="no" dir="ltr">RaggedTensor</code>, or <code translate="no" dir="ltr">StructuredTensor</code>, providing the values for individual fields in each structure. If <code translate="no" dir="ltr">shape.rank &gt; 0</code>, then every tensor in <code translate="no" dir="ltr">fields</code> must have the same shape in the first <code translate="no" dir="ltr">shape.rank</code> dimensions; and that shape must be compatible with <code translate="no" dir="ltr">shape</code>; and <code translate="no" dir="ltr">result[i1...iN][key] = fields[key][i1...iN]</code> (where <code translate="no" dir="ltr">N==shape.rank</code>). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shape</code> </td> <td> A <code translate="no" dir="ltr">TensorShape</code>: static information about the shape of the <code translate="no" dir="ltr">StructuredTensor</code>. Must have a known <code translate="no" dir="ltr">rank</code>. Defaults to scalar shape (i.e. <code translate="no" dir="ltr">rank=0</code>). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">nrows</code> </td> <td> scalar integer tensor containing the number of rows in this <code translate="no" dir="ltr">StructuredTensor</code>. Should only be specified if <code translate="no" dir="ltr">shape.rank &gt; 0</code>. Default value is inferred from the <code translate="no" dir="ltr">fields</code> values. If <code translate="no" dir="ltr">fields</code> is empty, then this must be specified. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_partitions</code> </td> <td> A list of <code translate="no" dir="ltr">RowPartition</code>s describing the (possibly ragged) shape of this <code translate="no" dir="ltr">StructuredTensor</code>. Should only be specified if <code translate="no" dir="ltr">shape.rank &gt; 1</code>. Default value is inferred from the <code translate="no" dir="ltr">fields</code> values. If <code translate="no" dir="ltr">fields</code> is empty, then this must be specified. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then add runtime validation ops that check that the field values all have compatible shapes in the outer <code translate="no" dir="ltr">shape.rank</code> dimensions. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">StructuredTensor</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Examples</th></tr> <tr class="alt"> <td colspan="2"> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">&gt;&gt;&gt; tf.experimental.StructuredTensor.from_fields({'x': 1, 'y': [1, 2, 3]})
&lt;StructuredTensor(
  fields={
    "x": tf.Tensor(1, shape=(), dtype=int32),
    "y": tf.Tensor([1 2 3], shape=(3,), dtype=int32)},
  shape=())&gt;
</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.experimental.StructuredTensor.from_fields(
    {'foo': [1, 2], 'bar': [3, 4]}, shape=[2])
&lt;StructuredTensor(
  fields={
    "bar": tf.Tensor([3 4], shape=(2,), dtype=int32),
    "foo": tf.Tensor([1 2], shape=(2,), dtype=int32)},
  shape=(2,))&gt;</pre></devsite-code> 
</td> </tr> 
</table> <h3 id="from_fields_and_rank" data-text="from_fields_and_rank" tabindex="-1"><code translate="no" dir="ltr">from_fields_and_rank</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L253-L318">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@classmethod
from_fields_and_rank(
    fields: Mapping[str, _FieldValue],
    rank: int,
    validate: bool = False,
    dtype: Optional[tf.dtypes.DType] = None
) -&gt; 'StructuredTensor'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">StructuredTensor</code> from a nonempty dictionary of fields.</p> <p>Note that if the shape dtype is not specified, the shape dtype will be inferred from any fields that have a shape dtype. If fields differ, then int64 will be preferred to int32, because coercing from int32 to int64 is safer than coercing from int64 to int32.</p> <p>If there are no ragged fields, then it will be int64 by default, but this will be changed to int32 in the future.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">fields</code> </td> <td> A dictionary mapping from string to <code translate="no" dir="ltr">Tensor</code>, <code translate="no" dir="ltr">RaggedTensor</code>, or <code translate="no" dir="ltr">StructuredTensor</code>, providing the values for individual fields in each structure. If <code translate="no" dir="ltr">rank &gt; 0</code>, then every tensor in <code translate="no" dir="ltr">fields</code> must have the same shape in the first <code translate="no" dir="ltr">rank</code> dimensions. Cannot be empty. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">rank</code> </td> <td> The rank of the resulting structured tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then add runtime validation ops that check that the field values all have compatible shapes in the outer <code translate="no" dir="ltr">rank</code> dimensions. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> If specified, then forces dtype of the shape to be this. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">StructuredTensor</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Examples</th></tr> <tr class="alt"> <td colspan="2"> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">&gt;&gt;&gt; tf.experimental.StructuredTensor.from_fields_and_rank(
...     {'x': 1, 'y': [1, 2, 3]}, 0)
&lt;StructuredTensor(
  fields={
    "x": tf.Tensor(1, shape=(), dtype=int32),
    "y": tf.Tensor([1 2 3], shape=(3,), dtype=int32)},
  shape=())&gt;
&gt;&gt;&gt; StructuredTensor.from_fields_and_rank({'foo': [1, 2], 'bar': [3, 4]},
...                              1)
&lt;StructuredTensor(
  fields={
    "bar": tf.Tensor([3 4], shape=(2,), dtype=int32),
    "foo": tf.Tensor([1 2], shape=(2,), dtype=int32)},
  shape=(2,))&gt;
</pre></devsite-code> 
</td> </tr> 
</table> <h3 id="from_pyval" data-text="from_pyval" tabindex="-1"><code translate="no" dir="ltr">from_pyval</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L881-L906">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@classmethod
from_pyval(
    pyval, typespec=None
)
</pre></devsite-code> <p>Constructs a StructuredTensor from a nested Python structure.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.experimental.StructuredTensor.from_pyval(
    {'a': [1, 2, 3], 'b': [[4, 5], [6, 7]]})
&lt;StructuredTensor(
    fields={
      "a": tf.Tensor([1 2 3], shape=(3,), dtype=int32),
      "b": &lt;tf.RaggedTensor [[4, 5], [6, 7]]&gt;},
    shape=())&gt;</pre></devsite-code> <p>Note that <code translate="no" dir="ltr">StructuredTensor.from_pyval(pyval).to_pyval() == pyval</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">pyval</code> </td> <td> The nested Python structure that should be used to create the new <code translate="no" dir="ltr">StructuredTensor</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">typespec</code> </td> <td> A <a href="structuredtensor/spec.html"><code translate="no" dir="ltr">StructuredTensor.Spec</code></a> specifying the expected type for each field. If not specified, then all nested dictionaries are turned into StructuredTensors, and all nested lists are turned into Tensors (if rank&lt;2) or RaggedTensors (if rank&gt;=2). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">StructuredTensor</code>. </td> </tr> 
</table> <h3 id="from_shape" data-text="from_shape" tabindex="-1"><code translate="no" dir="ltr">from_shape</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L149-L161">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@classmethod
from_shape(
    ragged_shape: tf.experimental.DynamicRaggedShape
) -&gt; 'StructuredTensor'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">StructuredTensor</code> with no fields and ragged_shape.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ragged_shape</code> </td> <td> the shape of the structured tensor. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> a StructuredTensor with no fields and ragged_shape. </td> </tr> 
</table> <h3 id="merge_dims" data-text="merge_dims" tabindex="-1"><code translate="no" dir="ltr">merge_dims</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L1099-L1138">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">merge_dims(
    outer_axis, inner_axis
)
</pre></devsite-code> <p>Merges outer_axis...inner_axis into a single dimension.</p> <p>Returns a copy of this RaggedTensor with the specified range of dimensions flattened into a single dimension, with elements in row-major order.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">st = tf.experimental.StructuredTensor.from_pyval(
    [[{'foo': 12}, {'foo': 33}], [], [{'foo': 99}]])
st.merge_dims(0, 1)
&lt;StructuredTensor(
  fields={
    "foo": tf.Tensor([12 33 99], shape=(3,), dtype=int32)},
  shape=(3,))&gt;</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">outer_axis</code> </td> <td> <code translate="no" dir="ltr">int</code>: The first dimension in the range of dimensions to merge. May be negative (to index from the last dimension). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">inner_axis</code> </td> <td> <code translate="no" dir="ltr">int</code>: The last dimension in the range of dimensions to merge. May be negative (to index from the last dimension). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A copy of this tensor, with the specified dimensions merged into a single dimension. The shape of the returned tensor will be <code translate="no" dir="ltr">self.shape[:outer_axis] + [N] + self.shape[inner_axis + 1:]</code>, where <code translate="no" dir="ltr">N</code> is the total number of slices in the merged dimensions. </td> </tr> 
</table> <h3 id="nrows" data-text="nrows" tabindex="-1"><code translate="no" dir="ltr">nrows</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L647-L663">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">nrows()
</pre></devsite-code> <p>The number of rows in this StructuredTensor (if rank&gt;0).</p> <p>This means the length of the outer-most dimension of the StructuredTensor.</p> <p>Notice that if <code translate="no" dir="ltr">self.rank &gt; 1</code>, then this equals the number of rows of the first row partition. That is, <code translate="no" dir="ltr">self.nrows() == self.row_partitions[0].nrows()</code>.</p> <p>Otherwise <code translate="no" dir="ltr">self.nrows()</code> will be the first dimension of the field values.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A scalar integer <code translate="no" dir="ltr">Tensor</code> (or <code translate="no" dir="ltr">None</code> if <code translate="no" dir="ltr">self.rank == 0</code>). </td> </tr> 
</table> <h3 id="partition_outer_dimension" data-text="partition_outer_dimension" tabindex="-1"><code translate="no" dir="ltr">partition_outer_dimension</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L1070-L1097">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">partition_outer_dimension(
    row_partition
)
</pre></devsite-code> <p>Partitions the outer dimension of this StructuredTensor.</p> <p>Returns a new <code translate="no" dir="ltr">StructuredTensor</code> with the same values as <code translate="no" dir="ltr">self</code>, where the outer dimension is partitioned into two (possibly ragged) dimensions. Requires that this StructuredTensor have an outer dimension (i.e., <code translate="no" dir="ltr">self.shape.rank &gt; 0</code>).</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">st = tf.experimental.StructuredTensor.from_pyval(
    [{'foo': 12}, {'foo': 33}, {'foo': 99}])
partition = RowPartition.from_row_lengths([2, 0, 1])
st.partition_outer_dimension(partition)
&lt;StructuredTensor(
  fields={
    "foo": &lt;tf.RaggedTensor [[12, 33], [], [99]]&gt;},
  shape=(3, None))&gt;</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">row_partition</code> </td> <td> A <code translate="no" dir="ltr">RowPartition</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">StructuredTensor</code> with rank <code translate="no" dir="ltr">values.rank + 1</code>. </td> </tr> 
</table> <h3 id="promote" data-text="promote" tabindex="-1"><code translate="no" dir="ltr">promote</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L520-L558">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">promote(
    source_path, new_name
)
</pre></devsite-code> <p>Promotes a field, merging dimensions between grandparent and parent.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">d = [
 {'docs': [{'tokens':[1, 2]}, {'tokens':[3]}]},
 {'docs': [{'tokens':[7]}]}]
st = tf.experimental.StructuredTensor.from_pyval(d)
st2 =st.promote(('docs','tokens'), 'docs_tokens')
st2[0]['docs_tokens']
&lt;tf.Tensor: shape=(3,), dtype=int32, numpy=array([1, 2, 3], dtype=int32)&gt;
st2[1]['docs_tokens']
&lt;tf.Tensor: shape=(1,), dtype=int32, numpy=array([7], dtype=int32)&gt;</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">source_path</code> </td> <td> the path of the field or substructure to promote; must have length at least 2. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">new_name</code> </td> <td> the name of the new field (must be a string). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> a modified structured tensor with the new field as a child of the grandparent of the source_path. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> if source_path is not a list or a tuple or has a length less than two, or new_name is not a string, or the rank of source_path is unknown and it is needed. </td> </tr> </table> <h3 id="to_pyval" data-text="to_pyval" tabindex="-1"><code translate="no" dir="ltr">to_pyval</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L823-L879">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">to_pyval()
</pre></devsite-code> <p>Returns this StructuredTensor as a nested Python dict or list of dicts.</p> <p>Converts this <code translate="no" dir="ltr">StructuredTensor</code> to a nested python value:</p> <ul> <li>
<p><code translate="no" dir="ltr">StructTensors</code> with <code translate="no" dir="ltr">rank=0</code> are converted into a dictionary, with an entry for each field. Field names are used as keys and field values are converted to python values. In particular:</p> <ul> <li>Scalar Tensor fields are converted to simple values (such as <code translate="no" dir="ltr">int</code> or <code translate="no" dir="ltr">float</code> or <code translate="no" dir="ltr">string</code>)</li> <li>Non-scalar Tensor fields and RaggedTensor fields are converted to nested lists of simple values.</li> <li>StructuredTensor fields are converted recursively using <code translate="no" dir="ltr">to_pyval</code>.</li> </ul>
</li> <li><p><code translate="no" dir="ltr">StructTensors</code> with <code translate="no" dir="ltr">rank&gt;0</code> are converted to nested python <code translate="no" dir="ltr">list</code>s, containing one dictionary for each structure (where each structure's dictionary is defined as described above).</p></li> </ul> <p>Requires that all fields are Eager tensors.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.experimental.StructuredTensor.from_fields(
    {'a': [1, 2, 3]}, [3]).to_pyval()
[{'a': 1}, {'a': 2}, {'a': 3}]</pre></devsite-code> <p>Note that <code translate="no" dir="ltr">StructuredTensor.from_pyval(pyval).to_pyval() == pyval</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A nested Python dict or list of dicts. </td> </tr> 
</table> <h3 id="with_shape_dtype" data-text="with_shape_dtype" tabindex="-1"><code translate="no" dir="ltr">with_shape_dtype</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L665-L670">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">with_shape_dtype(
    dtype: tf.dtypes.DType
) -&gt; 'StructuredTensor'
</pre></devsite-code> <h3 id="with_updates" data-text="with_updates" tabindex="-1"><code translate="no" dir="ltr">with_updates</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L320-L407">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">with_updates(
    updates: Dict[FieldName, Union[_FieldValue, _FieldFn, None]],
    validate: bool = False
) -&gt; 'StructuredTensor'
</pre></devsite-code> <p>Creates a new <code translate="no" dir="ltr">StructuredTensor</code> with the updated fields.</p> <p>If this <code translate="no" dir="ltr">StructuredTensor</code> is a scalar, and <code translate="no" dir="ltr">k</code> is the <code translate="no" dir="ltr">FieldName</code> being updated and <code translate="no" dir="ltr">v</code> the new value, then:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">result[k] = v              # If (k, v) is in updates and v is a FieldValue
result[k] = f(self[k])     # If (k, f) is in updates and f is a FieldFn
result[k] = self[k]        # If k is in self.field_names but not in updates
</pre></devsite-code> <p>If this <code translate="no" dir="ltr">StructuredTensor</code> has rank <code translate="no" dir="ltr">N</code> and shape <code translate="no" dir="ltr">[D1...DN]</code>, then each FieldValue <code translate="no" dir="ltr">v</code> in <code translate="no" dir="ltr">updates</code> must have shape <code translate="no" dir="ltr">[D1...DN, ...]</code>, that is, prefixed with the same shape as the <code translate="no" dir="ltr">StructuredTensor</code>. Then the resulting <code translate="no" dir="ltr">StructuredTensor</code> will have:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">result[i1...iN][k] = v[i1...iN]                        # (k, v) in updates
result[i1...iN][k] = f(self.field_value(k))[i1...iN]   # (k, f) in updates
result[i1...iN][k] = self[i1...iN][k]                  # k not in updates
</pre></devsite-code> <p>Note that <code translate="no" dir="ltr">result.shape</code> is always equal to <code translate="no" dir="ltr">self.shape</code> (but the shapes of nested StructuredTensors may be changed if they are updated with new values).</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">updates</code> </td> <td> A dictionary mapping <code translate="no" dir="ltr">FieldName</code> to either a <code translate="no" dir="ltr">FieldValue</code> to be used to update, or a <code translate="no" dir="ltr">FieldFn</code> that will transform the value for the given <code translate="no" dir="ltr">FieldName</code>. <code translate="no" dir="ltr">FieldName</code> can be a string for a direct field, or a sequence of strings to refer to a nested sub-field. <code translate="no" dir="ltr">FieldFn</code> is a function that takes a <code translate="no" dir="ltr">FieldValue</code> as input and should return a <code translate="no" dir="ltr">FieldValue</code>. All other fields are copied over to the new <code translate="no" dir="ltr">StructuredTensor</code>. New <code translate="no" dir="ltr">FieldName</code> can be given (to add new fields), but only to existing <code translate="no" dir="ltr">StructuredTensor</code>, it won't automatically create new nested structures -- but one can create a whole <code translate="no" dir="ltr">StructureTensor</code> sub-structure and set that into an existing structure. If the new value is set to <code translate="no" dir="ltr">None</code>, it is removed. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">validate</code> </td> <td> If true, then add runtime validation ops that check that the field values all have compatible shapes in the outer <code translate="no" dir="ltr">shape.rank</code> dimensions. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">StructuredTensor</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">ValueError</code>: If the any of the <code translate="no" dir="ltr">FieldName</code> keys points to non-existent sub-structures, if parent and child nodes are updated, if shapes change, if a delete update is given for a non-existent field, or if a <code translate="no" dir="ltr">FieldFn</code> transforming function is given for a <code translate="no" dir="ltr">FieldName</code> that doesn't yet exist. </td> </tr> 
</table> <h4 id="examples_2" data-text="Examples:" tabindex="-1">Examples:</h4> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">shoes_us = tf.experimental.StructuredTensor.from_pyval([
   {"age": 12, "nicknames": ["Josaphine"],
      "shoes": {"sizes": [8.0, 7.5, 7.5]} },
   {"age": 82, "nicknames": ["Bob", "Bobby"],
       "shoes": {"sizes": [11.0, 11.5, 12.0]} },
   {"age": 42, "nicknames": ["Elmo"],
       "shoes": {"sizes": [9.0, 9.5, 10.0]} }])
def us_to_europe(t):
  return tf.round(t * 2.54 + 17.0)  # Rough approximation.
shoe_sizes_key = ("shoes", "sizes")
shoes_eu = shoes_us.with_updates({shoe_sizes_key: us_to_europe})
shoes_eu.field_value(shoe_sizes_key)
&lt;tf.RaggedTensor [[37.0, 36.0, 36.0], [45.0, 46.0, 47.0],
[40.0, 41.0, 42.0]]&gt;</pre></devsite-code> <h3 id="__eq__" data-text="__eq__" tabindex="-1"><code translate="no" dir="ltr">__eq__</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/framework/extension_type.py#L276-L305">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">__eq__(
    other
)
</pre></devsite-code> <p>Return self==value.</p> <h3 id="__getitem__" data-text="__getitem__" tabindex="-1"><code translate="no" dir="ltr">__getitem__</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/ops/structured/structured_tensor.py#L724-L767">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">__getitem__(
    key
)
</pre></devsite-code> <p>Returns the specified piece of this StructuredTensor.</p> <ul> <li><p>If <code translate="no" dir="ltr">struct_tensor</code> is scalar (i.e., a single structure), then <code translate="no" dir="ltr">struct_tensor[f]</code> returns the value of field <code translate="no" dir="ltr">f</code> (where <code translate="no" dir="ltr">f</code> must be a string).</p></li> <li>
<p>If <code translate="no" dir="ltr">struct_tensor</code> is non-scalar (i.e., a vector or higher-dimensional tensor of structures), <code translate="no" dir="ltr">struct_tensor[i]</code> selects an element or slice of the tensor using standard Python semantics (e.g., negative values index from the end). <code translate="no" dir="ltr">i</code> may have any of the following types:</p> <ul> <li>
<code translate="no" dir="ltr">int</code> constant</li> <li>
<code translate="no" dir="ltr">string</code> constant</li> <li>scalar integer <code translate="no" dir="ltr">Tensor</code>
</li> <li>
<code translate="no" dir="ltr">slice</code> containing integer constants and/or scalar integer <code translate="no" dir="ltr">Tensor</code>s</li> </ul>
</li> </ul> <h4 id="multidimensional_indexing" data-text="Multidimensional indexing" tabindex="-1">Multidimensional indexing</h4> <p><code translate="no" dir="ltr">StructuredTensor</code> supports multidimensional indexing. I.e., <code translate="no" dir="ltr">key</code> may be a <code translate="no" dir="ltr">tuple</code> of values, indexing or slicing multiple dimensions at once. For example, if <code translate="no" dir="ltr">people</code> is a vector of structures, each of which has a vector- valued <code translate="no" dir="ltr">names</code> field, then <code translate="no" dir="ltr">people[3, 'names', 0]</code> is equivalent to <code translate="no" dir="ltr">people[3]['names'][0]</code>; and <code translate="no" dir="ltr">people[:, 'names', :]</code> will return a (possibly ragged) matrix of names, with shape <code translate="no" dir="ltr">[num_people, num_names_per_person]</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">key</code> </td> <td> Indicates which piece of the StructuredTensor to return. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>, <code translate="no" dir="ltr">StructuredTensor</code>, or <code translate="no" dir="ltr">RaggedTensor</code>. </td> </tr> 
</table> <h3 id="__ne__" data-text="__ne__" tabindex="-1"><code translate="no" dir="ltr">__ne__</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/framework/extension_type.py#L307-L312">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">__ne__(
    other
)
</pre></devsite-code> <p>Return self!=value.</p>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/experimental/StructuredTensor" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/experimental/StructuredTensor</a>
  </p>
</div>
