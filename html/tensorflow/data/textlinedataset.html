<h1 class="devsite-page-title" tabindex="-1"> tf.data.TextLineDataset </h1> <devsite-feature-tooltip ack-key="AckCollectionsBookmarkTooltipDismiss" analytics-category="Site-Wide Custom Events" analytics-action-show="Callout Profile displayed" analytics-action-close="Callout Profile dismissed" analytics-label="Create Collection Callout" class="devsite-page-bookmark-tooltip nocontent" dismiss-button="true" id="devsite-collections-dropdown" dismiss-button-text="Dismiss" close-button-text="Got it">    </devsite-feature-tooltip> <div class="devsite-page-title-meta"><devsite-view-release-notes></devsite-view-release-notes></div>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.data.TextLineDataset"> <meta itemprop="path" content="Stable"> <meta itemprop="property" content="__bool__"> <meta itemprop="property" content="__init__"> <meta itemprop="property" content="__iter__"> <meta itemprop="property" content="__len__"> <meta itemprop="property" content="__nonzero__"> <meta itemprop="property" content="apply"> <meta itemprop="property" content="as_numpy_iterator"> <meta itemprop="property" content="batch"> <meta itemprop="property" content="bucket_by_sequence_length"> <meta itemprop="property" content="cache"> <meta itemprop="property" content="cardinality"> <meta itemprop="property" content="choose_from_datasets"> <meta itemprop="property" content="concatenate"> <meta itemprop="property" content="counter"> <meta itemprop="property" content="enumerate"> <meta itemprop="property" content="filter"> <meta itemprop="property" content="fingerprint"> <meta itemprop="property" content="flat_map"> <meta itemprop="property" content="from_generator"> <meta itemprop="property" content="from_tensor_slices"> <meta itemprop="property" content="from_tensors"> <meta itemprop="property" content="get_single_element"> <meta itemprop="property" content="group_by_window"> <meta itemprop="property" content="ignore_errors"> <meta itemprop="property" content="interleave"> <meta itemprop="property" content="list_files"> <meta itemprop="property" content="load"> <meta itemprop="property" content="map"> <meta itemprop="property" content="options"> <meta itemprop="property" content="padded_batch"> <meta itemprop="property" content="prefetch"> <meta itemprop="property" content="ragged_batch"> <meta itemprop="property" content="random"> <meta itemprop="property" content="range"> <meta itemprop="property" content="rebatch"> <meta itemprop="property" content="reduce"> <meta itemprop="property" content="rejection_resample"> <meta itemprop="property" content="repeat"> <meta itemprop="property" content="sample_from_datasets"> <meta itemprop="property" content="save"> <meta itemprop="property" content="scan"> <meta itemprop="property" content="shard"> <meta itemprop="property" content="shuffle"> <meta itemprop="property" content="skip"> <meta itemprop="property" content="snapshot"> <meta itemprop="property" content="sparse_batch"> <meta itemprop="property" content="take"> <meta itemprop="property" content="take_while"> <meta itemprop="property" content="unbatch"> <meta itemprop="property" content="unique"> <meta itemprop="property" content="window"> <meta itemprop="property" content="with_options"> <meta itemprop="property" content="zip"> </div>   <p>Creates a <code translate="no" dir="ltr">Dataset</code> comprising lines from one or more text files.</p> <p>Inherits From: <a href="dataset.html"><code translate="no" dir="ltr">Dataset</code></a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.data.TextLineDataset(
    filenames,
    compression_type=None,
    buffer_size=None,
    num_parallel_reads=None,
    name=None
)
</pre></devsite-code> <h3 id="used-in-the-notebooks" data-text="Used in the notebooks" tabindex="-1">Used in the notebooks</h3> <table class="vertical-rules"> <thead> <tr> <th>Used in the guide</th> <th>Used in the tutorials</th> </tr> </thead> <tbody> <tr> <td> <ul> <li><a href="https://www.tensorflow.org/guide/data">tf.data: Build TensorFlow input pipelines</a></li> </ul> </td> <td> <ul> <li><a href="https://www.tensorflow.org/tutorials/load_data/csv">Load CSV data</a></li> <li><a href="https://www.tensorflow.org/tutorials/customization/basics">Customization basics: tensors and operations</a></li> <li><a href="https://www.tensorflow.org/tutorials/load_data/text">Load text</a></li> <li><a href="https://www.tensorflow.org/text/tutorials/word2vec">word2vec</a></li> </ul> </td> </tr> </tbody> </table> <p>The <a href="textlinedataset.html"><code translate="no" dir="ltr">tf.data.TextLineDataset</code></a> loads text from text files and creates a dataset where each line of the files becomes an element of the dataset.</p> <p>For example, suppose we have 2 files "text_lines0.txt" and "text_lines1.txt" with the following lines:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">with open('/tmp/text_lines0.txt', 'w') as f:
  f.write('the cow\n')
  f.write('jumped over\n')
  f.write('the moon\n')
with open('/tmp/text_lines1.txt', 'w') as f:
  f.write('jack and jill\n')
  f.write('went up\n')
  f.write('the hill\n')</pre></devsite-code> <p>We can construct a TextLineDataset from them as follows:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.TextLineDataset(['/tmp/text_lines0.txt',
                                   '/tmp/text_lines1.txt'])</pre></devsite-code> <p>The elements of the dataset are expected to be:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">for element in dataset.as_numpy_iterator():
  print(element)
b'the cow'
b'jumped over'
b'the moon'
b'jack and jill'
b'went up'
b'the hill'</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">filenames</code> </td> <td> A <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a> whose elements are <a href="../../tf.html#string"><code translate="no" dir="ltr">tf.string</code></a> scalars, a <a href="../../tf.html#string"><code translate="no" dir="ltr">tf.string</code></a> tensor, or a value that can be converted to a <a href="../../tf.html#string"><code translate="no" dir="ltr">tf.string</code></a> tensor (such as a list of Python strings). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">compression_type</code> </td> <td> (Optional.) A <a href="../../tf.html#string"><code translate="no" dir="ltr">tf.string</code></a> scalar evaluating to one of <code translate="no" dir="ltr">""</code> (no compression), <code translate="no" dir="ltr">"ZLIB"</code>, or <code translate="no" dir="ltr">"GZIP"</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">buffer_size</code> </td> <td> (Optional.) A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar denoting the number of bytes to buffer. A value of 0 results in the default buffering values chosen based on the compression type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">num_parallel_reads</code> </td> <td> (Optional.) A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar representing the number of files to read in parallel. If greater than one, the records of files read in parallel are outputted in an interleaved order. If your input pipeline is I/O bottlenecked, consider setting this parameter to a value greater than one to parallelize the I/O. If <code translate="no" dir="ltr">None</code>, files will be read sequentially. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">element_spec</code> </td> <td> The type specification of an element of this dataset. 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])
dataset.element_spec
TensorSpec(shape=(), dtype=tf.int32, name=None)</pre></devsite-code> <p>For more information, read <a href="https://www.tensorflow.org/guide/data#dataset_structure">this guide</a>. </p>
</td> </tr> </table> <h2 id="methods" data-text="Methods" tabindex="-1">Methods</h2> <h3 id="apply" data-text="apply" tabindex="-1"><code translate="no" dir="ltr">apply</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2521-L2548">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">apply(
    transformation_func
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Applies a transformation function to this dataset.</p> <p><code translate="no" dir="ltr">apply</code> enables chaining of custom <code translate="no" dir="ltr">Dataset</code> transformations, which are represented as functions that take one <code translate="no" dir="ltr">Dataset</code> argument and return a transformed <code translate="no" dir="ltr">Dataset</code>.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(100)
def dataset_fn(ds):
  return ds.filter(lambda x: x &lt; 5)
dataset = dataset.apply(dataset_fn)
list(dataset.as_numpy_iterator())
[0, 1, 2, 3, 4]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">transformation_func</code> </td> <td> A function that takes one <code translate="no" dir="ltr">Dataset</code> argument and returns a <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="as_numpy_iterator" data-text="as_numpy_iterator" tabindex="-1"><code translate="no" dir="ltr">as_numpy_iterator</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L571-L628">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">as_numpy_iterator()
</pre></devsite-code> <p>Returns an iterator which converts all elements of the dataset to numpy.</p> <p>Use <code translate="no" dir="ltr">as_numpy_iterator</code> to inspect the content of your dataset. To see element shapes and types, print dataset elements directly instead of using <code translate="no" dir="ltr">as_numpy_iterator</code>.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])
for element in dataset:
  print(element)
tf.Tensor(1, shape=(), dtype=int32)
tf.Tensor(2, shape=(), dtype=int32)
tf.Tensor(3, shape=(), dtype=int32)</pre></devsite-code> <p>This method requires that you are running in eager mode and the dataset's element_spec contains only <code translate="no" dir="ltr">TensorSpec</code> components.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])
for element in dataset.as_numpy_iterator():
  print(element)
1
2
3</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])
print(list(dataset.as_numpy_iterator()))
[1, 2, 3]</pre></devsite-code> <p><code translate="no" dir="ltr">as_numpy_iterator()</code> will preserve the nested structure of dataset elements.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices({'a': ([1, 2], [3, 4]),
                                              'b': [5, 6]})
list(dataset.as_numpy_iterator()) == [{'a': (1, 3), 'b': 5},
                                      {'a': (2, 4), 'b': 6}]
True</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An iterable over the elements of the dataset, with their tensors converted to numpy arrays. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> if an element contains a non-<code translate="no" dir="ltr">Tensor</code> value. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">RuntimeError</code> </td> <td> if eager execution is not enabled. </td> </tr> </table> <h3 id="batch" data-text="batch" tabindex="-1"><code translate="no" dir="ltr">batch</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1835-L1898">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">batch(
    batch_size,
    drop_remainder=False,
    num_parallel_calls=None,
    deterministic=None,
    name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Combines consecutive elements of this dataset into batches.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(8)
dataset = dataset.batch(3)
list(dataset.as_numpy_iterator())
[array([0, 1, 2]), array([3, 4, 5]), array([6, 7])]</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(8)
dataset = dataset.batch(3, drop_remainder=True)
list(dataset.as_numpy_iterator())
[array([0, 1, 2]), array([3, 4, 5])]</pre></devsite-code> <p>The components of the resulting element will have an additional outer dimension, which will be <code translate="no" dir="ltr">batch_size</code> (or <code translate="no" dir="ltr">N % batch_size</code> for the last element if <code translate="no" dir="ltr">batch_size</code> does not divide the number of input elements <code translate="no" dir="ltr">N</code> evenly and <code translate="no" dir="ltr">drop_remainder</code> is <code translate="no" dir="ltr">False</code>). If your program depends on the batches having the same outer dimension, you should set the <code translate="no" dir="ltr">drop_remainder</code> argument to <code translate="no" dir="ltr">True</code> to prevent the smaller batch from being produced.</p> <blockquote class="note">
<strong>Note:</strong><span> If your program requires data to have a statically known shape (e.g., when using XLA), you should use <code translate="no" dir="ltr">drop_remainder=True</code>. Without <code translate="no" dir="ltr">drop_remainder=True</code> the shape of the output dataset will have an unknown leading dimension due to the possibility of a smaller final batch.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">batch_size</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of consecutive elements of this dataset to combine in a single batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">drop_remainder</code> </td> <td> (Optional.) A <a href="../../tf.html#bool"><code translate="no" dir="ltr">tf.bool</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing whether the last batch should be dropped in the case it has fewer than <code translate="no" dir="ltr">batch_size</code> elements; the default behavior is not to drop the smaller batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">num_parallel_calls</code> </td> <td> (Optional.) A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of batches to compute asynchronously in parallel. If not specified, batches will be computed sequentially. If the value <a href="../data.html#AUTOTUNE"><code translate="no" dir="ltr">tf.data.AUTOTUNE</code></a> is used, then the number of parallel calls is set dynamically based on available resources. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">deterministic</code> </td> <td> (Optional.) When <code translate="no" dir="ltr">num_parallel_calls</code> is specified, if this boolean is specified (<code translate="no" dir="ltr">True</code> or <code translate="no" dir="ltr">False</code>), it controls the order in which the transformation produces elements. If set to <code translate="no" dir="ltr">False</code>, the transformation is allowed to yield elements out of order to trade determinism for performance. If not specified, the <a href="options.html#deterministic"><code translate="no" dir="ltr">tf.data.Options.deterministic</code></a> option (<code translate="no" dir="ltr">True</code> by default) controls the behavior. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="bucket_by_sequence_length" data-text="bucket_by_sequence_length" tabindex="-1"><code translate="no" dir="ltr">bucket_by_sequence_length</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L3060-L3207">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">bucket_by_sequence_length(
    element_length_func,
    bucket_boundaries,
    bucket_batch_sizes,
    padded_shapes=None,
    padding_values=None,
    pad_to_bucket_boundary=False,
    no_padding=False,
    drop_remainder=False,
    name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>A transformation that buckets elements in a <code translate="no" dir="ltr">Dataset</code> by length.</p> <p>Elements of the <code translate="no" dir="ltr">Dataset</code> are grouped together by length and then are padded and batched.</p> <p>This is useful for sequence tasks in which the elements have variable length. Grouping together elements that have similar lengths reduces the total fraction of padding in a batch which increases training step efficiency.</p> <p>Below is an example to bucketize the input data to the 3 buckets "[0, 3), [3, 5), [5, inf)" based on sequence length, with batch size 2.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">elements = [
  [0], [1, 2, 3, 4], [5, 6, 7],
  [7, 8, 9, 10, 11], [13, 14, 15, 16, 19, 20], [21, 22]]
dataset = tf.data.Dataset.from_generator(
    lambda: elements, tf.int64, output_shapes=[None])
dataset = dataset.bucket_by_sequence_length(
        element_length_func=lambda elem: tf.shape(elem)[0],
        bucket_boundaries=[3, 5],
        bucket_batch_sizes=[2, 2, 2])
for elem in dataset.as_numpy_iterator():
  print(elem)
[[1 2 3 4]
[5 6 7 0]]
[[ 7  8  9 10 11  0]
[13 14 15 16 19 20]]
[[ 0  0]
[21 22]]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">element_length_func</code> </td> <td> function from element in <code translate="no" dir="ltr">Dataset</code> to <a href="../../tf.html#int32"><code translate="no" dir="ltr">tf.int32</code></a>, determines the length of the element, which will determine the bucket it goes into. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">bucket_boundaries</code> </td> <td> <code translate="no" dir="ltr">list&lt;int&gt;</code>, upper length boundaries of the buckets. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">bucket_batch_sizes</code> </td> <td> <code translate="no" dir="ltr">list&lt;int&gt;</code>, batch size per bucket. Length should be <code translate="no" dir="ltr">len(bucket_boundaries) + 1</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">padded_shapes</code> </td> <td> Nested structure of <a href="../tensorshape.html"><code translate="no" dir="ltr">tf.TensorShape</code></a> to pass to <a href="dataset.html#padded_batch"><code translate="no" dir="ltr">tf.data.Dataset.padded_batch</code></a>. If not provided, will use <code translate="no" dir="ltr">dataset.output_shapes</code>, which will result in variable length dimensions being padded out to the maximum length in each batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">padding_values</code> </td> <td> Values to pad with, passed to <a href="dataset.html#padded_batch"><code translate="no" dir="ltr">tf.data.Dataset.padded_batch</code></a>. Defaults to padding with 0. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">pad_to_bucket_boundary</code> </td> <td> bool, if <code translate="no" dir="ltr">False</code>, will pad dimensions with unknown size to maximum length in batch. If <code translate="no" dir="ltr">True</code>, will pad dimensions with unknown size to bucket boundary minus 1 (i.e., the maximum length in each bucket), and caller must ensure that the source <code translate="no" dir="ltr">Dataset</code> does not contain any elements with length longer than <code translate="no" dir="ltr">max(bucket_boundaries)</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">no_padding</code> </td> <td> <code translate="no" dir="ltr">bool</code>, indicates whether to pad the batch features (features need to be either of type <a href="../sparse/sparsetensor.html"><code translate="no" dir="ltr">tf.sparse.SparseTensor</code></a> or of same shape). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">drop_remainder</code> </td> <td> (Optional.) A <a href="../../tf.html#bool"><code translate="no" dir="ltr">tf.bool</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing whether the last batch should be dropped in the case it has fewer than <code translate="no" dir="ltr">batch_size</code> elements; the default behavior is not to drop the smaller batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> if <code translate="no" dir="ltr">len(bucket_batch_sizes) != len(bucket_boundaries) + 1</code>. </td> </tr> </table> <h3 id="cache" data-text="cache" tabindex="-1"><code translate="no" dir="ltr">cache</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1500-L1556">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">cache(
    filename='', name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Caches the elements in this dataset.</p> <p>The first time the dataset is iterated over, its elements will be cached either in the specified file or in memory. Subsequent iterations will use the cached data.</p> <blockquote class="note">
<strong>Note:</strong><span> To guarantee that the cache gets finalized, the input dataset must be iterated through in its entirety, until it raises StopIteration. Otherwise, subsequent iterations may not use cached data.</span>
</blockquote> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(5)
dataset = dataset.map(lambda x: x**2)
dataset = dataset.cache()
# The first time reading through the data will generate the data using
# `range` and `map`.
list(dataset.as_numpy_iterator())
[0, 1, 4, 9, 16]
# Subsequent iterations read from the cache.
list(dataset.as_numpy_iterator())
[0, 1, 4, 9, 16]</pre></devsite-code> <p>When caching to a file, the cached data will persist across runs. Even the first iteration through the data will read from the cache file. Changing the input pipeline before the call to <code translate="no" dir="ltr">.cache()</code> will have no effect until the cache file is removed or the filename is changed.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(5)
dataset = dataset.cache("/path/to/file")
list(dataset.as_numpy_iterator())
# [0, 1, 2, 3, 4]
dataset = tf.data.Dataset.range(10)
dataset = dataset.cache("/path/to/file")  # Same file!
list(dataset.as_numpy_iterator())
# [0, 1, 2, 3, 4]
</pre></devsite-code><blockquote class="note">
<strong>Note:</strong><span> <code translate="no" dir="ltr">cache</code> will produce exactly the same elements during each iteration through the dataset. If you wish to randomize the iteration order, make sure to call <code translate="no" dir="ltr">shuffle</code> <em>after</em> calling <code translate="no" dir="ltr">cache</code>.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">filename</code> </td> <td> A <a href="../../tf.html#string"><code translate="no" dir="ltr">tf.string</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the name of a directory on the filesystem to use for caching elements in this Dataset. If a filename is not provided, the dataset will be cached in memory. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="cardinality" data-text="cardinality" tabindex="-1"><code translate="no" dir="ltr">cardinality</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2969-L2995">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">cardinality()
</pre></devsite-code> <p>Returns the cardinality of the dataset, if known.</p> <p><code translate="no" dir="ltr">cardinality</code> may return <a href="../data.html#INFINITE_CARDINALITY"><code translate="no" dir="ltr">tf.data.INFINITE_CARDINALITY</code></a> if the dataset contains an infinite number of elements or <a href="../data.html#UNKNOWN_CARDINALITY"><code translate="no" dir="ltr">tf.data.UNKNOWN_CARDINALITY</code></a> if the analysis fails to determine the number of elements in the dataset (e.g. when the dataset source is a file).</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(42)
print(dataset.cardinality().numpy())
42
dataset = dataset.repeat()
cardinality = dataset.cardinality()
print((cardinality == tf.data.INFINITE_CARDINALITY).numpy())
True
dataset = dataset.filter(lambda x: True)
cardinality = dataset.cardinality()
print((cardinality == tf.data.UNKNOWN_CARDINALITY).numpy())
True</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A scalar <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> <code translate="no" dir="ltr">Tensor</code> representing the cardinality of the dataset. If the cardinality is infinite or unknown, <code translate="no" dir="ltr">cardinality</code> returns the named constants <a href="../data.html#INFINITE_CARDINALITY"><code translate="no" dir="ltr">tf.data.INFINITE_CARDINALITY</code></a> and <a href="../data.html#UNKNOWN_CARDINALITY"><code translate="no" dir="ltr">tf.data.UNKNOWN_CARDINALITY</code></a> respectively. </td> </tr> 
</table> <h3 id="choose_from_datasets" data-text="choose_from_datasets" tabindex="-1"><code translate="no" dir="ltr">choose_from_datasets</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L3612-L3662">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@staticmethod
choose_from_datasets(
    datasets, choice_dataset, stop_on_empty_dataset=True
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a dataset that deterministically chooses elements from <code translate="no" dir="ltr">datasets</code>.</p> <p>For example, given the following datasets:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">datasets = [tf.data.Dataset.from_tensors("foo").repeat(),
            tf.data.Dataset.from_tensors("bar").repeat(),
            tf.data.Dataset.from_tensors("baz").repeat()]

# Define a dataset containing `[0, 1, 2, 0, 1, 2, 0, 1, 2]`.
choice_dataset = tf.data.Dataset.range(3).repeat(3)

result = tf.data.Dataset.choose_from_datasets(datasets, choice_dataset)
</pre></devsite-code> <p>The elements of <code translate="no" dir="ltr">result</code> will be:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">"foo", "bar", "baz", "foo", "bar", "baz", "foo", "bar", "baz"
</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">datasets</code> </td> <td> A non-empty list of <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a> objects with compatible structure. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">choice_dataset</code> </td> <td> A <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a> of scalar <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> tensors between <code translate="no" dir="ltr">0</code> and <code translate="no" dir="ltr">len(datasets) - 1</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">stop_on_empty_dataset</code> </td> <td> If <code translate="no" dir="ltr">True</code>, selection stops if it encounters an empty dataset. If <code translate="no" dir="ltr">False</code>, it skips empty datasets. It is recommended to set it to <code translate="no" dir="ltr">True</code>. Otherwise, the selected elements start off as the user intends, but may change as input datasets become empty. This can be difficult to detect since the dataset starts off looking correct. Defaults to <code translate="no" dir="ltr">True</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If <code translate="no" dir="ltr">datasets</code> or <code translate="no" dir="ltr">choice_dataset</code> has the wrong type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">datasets</code> is empty. </td> </tr> </table> <h3 id="concatenate" data-text="concatenate" tabindex="-1"><code translate="no" dir="ltr">concatenate</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1082-L1115">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">concatenate(
    dataset, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> by concatenating the given dataset with this dataset.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">a = tf.data.Dataset.range(1, 4)  # ==&gt; [ 1, 2, 3 ]
b = tf.data.Dataset.range(4, 8)  # ==&gt; [ 4, 5, 6, 7 ]
ds = a.concatenate(b)
list(ds.as_numpy_iterator())
[1, 2, 3, 4, 5, 6, 7]
# The input dataset and dataset to be concatenated should have
# compatible element specs.
c = tf.data.Dataset.zip((a, b))
a.concatenate(c)
Traceback (most recent call last):
TypeError: Two datasets to concatenate have different types
&lt;dtype: 'int64'&gt; and (tf.int64, tf.int64)
d = tf.data.Dataset.from_tensor_slices(["a", "b", "c"])
a.concatenate(d)
Traceback (most recent call last):
TypeError: Two datasets to concatenate have different types
&lt;dtype: 'int64'&gt; and &lt;dtype: 'string'&gt;</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">dataset</code> </td> <td> <code translate="no" dir="ltr">Dataset</code> to be concatenated. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="counter" data-text="counter" tabindex="-1"><code translate="no" dir="ltr">counter</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1117-L1157">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@staticmethod
counter(
    start=0,
    step=1,
    dtype=tf.dtypes.int64,
    name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> that counts from <code translate="no" dir="ltr">start</code> in steps of size <code translate="no" dir="ltr">step</code>.</p> <p>Unlike <a href="dataset.html#range"><code translate="no" dir="ltr">tf.data.Dataset.range</code></a>, which stops at some ending number, <a href="dataset.html#counter"><code translate="no" dir="ltr">tf.data.Dataset.counter</code></a> produces elements indefinitely.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.experimental.Counter().take(5)
list(dataset.as_numpy_iterator())
[0, 1, 2, 3, 4]
dataset.element_spec
TensorSpec(shape=(), dtype=tf.int64, name=None)
dataset = tf.data.experimental.Counter(dtype=tf.int32)
dataset.element_spec
TensorSpec(shape=(), dtype=tf.int32, name=None)
dataset = tf.data.experimental.Counter(start=2).take(5)
list(dataset.as_numpy_iterator())
[2, 3, 4, 5, 6]
dataset = tf.data.experimental.Counter(start=2, step=5).take(5)
list(dataset.as_numpy_iterator())
[2, 7, 12, 17, 22]
dataset = tf.data.experimental.Counter(start=10, step=-1).take(5)
list(dataset.as_numpy_iterator())
[10, 9, 8, 7, 6]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">start</code> </td> <td> (Optional.) The starting value for the counter. Defaults to 0. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">step</code> </td> <td> (Optional.) The step size for the counter. Defaults to 1. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dtype</code> </td> <td> (Optional.) The data type for counter elements. Defaults to <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Dataset</code> of scalar <code translate="no" dir="ltr">dtype</code> elements. </td> </tr> 
</table> <h3 id="enumerate" data-text="enumerate" tabindex="-1"><code translate="no" dir="ltr">enumerate</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1371-L1408">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">enumerate(
    start=0, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Enumerates the elements of this dataset.</p> <p>It is similar to python's <code translate="no" dir="ltr">enumerate</code>.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])
dataset = dataset.enumerate(start=5)
for element in dataset.as_numpy_iterator():
  print(element)
(5, 1)
(6, 2)
(7, 3)</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># The (nested) structure of the input dataset determines the
# structure of elements in the resulting dataset.
dataset = tf.data.Dataset.from_tensor_slices([(7, 8), (9, 10)])
dataset = dataset.enumerate()
for element in dataset.as_numpy_iterator():
  print(element)
(0, array([7, 8], dtype=int32))
(1, array([ 9, 10], dtype=int32))</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">start</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the start value for enumeration. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> Optional. A name for the tf.data operations used by <code translate="no" dir="ltr">enumerate</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="filter" data-text="filter" tabindex="-1"><code translate="no" dir="ltr">filter</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2493-L2519">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">filter(
    predicate, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Filters this dataset according to <code translate="no" dir="ltr">predicate</code>.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])
dataset = dataset.filter(lambda x: x &lt; 3)
list(dataset.as_numpy_iterator())
[1, 2]
# `tf.math.equal(x, y)` is required for equality comparison
def filter_fn(x):
  return tf.math.equal(x, 1)
dataset = dataset.filter(filter_fn)
list(dataset.as_numpy_iterator())
[1]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">predicate</code> </td> <td> A function mapping a dataset element to a boolean. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="fingerprint" data-text="fingerprint" tabindex="-1"><code translate="no" dir="ltr">fingerprint</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1159-L1175">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">fingerprint()
</pre></devsite-code> <p>Computes the fingerprint of this <code translate="no" dir="ltr">Dataset</code>.</p> <p>If two datasets have the same fingerprint, it is guaranteeed that they would produce identical elements as long as the content of the upstream input files does not change and they produce data deterministically.</p> <p>However, two datasets producing identical values does not always mean they would have the same fingerprint due to different graph constructs.</p> <p>In other words, if two datasets have different fingerprints, they could still produce identical values.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a> of type <a href="../../tf.html#uint64"><code translate="no" dir="ltr">tf.uint64</code></a>. </td> </tr> 
</table> <h3 id="flat_map" data-text="flat_map" tabindex="-1"><code translate="no" dir="ltr">flat_map</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2307-L2345">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">flat_map(
    map_func, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Maps <code translate="no" dir="ltr">map_func</code> across this dataset and flattens the result.</p> <h4 id="the_type_signature_is" data-text="The type signature is:" tabindex="-1">The type signature is:</h4> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def flat_map(
  self: Dataset[T],
  map_func: Callable[[T], Dataset[S]]
) -&gt; Dataset[S]
</pre></devsite-code> <p>Use <code translate="no" dir="ltr">flat_map</code> if you want to make sure that the order of your dataset stays the same. For example, to flatten a dataset of batches into a dataset of their elements:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices(
    [[1, 2, 3], [4, 5, 6], [7, 8, 9]])
dataset = dataset.flat_map(tf.data.Dataset.from_tensor_slices)
list(dataset.as_numpy_iterator())
[1, 2, 3, 4, 5, 6, 7, 8, 9]</pre></devsite-code> <p><a href="dataset.html#interleave"><code translate="no" dir="ltr">tf.data.Dataset.interleave()</code></a> is a generalization of <code translate="no" dir="ltr">flat_map</code>, since <code translate="no" dir="ltr">flat_map</code> produces the same output as <a href="dataset.html#interleave"><code translate="no" dir="ltr">tf.data.Dataset.interleave(cycle_length=1)</code></a></p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">map_func</code> </td> <td> A function mapping a dataset element to a dataset. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="from_generator" data-text="from_generator" tabindex="-1"><code translate="no" dir="ltr">from_generator</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L873-L971">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@staticmethod
from_generator(
    generator,
    output_types=None,
    output_shapes=None,
    args=None,
    output_signature=None,
    name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> whose elements are generated by <code translate="no" dir="ltr">generator</code>. (deprecated arguments)</p> <aside class="deprecated"><strong>Deprecated:</strong><span> SOME ARGUMENTS ARE DEPRECATED: <code translate="no" dir="ltr">(output_shapes, output_types)</code>. They will be removed in a future version. Instructions for updating: Use output_signature instead</span></aside><blockquote class="note">
<strong>Note:</strong><span> The current implementation of <a href="dataset.html#from_generator"><code translate="no" dir="ltr">Dataset.from_generator()</code></a> uses <a href="../numpy_function.html"><code translate="no" dir="ltr">tf.numpy_function</code></a> and inherits the same constraints. In particular, it requires the dataset and iterator related operations to be placed on a device in the same process as the Python program that called <a href="dataset.html#from_generator"><code translate="no" dir="ltr">Dataset.from_generator()</code></a>. In particular, using <code translate="no" dir="ltr">from_generator</code> will preclude the use of tf.data service for scaling out dataset processing. The body of <code translate="no" dir="ltr">generator</code> will not be serialized in a <code translate="no" dir="ltr">GraphDef</code>, and you should not use this method if you need to serialize your model and restore it in a different environment.</span>
</blockquote> <p>The <code translate="no" dir="ltr">generator</code> argument must be a callable object that returns an object that supports the <code translate="no" dir="ltr">iter()</code> protocol (e.g. a generator function).</p> <p>The elements generated by <code translate="no" dir="ltr">generator</code> must be compatible with either the given <code translate="no" dir="ltr">output_signature</code> argument or with the given <code translate="no" dir="ltr">output_types</code> and (optionally) <code translate="no" dir="ltr">output_shapes</code> arguments, whichever was specified.</p> <p>The recommended way to call <code translate="no" dir="ltr">from_generator</code> is to use the <code translate="no" dir="ltr">output_signature</code> argument. In this case the output will be assumed to consist of objects with the classes, shapes and types defined by <a href="../typespec.html"><code translate="no" dir="ltr">tf.TypeSpec</code></a> objects from <code translate="no" dir="ltr">output_signature</code> argument:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def gen():
  ragged_tensor = tf.ragged.constant([[1, 2], [3]])
  yield 42, ragged_tensor

dataset = tf.data.Dataset.from_generator(
     gen,
     output_signature=(
         tf.TensorSpec(shape=(), dtype=tf.int32),
         tf.RaggedTensorSpec(shape=(2, None), dtype=tf.int32)))

list(dataset.take(1))
[(&lt;tf.Tensor: shape=(), dtype=int32, numpy=42&gt;,
&lt;tf.RaggedTensor [[1, 2], [3]]&gt;)]</pre></devsite-code> <p>There is also a deprecated way to call <code translate="no" dir="ltr">from_generator</code> by either with <code translate="no" dir="ltr">output_types</code> argument alone or together with <code translate="no" dir="ltr">output_shapes</code> argument. In this case the output of the function will be assumed to consist of <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a> objects with the types defined by <code translate="no" dir="ltr">output_types</code> and with the shapes which are either unknown or defined by <code translate="no" dir="ltr">output_shapes</code>.</p> <blockquote class="note">
<strong>Note:</strong><span> If <code translate="no" dir="ltr">generator</code> depends on mutable global variables or other external state, be aware that the runtime may invoke <code translate="no" dir="ltr">generator</code> multiple times (in order to support repeating the <code translate="no" dir="ltr">Dataset</code>) and at any time between the call to <a href="dataset.html#from_generator"><code translate="no" dir="ltr">Dataset.from_generator()</code></a> and the production of the first element from the generator. Mutating global variables or external state can cause undefined behavior, and we recommend that you explicitly cache any external state in <code translate="no" dir="ltr">generator</code> before calling <a href="dataset.html#from_generator"><code translate="no" dir="ltr">Dataset.from_generator()</code></a>.</span>
</blockquote>
<blockquote class="note">
<strong>Note:</strong><span> While the <code translate="no" dir="ltr">output_signature</code> parameter makes it possible to yield <code translate="no" dir="ltr">Dataset</code> elements, the scope of <a href="dataset.html#from_generator"><code translate="no" dir="ltr">Dataset.from_generator()</code></a> should be limited to logic that cannot be expressed through tf.data operations. Using tf.data operations within the generator function is an anti-pattern and may result in incremental memory growth.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">generator</code> </td> <td> A callable object that returns an object that supports the <code translate="no" dir="ltr">iter()</code> protocol. If <code translate="no" dir="ltr">args</code> is not specified, <code translate="no" dir="ltr">generator</code> must take no arguments; otherwise it must take as many arguments as there are values in <code translate="no" dir="ltr">args</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">output_types</code> </td> <td> (Optional.) A (nested) structure of <a href="../dtypes/dtype.html"><code translate="no" dir="ltr">tf.DType</code></a> objects corresponding to each component of an element yielded by <code translate="no" dir="ltr">generator</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">output_shapes</code> </td> <td> (Optional.) A (nested) structure of <a href="../tensorshape.html"><code translate="no" dir="ltr">tf.TensorShape</code></a> objects corresponding to each component of an element yielded by <code translate="no" dir="ltr">generator</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">args</code> </td> <td> (Optional.) A tuple of <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a> objects that will be evaluated and passed to <code translate="no" dir="ltr">generator</code> as NumPy-array arguments. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">output_signature</code> </td> <td> (Optional.) A (nested) structure of <a href="../typespec.html"><code translate="no" dir="ltr">tf.TypeSpec</code></a> objects corresponding to each component of an element yielded by <code translate="no" dir="ltr">generator</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operations used by <code translate="no" dir="ltr">from_generator</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="from_tensor_slices" data-text="from_tensor_slices" tabindex="-1"><code translate="no" dir="ltr">from_tensor_slices</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L744-L827">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@staticmethod
from_tensor_slices(
    tensors, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> whose elements are slices of the given tensors.</p> <p>The given tensors are sliced along their first dimension. This operation preserves the structure of the input tensors, removing the first dimension of each tensor and using it as the dataset dimension. All input tensors must have the same size in their first dimensions.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># Slicing a 1D tensor produces scalar tensor elements.
dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])
list(dataset.as_numpy_iterator())
[1, 2, 3]</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># Slicing a 2D tensor produces 1D tensor elements.
dataset = tf.data.Dataset.from_tensor_slices([[1, 2], [3, 4]])
list(dataset.as_numpy_iterator())
[array([1, 2], dtype=int32), array([3, 4], dtype=int32)]</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># Slicing a tuple of 1D tensors produces tuple elements containing
# scalar tensors.
dataset = tf.data.Dataset.from_tensor_slices(([1, 2], [3, 4], [5, 6]))
list(dataset.as_numpy_iterator())
[(1, 3, 5), (2, 4, 6)]</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># Dictionary structure is also preserved.
dataset = tf.data.Dataset.from_tensor_slices({"a": [1, 2], "b": [3, 4]})
list(dataset.as_numpy_iterator()) == [{'a': 1, 'b': 3},
                                      {'a': 2, 'b': 4}]
True</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># Two tensors can be combined into one Dataset object.
features = tf.constant([[1, 3], [2, 1], [3, 3]]) # ==&gt; 3x2 tensor
labels = tf.constant(['A', 'B', 'A']) # ==&gt; 3x1 tensor
dataset = Dataset.from_tensor_slices((features, labels))
# Both the features and the labels tensors can be converted
# to a Dataset object separately and combined after.
features_dataset = Dataset.from_tensor_slices(features)
labels_dataset = Dataset.from_tensor_slices(labels)
dataset = Dataset.zip((features_dataset, labels_dataset))
# A batched feature and label set can be converted to a Dataset
# in similar fashion.
batched_features = tf.constant([[[1, 3], [2, 3]],
                                [[2, 1], [1, 2]],
                                [[3, 3], [3, 2]]], shape=(3, 2, 2))
batched_labels = tf.constant([['A', 'A'],
                              ['B', 'B'],
                              ['A', 'B']], shape=(3, 2, 1))
dataset = Dataset.from_tensor_slices((batched_features, batched_labels))
for element in dataset.as_numpy_iterator():
  print(element)
(array([[1, 3],
       [2, 3]], dtype=int32), array([[b'A'],
       [b'A']], dtype=object))
(array([[2, 1],
       [1, 2]], dtype=int32), array([[b'B'],
       [b'B']], dtype=object))
(array([[3, 3],
       [3, 2]], dtype=int32), array([[b'A'],
       [b'B']], dtype=object))</pre></devsite-code> <p>Note that if <code translate="no" dir="ltr">tensors</code> contains a NumPy array, and eager execution is not enabled, the values will be embedded in the graph as one or more <a href="../constant.html"><code translate="no" dir="ltr">tf.constant</code></a> operations. For large datasets (&gt; 1 GB), this can waste memory and run into byte limits of graph serialization. If <code translate="no" dir="ltr">tensors</code> contains one or more large NumPy arrays, consider the alternative described in <a href="https://tensorflow.org/guide/data#consuming_numpy_arrays">this guide</a>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">tensors</code> </td> <td> A dataset element, whose components have the same first dimension. Supported values are documented <a href="https://www.tensorflow.org/guide/data#dataset_structure">here</a>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="from_tensors" data-text="from_tensors" tabindex="-1"><code translate="no" dir="ltr">from_tensors</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L700-L742">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@staticmethod
from_tensors(
    tensors, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> with a single element, comprising the given tensors.</p> <p><code translate="no" dir="ltr">from_tensors</code> produces a dataset containing only a single element. To slice the input tensor into multiple elements, use <code translate="no" dir="ltr">from_tensor_slices</code> instead.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensors([1, 2, 3])
list(dataset.as_numpy_iterator())
[array([1, 2, 3], dtype=int32)]
dataset = tf.data.Dataset.from_tensors(([1, 2, 3], 'A'))
list(dataset.as_numpy_iterator())
[(array([1, 2, 3], dtype=int32), b'A')]</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># You can use `from_tensors` to produce a dataset which repeats
# the same example many times.
example = tf.constant([1,2,3])
dataset = tf.data.Dataset.from_tensors(example).repeat(2)
list(dataset.as_numpy_iterator())
[array([1, 2, 3], dtype=int32), array([1, 2, 3], dtype=int32)]</pre></devsite-code> <p>Note that if <code translate="no" dir="ltr">tensors</code> contains a NumPy array, and eager execution is not enabled, the values will be embedded in the graph as one or more <a href="../constant.html"><code translate="no" dir="ltr">tf.constant</code></a> operations. For large datasets (&gt; 1 GB), this can waste memory and run into byte limits of graph serialization. If <code translate="no" dir="ltr">tensors</code> contains one or more large NumPy arrays, consider the alternative described in <a href="https://tensorflow.org/guide/data#consuming_numpy_arrays">this guide</a>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">tensors</code> </td> <td> A dataset "element". Supported values are documented <a href="https://www.tensorflow.org/guide/data#dataset_structure">here</a>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="get_single_element" data-text="get_single_element" tabindex="-1"><code translate="no" dir="ltr">get_single_element</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2821-L2908">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">get_single_element(
    name=None
)
</pre></devsite-code> <p>Returns the single element of the <code translate="no" dir="ltr">dataset</code>.</p> <p>The function enables you to use a <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a> in a stateless "tensor-in tensor-out" expression, without creating an iterator. This facilitates the ease of data transformation on tensors using the optimized <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a> abstraction on top of them.</p> <p>For example, lets consider a <code translate="no" dir="ltr">preprocessing_fn</code> which would take as an input the raw features and returns the processed feature along with it's label.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def preprocessing_fn(raw_feature):
  # ... the raw_feature is preprocessed as per the use-case
  return feature

raw_features = ...  # input batch of BATCH_SIZE elements.
dataset = (tf.data.Dataset.from_tensor_slices(raw_features)
          .map(preprocessing_fn, num_parallel_calls=BATCH_SIZE)
          .batch(BATCH_SIZE))

processed_features = dataset.get_single_element()
</pre></devsite-code> <p>In the above example, the <code translate="no" dir="ltr">raw_features</code> tensor of length=BATCH_SIZE was converted to a <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a>. Next, each of the <code translate="no" dir="ltr">raw_feature</code> was mapped using the <code translate="no" dir="ltr">preprocessing_fn</code> and the processed features were grouped into a single batch. The final <code translate="no" dir="ltr">dataset</code> contains only one element which is a batch of all the processed features.</p> <blockquote class="note">
<strong>Note:</strong><span> The <code translate="no" dir="ltr">dataset</code> should contain only one element.</span>
</blockquote> <p>Now, instead of creating an iterator for the <code translate="no" dir="ltr">dataset</code> and retrieving the batch of features, the <code translate="no" dir="ltr">tf.data.get_single_element()</code> function is used to skip the iterator creation process and directly output the batch of features.</p> <p>This can be particularly useful when your tensor transformations are expressed as <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a> operations, and you want to use those transformations while serving your model.</p> <h4 id="keras" data-text="Keras" tabindex="-1">Keras</h4> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">
model = ... # A pre-built or custom model

class PreprocessingModel(tf.keras.Model):
  def __init__(self, model):
    super().__init__(self)
    self.model = model

  @tf.function(input_signature=[...])
  def serving_fn(self, data):
    ds = tf.data.Dataset.from_tensor_slices(data)
    ds = ds.map(preprocessing_fn, num_parallel_calls=BATCH_SIZE)
    ds = ds.batch(batch_size=BATCH_SIZE)
    return tf.argmax(self.model(ds.get_single_element()), axis=-1)

preprocessing_model = PreprocessingModel(model)
your_exported_model_dir = ... # save the model to this path.
tf.saved_model.save(preprocessing_model, your_exported_model_dir,
              signatures={'serving_default': preprocessing_model.serving_fn}
              )
</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A nested structure of <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a> objects, corresponding to the single element of <code translate="no" dir="ltr">dataset</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">InvalidArgumentError</code> </td> <td> (at runtime) if <code translate="no" dir="ltr">dataset</code> does not contain exactly one element. </td> </tr> </table> <h3 id="group_by_window" data-text="group_by_window" tabindex="-1"><code translate="no" dir="ltr">group_by_window</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2997-L3058">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">group_by_window(
    key_func, reduce_func, window_size=None, window_size_func=None, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Groups windows of elements by key and reduces them.</p> <p>This transformation maps each consecutive element in a dataset to a key using <code translate="no" dir="ltr">key_func</code> and groups the elements by key. It then applies <code translate="no" dir="ltr">reduce_func</code> to at most <code translate="no" dir="ltr">window_size_func(key)</code> elements matching the same key. All except the final window for each key will contain <code translate="no" dir="ltr">window_size_func(key)</code> elements; the final window may be smaller.</p> <p>You may provide either a constant <code translate="no" dir="ltr">window_size</code> or a window size determined by the key through <code translate="no" dir="ltr">window_size_func</code>.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(10)
window_size = 5
key_func = lambda x: x%2
reduce_func = lambda key, dataset: dataset.batch(window_size)
dataset = dataset.group_by_window(
          key_func=key_func,
          reduce_func=reduce_func,
          window_size=window_size)
for elem in dataset.as_numpy_iterator():
  print(elem)
[0 2 4 6 8]
[1 3 5 7 9]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">key_func</code> </td> <td> A function mapping a nested structure of tensors (having shapes and types defined by <code translate="no" dir="ltr">self.output_shapes</code> and <code translate="no" dir="ltr">self.output_types</code>) to a scalar <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">reduce_func</code> </td> <td> A function mapping a key and a dataset of up to <code translate="no" dir="ltr">window_size</code> consecutive elements matching that key to another dataset. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">window_size</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of consecutive elements matching the same key to combine in a single batch, which will be passed to <code translate="no" dir="ltr">reduce_func</code>. Mutually exclusive with <code translate="no" dir="ltr">window_size_func</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">window_size_func</code> </td> <td> A function mapping a key to a <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of consecutive elements matching the same key to combine in a single batch, which will be passed to <code translate="no" dir="ltr">reduce_func</code>. Mutually exclusive with <code translate="no" dir="ltr">window_size</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> if neither or both of {<code translate="no" dir="ltr">window_size</code>, <code translate="no" dir="ltr">window_size_func</code>} are passed. </td> </tr> </table> <h3 id="ignore_errors" data-text="ignore_errors" tabindex="-1"><code translate="no" dir="ltr">ignore_errors</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2347-L2373">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">ignore_errors(
    log_warning=False, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Drops elements that cause errors.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices([1., 2., 0., 4.])
dataset = dataset.map(lambda x: tf.debugging.check_numerics(1. / x, ""))
list(dataset.as_numpy_iterator())
Traceback (most recent call last):

InvalidArgumentError: ... Tensor had Inf values
dataset = dataset.ignore_errors()
list(dataset.as_numpy_iterator())
[1.0, 0.5, 0.25]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">log_warning</code> </td> <td> (Optional.) A bool indicating whether or not ignored errors should be logged to stderr. Defaults to <code translate="no" dir="ltr">False</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A string indicating a name for the <a href="../data.html"><code translate="no" dir="ltr">tf.data</code></a> operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="interleave" data-text="interleave" tabindex="-1"><code translate="no" dir="ltr">interleave</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2375-L2491">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">interleave(
    map_func,
    cycle_length=None,
    block_length=None,
    num_parallel_calls=None,
    deterministic=None,
    name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Maps <code translate="no" dir="ltr">map_func</code> across this dataset, and interleaves the results.</p> <h4 id="the_type_signature_is_2" data-text="The type signature is:" tabindex="-1">The type signature is:</h4> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def interleave(
  self: Dataset[T],
  map_func: Callable[[T], Dataset[S]]
) -&gt; Dataset[S]
</pre></devsite-code> <p>For example, you can use <a href="dataset.html#interleave"><code translate="no" dir="ltr">Dataset.interleave()</code></a> to process many input files concurrently:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># Preprocess 4 files concurrently, and interleave blocks of 16 records
# from each file.
filenames = ["/var/data/file1.txt", "/var/data/file2.txt",
             "/var/data/file3.txt", "/var/data/file4.txt"]
dataset = tf.data.Dataset.from_tensor_slices(filenames)
def parse_fn(filename):
  return tf.data.Dataset.range(10)
dataset = dataset.interleave(lambda x:
    tf.data.TextLineDataset(x).map(parse_fn, num_parallel_calls=1),
    cycle_length=4, block_length=16)</pre></devsite-code> <p>The <code translate="no" dir="ltr">cycle_length</code> and <code translate="no" dir="ltr">block_length</code> arguments control the order in which elements are produced. <code translate="no" dir="ltr">cycle_length</code> controls the number of input elements that are processed concurrently. If you set <code translate="no" dir="ltr">cycle_length</code> to 1, this transformation will handle one input element at a time, and will produce identical results to <a href="dataset.html#flat_map"><code translate="no" dir="ltr">tf.data.Dataset.flat_map</code></a>. In general, this transformation will apply <code translate="no" dir="ltr">map_func</code> to <code translate="no" dir="ltr">cycle_length</code> input elements, open iterators on the returned <code translate="no" dir="ltr">Dataset</code> objects, and cycle through them producing <code translate="no" dir="ltr">block_length</code> consecutive elements from each iterator, and consuming the next input element each time it reaches the end of an iterator.</p> <h4 id="for_example" data-text="For example:" tabindex="-1">For example:</h4> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = Dataset.range(1, 6)  # ==&gt; [ 1, 2, 3, 4, 5 ]
# NOTE: New lines indicate "block" boundaries.
dataset = dataset.interleave(
    lambda x: Dataset.from_tensors(x).repeat(6),
    cycle_length=2, block_length=4)
list(dataset.as_numpy_iterator())
[1, 1, 1, 1,
 2, 2, 2, 2,
 1, 1,
 2, 2,
 3, 3, 3, 3,
 4, 4, 4, 4,
 3, 3,
 4, 4,
 5, 5, 5, 5,
 5, 5]</pre></devsite-code> <blockquote class="note">
<strong>Note:</strong><span> The order of elements yielded by this transformation is deterministic, as long as <code translate="no" dir="ltr">map_func</code> is a pure function and <code translate="no" dir="ltr">deterministic=True</code>. If <code translate="no" dir="ltr">map_func</code> contains any stateful operations, the order in which that state is accessed is undefined.</span>
</blockquote> <p>Performance can often be improved by setting <code translate="no" dir="ltr">num_parallel_calls</code> so that <code translate="no" dir="ltr">interleave</code> will use multiple threads to fetch elements. If determinism isn't required, it can also improve performance to set <code translate="no" dir="ltr">deterministic=False</code>.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">filenames = ["/var/data/file1.txt", "/var/data/file2.txt",
             "/var/data/file3.txt", "/var/data/file4.txt"]
dataset = tf.data.Dataset.from_tensor_slices(filenames)
dataset = dataset.interleave(lambda x: tf.data.TFRecordDataset(x),
    cycle_length=4, num_parallel_calls=tf.data.AUTOTUNE,
    deterministic=False)</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">map_func</code> </td> <td> A function that takes a dataset element and returns a <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">cycle_length</code> </td> <td> (Optional.) The number of input elements that will be processed concurrently. If not set, the tf.data runtime decides what it should be based on available CPU. If <code translate="no" dir="ltr">num_parallel_calls</code> is set to <a href="../data.html#AUTOTUNE"><code translate="no" dir="ltr">tf.data.AUTOTUNE</code></a>, the <code translate="no" dir="ltr">cycle_length</code> argument identifies the maximum degree of parallelism. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">block_length</code> </td> <td> (Optional.) The number of consecutive elements to produce from each input element before cycling to another input element. If not set, defaults to 1. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">num_parallel_calls</code> </td> <td> (Optional.) If specified, the implementation creates a threadpool, which is used to fetch inputs from cycle elements asynchronously and in parallel. The default behavior is to fetch inputs from cycle elements synchronously with no parallelism. If the value <a href="../data.html#AUTOTUNE"><code translate="no" dir="ltr">tf.data.AUTOTUNE</code></a> is used, then the number of parallel calls is set dynamically based on available CPU. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">deterministic</code> </td> <td> (Optional.) When <code translate="no" dir="ltr">num_parallel_calls</code> is specified, if this boolean is specified (<code translate="no" dir="ltr">True</code> or <code translate="no" dir="ltr">False</code>), it controls the order in which the transformation produces elements. If set to <code translate="no" dir="ltr">False</code>, the transformation is allowed to yield elements out of order to trade determinism for performance. If not specified, the <a href="options.html#deterministic"><code translate="no" dir="ltr">tf.data.Options.deterministic</code></a> option (<code translate="no" dir="ltr">True</code> by default) controls the behavior. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="list_files" data-text="list_files" tabindex="-1"><code translate="no" dir="ltr">list_files</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1262-L1341">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@staticmethod
list_files(
    file_pattern, shuffle=None, seed=None, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>A dataset of all files matching one or more glob patterns.</p> <p>The <code translate="no" dir="ltr">file_pattern</code> argument should be a small number of glob patterns. If your filenames have already been globbed, use <a href="dataset.html#from_tensor_slices"><code translate="no" dir="ltr">Dataset.from_tensor_slices(filenames)</code></a> instead, as re-globbing every filename with <code translate="no" dir="ltr">list_files</code> may result in poor performance with remote storage systems.</p> <blockquote class="note">
<strong>Note:</strong><span> The default behavior of this method is to return filenames in a non-deterministic random shuffled order. Pass a <code translate="no" dir="ltr">seed</code> or <code translate="no" dir="ltr">shuffle=False</code> to get results in a deterministic order.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Example</th></tr> <tr class="alt"> <td colspan="2"> If we had the following files on our filesystem: <ul> <li>/path/to/dir/a.txt</li> <li>/path/to/dir/b.py</li> <li>/path/to/dir/c.py</li> </ul> <p>If we pass "/path/to/dir/*.py" as the directory, the dataset would produce:</p> <ul> <li>/path/to/dir/b.py</li> <li>/path/to/dir/c.py </li>
</ul>
</td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">file_pattern</code> </td> <td> A string, a list of strings, or a <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a> of string type (scalar or vector), representing the filename glob (i.e. shell wildcard) pattern(s) that will be matched. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shuffle</code> </td> <td> (Optional.) If <code translate="no" dir="ltr">True</code>, the file names will be shuffled randomly. Defaults to <code translate="no" dir="ltr">True</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">seed</code> </td> <td> (Optional.) A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the random seed that will be used to create the distribution. See <a href="../random/set_seed.html"><code translate="no" dir="ltr">tf.random.set_seed</code></a> for behavior. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> Optional. A name for the tf.data operations used by <code translate="no" dir="ltr">list_files</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code> of strings corresponding to file names. </td> </tr> </table> <h3 id="load" data-text="load" tabindex="-1"><code translate="no" dir="ltr">load</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1764-L1833">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@staticmethod
load(
    path, element_spec=None, compression=None, reader_func=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Loads a previously saved dataset.</p> <h4 id="example_usage" data-text="Example usage:" tabindex="-1">Example usage:</h4> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">import tempfile
path = os.path.join(tempfile.gettempdir(), "saved_data")
# Save a dataset
dataset = tf.data.Dataset.range(2)
tf.data.Dataset.save(dataset, path)
new_dataset = tf.data.Dataset.load(path)
for elem in new_dataset:
  print(elem)
tf.Tensor(0, shape=(), dtype=int64)
tf.Tensor(1, shape=(), dtype=int64)</pre></devsite-code> <p>If the default option of sharding the saved dataset was used, the element order of the saved dataset will be preserved when loading it.</p> <p>The <code translate="no" dir="ltr">reader_func</code> argument can be used to specify a custom order in which elements should be loaded from the individual shards. The <code translate="no" dir="ltr">reader_func</code> is expected to take a single argument -- a dataset of datasets, each containing elements of one of the shards -- and return a dataset of elements. For example, the order of shards can be shuffled when loading them as follows:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def custom_reader_func(datasets):
  datasets = datasets.shuffle(NUM_SHARDS)
  return datasets.interleave(lambda x: x, num_parallel_calls=AUTOTUNE)

dataset = tf.data.Dataset.load(
    path="/path/to/data", ..., reader_func=custom_reader_func)
</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">path</code> </td> <td> Required. A path pointing to a previously saved dataset. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">element_spec</code> </td> <td> Optional. A nested structure of <a href="../typespec.html"><code translate="no" dir="ltr">tf.TypeSpec</code></a> objects matching the structure of an element of the saved dataset and specifying the type of individual element components. If not provided, the nested structure of <a href="../typespec.html"><code translate="no" dir="ltr">tf.TypeSpec</code></a> saved with the saved dataset is used. Note that this argument is required in graph mode. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">compression</code> </td> <td> Optional. The algorithm to use to decompress the data when reading it. Supported options are <code translate="no" dir="ltr">GZIP</code> and <code translate="no" dir="ltr">NONE</code>. Defaults to <code translate="no" dir="ltr">NONE</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">reader_func</code> </td> <td> Optional. A function to control how to read data from shards. If present, the function will be traced and executed as graph computation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a> instance. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">FileNotFoundError</code> </td> <td> If <code translate="no" dir="ltr">element_spec</code> is not specified and the saved nested structure of <a href="../typespec.html"><code translate="no" dir="ltr">tf.TypeSpec</code></a> can not be located with the saved dataset. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">element_spec</code> is not specified and the method is executed in graph mode. </td> </tr> </table> <h3 id="map" data-text="map" tabindex="-1"><code translate="no" dir="ltr">map</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2144-L2305">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">map(
    map_func, num_parallel_calls=None, deterministic=None, name=None
)
</pre></devsite-code> <p>Maps <code translate="no" dir="ltr">map_func</code> across the elements of this dataset.</p> <p>This transformation applies <code translate="no" dir="ltr">map_func</code> to each element of this dataset, and returns a new dataset containing the transformed elements, in the same order as they appeared in the input. <code translate="no" dir="ltr">map_func</code> can be used to change both the values and the structure of a dataset's elements. Supported structure constructs are documented <a href="https://www.tensorflow.org/guide/data#dataset_structure">here</a>.</p> <p>For example, <code translate="no" dir="ltr">map</code> can be used for adding 1 to each element, or projecting a subset of element components.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = Dataset.range(1, 6)  # ==&gt; [ 1, 2, 3, 4, 5 ]
dataset = dataset.map(lambda x: x + 1)
list(dataset.as_numpy_iterator())
[2, 3, 4, 5, 6]</pre></devsite-code> <p>The input signature of <code translate="no" dir="ltr">map_func</code> is determined by the structure of each element in this dataset.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = Dataset.range(5)
# `map_func` takes a single argument of type `tf.Tensor` with the same
# shape and dtype.
result = dataset.map(lambda x: x + 1)</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># Each element is a tuple containing two `tf.Tensor` objects.
elements = [(1, "foo"), (2, "bar"), (3, "baz")]
dataset = tf.data.Dataset.from_generator(
    lambda: elements, (tf.int32, tf.string))
# `map_func` takes two arguments of type `tf.Tensor`. This function
# projects out just the first component.
result = dataset.map(lambda x_int, y_str: x_int)
list(result.as_numpy_iterator())
[1, 2, 3]</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># Each element is a dictionary mapping strings to `tf.Tensor` objects.
elements =  ([{"a": 1, "b": "foo"},
              {"a": 2, "b": "bar"},
              {"a": 3, "b": "baz"}])
dataset = tf.data.Dataset.from_generator(
    lambda: elements, {"a": tf.int32, "b": tf.string})
# `map_func` takes a single argument of type `dict` with the same keys
# as the elements.
result = dataset.map(lambda d: str(d["a"]) + d["b"])</pre></devsite-code> <p>The value or values returned by <code translate="no" dir="ltr">map_func</code> determine the structure of each element in the returned dataset.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(3)
# `map_func` returns two `tf.Tensor` objects.
def g(x):
  return tf.constant(37.0), tf.constant(["Foo", "Bar", "Baz"])
result = dataset.map(g)
result.element_spec
(TensorSpec(shape=(), dtype=tf.float32, name=None), TensorSpec(shape=(3,), dtype=tf.string, name=None))
# Python primitives, lists, and NumPy arrays are implicitly converted to
# `tf.Tensor`.
def h(x):
  return 37.0, ["Foo", "Bar"], np.array([1.0, 2.0], dtype=np.float64)
result = dataset.map(h)
result.element_spec
(TensorSpec(shape=(), dtype=tf.float32, name=None), TensorSpec(shape=(2,), dtype=tf.string, name=None), TensorSpec(shape=(2,), dtype=tf.float64, name=None))
# `map_func` can return nested structures.
def i(x):
  return (37.0, [42, 16]), "foo"
result = dataset.map(i)
result.element_spec
((TensorSpec(shape=(), dtype=tf.float32, name=None),
  TensorSpec(shape=(2,), dtype=tf.int32, name=None)),
 TensorSpec(shape=(), dtype=tf.string, name=None))</pre></devsite-code> <p><code translate="no" dir="ltr">map_func</code> can accept as arguments and return any type of dataset element.</p> <p>Note that irrespective of the context in which <code translate="no" dir="ltr">map_func</code> is defined (eager vs. graph), tf.data traces the function and executes it as a graph. To use Python code inside of the function you have a few options:</p> <p>1) Rely on AutoGraph to convert Python code into an equivalent graph computation. The downside of this approach is that AutoGraph can convert some but not all Python code.</p> <p>2) Use <a href="../py_function.html"><code translate="no" dir="ltr">tf.py_function</code></a>, which allows you to write arbitrary Python code but will generally result in worse performance than 1). For example:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">d = tf.data.Dataset.from_tensor_slices(['hello', 'world'])
# transform a string tensor to upper case string using a Python function
def upper_case_fn(t: tf.Tensor):
  return t.numpy().decode('utf-8').upper()
d = d.map(lambda x: tf.py_function(func=upper_case_fn,
          inp=[x], Tout=tf.string))
list(d.as_numpy_iterator())
[b'HELLO', b'WORLD']</pre></devsite-code> <p>3) Use <a href="../numpy_function.html"><code translate="no" dir="ltr">tf.numpy_function</code></a>, which also allows you to write arbitrary Python code. Note that <a href="../py_function.html"><code translate="no" dir="ltr">tf.py_function</code></a> accepts <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a> whereas <a href="../numpy_function.html"><code translate="no" dir="ltr">tf.numpy_function</code></a> accepts numpy arrays and returns only numpy arrays. For example:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">d = tf.data.Dataset.from_tensor_slices(['hello', 'world'])
def upper_case_fn(t: np.ndarray):
  return t.decode('utf-8').upper()
d = d.map(lambda x: tf.numpy_function(func=upper_case_fn,
          inp=[x], Tout=tf.string))
list(d.as_numpy_iterator())
[b'HELLO', b'WORLD']</pre></devsite-code> <p>Note that the use of <a href="../numpy_function.html"><code translate="no" dir="ltr">tf.numpy_function</code></a> and <a href="../py_function.html"><code translate="no" dir="ltr">tf.py_function</code></a> in general precludes the possibility of executing user-defined transformations in parallel (because of Python GIL).</p> <p>Performance can often be improved by setting <code translate="no" dir="ltr">num_parallel_calls</code> so that <code translate="no" dir="ltr">map</code> will use multiple threads to process elements. If deterministic order isn't required, it can also improve performance to set <code translate="no" dir="ltr">deterministic=False</code>.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = Dataset.range(1, 6)  # ==&gt; [ 1, 2, 3, 4, 5 ]
dataset = dataset.map(lambda x: x + 1,
    num_parallel_calls=tf.data.AUTOTUNE,
    deterministic=False)</pre></devsite-code> <p>The order of elements yielded by this transformation is deterministic if <code translate="no" dir="ltr">deterministic=True</code>. If <code translate="no" dir="ltr">map_func</code> contains stateful operations and <code translate="no" dir="ltr">num_parallel_calls &gt; 1</code>, the order in which that state is accessed is undefined, so the values of output elements may not be deterministic regardless of the <code translate="no" dir="ltr">deterministic</code> flag value.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">map_func</code> </td> <td> A function mapping a dataset element to another dataset element. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">num_parallel_calls</code> </td> <td> (Optional.) A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number elements to process asynchronously in parallel. If not specified, elements will be processed sequentially. If the value <a href="../data.html#AUTOTUNE"><code translate="no" dir="ltr">tf.data.AUTOTUNE</code></a> is used, then the number of parallel calls is set dynamically based on available CPU. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">deterministic</code> </td> <td> (Optional.) When <code translate="no" dir="ltr">num_parallel_calls</code> is specified, if this boolean is specified (<code translate="no" dir="ltr">True</code> or <code translate="no" dir="ltr">False</code>), it controls the order in which the transformation produces elements. If set to <code translate="no" dir="ltr">False</code>, the transformation is allowed to yield elements out of order to trade determinism for performance. If not specified, the <a href="options.html#deterministic"><code translate="no" dir="ltr">tf.data.Options.deterministic</code></a> option (<code translate="no" dir="ltr">True</code> by default) controls the behavior. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="options" data-text="options" tabindex="-1"><code translate="no" dir="ltr">options</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L453-L471">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">options()
</pre></devsite-code> <p>Returns the options for this dataset and its inputs.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <a href="options.html"><code translate="no" dir="ltr">tf.data.Options</code></a> object representing the dataset options. </td> </tr> 
</table> <h3 id="padded_batch" data-text="padded_batch" tabindex="-1"><code translate="no" dir="ltr">padded_batch</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1900-L2028">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">padded_batch(
    batch_size,
    padded_shapes=None,
    padding_values=None,
    drop_remainder=False,
    name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Combines consecutive elements of this dataset into padded batches.</p> <p>This transformation combines multiple consecutive elements of the input dataset into a single element.</p> <p>Like <a href="dataset.html#batch"><code translate="no" dir="ltr">tf.data.Dataset.batch</code></a>, the components of the resulting element will have an additional outer dimension, which will be <code translate="no" dir="ltr">batch_size</code> (or <code translate="no" dir="ltr">N % batch_size</code> for the last element if <code translate="no" dir="ltr">batch_size</code> does not divide the number of input elements <code translate="no" dir="ltr">N</code> evenly and <code translate="no" dir="ltr">drop_remainder</code> is <code translate="no" dir="ltr">False</code>). If your program depends on the batches having the same outer dimension, you should set the <code translate="no" dir="ltr">drop_remainder</code> argument to <code translate="no" dir="ltr">True</code> to prevent the smaller batch from being produced.</p> <p>Unlike <a href="dataset.html#batch"><code translate="no" dir="ltr">tf.data.Dataset.batch</code></a>, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in <code translate="no" dir="ltr">padded_shapes</code>. The <code translate="no" dir="ltr">padded_shapes</code> argument determines the resulting shape for each dimension of each component in an output element:</p> <ul> <li>If the dimension is a constant, the component will be padded out to that length in that dimension.</li> <li>If the dimension is unknown, the component will be padded out to the maximum length of all elements in that dimension.</li> </ul> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">A = (tf.data.Dataset
     .range(1, 5, output_type=tf.int32)
     .map(lambda x: tf.fill([x], x)))
# Pad to the smallest per-batch size that fits all elements.
B = A.padded_batch(2)
for element in B.as_numpy_iterator():
  print(element)
[[1 0]
 [2 2]]
[[3 3 3 0]
 [4 4 4 4]]
# Pad to a fixed size.
C = A.padded_batch(2, padded_shapes=5)
for element in C.as_numpy_iterator():
  print(element)
[[1 0 0 0 0]
 [2 2 0 0 0]]
[[3 3 3 0 0]
 [4 4 4 4 0]]
# Pad with a custom value.
D = A.padded_batch(2, padded_shapes=5, padding_values=-1)
for element in D.as_numpy_iterator():
  print(element)
[[ 1 -1 -1 -1 -1]
 [ 2  2 -1 -1 -1]]
[[ 3  3  3 -1 -1]
 [ 4  4  4  4 -1]]
# Components of nested elements can be padded independently.
elements = [([1, 2, 3], [10]),
            ([4, 5], [11, 12])]
dataset = tf.data.Dataset.from_generator(
    lambda: iter(elements), (tf.int32, tf.int32))
# Pad the first component of the tuple to length 4, and the second
# component to the smallest size that fits.
dataset = dataset.padded_batch(2,
    padded_shapes=([4], [None]),
    padding_values=(-1, 100))
list(dataset.as_numpy_iterator())
[(array([[ 1,  2,  3, -1], [ 4,  5, -1, -1]], dtype=int32),
  array([[ 10, 100], [ 11,  12]], dtype=int32))]
# Pad with a single value and multiple components.
E = tf.data.Dataset.zip((A, A)).padded_batch(2, padding_values=-1)
for element in E.as_numpy_iterator():
  print(element)
(array([[ 1, -1],
       [ 2,  2]], dtype=int32), array([[ 1, -1],
       [ 2,  2]], dtype=int32))
(array([[ 3,  3,  3, -1],
       [ 4,  4,  4,  4]], dtype=int32), array([[ 3,  3,  3, -1],
       [ 4,  4,  4,  4]], dtype=int32))</pre></devsite-code> <p>See also <a href="experimental/dense_to_sparse_batch.html"><code translate="no" dir="ltr">tf.data.experimental.dense_to_sparse_batch</code></a>, which combines elements that may have different shapes into a <a href="../sparse/sparsetensor.html"><code translate="no" dir="ltr">tf.sparse.SparseTensor</code></a>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">batch_size</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of consecutive elements of this dataset to combine in a single batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">padded_shapes</code> </td> <td> (Optional.) A (nested) structure of <a href="../tensorshape.html"><code translate="no" dir="ltr">tf.TensorShape</code></a> or <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> vector tensor-like objects representing the shape to which the respective component of each input element should be padded prior to batching. Any unknown dimensions will be padded to the maximum size of that dimension in each batch. If unset, all dimensions of all components are padded to the maximum size in the batch. <code translate="no" dir="ltr">padded_shapes</code> must be set if any component has an unknown rank. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">padding_values</code> </td> <td> (Optional.) A (nested) structure of scalar-shaped <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the padding values to use for the respective components. None represents that the (nested) structure should be padded with default values. Defaults are <code translate="no" dir="ltr">0</code> for numeric types and the empty string for string types. The <code translate="no" dir="ltr">padding_values</code> should have the same (nested) structure as the input dataset. If <code translate="no" dir="ltr">padding_values</code> is a single element and the input dataset has multiple components, then the same <code translate="no" dir="ltr">padding_values</code> will be used to pad every component of the dataset. If <code translate="no" dir="ltr">padding_values</code> is a scalar, then its value will be broadcasted to match the shape of each component. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">drop_remainder</code> </td> <td> (Optional.) A <a href="../../tf.html#bool"><code translate="no" dir="ltr">tf.bool</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing whether the last batch should be dropped in the case it has fewer than <code translate="no" dir="ltr">batch_size</code> elements; the default behavior is not to drop the smaller batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If a component has an unknown rank, and the <code translate="no" dir="ltr">padded_shapes</code> argument is not set. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If a component is of an unsupported type. The list of supported types is documented in <a href="https://www.tensorflow.org/guide/data#dataset_structure">https://www.tensorflow.org/guide/data#dataset_structure</a> </td> </tr> </table> <h3 id="prefetch" data-text="prefetch" tabindex="-1"><code translate="no" dir="ltr">prefetch</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1231-L1260">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">prefetch(
    buffer_size, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> that prefetches elements from this dataset.</p> <p>Most dataset input pipelines should end with a call to <code translate="no" dir="ltr">prefetch</code>. This allows later elements to be prepared while the current element is being processed. This often improves latency and throughput, at the cost of using additional memory to store prefetched elements.</p> <blockquote class="note">
<strong>Note:</strong><span> Like other <code translate="no" dir="ltr">Dataset</code> methods, prefetch operates on the elements of the input dataset. It has no concept of examples vs. batches. <code translate="no" dir="ltr">examples.prefetch(2)</code> will prefetch two elements (2 examples), while <code translate="no" dir="ltr">examples.batch(20).prefetch(2)</code> will prefetch 2 elements (2 batches, of 20 examples each).</span>
</blockquote> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(3)
dataset = dataset.prefetch(2)
list(dataset.as_numpy_iterator())
[0, 1, 2]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">buffer_size</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the maximum number of elements that will be buffered when prefetching. If the value <a href="../data.html#AUTOTUNE"><code translate="no" dir="ltr">tf.data.AUTOTUNE</code></a> is used, then the buffer size is dynamically tuned. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> Optional. A name for the tf.data transformation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="ragged_batch" data-text="ragged_batch" tabindex="-1"><code translate="no" dir="ltr">ragged_batch</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2030-L2093">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">ragged_batch(
    batch_size,
    drop_remainder=False,
    row_splits_dtype=tf.dtypes.int64,
    name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Combines consecutive elements of this dataset into <a href="../raggedtensor.html"><code translate="no" dir="ltr">tf.RaggedTensor</code></a>s.</p> <p>Like <a href="dataset.html#batch"><code translate="no" dir="ltr">tf.data.Dataset.batch</code></a>, the components of the resulting element will have an additional outer dimension, which will be <code translate="no" dir="ltr">batch_size</code> (or <code translate="no" dir="ltr">N % batch_size</code> for the last element if <code translate="no" dir="ltr">batch_size</code> does not divide the number of input elements <code translate="no" dir="ltr">N</code> evenly and <code translate="no" dir="ltr">drop_remainder</code> is <code translate="no" dir="ltr">False</code>). If your program depends on the batches having the same outer dimension, you should set the <code translate="no" dir="ltr">drop_remainder</code> argument to <code translate="no" dir="ltr">True</code> to prevent the smaller batch from being produced.</p> <p>Unlike <a href="dataset.html#batch"><code translate="no" dir="ltr">tf.data.Dataset.batch</code></a>, the input elements to be batched may have different shapes:</p> <ul> <li>If an input element is a <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a> whose static <a href="../tensorshape.html"><code translate="no" dir="ltr">tf.TensorShape</code></a> is fully defined, then it is batched as normal.</li> <li>If an input element is a <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a> whose static <a href="../tensorshape.html"><code translate="no" dir="ltr">tf.TensorShape</code></a> contains one or more axes with unknown size (i.e., <code translate="no" dir="ltr">shape[i]=None</code>), then the output will contain a <a href="../raggedtensor.html"><code translate="no" dir="ltr">tf.RaggedTensor</code></a> that is ragged up to any of such dimensions.</li> <li>If an input element is a <a href="../raggedtensor.html"><code translate="no" dir="ltr">tf.RaggedTensor</code></a> or any other type, then it is batched as normal.</li> </ul> <h4 id="example" data-text="Example:" tabindex="-1">Example:</h4> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(6)
dataset = dataset.map(lambda x: tf.range(x))
dataset.element_spec.shape
TensorShape([None])
dataset = dataset.ragged_batch(2)
for batch in dataset:
  print(batch)
&lt;tf.RaggedTensor [[], [0]]&gt;
&lt;tf.RaggedTensor [[0, 1], [0, 1, 2]]&gt;
&lt;tf.RaggedTensor [[0, 1, 2, 3], [0, 1, 2, 3, 4]]&gt;</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">batch_size</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of consecutive elements of this dataset to combine in a single batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">drop_remainder</code> </td> <td> (Optional.) A <a href="../../tf.html#bool"><code translate="no" dir="ltr">tf.bool</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing whether the last batch should be dropped in the case it has fewer than <code translate="no" dir="ltr">batch_size</code> elements; the default behavior is not to drop the smaller batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_splits_dtype</code> </td> <td> The dtype that should be used for the <code translate="no" dir="ltr">row_splits</code> of any new ragged tensors. Existing <a href="../raggedtensor.html"><code translate="no" dir="ltr">tf.RaggedTensor</code></a> elements do not have their row_splits dtype changed. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A string indicating a name for the <a href="../data.html"><code translate="no" dir="ltr">tf.data</code></a> operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="random" data-text="random" tabindex="-1"><code translate="no" dir="ltr">random</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L3209-L3260">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@staticmethod
random(
    seed=None, rerandomize_each_iteration=None, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> of pseudorandom values.</p> <p>The dataset generates a sequence of uniformly distributed integer values.</p> <p><code translate="no" dir="ltr">rerandomize_each_iteration</code> controls whether the sequence of random number generated should be re-randomized for each epoch. The default value is False where the dataset generates the same sequence of random numbers for each epoch.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">ds1 = tf.data.Dataset.random(seed=4).take(10)
ds2 = tf.data.Dataset.random(seed=4).take(10)
print(list(ds1.as_numpy_iterator())==list(ds2.as_numpy_iterator()))
True</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">ds3 = tf.data.Dataset.random(seed=4).take(10)
ds3_first_epoch = list(ds3.as_numpy_iterator())
ds3_second_epoch = list(ds3.as_numpy_iterator())
print(ds3_first_epoch == ds3_second_epoch)
True</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">ds4 = tf.data.Dataset.random(
    seed=4, rerandomize_each_iteration=True).take(10)
ds4_first_epoch = list(ds4.as_numpy_iterator())
ds4_second_epoch = list(ds4.as_numpy_iterator())
print(ds4_first_epoch == ds4_second_epoch)
False</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">seed</code> </td> <td> (Optional) If specified, the dataset produces a deterministic sequence of values. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">rerandomize_each_iteration</code> </td> <td> (Optional) If set to False, the dataset generates the same sequence of random numbers for each epoch. If set to True, it generates a different deterministic sequence of random numbers for each epoch. It is defaulted to False if left unspecified. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="range" data-text="range" tabindex="-1"><code translate="no" dir="ltr">range</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L973-L1014">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@staticmethod
range(
    *args, **kwargs
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> of a step-separated range of values.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">list(Dataset.range(5).as_numpy_iterator())
[0, 1, 2, 3, 4]
list(Dataset.range(2, 5).as_numpy_iterator())
[2, 3, 4]
list(Dataset.range(1, 5, 2).as_numpy_iterator())
[1, 3]
list(Dataset.range(1, 5, -2).as_numpy_iterator())
[]
list(Dataset.range(5, 1).as_numpy_iterator())
[]
list(Dataset.range(5, 1, -2).as_numpy_iterator())
[5, 3]
list(Dataset.range(2, 5, output_type=tf.int32).as_numpy_iterator())
[2, 3, 4]
list(Dataset.range(1, 5, 2, output_type=tf.float32).as_numpy_iterator())
[1.0, 3.0]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">*args</code> </td> <td> follows the same semantics as python's range. len(args) == 1 -&gt; start = 0, stop = args[0], step = 1. len(args) == 2 -&gt; start = args[0], stop = args[1], step = 1. len(args) == 3 -&gt; start = args[0], stop = args[1], step = args[2]. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">**kwargs</code> </td> <td> <ul> <li>output_type: Its expected dtype. (Optional, default: <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a>).</li> <li>name: (Optional.) A name for the tf.data operation. </li>
</ul>
</td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">RangeDataset</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> if len(args) == 0. </td> </tr> </table> <h3 id="rebatch" data-text="rebatch" tabindex="-1"><code translate="no" dir="ltr">rebatch</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1177-L1229">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">rebatch(
    batch_size, drop_remainder=False, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> that rebatches the elements from this dataset.</p> <p><code translate="no" dir="ltr">rebatch(N)</code> is functionally equivalent to <code translate="no" dir="ltr">unbatch().batch(N)</code>, but is more efficient, performing one copy instead of two.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">ds = tf.data.Dataset.range(6)
ds = ds.batch(2)
ds = ds.rebatch(3)
list(ds.as_numpy_iterator())
[array([0, 1, 2]), array([3, 4, 5])]</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">ds = tf.data.Dataset.range(7)
ds = ds.batch(4)
ds = ds.rebatch(3)
list(ds.as_numpy_iterator())
[array([0, 1, 2]), array([3, 4, 5]), array([6])]</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">ds = tf.data.Dataset.range(7)
ds = ds.batch(2)
ds = ds.rebatch(3, drop_remainder=True)
list(ds.as_numpy_iterator())
[array([0, 1, 2]), array([3, 4, 5])]</pre></devsite-code> <p>If the <code translate="no" dir="ltr">batch_size</code> argument is a list, <code translate="no" dir="ltr">rebatch</code> cycles through the list to determine the size of each batch.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">ds = tf.data.Dataset.range(8)
ds = ds.batch(4)
ds = ds.rebatch([2, 1, 1])
list(ds.as_numpy_iterator())
[array([0, 1]), array([2]), array([3]), array([4, 5]), array([6]),
array([7])]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">batch_size</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar or vector, representing the size of batches to produce. If this argument is a vector, these values are cycled through in round robin fashion. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">drop_remainder</code> </td> <td> (Optional.) A <a href="../../tf.html#bool"><code translate="no" dir="ltr">tf.bool</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing whether the last batch should be dropped in the case it has fewer than <code translate="no" dir="ltr">batch_size[cycle_index]</code> elements; the default behavior is not to drop the smaller batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Dataset</code> of scalar <code translate="no" dir="ltr">dtype</code> elements. </td> </tr> 
</table> <h3 id="reduce" data-text="reduce" tabindex="-1"><code translate="no" dir="ltr">reduce</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2703-L2819">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">reduce(
    initial_state, reduce_func, name=None
)
</pre></devsite-code> <p>Reduces the input dataset to a single element.</p> <p>The transformation calls <code translate="no" dir="ltr">reduce_func</code> successively on every element of the input dataset until the dataset is exhausted, aggregating information in its internal state. The <code translate="no" dir="ltr">initial_state</code> argument is used for the initial state and the final state is returned as the result.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">tf.data.Dataset.range(5).reduce(np.int64(0), lambda x, _: x + 1).numpy()
5
tf.data.Dataset.range(5).reduce(np.int64(0), lambda x, y: x + y).numpy()
10</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">initial_state</code> </td> <td> An element representing the initial state of the transformation. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">reduce_func</code> </td> <td> A function that maps <code translate="no" dir="ltr">(old_state, input_element)</code> to <code translate="no" dir="ltr">new_state</code>. It must take two arguments and return a new element The structure of <code translate="no" dir="ltr">new_state</code> must match the structure of <code translate="no" dir="ltr">initial_state</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A dataset element corresponding to the final state of the transformation. </td> </tr> 
</table> <h3 id="rejection_resample" data-text="rejection_resample" tabindex="-1"><code translate="no" dir="ltr">rejection_resample</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L3439-L3532">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">rejection_resample(
    class_func, target_dist, initial_dist=None, seed=None, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Resamples elements to reach a target distribution.</p> <blockquote class="note">
<strong>Note:</strong><span> This implementation can reject <strong>or repeat</strong> elements in order to reach the <code translate="no" dir="ltr">target_dist</code>. So, in some cases, the output <code translate="no" dir="ltr">Dataset</code> may be larger than the input <code translate="no" dir="ltr">Dataset</code>.</span>
</blockquote> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">initial_dist = [0.6, 0.4]
n = 1000
elems = np.random.choice(len(initial_dist), size=n, p=initial_dist)
dataset = tf.data.Dataset.from_tensor_slices(elems)
zero, one = np.bincount(list(dataset.as_numpy_iterator())) / n</pre></devsite-code> <p>Following from <code translate="no" dir="ltr">initial_dist</code>, <code translate="no" dir="ltr">zero</code> is ~0.6 and <code translate="no" dir="ltr">one</code> is ~0.4.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">target_dist = [0.5, 0.5]
dataset = dataset.rejection_resample(
   class_func=lambda x: x,
   target_dist=target_dist,
   initial_dist=initial_dist)
dataset = dataset.map(lambda class_func_result, data: data)
zero, one = np.bincount(list(dataset.as_numpy_iterator())) / n</pre></devsite-code> <p>Following from <code translate="no" dir="ltr">target_dist</code>, <code translate="no" dir="ltr">zero</code> is ~0.5 and <code translate="no" dir="ltr">one</code> is ~0.5.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">class_func</code> </td> <td> A function mapping an element of the input dataset to a scalar <a href="../../tf.html#int32"><code translate="no" dir="ltr">tf.int32</code></a> tensor. Values should be in <code translate="no" dir="ltr">[0, num_classes)</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">target_dist</code> </td> <td> A floating point type tensor, shaped <code translate="no" dir="ltr">[num_classes]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">initial_dist</code> </td> <td> (Optional.) A floating point type tensor, shaped <code translate="no" dir="ltr">[num_classes]</code>. If not provided, the true class distribution is estimated live in a streaming fashion. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">seed</code> </td> <td> (Optional.) Python integer seed for the resampler. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="repeat" data-text="repeat" tabindex="-1"><code translate="no" dir="ltr">repeat</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1343-L1369">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">repeat(
    count=None, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Repeats this dataset so each original value is seen <code translate="no" dir="ltr">count</code> times.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])
dataset = dataset.repeat(3)
list(dataset.as_numpy_iterator())
[1, 2, 3, 1, 2, 3, 1, 2, 3]</pre></devsite-code> <blockquote class="note">
<strong>Note:</strong><span> If the input dataset depends on global state (e.g. a random number generator) or its output is non-deterministic (e.g. because of upstream <code translate="no" dir="ltr">shuffle</code>), then different repetitions may produce different elements.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">count</code> </td> <td> (Optional.) A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of times the dataset should be repeated. The default behavior (if <code translate="no" dir="ltr">count</code> is <code translate="no" dir="ltr">None</code> or <code translate="no" dir="ltr">-1</code>) is for the dataset be repeated indefinitely. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="sample_from_datasets" data-text="sample_from_datasets" tabindex="-1"><code translate="no" dir="ltr">sample_from_datasets</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L3534-L3610">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@staticmethod
sample_from_datasets(
    datasets,
    weights=None,
    seed=None,
    stop_on_empty_dataset=False,
    rerandomize_each_iteration=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Samples elements at random from the datasets in <code translate="no" dir="ltr">datasets</code>.</p> <p>Creates a dataset by interleaving elements of <code translate="no" dir="ltr">datasets</code> with <code translate="no" dir="ltr">weight[i]</code> probability of picking an element from dataset <code translate="no" dir="ltr">i</code>. Sampling is done without replacement. For example, suppose we have 2 datasets:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset1 = tf.data.Dataset.range(0, 3)
dataset2 = tf.data.Dataset.range(100, 103)
</pre></devsite-code> <p>Suppose that we sample from these 2 datasets with the following weights:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">sample_dataset = tf.data.Dataset.sample_from_datasets(
    [dataset1, dataset2], weights=[0.5, 0.5])
</pre></devsite-code> <p>One possible outcome of elements in sample_dataset is:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">print(list(sample_dataset.as_numpy_iterator()))
# [100, 0, 1, 101, 2, 102]
</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">datasets</code> </td> <td> A non-empty list of <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a> objects with compatible structure. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">weights</code> </td> <td> (Optional.) A list or Tensor of <code translate="no" dir="ltr">len(datasets)</code> floating-point values where <code translate="no" dir="ltr">weights[i]</code> represents the probability to sample from <code translate="no" dir="ltr">datasets[i]</code>, or a <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a> object where each element is such a list. Defaults to a uniform distribution across <code translate="no" dir="ltr">datasets</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">seed</code> </td> <td> (Optional.) A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the random seed that will be used to create the distribution. See <a href="../random/set_seed.html"><code translate="no" dir="ltr">tf.random.set_seed</code></a> for behavior. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">stop_on_empty_dataset</code> </td> <td> If <code translate="no" dir="ltr">True</code>, sampling stops if it encounters an empty dataset. If <code translate="no" dir="ltr">False</code>, it continues sampling and skips any empty datasets. It is recommended to set it to <code translate="no" dir="ltr">True</code>. Otherwise, the distribution of samples starts off as the user intends, but may change as input datasets become empty. This can be difficult to detect since the dataset starts off looking correct. Default to <code translate="no" dir="ltr">False</code> for backward compatibility. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">rerandomize_each_iteration</code> </td> <td> An optional <code translate="no" dir="ltr">bool</code>. The boolean argument controls whether the sequence of random numbers used to determine which dataset to sample from will be rerandomized each epoch. That is, it determinies whether datasets will be sampled in the same order across different epochs (the default behavior) or not. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A dataset that interleaves elements from <code translate="no" dir="ltr">datasets</code> at random, according to <code translate="no" dir="ltr">weights</code> if provided, otherwise with uniform probability. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If the <code translate="no" dir="ltr">datasets</code> or <code translate="no" dir="ltr">weights</code> arguments have the wrong type. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> <ul> <li>If <code translate="no" dir="ltr">datasets</code> is empty, or</li> <li>If <code translate="no" dir="ltr">weights</code> is specified and does not match the length of <code translate="no" dir="ltr">datasets</code>. </li>
</ul>
</td> </tr> </table> <h3 id="save" data-text="save" tabindex="-1"><code translate="no" dir="ltr">save</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1680-L1762">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">save(
    path, compression=None, shard_func=None, checkpoint_args=None
)
</pre></devsite-code> <p>Saves the content of the given dataset.</p> <p>Example usage:</p> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">import tempfile
path = os.path.join(tempfile.gettempdir(), "saved_data")
# Save a dataset
dataset = tf.data.Dataset.range(2)
dataset.save(path)
new_dataset = tf.data.Dataset.load(path)
for elem in new_dataset:
  print(elem)
  tf.Tensor(0, shape=(), dtype=int64)
  tf.Tensor(1, shape=(), dtype=int64)
  
</pre></devsite-code> <p>The saved dataset is saved in multiple file "shards". By default, the dataset output is divided to shards in a round-robin fashion but custom sharding can be specified via the <code translate="no" dir="ltr">shard_func</code> function. For example, you can save the dataset to using a single shard as follows:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = make_dataset()
def custom_shard_func(element):
  return np.int64(0)
dataset.save(
    path="/path/to/data", ..., shard_func=custom_shard_func)
</pre></devsite-code> <p>To enable checkpointing, pass in <code translate="no" dir="ltr">checkpoint_args</code> to the <code translate="no" dir="ltr">save</code> method as follows:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(100)
save_dir = "..."
checkpoint_prefix = "..."
step_counter = tf.Variable(0, trainable=False)
checkpoint_args = {
  "checkpoint_interval": 50,
  "step_counter": step_counter,
  "directory": checkpoint_prefix,
  "max_to_keep": 20,
}
dataset.save(dataset, save_dir, checkpoint_args=checkpoint_args)
</pre></devsite-code><blockquote class="note">
<strong>Note:</strong><span> The directory layout and file format used for saving the dataset is considered an implementation detail and may change. For this reason, datasets saved through <a href="dataset.html#save"><code translate="no" dir="ltr">tf.data.Dataset.save</code></a> should only be consumed through <a href="dataset.html#load"><code translate="no" dir="ltr">tf.data.Dataset.load</code></a>, which is guaranteed to be backwards compatible.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">path</code> </td> <td> Required. A directory to use for saving the dataset. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">compression</code> </td> <td> Optional. The algorithm to use to compress data when writing it. Supported options are <code translate="no" dir="ltr">GZIP</code> and <code translate="no" dir="ltr">NONE</code>. Defaults to <code translate="no" dir="ltr">NONE</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shard_func</code> </td> <td> Optional. A function to control the mapping of dataset elements to file shards. The function is expected to map elements of the input dataset to int64 shard IDs. If present, the function will be traced and executed as graph computation. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">checkpoint_args</code> </td> <td> Optional args for checkpointing which will be passed into the <a href="../train/checkpointmanager.html"><code translate="no" dir="ltr">tf.train.CheckpointManager</code></a>. If <code translate="no" dir="ltr">checkpoint_args</code> are not specified, then checkpointing will not be performed. The <code translate="no" dir="ltr">save()</code> implementation creates a <a href="../train/checkpoint.html"><code translate="no" dir="ltr">tf.train.Checkpoint</code></a> object internally, so users should not set the <code translate="no" dir="ltr">checkpoint</code> argument in <code translate="no" dir="ltr">checkpoint_args</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An operation which when executed performs the save. When writing checkpoints, returns None. The return value is useful in unit tests. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> <tr class="alt"> <td colspan="2"> ValueError if <code translate="no" dir="ltr">checkpoint</code> is passed into <code translate="no" dir="ltr">checkpoint_args</code>. </td> </tr> 
</table> <h3 id="scan" data-text="scan" tabindex="-1"><code translate="no" dir="ltr">scan</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L3353-L3386">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">scan(
    initial_state, scan_func, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>A transformation that scans a function across an input dataset.</p> <p>This transformation is a stateful relative of <a href="dataset.html#map"><code translate="no" dir="ltr">tf.data.Dataset.map</code></a>. In addition to mapping <code translate="no" dir="ltr">scan_func</code> across the elements of the input dataset, <code translate="no" dir="ltr">scan()</code> accumulates one or more state tensors, whose initial values are <code translate="no" dir="ltr">initial_state</code>.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(10)
initial_state = tf.constant(0, dtype=tf.int64)
scan_func = lambda state, i: (state + i, state + i)
dataset = dataset.scan(initial_state=initial_state, scan_func=scan_func)
list(dataset.as_numpy_iterator())
[0, 1, 3, 6, 10, 15, 21, 28, 36, 45]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">initial_state</code> </td> <td> A nested structure of tensors, representing the initial state of the accumulator. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">scan_func</code> </td> <td> A function that maps <code translate="no" dir="ltr">(old_state, input_element)</code> to <code translate="no" dir="ltr">(new_state, output_element)</code>. It must take two arguments and return a pair of nested structures of tensors. The <code translate="no" dir="ltr">new_state</code> must match the structure of <code translate="no" dir="ltr">initial_state</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="shard" data-text="shard" tabindex="-1"><code translate="no" dir="ltr">shard</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1608-L1678">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">shard(
    num_shards, index, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> that includes only 1/<code translate="no" dir="ltr">num_shards</code> of this dataset.</p> <p><code translate="no" dir="ltr">shard</code> is deterministic. The Dataset produced by <code translate="no" dir="ltr">A.shard(n, i)</code> will contain all elements of A whose index mod n = i.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">A = tf.data.Dataset.range(10)
B = A.shard(num_shards=3, index=0)
list(B.as_numpy_iterator())
[0, 3, 6, 9]
C = A.shard(num_shards=3, index=1)
list(C.as_numpy_iterator())
[1, 4, 7]
D = A.shard(num_shards=3, index=2)
list(D.as_numpy_iterator())
[2, 5, 8]</pre></devsite-code> <p>This dataset operator is very useful when running distributed training, as it allows each worker to read a unique subset.</p> <p>When reading a single input file, you can shard elements as follows:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">d = tf.data.TFRecordDataset(input_file)
d = d.shard(num_workers, worker_index)
d = d.repeat(num_epochs)
d = d.shuffle(shuffle_buffer_size)
d = d.map(parser_fn, num_parallel_calls=num_map_threads)
</pre></devsite-code> <h4 id="important_caveats" data-text="Important caveats:" tabindex="-1">Important caveats:</h4> <ul> <li>Be sure to shard before you use any randomizing operator (such as shuffle).</li> <li>Generally it is best if the shard operator is used early in the dataset pipeline. For example, when reading from a set of TFRecord files, shard before converting the dataset to input samples. This avoids reading every file on every worker. The following is an example of an efficient sharding strategy within a complete pipeline:</li> </ul> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">d = Dataset.list_files(pattern, shuffle=False)
d = d.shard(num_workers, worker_index)
d = d.repeat(num_epochs)
d = d.shuffle(shuffle_buffer_size)
d = d.interleave(tf.data.TFRecordDataset,
                 cycle_length=num_readers, block_length=1)
d = d.map(parser_fn, num_parallel_calls=num_map_threads)
</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">num_shards</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of shards operating in parallel. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">index</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the worker index. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">InvalidArgumentError</code> </td> <td> if <code translate="no" dir="ltr">num_shards</code> or <code translate="no" dir="ltr">index</code> are illegal values. <blockquote class="note">
<strong>Note:</strong><span> error checking is done on a best-effort basis, and errors aren't guaranteed to be caught upon dataset creation. (e.g. providing in a placeholder tensor bypasses the early checking, and will instead result in an error during a session.run call.) </span>
</blockquote>
</td> </tr> </table> <h3 id="shuffle" data-text="shuffle" tabindex="-1"><code translate="no" dir="ltr">shuffle</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1410-L1498">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">shuffle(
    buffer_size, seed=None, reshuffle_each_iteration=None, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Randomly shuffles the elements of this dataset.</p> <p>This dataset fills a buffer with <code translate="no" dir="ltr">buffer_size</code> elements, then randomly samples elements from this buffer, replacing the selected elements with new elements. For perfect shuffling, a buffer size greater than or equal to the full size of the dataset is required.</p> <p>For instance, if your dataset contains 10,000 elements but <code translate="no" dir="ltr">buffer_size</code> is set to 1,000, then <code translate="no" dir="ltr">shuffle</code> will initially select a random element from only the first 1,000 elements in the buffer. Once an element is selected, its space in the buffer is replaced by the next (i.e. 1,001-st) element, maintaining the 1,000 element buffer.</p> <p><code translate="no" dir="ltr">reshuffle_each_iteration</code> controls whether the shuffle order should be different for each epoch. In TF 1.X, the idiomatic way to create epochs was through the <code translate="no" dir="ltr">repeat</code> transformation:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(3)
dataset = dataset.shuffle(3, reshuffle_each_iteration=True)
dataset = dataset.repeat(2)
# [1, 0, 2, 1, 2, 0]

dataset = tf.data.Dataset.range(3)
dataset = dataset.shuffle(3, reshuffle_each_iteration=False)
dataset = dataset.repeat(2)
# [1, 0, 2, 1, 0, 2]
</pre></devsite-code> <p>In TF 2.0, <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a> objects are Python iterables which makes it possible to also create epochs through Python iteration:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(3)
dataset = dataset.shuffle(3, reshuffle_each_iteration=True)
list(dataset.as_numpy_iterator())
# [1, 0, 2]
list(dataset.as_numpy_iterator())
# [1, 2, 0]
</pre></devsite-code>
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(3)
dataset = dataset.shuffle(3, reshuffle_each_iteration=False)
list(dataset.as_numpy_iterator())
# [1, 0, 2]
list(dataset.as_numpy_iterator())
# [1, 0, 2]
</pre></devsite-code> <h4 id="fully_shuffling_all_the_data" data-text="Fully shuffling all the data" tabindex="-1">Fully shuffling all the data</h4> <p>To shuffle an entire dataset, set <code translate="no" dir="ltr">buffer_size=dataset.cardinality()</code>. This is equivalent to setting the <code translate="no" dir="ltr">buffer_size</code> equal to the number of elements in the dataset, resulting in uniform shuffle.</p> <blockquote class="note">
<strong>Note:</strong><span> <code translate="no" dir="ltr">shuffle(dataset.cardinality())</code> loads the full dataset into memory so that it can be shuffled. This will cause a memory overflow (OOM) error if the dataset is too large, so full-shuffle should only be used for datasets that are known to fit in the memory, such as datasets of filenames or other small datasets.</span>
</blockquote>

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(20)
dataset = dataset.shuffle(dataset.cardinality())
# [18, 4, 9, 2, 17, 8, 5, 10, 0, 6, 16, 3, 19, 7, 14, 11, 15, 13, 12, 1]
</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">buffer_size</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of elements from this dataset from which the new dataset will sample. To uniformly shuffle the entire dataset, use <code translate="no" dir="ltr">buffer_size=dataset.cardinality()</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">seed</code> </td> <td> (Optional.) A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the random seed that will be used to create the distribution. See <a href="../random/set_seed.html"><code translate="no" dir="ltr">tf.random.set_seed</code></a> for behavior. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">reshuffle_each_iteration</code> </td> <td> (Optional.) A boolean, which if true indicates that the dataset should be pseudorandomly reshuffled each time it is iterated over. (Defaults to <code translate="no" dir="ltr">True</code>.) </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="skip" data-text="skip" tabindex="-1"><code translate="no" dir="ltr">skip</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1583-L1606">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">skip(
    count, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> that skips <code translate="no" dir="ltr">count</code> elements from this dataset.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(10)
dataset = dataset.skip(7)
list(dataset.as_numpy_iterator())
[7, 8, 9]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">count</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of elements of this dataset that should be skipped to form the new dataset. If <code translate="no" dir="ltr">count</code> is greater than the size of this dataset, the new dataset will contain no elements. If <code translate="no" dir="ltr">count</code> is -1, skips the entire dataset. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="snapshot" data-text="snapshot" tabindex="-1"><code translate="no" dir="ltr">snapshot</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L3262-L3351">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">snapshot(
    path,
    compression='AUTO',
    reader_func=None,
    shard_func=None,
    name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>API to persist the output of the input dataset.</p> <p>The snapshot API allows users to transparently persist the output of their preprocessing pipeline to disk, and materialize the pre-processed data on a different training run.</p> <p>This API enables repeated preprocessing steps to be consolidated, and allows re-use of already processed data, trading off disk storage and network bandwidth for freeing up more valuable CPU resources and accelerator compute time.</p> <p><a href="https://github.com/tensorflow/community/blob/master/rfcs/20200107-tf-data-snapshot.md">https://github.com/tensorflow/community/blob/master/rfcs/20200107-tf-data-snapshot.md</a> has detailed design documentation of this feature.</p> <p>Users can specify various options to control the behavior of snapshot, including how snapshots are read from and written to by passing in user-defined functions to the <code translate="no" dir="ltr">reader_func</code> and <code translate="no" dir="ltr">shard_func</code> parameters.</p> <p><code translate="no" dir="ltr">shard_func</code> is a user specified function that maps input elements to snapshot shards.</p> <p>Users may want to specify this function to control how snapshot files should be written to disk. Below is an example of how a potential <code translate="no" dir="ltr">shard_func</code> could be written.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = ...
dataset = dataset.enumerate()
dataset = dataset.snapshot("/path/to/snapshot/dir",
    shard_func=lambda x, y: x % NUM_SHARDS, ...)
dataset = dataset.map(lambda x, y: y)
</pre></devsite-code> <p><code translate="no" dir="ltr">reader_func</code> is a user specified function that accepts a single argument: (1) a Dataset of Datasets, each representing a "split" of elements of the original dataset. The cardinality of the input dataset matches the number of the shards specified in the <code translate="no" dir="ltr">shard_func</code> (see above). The function should return a Dataset of elements of the original dataset.</p> <p>Users may want specify this function to control how snapshot files should be read from disk, including the amount of shuffling and parallelism.</p> <p>Here is an example of a standard reader function a user can define. This function enables both dataset shuffling and parallel reading of datasets:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def user_reader_func(datasets):
  # shuffle the datasets splits
  datasets = datasets.shuffle(NUM_CORES)
  # read datasets in parallel and interleave their elements
  return datasets.interleave(lambda x: x, num_parallel_calls=AUTOTUNE)

dataset = dataset.snapshot("/path/to/snapshot/dir",
    reader_func=user_reader_func)
</pre></devsite-code> <p>By default, snapshot parallelizes reads by the number of cores available on the system, but will not attempt to shuffle the data.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">path</code> </td> <td> Required. A directory to use for storing / loading the snapshot to / from. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">compression</code> </td> <td> Optional. The type of compression to apply to the snapshot written to disk. Supported options are <code translate="no" dir="ltr">GZIP</code>, <code translate="no" dir="ltr">SNAPPY</code>, <code translate="no" dir="ltr">AUTO</code> or None. Defaults to <code translate="no" dir="ltr">AUTO</code>, which attempts to pick an appropriate compression algorithm for the dataset. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">reader_func</code> </td> <td> Optional. A function to control how to read data from snapshot shards. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shard_func</code> </td> <td> Optional. A function to control how to shard data when writing a snapshot. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="sparse_batch" data-text="sparse_batch" tabindex="-1"><code translate="no" dir="ltr">sparse_batch</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2095-L2142">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">sparse_batch(
    batch_size, row_shape, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Combines consecutive elements into <a href="../sparse/sparsetensor.html"><code translate="no" dir="ltr">tf.sparse.SparseTensor</code></a>s.</p> <p>Like <a href="dataset.html#padded_batch"><code translate="no" dir="ltr">Dataset.padded_batch()</code></a>, this transformation combines multiple consecutive elements of the dataset, which might have different shapes, into a single element. The resulting element has three components (<code translate="no" dir="ltr">indices</code>, <code translate="no" dir="ltr">values</code>, and <code translate="no" dir="ltr">dense_shape</code>), which comprise a <a href="../sparse/sparsetensor.html"><code translate="no" dir="ltr">tf.sparse.SparseTensor</code></a> that represents the same data. The <code translate="no" dir="ltr">row_shape</code> represents the dense shape of each row in the resulting <a href="../sparse/sparsetensor.html"><code translate="no" dir="ltr">tf.sparse.SparseTensor</code></a>, to which the effective batch size is prepended. For example:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># NOTE: The following examples use `{ ... }` to represent the
# contents of a dataset.
a = { ['a', 'b', 'c'], ['a', 'b'], ['a', 'b', 'c', 'd'] }

a.apply(tf.data.experimental.dense_to_sparse_batch(
    batch_size=2, row_shape=[6])) ==
{
    ([[0, 0], [0, 1], [0, 2], [1, 0], [1, 1]],  # indices
     ['a', 'b', 'c', 'a', 'b'],                 # values
     [2, 6]),                                   # dense_shape
    ([[0, 0], [0, 1], [0, 2], [0, 3]],
     ['a', 'b', 'c', 'd'],
     [1, 6])
}
</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">batch_size</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of consecutive elements of this dataset to combine in a single batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">row_shape</code> </td> <td> A <a href="../tensorshape.html"><code translate="no" dir="ltr">tf.TensorShape</code></a> or <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> vector tensor-like object representing the equivalent dense shape of a row in the resulting <a href="../sparse/sparsetensor.html"><code translate="no" dir="ltr">tf.sparse.SparseTensor</code></a>. Each element of this dataset must have the same rank as <code translate="no" dir="ltr">row_shape</code>, and must have size less than or equal to <code translate="no" dir="ltr">row_shape</code> in each dimension. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A string indicating a name for the <a href="../data.html"><code translate="no" dir="ltr">tf.data</code></a> operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="take" data-text="take" tabindex="-1"><code translate="no" dir="ltr">take</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1558-L1581">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">take(
    count, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> with at most <code translate="no" dir="ltr">count</code> elements from this dataset.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(10)
dataset = dataset.take(3)
list(dataset.as_numpy_iterator())
[0, 1, 2]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">count</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of elements of this dataset that should be taken to form the new dataset. If <code translate="no" dir="ltr">count</code> is -1, or if <code translate="no" dir="ltr">count</code> is greater than the size of this dataset, the new dataset will contain all elements of this dataset. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="take_while" data-text="take_while" tabindex="-1"><code translate="no" dir="ltr">take_while</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L3388-L3410">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">take_while(
    predicate, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>A transformation that stops dataset iteration based on a <code translate="no" dir="ltr">predicate</code>.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(10)
dataset = dataset.take_while(lambda x: x &lt; 5)
list(dataset.as_numpy_iterator())
[0, 1, 2, 3, 4]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">predicate</code> </td> <td> A function that maps a nested structure of tensors (having shapes and types defined by <code translate="no" dir="ltr">self.output_shapes</code> and <code translate="no" dir="ltr">self.output_types</code>) to a scalar <a href="../../tf.html#bool"><code translate="no" dir="ltr">tf.bool</code></a> tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="unbatch" data-text="unbatch" tabindex="-1"><code translate="no" dir="ltr">unbatch</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2910-L2939">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">unbatch(
    name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Splits elements of a dataset into multiple elements.</p> <p>For example, if elements of the dataset are shaped <code translate="no" dir="ltr">[B, a0, a1, ...]</code>, where <code translate="no" dir="ltr">B</code> may vary for each input element, then for each element in the dataset, the unbatched dataset will contain <code translate="no" dir="ltr">B</code> consecutive elements of shape <code translate="no" dir="ltr">[a0, a1, ...]</code>.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">elements = [ [1, 2, 3], [1, 2], [1, 2, 3, 4] ]
dataset = tf.data.Dataset.from_generator(lambda: elements, tf.int64)
dataset = dataset.unbatch()
list(dataset.as_numpy_iterator())
[1, 2, 3, 1, 2, 1, 2, 3, 4]</pre></devsite-code> <blockquote class="note">
<strong>Note:</strong><span> <code translate="no" dir="ltr">unbatch</code> requires a data copy to slice up the batched tensor into smaller, unbatched tensors. When optimizing performance, try to avoid unnecessary usage of <code translate="no" dir="ltr">unbatch</code>.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="unique" data-text="unique" tabindex="-1"><code translate="no" dir="ltr">unique</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L3412-L3437">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">unique(
    name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>A transformation that discards duplicate elements of a <code translate="no" dir="ltr">Dataset</code>.</p> <p>Use this transformation to produce a dataset that contains one instance of each unique element in the input. For example:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices([1, 37, 2, 37, 2, 1])
dataset = dataset.unique()
sorted(list(dataset.as_numpy_iterator()))
[1, 2, 37]</pre></devsite-code> <blockquote class="note">
<strong>Note:</strong><span> This transformation only supports datasets which fit into memory and have elements of either <a href="../../tf.html#int32"><code translate="no" dir="ltr">tf.int32</code></a>, <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> or <a href="../../tf.html#string"><code translate="no" dir="ltr">tf.string</code></a> type.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="window" data-text="window" tabindex="-1"><code translate="no" dir="ltr">window</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2550-L2701">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">window(
    size, shift=None, stride=1, drop_remainder=False, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Returns a dataset of "windows".</p> <p>Each "window" is a dataset that contains a subset of elements of the input dataset. These are finite datasets of size <code translate="no" dir="ltr">size</code> (or possibly fewer if there are not enough input elements to fill the window and <code translate="no" dir="ltr">drop_remainder</code> evaluates to <code translate="no" dir="ltr">False</code>).</p> <h4 id="for_example_2" data-text="For example:" tabindex="-1">For example:</h4> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(7).window(3)
for window in dataset:
  print(window)
&lt;...Dataset element_spec=TensorSpec(shape=(), dtype=tf.int64, name=None)&gt;
&lt;...Dataset element_spec=TensorSpec(shape=(), dtype=tf.int64, name=None)&gt;
&lt;...Dataset element_spec=TensorSpec(shape=(), dtype=tf.int64, name=None)&gt;</pre></devsite-code> <p>Since windows are datasets, they can be iterated over:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">for window in dataset:
  print(list(window.as_numpy_iterator()))
[0, 1, 2]
[3, 4, 5]
[6]</pre></devsite-code> <h4 id="shift" data-text="Shift" tabindex="-1">Shift</h4> <p>The <code translate="no" dir="ltr">shift</code> argument determines the number of input elements to shift between the start of each window. If windows and elements are both numbered starting at 0, the first element in window <code translate="no" dir="ltr">k</code> will be element <code translate="no" dir="ltr">k * shift</code> of the input dataset. In particular, the first element of the first window will always be the first element of the input dataset.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(7).window(3, shift=1,
                                          drop_remainder=True)
for window in dataset:
  print(list(window.as_numpy_iterator()))
[0, 1, 2]
[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]</pre></devsite-code> <h4 id="stride" data-text="Stride" tabindex="-1">Stride</h4> <p>The <code translate="no" dir="ltr">stride</code> argument determines the stride between input elements within a window.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(7).window(3, shift=1, stride=2,
                                          drop_remainder=True)
for window in dataset:
  print(list(window.as_numpy_iterator()))
[0, 2, 4]
[1, 3, 5]
[2, 4, 6]</pre></devsite-code> <h4 id="nested_elements" data-text="Nested elements" tabindex="-1">Nested elements</h4> <p>When the <code translate="no" dir="ltr">window</code> transformation is applied to a dataset whos elements are nested structures, it produces a dataset where the elements have the same nested structure but each leaf is replaced by a window. In other words, the nesting is applied outside of the windows as opposed inside of them.</p> <h4 id="the_type_signature_is_3" data-text="The type signature is:" tabindex="-1">The type signature is:</h4> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def window(
    self: Dataset[Nest[T]], ...
) -&gt; Dataset[Nest[Dataset[T]]]
</pre></devsite-code> <p>Applying <code translate="no" dir="ltr">window</code> to a <code translate="no" dir="ltr">Dataset</code> of tuples gives a tuple of windows:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices(([1, 2, 3, 4, 5],
                                              [6, 7, 8, 9, 10]))
dataset = dataset.window(2)
windows = next(iter(dataset))
windows
(&lt;...Dataset element_spec=TensorSpec(shape=(), dtype=tf.int32, name=None)&gt;,
 &lt;...Dataset element_spec=TensorSpec(shape=(), dtype=tf.int32, name=None)&gt;)</pre></devsite-code> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">def to_numpy(ds):
  return list(ds.as_numpy_iterator())

for windows in dataset:
  print(to_numpy(windows[0]), to_numpy(windows[1]))
[1, 2] [6, 7]
[3, 4] [8, 9]
[5] [10]</pre></devsite-code> <p>Applying <code translate="no" dir="ltr">window</code> to a <code translate="no" dir="ltr">Dataset</code> of dictionaries gives a dictionary of <code translate="no" dir="ltr">Datasets</code>:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.from_tensor_slices({'a': [1, 2, 3],
                                              'b': [4, 5, 6],
                                              'c': [7, 8, 9]})
dataset = dataset.window(2)
def to_numpy(ds):
  return list(ds.as_numpy_iterator())

for windows in dataset:
  print(tf.nest.map_structure(to_numpy, windows))
{'a': [1, 2], 'b': [4, 5], 'c': [7, 8]}
{'a': [3], 'b': [6], 'c': [9]}</pre></devsite-code> <h4 id="flatten_a_dataset_of_windows" data-text="Flatten a dataset of windows" tabindex="-1">Flatten a dataset of windows</h4> <p>The <a href="dataset.html#flat_map"><code translate="no" dir="ltr">Dataset.flat_map</code></a> and <a href="dataset.html#interleave"><code translate="no" dir="ltr">Dataset.interleave</code></a> methods can be used to flatten a dataset of windows into a single dataset.</p> <p>The argument to <code translate="no" dir="ltr">flat_map</code> is a function that takes an element from the dataset and returns a <code translate="no" dir="ltr">Dataset</code>. <code translate="no" dir="ltr">flat_map</code> chains together the resulting datasets sequentially.</p> <p>For example, to turn each window into a dense tensor:</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">dataset = tf.data.Dataset.range(7).window(3, shift=1,
                                          drop_remainder=True)
batched = dataset.flat_map(lambda x:x.batch(3))
for batch in batched:
  print(batch.numpy())
[0 1 2]
[1 2 3]
[2 3 4]
[3 4 5]
[4 5 6]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">size</code> </td> <td> A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of elements of the input dataset to combine into a window. Must be positive. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shift</code> </td> <td> (Optional.) A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of input elements by which the window moves in each iteration. Defaults to <code translate="no" dir="ltr">size</code>. Must be positive. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">stride</code> </td> <td> (Optional.) A <a href="../../tf.html#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the stride of the input elements in the sliding window. Must be positive. The default value of 1 means "retain every input element". </td> </tr>
<tr> <td> <code translate="no" dir="ltr">drop_remainder</code> </td> <td> (Optional.) A <a href="../../tf.html#bool"><code translate="no" dir="ltr">tf.bool</code></a> scalar <a href="../tensor.html"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing whether the last windows should be dropped if their size is smaller than <code translate="no" dir="ltr">size</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="with_options" data-text="with_options" tabindex="-1"><code translate="no" dir="ltr">with_options</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L2941-L2967">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">with_options(
    options, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Returns a new <a href="dataset.html"><code translate="no" dir="ltr">tf.data.Dataset</code></a> with the given options set.</p> <p>The options are "global" in the sense they apply to the entire dataset. If options are set multiple times, they are merged as long as different options do not use different non-default values.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">ds = tf.data.Dataset.range(5)
ds = ds.interleave(lambda x: tf.data.Dataset.range(5),
                   cycle_length=3,
                   num_parallel_calls=3)
options = tf.data.Options()
# This will make the interleave order non-deterministic.
options.deterministic = False
ds = ds.with_options(options)</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">options</code> </td> <td> A <a href="options.html"><code translate="no" dir="ltr">tf.data.Options</code></a> that identifies the options the use. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> when an option is set more than once to a non-default value </td> </tr> </table> <h3 id="zip" data-text="zip" tabindex="-1"><code translate="no" dir="ltr">zip</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L1016-L1080">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">@staticmethod
zip(
    *args, datasets=None, name=None
) -&gt; 'DatasetV2'
</pre></devsite-code> <p>Creates a <code translate="no" dir="ltr">Dataset</code> by zipping together the given datasets.</p> <p>This method has similar semantics to the built-in <code translate="no" dir="ltr">zip()</code> function in Python, with the main difference being that the <code translate="no" dir="ltr">datasets</code> argument can be a (nested) structure of <code translate="no" dir="ltr">Dataset</code> objects. The supported nesting mechanisms are documented <a href="https://www.tensorflow.org/guide/data#dataset_structure">here</a>.</p> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp"># The datasets or nested structure of datasets `*args` argument
# determines the structure of elements in the resulting dataset.
a = tf.data.Dataset.range(1, 4)  # ==&gt; [ 1, 2, 3 ]
b = tf.data.Dataset.range(4, 7)  # ==&gt; [ 4, 5, 6 ]
ds = tf.data.Dataset.zip(a, b)
list(ds.as_numpy_iterator())
[(1, 4), (2, 5), (3, 6)]
ds = tf.data.Dataset.zip(b, a)
list(ds.as_numpy_iterator())
[(4, 1), (5, 2), (6, 3)]

# The `datasets` argument may contain an arbitrary number of datasets.
c = tf.data.Dataset.range(7, 13).batch(2)  # ==&gt; [ [7, 8],
                                           #       [9, 10],
                                           #       [11, 12] ]
ds = tf.data.Dataset.zip(a, b, c)
for element in ds.as_numpy_iterator():
  print(element)
(1, 4, array([7, 8]))
(2, 5, array([ 9, 10]))
(3, 6, array([11, 12]))

# The number of elements in the resulting dataset is the same as
# the size of the smallest dataset in `datasets`.
d = tf.data.Dataset.range(13, 15)  # ==&gt; [ 13, 14 ]
ds = tf.data.Dataset.zip(a, d)
list(ds.as_numpy_iterator())
[(1, 13), (2, 14)]</pre></devsite-code>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">*args</code> </td> <td> Datasets or nested structures of datasets to zip together. This can't be set if <code translate="no" dir="ltr">datasets</code> is set. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">datasets</code> </td> <td> A (nested) structure of datasets. This can't be set if <code translate="no" dir="ltr">*args</code> is set. Note that this exists only for backwards compatibility and it is preferred to use *args. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> (Optional.) A name for the tf.data operation. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A new <code translate="no" dir="ltr">Dataset</code> with the transformation applied as described above. </td> </tr> 
</table> <h3 id="__bool__" data-text="__bool__" tabindex="-1"><code translate="no" dir="ltr">__bool__</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L506-L507">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">__bool__()
</pre></devsite-code> <h3 id="__iter__" data-text="__iter__" tabindex="-1"><code translate="no" dir="ltr">__iter__</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L488-L504">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">__iter__() -&gt; iterator_ops.OwnedIterator
</pre></devsite-code> <p>Creates an iterator for elements of this dataset.</p> <p>The returned iterator implements the Python Iterator protocol.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An <a href="iterator.html"><code translate="no" dir="ltr">tf.data.Iterator</code></a> for the elements of this dataset. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">RuntimeError</code> </td> <td> If not inside of tf.function and not executing eagerly. </td> </tr> </table> <h3 id="__len__" data-text="__len__" tabindex="-1"><code translate="no" dir="ltr">__len__</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L511-L534">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">__len__()
</pre></devsite-code> <p>Returns the length of the dataset if it is known and finite.</p> <p>This method requires that you are running in eager mode, and that the length of the dataset is known and non-infinite. When the length may be unknown or infinite, or if you are running in graph mode, use <a href="dataset.html#cardinality"><code translate="no" dir="ltr">tf.data.Dataset.cardinality</code></a> instead.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An integer representing the length of the dataset. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">RuntimeError</code> </td> <td> If the dataset length is unknown or infinite, or if eager execution is not enabled. </td> </tr> </table> <h3 id="__nonzero__" data-text="__nonzero__" tabindex="-1"><code translate="no" dir="ltr">__nonzero__</code></h3> <p><a target="_blank" class="external" href="https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/python/data/ops/dataset_ops.py#L506-L507">View source</a></p> 
<devsite-code><pre class="devsite-click-to-copy tfo-signature-link" translate="no" dir="ltr" is-upgraded syntax="Python" data-language="cpp">__nonzero__()
</pre></devsite-code>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/data/TextLineDataset" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/data/TextLineDataset</a>
  </p>
</div>
