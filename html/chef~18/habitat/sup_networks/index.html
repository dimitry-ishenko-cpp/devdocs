<div id="col-content" data-swiftype-index="true"> <div id="supervisor-networks"><h1>Supervisor Networks</h1></div>  <div class="prose"> <p data-swiftype-index="false"> <a href="https://github.com/habitat-sh/habitat/tree/main/components/docs-chef-io/content/habitat/sup_networks.md" alt="Link to page on GitHub repository">[edit on GitHub]</a> </p> <p>Chef Habitat Supervisors communicate amongst each other using “gossip” algorithms, which underpin the membership management, leadership election, and service discovery mechanics of Chef Habitat. By simply being “peered” to a single existing Supervisor, a new Supervisor will gradually come to know about <em>all</em> the Supervisors in a Chef Habitat network. The gossip algorithm has built-in features to counteract brief network splits, but care must be taken to set up a robust Supervisor network.</p> <h2 id="the-initial-peer">The Initial Peer</h2> <p>While a Chef Habitat Supervisor does not need to connect with any other Supervisors in order to be useful, leveraging a network of Supervisors unlocks the full potential of Chef Habitat as a platform. In order to do this, a Supervisor must be given the address of at least one other Supervisor in this network when it starts up; this is known as the “initial peer problem”. You might think of a Supervisor network as an exclusive members-only club; you must first know a member in order to become a member yourself.</p> <p>This Supervisor does <em>not</em> know about any other Supervisors, and will (at least initially) run in complete isolation.</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-sh" data-lang="sh">hab sup run
</code></pre></div>
<p>This Supervisor, on the other hand, will start up knowing about three other Supervisors, and will quickly establish contact with each of them. Thanks to the gossip mechanism, it will also find out about every other Supervisor those initial Supervisors know about. Similarly, every other Supervisor will discover the presence of <em>this</em> new Supervisor.</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-sh" data-lang="sh">hab sup run --peer<span style="color:#666">=</span>192.168.0.1 --peer<span style="color:#666">=</span>192.168.0.2 --peer<span style="color:#666">=</span>192.168.0.3
</code></pre></div>
<p>It should be noted that peering is symmetric. Even though our first Supervisor above did not start out peered with any other Supervisors, it can still become part of a Supervisor network if some other Supervisor declares it to be a peer.</p> <h2 id="managing-membership-with-swim">Managing Membership with SWIM</h2> <p>In order for Chef Habitat’s network functionality to work, the Supervisors must first know which other Supervisors they can communicate with. This is a problem of maintaining “membership lists”, and is achieved using the membership protocol known as [SWIM][SWIM]. As detailed above, we must first “seed” a Supervisor’s membership list with at least one “peer”; that is, another Supervisor that it can communicate with.</p> <p>Given a non-empty membership list, the Supervisor can begin probing the members of that list to see if they are still alive and running. Supervisor A sends a message to Supervisor B, effectively asking “are you still there?”. If Supervisor B <em>is</em> available, it will reply to Supervisor A, also sending contact information for up to five Supervisors that <em>it</em> has in its membership lists (Supervisor A sends these introductions in its initial message, as well). In this way, Supervisors can both maintain and <em>grow</em> their membership lists. In short order, Supervisor A will come to know of all the other Supervisors in the network, and they, too, will come to know of Supervisor A.</p> <p>If Supervisor A cannot establish contact with Supervisor B for some reason, it does not immediately consider it to be dead. This would be too strict, and could lead to unnecessary service “flapping”. Instead, Supervisor A will consider Supervisor B “suspect”. In this case, it will ask Supervisor C (another Supervisor in its membership list) if <em>it</em> can contact Supervisor B. If Supervisor C can make contact, it relays that information back to Supervisor A, which will then consider Supervisor B to be alive again, and <em>not</em> suspect. This scenario can arise, for example, if there is a network split between Supervisors A and B, but not between A and C, or B and C. Similarly, network congestion could delay messages such that Supervisor A’s request times out before Supervisor B’s reply can make it back.</p> <p>If no Supervisor can make contact with Supervisor B, either directly or indirectly, the network comes to view Supervisor B as “confirmed” dead. In this case, Supervisor B is effectively removed from all membership lists across the network. As a result, no Supervisors try to contact it again. This is ultimately what happens when you shut down a Supervisor; the rest of the network realizes that it is gone and can reconfigure any services to no longer communicate with any services that were running on it.</p> <p>If, on the other hand, Supervisor B is started back up again, it can rejoin the network. All the other Supervisors will (through the same SWIM mechanism described) recognize that it is back, and will mark it as alive once again. Services will be reconfigured to communicate with Supervisor B’s services as appropriate.</p> <p>This mechanism forms the foundation of the Chef Habitat network, but cannot by itself provide a completely robust network. For that, we need something additional.</p> <h2 id="permanent-peers">Permanent Peers</h2> <p>An important thing to keep in mind about the basic SWIM mechanism is that if two Supervisors are separated from each other for a long enough amount of time, they will each come to view the other as being dead, and will not try to reestablish contact. While this is the behavior you want when you legitimately shut a Supervisor down, it is definitely <em>not</em> the behavior you want if your Chef Habitat network experiences an extended network incident. In such a case, you could end up with two (or more!) smaller Supervisor networks that are all still <em>internally</em> connected, but completely disconnected <em>from each other</em>. Supervisors in “Network A” would view those in “Network B” as dead, and vice versa. Once network connectivity had been restored, you would continue to have a fractured network, because each network would collectively consider the other to still be dead.</p> <p>By starting a few Supervisors in the network using the <code>--permanent-peer</code> option, an additional bit of information is gossipped about these Supervisors. In effect, it tells all other Supervisors it communicates with to <em>always</em> try to reestablish contact with it, even if that Supervisor considers the “permanent” Supervisor to be dead. This provides a mechanism by which split networks can stitch themselves together again after the split has been resolved.</p> <h2 id="the-bastion-ring">The “Bastion Ring”</h2> <p>Defining a few Supervisors to be “permanent peers” <em>will</em> provide a robust network, but unless done with care, it can be less than ideal. We recommend running a small number of Supervisors as permanent peers, but <em>to run no services on those Supervisors</em>. In modern dynamic architectures, it’s common for nodes to come and go; VMs may get shut down, containers can be rescheduled, and so on. If you were to go to the extreme and have <em>all</em> your Supervisors be permanent peers, you would end up with unnecessary network traffic as the Supervisors come and go as the infrastructure evolves across time. Each Supervisor would try to maintain contact with every Supervisor that had ever been a member of the network!</p> <p>If your permanent peer Supervisors are not running any services, they will be less subject to the pressures that would cause service-running Supervisors to come and go. They can exist solely to anchor the entire Supervisor network.</p> <h2 id="pulling-it-all-together-a-robust-supervisor-network">Pulling It All Together: A Robust Supervisor Network</h2> <p>With all this, we can come up with a robust Chef Habitat network architecture. In fact, this is the same architecture the Chef Habitat team uses to run the public <a href="https://bldr.habitat.sh">Builder service</a>.</p> <h3 id="create-the-bastion-ring">Create the Bastion Ring</h3> <p>First, set up three Supervisors as permanent peers, all mutually peered to each other (The labels “A”, “B”, and “C” are stand-ins for the IP addresses at which these Supervisors are reachable):</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-sh" data-lang="sh"><span style="color:#60a0b0;font-style:italic"># Supervisor "A"</span>
hab sup run --permanent-peer --peer<span style="color:#666">=</span>B --peer<span style="color:#666">=</span>C

<span style="color:#60a0b0;font-style:italic"># Supervisor "B"</span>
hab sup run --permanent-peer --peer<span style="color:#666">=</span>A --peer<span style="color:#666">=</span>C

<span style="color:#60a0b0;font-style:italic"># Supervisor "C"</span>
hab sup run --permanent-peer --peer<span style="color:#666">=</span>A --peer<span style="color:#666">=</span>B
</code></pre></div>
<p>These Supervisors should never be used to run services. They <em>can</em> however, serve as convenient, well-known, and stable entry points to the network for doing things like injecting configurations using <code>hab config apply</code>, adding files using <code>hab file upload</code>, or departing Supervisors using <code>hab sup depart</code>.</p> <h3 id="peer-additional-supervisors-to-the-bastion-supervisors">Peer Additional Supervisors to the Bastion Supervisors</h3> <p>Each additional Supervisor you add to the network should be peered to <em>at least one</em> of the bastion ring Supervisors. Technically speaking, only one peer is necessary, as that provides access to the rest of the network. However, it could be possible to not fully connect to all of them if, say, the Supervisor joined <em>during</em> a network split event. Out of convention and redundancy, we peer to <em>all</em> the bastion ring Supervisors, like so:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-sh" data-lang="sh"><span style="color:#60a0b0;font-style:italic"># Supervisor "D" (a "normal" Supervisor)</span>
hab sup run --peer<span style="color:#666">=</span>A --peer<span style="color:#666">=</span>B --peer<span style="color:#666">=</span>C
</code></pre></div>
<p>This Supervisor <em>should</em> be used to run services, but <em>should not</em> be started as a permanent peer.</p> <h2 id="conclusion">Conclusion</h2> <p>Hopefully, the above discussion has given you a better idea of how Chef Habitat’s networking works, and how you can best take advantage of it to provide a robust network foundation for the services you run.</p> <p>For those that like to keep things succinct, the above advice can be summed up thusly:</p> <ol> <li>Run three mutually-peered, permanent Supervisors</li> <li>Never run services on those Supervisors</li> <li>Peer all other Supervisors to those first three</li> </ol> <h2 id="related-reading">Related Reading</h2> <p>If you would like additional details, the following technical journal articles describe the algorithms that form the basis of Chef Habitat’s gossip system:</p> <ul> <li>
<a href="https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf">SWIM: Scalable Weakly-consistent Infection-style Process Group Membership Protocol</a> by Abhinandan Das, Indranil Gupta, Ashish Motivala.</li> <li>
<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.8773&amp;rep=rep1&amp;type=pdf">A Robust and Scalable Peer-to-Peer Gossiping Protocol</a> by Spyros Voulgaris, Mark Jelasity, and Maarten van Steen.</li> </ul> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Chef Software, Inc.<br>Licensed under the Creative Commons Attribution 3.0 Unported License.<br>The Chef&trade; Mark and Chef Logo are either registered trademarks/service marks or trademarks/servicemarks of Chef, in the United States and other countries and are used with Chef Inc's permission.<br>We are not affiliated with, endorsed or sponsored by Chef Inc.<br>
    <a href="https://docs.chef.io/habitat/sup_networks/" class="_attribution-link">https://docs.chef.io/habitat/sup_networks/</a>
  </p>
</div>
