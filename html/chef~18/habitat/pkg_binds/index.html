<div id="col-content" data-swiftype-index="true"> <div id="runtime-binds"><h1>Runtime Binds</h1></div> <div class="prose"> <p data-swiftype-index="false"> <a href="https://github.com/habitat-sh/habitat/tree/main/components/docs-chef-io/content/habitat/pkg_binds.md" alt="Link to page on GitHub repository">[edit on GitHub]</a> </p> <p><em>Runtime binding</em> in Chef Habitat refers to the ability for one service group to connect to another, forming a producer-consumer relationship where the consumer service can use the producer service’s current configuration in order to configure itself at runtime. When the producer’s configuration change, the consumer is notified and can reconfigure itself as needed.</p> <p>With runtime binding, a consumer service can use a “binding name” of their choosing in their configuration and lifecycle hook templates as a kind of handle to refer to the configuration values they need from the producer service. This name isn’t inherently tied to any particular package or service group name. Instead, when the service is run, users associate a service group with that binding name, which gives Chef Habitat all the information it needs to wire the producer and consumer services together.</p> <p>Let’s look at how we set up this relationship in detail.</p> <h3 id="defining-the-producer-contract">Defining the Producer Contract</h3> <p>A producer service defines its contract by “exporting” a subset of its runtime configuration. This is done by defining values in the <code>pkg_exports</code> associative array defined in your package’s <code>plan.sh</code>. For example, a database server named <code>amnesia</code> might define the following exports:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash"><span style="color:#bb60d5">pkg_exports</span><span style="color:#666">=(</span>
  <span style="color:#666">[</span>port<span style="color:#666">]=</span>network.port
  <span style="color:#666">[</span>ssl-port<span style="color:#666">]=</span>network.ssl.port
<span style="color:#666">)</span>
</code></pre></div>
<p>Note that Powershell plans use hashtables where Bash plans use associative arrays. A <code>plan.ps1</code> would declare its exports as:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-powershell" data-lang="powershell"><span style="color:#bb60d5">$pkg_exports</span>=@{
  port=<span style="color:#4070a0">"network.port"</span>
  <span style="color:#007020">ssl-port</span>=<span style="color:#4070a0">"network.ssl.port"</span>
}
</code></pre></div>
<p>This will export the runtime values of its <code>network.port</code> and <code>network.ssl.port</code> configuration entries publicly as <code>port</code> and <code>ssl-port</code>, respectively. All configuration entries in <code>pkg_exports</code> must have a default value in <code>default.toml</code>, but the actual exported values will change at runtime to reflect the producer’s current configuration. When values change (for example, by <code>hab config apply</code>), the consumer service will be notified that its producer service configuration has changed. We’ll see how to use this on the consumer in the sections below.</p> <p>Producer services export only the <em>subset</em> of their configuration that is defined through <code>pkg_exports</code> and not the entire thing. Consumer services see only what the producer service exports, and nothing more. This is important, because it means that configuration that must remain secret–such as passwords–are not shared <em>unless</em> they are explicitly defined in <code>pkg_exports</code>.</p> <p>Additionally, the internal structure of the producer’s configuration is independent of the exported interface it presents. In our example, <code>ssl-port</code> originally comes from a deeply-nested <code>network.ssl.port</code> value. However, the exported interface is <em>flat</em>, effectively a non-nested set of key-value pairs.</p> <h3 id="defining-the-consumer-contract">Defining the Consumer Contract</h3> <p>The consumer service defines a “binding name” as a handle to refer to a service group from which it receives configuration data. However, it must do more than just name the bind, it must also state the configuration values it expects from the service group. Chef Habitat will make sure that whatever service group is bound actually exports the expected values to the consumer service.</p> <p>As an example, let’s say we have an application server, called <code>session-server</code>, that needs to connect to a database service, and needs both a “port” and an “ssl-port” in order to make that connection. We can describe this relationship in our <code>plan.sh</code> file like so:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash"><span style="color:#bb60d5">pkg_binds</span><span style="color:#666">=(</span>
  <span style="color:#666">[</span>database<span style="color:#666">]=</span><span style="color:#4070a0">"port ssl-port"</span>
<span style="color:#666">)</span>
</code></pre></div>
<p>Here, <code>pkg_binds</code> is an associative array. The key (“database”) is the binding name, while the value (“port ssl-port”) is a space-delimited list of the exported configuration the binding requires. A consumer can specify multiple binds; each would be an individual entry in this associative array. Judging from this, the producer we described above would be a good candidate for this application server to bind to, because it exports both a “port” and an “ssl-port”.</p> <p>A bound service group may export additional values, but they cannot export less and still satisfy the contract.</p> <p>Chef Habitat only matches services up at the syntactic, not semantic, level of this contract. If you bind to a service that exports a “port”, Chef Habitat only knows that the service exports something called “port”; it could be the port for a PostgreSQL database, or it could be the port of an application server. You will need to ensure that you connect the correct services together; Chef Habitat’s binds provide the means by which you express these relationships. You are, however, free to create bind names and export names that are meaningful for you.</p> <h4 id="the-difference-between-_pkg_binds_-and-_pkg_binds_optional_">The Difference Between <em>pkg_binds</em> and <em>pkg_binds_optional</em>
</h4> <p>In addition to the <code>pkg_binds</code> array, Plan authors may also specify <code>pkg_binds_optional</code>. It has exactly the same structure as <code>pkg_binds</code>, but, as the name implies, these bindings are <em>optional</em>; however, it is worth examining exactly what is meant by “optional” in this case.</p> <p>In order to load a service into the Supervisor, each bind defined in <code>pkg_binds</code> <em>must</em> be mapped to a service group; if any of these binds are not mapped, then the Supervisor will refuse to load the service.</p> <p>Binds defined in <code>pkg_binds_optional</code>, on the other hand, <em>may</em> be mapped when loading a service. If a service group mapping is not defined at load time, the Supervisor will load the service without question. As an extreme example, a service could have no <code>pkg_binds</code> entries, and five <code>pkg_binds_optional</code> entries; such a service could be loaded with no binds mapped, one bind mapped, all the way to mapping all five binds.</p> <p>There are several scenarios where optional binds may be useful:</p> <ul> <li> <p>A service may have some default functionality which may be overridden at load-time by mapping an optional binding. Perhaps you have some kind of artifact repository service that, in the absence of a “remote-store” bind stores data on the local filesystem. However, if <code>remote-store</code> is bound to an appropriate S3 API-compatible service, such as <a href="https://www.minio.io">Minio</a>, it could modify its behavior to store data remotely.</p> </li> <li> <p>A service can be optionally bind to a service to unlock additional features. For example, say you have an application that may run with or without a caching layer. You can model this using an optional bind named (say), “cache”. If you wish to run without the caching functionality enabled, you can start the service without specifying a service group mapping for the “cache” bind. Since the bind is optional, it is not needed for Chef Habitat to run your service. However, if you do wish to run with the caching enabled, you can specify a service group mapping, e.g. <code>hab svc load acme/my-app --bind=cache:redis.prod</code>. In this scenario, your service’s configuration can pull configuration values from the <code>redis.prod</code> service group, enabling it to use Redis as a caching layer.</p> </li> <li> <p>A service may can optionally bind one of several services; if bind “X” is mapped, operate <em>this</em> way; if “Y” is mapped, operate <em>that</em> way. An application that could use either a Redis backend or a PostgreSQL backend, depending on the deployment scenario, could declare optional “redis” and “postgresql” bindings, and pick which one to map at service load-time. If this is your use case, Chef Habitat does not have a way to encode the fact that “one and only one of these optional bindings should be mapped”, so you will have to manage that on your own.</p> </li> </ul> <h3 id="service-start-up-behavior">Service Start-up Behavior</h3> <p>Prior to Chef Habitat 0.56.0, if the service group that you bound to was not present in the Supervisor network census, or had no live members, your service would not start until the group was present with live members. While this can be desirable behavior in some cases, as with running certain legacy applications, it is not always desirable, particularly for modern microservice applications, which should be able to gracefully cope with the absence of their networked dependencies.</p> <p>With 0.56.0, however, this behavior can be modified using the new runtime service option <code>--binding-mode</code>. By setting <code>--binding-mode=relaxed</code> when loading a service, that service can start immediately, whether there are any members of a bound service group present or not. (Setting <code>--binding-mode=strict</code> will give you the previous, start-only-after-all-bound-groups-are-present behavior. This is also the current default, though <code>relaxed</code> will be the eventual default for Chef Habitat 1.0.0.). Such a service should have configuration and lifecycle hook templates written in such a way that the service can remain operational (though perhaps with reduced functionality) when there are no live members of a bound service group present in the network census.</p> <h4 id="the-difference-between-required-binds-optional-binds-and-binding-mode">The Difference Between Required Binds, Optional Binds, and Binding Mode</h4> <p>While there is a bit of overlap in these concepts, they are distinct. It’s best to think of required and optional binds as defining “how applications can be wired together” (specifically, which “wires” must be connected in order to provide the minimal amount of information needed to run a service). Binding mode, on the other hand, defines how the application’s start-up behavior is affected the presence or absence of its networked dependencies.</p> <p>Another useful thing to keep in mind when thinking about required and optional binds is that service group mappings currently cannot be dynamically changed at runtime. They can only be changed by stopping a service, reloading the service with a new set of options, and then starting it up again. This constraint (which may change in future versions of Chef Habitat) may help guide your choice between what should be a required bind, and what should be optional, particularly when using the relaxed binding mode.</p> <h3 id="using-runtime-binds-with-consumer-services">Using Runtime Binds with Consumer Services</h3> <p>Once you’ve defined both ends of the contract, you can leverage the bind in any of your package’s hooks or configuration files. Given the two example services above, a section of a configuration file for <code>session-server</code> might look like this:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-handlebars" data-lang="handlebars"><span style="color:#007020">{{</span><span>~</span><span style="color:#007020;font-weight:700">#each</span> <span style="color:#bb60d5">bind.database.members</span> <span style="color:#bb60d5">as</span> <span>|</span><span style="color:#bb60d5">member</span><span>|</span><span style="color:#007020">}}</span>
  database = "<span style="color:#007020">{{</span><span style="color:#bb60d5">member.sys.ip</span><span style="color:#007020">}}</span>:<span style="color:#007020">{{</span><span style="color:#bb60d5">member.cfg.port</span><span style="color:#007020">}}</span>"
  database-secure = "<span style="color:#007020">{{</span><span style="color:#bb60d5">member.sys.ip</span><span style="color:#007020">}}</span>:<span style="color:#007020">{{</span><span style="color:#bb60d5">member.cfg.ssl-port</span><span style="color:#007020">}}</span>"
<span style="color:#007020">{{</span><span>~</span><span style="color:#007020;font-weight:700">/each</span><span style="color:#007020">}}</span>
</code></pre></div>
<p>Here, <code>bind.&lt;BINDING_NAME&gt;</code> will be “truthy” (and can thus be used in boolean expressions) only if the bind has been satisfied, and <code>bind.&lt;BINDING_NAME&gt;.members</code> will be an array of only active members.</p> <p>(Prior to Chef Habitat 0.56.0, <code>bind.&lt;BINDING_NAME&gt;</code> was always present, and <code>bind.&lt;BINDING_NAME&gt;.members</code> had <em>all</em> members, even ones that had left the Supervisor network long ago. This necessitated using the <code>eachAlive</code> helper function, instead of just <code>each</code>.)</p> <h3 id="starting-a-consumer-service">Starting a Consumer Service</h3> <p>Since your application server defined <code>database</code> as a required bind, you’ll need to provide the name of a service group running a package which fulfills the contract using the <code>--bind</code> parameter to the Supervisor. For example, running the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">hab svc load &lt;ORIGIN&gt;/&lt;NAME&gt; --bind database:amnesia.default
</code></pre></div>
<p>would create a bind aliasing <code>database</code> to the <code>amnesia</code> service in the <code>default</code> service group.</p> <p>The service group passed to <code>--bind database:{service}.{group}</code> doesn’t <em>need</em> to be the service <code>amnesia</code>. This bind can be any service as long as they export a configuration key for <code>port</code> and <code>ssl-port</code>.</p> <p>You can declare bindings to multiple service groups in your templates by using the <code>--bind</code> option multiple times on the command line. Your service will not start if your package has declared a required bind and a value for it was not specified by <code>--bind</code>.</p> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Chef Software, Inc.<br>Licensed under the Creative Commons Attribution 3.0 Unported License.<br>The Chef&trade; Mark and Chef Logo are either registered trademarks/service marks or trademarks/servicemarks of Chef, in the United States and other countries and are used with Chef Inc's permission.<br>We are not affiliated with, endorsed or sponsored by Chef Inc.<br>
    <a href="https://docs.chef.io/habitat/pkg_binds/" class="_attribution-link">https://docs.chef.io/habitat/pkg_binds/</a>
  </p>
</div>
