<h1>dojo/data/api/Write</h1> <div class="jsdoc-mixins"> <label>Extends</label><a href="read.html">dojo/data/api/Read</a> </div>  <h2 id="summary">Summary</h2> <p>This is an abstract API that data provider implementations conform to. This file defines function signatures and intentionally leaves all the functions unimplemented.</p>  <p>See the <a href="http://dojotoolkit.org/reference-guide/1.10/dojo/data/api/Write.html" target="_blank">dojo/data/api/Write reference documentation</a> for more information.</p>          <h2 id="methods">Methods</h2>    <h3 id="1_10dojo_data_api_Write_close">
<code class="functionIcon">close</code><code class="parameters">(request)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>The close() method is intended for instructing the store to 'close' out any information associated with a particular request.</p>  <p>The close() method is intended for instructing the store to 'close' out any information associated with a particular request. In general, this API expects to receive as a parameter a request object returned from a fetch. It will then close out anything associated with that request, such as clearing any internal datastore caches and closing any 'open' connections. For some store implementations, this call may be a no-op.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>request</td> <td>
<a href="request.html">dojo/data/api/Request</a> | Object</td> <td> <div><em>Optional</em></div>
<p>An instance of a request for the store to use to identify what to close out. If no request is passed, then the store should clear all internal caches (if any) and close out all 'open' connections. It does not render the store unusable from there on, it merely cleans out any current data and resets the store to initial state.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var request = store.fetch({onComplete: doSomething});
...
store.close(request);</code></pre>       <h3 id="1_10dojo_data_api_Write_containsValue">
<code class="functionIcon">containsValue</code><code class="parameters">(item,attribute,value)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>Returns true if the given <em>value</em> is one of the values that getValues() would return.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td><a href="item.html">dojo/data/api/Item</a></td> <td>
<p>The item to access values on.</p> </td> </tr> <tr> <td>attribute</td> <td>attribute-name-string</td> <td>
<p>The attribute to access represented as a string.</p> </td> </tr> <tr> <td>value</td> <td>anything</td> <td>
<p>The value to match as a value for the attribute.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var trueOrFalse = store.containsValue(kermit, "color", "green");</code></pre>       <h3 id="1_10dojo_data_api_Write_deleteItem">
<code class="functionIcon">deleteItem</code><code class="parameters">(item)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="write.html">dojo/data/api/Write</a> </p> <p>Deletes an item from the store.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td><a href="item.html">dojo/data/api/Item</a></td> <td>
<p>The item to delete.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var success = store.deleteItem(kermit);</code></pre>       <h3 id="1_10dojo_data_api_Write_fetch">
<code class="functionIcon">fetch</code><code class="parameters">(keywordArgs)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>Given a query and set of defined options, such as a start and count of items to return, this method executes the query and makes the results available as data items. The format and expectations of stores is that they operate in a generally asynchronous manner, therefore callbacks are always used to return items located by the fetch parameters.</p>  <p>A Request object will always be returned and is returned immediately. The basic request is nothing more than the keyword args passed to fetch and an additional function attached, abort(). The returned request object may then be used to cancel a fetch. All data items returns are passed through the callbacks defined in the fetch parameters and are not present on the 'request' object. </p> <p>This does not mean that custom stores can not add methods and properties to the request object returned, only that the API does not require it. For more info about the Request API, see <a href="request.html">dojo/data/api/Request</a></p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>keywordArgs</td> <td>Object</td> <td>
<p>The keywordArgs parameter may either be an instance of conforming to dojo/data/api/Request or may be a simple anonymous object that may contain any of the following: </p> <pre data-language="javascript"><code>{
    query: query-object or query-string,
    queryOptions: object,
    onBegin: Function,
    onItem: Function,
    onComplete: Function,
    onError: Function,
    scope: object,
    start: int
    count: int
    sort: array
}</code></pre> <p>All implementations should accept keywordArgs objects with any of </p> <p>the 9 standard properties: query, onBegin, onItem, onComplete, onError scope, sort, start, and count. Some implementations may accept additional properties in the keywordArgs object as valid parameters, such as {includeOutliers:true}. </p> <h4>The <em>query</em> parameter</h4> <p>The query may be optional in some data store implementations. The dojo/data/api/Read API does not specify the syntax or semantics of the query itself -- each different data store implementation may have its own notion of what a query should look like. However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data and dojox.data support an object structure query, where the object is a set of name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}. Most of the dijit widgets, such as ComboBox assume this to be the case when working with a datastore when they dynamically update the query. Therefore, for maximum compatibility with dijit widgets the recommended query parameter is a key/value object. That does not mean that the the datastore may not take alternative query forms, such as a simple string, a Date, a number, or a mix of such. Ultimately, The dojo/data/api/Read API is agnostic about what the query format. </p> <p>Further note: In general for query objects that accept strings as attribute value matches, the store should also support basic filtering capability, such as <em> (match any character) and ? (match single character). An example query that is a query object would be like: { attrFoo: "value</em>"}. Which generally means match all items where they have an attribute named attrFoo, with a value that starts with 'value'. </p> <h4>The <em>queryOptions</em> parameter</h4> <p>The queryOptions parameter is an optional parameter used to specify options that may modify the query in some fashion, such as doing a case insensitive search, or doing a deep search where all items in a hierarchical representation of data are scanned instead of just the root items. It currently defines two options that all datastores should attempt to honor if possible: </p> <pre data-language="javascript"><code>{
    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.
    deep: boolean   // Whether or not a fetch should do a deep search of items and all child
                    // items instead of just root-level items in a datastore.  Default is false.
}</code></pre> <h4>The <em>onBegin</em> parameter.</h4> <p>function(size, request); If an onBegin callback function is provided, the callback function will be called just once, before the first onItem callback is called. The onBegin callback function will be passed two arguments, the the total number of items identified and the Request object. If the total number is unknown, then size will be -1. Note that size is not necessarily the size of the collection of items returned from the query, as the request may have specified to return only a subset of the total set of items through the use of the start and count parameters. </p> <h4>The <em>onItem</em> parameter.</h4> <p>function(item, request); </p> <p>If an onItem callback function is provided, the callback function will be called as each item in the result is received. The callback function will be passed two arguments: the item itself, and the Request object. </p> <h4>The <em>onComplete</em> parameter.</h4> <p>function(items, request); </p> <p>If an onComplete callback function is provided, the callback function will be called just once, after the last onItem callback is called. Note that if the onItem callback is not present, then onComplete will be passed an array containing all items which matched the query and the request object. If the onItem callback is present, then onComplete is called as: onComplete(null, request). </p> <h4>The <em>onError</em> parameter.</h4> <p>function(errorData, request); </p> <p>If an onError callback function is provided, the callback function will be called if there is any sort of error while attempting to execute the query. The onError callback function will be passed two arguments: an Error object and the Request object. </p> <h4>The <em>scope</em> parameter.</h4> <p>If a scope object is provided, all of the callback functions (onItem, onComplete, onError, etc) will be invoked in the context of the scope object. In the body of the callback function, the value of the "this" keyword will be the scope object. If no scope object is provided, the callback functions will be called in the context of dojo.global(). For example, onItem.call(scope, item, request) vs. onItem.call(dojo.global(), item, request) </p> <h4>The <em>start</em> parameter.</h4> <p>If a start parameter is specified, this is a indication to the datastore to only start returning items once the start number of items have been located and skipped. When this parameter is paired with 'count', the store should be able to page across queries with millions of hits by only returning subsets of the hits for each query </p> <h4>The <em>count</em> parameter.</h4> <p>If a count parameter is specified, this is a indication to the datastore to only return up to that many items. This allows a fetch call that may have millions of item matches to be paired down to something reasonable. </p> <h4>The <em>sort</em> parameter.</h4> <p>If a sort parameter is specified, this is a indication to the datastore to sort the items in some manner before returning the items. The array is an array of javascript objects that must conform to the following format to be applied to the fetching of items: </p> <pre data-language="javascript"><code>{
    attribute: attribute || attribute-name-string,
    descending: true|false;   // Optional.  Default is false.
}</code></pre> <p>Note that when comparing attributes, if an item contains no value for the attribute </p> <p>(undefined), then it the default ascending sort logic should push it to the bottom of the list. In the descending order case, it such items should appear at the top of the list.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>The fetch() method will return a javascript object conforming to the API defined in dojo/data/api/Request. In general, it will be the keywordArgs object returned with the required functions in Request.js attached. Its general purpose is to provide a convenient way for a caller to abort an ongoing fetch. </p> <p>The Request object may also have additional properties when it is returned such as request.store property, which is a pointer to the datastore object that fetch() is a method of.</p>   <h2>Examples</h2>  <h3>Example 1</h3><p>Fetch all books identified by the query and call 'showBooks' when complete </p> <pre data-language="javascript"><code>var request = store.fetch({query:"all books", onComplete: showBooks});</code></pre>   <h3>Example 2</h3><p>Fetch all items in the story and call 'showEverything' when complete. </p> <pre data-language="javascript"><code>var request = store.fetch(onComplete: showEverything);</code></pre>   <h3>Example 3</h3><p>Fetch only 10 books that match the query 'all books', starting at the fifth book found during the search. This demonstrates how paging can be done for specific queries. </p> <pre data-language="javascript"><code>var request = store.fetch({query:"all books", start: 4, count: 10, onComplete: showBooks});</code></pre>   <h3>Example 4</h3><p>Fetch all items that match the query, calling 'callback' each time an item is located. </p> <pre data-language="javascript"><code>var request = store.fetch({query:"foo/bar", onItem:callback});</code></pre>   <h3>Example 5</h3><p>Fetch the first 100 books by author King, call showKing when up to 100 items have been located. </p> <pre data-language="javascript"><code>var request = store.fetch({query:{author:"King"}, start: 0, count:100, onComplete: showKing});</code></pre>   <h3>Example 6</h3><p>Locate the books written by Author King, sort it on title and publisher, then return the first 100 items from the sorted items. </p> <pre data-language="javascript"><code>var request = store.fetch({query:{author:"King"}, sort: [{ attribute: "title", descending: true}, {attribute: "publisher"}], ,start: 0, count:100, onComplete: 'showKing'});</code></pre>   <h3>Example 7</h3><p>Fetch the first 100 books by authors starting with the name King, then call showKing when up to 100 items have been located. </p> <pre data-language="javascript"><code>var request = store.fetch({query:{author:"King*"}, start: 0, count:100, onComplete: showKing});</code></pre>   <h3>Example 8</h3><p>Fetch the first 100 books by authors ending with 'ing', but only have one character before it (King, Bing, Ling, Sing, etc.), then call showBooks when up to 100 items have been located. </p> <pre data-language="javascript"><code>var request = store.fetch({query:{author:"?ing"}, start: 0, count:100, onComplete: showBooks});</code></pre>   <h3>Example 9</h3><p>Fetch the first 100 books by author King, where the name may appear as King, king, KING, kInG, and so on, then call showKing when up to 100 items have been located. </p> <pre data-language="javascript"><code>var request = store.fetch({query:{author:"King"}, queryOptions:(ignoreCase: true}, start: 0, count:100, onComplete: showKing});</code></pre>   <h3>Example 10</h3><p>Paging </p> <pre data-language="javascript"><code>var store = new LargeRdbmsStore({url:"jdbc:odbc:foobar"});
var fetchArgs = {
    query: {type:"employees", name:"Hillary *"}, // string matching
    sort: [{attribute:"department", descending:true}],
    start: 0,
    count: 20,
    scope: displayer,
    onBegin: showThrobber,
    onItem: displayItem,
    onComplete: stopThrobber,
    onError: handleFetchError,
};
store.fetch(fetchArgs);
...</code></pre> <p>and then when the user presses the "Next Page" button... </p> <pre data-language="javascript"><code>fetchArgs.start += 20;
store.fetch(fetchArgs);  // get the next 20 items</code></pre>       <h3 id="1_10dojo_data_api_Write_getAttributes">
<code class="functionIcon">getAttributes</code><code class="parameters">(item)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>Returns an array with all the attributes that this item has. This method will always return an array; if the item has no attributes at all, getAttributes() will return an empty array: [].</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td><a href="item.html">dojo/data/api/Item</a></td> <td>
<p>The item to access attributes on.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var array = store.getAttributes(kermit);</code></pre>       <h3 id="1_10dojo_data_api_Write_getFeatures">
<code class="functionIcon">getFeatures</code><code class="parameters">()</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="write.html">dojo/data/api/Write</a> </p> <p>See dojo/data/api/Read.getFeatures()</p>  <p class="returnsInfo"><strong>Returns: </strong>object</p>     <h3 id="1_10dojo_data_api_Write_getLabel">
<code class="functionIcon">getLabel</code><code class="parameters">(item)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>Method to inspect the item and return a user-readable 'label' for the item that provides a general/adequate description of what the item is.</p>  <p>Method to inspect the item and return a user-readable 'label' for the item that provides a general/adequate description of what the item is. In general most labels will be a specific attribute value or collection of the attribute values that combine to label the item in some manner. For example for an item that represents a person it may return the label as: "firstname lastlame" where the firstname and lastname are attributes on the item. If the store is unable to determine an adequate human readable label, it should return undefined. Users that wish to customize how a store instance labels items should replace the getLabel() function on their instance of the store, or extend the store and replace the function in the extension class.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td><a href="item.html">dojo/data/api/Item</a></td> <td>
<p>The item to return the label for.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>A user-readable string representing the item or undefined if no user-readable label can be generated.</p>      <h3 id="1_10dojo_data_api_Write_getLabelAttributes">
<code class="functionIcon">getLabelAttributes</code><code class="parameters">(item)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>Method to inspect the item and return an array of what attributes of the item were used to generate its label, if any.</p>  <p>Method to inspect the item and return an array of what attributes of the item were used to generate its label, if any. This function is to assist UI developers in knowing what attributes can be ignored out of the attributes an item has when displaying it, in cases where the UI is using the label as an overall identifer should they wish to hide redundant information.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td><a href="item.html">dojo/data/api/Item</a></td> <td>
<p>The item to return the list of label attributes for.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>An array of attribute names that were used to generate the label, or null if public attributes were not used to generate the label.</p>      <h3 id="1_10dojo_data_api_Write_getValue">
<code class="functionIcon">getValue</code><code class="parameters">(item,attribute,defaultValue)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>Returns a single attribute value. Returns defaultValue if and only if <em>item</em> does not have a value for <em>attribute</em>. Returns null if and only if null was explicitly set as the attribute value. Returns undefined if and only if the item does not have a value for the given attribute (which is the same as saying the item does not have the attribute).</p>  <p>Saying that an "item x does not have a value for an attribute y" is identical to saying that an "item x does not have attribute y". It is an oxymoron to say "that attribute is present but has no values" or "the item has that attribute but does not have any attribute values". If store.hasAttribute(item, attribute) returns false, then store.getValue(item, attribute) will return undefined.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td><a href="item.html">dojo/data/api/Item</a></td> <td>
<p>The item to access values on.</p> </td> </tr> <tr> <td>attribute</td> <td>attribute-name-string</td> <td>
<p>The attribute to access represented as a string.</p> </td> </tr> <tr> <td>defaultValue</td> <td>value</td> <td> <div><em>Optional</em></div>
<p>Optional. A default value to use for the getValue return in the attribute does not exist or has no value.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>a literal, an item, null, or undefined (never an array)</p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var darthVader = store.getValue(lukeSkywalker, "father");</code></pre>       <h3 id="1_10dojo_data_api_Write_getValues">
<code class="functionIcon">getValues</code><code class="parameters">(item,attribute)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>This getValues() method works just like the getValue() method, but getValues() always returns an array rather than a single attribute value. The array may be empty, may contain a single attribute value, or may contain many attribute values. If the item does not have a value for the given attribute, then getValues() will return an empty array: []. (So, if store.hasAttribute(item, attribute) has a return of false, then store.getValues(item, attribute) will return [].)</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td><a href="item.html">dojo/data/api/Item</a></td> <td>
<p>The item to access values on.</p> </td> </tr> <tr> <td>attribute</td> <td>attribute-name-string</td> <td>
<p>The attribute to access represented as a string.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>an array that may contain literals and items</p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var friendsOfLuke = store.getValues(lukeSkywalker, "friends");</code></pre>       <h3 id="1_10dojo_data_api_Write_hasAttribute">
<code class="functionIcon">hasAttribute</code><code class="parameters">(item,attribute)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>Returns true if the given <em>item</em> has a value for the given <em>attribute</em>.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td><a href="item.html">dojo/data/api/Item</a></td> <td>
<p>The item to access attributes on.</p> </td> </tr> <tr> <td>attribute</td> <td>attribute-name-string</td> <td>
<p>The attribute to access represented as a string.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var trueOrFalse = store.hasAttribute(kermit, "color");</code></pre>       <h3 id="1_10dojo_data_api_Write_isDirty">
<code class="functionIcon">isDirty</code><code class="parameters">(item)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="write.html">dojo/data/api/Write</a> </p> <p>Given an item, isDirty() returns true if the item has been modified since the last save(). If isDirty() is called with no <em>item</em> argument, then this function returns true if any item has been modified since the last save().</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td>item</td> <td> <div><em>Optional</em></div>
<p>The item to check.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var trueOrFalse = store.isDirty(kermit); // true if kermit is dirty
var trueOrFalse = store.isDirty();       // true if any item is dirty</code></pre>       <h3 id="1_10dojo_data_api_Write_isItem">
<code class="functionIcon">isItem</code><code class="parameters">(something)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>Returns true if <em>something</em> is an item and came from the store instance. Returns false if <em>something</em> is a literal, an item from another store instance, or is any object other than an item.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>something</td> <td>anything</td> <td>
<p>Can be anything.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var yes = store.isItem(store.newItem());
var no  = store.isItem("green");</code></pre>       <h3 id="1_10dojo_data_api_Write_isItemLoaded">
<code class="functionIcon">isItemLoaded</code><code class="parameters">(something)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>Returns false if isItem(something) is false. Returns false if if isItem(something) is true but the the item is not yet loaded in local memory (for example, if the item has not yet been read from the server).</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>something</td> <td>anything</td> <td>
<p>Can be anything.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var yes = store.isItemLoaded(store.newItem());
var no  = store.isItemLoaded("green");</code></pre>       <h3 id="1_10dojo_data_api_Write_loadItem">
<code class="functionIcon">loadItem</code><code class="parameters">(keywordArgs)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="read.html">dojo/data/api/Read</a> </p> <p>Given an item, this method loads the item so that a subsequent call to store.isItemLoaded(item) will return true. If a call to isItemLoaded() returns true before loadItem() is even called, then loadItem() need not do any work at all and will not even invoke the callback handlers. So, before invoking this method, check that the item has not already been loaded.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>keywordArgs</td> <td>Object</td> <td>
<p>An anonymous object that defines the item to load and callbacks to invoke when the load has completed. The format of the object is as follows: </p> <pre data-language="javascript"><code>{
    item: object,
    onItem: Function,
    onError: Function,
    scope: object
}</code></pre> <h4>The <em>item</em> parameter</h4> <p>The item parameter is an object that represents the item in question that should be contained by the store. This attribute is required. </p> <h4>The <em>onItem</em> parameter</h4> <p>Function(item) The onItem parameter is the callback to invoke when the item has been loaded. It takes only one parameter, the fully loaded item. </p> <h4>The <em>onError</em> parameter</h4> <p>Function(error) The onError parameter is the callback to invoke when the item load encountered an error. It takes only one parameter, the error object </p> <h4>The <em>scope</em> parameter</h4> <p>If a scope object is provided, all of the callback functions (onItem, onError, etc) will be invoked in the context of the scope object. In the body of the callback function, the value of the "this" keyword will be the scope object. If no scope object is provided, the callback functions will be called in the context of dojo.global(). For example, onItem.call(scope, item, request) vs. onItem.call(dojo.global(), item, request)</p> </td> </tr> </table>     <h3 id="1_10dojo_data_api_Write_newItem">
<code class="functionIcon">newItem</code><code class="parameters">(keywordArgs,parentInfo)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="write.html">dojo/data/api/Write</a> </p> <p>Returns a newly created item. Sets the attributes of the new item based on the <em>keywordArgs</em> provided. In general, the attribute names in the keywords become the attributes in the new item and as for the attribute values in keywordArgs, they become the values of the attributes in the new item. In addition, for stores that support hierarchical item creation, an optional second parameter is accepted that defines what item is the parent of the new item and what attribute of that item should the new item be assigned to. In general, this will assume that the attribute targeted is multi-valued and a new item is appended onto the list of values for that attribute.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>keywordArgs</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>A javascript object defining the initial content of the item as a set of JavaScript 'property name: value' pairs.</p> </td> </tr> <tr> <td>parentInfo</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>An optional javascript object defining what item is the parent of this item (in a hierarchical store. Not all stores do hierarchical items), and what attribute of that parent to assign the new item to. If this is present, and the attribute specified is a multi-valued attribute, it will append this item into the array of values for that attribute. The structure of the object is as follows: </p> <pre data-language="javascript"><code>{
    parent: someItem,
    attribute: "attribute-name-string"
}</code></pre> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var kermit = store.newItem({name: "Kermit", color:[blue, green]});</code></pre>       <h3 id="1_10dojo_data_api_Write_revert">
<code class="functionIcon">revert</code><code class="parameters">()</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="write.html">dojo/data/api/Write</a> </p> <p>Discards any unsaved changes.</p>  <p>Discards any unsaved changes.</p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var success = store.revert();</code></pre>       <h3 id="1_10dojo_data_api_Write_save">
<code class="functionIcon">save</code><code class="parameters">(keywordArgs)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="write.html">dojo/data/api/Write</a> </p> <p>Saves to the server all the changes that have been made locally. The save operation may take some time and is generally performed in an asynchronous fashion. The outcome of the save action is is passed into the set of supported callbacks for the save.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>keywordArgs</td> <td>object</td> <td>
<pre data-language="javascript"><code>{
    onComplete: function
    onError: function
    scope: object
}

 ####The *onComplete* parameter.

 function();

 If an onComplete callback function is provided, the callback function
 will be called just once, after the save has completed.  No parameters
 are generally passed to the onComplete.

 ####The *onError* parameter.

 function(errorData);

 If an onError callback function is provided, the callback function
 will be called if there is any sort of error while attempting to
 execute the save.  The onError function will be based one parameter, the
 error.

 ####The *scope* parameter.

 If a scope object is provided, all of the callback function (
 onComplete, onError, etc) will be invoked in the context of the scope
 object.  In the body of the callback function, the value of the "this"
 keyword will be the scope object.   If no scope object is provided,
 the callback functions will be called in the context of dojo.global.
 For example, onComplete.call(scope) vs.
 onComplete.call(dojo.global)</code></pre> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>Nothing. Since the saves are generally asynchronous, there is no need to return anything. All results are passed via callbacks.</p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>store.save({onComplete: onSave});
store.save({scope: fooObj, onComplete: onSave, onError: saveFailed});</code></pre>       <h3 id="1_10dojo_data_api_Write_setValue">
<code class="functionIcon">setValue</code><code class="parameters">(item,attribute,value)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="write.html">dojo/data/api/Write</a> </p> <p>Sets the value of an attribute on an item. Replaces any previous value or values.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td><a href="item.html">dojo/data/api/Item</a></td> <td>
<p>The item to modify.</p> </td> </tr> <tr> <td>attribute</td> <td>string</td> <td>
<p>The attribute of the item to change represented as a string name.</p> </td> </tr> <tr> <td>value</td> <td>almost anything</td> <td>
<p>The value to assign to the item.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var success = store.set(kermit, "color", "green");</code></pre>       <h3 id="1_10dojo_data_api_Write_setValues">
<code class="functionIcon">setValues</code><code class="parameters">(item,attribute,values)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="write.html">dojo/data/api/Write</a> </p> <p>Adds each value in the <em>values</em> array as a value of the given attribute on the given item. Replaces any previous value or values. Calling store.setValues(x, y, []) (with <em>values</em> as an empty array) has the same effect as calling store.unsetAttribute(x, y).</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td><a href="item.html">dojo/data/api/Item</a></td> <td>
<p>The item to modify.</p> </td> </tr> <tr> <td>attribute</td> <td>string</td> <td>
<p>The attribute of the item to change represented as a string name.</p> </td> </tr> <tr> <td>values</td> <td>array</td> <td>
<p>An array of values to assign to the attribute..</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var success = store.setValues(kermit, "color", ["green", "aqua"]);
success = store.setValues(kermit, "color", []);
if (success){assert(!store.hasAttribute(kermit, "color"));}</code></pre>       <h3 id="1_10dojo_data_api_Write_unsetAttribute">
<code class="functionIcon">unsetAttribute</code><code class="parameters">(item,attribute)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="write.html">dojo/data/api/Write</a> </p> <p>Deletes all the values of an attribute on an item.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>item</td> <td><a href="item.html">dojo/data/api/Item</a></td> <td>
<p>The item to modify.</p> </td> </tr> <tr> <td>attribute</td> <td>string</td> <td>
<p>The attribute of the item to unset represented as a string.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var success = store.unsetAttribute(kermit, "color");
if (success){assert(!store.hasAttribute(kermit, "color"));}</code></pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2017 JS Foundation<br>Licensed under the AFL 2.1 and BSD 3-Clause licenses.<br>
    <a href="http://dojotoolkit.org/api/1.10/dojo/data/api/Write.html" class="_attribution-link">http://dojotoolkit.org/api/1.10/dojo/data/api/Write.html</a>
  </p>
</div>
