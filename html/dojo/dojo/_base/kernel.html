<h1>dojo/_base/kernel</h1>  <h2 id="summary">Summary</h2> <p>This module is the foundational module of the dojo boot sequence; it defines the dojo object.</p>  <p>See the <a href="http://dojotoolkit.org/reference-guide/1.10/dojo/_base/kernel.html" target="_blank">dojo/_base/kernel reference documentation</a> for more information.</p>            <h2 id="properties">Properties</h2>              <h3 id="1_10dojo__base_kernel_back">back </h3> <p class="jsdoc-inheritance">Defined by: <a href="../back.html">dojo/back</a> </p> <div class="jsdoc-summary">
<p>Browser history management resources</p> </div>     <h3 id="1_10dojo__base_kernel_baseUrl">baseUrl </h3> <p class="jsdoc-inheritance">Defined by: <a href="configspidermonkey.html">dojo/_base/configSpidermonkey</a> </p>     <h3 id="1_10dojo__base_kernel_behavior">behavior </h3> <p class="jsdoc-inheritance">Defined by: <a href="../behavior.html">dojo/behavior</a> </p>     <h3 id="1_10dojo__base_kernel_cldr">cldr </h3> <p class="jsdoc-inheritance">Defined by: <a href="../cldr/monetary.html">dojo/cldr/monetary</a> </p>     <h3 id="1_10dojo__base_kernel_colors">colors </h3> <p class="jsdoc-inheritance">Defined by: <a href="../colors.html">dojo/colors</a> </p>     <h3 id="1_10dojo__base_kernel_config">config </h3> <p class="jsdoc-inheritance">Defined by: <a href="kernel.html">dojo/_base/kernel</a> </p> <div class="jsdoc-summary">
<p>This module defines the user configuration during bootstrap.</p> </div>     <h3 id="1_10dojo__base_kernel_connectPublisher">connectPublisher </h3> <p class="jsdoc-inheritance">Defined by: <a href="../robotx.html">dojo/robotx</a> </p>     <h3 id="1_10dojo__base_kernel_contentHandlers">contentHandlers </h3> <p class="jsdoc-inheritance">Defined by: <a href="xhr.html">dojo/_base/xhr</a> </p> <div class="jsdoc-summary">
<p>A map of available XHR transport handle types. Name matches the <code>handleAs</code> attribute passed to XHR calls.</p> </div>     <h3 id="1_10dojo__base_kernel_currency">currency </h3> <p class="jsdoc-inheritance">Defined by: <a href="../currency.html">dojo/currency</a> </p> <div class="jsdoc-summary">
<p>localized formatting and parsing routines for currencies</p> </div>     <h3 id="1_10dojo__base_kernel_data">data </h3> <p class="jsdoc-inheritance">Defined by: <a href="../data/util/filter.html">dojo/data/util/filter</a> </p>     <h3 id="1_10dojo__base_kernel_date">date </h3> <p class="jsdoc-inheritance">Defined by: <a href="../date/stamp.html">dojo/date/stamp</a> </p>     <h3 id="1_10dojo__base_kernel_dijit">dijit </h3> <p class="jsdoc-inheritance">Defined by: <a href="kernel.html">dojo/_base/kernel</a> </p>     <h3 id="1_10dojo__base_kernel_dnd">dnd </h3> <p class="jsdoc-inheritance">Defined by: <a href="../dnd/common.html">dojo/dnd/common</a> </p>     <h3 id="1_10dojo__base_kernel_doc">doc </h3> <p class="jsdoc-inheritance">Defined by: <a href="window.html">dojo/_base/window</a> </p> <div class="jsdoc-summary">
<p>Alias for the current document. 'doc' can be modified for temporary context shifting. See also withDoc().</p> </div>     <h3 id="1_10dojo__base_kernel_dojox">dojox </h3> <p class="jsdoc-inheritance">Defined by: <a href="kernel.html">dojo/_base/kernel</a> </p>     <h3 id="1_10dojo__base_kernel_fx">fx </h3> <p class="jsdoc-inheritance">Defined by: <a href="../fx.html">dojo/fx</a> </p> <div class="jsdoc-summary">
<p>Effects library on top of Base animations</p> </div>     <h3 id="1_10dojo__base_kernel_gears">gears </h3> <p class="jsdoc-inheritance">Defined by: <a href="../gears.html">dojo/gears</a> </p> <div class="jsdoc-summary">
<p>TODOC</p> </div>     <h3 id="1_10dojo__base_kernel_global">global </h3> <p class="jsdoc-inheritance">Defined by: <a href="window.html">dojo/_base/window</a> </p> <div class="jsdoc-summary">
<p>Alias for the current window. 'global' can be modified for temporary context shifting. See also withGlobal().</p> </div>     <h3 id="1_10dojo__base_kernel_html">html </h3> <p class="jsdoc-inheritance">Defined by: <a href="../html.html">dojo/html</a> </p> <div class="jsdoc-summary">
<p>TODOC</p> </div>     <h3 id="1_10dojo__base_kernel_i18n">i18n </h3> <p class="jsdoc-inheritance">Defined by: <a href="../i18n.html">dojo/i18n</a> </p> <div class="jsdoc-summary">
<p>This module implements the <a href="../i18n.html">dojo/i18n</a>! plugin and the v1.6- i18n API</p> </div>     <h3 id="1_10dojo__base_kernel_io">io </h3> <p class="jsdoc-inheritance">Defined by: <a href="../io/iframe.html">dojo/io/iframe</a> </p>     <h3 id="1_10dojo__base_kernel_isAir">isAir </h3> <p class="jsdoc-inheritance">Defined by: <a href="sniff.html">dojo/_base/sniff</a> </p> <div class="jsdoc-summary">
<p>True if client is Adobe Air</p> </div>     <h3 id="1_10dojo__base_kernel_isAndroid">isAndroid </h3> <p class="jsdoc-inheritance">Defined by: <a href="sniff.html">dojo/_base/sniff</a> </p> <div class="jsdoc-summary">
<p>Version as a Number if client is android browser. undefined otherwise.</p> </div>     <h3 id="1_10dojo__base_kernel_isAsync">isAsync </h3> <p class="jsdoc-inheritance">Defined by: <a href="kernel.html">dojo/_base/kernel</a> </p>     <h3 id="1_10dojo__base_kernel_isBrowser">isBrowser </h3> <p class="jsdoc-inheritance">Defined by: <a href="configfirefoxextension.html">dojo/_base/configFirefoxExtension</a> </p>     <h3 id="1_10dojo__base_kernel_isChrome">isChrome </h3> <p class="jsdoc-inheritance">Defined by: <a href="sniff.html">dojo/_base/sniff</a> </p> <div class="jsdoc-summary">
<p>Version as a Number if client is Chrome browser. undefined otherwise.</p> </div>     <h3 id="1_10dojo__base_kernel_isCopyKey">isCopyKey </h3> <p class="jsdoc-inheritance">Defined by: <a href="http://dojotoolkit.org/api/1.10/dojox/grid/_Grid">dojox/grid/_Grid</a> </p>     <h3 id="1_10dojo__base_kernel_isFF">isFF </h3> <p class="jsdoc-inheritance">Defined by: <a href="configfirefoxextension.html">dojo/_base/configFirefoxExtension</a> </p>     <h3 id="1_10dojo__base_kernel_isIE">isIE </h3> <p class="jsdoc-inheritance">Defined by: <a href="sniff.html">dojo/_base/sniff</a> </p> <div class="jsdoc-summary">
<p>Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to major detected IE version (6, 7, 8, etc.)</p> </div>     <h3 id="1_10dojo__base_kernel_isIos">isIos </h3> <p class="jsdoc-inheritance">Defined by: <a href="sniff.html">dojo/_base/sniff</a> </p> <div class="jsdoc-summary">
<p>Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.</p> </div>     <h3 id="1_10dojo__base_kernel_isKhtml">isKhtml </h3> <p class="jsdoc-inheritance">Defined by: <a href="sniff.html">dojo/_base/sniff</a> </p> <div class="jsdoc-summary">
<p>Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major detected version.</p> </div>     <h3 id="1_10dojo__base_kernel_isMac">isMac </h3> <p class="jsdoc-inheritance">Defined by: <a href="sniff.html">dojo/_base/sniff</a> </p> <div class="jsdoc-summary">
<p>True if the client runs on Mac</p> </div>     <h3 id="1_10dojo__base_kernel_isMoz">isMoz </h3> <p class="jsdoc-inheritance">Defined by: <a href="configfirefoxextension.html">dojo/_base/configFirefoxExtension</a> </p>     <h3 id="1_10dojo__base_kernel_isMozilla">isMozilla </h3> <p class="jsdoc-inheritance">Defined by: <a href="configfirefoxextension.html">dojo/_base/configFirefoxExtension</a> </p>     <h3 id="1_10dojo__base_kernel_isOpera">isOpera </h3> <p class="jsdoc-inheritance">Defined by: <a href="sniff.html">dojo/_base/sniff</a> </p> <div class="jsdoc-summary">
<p>Version as a Number if client is Opera. undefined otherwise. Corresponds to major detected version.</p> </div>     <h3 id="1_10dojo__base_kernel_isQuirks">isQuirks </h3> <p class="jsdoc-inheritance">Defined by: <a href="configfirefoxextension.html">dojo/_base/configFirefoxExtension</a> </p>     <h3 id="1_10dojo__base_kernel_isSafari">isSafari </h3> <p class="jsdoc-inheritance">Defined by: <a href="sniff.html">dojo/_base/sniff</a> </p> <div class="jsdoc-summary">
<p>Version as a Number if client is Safari or iPhone. undefined otherwise.</p> </div>     <h3 id="1_10dojo__base_kernel_isSpidermonkey">isSpidermonkey </h3> <p class="jsdoc-inheritance">Defined by: <a href="configspidermonkey.html">dojo/_base/configSpidermonkey</a> </p>     <h3 id="1_10dojo__base_kernel_isWebKit">isWebKit </h3> <p class="jsdoc-inheritance">Defined by: <a href="sniff.html">dojo/_base/sniff</a> </p> <div class="jsdoc-summary">
<p>Version as a Number if client is a WebKit-derived browser (Konqueror, Safari, Chrome, etc.). undefined otherwise.</p> </div>     <h3 id="1_10dojo__base_kernel_isWii">isWii </h3> <p class="jsdoc-inheritance">Defined by: <a href="sniff.html">dojo/_base/sniff</a> </p> <div class="jsdoc-summary">
<p>True if client is Wii</p> </div>     <h3 id="1_10dojo__base_kernel_keys">keys </h3> <p class="jsdoc-inheritance">Defined by: <a href="../keys.html">dojo/keys</a> </p> <div class="jsdoc-summary">
<p>Definitions for common key values. Client code should test keyCode against these named constants, as the actual codes can vary by browser.</p> </div>     <h3 id="1_10dojo__base_kernel_locale">locale </h3> <p class="jsdoc-inheritance">Defined by: <a href="configfirefoxextension.html">dojo/_base/configFirefoxExtension</a> </p>     <h3 id="1_10dojo__base_kernel_mouseButtons">mouseButtons </h3> <p class="jsdoc-inheritance">Defined by: <a href="../mouse.html">dojo/mouse</a> </p>     <h3 id="1_10dojo__base_kernel_number">number </h3> <p class="jsdoc-inheritance">Defined by: <a href="../number.html">dojo/number</a> </p> <div class="jsdoc-summary">
<p>localized formatting and parsing routines for Number</p> </div>     <h3 id="1_10dojo__base_kernel_parser">parser </h3> <p class="jsdoc-inheritance">Defined by: <a href="http://dojotoolkit.org/api/1.10/dojox/mobile/parser">dojox/mobile/parser</a> </p>     <h3 id="1_10dojo__base_kernel_publish">publish </h3> <p class="jsdoc-inheritance">Defined by: <a href="../robotx.html">dojo/robotx</a> </p>     <h3 id="1_10dojo__base_kernel_query">query </h3> <p class="jsdoc-inheritance">Defined by: <a href="../query.html">dojo/query</a> </p>     <h3 id="1_10dojo__base_kernel_regexp">regexp </h3> <p class="jsdoc-inheritance">Defined by: <a href="../regexp.html">dojo/regexp</a> </p> <div class="jsdoc-summary">
<p>Regular expressions and Builder resources</p> </div>     <h3 id="1_10dojo__base_kernel_rpc">rpc </h3> <p class="jsdoc-inheritance">Defined by: <a href="../rpc/rpcservice.html">dojo/rpc/RpcService</a> </p>     <h3 id="1_10dojo__base_kernel_scopeMap">scopeMap </h3> <p class="jsdoc-inheritance">Defined by: <a href="kernel.html">dojo/_base/kernel</a> </p>     <h3 id="1_10dojo__base_kernel_store">store </h3> <p class="jsdoc-inheritance">Defined by: <a href="../store/cache.html">dojo/store/Cache</a> </p>     <h3 id="1_10dojo__base_kernel_string">string </h3> <p class="jsdoc-inheritance">Defined by: <a href="../string.html">dojo/string</a> </p> <div class="jsdoc-summary">
<p>String utilities for Dojo</p> </div>     <h3 id="1_10dojo__base_kernel_subscribe">subscribe </h3> <p class="jsdoc-inheritance">Defined by: <a href="../robotx.html">dojo/robotx</a> </p>     <h3 id="1_10dojo__base_kernel_tests">tests </h3> <p class="jsdoc-inheritance">Defined by: <a href="../tests.html">dojo/tests</a> </p> <div class="jsdoc-summary">
<p>D.O.H. Test files for Dojo unit testing.</p> </div>     <h3 id="1_10dojo__base_kernel_toJsonIndentStr">toJsonIndentStr </h3> <p class="jsdoc-inheritance">Defined by: <a href="json.html">dojo/_base/json</a> </p>     <h3 id="1_10dojo__base_kernel_touch">touch </h3> <p class="jsdoc-inheritance">Defined by: <a href="../touch.html">dojo/touch</a> </p> <div class="jsdoc-summary">
<p>This module provides unified touch event handlers by exporting press, move, release and cancel which can also run well on desktop. Based on <a href="http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html">http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html</a> Also, if the dojoClick property is set to truthy on a DOM node, <a href="../touch.html">dojo/touch</a> generates click events immediately for this node and its descendants (except for descendants that have a dojoClick property set to falsy), to avoid the delay before native browser click events, and regardless of whether evt.preventDefault() was called in a touch.press event listener. </p> </div>     <h3 id="1_10dojo__base_kernel_version">version </h3> <p class="jsdoc-inheritance">Defined by: <a href="kernel.html">dojo/_base/kernel</a> </p> <div class="jsdoc-summary">
<p>Version number of the Dojo Toolkit</p> </div>     <h3 id="1_10dojo__base_kernel_window">window </h3> <p class="jsdoc-inheritance">Defined by: <a href="../window.html">dojo/window</a> </p> <div class="jsdoc-summary">
<p>TODOC</p> </div>    <h2 id="methods">Methods</h2>                                              <h3 id="1_10dojo__base_kernel_AdapterRegistry">
<code class="functionIcon">AdapterRegistry</code><code class="parameters">(returnWrappers)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../adapterregistry.html">dojo/AdapterRegistry</a> </p> <p>A registry to make contextual calling/searching easier.</p>  <p>Objects of this class keep list of arrays in the form [name, check, wrap, directReturn] that are used to determine what the contextual result of a set of checked arguments is. All check/wrap functions in this registry should be of the same arity.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>returnWrappers</td> <td>Boolean</td> <td> <div><em>Optional</em></div> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// create a new registry
require(["dojo/AdapterRegistry"],
function(AdapterRegistry){
    var reg = new AdapterRegistry();
    reg.register("handleString",
        function(str){
            return typeof val == "string"
        },
        function(str){
            // do something with the string here
        }
    );
    reg.register("handleArr",
        dojo.isArray,
        function(arr){
            // do something with the array here
        }
    );

    // now we can pass reg.match() *either* an array or a string and
    // the value we pass will get handled by the right function
    reg.match("someValue"); // will call the first function
    reg.match(["someValue"]); // will call the second
});</code></pre>       <h3 id="1_10dojo__base_kernel_addClass">
<code class="functionIcon">addClass</code><code class="parameters">(node,classStr)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-class.html">dojo/dom-class</a> </p> <p>Adds the specified classes to the end of the class list on the passed node. Will not re-apply duplicate classes. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>String | DOMNode</td> <td>
<p>String ID or DomNode reference to add a class string too </p> </td> </tr> <tr> <td>classStr</td> <td>String | Array</td> <td>
<p>A String class name to add, or several space-separated class names, or an array of class names. </p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><p>Add a class to some node: </p> <pre data-language="javascript"><code>require(["dojo/dom-class"], function(domClass){
    domClass.add("someNode", "anewClass");
});</code></pre>   <h3>Example 2</h3><p>Add two classes at once: </p> <pre data-language="javascript"><code>require(["dojo/dom-class"], function(domClass){
    domClass.add("someNode", "firstClass secondClass");
});</code></pre>   <h3>Example 3</h3><p>Add two classes at once (using array): </p> <pre data-language="javascript"><code>require(["dojo/dom-class"], function(domClass){
    domClass.add("someNode", ["firstClass", "secondClass"]);
});</code></pre>   <h3>Example 4</h3><p>Available in <code>dojo/NodeList</code> for multiple additions </p> <pre data-language="javascript"><code>require(["dojo/query"], function(query){
    query("ul &gt; li").addClass("firstLevel");
});</code></pre>       <h3 id="1_10dojo__base_kernel_addOnLoad">
<code class="functionIcon">addOnLoad</code><code class="parameters">(priority,context,callback)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../ready.html">dojo/ready</a> </p> <p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated. In most cases, the <code>domReady</code> plug-in should suffice and this method should not be needed. </p> <p>When called in a non-browser environment, just checks that all requested modules have arrived and been evaluated.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>priority</td> <td>Integer</td> <td> <div><em>Optional</em></div>
<p>The order in which to exec this callback relative to other callbacks, defaults to 1000</p> </td> </tr> <tr> <td>context</td> <td>undefined</td> <td>
<p>The context in which to run execute callback, or a callback if not using context</p> </td> </tr> <tr> <td>callback</td> <td>Function</td> <td> <div><em>Optional</em></div>
<p>The function to execute. </p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><p>Simple DOM and Modules ready syntax </p> <pre data-language="javascript"><code>require(["dojo/ready"], function(ready){
    ready(function(){ alert("Dom ready!"); });
});</code></pre>   <h3>Example 2</h3><p>Using a priority </p> <pre data-language="javascript"><code>require(["dojo/ready"], function(ready){
    ready(2, function(){ alert("low priority ready!"); })
});</code></pre>   <h3>Example 3</h3><p>Using context </p> <pre data-language="javascript"><code>require(["dojo/ready"], function(ready){
    ready(foo, function(){
        // in here, this == foo
    });
});</code></pre>   <h3>Example 4</h3><p>Using dojo/hitch style args: </p> <pre data-language="javascript"><code>require(["dojo/ready"], function(ready){
    var foo = { dojoReady: function(){ console.warn(this, "dojo dom and modules ready."); } };
    ready(foo, "dojoReady");
});</code></pre>       <h3 id="1_10dojo__base_kernel_addOnUnload">
<code class="functionIcon">addOnUnload</code><code class="parameters">(obj,functionName)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="unload.html">dojo/_base/unload</a> </p> <p>Registers a function to be triggered when the page unloads. Deprecated, use on(window, "beforeunload", lang.hitch(obj, functionName)) instead.</p>  <p>The first time that addOnUnload is called Dojo will register a page listener to trigger your unload handler with. </p> <p>In a browser environment, the functions will be triggered during the window.onbeforeunload event. Be careful of doing too much work in an unload handler. onbeforeunload can be triggered if a link to download a file is clicked, or if the link is a javascript: link. In these cases, the onbeforeunload event fires, but the document is not actually destroyed. So be careful about doing destructive operations in a dojo.addOnUnload callback. </p> <p>Further note that calling dojo.addOnUnload will prevent browsers from using a "fast back" cache to make page loading via back button instantaneous.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>obj</td> <td>Object? | Function</td> <td> <div><em>Optional</em></div> </td> </tr> <tr> <td>functionName</td> <td>String | Function</td> <td> <div><em>Optional</em></div> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var afunc = function() {console.log("global function");};
require(["dojo/_base/unload"], function(unload) {
    var foo = {bar: function(){ console.log("bar unloading...");}, 
               data: "mydata"};
    unload.addOnUnload(afunc);
    unload.addOnUnload(foo, "bar");
    unload.addOnUnload(foo, function(){console.log("", this.data);});
});</code></pre>       <h3 id="1_10dojo__base_kernel_addOnWindowUnload">
<code class="functionIcon">addOnWindowUnload</code><code class="parameters">(obj,functionName)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="configfirefoxextension.html">dojo/_base/configFirefoxExtension</a> </p> <p>registers a function to be triggered when window.onunload fires. Be careful trying to modify the DOM or access JavaScript properties during this phase of page unloading: they may not always be available. Consider dojo.addOnUnload() if you need to modify the DOM or do heavy JavaScript work.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>obj</td> <td>Object</td> <td> <div><em>Optional</em></div> </td> </tr> <tr> <td>functionName</td> <td>String | Function</td> <td> <div><em>Optional</em></div> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>dojo.addOnWindowUnload(functionPointer)
dojo.addOnWindowUnload(object, "functionName")
dojo.addOnWindowUnload(object, function(){ /* ... */});</code></pre>       <h3 id="1_10dojo__base_kernel_anim">
<code class="functionIcon">anim</code><code class="parameters">(node,properties,duration,easing,onEnd,delay)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="fx.html">dojo/_base/fx</a> </p> <p>A simpler interface to <code>animateProperty()</code>, also returns an instance of <code>Animation</code> but begins the animation immediately, unlike nearly every other Dojo animation API.</p>  <p>Simpler (but somewhat less powerful) version of <code>animateProperty</code>. It uses defaults for many basic properties and allows for positional parameters to be used in place of the packed "property bag" which is used for other Dojo animation methods. </p> <p>The <code>Animation</code> object returned will be already playing, so calling play() on it again is (usually) a no-op.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>a DOM node or the id of a node to animate CSS properties on</p> </td> </tr> <tr> <td>properties</td> <td>Object</td> <td> </td> </tr> <tr> <td>duration</td> <td>Integer</td> <td> <div><em>Optional</em></div>
<p>The number of milliseconds over which the animation should run. Defaults to the global animation default duration (350ms).</p> </td> </tr> <tr> <td>easing</td> <td>Function</td> <td> <div><em>Optional</em></div>
<p>An easing function over which to calculate acceleration and deceleration of the animation through its duration. A default easing algorithm is provided, but you may plug in any you wish. A large selection of easing algorithms are available in <code>dojo/fx/easing</code>.</p> </td> </tr> <tr> <td>onEnd</td> <td>Function</td> <td> <div><em>Optional</em></div>
<p>A function to be called when the animation finishes running.</p> </td> </tr> <tr> <td>delay</td> <td>Integer</td> <td> <div><em>Optional</em></div>
<p>The number of milliseconds to delay beginning the animation by. The default is 0.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>Fade out a node </p> <pre data-language="javascript"><code>basefx.anim("id", { opacity: 0 });</code></pre>   <h3>Example 2</h3><p>Fade out a node over a full second </p> <pre data-language="javascript"><code>basefx.anim("id", { opacity: 0 }, 1000);</code></pre>       <h3 id="1_10dojo__base_kernel_animateProperty">
<code class="functionIcon">animateProperty</code><code class="parameters">(args)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="fx.html">dojo/_base/fx</a> </p> <p>Returns an animation that will transition the properties of node defined in <code>args</code> depending how they are defined in <code>args.properties</code> </p>  <p>Foundation of most <a href="fx.html">dojo/_base/fx</a> animations. It takes an object of "properties" corresponding to style properties, and animates them in parallel over a set duration. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>args</td> <td>Object</td> <td>
<p>An object with the following properties:</p>
<ul>
<li>properties (Object, optional): <p>A hash map of style properties to Objects describing the transition, such as the properties of _Line with an additional 'units' property</p> </li>
<li>node (DOMNode|String): <p>The node referenced in the animation</p> </li>
<li>duration (Integer, optional): <p>Duration of the animation in milliseconds.</p> </li>
<li>easing (Function, optional): <p>An easing function.</p> </li>
</ul> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>instance</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>A simple animation that changes the width of the specified node. </p> <pre data-language="javascript"><code>basefx.animateProperty({
    node: "nodeId",
    properties: { width: 400 },
}).play();</code></pre> <p>Dojo figures out the start value for the width and converts the </p> <p>integer specified for the width to the more expressive but verbose form <code>{ width: { end: '400', units: 'px' } }</code> which you can also specify directly. Defaults to 'px' if omitted. </p>   <h3>Example 2</h3><p>Animate width, height, and padding over 2 seconds... the pedantic way: </p> <pre data-language="javascript"><code>basefx.animateProperty({ node: node, duration:2000,
    properties: {
        width: { start: '200', end: '400', units:"px" },
        height: { start:'200', end: '400', units:"px" },
        paddingTop: { start:'5', end:'50', units:"px" }
    }
}).play();</code></pre> <p>Note 'paddingTop' is used over 'padding-top'. Multi-name CSS properties </p> <p>are written using "mixed case", as the hyphen is illegal as an object key. </p>   <h3>Example 3</h3><p>Plug in a different easing function and register a callback for when the animation ends. Easing functions accept values between zero and one and return a value on that basis. In this case, an exponential-in curve. </p> <pre data-language="javascript"><code>basefx.animateProperty({
    node: "nodeId",
    // dojo figures out the start value
    properties: { width: { end: 400 } },
    easing: function(n){
        return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
    },
    onEnd: function(node){
        // called when the animation finishes. The animation
        // target is passed to this function
    }
}).play(500); // delay playing half a second</code></pre>   <h3>Example 4</h3><p>Like all <code>Animation</code>s, animateProperty returns a handle to the Animation instance, which fires the events common to Dojo FX. Use <code>aspect.after</code> to access these events outside of the Animation definition: </p> <pre data-language="javascript"><code>var anim = basefx.animateProperty({
    node:"someId",
    properties:{
        width:400, height:500
    }
});
aspect.after(anim, "onEnd", function(){
    console.log("animation ended");
}, true);
// play the animation now:
anim.play();</code></pre>   <h3>Example 5</h3><p>Each property can be a function whose return value is substituted along. Additionally, each measurement (eg: start, end) can be a function. The node reference is passed directly to callbacks. </p> <pre data-language="javascript"><code>basefx.animateProperty({
    node:"mine",
    properties:{
        height:function(node){
            // shrink this node by 50%
            return domGeom.position(node).h / 2
        },
        width:{
            start:function(node){ return 100; },
            end:function(node){ return 200; }
        }
    }
}).play();</code></pre>       <h3 id="1_10dojo__base_kernel_Animation">
<code class="functionIcon">Animation</code><code class="parameters">(args)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="fx.html">dojo/_base/fx</a> </p> <p>A generic animation class that fires callbacks into its handlers object at various states.</p>  <p>A generic animation class that fires callbacks into its handlers object at various states. Nearly all dojo animation functions return an instance of this method, usually without calling the .play() method beforehand. Therefore, you will likely need to call .play() on instances of <code>Animation</code> when one is returned.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>args</td> <td>Object</td> <td>
<p>The 'magic argument', mixing all the properties into this animation instance.</p> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_attr">
<code class="functionIcon">attr</code><code class="parameters">(node,name,value)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="html.html">dojo/_base/html</a> </p> <p>Gets or sets an attribute on an HTML element.</p>  <p>Handles normalized getting and setting of attributes on DOM Nodes. If 2 arguments are passed, and a the second argument is a string, acts as a getter. </p> <p>If a third argument is passed, or if the second argument is a map of attributes, acts as a setter. </p> <p>When passing functions as values, note that they will not be directly assigned to slots on the node, but rather the default behavior will be removed and the new behavior will be added using <code>dojo.connect()</code>, meaning that event handler properties will be normalized and that some caveats with regards to non-standard behaviors for onsubmit apply. Namely that you should cancel form submission using <code>dojo.stopEvent()</code> on the passed event object instead of returning a boolean value from the handler itself.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>id or reference to the element to get or set the attribute on</p> </td> </tr> <tr> <td>name</td> <td>String | Object</td> <td>
<p>the name of the attribute to get or set.</p> </td> </tr> <tr> <td>value</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>The value to set for the attribute</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any | undefined</p> <p>when used as a getter, the value of the requested attribute or null if that attribute does not have a specified or default value; </p> <p>when used as a setter, the DOM node </p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// get the current value of the "foo" attribute on a node
dojo.attr(dojo.byId("nodeId"), "foo");
// or we can just pass the id:
dojo.attr("nodeId", "foo");</code></pre>   <h3>Example 2</h3><pre data-language="javascript"><code>// use attr() to set the tab index
dojo.attr("nodeId", "tabIndex", 3);</code></pre>   <h3>Example 3</h3><p>Set multiple values at once, including event handlers: </p> <pre data-language="javascript"><code>dojo.attr("formId", {
    "foo": "bar",
    "tabIndex": -1,
    "method": "POST",
    "onsubmit": function(e){
        // stop submitting the form. Note that the IE behavior
        // of returning true or false will have no effect here
        // since our handler is connect()ed to the built-in
        // onsubmit behavior and so we need to use
        // dojo.stopEvent() to ensure that the submission
        // doesn't proceed.
        dojo.stopEvent(e);

        // submit the form with Ajax
        dojo.xhrPost({ form: "formId" });
    }
});</code></pre>   <h3>Example 4</h3><p>Style is s special case: Only set with an object hash of styles </p> <pre data-language="javascript"><code>dojo.attr("someNode",{
    id:"bar",
    style:{
        width:"200px", height:"100px", color:"#000"
    }
});</code></pre>   <h3>Example 5</h3><p>Again, only set style as an object hash of styles: </p> <pre data-language="javascript"><code>var obj = { color:"#fff", backgroundColor:"#000" };
dojo.attr("someNode", "style", obj);

// though shorter to use `dojo.style()` in this case:
dojo.style("someNode", obj);</code></pre>       <h3 id="1_10dojo__base_kernel_blendColors">
<code class="functionIcon">blendColors</code><code class="parameters">(start,end,weight,obj)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="color.html">dojo/_base/Color</a> </p> <p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend, can reuse a previously allocated Color object for the result</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>start</td> <td><a href="color.html">dojo/_base/Color</a></td> <td> </td> </tr> <tr> <td>end</td> <td><a href="color.html">dojo/_base/Color</a></td> <td> </td> </tr> <tr> <td>weight</td> <td>Number</td> <td> </td> </tr> <tr> <td>obj</td> <td><a href="color.html">dojo/_base/Color</a></td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_body">
<code class="functionIcon">body</code><code class="parameters">(doc)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="window.html">dojo/_base/window</a> </p> <p>Return the body element of the specified document or of dojo/_base/window::doc.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>doc</td> <td>Document</td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>win.body().appendChild(dojo.doc.createElement('div'));</code></pre>       <h3 id="1_10dojo__base_kernel_byId">
<code class="functionIcon">byId</code><code class="parameters">(id,doc)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom.html">dojo/dom</a> </p> <p>Returns DOM node with matching <code>id</code> attribute or falsy value (ex: null or undefined) if not found. If <code>id</code> is a DomNode, this function is a no-op. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>id</td> <td>String | DOMNode</td> <td>
<p>A string to match an HTML id attribute or a reference to a DOM Node </p> </td> </tr> <tr> <td>doc</td> <td>Document</td> <td> <div><em>Optional</em></div>
<p>Document to work in. Defaults to the current value of dojo/_base/window.doc. Can be used to retrieve node references from other documents. </p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>instance</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>Look up a node by ID: </p> <pre data-language="javascript"><code>require(["dojo/dom"], function(dom){
    var n = dom.byId("foo");
});</code></pre>   <h3>Example 2</h3><p>Check if a node exists, and use it. </p> <pre data-language="javascript"><code>require(["dojo/dom"], function(dom){
    var n = dom.byId("bar");
    if(n){ doStuff() ... }
});</code></pre>   <h3>Example 3</h3><p>Allow string or DomNode references to be passed to a custom function: </p> <pre data-language="javascript"><code>require(["dojo/dom"], function(dom){
    var foo = function(nodeOrId){
        nodeOrId = dom.byId(nodeOrId);
        // ... more stuff
    }
});</code></pre>       <h3 id="1_10dojo__base_kernel_cache">
<code class="functionIcon">cache</code><code class="parameters">(module,url,value)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../text.html">dojo/text</a> </p> <p>A getter and setter for storing the string content associated with the module and url arguments.</p>  <p>If module is a string that contains slashes, then it is interpretted as a fully resolved path (typically a result returned by require.toUrl), and url should not be provided. This is the preferred signature. If module is a string that does not contain slashes, then url must also be provided and module and url are used to call <code>dojo.moduleUrl()</code> to generate a module URL. This signature is deprecated. If value is specified, the cache value for the moduleUrl will be set to that value. Otherwise, dojo.cache will fetch the moduleUrl and store it in its internal cache and return that cached value for the URL. To clear a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the the URL contents, only modules on the same domain of the page can use this capability. The build system can inline the cache values though, to allow for xdomain hosting.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>module</td> <td>String | Object</td> <td>
<p>dojo/cldr/supplemental</p> </td> </tr> <tr> <td>url</td> <td>String</td> <td>
<p>The rest of the path to append to the path derived from the module argument. If module is an object, then this second argument should be the "value" argument instead.</p> </td> </tr> <tr> <td>value</td> <td>String | Object</td> <td> <div><em>Optional</em></div>
<p>If a String, the value to use in the cache for the module/url combination. If an Object, it can have two properties: value and sanitize. The value property should be the value to use in the cache, and sanitize can be set to true or false, to indicate if XML declarations should be removed from the value and if the HTML inside a body tag in the value should be extracted as the real value. The value argument or the value property on the value argument are usually only used by the build system as it inlines cache content.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined | null</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style of call is used to avoid an issue with the build system erroneously trying to intern this example. To get the build system to intern your dojo.cache calls, use the "dojo.cache" style of call): </p> <pre data-language="javascript"><code>//If template.html contains "&lt;h1&gt;Hello&lt;/h1&gt;" that will be
//the value for the text variable.
//Note: This is pre-AMD, deprecated syntax
var text = dojo["cache"]("my.module", "template.html");</code></pre>   <h3>Example 2</h3><p>To ask dojo.cache to fetch content and store it in the cache, and sanitize the input (the dojo["cache"] style of call is used to avoid an issue with the build system erroneously trying to intern this example. To get the build system to intern your dojo.cache calls, use the "dojo.cache" style of call): </p> <pre data-language="javascript"><code>//If template.html contains "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;", the
//text variable will contain just "&lt;h1&gt;Hello&lt;/h1&gt;".
//Note: This is pre-AMD, deprecated syntax
var text = dojo["cache"]("my.module", "template.html", {sanitize: true});</code></pre>   <h3>Example 3</h3><p>Same example as previous, but demonstrates how an object can be passed in as the first argument, then the value argument can then be the second argument. </p> <pre data-language="javascript"><code>//If template.html contains "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;", the
//text variable will contain just "&lt;h1&gt;Hello&lt;/h1&gt;".
//Note: This is pre-AMD, deprecated syntax
var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});</code></pre>       <h3 id="1_10dojo__base_kernel_clearCache">
<code class="functionIcon">clearCache</code><code class="parameters">()</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="array.html">dojo/_base/array</a> </p>      <h3 id="1_10dojo__base_kernel_Color">
<code class="functionIcon">Color</code><code class="parameters">(color)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="color.html">dojo/_base/Color</a> </p> <p>Takes a named string, hex string, array of rgb or rgba values, an object with r, g, b, and a properties, or another <code>Color</code> object and creates a new Color instance to work from. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>color</td> <td>Array | String | Object</td> <td> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><p>Work with a Color instance: </p> <pre data-language="javascript"><code>require(["dojo/_base/color"], function(Color){
    var c = new Color();
    c.setColor([0,0,0]); // black
    var hex = c.toHex(); // #000000
});</code></pre>   <h3>Example 2</h3><p>Work with a node's color: </p> <pre data-language="javascript"><code>  require(["dojo/_base/color", "dojo/dom-style"], function(Color, domStyle){
      var color = domStyle("someNode", "backgroundColor");
      var n = new Color(color);
      // adjust the color some
      n.r *= .5;
      console.log(n.toString()); // rgb(128, 255, 255);
  });</code></pre>       <h3 id="1_10dojo__base_kernel_colorFromArray">
<code class="functionIcon">colorFromArray</code><code class="parameters">(a,obj)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="color.html">dojo/_base/Color</a> </p> <p>Builds a <code>Color</code> from a 3 or 4 element array, mapping each element in sequence to the rgb(a) values of the color.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>a</td> <td>Array</td> <td> </td> </tr> <tr> <td>obj</td> <td><a href="color.html">dojo/_base/Color</a></td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any | undefined</p> <p>A Color object. If obj is passed, it will be the return value.</p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>require(["dojo/_base/color"], function(Color){
    var myColor = new Color().fromArray([237,237,237,0.5]); // grey, 50% alpha
});</code></pre>       <h3 id="1_10dojo__base_kernel_colorFromHex">
<code class="functionIcon">colorFromHex</code><code class="parameters">(color,obj)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="color.html">dojo/_base/Color</a> </p> <p>Converts a hex string with a '#' prefix to a color object. Supports 12-bit #rgb shorthand. Optionally accepts a <code>Color</code> object to update with the parsed value. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>color</td> <td>String</td> <td> </td> </tr> <tr> <td>obj</td> <td><a href="color.html">dojo/_base/Color</a></td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>A Color object. If obj is passed, it will be the return value. </p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>require(["dojo/_base/color"], function(Color){
    var thing = new Color().fromHex("#ededed"); // grey, longhand
    var thing2 = new Color().fromHex("#000"); // black, shorthand
});</code></pre>       <h3 id="1_10dojo__base_kernel_colorFromRgb">
<code class="functionIcon">colorFromRgb</code><code class="parameters">(color,obj)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../colors.html">dojo/colors</a> </p> <p>get rgb(a) array from css-style color declarations</p>  <p>this function can handle all 4 CSS3 Color Module formats: rgb, rgba, hsl, hsla, including rgb(a) with percentage values.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>color</td> <td>String</td> <td> </td> </tr> <tr> <td>obj</td> <td><a href="color.html">dojo/_base/Color</a></td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>null</p>     <h3 id="1_10dojo__base_kernel_colorFromString">
<code class="functionIcon">colorFromString</code><code class="parameters">(str,obj)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="color.html">dojo/_base/Color</a> </p> <p>Parses <code>str</code> for a color value. Accepts hex, rgb, and rgba style color values.</p>  <p>Acceptable input values for str may include arrays of any form accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10, 10, 50)"</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>str</td> <td>String</td> <td> </td> </tr> <tr> <td>obj</td> <td><a href="color.html">dojo/_base/Color</a></td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>A Color object. If obj is passed, it will be the return value.</p>      <h3 id="1_10dojo__base_kernel_connect">
<code class="functionIcon">connect</code><code class="parameters">(obj,event,context,method,dontFix)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="connect.html">dojo/_base/connect</a> </p> <p><code>dojo.connect</code> is a deprecated event handling and delegation method in Dojo. It allows one function to "listen in" on the execution of any other, triggering the second whenever the first is called. Many listeners may be attached to a function, and source functions may be either regular function calls or DOM events. </p>  <p>Connects listeners to actions, so that after event fires, a listener is called with the same arguments passed to the original function. </p> <p>Since <code>dojo.connect</code> allows the source of events to be either a "regular" JavaScript function or a DOM event, it provides a uniform interface for listening to all the types of events that an application is likely to deal with though a single, unified interface. DOM programmers may want to think of it as "addEventListener for everything and anything". </p> <p>When setting up a connection, the <code>event</code> parameter must be a string that is the name of the method/event to be listened for. If <code>obj</code> is null, <code>kernel.global</code> is assumed, meaning that connections to global methods are supported but also that you may inadvertently connect to a global by passing an incorrect object name or invalid reference. </p> <p><code>dojo.connect</code> generally is forgiving. If you pass the name of a function or method that does not yet exist on <code>obj</code>, connect will not fail, but will instead set up a stub method. Similarly, null arguments may simply be omitted such that fewer than 4 arguments may be required to set up a connection See the examples for details. </p> <p>The return value is a handle that is needed to remove this connection with <code>dojo.disconnect</code>. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>obj</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>The source object for the event function. Defaults to <code>kernel.global</code> if null. If obj is a DOM node, the connection is delegated to the DOM event manager (unless dontFix is true). </p> </td> </tr> <tr> <td>event</td> <td>String</td> <td>
<p>String name of the event function in obj. I.e. identifies a property <code>obj[event]</code>. </p> </td> </tr> <tr> <td>context</td> <td>Object | null</td> <td>
<p>The object that method will receive as "this". </p> <p>If context is null and method is a function, then method inherits the context of event. </p> <p>If method is a string then context must be the source object object for method (context[method]). If context is null, kernel.global is used. </p> </td> </tr> <tr> <td>method</td> <td>String | Function</td> <td>
<p>A function reference, or name of a function in context. The function identified by method fires after event does. method receives the same arguments as the event. See context argument comments for information on method's scope. </p> </td> </tr> <tr> <td>dontFix</td> <td>Boolean</td> <td> <div><em>Optional</em></div>
<p>If obj is a DOM node, set dontFix to true to prevent delegation of this connection to the DOM event manager. </p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>When obj.onchange(), do ui.update(): </p> <pre data-language="javascript"><code>dojo.connect(obj, "onchange", ui, "update");
dojo.connect(obj, "onchange", ui, ui.update); // same</code></pre>   <h3>Example 2</h3><p>Using return value for disconnect: </p> <pre data-language="javascript"><code>var link = dojo.connect(obj, "onchange", ui, "update");
...
dojo.disconnect(link);</code></pre>   <h3>Example 3</h3><p>When onglobalevent executes, watcher.handler is invoked: </p> <pre data-language="javascript"><code>dojo.connect(null, "onglobalevent", watcher, "handler");</code></pre>   <h3>Example 4</h3><p>When ob.onCustomEvent executes, customEventHandler is invoked: </p> <pre data-language="javascript"><code>dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same</code></pre>   <h3>Example 5</h3><p>When ob.onCustomEvent executes, customEventHandler is invoked with the same scope (this): </p> <pre data-language="javascript"><code>dojo.connect(ob, "onCustomEvent", null, customEventHandler);
dojo.connect(ob, "onCustomEvent", customEventHandler); // same</code></pre>   <h3>Example 6</h3><p>When globalEvent executes, globalHandler is invoked with the same scope (this): </p> <pre data-language="javascript"><code>dojo.connect(null, "globalEvent", null, globalHandler);
dojo.connect("globalEvent", globalHandler); // same</code></pre>       <h3 id="1_10dojo__base_kernel_contentBox">
<code class="functionIcon">contentBox</code><code class="parameters">(node,box)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="html.html">dojo/_base/html</a> </p> <p>Getter/setter for the content-box of node.</p>  <p>Returns an object in the expected format of box (regardless if box is passed). The object might look like: <code>{ l: 50, t: 200, w: 300: h: 150 }</code> for a node offset from its parent 50px to the left, 200px from the top with a content width of 300px and a content-height of 150px. Note that the content box may have a much larger border or margin box, depending on the box model currently in use and CSS values set/inherited for node. While the getter will return top and left values, the setter only accepts setting the width and height.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DomNode | String</td> <td>
<p>id or reference to DOM Node to get/set box for</p> </td> </tr> <tr> <td>box</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>If passed, denotes that dojo.contentBox() should update/set the content box for node. Box is an object in the above format, but only w (width) and h (height) are supported. All properties are optional if passed.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_cookie">
<code class="functionIcon">cookie</code><code class="parameters">(name,value,props)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../cookie.html">dojo/cookie</a> </p> <p>Get or set a cookie.</p>  <p>If one argument is passed, returns the value of the cookie For two or more arguments, acts as a setter.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>name</td> <td>String</td> <td>
<p>Name of the cookie</p> </td> </tr> <tr> <td>value</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>Value for the cookie</p> </td> </tr> <tr> <td>props</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>Properties for the cookie</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>set a cookie with the JSON-serialized contents of an object which will expire 5 days from now: </p> <pre data-language="javascript"><code>require(["dojo/cookie", "dojo/json"], function(cookie, json){
    cookie("configObj", json.stringify(config, {expires: 5 }));
});</code></pre>   <h3>Example 2</h3><p>de-serialize a cookie back into a JavaScript object: </p> <pre data-language="javascript"><code>require(["dojo/cookie", "dojo/json"], function(cookie, json){
    config = json.parse(cookie("configObj"));
});</code></pre>   <h3>Example 3</h3><p>delete a cookie: </p> <pre data-language="javascript"><code>require(["dojo/cookie"], function(cookie){
    cookie("configObj", null, {expires: -1});
});</code></pre>       <h3 id="1_10dojo__base_kernel_coords">
<code class="functionIcon">coords</code><code class="parameters">(node,includeScroll)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="html.html">dojo/_base/html</a> </p> <p>Deprecated: Use position() for border-box x/y/w/h or marginBox() for margin-box w/h/l/t. </p> <p>Returns an object that measures margin-box (w)idth/(h)eight and absolute position x/y of the border-box. Also returned is computed (l)eft and (t)op values in pixels from the node's offsetParent as returned from marginBox(). Return value will be in the form: </p> <pre data-language="javascript"><code>{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }</code></pre> <p>Does not act as a setter. If includeScroll is passed, the x and </p> <p>y params are affected as one would expect in dojo.position().</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DomNode | String</td> <td> </td> </tr> <tr> <td>includeScroll</td> <td>Boolean</td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_create">
<code class="functionIcon">create</code><code class="parameters">(tag,attrs,refNode,pos)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-construct.html">dojo/dom-construct</a> </p> <p>Create an element, allowing for optional attribute decoration and placement.</p>  <p>A DOM Element creation function. A shorthand method for creating a node or a fragment, and allowing for a convenient optional attribute setting step, as well as an optional DOM placement reference. </p> <p>Attributes are set by passing the optional object through <code>dojo.setAttr</code>. See <code>dojo.setAttr</code> for noted caveats and nuances, and API if applicable. </p> <p>Placement is done via <code>dojo.place</code>, assuming the new node to be the action node, passing along the optional reference node and position.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>tag</td> <td>DOMNode | String</td> <td>
<p>A string of the element to create (eg: "div", "a", "p", "li", "script", "br"), or an existing DOM node to process.</p> </td> </tr> <tr> <td>attrs</td> <td>Object</td> <td>
<p>An object-hash of attributes to set on the newly created node. Can be null, if you don't want to set any attributes/styles. See: <code>dojo.setAttr</code> for a description of available attributes.</p> </td> </tr> <tr> <td>refNode</td> <td>DOMNode | String</td> <td> <div><em>Optional</em></div>
<p>Optional reference node. Used by <code>dojo.place</code> to place the newly created node somewhere in the dom relative to refNode. Can be a DomNode reference or String ID of a node.</p> </td> </tr> <tr> <td>pos</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>Optional positional reference. Defaults to "last" by way of <code>dojo.place</code>, though can be set to "first","after","before","last", "replace" or "only" to further control the placement of the new node relative to the refNode. 'refNode' is required if a 'pos' is specified.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>Create a DIV: </p> <pre data-language="javascript"><code>require(["dojo/dom-construct"], function(domConstruct){
    var n = domConstruct.create("div");
});</code></pre>   <h3>Example 2</h3><p>Create a DIV with content: </p> <pre data-language="javascript"><code>require(["dojo/dom-construct"], function(domConstruct){
    var n = domConstruct.create("div", { innerHTML:"&lt;p&gt;hi&lt;/p&gt;" });
});</code></pre>   <h3>Example 3</h3><p>Place a new DIV in the BODY, with no attributes set </p> <pre data-language="javascript"><code>require(["dojo/dom-construct"], function(domConstruct){
    var n = domConstruct.create("div", null, dojo.body());
});</code></pre>   <h3>Example 4</h3><p>Create an UL, and populate it with LI's. Place the list as the first-child of a node with id="someId": </p> <pre data-language="javascript"><code>require(["dojo/dom-construct", "dojo/_base/array"],
function(domConstruct, arrayUtil){
    var ul = domConstruct.create("ul", null, "someId", "first");
    var items = ["one", "two", "three", "four"];
    arrayUtil.forEach(items, function(data){
        domConstruct.create("li", { innerHTML: data }, ul);
    });
});</code></pre>   <h3>Example 5</h3><p>Create an anchor, with an href. Place in BODY: </p> <pre data-language="javascript"><code>require(["dojo/dom-construct"], function(domConstruct){
    domConstruct.create("a", { href:"foo.html", title:"Goto FOO!" }, dojo.body());
});</code></pre>       <h3 id="1_10dojo__base_kernel_declare">
<code class="functionIcon">declare</code><code class="parameters">(className,superclass,props)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="declare.html">dojo/_base/declare</a> </p> <p>Create a feature-rich constructor from compact notation.</p>  <p>Create a constructor using a compact notation for inheritance and prototype extension. </p> <p>Mixin ancestors provide a type of multiple inheritance. Prototypes of mixin ancestors are copied to the new class: changes to mixin prototypes will not affect classes to which they have been mixed in. </p> <p>Ancestors can be compound classes created by this version of declare(). In complex cases all base classes are going to be linearized according to C3 MRO algorithm (see <a href="http://www.python.org/download/releases/2.3/mro/">http://www.python.org/download/releases/2.3/mro/</a> for more details). </p> <p>"className" is cached in "declaredClass" property of the new class, if it was supplied. The immediate super class will be cached in "superclass" property of the new class. </p> <p>Methods in "props" will be copied and modified: "nom" property (the declared name of the method) will be added to all copied functions to help identify them for the internal machinery. Be very careful, while reusing methods: if you use the same function under different names, it can produce errors in some cases. </p> <p>It is possible to use constructors created "manually" (without declare()) as bases. They will be called as usual during the creation of an instance, their methods will be chained, and even called by "this.inherited()". </p> <p>Special property "-chains-" governs how to chain methods. It is a dictionary, which uses method names as keys, and hint strings as values. If a hint string is "after", this method will be called after methods of its base classes. If a hint string is "before", this method will be called before methods of its base classes. </p> <p>If "constructor" is not mentioned in "-chains-" property, it will be chained using the legacy mode: using "after" chaining, calling preamble() method before each constructor, if available, and calling postscript() after all constructors were executed. If the hint is "after", it is chained as a regular method, but postscript() will be called after the chain of constructors. "constructor" cannot be chained "before", but it allows a special hint string: "manual", which means that constructors are not going to be chained in any way, and programmer will call them manually using this.inherited(). In the latter case postscript() will be called after the construction. </p> <p>All chaining hints are "inherited" from base classes and potentially can be overridden. Be very careful when overriding hints! Make sure that all chained methods can work in a proposed manner of chaining. </p> <p>Once a method was chained, it is impossible to unchain it. The only exception is "constructor". You don't need to define a method in order to supply a chaining hint. </p> <p>If a method is chained, it cannot use this.inherited() because all other methods in the hierarchy will be called automatically. </p> <p>Usually constructors and initializers of any kind are chained using "after" and destructors of any kind are chained as "before". Note that chaining assumes that chained methods do not return any value: any returned value will be discarded. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>className</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>The optional name of the constructor (loosely, a "class") stored in the "declaredClass" property in the created prototype. It will be used as a global name for a created constructor.</p> </td> </tr> <tr> <td>superclass</td> <td>Function | Function[]</td> <td>
<p>May be null, a Function, or an Array of Functions. This argument specifies a list of bases (the left-most one is the most deepest base).</p> </td> </tr> <tr> <td>props</td> <td>Object</td> <td>
<p>An object whose properties are copied to the created prototype. Add an instance-initialization function by making it a property named "constructor".</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong><a href="declare.__declarecreatedobject.html">dojo/_base/declare.__DeclareCreatedObject</a> | undefined</p> <p>New constructor function.</p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>declare("my.classes.bar", my.classes.foo, {
    // properties to be added to the class prototype
    someValue: 2,
    // initialization function
    constructor: function(){
        this.myComplicatedObject = new ReallyComplicatedObject();
    },
    // other functions
    someMethod: function(){
        doStuff();
    }
});</code></pre>   <h3>Example 2</h3><pre data-language="javascript"><code>var MyBase = declare(null, {
    // constructor, properties, and methods go here
    // ...
});
var MyClass1 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
});
var MyClass2 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
});
var MyDiamond = declare([MyClass1, MyClass2], {
    // constructor, properties, and methods go here
    // ...
});</code></pre>   <h3>Example 3</h3><pre data-language="javascript"><code>var F = function(){ console.log("raw constructor"); };
F.prototype.method = function(){
    console.log("raw method");
};
var A = declare(F, {
    constructor: function(){
        console.log("A.constructor");
    },
    method: function(){
        console.log("before calling F.method...");
        this.inherited(arguments);
        console.log("...back in A");
    }
});
new A().method();
// will print:
// raw constructor
// A.constructor
// before calling F.method...
// raw method
// ...back in A</code></pre>   <h3>Example 4</h3><pre data-language="javascript"><code>var A = declare(null, {
    "-chains-": {
        destroy: "before"
    }
});
var B = declare(A, {
    constructor: function(){
        console.log("B.constructor");
    },
    destroy: function(){
        console.log("B.destroy");
    }
});
var C = declare(B, {
    constructor: function(){
        console.log("C.constructor");
    },
    destroy: function(){
        console.log("C.destroy");
    }
});
new C().destroy();
// prints:
// B.constructor
// C.constructor
// C.destroy
// B.destroy</code></pre>   <h3>Example 5</h3><pre data-language="javascript"><code>var A = declare(null, {
    "-chains-": {
        constructor: "manual"
    }
});
var B = declare(A, {
    constructor: function(){
        // ...
        // call the base constructor with new parameters
        this.inherited(arguments, [1, 2, 3]);
        // ...
    }
});</code></pre>   <h3>Example 6</h3><pre data-language="javascript"><code>var A = declare(null, {
    "-chains-": {
        m1: "before"
    },
    m1: function(){
        console.log("A.m1");
    },
    m2: function(){
        console.log("A.m2");
    }
});
var B = declare(A, {
    "-chains-": {
        m2: "after"
    },
    m1: function(){
        console.log("B.m1");
    },
    m2: function(){
        console.log("B.m2");
    }
});
var x = new B();
x.m1();
// prints:
// B.m1
// A.m1
x.m2();
// prints:
// A.m2
// B.m2</code></pre>       <h3 id="1_10dojo__base_kernel_Deferred">
<code class="functionIcon">Deferred</code><code class="parameters">(canceller)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="deferred.html">dojo/_base/Deferred</a> </p> <p>Deprecated. This module defines the legacy dojo/_base/Deferred API. New code should use dojo/Deferred instead.</p>  <p>The Deferred API is based on the concept of promises that provide a generic interface into the eventual completion of an asynchronous action. The motivation for promises fundamentally is about creating a separation of concerns that allows one to achieve the same type of call patterns and logical data flow in asynchronous code as can be achieved in synchronous code. Promises allows one to be able to call a function purely with arguments needed for execution, without conflating the call with concerns of whether it is sync or async. One shouldn't need to alter a call's arguments if the implementation switches from sync to async (or vice versa). By having async functions return promises, the concerns of making the call are separated from the concerns of asynchronous interaction (which are handled by the promise). </p> <p>The Deferred is a type of promise that provides methods for fulfilling the promise with a successful result or an error. The most important method for working with Dojo's promises is the then() method, which follows the CommonJS proposed promise API. An example of using a Dojo promise: </p> <pre data-language="javascript"><code>var resultingPromise = someAsyncOperation.then(function(result){
    ... handle result ...
},
function(error){
    ... handle error ...
});</code></pre> <p>The .then() call returns a new promise that represents the result of the execution of the callback. The callbacks will never affect the original promises value. </p> <p>The Deferred instances also provide the following functions for backwards compatibility: </p> <ul> <li>addCallback(handler)</li> <li>addErrback(handler)</li> <li>callback(result)</li> <li>errback(result)</li> </ul> <p>Callbacks are allowed to return promises themselves, so you can build complicated sequences of events with ease. </p> <p>The creator of the Deferred may specify a canceller. The canceller is a function that will be called if Deferred.cancel is called before the Deferred fires. You can use this to implement clean aborting of an XMLHttpRequest, etc. Note that cancel will fire the deferred with a CancelledError (unless your canceller returns another kind of error), so the errbacks should be prepared to handle that error for cancellable Deferreds.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>canceller</td> <td>Function</td> <td> <div><em>Optional</em></div> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var deferred = new Deferred();
setTimeout(function(){ deferred.callback({success: true}); }, 1000);
return deferred;</code></pre>   <h3>Example 2</h3><p>Deferred objects are often used when making code asynchronous. It may be easiest to write functions in a synchronous manner and then split code using a deferred to trigger a response to a long-lived operation. For example, instead of register a callback function to denote when a rendering operation completes, the function can simply return a deferred: </p> <pre data-language="javascript"><code>// callback style:
function renderLotsOfData(data, callback){
    var success = false
    try{
        for(var x in data){
            renderDataitem(data[x]);
        }
        success = true;
    }catch(e){ }
    if(callback){
        callback(success);
    }
}


// using callback style
renderLotsOfData(someDataObj, function(success){
    // handles success or failure
    if(!success){
        promptUserToRecover();
    }
});
// NOTE: no way to add another callback here!!</code></pre>   <h3>Example 3</h3><p>Using a Deferred doesn't simplify the sending code any, but it provides a standard interface for callers and senders alike, providing both with a simple way to service multiple callbacks for an operation and freeing both sides from worrying about details such as "did this get called already?". With Deferreds, new callbacks can be added at any time. </p> <pre data-language="javascript"><code>// Deferred style:
function renderLotsOfData(data){
    var d = new Deferred();
    try{
        for(var x in data){
            renderDataitem(data[x]);
        }
        d.callback(true);
    }catch(e){
        d.errback(new Error("rendering failed"));
    }
    return d;
}


// using Deferred style
renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
});
// NOTE: addErrback and addCallback both return the Deferred
// again, so we could chain adding callbacks or save the
// deferred for later should we need to be notified again.</code></pre>   <h3>Example 4</h3><p>In this example, renderLotsOfData is synchronous and so both versions are pretty artificial. Putting the data display on a timeout helps show why Deferreds rock: </p> <pre data-language="javascript"><code>// Deferred style and async func
function renderLotsOfData(data){
    var d = new Deferred();
    setTimeout(function(){
        try{
            for(var x in data){
                renderDataitem(data[x]);
            }
            d.callback(true);
        }catch(e){
            d.errback(new Error("rendering failed"));
        }
    }, 100);
    return d;
}


// using Deferred style
renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
});</code></pre> <p>Note that the caller doesn't have to change his code at all to handle the asynchronous case.</p>       <h3 id="1_10dojo__base_kernel_DeferredList">
<code class="functionIcon">DeferredList</code><code class="parameters">(list,fireOnOneCallback,fireOnOneErrback,consumeErrors,canceller)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../deferredlist.html">dojo/DeferredList</a> </p> <p>Deprecated, use dojo/promise/all instead. Provides event handling for a group of Deferred objects.</p>  <p>DeferredList takes an array of existing deferreds and returns a new deferred of its own this new deferred will typically have its callback fired when all of the deferreds in the given list have fired their own deferreds. The parameters <code>fireOnOneCallback</code> and fireOnOneErrback, will fire before all the deferreds as appropriate</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>list</td> <td>Array</td> <td>
<p>The list of deferreds to be synchronizied with this DeferredList</p> </td> </tr> <tr> <td>fireOnOneCallback</td> <td>Boolean</td> <td> <div><em>Optional</em></div>
<p>Will cause the DeferredLists callback to be fired as soon as any of the deferreds in its list have been fired instead of waiting until the entire list has finished</p> </td> </tr> <tr> <td>fireOnOneErrback</td> <td>Boolean</td> <td> <div><em>Optional</em></div> </td> </tr> <tr> <td>consumeErrors</td> <td>Boolean</td> <td> <div><em>Optional</em></div> </td> </tr> <tr> <td>canceller</td> <td>Function</td> <td> <div><em>Optional</em></div>
<p>A deferred canceller function, see dojo.Deferred</p> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_deprecated">
<code class="functionIcon">deprecated</code><code class="parameters">(behaviour,extra,removal)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="kernel.html">dojo/_base/kernel</a> </p> <p>Log a debug message to indicate that a behavior has been deprecated.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>behaviour</td> <td>String</td> <td>
<p>The API or behavior being deprecated. Usually in the form of "myApp.someFunction()".</p> </td> </tr> <tr> <td>extra</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>Text to append to the message. Often provides advice on a new function or facility to achieve the same goal during the deprecation period.</p> </td> </tr> <tr> <td>removal</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>Text to indicate when in the future the behavior will be removed. Usually a version number.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");</code></pre>       <h3 id="1_10dojo__base_kernel_destroy">
<code class="functionIcon">destroy</code><code class="parameters">(node)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="html.html">dojo/_base/html</a> </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>undefined</td> <td> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_disconnect">
<code class="functionIcon">disconnect</code><code class="parameters">(handle)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="connect.html">dojo/_base/connect</a> </p> <p>Remove a link created by dojo.connect.</p>  <p>Removes the connection between event and the method referenced by handle.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>handle</td> <td>Handle</td> <td>
<p>the return value of the dojo.connect call that created the connection.</p> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_docScroll">
<code class="functionIcon">docScroll</code><code class="parameters">(doc)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>Returns an object with {node, x, y} with corresponding offsets.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>doc</td> <td>Document</td> <td> <div><em>Optional</em></div>
<p>Optional document to query. If unspecified, use win.doc.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Object | undefined</p>     <h3 id="1_10dojo__base_kernel_empty">
<code class="functionIcon">empty</code><code class="parameters">(node)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="html.html">dojo/_base/html</a> </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>undefined</td> <td> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_eval">
<code class="functionIcon">eval</code><code class="parameters">(scriptText)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="kernel.html">dojo/_base/kernel</a> </p> <p>A legacy method created for use exclusively by internal Dojo methods. Do not use this method directly unless you understand its possibly-different implications on the platforms your are targeting.</p>  <p>Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers that support indirect eval. </p> <p>As usual, IE does not. On IE, the only way to implement global eval is to use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval. This implementation uses the technique of executing eval in the scope of a function that is a single scope frame below the global scope; thereby coming close to the global scope. Note carefully that </p> <p>dojo.eval("var pi = 3.14;"); </p> <p>will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want to define a global variable using dojo.eval, write something like </p> <p>dojo.eval("window.pi = 3.14;")</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>scriptText</td> <td>undefined</td> <td>
<p>The text to evaluation.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>The result of the evaluation. Often <code>undefined</code></p>      <h3 id="1_10dojo__base_kernel_every">
<code class="functionIcon">every</code><code class="parameters">(arr,callback,thisObject)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="array.html">dojo/_base/array</a> </p> <p>Determines whether or not every item in arr satisfies the condition implemented by callback.</p>  <p>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when run over sparse arrays, this implementation passes the "holes" in the sparse array to the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array. For more details, see: <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every</a></p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>arr</td> <td>Array | String</td> <td>
<p>the array to iterate on. If a string, operates on individual characters.</p> </td> </tr> <tr> <td>callback</td> <td>Function | String</td> <td>
<p>a function is invoked with three arguments: item, index, and array and returns true if the condition is met.</p> </td> </tr> <tr> <td>thisObject</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>may be used to scope the call to callback</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Boolean</p>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// returns false
array.every([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>   <h3>Example 2</h3><pre data-language="javascript"><code>// returns true
array.every([1, 2, 3, 4], function(item){ return item&gt;0; });</code></pre>       <h3 id="1_10dojo__base_kernel_exit">
<code class="functionIcon">exit</code><code class="parameters">(exitcode)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="configspidermonkey.html">dojo/_base/configSpidermonkey</a> </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>exitcode</td> <td>undefined</td> <td> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_experimental">
<code class="functionIcon">experimental</code><code class="parameters">(moduleName,extra)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="kernel.html">dojo/_base/kernel</a> </p> <p>Marks code as experimental.</p>  <p>This can be used to mark a function, file, or module as experimental. Experimental code is not ready to be used, and the APIs are subject to change without notice. Experimental code may be completed deleted without going through the normal deprecation process.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>moduleName</td> <td>String</td> <td>
<p>The name of a module, or the name of a module file or a specific function</p> </td> </tr> <tr> <td>extra</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>some additional message for the user</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>dojo.experimental("dojo.data.Result");</code></pre>   <h3>Example 2</h3><pre data-language="javascript"><code>dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");</code></pre>       <h3 id="1_10dojo__base_kernel_fadeIn">
<code class="functionIcon">fadeIn</code><code class="parameters">(args)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="fx.html">dojo/_base/fx</a> </p> <p>Returns an animation that will fade node defined in 'args' from its current opacity to fully opaque.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>args</td> <td>Object</td> <td>
<p>An object with the following properties:</p>
<ul>
<li>node (DOMNode|String): <p>The node referenced in the animation</p> </li>
<li>duration (Integer, optional): <p>Duration of the animation in milliseconds.</p> </li>
<li>easing (Function, optional): <p>An easing function.</p> </li>
</ul> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_fadeOut">
<code class="functionIcon">fadeOut</code><code class="parameters">(args)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="fx.html">dojo/_base/fx</a> </p> <p>Returns an animation that will fade node defined in 'args' from its current opacity to fully transparent.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>args</td> <td>Object</td> <td>
<p>An object with the following properties:</p>
<ul>
<li>node (DOMNode|String): <p>The node referenced in the animation</p> </li>
<li>duration (Integer, optional): <p>Duration of the animation in milliseconds.</p> </li>
<li>easing (Function, optional): <p>An easing function.</p> </li>
</ul> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_fieldToObject">
<code class="functionIcon">fieldToObject</code><code class="parameters">(inputNode)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-form.html">dojo/dom-form</a> </p> <p>Serialize a form field to a JavaScript object.</p>  <p>Returns the value encoded in a form field as as a string or an array of strings. Disabled form elements and unchecked radio and checkboxes are skipped. Multi-select elements are returned as an array of string values.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>inputNode</td> <td>DOMNode | String</td> <td> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Object | undefined</p>     <h3 id="1_10dojo__base_kernel_filter">
<code class="functionIcon">filter</code><code class="parameters">(arr,callback,thisObject)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="array.html">dojo/_base/array</a> </p> <p>Returns a new Array with those items from arr that match the condition implemented by callback.</p>  <p>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when run over sparse arrays, this implementation passes the "holes" in the sparse array to the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array. For more details, see: <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter</a></p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>arr</td> <td>Array</td> <td>
<p>the array to iterate over.</p> </td> </tr> <tr> <td>callback</td> <td>Function | String</td> <td>
<p>a function that is invoked with three arguments (item, index, array). The return of this function is expected to be a boolean which determines whether the passed-in item will be included in the returned array.</p> </td> </tr> <tr> <td>thisObject</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>may be used to scope the call to callback</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Array</p>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// returns [2, 3, 4]
array.filter([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>       <h3 id="1_10dojo__base_kernel_fixEvent">
<code class="functionIcon">fixEvent</code><code class="parameters">(evt,sender)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="event.html">dojo/_base/event</a> </p> <p>normalizes properties on the event object including event bubbling methods, keystroke normalization, and x/y positions</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>evt</td> <td>Event</td> <td>
<p>native event object</p> </td> </tr> <tr> <td>sender</td> <td>DOMNode</td> <td>
<p>node to treat as "currentTarget"</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Event</p> <p>native event object</p>      <h3 id="1_10dojo__base_kernel_fixIeBiDiScrollLeft">
<code class="functionIcon">fixIeBiDiScrollLeft</code><code class="parameters">(scrollLeft,doc)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>In RTL direction, scrollLeft should be a negative value, but IE returns a positive one. All codes using documentElement.scrollLeft must call this function to fix this error, otherwise the position will offset to right when there is a horizontal scrollbar.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>scrollLeft</td> <td>Number</td> <td> </td> </tr> <tr> <td>doc</td> <td>Document</td> <td> <div><em>Optional</em></div>
<p>Optional document to query. If unspecified, use win.doc.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Number | number</p>     <h3 id="1_10dojo__base_kernel_forEach">
<code class="functionIcon">forEach</code><code class="parameters">(arr,callback,thisObject)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="array.html">dojo/_base/array</a> </p> <p>for every item in arr, callback is invoked. Return values are ignored. If you want to break out of the loop, consider using array.every() or array.some(). forEach does not allow breaking out of the loop over the items in arr.</p>  <p>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when run over sparse arrays, this implementation passes the "holes" in the sparse array to the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array. For more details, see: <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach</a></p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>arr</td> <td>Array | String</td> <td> </td> </tr> <tr> <td>callback</td> <td>Function | String</td> <td> </td> </tr> <tr> <td>thisObject</td> <td>Object</td> <td> <div><em>Optional</em></div> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// log out all members of the array:
array.forEach(
      [ "thinger", "blah", "howdy", 10 ],
      function(item){
          console.log(item);
      }
);</code></pre>   <h3>Example 2</h3><pre data-language="javascript"><code>// log out the members and their indexes
array.forEach(
      [ "thinger", "blah", "howdy", 10 ],
      function(item, idx, arr){
          console.log(item, "at index:", idx);
      }
);</code></pre>   <h3>Example 3</h3><pre data-language="javascript"><code>// use a scoped object member as the callback

var obj = {
      prefix: "logged via obj.callback:",
      callback: function(item){
          console.log(this.prefix, item);
      }
};

// specifying the scope function executes the callback in that scope
array.forEach(
      [ "thinger", "blah", "howdy", 10 ],
      obj.callback,
      obj
);

// alternately, we can accomplish the same thing with lang.hitch()
array.forEach(
      [ "thinger", "blah", "howdy", 10 ],
      lang.hitch(obj, "callback")
);</code></pre>       <h3 id="1_10dojo__base_kernel_formToJson">
<code class="functionIcon">formToJson</code><code class="parameters">(formNode,prettyPrint)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-form.html">dojo/dom-form</a> </p> <p>Create a serialized JSON string from a form node or string ID identifying the form to serialize</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>formNode</td> <td>DOMNode | String</td> <td> </td> </tr> <tr> <td>prettyPrint</td> <td>Boolean</td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>String | undefined</p>     <h3 id="1_10dojo__base_kernel_formToObject">
<code class="functionIcon">formToObject</code><code class="parameters">(formNode)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-form.html">dojo/dom-form</a> </p> <p>Serialize a form node to a JavaScript object.</p>  <p>Returns the values encoded in an HTML form as string properties in an object which it then returns. Disabled form elements, buttons, and other non-value form elements are skipped. Multi-select elements are returned as an array of string values.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>formNode</td> <td>DOMNode | String</td> <td> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>object</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>This form: </p> <pre data-language="markup"><code>&lt;form id="test_form"&gt;
    &lt;input type="text" name="blah" value="blah"&gt;
    &lt;input type="text" name="no_value" value="blah" disabled&gt;
    &lt;input type="button" name="no_value2" value="blah"&gt;
    &lt;select type="select" multiple name="multi" size="5"&gt;
        &lt;option value="blah"&gt;blah&lt;/option&gt;
        &lt;option value="thud" selected&gt;thud&lt;/option&gt;
        &lt;option value="thonk" selected&gt;thonk&lt;/option&gt;
    &lt;/select&gt;
&lt;/form&gt;</code></pre> <p>yields this object structure as the result of a call to formToObject(): </p> <pre data-language="javascript"><code>{
    blah: "blah",
    multi: [
        "thud",
        "thonk"
    ]
};</code></pre>       <h3 id="1_10dojo__base_kernel_formToQuery">
<code class="functionIcon">formToQuery</code><code class="parameters">(formNode)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-form.html">dojo/dom-form</a> </p> <p>Returns a URL-encoded string representing the form passed as either a node or string ID identifying the form to serialize</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>formNode</td> <td>DOMNode | String</td> <td> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>String | undefined</p>     <h3 id="1_10dojo__base_kernel_fromJson">
<code class="functionIcon">fromJson</code><code class="parameters">(js)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="json.html">dojo/_base/json</a> </p> <p>Parses a JavaScript expression and returns a JavaScript value.</p>  <p>Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It always delegates to eval(). The content passed to this method must therefore come from a trusted source. It is recommend that you use <a href="../json.html">dojo/json</a>'s parse function for an implementation uses the (faster) native JSON parse when available.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>js</td> <td>String</td> <td>
<p>a string literal of a JavaScript expression, for instance: <code>'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'</code></p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_getAttr">
<code class="functionIcon">getAttr</code><code class="parameters">(node,name)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-attr.html">dojo/dom-attr</a> </p> <p>Gets an attribute on an HTML element.</p>  <p>Handles normalized getting of attributes on DOM Nodes.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>id or reference to the element to get the attribute on</p> </td> </tr> <tr> <td>name</td> <td>String</td> <td>
<p>the name of the attribute to get.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any | undefined | null</p> <p>the value of the requested attribute or null if that attribute does not have a specified or default value; </p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// get the current value of the "foo" attribute on a node
require(["dojo/dom-attr", "dojo/dom"], function(domAttr, dom){
    domAttr.get(dom.byId("nodeId"), "foo");
    // or we can just pass the id:
    domAttr.get("nodeId", "foo");
}); </code></pre>       <h3 id="1_10dojo__base_kernel_getBorderExtents">
<code class="functionIcon">getBorderExtents</code><code class="parameters">(node,computedStyle)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>returns an object with properties useful for noting the border dimensions.</p>  <ul> <li>l/t/r/b = the sum of left/top/right/bottom border (respectively)</li> <li>w = the sum of the left and right border</li> <li>h = the sum of the top and bottom border</li> </ul> <p>The w/h are used for calculating boxes. Normally application code will not need to invoke this directly, and will use the ...box... functions instead.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode</td> <td> </td> </tr> <tr> <td>computedStyle</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>This parameter accepts computed styles object. If this parameter is omitted, the functions will call dojo/dom-style.getComputedStyle to get one. It is a better way, calling dojo/dom-style.getComputedStyle once, and then pass the reference to this computedStyle parameter. Wherever possible, reuse the returned object of dojo/dom-style.getComputedStyle().</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>object</p>     <h3 id="1_10dojo__base_kernel_getComputedStyle">
<code class="functionIcon">getComputedStyle</code><code class="parameters">(node)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-style.html">dojo/dom-style</a> </p> <p>Returns a "computed style" object. </p>  <p>Gets a "computed style" object which can be used to gather information about the current state of the rendered node. </p> <p>Note that this may behave differently on different browsers. Values may have different formats and value encodings across browsers. </p> <p>Note also that this method is expensive. Wherever possible, reuse the returned object. </p> <p>Use the <a href="../dom-style.html#get">dojo/dom-style.get()</a> method for more consistent (pixelized) return values. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode</td> <td>
<p>A reference to a DOM node. Does NOT support taking an ID string for speed reasons.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
    domStyle.getComputedStyle(dom.byId('foo')).borderWidth;
});</code></pre>   <h3>Example 2</h3><p>Reusing the returned object, avoiding multiple lookups: </p> <pre data-language="javascript"><code>require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
    var cs = domStyle.getComputedStyle(dom.byId("someNode"));
    var w = cs.width, h = cs.height;
});</code></pre>       <h3 id="1_10dojo__base_kernel_getContentBox">
<code class="functionIcon">getContentBox</code><code class="parameters">(node,computedStyle)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>Returns an object that encodes the width, height, left and top positions of the node's content box, irrespective of the current box model.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode</td> <td> </td> </tr> <tr> <td>computedStyle</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>This parameter accepts computed styles object. If this parameter is omitted, the functions will call dojo/dom-style.getComputedStyle to get one. It is a better way, calling dojo/dom-style.getComputedStyle once, and then pass the reference to this computedStyle parameter. Wherever possible, reuse the returned object of dojo/dom-style.getComputedStyle().</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>object</p>     <h3 id="1_10dojo__base_kernel_getIeDocumentElementOffset">
<code class="functionIcon">getIeDocumentElementOffset</code><code class="parameters">(doc)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>returns the offset in x and y from the document body to the visual edge of the page for IE</p>  <p>The following values in IE contain an offset: </p> <pre data-language="javascript"><code>event.clientX
event.clientY
node.getBoundingClientRect().left
node.getBoundingClientRect().top</code></pre> <p>But other position related values do not contain this offset, </p> <p>such as node.offsetLeft, node.offsetTop, node.style.left and node.style.top. The offset is always (2, 2) in LTR direction. When the body is in RTL direction, the offset counts the width of left scroll bar's width. This function computes the actual offset.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>doc</td> <td>Document</td> <td> <div><em>Optional</em></div>
<p>Optional document to query. If unspecified, use win.doc.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>object</p>     <h3 id="1_10dojo__base_kernel_getL10nName">
<code class="functionIcon">getL10nName</code><code class="parameters">(moduleName,bundleName,locale)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../i18n.html">dojo/i18n</a> </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>moduleName</td> <td>undefined</td> <td> </td> </tr> <tr> <td>bundleName</td> <td>undefined</td> <td> </td> </tr> <tr> <td>locale</td> <td>undefined</td> <td> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>string</p>     <h3 id="1_10dojo__base_kernel_getMarginBox">
<code class="functionIcon">getMarginBox</code><code class="parameters">(node,computedStyle)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>returns an object that encodes the width, height, left and top positions of the node's margin box.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode</td> <td> </td> </tr> <tr> <td>computedStyle</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>This parameter accepts computed styles object. If this parameter is omitted, the functions will call dojo/dom-style.getComputedStyle to get one. It is a better way, calling dojo/dom-style.getComputedStyle once, and then pass the reference to this computedStyle parameter. Wherever possible, reuse the returned object of dojo/dom-style.getComputedStyle().</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>object</p>     <h3 id="1_10dojo__base_kernel_getMarginExtents">
<code class="functionIcon">getMarginExtents</code><code class="parameters">(node,computedStyle)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>returns object with properties useful for box fitting with regards to box margins (i.e., the outer-box). </p> <ul> <li>l/t = marginLeft, marginTop, respectively</li> <li>w = total width, margin inclusive</li> <li>h = total height, margin inclusive</li> </ul> <p>The w/h are used for calculating boxes. Normally application code will not need to invoke this directly, and will use the ...box... functions instead.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode</td> <td> </td> </tr> <tr> <td>computedStyle</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>This parameter accepts computed styles object. If this parameter is omitted, the functions will call dojo/dom-style.getComputedStyle to get one. It is a better way, calling dojo/dom-style.getComputedStyle once, and then pass the reference to this computedStyle parameter. Wherever possible, reuse the returned object of dojo/dom-style.getComputedStyle().</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>object</p>     <h3 id="1_10dojo__base_kernel_getMarginSize">
<code class="functionIcon">getMarginSize</code><code class="parameters">(node,computedStyle)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>returns an object that encodes the width and height of the node's margin box</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td> </td> </tr> <tr> <td>computedStyle</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>This parameter accepts computed styles object. If this parameter is omitted, the functions will call dojo/dom-style.getComputedStyle to get one. It is a better way, calling dojo/dom-style.getComputedStyle once, and then pass the reference to this computedStyle parameter. Wherever possible, reuse the returned object of dojo/dom-style.getComputedStyle().</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>object</p>     <h3 id="1_10dojo__base_kernel_getNodeProp">
<code class="functionIcon">getNodeProp</code><code class="parameters">(node,name)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-attr.html">dojo/dom-attr</a> </p> <p>Returns an effective value of a property or an attribute.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>id or reference to the element to remove the attribute from</p> </td> </tr> <tr> <td>name</td> <td>String</td> <td>
<p>the name of the attribute</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>the value of the attribute</p>      <h3 id="1_10dojo__base_kernel_getPadBorderExtents">
<code class="functionIcon">getPadBorderExtents</code><code class="parameters">(node,computedStyle)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>Returns object with properties useful for box fitting with regards to padding.</p>  <ul> <li>l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)</li> <li>w = the sum of the left and right padding and border</li> <li>h = the sum of the top and bottom padding and border</li> </ul> <p>The w/h are used for calculating boxes. Normally application code will not need to invoke this directly, and will use the ...box... functions instead.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode</td> <td> </td> </tr> <tr> <td>computedStyle</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>This parameter accepts computed styles object. If this parameter is omitted, the functions will call dojo/dom-style.getComputedStyle to get one. It is a better way, calling dojo/dom-style.getComputedStyle once, and then pass the reference to this computedStyle parameter. Wherever possible, reuse the returned object of dojo/dom-style.getComputedStyle().</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>object</p>     <h3 id="1_10dojo__base_kernel_getPadExtents">
<code class="functionIcon">getPadExtents</code><code class="parameters">(node,computedStyle)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>Returns object with special values specifically useful for node fitting.</p>  <p>Returns an object with <code>w</code>, <code>h</code>, <code>l</code>, <code>t</code> properties: </p> <pre data-language="javascript"><code>l/t/r/b = left/top/right/bottom padding (respectively)
w = the total of the left and right padding
h = the total of the top and bottom padding</code></pre> <p>If 'node' has position, l/t forms the origin for child nodes. </p> <p>The w/h are used for calculating boxes. Normally application code will not need to invoke this directly, and will use the ...box... functions instead.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode</td> <td> </td> </tr> <tr> <td>computedStyle</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>This parameter accepts computed styles object. If this parameter is omitted, the functions will call dojo/dom-style.getComputedStyle to get one. It is a better way, calling dojo/dom-style.getComputedStyle once, and then pass the reference to this computedStyle parameter. Wherever possible, reuse the returned object of dojo/dom-style.getComputedStyle().</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>object</p>     <h3 id="1_10dojo__base_kernel_getProp">
<code class="functionIcon">getProp</code><code class="parameters">(node,name)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-prop.html">dojo/dom-prop</a> </p> <p>Gets a property on an HTML element.</p>  <p>Handles normalized getting of properties on DOM nodes. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>id or reference to the element to get the property on</p> </td> </tr> <tr> <td>name</td> <td>String</td> <td>
<p>the name of the property to get.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any | undefined</p> <p>the value of the requested property or its default value </p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// get the current value of the "foo" property on a node
require(["dojo/dom-prop", "dojo/dom"], function(domProp, dom){
    domProp.get(dom.byId("nodeId"), "foo");
    // or we can just pass the id:
    domProp.get("nodeId", "foo");
});</code></pre>       <h3 id="1_10dojo__base_kernel_getStyle">
<code class="functionIcon">getStyle</code><code class="parameters">(node,name)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-style.html">dojo/dom-style</a> </p> <p>Accesses styles on a node.</p>  <p>Getting the style value uses the computed style for the node, so the value will be a calculated value, not just the immediate node.style value. Also when getting values, use specific style names, like "borderBottomWidth" instead of "border" since compound values like "border" are not necessarily reflected as expected. If you want to get node dimensions, use <a href="../dom-geometry.html#getMarginBox">dojo/dom-geometry.getMarginBox()</a>, <a href="../dom-geometry.html#getContentBox">dojo/dom-geometry.getContentBox()</a> or <a href="../dom-geometry.html#getPosition">dojo/dom-geometry.getPosition()</a>.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>id or reference to node to get style for</p> </td> </tr> <tr> <td>name</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>the style property to get</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>Passing only an ID or node returns the computed style object of the node: </p> <pre data-language="javascript"><code>require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
    domStyle.get("thinger");
});</code></pre>   <h3>Example 2</h3><p>Passing a node and a style property returns the current normalized, computed value for that property: </p> <pre data-language="javascript"><code>require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
    domStyle.get("thinger", "opacity"); // 1 by default
});</code></pre>       <h3 id="1_10dojo__base_kernel_hasAttr">
<code class="functionIcon">hasAttr</code><code class="parameters">(node,name)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-attr.html">dojo/dom-attr</a> </p> <p>Returns true if the requested attribute is specified on the given element, and false otherwise.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>id or reference to the element to check</p> </td> </tr> <tr> <td>name</td> <td>String</td> <td>
<p>the name of the attribute</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Boolean | contentWindow.document isn't accessible within IE7/8</p> <p>true if the requested attribute is specified on the given element, and false otherwise</p>      <h3 id="1_10dojo__base_kernel_hasClass">
<code class="functionIcon">hasClass</code><code class="parameters">(node,classStr)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-class.html">dojo/dom-class</a> </p> <p>Returns whether or not the specified classes are a portion of the class list currently applied to the node.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>String | DOMNode</td> <td>
<p>String ID or DomNode reference to check the class for.</p> </td> </tr> <tr> <td>classStr</td> <td>String</td> <td>
<p>A string class name to look for.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>boolean</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>Do something if a node with id="someNode" has class="aSillyClassName" present </p> <pre data-language="javascript"><code>if(dojo.hasClass("someNode","aSillyClassName")){ ... }</code></pre>       <h3 id="1_10dojo__base_kernel_hash">
<code class="functionIcon">hash</code><code class="parameters">(hash,replace)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../hash.html">dojo/hash</a> </p> <p>Gets or sets the hash string in the browser URL.</p>  <p>Handles getting and setting of location.hash. </p> <ul> <li>If no arguments are passed, acts as a getter.</li> <li>If a string is passed, acts as a setter.</li> </ul>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>hash</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>the hash is set - #string.</p> </td> </tr> <tr> <td>replace</td> <td>Boolean</td> <td> <div><em>Optional</em></div>
<p>If true, updates the hash value in the current history state instead of creating a new history state.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any | undefined</p> <p>when used as a getter, returns the current hash string. when used as a setter, returns the new hash string.</p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>topic.subscribe("/dojo/hashchange", context, callback);

function callback (hashValue){
    // do something based on the hash value.
}</code></pre>       <h3 id="1_10dojo__base_kernel_indexOf">
<code class="functionIcon">indexOf</code><code class="parameters">(arr,value,fromIndex,findLast)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="array.html">dojo/_base/array</a> </p> <p>locates the first index of the provided value in the passed array. If the value is not found, -1 is returned.</p>  <p>This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences: </p> <ol> <li>when run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript 1.6's indexOf skips the holes in the sparse array.</li> <li>uses equality (==) rather than strict equality (===)</li> </ol> <p>For details on this method, see: <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf</a></p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>arr</td> <td>Array</td> <td> </td> </tr> <tr> <td>value</td> <td>Object</td> <td> </td> </tr> <tr> <td>fromIndex</td> <td>Integer</td> <td> <div><em>Optional</em></div> </td> </tr> <tr> <td>findLast</td> <td>Boolean</td> <td> <div><em>Optional</em></div>
<p>Makes indexOf() work like lastIndexOf(). Used internally; not meant for external usage.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Number</p>     <h3 id="1_10dojo__base_kernel_isBodyLtr">
<code class="functionIcon">isBodyLtr</code><code class="parameters">(doc)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>Returns true if the current language is left-to-right, and false otherwise.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>doc</td> <td>Document</td> <td> <div><em>Optional</em></div>
<p>Optional document to query. If unspecified, use win.doc.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Boolean | boolean</p>     <h3 id="1_10dojo__base_kernel_isDescendant">
<code class="functionIcon">isDescendant</code><code class="parameters">(node,ancestor)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom.html">dojo/dom</a> </p> <p>Returns true if node is a descendant of ancestor</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>string id or node reference to test</p> </td> </tr> <tr> <td>ancestor</td> <td>DOMNode | String</td> <td>
<p>string id or node reference of potential parent to test against </p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>boolean</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>Test is node id="bar" is a descendant of node id="foo" </p> <pre data-language="javascript"><code>require(["dojo/dom"], function(dom){
    if(dom.isDescendant("bar", "foo")){ ... }
});</code></pre>       <h3 id="1_10dojo__base_kernel_lastIndexOf">
<code class="functionIcon">lastIndexOf</code><code class="parameters">(arr,value,fromIndex)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="array.html">dojo/_base/array</a> </p> <p>locates the last index of the provided value in the passed array. If the value is not found, -1 is returned.</p>  <p>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences: </p> <ol> <li>when run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.</li> <li>uses equality (==) rather than strict equality (===)</li> </ol> <p>For details on this method, see: <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf</a></p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>arr</td> <td>undefined</td> <td> </td> </tr> <tr> <td>value</td> <td>undefined</td> <td> </td> </tr> <tr> <td>fromIndex</td> <td>Integer</td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Number</p>     <h3 id="1_10dojo__base_kernel_loadInit">
<code class="functionIcon">loadInit</code><code class="parameters">(f)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="loader.html">dojo/_base/loader</a> </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>f</td> <td>undefined</td> <td> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_map">
<code class="functionIcon">map</code><code class="parameters">(arr,callback,thisObject,Ctr)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="array.html">dojo/_base/array</a> </p> <p>applies callback to each element of arr and returns an Array with the results</p>  <p>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when run over sparse arrays, this implementation passes the "holes" in the sparse array to the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array. For more details, see: <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map</a></p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>arr</td> <td>Array | String</td> <td>
<p>the array to iterate on. If a string, operates on individual characters.</p> </td> </tr> <tr> <td>callback</td> <td>Function | String</td> <td>
<p>a function is invoked with three arguments, (item, index, array), and returns a value</p> </td> </tr> <tr> <td>thisObject</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>may be used to scope the call to callback</p> </td> </tr> <tr> <td>Ctr</td> <td>undefined</td> <td> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Array | instance</p>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// returns [2, 3, 4, 5]
array.map([1, 2, 3, 4], function(item){ return item+1 });</code></pre>       <h3 id="1_10dojo__base_kernel_marginBox">
<code class="functionIcon">marginBox</code><code class="parameters">(node,box)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="html.html">dojo/_base/html</a> </p> <p>Getter/setter for the margin-box of node.</p>  <p>Getter/setter for the margin-box of node. Returns an object in the expected format of box (regardless if box is passed). The object might look like: <code>{ l: 50, t: 200, w: 300: h: 150 }</code> for a node offset from its parent 50px to the left, 200px from the top with a margin width of 300px and a margin-height of 150px.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DomNode | String</td> <td>
<p>id or reference to DOM Node to get/set box for</p> </td> </tr> <tr> <td>box</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>If passed, denotes that dojo.marginBox() should update/set the margin box for node. Box is an object in the above format. All properties are optional if passed.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>Retrieve the margin box of a passed node </p> <pre data-language="javascript"><code>var box = dojo.marginBox("someNodeId");
console.dir(box);</code></pre>   <h3>Example 2</h3><p>Set a node's margin box to the size of another node </p> <pre data-language="javascript"><code>var box = dojo.marginBox("someNodeId");
dojo.marginBox("someOtherNode", box);</code></pre>       <h3 id="1_10dojo__base_kernel_moduleUrl">
<code class="functionIcon">moduleUrl</code><code class="parameters">(module,url)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="kernel.html">dojo/_base/kernel</a> </p> <p>Returns a URL relative to a module.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>module</td> <td>String</td> <td>
<p>dojo/dom-class</p> </td> </tr> <tr> <td>url</td> <td>String</td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>string</p>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var pngPath = dojo.moduleUrl("acme","images/small.png");
console.dir(pngPath); // list the object properties
// create an image and set it's source to pngPath's value:
var img = document.createElement("img");
img.src = pngPath;
// add our image to the document
dojo.body().appendChild(img);</code></pre>   <h3>Example 2</h3><p>you may de-reference as far as you like down the package hierarchy. This is sometimes handy to avoid lengthy relative urls or for building portable sub-packages. In this example, the <code>acme.widget</code> and <code>acme.util</code> directories may be located under different roots (see <code>dojo.registerModulePath</code>) but the the modules which reference them can be unaware of their relative locations on the filesystem: </p> <pre data-language="javascript"><code>// somewhere in a configuration block
dojo.registerModulePath("acme.widget", "../../acme/widget");
dojo.registerModulePath("acme.util", "../../util");

// ...

// code in a module using acme resources
var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
var dataPath = dojo.moduleUrl("acme.util","resources/data.json");</code></pre>       <h3 id="1_10dojo__base_kernel_NodeList">
<code class="functionIcon">NodeList</code><code class="parameters">(array)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../query.html">dojo/query</a> </p> <p>Array-like object which adds syntactic sugar for chaining, common iteration operations, animation, and node manipulation. NodeLists are most often returned as the result of dojo/query() calls.</p>  <p>NodeList instances provide many utilities that reflect core Dojo APIs for Array iteration and manipulation, DOM manipulation, and event handling. Instead of needing to dig up functions in the dojo package, NodeLists generally make the full power of Dojo available for DOM manipulation tasks in a simple, chainable way.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>array</td> <td>undefined</td> <td> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Array</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>create a node list from a node </p> <pre data-language="javascript"><code>require(["dojo/query", "dojo/dom"
], function(query, dom){
    query.NodeList(dom.byId("foo"));
});</code></pre>   <h3>Example 2</h3><p>get a NodeList from a CSS query and iterate on it </p> <pre data-language="javascript"><code>require(["dojo/on", "dojo/dom"
], function(on, dom){
    var l = query(".thinger");
    l.forEach(function(node, index, nodeList){
        console.log(index, node.innerHTML);
    });
});</code></pre>   <h3>Example 3</h3><p>use native and Dojo-provided array methods to manipulate a NodeList without needing to use dojo.* functions explicitly: </p> <pre data-language="javascript"><code>require(["dojo/query", "dojo/dom-construct", "dojo/dom"
], function(query, domConstruct, dom){
    var l = query(".thinger");
    // since NodeLists are real arrays, they have a length
    // property that is both readable and writable and
    // push/pop/shift/unshift methods
    console.log(l.length);
    l.push(domConstruct.create("span"));

    // dojo's normalized array methods work too:
    console.log( l.indexOf(dom.byId("foo")) );
    // ...including the special "function as string" shorthand
    console.log( l.every("item.nodeType == 1") );

    // NodeLists can be [..] indexed, or you can use the at()
    // function to get specific items wrapped in a new NodeList:
    var node = l[3]; // the 4th element
    var newList = l.at(1, 3); // the 2nd and 4th elements
});</code></pre>   <h3>Example 4</h3><p>chainability is a key advantage of NodeLists: </p> <pre data-language="javascript"><code>require(["dojo/query", "dojo/NodeList-dom"
], function(query){
    query(".thinger")
        .onclick(function(e){ /* ... */ })
        .at(1, 3, 8) // get a subset
            .style("padding", "5px")
            .forEach(console.log);
});</code></pre>       <h3 id="1_10dojo__base_kernel_objectToQuery">
<code class="functionIcon">objectToQuery</code><code class="parameters">(map)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../io-query.html">dojo/io-query</a> </p> <p>takes a name/value mapping object and returns a string representing a URL-encoded version of that object.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>map</td> <td>Object</td> <td> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>this object: </p> <pre data-language="javascript"><code>{
    blah: "blah",
    multi: [
        "thud",
        "thonk"
    ]
};</code></pre> <p>yields the following query string: </p> <pre data-language="javascript"><code>"blah=blah&amp;multi=thud&amp;multi=thonk"</code></pre>       <h3 id="1_10dojo__base_kernel_place">
<code class="functionIcon">place</code><code class="parameters">(node,refNode,position)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-construct.html">dojo/dom-construct</a> </p> <p>Attempt to insert node into the DOM, choosing from various positioning options. Returns the first argument resolved to a DOM node.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | DocumentFragment | String</td> <td>
<p>id or node reference, or HTML fragment starting with "&lt;" to place relative to refNode</p> </td> </tr> <tr> <td>refNode</td> <td>DOMNode | String</td> <td>
<p>id or node reference to use as basis for placement</p> </td> </tr> <tr> <td>position</td> <td>String | Number</td> <td> <div><em>Optional</em></div>
<p>string noting the position of node relative to refNode or a number indicating the location in the childNodes collection of refNode. Accepted string values are: </p> <ul> <li>before</li> <li>after</li> <li>replace</li> <li>only</li> <li>first</li> <li>last</li> </ul> <p>"first" and "last" indicate positions as children of refNode, "replace" replaces refNode, "only" replaces all children. position defaults to "last" if not specified</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>DOMNode | undefined</p> <p>Returned values is the first argument resolved to a DOM node. </p> <p>.place() is also a method of <code>dojo/NodeList</code>, allowing <code>dojo/query</code> node lookups.</p>   <h2>Examples</h2>  <h3>Example 1</h3><p>Place a node by string id as the last child of another node by string id: </p> <pre data-language="javascript"><code>require(["dojo/dom-construct"], function(domConstruct){
    domConstruct.place("someNode", "anotherNode");
});</code></pre>   <h3>Example 2</h3><p>Place a node by string id before another node by string id </p> <pre data-language="javascript"><code>require(["dojo/dom-construct"], function(domConstruct){
    domConstruct.place("someNode", "anotherNode", "before");
});</code></pre>   <h3>Example 3</h3><p>Create a Node, and place it in the body element (last child): </p> <pre data-language="javascript"><code>require(["dojo/dom-construct", "dojo/_base/window"
], function(domConstruct, win){
    domConstruct.place("&lt;div&gt;&lt;/div&gt;", win.body());
});</code></pre>   <h3>Example 4</h3><p>Put a new LI as the first child of a list by id: </p> <pre data-language="javascript"><code>require(["dojo/dom-construct"], function(domConstruct){
    domConstruct.place("&lt;li&gt;&lt;/li&gt;", "someUl", "first");
});</code></pre>       <h3 id="1_10dojo__base_kernel_platformRequire">
<code class="functionIcon">platformRequire</code><code class="parameters">(modMap)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="loader.html">dojo/_base/loader</a> </p> <p>require one or more modules based on which host environment Dojo is currently operating in</p>  <p>This method takes a "map" of arrays which one can use to optionally load dojo modules. The map is indexed by the possible dojo.name<em> values, with two additional values: "default" and "common". The items in the "default" array will be loaded if none of the other items have been chosen based on dojo.name</em>, set by your host environment. The items in the "common" array will <em>always</em> be loaded, regardless of which list is chosen.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>modMap</td> <td>Object</td> <td> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>dojo.platformRequire({
    browser: [
        "foo.sample", // simple module
        "foo.test",
        ["foo.bar.baz", true] // skip object check in _loadModule (dojo.require)
    ],
    default: [ "foo.sample._base" ],
    common: [ "important.module.common" ]
});</code></pre>       <h3 id="1_10dojo__base_kernel_popContext">
<code class="functionIcon">popContext</code><code class="parameters">()</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="configfirefoxextension.html">dojo/_base/configFirefoxExtension</a> </p> <p>If the context stack contains elements, ensure that subsequent code executes in the <em>previous</em> context to the current context. The current context set ([global, document]) is returned.</p>      <h3 id="1_10dojo__base_kernel_position">
<code class="functionIcon">position</code><code class="parameters">(node,includeScroll)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>Gets the position and size of the passed element relative to the viewport (if includeScroll==false), or relative to the document root (if includeScroll==true). </p>  <p>Returns an object of the form: <code>{ x: 100, y: 300, w: 20, h: 15 }</code>. If includeScroll==true, the x and y values will include any document offsets that may affect the position relative to the viewport. Uses the border-box model (inclusive of border and padding but not margin). Does not act as a setter.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td> </td> </tr> <tr> <td>includeScroll</td> <td>Boolean</td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Object | object</p>     <h3 id="1_10dojo__base_kernel_prop">
<code class="functionIcon">prop</code><code class="parameters">(node,name,value)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="html.html">dojo/_base/html</a> </p> <p>Gets or sets a property on an HTML element.</p>  <p>Handles normalized getting and setting of properties on DOM Nodes. If 2 arguments are passed, and a the second argument is a string, acts as a getter. </p> <p>If a third argument is passed, or if the second argument is a map of attributes, acts as a setter. </p> <p>When passing functions as values, note that they will not be directly assigned to slots on the node, but rather the default behavior will be removed and the new behavior will be added using <code>dojo.connect()</code>, meaning that event handler properties will be normalized and that some caveats with regards to non-standard behaviors for onsubmit apply. Namely that you should cancel form submission using <code>dojo.stopEvent()</code> on the passed event object instead of returning a boolean value from the handler itself.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DomNode | String</td> <td>
<p>id or reference to the element to get or set the property on</p> </td> </tr> <tr> <td>name</td> <td>String | Object</td> <td>
<p>the name of the property to get or set.</p> </td> </tr> <tr> <td>value</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>The value to set for the property</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>when used as a getter, the value of the requested property or null if that attribute does not have a specified or default value; </p> <p>when used as a setter, the DOM node </p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// get the current value of the "foo" property on a node
dojo.prop(dojo.byId("nodeId"), "foo");
// or we can just pass the id:
dojo.prop("nodeId", "foo");</code></pre>   <h3>Example 2</h3><pre data-language="javascript"><code>// use prop() to set the tab index
dojo.prop("nodeId", "tabIndex", 3);</code></pre>   <h3>Example 3</h3><p>Set multiple values at once, including event handlers: </p> <pre data-language="javascript"><code>dojo.prop("formId", {
    "foo": "bar",
    "tabIndex": -1,
    "method": "POST",
    "onsubmit": function(e){
        // stop submitting the form. Note that the IE behavior
        // of returning true or false will have no effect here
        // since our handler is connect()ed to the built-in
        // onsubmit behavior and so we need to use
        // dojo.stopEvent() to ensure that the submission
        // doesn't proceed.
        dojo.stopEvent(e);

        // submit the form with Ajax
        dojo.xhrPost({ form: "formId" });
    }
});</code></pre>   <h3>Example 4</h3><p>Style is s special case: Only set with an object hash of styles </p> <pre data-language="javascript"><code>dojo.prop("someNode",{
    id:"bar",
    style:{
        width:"200px", height:"100px", color:"#000"
    }
});</code></pre>   <h3>Example 5</h3><p>Again, only set style as an object hash of styles: </p> <pre data-language="javascript"><code>var obj = { color:"#fff", backgroundColor:"#000" };
dojo.prop("someNode", "style", obj);

// though shorter to use `dojo.style()` in this case:
dojo.style("someNode", obj);</code></pre>       <h3 id="1_10dojo__base_kernel_provide">
<code class="functionIcon">provide</code><code class="parameters">(mid)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="loader.html">dojo/_base/loader</a> </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>mid</td> <td>undefined</td> <td> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_pushContext">
<code class="functionIcon">pushContext</code><code class="parameters">(g,d)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="configfirefoxextension.html">dojo/_base/configFirefoxExtension</a> </p> <p>causes subsequent calls to Dojo methods to assume the passed object and, optionally, document as the default scopes to use. A 2-element array of the previous global and document are returned.</p>  <p>dojo.pushContext treats contexts as a stack. The auto-detected contexts which are initially provided using dojo.setContext() require authors to keep state in order to "return" to a previous context, whereas the dojo.pushContext and dojo.popContext methods provide a more natural way to augment blocks of code to ensure that they execute in a different window or frame without issue. If called without any arguments, the default context (the context when Dojo is first loaded) is instead pushed into the stack. If only a single string is passed, a node in the intitial context's document is looked up and its contextWindow and contextDocument properties are used as the context to push. This means that iframes can be given an ID and code can be executed in the scope of the iframe's document in subsequent calls easily.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>g</td> <td>Object | String</td> <td> <div><em>Optional</em></div>
<p>The global context. If a string, the id of the frame to search for a context and document.</p> </td> </tr> <tr> <td>d</td> <td>MDocumentElement</td> <td> <div><em>Optional</em></div>
<p>The document element to execute subsequent code with.</p> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_queryToObject">
<code class="functionIcon">queryToObject</code><code class="parameters">(str)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../io-query.html">dojo/io-query</a> </p> <p>Create an object representing a de-serialized query section of a URL. Query keys with multiple values are returned in an array. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>str</td> <td>String</td> <td> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>object</p>  <h2>Examples</h2>  <h3>Example 1</h3><p>This string: </p> <pre data-language="javascript"><code>"foo=bar&amp;foo=baz&amp;thinger=%20spaces%20=blah&amp;zonk=blarg&amp;"</code></pre> <p>results in this object structure: </p> <pre data-language="javascript"><code>{
    foo: [ "bar", "baz" ],
    thinger: " spaces =blah",
    zonk: "blarg"
}</code></pre> <p>Note that spaces and other urlencoded entities are correctly handled.</p>       <h3 id="1_10dojo__base_kernel_rawXhrPost">
<code class="functionIcon">rawXhrPost</code><code class="parameters">(args)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="xhr.html">dojo/_base/xhr</a> </p> <p>Sends an HTTP POST request to the server. In addition to the properties listed for the dojo.__XhrArgs type, the following property is allowed:</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>args</td> <td>Object</td> <td>
<p>An object with the following properties:</p>
<ul>
<li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional, json-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p> </li>
<li>sync (Boolean, optional): <p>false is default. Indicates whether the request should be a synchronous (blocking) request.</p> </li>
<li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p> </li>
<li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be allowed to fail (and therefore no console error message in the event of a failure)</p> </li>
<li>contentType (String|Boolean): <p>"application/x-www-form-urlencoded" is default. Set to false to prevent a Content-Type header from being sent, or to a string to send a different Content-Type.</p> </li>
<li>load: <p>This function will be called on a successful HTTP response code.</p> </li>
<li>error: <p>This function will be called when the request fails due to a network or server error, the url is invalid, etc. It will also be called if the load or handle callback throws an exception, unless djConfig.debugAtAllCosts is true. This allows deployed applications to continue to run even when a logic error happens in the callback, while making it easier to troubleshoot while in debug mode.</p> </li>
<li>handle: <p>This function will be called at the end of every request, whether or not an error occurs.</p> </li>
<li>url (String): <p>URL to server endpoint.</p> </li>
<li>content (Object, optional): <p>Contains properties with string values. These properties will be serialized as name1=value2 and passed in the request.</p> </li>
<li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time passes, the then error callbacks are called.</p> </li>
<li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values and send to the server.</p> </li>
<li>preventCache (Boolean, optional): <p>Default is false. If true, then a "dojo.preventCache" parameter is sent in the request with a value that changes with each request (timestamp). Useful only with GET-type requests.</p> </li>
<li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content property is ignored. This is mostly useful for HTTP methods that have a body to their requests, like PUT or POST. This property can be used instead of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p> </li>
<li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to IO operations. Otherwise, if djConfig.ioPublish is set to true, topics will be published via dojo/topic.publish() for different phases of an IO operation. See dojo/main.__IoPublish for a list of topics that are published.</p> </li>
</ul> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_rawXhrPut">
<code class="functionIcon">rawXhrPut</code><code class="parameters">(args)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="xhr.html">dojo/_base/xhr</a> </p> <p>Sends an HTTP PUT request to the server. In addition to the properties listed for the dojo.__XhrArgs type, the following property is allowed:</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>args</td> <td>Object</td> <td>
<p>An object with the following properties:</p>
<ul>
<li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional, json-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p> </li>
<li>sync (Boolean, optional): <p>false is default. Indicates whether the request should be a synchronous (blocking) request.</p> </li>
<li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p> </li>
<li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be allowed to fail (and therefore no console error message in the event of a failure)</p> </li>
<li>contentType (String|Boolean): <p>"application/x-www-form-urlencoded" is default. Set to false to prevent a Content-Type header from being sent, or to a string to send a different Content-Type.</p> </li>
<li>load: <p>This function will be called on a successful HTTP response code.</p> </li>
<li>error: <p>This function will be called when the request fails due to a network or server error, the url is invalid, etc. It will also be called if the load or handle callback throws an exception, unless djConfig.debugAtAllCosts is true. This allows deployed applications to continue to run even when a logic error happens in the callback, while making it easier to troubleshoot while in debug mode.</p> </li>
<li>handle: <p>This function will be called at the end of every request, whether or not an error occurs.</p> </li>
<li>url (String): <p>URL to server endpoint.</p> </li>
<li>content (Object, optional): <p>Contains properties with string values. These properties will be serialized as name1=value2 and passed in the request.</p> </li>
<li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time passes, the then error callbacks are called.</p> </li>
<li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values and send to the server.</p> </li>
<li>preventCache (Boolean, optional): <p>Default is false. If true, then a "dojo.preventCache" parameter is sent in the request with a value that changes with each request (timestamp). Useful only with GET-type requests.</p> </li>
<li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content property is ignored. This is mostly useful for HTTP methods that have a body to their requests, like PUT or POST. This property can be used instead of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p> </li>
<li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to IO operations. Otherwise, if djConfig.ioPublish is set to true, topics will be published via dojo/topic.publish() for different phases of an IO operation. See dojo/main.__IoPublish for a list of topics that are published.</p> </li>
</ul> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_ready">
<code class="functionIcon">ready</code><code class="parameters">(priority,context,callback)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../ready.html">dojo/ready</a> </p> <p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated. In most cases, the <code>domReady</code> plug-in should suffice and this method should not be needed. </p> <p>When called in a non-browser environment, just checks that all requested modules have arrived and been evaluated.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>priority</td> <td>Integer</td> <td> <div><em>Optional</em></div>
<p>The order in which to exec this callback relative to other callbacks, defaults to 1000</p> </td> </tr> <tr> <td>context</td> <td>undefined</td> <td>
<p>The context in which to run execute callback, or a callback if not using context</p> </td> </tr> <tr> <td>callback</td> <td>Function</td> <td> <div><em>Optional</em></div>
<p>The function to execute. </p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><p>Simple DOM and Modules ready syntax </p> <pre data-language="javascript"><code>require(["dojo/ready"], function(ready){
    ready(function(){ alert("Dom ready!"); });
});</code></pre>   <h3>Example 2</h3><p>Using a priority </p> <pre data-language="javascript"><code>require(["dojo/ready"], function(ready){
    ready(2, function(){ alert("low priority ready!"); })
});</code></pre>   <h3>Example 3</h3><p>Using context </p> <pre data-language="javascript"><code>require(["dojo/ready"], function(ready){
    ready(foo, function(){
        // in here, this == foo
    });
});</code></pre>   <h3>Example 4</h3><p>Using dojo/hitch style args: </p> <pre data-language="javascript"><code>require(["dojo/ready"], function(ready){
    var foo = { dojoReady: function(){ console.warn(this, "dojo dom and modules ready."); } };
    ready(foo, "dojoReady");
});</code></pre>       <h3 id="1_10dojo__base_kernel_registerModulePath">
<code class="functionIcon">registerModulePath</code><code class="parameters">(moduleName,prefix)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="loader.html">dojo/_base/loader</a> </p> <p>Maps a module name to a path</p>  <p>An unregistered module is given the default path of ../[module], relative to Dojo root. For example, module acme is mapped to ../acme. If you want to use a different module name, use dojo.registerModulePath.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>moduleName</td> <td>String</td> <td> </td> </tr> <tr> <td>prefix</td> <td>String</td> <td> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><p>If your dojo.js is located at this location in the web root: </p> <pre data-language="javascript"><code>/myapp/js/dojo/dojo/dojo.js</code></pre> <p>and your modules are located at: </p> <pre data-language="javascript"><code>/myapp/js/foo/bar.js
/myapp/js/foo/baz.js
/myapp/js/foo/thud/xyzzy.js</code></pre> <p>Your application can tell Dojo to locate the "foo" namespace by calling: </p> <pre data-language="javascript"><code>dojo.registerModulePath("foo", "../../foo");</code></pre> <p>At which point you can then use dojo.require() to load the </p> <p>modules (assuming they provide() the same things which are required). The full code might be: </p> <pre data-language="markup"><code>&lt;script type="text/javascript"
    src="/myapp/js/dojo/dojo/dojo.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    dojo.registerModulePath("foo", "../../foo");
    dojo.require("foo.bar");
    dojo.require("foo.baz");
    dojo.require("foo.thud.xyzzy");
&lt;/script&gt;</code></pre>       <h3 id="1_10dojo__base_kernel_removeAttr">
<code class="functionIcon">removeAttr</code><code class="parameters">(node,name)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-attr.html">dojo/dom-attr</a> </p> <p>Removes an attribute from an HTML element.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>id or reference to the element to remove the attribute from</p> </td> </tr> <tr> <td>name</td> <td>String</td> <td>
<p>the name of the attribute to remove</p> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_removeClass">
<code class="functionIcon">removeClass</code><code class="parameters">(node,classStr)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-class.html">dojo/dom-class</a> </p> <p>Removes the specified classes from node. No <code>contains()</code> check is required. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>String | DOMNode</td> <td>
<p>String ID or DomNode reference to remove the class from. </p> </td> </tr> <tr> <td>classStr</td> <td>String | Array</td> <td> <div><em>Optional</em></div>
<p>An optional String class name to remove, or several space-separated class names, or an array of class names. If omitted, all class names will be deleted. </p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><p>Remove a class from some node: </p> <pre data-language="javascript"><code>require(["dojo/dom-class"], function(domClass){
    domClass.remove("someNode", "firstClass");
});</code></pre>   <h3>Example 2</h3><p>Remove two classes from some node: </p> <pre data-language="javascript"><code>require(["dojo/dom-class"], function(domClass){
    domClass.remove("someNode", "firstClass secondClass");
});</code></pre>   <h3>Example 3</h3><p>Remove two classes from some node (using array): </p> <pre data-language="javascript"><code>require(["dojo/dom-class"], function(domClass){
    domClass.remove("someNode", ["firstClass", "secondClass"]);
});</code></pre>   <h3>Example 4</h3><p>Remove all classes from some node: </p> <pre data-language="javascript"><code>require(["dojo/dom-class"], function(domClass){
    domClass.remove("someNode");
});</code></pre>   <h3>Example 5</h3><p>Available in <code>dojo/NodeList</code> for multiple removal </p> <pre data-language="javascript"><code>require(["dojo/query"], function(query){
    query("ul &gt; li").removeClass("foo");
});</code></pre>       <h3 id="1_10dojo__base_kernel_replaceClass">
<code class="functionIcon">replaceClass</code><code class="parameters">(node,addClassStr,removeClassStr)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-class.html">dojo/dom-class</a> </p> <p>Replaces one or more classes on a node if not present. Operates more quickly than calling dojo.removeClass and dojo.addClass </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>String | DOMNode</td> <td>
<p>String ID or DomNode reference to remove the class from. </p> </td> </tr> <tr> <td>addClassStr</td> <td>String | Array</td> <td>
<p>A String class name to add, or several space-separated class names, or an array of class names. </p> </td> </tr> <tr> <td>removeClassStr</td> <td>String | Array</td> <td> <div><em>Optional</em></div>
<p>A String class name to remove, or several space-separated class names, or an array of class names. </p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>require(["dojo/dom-class"], function(domClass){
    domClass.replace("someNode", "add1 add2", "remove1 remove2");
});</code></pre>   <h3>Example 2</h3><p>Replace all classes with addMe </p> <pre data-language="javascript"><code>require(["dojo/dom-class"], function(domClass){
    domClass.replace("someNode", "addMe");
});</code></pre>   <h3>Example 3</h3><p>Available in <code>dojo/NodeList</code> for multiple toggles </p> <pre data-language="javascript"><code>require(["dojo/query"], function(query){
    query(".findMe").replaceClass("addMe", "removeMe");
});</code></pre>       <h3 id="1_10dojo__base_kernel_require">
<code class="functionIcon">require</code><code class="parameters">(moduleName,omitModuleCheck)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="loader.html">dojo/_base/loader</a> </p> <p>loads a Javascript module from the appropriate URI </p>  <p>Modules are loaded via dojo.require by using one of two loaders: the normal loader and the xdomain loader. The xdomain loader is used when dojo was built with a custom build that specified loader=xdomain and the module lives on a modulePath that is a whole URL, with protocol and a domain. The versions of Dojo that are on the Google and AOL CDNs use the xdomain loader. </p> <p>If the module is loaded via the xdomain loader, it is an asynchronous load, since the module is added via a dynamically created script tag. This means that dojo.require() can return before the module has loaded. However, this should only happen in the case where you do dojo.require calls in the top-level HTML page, or if you purposely avoid the loader checking for dojo.require dependencies in your module by using a syntax like dojo["require"] to load the module. </p> <p>Sometimes it is useful to not have the loader detect the dojo.require calls in the module so that you can dynamically load the modules as a result of an action on the page, instead of right at module load time. </p> <p>Also, for script blocks in an HTML page, the loader does not pre-process them, so it does not know to download the modules before the dojo.require calls occur. </p> <p>So, in those two cases, when you want on-the-fly module loading or for script blocks in the HTML page, special care must be taken if the dojo.required code is loaded asynchronously. To make sure you can execute code that depends on the dojo.required modules, be sure to add the code that depends on the modules in a dojo.addOnLoad() callback. dojo.addOnLoad waits for all outstanding modules to finish loading before executing. </p> <p>This type of syntax works with both xdomain and normal loaders, so it is good practice to always use this idiom for on-the-fly code loading and in HTML script blocks. If at some point you change loaders and where the code is loaded from, it will all still work. </p> <p>More on how dojo.require <code>dojo.require("A.B")</code> first checks to see if symbol A.B is defined. If it is, it is simply returned (nothing to do). </p> <p>If it is not defined, it will look for <code>A/B.js</code> in the script root directory. </p> <p><code>dojo.require</code> throws an exception if it cannot find a file to load, or if the symbol <code>A.B</code> is not defined after loading. </p> <p>It returns the object <code>A.B</code>, but note the caveats above about on-the-fly loading and HTML script blocks when the xdomain loader is loading a module. </p> <p><code>dojo.require()</code> does nothing about importing symbols into the current namespace. It is presumed that the caller will take care of that. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>moduleName</td> <td>String</td> <td>
<p>module name to load, using periods for separators, e.g. "dojo.date.locale". Module paths are de-referenced by dojo's internal mapping of locations to names and are disambiguated by longest prefix. See <code>dojo.registerModulePath()</code> for details on registering new modules. </p> </td> </tr> <tr> <td>omitModuleCheck</td> <td>Boolean</td> <td> <div><em>Optional</em></div>
<p>if <code>true</code>, omitModuleCheck skips the step of ensuring that the loaded file actually defines the symbol it is referenced by. For example if it called as <code>dojo.require("a.b.c")</code> and the file located at <code>a/b/c.js</code> does not define an object <code>a.b.c</code>, and exception will be throws whereas no exception is raised when called as <code>dojo.require("a.b.c", true)</code> </p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any</p> <p>the required namespace object</p>   <h2>Examples</h2>  <h3>Example 1</h3><p>To use dojo.require in conjunction with dojo.ready: </p> <pre data-language="javascript"><code>dojo.require("foo");
dojo.require("bar");
dojo.addOnLoad(function(){
    //you can now safely do something with foo and bar
});</code></pre>   <h3>Example 2</h3><p>For example, to import all symbols into a local block, you might write: </p> <pre data-language="javascript"><code>with (dojo.require("A.B")) {
    ...
}</code></pre> <p>And to import just the leaf symbol to a local variable: </p> <pre data-language="javascript"><code>var B = dojo.require("A.B");
...</code></pre>       <h3 id="1_10dojo__base_kernel_requireAfterIf">
<code class="functionIcon">requireAfterIf</code><code class="parameters">(condition,moduleName,omitModuleCheck)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="loader.html">dojo/_base/loader</a> </p> <p>If the condition is true then call <code>dojo.require()</code> for the specified resource </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>condition</td> <td>Boolean</td> <td> </td> </tr> <tr> <td>moduleName</td> <td>String</td> <td> </td> </tr> <tr> <td>omitModuleCheck</td> <td>Boolean</td> <td> <div><em>Optional</em></div> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>dojo.requireIf(dojo.isBrowser, "my.special.Module");</code></pre>       <h3 id="1_10dojo__base_kernel_requireIf">
<code class="functionIcon">requireIf</code><code class="parameters">(condition,moduleName,omitModuleCheck)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="loader.html">dojo/_base/loader</a> </p> <p>If the condition is true then call <code>dojo.require()</code> for the specified resource </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>condition</td> <td>Boolean</td> <td> </td> </tr> <tr> <td>moduleName</td> <td>String</td> <td> </td> </tr> <tr> <td>omitModuleCheck</td> <td>Boolean</td> <td> <div><em>Optional</em></div> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>dojo.requireIf(dojo.isBrowser, "my.special.Module");</code></pre>       <h3 id="1_10dojo__base_kernel_requireLocalization">
<code class="functionIcon">requireLocalization</code><code class="parameters">(moduleName,bundleName,locale)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="loader.html">dojo/_base/loader</a> </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>moduleName</td> <td>String</td> <td> </td> </tr> <tr> <td>bundleName</td> <td>String</td> <td> </td> </tr> <tr> <td>locale</td> <td>String</td> <td> <div><em>Optional</em></div> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_safeMixin">
<code class="functionIcon">safeMixin</code><code class="parameters">(target,source)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="declare.html">dojo/_base/declare</a> </p> <p>Mix in properties skipping a constructor and decorating functions like it is done by declare().</p>  <p>This function is used to mix in properties like lang.mixin does, but it skips a constructor property and decorates functions like declare() does. </p> <p>It is meant to be used with classes and objects produced with declare. Functions mixed in with dojo.safeMixin can use this.inherited() like normal methods. </p> <p>This function is used to implement extend() method of a constructor produced with declare(). </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>target</td> <td>Object</td> <td>
<p>Target object to accept new properties.</p> </td> </tr> <tr> <td>source</td> <td>Object</td> <td>
<p>Source object for new properties.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Object</p> <p>Target object to accept new properties.</p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var A = declare(null, {
    m1: function(){
        console.log("A.m1");
    },
    m2: function(){
        console.log("A.m2");
    }
});
var B = declare(A, {
    m1: function(){
        this.inherited(arguments);
        console.log("B.m1");
    }
});
B.extend({
    m2: function(){
        this.inherited(arguments);
        console.log("B.m2");
    }
});
var x = new B();
dojo.safeMixin(x, {
    m1: function(){
        this.inherited(arguments);
        console.log("X.m1");
    },
    m2: function(){
        this.inherited(arguments);
        console.log("X.m2");
    }
});
x.m2();
// prints:
// A.m1
// B.m1
// X.m1</code></pre>       <h3 id="1_10dojo__base_kernel_setAttr">
<code class="functionIcon">setAttr</code><code class="parameters">(node,name,value)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-attr.html">dojo/dom-attr</a> </p> <p>Sets an attribute on an HTML element.</p>  <p>Handles normalized setting of attributes on DOM Nodes. </p> <p>When passing functions as values, note that they will not be directly assigned to slots on the node, but rather the default behavior will be removed and the new behavior will be added using <code>dojo.connect()</code>, meaning that event handler properties will be normalized and that some caveats with regards to non-standard behaviors for onsubmit apply. Namely that you should cancel form submission using <code>dojo.stopEvent()</code> on the passed event object instead of returning a boolean value from the handler itself.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>id or reference to the element to set the attribute on</p> </td> </tr> <tr> <td>name</td> <td>String | Object</td> <td>
<p>the name of the attribute to set, or a hash of key-value pairs to set.</p> </td> </tr> <tr> <td>value</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>the value to set for the attribute, if the name is a string.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any | undefined</p> <p>the DOM node </p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// use attr() to set the tab index
require(["dojo/dom-attr"], function(domAttr){
    domAttr.set("nodeId", "tabIndex", 3);
});</code></pre>   <h3>Example 2</h3><p>Set multiple values at once, including event handlers: </p> <pre data-language="javascript"><code>require(["dojo/dom-attr"],
function(domAttr){
    domAttr.set("formId", {
        "foo": "bar",
        "tabIndex": -1,
        "method": "POST"
    }
});</code></pre>       <h3 id="1_10dojo__base_kernel_setContentSize">
<code class="functionIcon">setContentSize</code><code class="parameters">(node,box,computedStyle)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>Sets the size of the node's contents, irrespective of margins, padding, or borders.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode</td> <td> </td> </tr> <tr> <td>box</td> <td>Object</td> <td>
<p>hash with optional "w", and "h" properties for "width", and "height" respectively. All specified properties should have numeric values in whole pixels.</p> </td> </tr> <tr> <td>computedStyle</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>This parameter accepts computed styles object. If this parameter is omitted, the functions will call dojo/dom-style.getComputedStyle to get one. It is a better way, calling dojo/dom-style.getComputedStyle once, and then pass the reference to this computedStyle parameter. Wherever possible, reuse the returned object of dojo/dom-style.getComputedStyle().</p> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_setContext">
<code class="functionIcon">setContext</code><code class="parameters">(globalObject,globalDocument)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="window.html">dojo/_base/window</a> </p> <p>changes the behavior of many core Dojo functions that deal with namespace and DOM lookup, changing them to work in a new global context (e.g., an iframe). The varibles dojo.global and dojo.doc are modified as a result of calling this function and the result of <code>dojo.body()</code> likewise differs.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>globalObject</td> <td>Object</td> <td> </td> </tr> <tr> <td>globalDocument</td> <td>DocumentElement</td> <td> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_setMarginBox">
<code class="functionIcon">setMarginBox</code><code class="parameters">(node,box,computedStyle)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-geometry.html">dojo/dom-geometry</a> </p> <p>sets the size of the node's margin box and placement (left/top), irrespective of box model. Think of it as a passthrough to setBox that handles box-model vagaries for you.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode</td> <td> </td> </tr> <tr> <td>box</td> <td>Object</td> <td>
<p>hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height" respectively. All specified properties should have numeric values in whole pixels.</p> </td> </tr> <tr> <td>computedStyle</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>This parameter accepts computed styles object. If this parameter is omitted, the functions will call dojo/dom-style.getComputedStyle to get one. It is a better way, calling dojo/dom-style.getComputedStyle once, and then pass the reference to this computedStyle parameter. Wherever possible, reuse the returned object of dojo/dom-style.getComputedStyle().</p> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_setProp">
<code class="functionIcon">setProp</code><code class="parameters">(node,name,value)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-prop.html">dojo/dom-prop</a> </p> <p>Sets a property on an HTML element.</p>  <p>Handles normalized setting of properties on DOM nodes. </p> <p>When passing functions as values, note that they will not be directly assigned to slots on the node, but rather the default behavior will be removed and the new behavior will be added using <code>dojo.connect()</code>, meaning that event handler properties will be normalized and that some caveats with regards to non-standard behaviors for onsubmit apply. Namely that you should cancel form submission using <code>dojo.stopEvent()</code> on the passed event object instead of returning a boolean value from the handler itself.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>id or reference to the element to set the property on</p> </td> </tr> <tr> <td>name</td> <td>String | Object</td> <td>
<p>the name of the property to set, or a hash object to set multiple properties at once.</p> </td> </tr> <tr> <td>value</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>The value to set for the property</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any | undefined</p> <p>the DOM node </p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// use prop() to set the tab index
require(["dojo/dom-prop"], function(domProp){
    domProp.set("nodeId", "tabIndex", 3);
});</code></pre>   <h3>Example 2</h3><p>Set multiple values at once, including event handlers: </p> <pre data-language="javascript"><code>require(["dojo/dom-prop"], function(domProp){
    domProp.set("formId", {
        "foo": "bar",
        "tabIndex": -1,
        "method": "POST",
    });
});</code></pre>       <h3 id="1_10dojo__base_kernel_setSelectable">
<code class="functionIcon">setSelectable</code><code class="parameters">(node,selectable)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom.html">dojo/dom</a> </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>undefined</td> <td> </td> </tr> <tr> <td>selectable</td> <td>undefined</td> <td> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_setStyle">
<code class="functionIcon">setStyle</code><code class="parameters">(node,name,value)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-style.html">dojo/dom-style</a> </p> <p>Sets styles on a node.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>id or reference to node to set style for</p> </td> </tr> <tr> <td>name</td> <td>String | Object</td> <td>
<p>the style property to set in DOM-accessor format ("borderWidth", not "border-width") or an object with key/value pairs suitable for setting each property.</p> </td> </tr> <tr> <td>value</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>If passed, sets value on the node for style, handling cross-browser concerns. When setting a pixel value, be sure to include "px" in the value. For instance, top: "200px". Otherwise, in some cases, some browsers will not apply the style. </p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>String | undefined</p> <p>If passed, sets value on the node for style, handling cross-browser concerns. When setting a pixel value, be sure to include "px" in the value. For instance, top: "200px". Otherwise, in some cases, some browsers will not apply the style. </p>   <h2>Examples</h2>  <h3>Example 1</h3><p>Passing a node, a style property, and a value changes the current display of the node and returns the new computed value </p> <pre data-language="javascript"><code>require(["dojo/dom-style"], function(domStyle){
    domStyle.set("thinger", "opacity", 0.5); // == 0.5
});</code></pre>   <h3>Example 2</h3><p>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node: </p> <pre data-language="javascript"><code>require(["dojo/dom-style"], function(domStyle){
    domStyle.set("thinger", {
        "opacity": 0.5,
        "border": "3px solid black",
        "height": "300px"
    });
});</code></pre>   <h3>Example 3</h3><p>When the CSS style property is hyphenated, the JavaScript property is camelCased. font-size becomes fontSize, and so on. </p> <pre data-language="javascript"><code>require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
    domStyle.set("thinger",{
        fontSize:"14pt",
        letterSpacing:"1.2em"
    });
});</code></pre>   <h3>Example 4</h3><p>dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling dojo/dom-style.get() on every element of the list. See: <code>dojo/query</code> and <code>dojo/NodeList</code> </p> <pre data-language="javascript"><code>require(["dojo/dom-style", "dojo/query", "dojo/NodeList-dom"],
function(domStyle, query){
    query(".someClassName").style("visibility","hidden");
    // or
    query("#baz &gt; div").style({
        opacity:0.75,
        fontSize:"13pt"
    });
});</code></pre>       <h3 id="1_10dojo__base_kernel_some">
<code class="functionIcon">some</code><code class="parameters">(arr,callback,thisObject)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="array.html">dojo/_base/array</a> </p> <p>Determines whether or not any item in arr satisfies the condition implemented by callback.</p>  <p>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when run over sparse arrays, this implementation passes the "holes" in the sparse array to the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array. For more details, see: <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some</a></p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>arr</td> <td>Array | String</td> <td>
<p>the array to iterate over. If a string, operates on individual characters.</p> </td> </tr> <tr> <td>callback</td> <td>Function | String</td> <td>
<p>a function is invoked with three arguments: item, index, and array and returns true if the condition is met.</p> </td> </tr> <tr> <td>thisObject</td> <td>Object</td> <td> <div><em>Optional</em></div>
<p>may be used to scope the call to callback</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Boolean</p>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>// is true
array.some([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>   <h3>Example 2</h3><pre data-language="javascript"><code>// is false
array.some([1, 2, 3, 4], function(item){ return item&lt;1; });</code></pre>       <h3 id="1_10dojo__base_kernel_Stateful">
<code class="functionIcon">Stateful</code><code class="parameters">()</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../stateful.html">dojo/Stateful</a> </p>      <h3 id="1_10dojo__base_kernel_stopEvent">
<code class="functionIcon">stopEvent</code><code class="parameters">(evt)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="event.html">dojo/_base/event</a> </p> <p>prevents propagation and clobbers the default action of the passed event</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>evt</td> <td>Event</td> <td>
<p>The event object. If omitted, window.event is used on IE.</p> </td> </tr> </table>     <h3 id="1_10dojo__base_kernel_style">
<code class="functionIcon">style</code><code class="parameters">(node,name,value)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="html.html">dojo/_base/html</a> </p> <p>Accesses styles on a node. If 2 arguments are passed, acts as a getter. If 3 arguments are passed, acts as a setter.</p>  <p>Getting the style value uses the computed style for the node, so the value will be a calculated value, not just the immediate node.style value. Also when getting values, use specific style names, like "borderBottomWidth" instead of "border" since compound values like "border" are not necessarily reflected as expected. If you want to get node dimensions, use <code>dojo.marginBox()</code>, <code>dojo.contentBox()</code> or <code>dojo.position()</code>.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode | String</td> <td>
<p>id or reference to node to get/set style for</p> </td> </tr> <tr> <td>name</td> <td>String | Object</td> <td> <div><em>Optional</em></div>
<p>the style property to set in DOM-accessor format ("borderWidth", not "border-width") or an object with key/value pairs suitable for setting each property.</p> </td> </tr> <tr> <td>value</td> <td>String</td> <td> <div><em>Optional</em></div>
<p>If passed, sets value on the node for style, handling cross-browser concerns. When setting a pixel value, be sure to include "px" in the value. For instance, top: "200px". Otherwise, in some cases, some browsers will not apply the style.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any | undefined</p> <p>when used as a getter, return the computed style of the node if passing in an ID or node, or return the normalized, computed value for the property when passing in a node and a style property</p>   <h2>Examples</h2>  <h3>Example 1</h3><p>Passing only an ID or node returns the computed style object of the node: </p> <pre data-language="javascript"><code>dojo.style("thinger");</code></pre>   <h3>Example 2</h3><p>Passing a node and a style property returns the current normalized, computed value for that property: </p> <pre data-language="javascript"><code>dojo.style("thinger", "opacity"); // 1 by default</code></pre>   <h3>Example 3</h3><p>Passing a node, a style property, and a value changes the current display of the node and returns the new computed value </p> <pre data-language="javascript"><code>dojo.style("thinger", "opacity", 0.5); // == 0.5</code></pre>   <h3>Example 4</h3><p>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node: </p> <pre data-language="javascript"><code>dojo.style("thinger", {
    "opacity": 0.5,
    "border": "3px solid black",
    "height": "300px"
});</code></pre>   <h3>Example 5</h3><p>When the CSS style property is hyphenated, the JavaScript property is camelCased. font-size becomes fontSize, and so on. </p> <pre data-language="javascript"><code>dojo.style("thinger",{
    fontSize:"14pt",
    letterSpacing:"1.2em"
});</code></pre>   <h3>Example 6</h3><p>dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling dojo.style() on every element of the list. See: <code>dojo/query</code> and <code>dojo/NodeList</code> </p> <pre data-language="javascript"><code>dojo.query(".someClassName").style("visibility","hidden");
// or
dojo.query("#baz &gt; div").style({
    opacity:0.75,
    fontSize:"13pt"
});</code></pre>       <h3 id="1_10dojo__base_kernel_toDom">
<code class="functionIcon">toDom</code><code class="parameters">(frag,doc)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-construct.html">dojo/dom-construct</a> </p> <p>instantiates an HTML fragment returning the corresponding DOM.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>frag</td> <td>String</td> <td>
<p>the HTML fragment</p> </td> </tr> <tr> <td>doc</td> <td>DocumentNode</td> <td> <div><em>Optional</em></div>
<p>optional document to use when creating DOM nodes, defaults to dojo/_base/window.doc if not specified.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any | undefined</p> <p>Document fragment, unless it's a single node in which case it returns the node itself</p>   <h2>Examples</h2>  <h3>Example 1</h3><p>Create a table row: </p> <pre data-language="javascript"><code>require(["dojo/dom-construct"], function(domConstruct){
    var tr = domConstruct.toDom("&lt;tr&gt;&lt;td&gt;First!&lt;/td&gt;&lt;/tr&gt;");
});</code></pre>       <h3 id="1_10dojo__base_kernel_toggleClass">
<code class="functionIcon">toggleClass</code><code class="parameters">(node,classStr,condition)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-class.html">dojo/dom-class</a> </p> <p>Adds a class to node if not present, or removes if present. Pass a boolean condition if you want to explicitly add or remove. Returns the condition that was specified directly or indirectly. </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>String | DOMNode</td> <td>
<p>String ID or DomNode reference to toggle a class string </p> </td> </tr> <tr> <td>classStr</td> <td>String | Array</td> <td>
<p>A String class name to toggle, or several space-separated class names, or an array of class names. </p> </td> </tr> <tr> <td>condition</td> <td>Boolean</td> <td> <div><em>Optional</em></div>
<p>If passed, true means to add the class, false means to remove. Otherwise dojo.hasClass(node, classStr) is used to detect the class presence. </p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Boolean</p> <p>If passed, true means to add the class, false means to remove. Otherwise dojo.hasClass(node, classStr) is used to detect the class presence. </p>   <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>require(["dojo/dom-class"], function(domClass){
    domClass.toggle("someNode", "hovered");
});</code></pre>   <h3>Example 2</h3><p>Forcefully add a class </p> <pre data-language="javascript"><code>require(["dojo/dom-class"], function(domClass){
    domClass.toggle("someNode", "hovered", true);
});</code></pre>   <h3>Example 3</h3><p>Available in <code>dojo/NodeList</code> for multiple toggles </p> <pre data-language="javascript"><code>require(["dojo/query"], function(query){
    query(".toggleMe").toggleClass("toggleMe");
});</code></pre>       <h3 id="1_10dojo__base_kernel_toJson">
<code class="functionIcon">toJson</code><code class="parameters">(it,prettyPrint)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="json.html">dojo/_base/json</a> </p> <p>Returns a <a href="http://json.org">JSON</a> serialization of an object.</p>  <p>Returns a <a href="http://json.org">JSON</a> serialization of an object. Note that this doesn't check for infinite recursion, so don't do that! It is recommend that you use <a href="../json.html">dojo/json</a>'s stringify function for an lighter and faster implementation that matches the native JSON API and uses the native JSON serializer when available.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>it</td> <td>Object</td> <td>
<p>an object to be serialized. Objects may define their own serialization via a special "<strong>json</strong>" or "json" function property. If a specialized serializer has been defined, it will be used as a fallback. Note that in 1.6, toJson would serialize undefined, but this no longer supported since it is not supported by native JSON serializer.</p> </td> </tr> <tr> <td>prettyPrint</td> <td>Boolean</td> <td> <div><em>Optional</em></div>
<p>if true, we indent objects and arrays to make the output prettier. The variable <code>dojo.toJsonIndentStr</code> is used as the indent string -- to use something other than the default (tab), change that variable before calling dojo.toJson(). Note that if native JSON support is available, it will be used for serialization, and native implementations vary on the exact spacing used in pretty printing.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>any | undefined</p> <p>A JSON string serialization of the passed-in object.</p>   <h2>Examples</h2>  <h3>Example 1</h3><p>simple serialization of a trivial object </p> <pre data-language="javascript"><code>var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);</code></pre>   <h3>Example 2</h3><p>a custom serializer for an objects of a particular class: </p> <pre data-language="javascript"><code>dojo.declare("Furby", null, {
    furbies: "are strange",
    furbyCount: 10,
    __json__: function(){
    },
});</code></pre>       <h3 id="1_10dojo__base_kernel_toPixelValue">
<code class="functionIcon">toPixelValue</code><code class="parameters">(node,value)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../dom-style.html">dojo/dom-style</a> </p> <p>converts style value to pixels on IE or return a numeric value.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>node</td> <td>DOMNode</td> <td> </td> </tr> <tr> <td>value</td> <td>String</td> <td> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>Number</p>     <h3 id="1_10dojo__base_kernel_unsubscribe">
<code class="functionIcon">unsubscribe</code><code class="parameters">(handle)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="connect.html">dojo/_base/connect</a> </p> <p>Remove a topic listener.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>handle</td> <td>Handle</td> <td>
<p>The handle returned from a call to subscribe.</p> </td> </tr> </table>  <h2>Examples</h2>  <h3>Example 1</h3><pre data-language="javascript"><code>var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
...
dojo.unsubscribe(alerter);</code></pre>       <h3 id="1_10dojo__base_kernel_when">
<code class="functionIcon">when</code><code class="parameters">(valueOrPromise,callback,errback,progback)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="../when.html">dojo/when</a> </p> <p>Transparently applies callbacks to values and/or promises.</p>  <p>Accepts promises but also transparently handles non-promises. If no callbacks are provided returns a promise, regardless of the initial value. Foreign promises are converted. </p> <p>If callbacks are provided and the initial value is not a promise, the callback is executed immediately with no error handling. Returns a promise if the initial value is a promise, or the result of the callback otherwise.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>valueOrPromise</td> <td>undefined</td> <td>
<p>Either a regular value or an object with a <code>then()</code> method that follows the Promises/A specification.</p> </td> </tr> <tr> <td>callback</td> <td>Function</td> <td> <div><em>Optional</em></div>
<p>Callback to be invoked when the promise is resolved, or a non-promise is received.</p> </td> </tr> <tr> <td>errback</td> <td>Function</td> <td> <div><em>Optional</em></div>
<p>Callback to be invoked when the promise is rejected.</p> </td> </tr> <tr> <td>progback</td> <td>Function</td> <td> <div><em>Optional</em></div>
<p>Callback to be invoked when the promise emits a progress update.</p> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong><a href="../promise/promise.html">dojo/promise/Promise</a> | summary: | name:</p> <p>Promise, or if a callback is provided, the result of the callback.</p>      <h3 id="1_10dojo__base_kernel_windowUnloaded">
<code class="functionIcon">windowUnloaded</code><code class="parameters">()</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="configfirefoxextension.html">dojo/_base/configFirefoxExtension</a> </p> <p>signal fired by impending window destruction. You may use dojo.addOnWIndowUnload() or dojo.connect() to this method to perform page/application cleanup methods. See dojo.addOnWindowUnload for more info.</p>      <h3 id="1_10dojo__base_kernel_withDoc">
<code class="functionIcon">withDoc</code><code class="parameters">(documentObject,callback,thisObject,cbArguments)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="window.html">dojo/_base/window</a> </p> <p>Invoke callback with documentObject as dojo/_base/window::doc.</p>  <p>Invoke callback with documentObject as <a href="window.html">dojo/_base/window</a>::doc. If provided, callback will be executed in the context of object thisObject When callback() returns or throws an error, the <a href="window.html">dojo/_base/window</a>::doc will be restored to its previous state.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>documentObject</td> <td>DocumentElement</td> <td> </td> </tr> <tr> <td>callback</td> <td>Function</td> <td> </td> </tr> <tr> <td>thisObject</td> <td>Object</td> <td> <div><em>Optional</em></div> </td> </tr> <tr> <td>cbArguments</td> <td>Array</td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_withGlobal">
<code class="functionIcon">withGlobal</code><code class="parameters">(globalObject,callback,thisObject,cbArguments)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="window.html">dojo/_base/window</a> </p> <p>Invoke callback with globalObject as dojo.global and globalObject.document as dojo.doc.</p>  <p>Invoke callback with globalObject as dojo.global and globalObject.document as dojo.doc. If provided, globalObject will be executed in the context of object thisObject When callback() returns or throws an error, the dojo.global and dojo.doc will be restored to its previous state.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>globalObject</td> <td>Object</td> <td> </td> </tr> <tr> <td>callback</td> <td>Function</td> <td> </td> </tr> <tr> <td>thisObject</td> <td>Object</td> <td> <div><em>Optional</em></div> </td> </tr> <tr> <td>cbArguments</td> <td>Array</td> <td> <div><em>Optional</em></div> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_xhr">
<code class="functionIcon">xhr</code><code class="parameters">(method,args)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="http://dojotoolkit.org/api/1.10/dojox/rpc/Client">dojox/rpc/Client</a> </p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>method</td> <td>undefined</td> <td> </td> </tr> <tr> <td>args</td> <td>undefined</td> <td> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_xhrDelete">
<code class="functionIcon">xhrDelete</code><code class="parameters">(args)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="xhr.html">dojo/_base/xhr</a> </p> <p>Sends an HTTP DELETE request to the server.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>args</td> <td>Object</td> <td>
<p>An object with the following properties:</p>
<ul>
<li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional, json-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p> </li>
<li>sync (Boolean, optional): <p>false is default. Indicates whether the request should be a synchronous (blocking) request.</p> </li>
<li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p> </li>
<li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be allowed to fail (and therefore no console error message in the event of a failure)</p> </li>
<li>contentType (String|Boolean): <p>"application/x-www-form-urlencoded" is default. Set to false to prevent a Content-Type header from being sent, or to a string to send a different Content-Type.</p> </li>
<li>load: <p>This function will be called on a successful HTTP response code.</p> </li>
<li>error: <p>This function will be called when the request fails due to a network or server error, the url is invalid, etc. It will also be called if the load or handle callback throws an exception, unless djConfig.debugAtAllCosts is true. This allows deployed applications to continue to run even when a logic error happens in the callback, while making it easier to troubleshoot while in debug mode.</p> </li>
<li>handle: <p>This function will be called at the end of every request, whether or not an error occurs.</p> </li>
<li>url (String): <p>URL to server endpoint.</p> </li>
<li>content (Object, optional): <p>Contains properties with string values. These properties will be serialized as name1=value2 and passed in the request.</p> </li>
<li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time passes, the then error callbacks are called.</p> </li>
<li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values and send to the server.</p> </li>
<li>preventCache (Boolean, optional): <p>Default is false. If true, then a "dojo.preventCache" parameter is sent in the request with a value that changes with each request (timestamp). Useful only with GET-type requests.</p> </li>
<li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content property is ignored. This is mostly useful for HTTP methods that have a body to their requests, like PUT or POST. This property can be used instead of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p> </li>
<li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to IO operations. Otherwise, if djConfig.ioPublish is set to true, topics will be published via dojo/topic.publish() for different phases of an IO operation. See dojo/main.__IoPublish for a list of topics that are published.</p> </li>
</ul> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_xhrGet">
<code class="functionIcon">xhrGet</code><code class="parameters">(args)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="xhr.html">dojo/_base/xhr</a> </p> <p>Sends an HTTP GET request to the server.</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>args</td> <td>Object</td> <td>
<p>An object with the following properties:</p>
<ul>
<li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional, json-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p> </li>
<li>sync (Boolean, optional): <p>false is default. Indicates whether the request should be a synchronous (blocking) request.</p> </li>
<li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p> </li>
<li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be allowed to fail (and therefore no console error message in the event of a failure)</p> </li>
<li>contentType (String|Boolean): <p>"application/x-www-form-urlencoded" is default. Set to false to prevent a Content-Type header from being sent, or to a string to send a different Content-Type.</p> </li>
<li>load: <p>This function will be called on a successful HTTP response code.</p> </li>
<li>error: <p>This function will be called when the request fails due to a network or server error, the url is invalid, etc. It will also be called if the load or handle callback throws an exception, unless djConfig.debugAtAllCosts is true. This allows deployed applications to continue to run even when a logic error happens in the callback, while making it easier to troubleshoot while in debug mode.</p> </li>
<li>handle: <p>This function will be called at the end of every request, whether or not an error occurs.</p> </li>
<li>url (String): <p>URL to server endpoint.</p> </li>
<li>content (Object, optional): <p>Contains properties with string values. These properties will be serialized as name1=value2 and passed in the request.</p> </li>
<li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time passes, the then error callbacks are called.</p> </li>
<li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values and send to the server.</p> </li>
<li>preventCache (Boolean, optional): <p>Default is false. If true, then a "dojo.preventCache" parameter is sent in the request with a value that changes with each request (timestamp). Useful only with GET-type requests.</p> </li>
<li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content property is ignored. This is mostly useful for HTTP methods that have a body to their requests, like PUT or POST. This property can be used instead of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p> </li>
<li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to IO operations. Otherwise, if djConfig.ioPublish is set to true, topics will be published via dojo/topic.publish() for different phases of an IO operation. See dojo/main.__IoPublish for a list of topics that are published.</p> </li>
</ul> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_xhrPost">
<code class="functionIcon">xhrPost</code><code class="parameters">(args)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="xhr.html">dojo/_base/xhr</a> </p> <p>Sends an HTTP POST request to the server. In addition to the properties listed for the dojo.__XhrArgs type, the following property is allowed:</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>args</td> <td>Object</td> <td>
<p>An object with the following properties:</p>
<ul>
<li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional, json-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p> </li>
<li>sync (Boolean, optional): <p>false is default. Indicates whether the request should be a synchronous (blocking) request.</p> </li>
<li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p> </li>
<li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be allowed to fail (and therefore no console error message in the event of a failure)</p> </li>
<li>contentType (String|Boolean): <p>"application/x-www-form-urlencoded" is default. Set to false to prevent a Content-Type header from being sent, or to a string to send a different Content-Type.</p> </li>
<li>load: <p>This function will be called on a successful HTTP response code.</p> </li>
<li>error: <p>This function will be called when the request fails due to a network or server error, the url is invalid, etc. It will also be called if the load or handle callback throws an exception, unless djConfig.debugAtAllCosts is true. This allows deployed applications to continue to run even when a logic error happens in the callback, while making it easier to troubleshoot while in debug mode.</p> </li>
<li>handle: <p>This function will be called at the end of every request, whether or not an error occurs.</p> </li>
<li>url (String): <p>URL to server endpoint.</p> </li>
<li>content (Object, optional): <p>Contains properties with string values. These properties will be serialized as name1=value2 and passed in the request.</p> </li>
<li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time passes, the then error callbacks are called.</p> </li>
<li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values and send to the server.</p> </li>
<li>preventCache (Boolean, optional): <p>Default is false. If true, then a "dojo.preventCache" parameter is sent in the request with a value that changes with each request (timestamp). Useful only with GET-type requests.</p> </li>
<li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content property is ignored. This is mostly useful for HTTP methods that have a body to their requests, like PUT or POST. This property can be used instead of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p> </li>
<li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to IO operations. Otherwise, if djConfig.ioPublish is set to true, topics will be published via dojo/topic.publish() for different phases of an IO operation. See dojo/main.__IoPublish for a list of topics that are published.</p> </li>
</ul> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p>     <h3 id="1_10dojo__base_kernel_xhrPut">
<code class="functionIcon">xhrPut</code><code class="parameters">(args)</code> </h3> <p class="jsdoc-inheritance">Defined by <a href="xhr.html">dojo/_base/xhr</a> </p> <p>Sends an HTTP PUT request to the server. In addition to the properties listed for the dojo.__XhrArgs type, the following property is allowed:</p>  <table> <tr> <th>Parameter</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>args</td> <td>Object</td> <td>
<p>An object with the following properties:</p>
<ul>
<li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional, json-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p> </li>
<li>sync (Boolean, optional): <p>false is default. Indicates whether the request should be a synchronous (blocking) request.</p> </li>
<li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p> </li>
<li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be allowed to fail (and therefore no console error message in the event of a failure)</p> </li>
<li>contentType (String|Boolean): <p>"application/x-www-form-urlencoded" is default. Set to false to prevent a Content-Type header from being sent, or to a string to send a different Content-Type.</p> </li>
<li>load: <p>This function will be called on a successful HTTP response code.</p> </li>
<li>error: <p>This function will be called when the request fails due to a network or server error, the url is invalid, etc. It will also be called if the load or handle callback throws an exception, unless djConfig.debugAtAllCosts is true. This allows deployed applications to continue to run even when a logic error happens in the callback, while making it easier to troubleshoot while in debug mode.</p> </li>
<li>handle: <p>This function will be called at the end of every request, whether or not an error occurs.</p> </li>
<li>url (String): <p>URL to server endpoint.</p> </li>
<li>content (Object, optional): <p>Contains properties with string values. These properties will be serialized as name1=value2 and passed in the request.</p> </li>
<li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time passes, the then error callbacks are called.</p> </li>
<li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values and send to the server.</p> </li>
<li>preventCache (Boolean, optional): <p>Default is false. If true, then a "dojo.preventCache" parameter is sent in the request with a value that changes with each request (timestamp). Useful only with GET-type requests.</p> </li>
<li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content property is ignored. This is mostly useful for HTTP methods that have a body to their requests, like PUT or POST. This property can be used instead of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p> </li>
<li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to IO operations. Otherwise, if djConfig.ioPublish is set to true, topics will be published via dojo/topic.publish() for different phases of an IO operation. See dojo/main.__IoPublish for a list of topics that are published.</p> </li>
</ul> </td> </tr> </table> <p class="returnsInfo"><strong>Returns: </strong>undefined</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2017 JS Foundation<br>Licensed under the AFL 2.1 and BSD 3-Clause licenses.<br>
    <a href="http://dojotoolkit.org/api/1.10/dojo/_base/kernel.html" class="_attribution-link">http://dojotoolkit.org/api/1.10/dojo/_base/kernel.html</a>
  </p>
</div>
