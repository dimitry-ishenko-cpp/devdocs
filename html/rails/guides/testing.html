<h1>Testing Rails Applications</h1>
<div class="_simple"> <p>This guide covers built-in mechanisms in Rails for testing your application.</p>
<p>After reading this guide, you will know:</p> <ul> <li>Rails testing terminology.</li> <li>How to write unit, functional, integration, and system tests for your application.</li> <li>Other popular testing approaches and plugins.</li> </ul>  <h2 class="chapter">  Chapters </h2> <ol class="chapters"> <li><a href="#why-write-tests-for-your-rails-applications-questionmark">Why Write Tests for Your Rails Applications?</a></li> <li>
<a href="#introduction-to-testing">Introduction to Testing</a> <ul> <li><a href="#rails-sets-up-for-testing-from-the-word-go">Rails Sets up for Testing from the Word Go</a></li> <li><a href="#the-test-environment">The Test Environment</a></li> <li><a href="#rails-meets-minitest">Rails Meets Minitest</a></li> <li><a href="#available-assertions">Available Assertions</a></li> <li><a href="#rails-specific-assertions">Rails Specific Assertions</a></li> <li><a href="#a-brief-note-about-test-cases">A Brief Note About Test Cases</a></li> <li><a href="#transactions">Transactions</a></li> <li><a href="#the-rails-test-runner">The Rails Test Runner</a></li> <li><a href="#running-tests-in-continuous-integration-ci">Running tests in Continuous Integration (CI)</a></li> </ul>
</li> <li>
<a href="#parallel-testing">Parallel Testing</a> <ul> <li><a href="#parallel-testing-with-processes">Parallel Testing with Processes</a></li> <li><a href="#parallel-testing-with-threads">Parallel Testing with Threads</a></li> <li><a href="#testing-parallel-transactions">Testing Parallel Transactions</a></li> <li><a href="#threshold-to-parallelize-tests">Threshold to parallelize tests</a></li> </ul>
</li> <li>
<a href="#the-test-database">The Test Database</a> <ul> <li><a href="#maintaining-the-test-database-schema">Maintaining the Test Database Schema</a></li> <li><a href="#the-low-down-on-fixtures">The Low-Down on Fixtures</a></li> </ul>
</li> <li><a href="#model-testing">Model Testing</a></li> <li>
<a href="#system-testing">System Testing</a> <ul> <li><a href="#changing-the-default-settings">Changing the Default Settings</a></li> <li><a href="#screenshot-helper">Screenshot Helper</a></li> <li><a href="#implementing-a-system-test">Implementing a System Test</a></li> </ul>
</li> <li>
<a href="#integration-testing">Integration Testing</a> <ul> <li><a href="#helpers-available-for-integration-tests">Helpers Available for Integration Tests</a></li> <li><a href="#implementing-an-integration-test">Implementing an Integration Test</a></li> </ul>
</li> <li>
<a href="#functional-tests-for-your-controllers">Functional Tests for Your Controllers</a> <ul> <li><a href="#what-to-include-in-your-functional-tests">What to Include in Your Functional Tests</a></li> <li><a href="#available-request-types-for-functional-tests">Available Request Types for Functional Tests</a></li> <li><a href="#testing-xhr-ajax-requests">Testing XHR (Ajax) Requests</a></li> <li><a href="#the-three-hashes-of-the-apocalypse">The Three Hashes of the Apocalypse</a></li> <li><a href="#instance-variables-available">Instance Variables Available</a></li> <li><a href="#setting-headers-and-cgi-variables">Setting Headers and CGI Variables</a></li> <li><a href="#testing-flash-notices">Testing <code>flash</code> Notices</a></li> <li><a href="#putting-it-together">Putting It Together</a></li> <li><a href="#test-helpers">Test Helpers</a></li> </ul>
</li> <li><a href="#testing-routes">Testing Routes</a></li> <li>
<a href="#testing-views">Testing Views</a> <ul> <li><a href="#additional-view-based-assertions">Additional View-Based Assertions</a></li> </ul>
</li> <li><a href="#testing-view-partials">Testing View Partials</a></li> <li><a href="#testing-helpers">Testing Helpers</a></li> <li>
<a href="#testing-your-mailers">Testing Your Mailers</a> <ul> <li><a href="#keeping-the-postman-in-check">Keeping the Postman in Check</a></li> <li><a href="#unit-testing">Unit Testing</a></li> <li><a href="#functional-and-system-testing">Functional and System Testing</a></li> </ul>
</li> <li>
<a href="#testing-jobs">Testing Jobs</a> <ul> <li><a href="#testing-jobs-in-isolation">Testing Jobs in Isolation</a></li> <li><a href="#testing-jobs-in-context">Testing Jobs in Context</a></li> <li><a href="#testing-that-exceptions-are-raised">Testing that Exceptions are Raised</a></li> </ul>
</li> <li>
<a href="#testing-action-cable">Testing Action Cable</a> <ul> <li><a href="#connection-test-case">Connection Test Case</a></li> <li><a href="#channel-test-case">Channel Test Case</a></li> <li><a href="#custom-assertions-and-testing-broadcasts-inside-other-components">Custom Assertions And Testing Broadcasts Inside Other Components</a></li> </ul>
</li> <li>
<a href="#testing-eager-loading">Testing Eager Loading</a> <ul> <li><a href="#continuous-integration">Continuous Integration</a></li> <li><a href="#bare-test-suites">Bare Test Suites</a></li> </ul>
</li> <li>
<a href="#additional-testing-resources">Additional Testing Resources</a> <ul> <li><a href="#testing-time-dependent-code">Testing Time-Dependent Code</a></li> </ul>
</li> </ol>  <hr>  <h1 id="why-write-tests-for-your-rails-applications-questionmark"><a class="anchorlink" href="#why-write-tests-for-your-rails-applications-questionmark"><span>1</span> Why Write Tests for Your Rails Applications?</a></h1>
<p>Rails makes it super easy to write your tests. It starts by producing skeleton test code while you are creating your models and controllers.</p>
<p>By running your Rails tests you can ensure your code adheres to the desired functionality even after some major code refactoring.</p>
<p>Rails tests can also simulate browser requests and thus you can test your application's response without having to test it through your browser.</p>
<h1 id="introduction-to-testing"><a class="anchorlink" href="#introduction-to-testing"><span>2</span> Introduction to Testing</a></h1>
<p>Testing support was woven into the Rails fabric from the beginning. It wasn't an "oh! let's bolt on support for running tests because they're new and cool" epiphany.</p>
<h2 id="rails-sets-up-for-testing-from-the-word-go"><a class="anchorlink" href="#rails-sets-up-for-testing-from-the-word-go"><span>2.1</span> Rails Sets up for Testing from the Word Go</a></h2>
<p>Rails creates a <code>test</code> directory for you as soon as you create a Rails project using <code>rails new</code> <em>application_name</em>. If you list the contents of this directory then you shall see:</p>
<div class="interstitial code"> <pre data-language="console">$ ls -F test
application_system_test_case.rb  controllers/                     helpers/                         mailers/                         system/
channels/                        fixtures/                        integration/                     models/                          test_helper.rb</pre> <button class="clipboard-button" data-clipboard-text="ls -F test
">Copy</button> </div> <p>The <code>helpers</code>, <code>mailers</code>, and <code>models</code> directories are meant to hold tests for view helpers, mailers, and models, respectively. The <code>channels</code> directory is meant to hold tests for Action Cable connection and channels. The <code>controllers</code> directory is meant to hold tests for controllers, routes, and views. The <code>integration</code> directory is meant to hold tests for interactions between controllers.</p>
<p>The system test directory holds system tests, which are used for full browser testing of your application. System tests allow you to test your application the way your users experience it and help you test your JavaScript as well. System tests inherit from Capybara and perform in browser tests for your application.</p>
<p>Fixtures are a way of organizing test data; they reside in the <code>fixtures</code> directory.</p>
<p>A <code>jobs</code> directory will also be created when an associated test is first generated.</p>
<p>The <code>test_helper.rb</code> file holds the default configuration for your tests.</p>
<p>The <code>application_system_test_case.rb</code> holds the default configuration for your system tests.</p>
<h2 id="the-test-environment"><a class="anchorlink" href="#the-test-environment"><span>2.2</span> The Test Environment</a></h2>
<p>By default, every Rails application has three environments: development, test, and production.</p>
<p>Each environment's configuration can be modified similarly. In this case, we can modify our test environment by changing the options found in <code>config/environments/test.rb</code>.</p>
<div class="interstitial note"><p>Your tests are run under <code>RAILS_ENV=test</code>.</p></div>
<h2 id="rails-meets-minitest"><a class="anchorlink" href="#rails-meets-minitest"><span>2.3</span> Rails Meets Minitest</a></h2>
<p>If you remember, we used the <code>bin/rails generate model</code> command in the <a href="getting_started.html">Getting Started with Rails</a> guide. We created our first model, and among other things it created test stubs in the <code>test</code> directory:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate model article title:string body:text
...
create  app/models/article.rb
create  test/models/article_test.rb
create  test/fixtures/articles.yml
...</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate model article title:string body:text
">Copy</button> </div> <p>The default test stub in <code>test/models/article_test.rb</code> looks like this:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class ArticleTest &lt; ActiveSupport::TestCase
  # test "the truth" do
  #   assert true
  # end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class ArticleTest &lt; ActiveSupport::TestCase
  # test "the truth" do
  #   assert true
  # end
end
'>Copy</button> </div> <p>A line by line examination of this file will help get you oriented to Rails testing code and terminology.</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"
'>Copy</button> </div> <p>By requiring this file, <code>test_helper.rb</code>, the default configuration to run our tests is loaded. We will include this with all the tests we write, so any methods added to this file are available to all our tests.</p>
<div class="interstitial code"> <pre data-language="ruby">class ArticleTest &lt; ActiveSupport::TestCase
  # ...
end</pre> <button class="clipboard-button" data-clipboard-text="class ArticleTest &lt; ActiveSupport::TestCase
  # ...
end
">Copy</button> </div> <p>The <code>ArticleTest</code> class defines a <em>test case</em> because it inherits from <code>ActiveSupport::TestCase</code>. <code>ArticleTest</code> thus has all the methods available from <code>ActiveSupport::TestCase</code>. Later in this guide, we'll see some of the methods it gives us.</p>
<p>Any method defined within a class inherited from <code>Minitest::Test</code> (which is the superclass of <code>ActiveSupport::TestCase</code>) that begins with <code>test_</code> is simply called a test. So, methods defined as <code>test_password</code> and <code>test_valid_password</code> are legal test names and are run automatically when the test case is run.</p>
<p>Rails also adds a <code>test</code> method that takes a test name and a block. It generates a normal <code>Minitest::Unit</code> test with method names prefixed with <code>test_</code>. So you don't have to worry about naming the methods, and you can write something like:</p>
<div class="interstitial code"> <pre data-language="ruby">test "the truth" do
  assert true
end</pre> <button class="clipboard-button" data-clipboard-text='test "the truth" do
  assert true
end
'>Copy</button> </div> <p>Which is approximately the same as writing this:</p>
<div class="interstitial code"> <pre data-language="ruby">def test_the_truth
  assert true
end</pre> <button class="clipboard-button" data-clipboard-text="def test_the_truth
  assert true
end
">Copy</button> </div> <p>Although you can still use regular method definitions, using the <code>test</code> macro allows for a more readable test name.</p>
<div class="interstitial note"><p>The method name is generated by replacing spaces with underscores. The result does not need to be a valid Ruby identifier though â€” the name may contain punctuation characters, etc. That's because in Ruby technically any string may be a method name. This may require use of <code>define_method</code> and <code>send</code> calls to function properly, but formally there's little restriction on the name.</p></div>
<p>Next, let's look at our first assertion:</p>
<div class="interstitial code"> <pre data-language="ruby">assert true</pre> <button class="clipboard-button" data-clipboard-text="assert true
">Copy</button> </div> <p>An assertion is a line of code that evaluates an object (or expression) for expected results. For example, an assertion can check:</p> <ul> <li>does this value = that value?</li> <li>is this object nil?</li> <li>does this line of code throw an exception?</li> <li>is the user's password greater than 5 characters?</li> </ul> <p>Every test may contain one or more assertions, with no restriction as to how many assertions are allowed. Only when all the assertions are successful will the test pass.</p>
<h3 id="your-first-failing-test"><a class="anchorlink" href="#your-first-failing-test"><span>2.3.1</span> Your First Failing Test</a></h3>
<p>To see how a test failure is reported, you can add a failing test to the <code>article_test.rb</code> test case.</p>
<div class="interstitial code"> <pre data-language="ruby">test "should not save article without title" do
  article = Article.new
  assert_not article.save
end</pre> <button class="clipboard-button" data-clipboard-text='test "should not save article without title" do
  article = Article.new
  assert_not article.save
end
'>Copy</button> </div> <p>Let us run this newly added test (where <code>6</code> is the line number where the test is defined).</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test test/models/article_test.rb:6
Run options: --seed 44656

# Running:

F

Failure:
ArticleTest#test_should_not_save_article_without_title [/path/to/blog/test/models/article_test.rb:6]:
Expected true to be nil or false


bin/rails test test/models/article_test.rb:6



Finished in 0.023918s, 41.8090 runs/s, 41.8090 assertions/s.

1 runs, 1 assertions, 1 failures, 0 errors, 0 skips</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test test/models/article_test.rb:6
">Copy</button> </div> <p>In the output, <code>F</code> denotes a failure. You can see the corresponding trace shown under <code>Failure</code> along with the name of the failing test. The next few lines contain the stack trace followed by a message that mentions the actual value and the expected value by the assertion. The default assertion messages provide just enough information to help pinpoint the error. To make the assertion failure message more readable, every assertion provides an optional message parameter, as shown here:</p>
<div class="interstitial code"> <pre data-language="ruby">test "should not save article without title" do
  article = Article.new
  assert_not article.save, "Saved the article without a title"
end</pre> <button class="clipboard-button" data-clipboard-text='test "should not save article without title" do
  article = Article.new
  assert_not article.save, "Saved the article without a title"
end
'>Copy</button> </div> <p>Running this test shows the friendlier assertion message:</p>
<div class="interstitial code"> <pre data-language="plaintext">Failure:
ArticleTest#test_should_not_save_article_without_title [/path/to/blog/test/models/article_test.rb:6]:
Saved the article without a title</pre> <button class="clipboard-button" data-clipboard-text="Failure:
ArticleTest#test_should_not_save_article_without_title [/path/to/blog/test/models/article_test.rb:6]:
Saved the article without a title
">Copy</button> </div> <p>Now to get this test to pass we can add a model level validation for the <em>title</em> field.</p>
<div class="interstitial code"> <pre data-language="ruby">class Article &lt; ApplicationRecord
  validates :title, presence: true
end</pre> <button class="clipboard-button" data-clipboard-text="class Article &lt; ApplicationRecord
  validates :title, presence: true
end
">Copy</button> </div> <p>Now the test should pass. Let us verify by running the test again:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test test/models/article_test.rb:6
Run options: --seed 31252

# Running:

.

Finished in 0.027476s, 36.3952 runs/s, 36.3952 assertions/s.

1 runs, 1 assertions, 0 failures, 0 errors, 0 skips</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test test/models/article_test.rb:6
">Copy</button> </div> <p>Now, if you noticed, we first wrote a test which fails for a desired functionality, then we wrote some code which adds the functionality and finally we ensured that our test passes. This approach to software development is referred to as <a href="http://c2.com/cgi/wiki?TestDrivenDevelopment"><em>Test-Driven Development</em> (TDD)</a>.</p>
<h3 id="what-an-error-looks-like"><a class="anchorlink" href="#what-an-error-looks-like"><span>2.3.2</span> What an Error Looks Like</a></h3>
<p>To see how an error gets reported, here's a test containing an error:</p>
<div class="interstitial code"> <pre data-language="ruby">test "should report error" do
  # some_undefined_variable is not defined elsewhere in the test case
  some_undefined_variable
  assert true
end</pre> <button class="clipboard-button" data-clipboard-text='test "should report error" do
  # some_undefined_variable is not defined elsewhere in the test case
  some_undefined_variable
  assert true
end
'>Copy</button> </div> <p>Now you can see even more output in the console from running the tests:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test test/models/article_test.rb
Run options: --seed 1808

# Running:

.E

Error:
ArticleTest#test_should_report_error:
NameError: undefined local variable or method 'some_undefined_variable' for #&lt;ArticleTest:0x007fee3aa71798&gt;
    test/models/article_test.rb:11:in 'block in &lt;class:ArticleTest&gt;'


bin/rails test test/models/article_test.rb:9



Finished in 0.040609s, 49.2500 runs/s, 24.6250 assertions/s.

2 runs, 1 assertions, 0 failures, 1 errors, 0 skips</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test test/models/article_test.rb
">Copy</button> </div> <p>Notice the 'E' in the output. It denotes a test with error.</p>
<div class="interstitial note"><p>The execution of each test method stops as soon as any error or an assertion failure is encountered, and the test suite continues with the next method. All test methods are executed in random order. The <a href="configuring.html#config-active-support-test-order"><code>config.active_support.test_order</code></a> option can be used to configure test order.</p></div>
<p>When a test fails you are presented with the corresponding backtrace. By default Rails filters that backtrace and will only print lines relevant to your application. This eliminates the framework noise and helps to focus on your code. However there are situations when you want to see the full backtrace. Set the <code>-b</code> (or <code>--backtrace</code>) argument to enable this behavior:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test -b test/models/article_test.rb</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test -b test/models/article_test.rb
">Copy</button> </div> <p>If we want this test to pass we can modify it to use <code>assert_raises</code> like so:</p>
<div class="interstitial code"> <pre data-language="ruby">test "should report error" do
  # some_undefined_variable is not defined elsewhere in the test case
  assert_raises(NameError) do
    some_undefined_variable
  end
end</pre> <button class="clipboard-button" data-clipboard-text='test "should report error" do
  # some_undefined_variable is not defined elsewhere in the test case
  assert_raises(NameError) do
    some_undefined_variable
  end
end
'>Copy</button> </div> <p>This test should now pass.</p>
<h2 id="available-assertions"><a class="anchorlink" href="#available-assertions"><span>2.4</span> Available Assertions</a></h2>
<p>By now you've caught a glimpse of some of the assertions that are available. Assertions are the worker bees of testing. They are the ones that actually perform the checks to ensure that things are going as planned.</p>
<p>Here's an extract of the assertions you can use with <a href="https://github.com/minitest/minitest"><code>Minitest</code></a>, the default testing library used by Rails. The <code>[msg]</code> parameter is an optional string message you can specify to make your test failure messages clearer.</p> <table>
<thead> <tr> <th>Assertion</th> <th>Purpose</th> </tr> </thead>
<tbody> <tr> <td><code>assert( test, [msg] )</code></td> <td>Ensures that <code>test</code> is true.</td> </tr> <tr> <td><code>assert_not( test, [msg] )</code></td> <td>Ensures that <code>test</code> is false.</td> </tr> <tr> <td><code>assert_equal( expected, actual, [msg] )</code></td> <td>Ensures that <code>expected == actual</code> is true.</td> </tr> <tr> <td><code>assert_not_equal( expected, actual, [msg] )</code></td> <td>Ensures that <code>expected != actual</code> is true.</td> </tr> <tr> <td><code>assert_same( expected, actual, [msg] )</code></td> <td>Ensures that <code>expected.equal?(actual)</code> is true.</td> </tr> <tr> <td><code>assert_not_same( expected, actual, [msg] )</code></td> <td>Ensures that <code>expected.equal?(actual)</code> is false.</td> </tr> <tr> <td><code>assert_nil( obj, [msg] )</code></td> <td>Ensures that <code>obj.nil?</code> is true.</td> </tr> <tr> <td><code>assert_not_nil( obj, [msg] )</code></td> <td>Ensures that <code>obj.nil?</code> is false.</td> </tr> <tr> <td><code>assert_empty( obj, [msg] )</code></td> <td>Ensures that <code>obj</code> is <code>empty?</code>.</td> </tr> <tr> <td><code>assert_not_empty( obj, [msg] )</code></td> <td>Ensures that <code>obj</code> is not <code>empty?</code>.</td> </tr> <tr> <td><code>assert_match( regexp, string, [msg] )</code></td> <td>Ensures that a string matches the regular expression.</td> </tr> <tr> <td><code>assert_no_match( regexp, string, [msg] )</code></td> <td>Ensures that a string doesn't match the regular expression.</td> </tr> <tr> <td><code>assert_includes( collection, obj, [msg] )</code></td> <td>Ensures that <code>obj</code> is in <code>collection</code>.</td> </tr> <tr> <td><code>assert_not_includes( collection, obj, [msg] )</code></td> <td>Ensures that <code>obj</code> is not in <code>collection</code>.</td> </tr> <tr> <td><code>assert_in_delta( expected, actual, [delta], [msg] )</code></td> <td>Ensures that the numbers <code>expected</code> and <code>actual</code> are within <code>delta</code> of each other.</td> </tr> <tr> <td><code>assert_not_in_delta( expected, actual, [delta], [msg] )</code></td> <td>Ensures that the numbers <code>expected</code> and <code>actual</code> are not within <code>delta</code> of each other.</td> </tr> <tr> <td><code>assert_in_epsilon ( expected, actual, [epsilon], [msg] )</code></td> <td>Ensures that the numbers <code>expected</code> and <code>actual</code> have a relative error less than <code>epsilon</code>.</td> </tr> <tr> <td><code>assert_not_in_epsilon ( expected, actual, [epsilon], [msg] )</code></td> <td>Ensures that the numbers <code>expected</code> and <code>actual</code> have a relative error not less than <code>epsilon</code>.</td> </tr> <tr> <td><code>assert_throws( symbol, [msg] ) { block }</code></td> <td>Ensures that the given block throws the symbol.</td> </tr> <tr> <td><code>assert_raises( exception1, exception2, ... ) { block }</code></td> <td>Ensures that the given block raises one of the given exceptions.</td> </tr> <tr> <td><code>assert_instance_of( class, obj, [msg] )</code></td> <td>Ensures that <code>obj</code> is an instance of <code>class</code>.</td> </tr> <tr> <td><code>assert_not_instance_of( class, obj, [msg] )</code></td> <td>Ensures that <code>obj</code> is not an instance of <code>class</code>.</td> </tr> <tr> <td><code>assert_kind_of( class, obj, [msg] )</code></td> <td>Ensures that <code>obj</code> is an instance of <code>class</code> or is descending from it.</td> </tr> <tr> <td><code>assert_not_kind_of( class, obj, [msg] )</code></td> <td>Ensures that <code>obj</code> is not an instance of <code>class</code> and is not descending from it.</td> </tr> <tr> <td><code>assert_respond_to( obj, symbol, [msg] )</code></td> <td>Ensures that <code>obj</code> responds to <code>symbol</code>.</td> </tr> <tr> <td><code>assert_not_respond_to( obj, symbol, [msg] )</code></td> <td>Ensures that <code>obj</code> does not respond to <code>symbol</code>.</td> </tr> <tr> <td><code>assert_operator( obj1, operator, [obj2], [msg] )</code></td> <td>Ensures that <code>obj1.operator(obj2)</code> is true.</td> </tr> <tr> <td><code>assert_not_operator( obj1, operator, [obj2], [msg] )</code></td> <td>Ensures that <code>obj1.operator(obj2)</code> is false.</td> </tr> <tr> <td><code>assert_predicate ( obj, predicate, [msg] )</code></td> <td>Ensures that <code>obj.predicate</code> is true, e.g. <code>assert_predicate str, :empty?</code>
</td> </tr> <tr> <td><code>assert_not_predicate ( obj, predicate, [msg] )</code></td> <td>Ensures that <code>obj.predicate</code> is false, e.g. <code>assert_not_predicate str, :empty?</code>
</td> </tr> <tr> <td><code>assert_error_reported(class) { block }</code></td> <td>Ensures that the error class has been reported, e.g. <code>assert_error_reported IOError { Rails.error.report(IOError.new("Oops")) }</code>
</td> </tr> <tr> <td><code>assert_no_error_reported { block }</code></td> <td>Ensures that no errors have been reported, e.g. <code>assert_no_error_reported { perform_service }</code>
</td> </tr> <tr> <td><code>flunk( [msg] )</code></td> <td>Ensures failure. This is useful to explicitly mark a test that isn't finished yet.</td> </tr> </tbody>
</table> <p>The above are a subset of assertions that minitest supports. For an exhaustive &amp; more up-to-date list, please check <a href="http://docs.seattlerb.org/minitest/">Minitest API documentation</a>, specifically <a href="http://docs.seattlerb.org/minitest/Minitest/Assertions.html"><code>Minitest::Assertions</code></a>.</p>
<p>Because of the modular nature of the testing framework, it is possible to create your own assertions. In fact, that's exactly what Rails does. It includes some specialized assertions to make your life easier.</p>
<div class="interstitial note"><p>Creating your own assertions is an advanced topic that we won't cover in this tutorial.</p></div>
<h2 id="rails-specific-assertions"><a class="anchorlink" href="#rails-specific-assertions"><span>2.5</span> Rails Specific Assertions</a></h2>
<p>Rails adds some custom assertions of its own to the <code>minitest</code> framework:</p> <table>
<thead> <tr> <th>Assertion</th> <th>Purpose</th> </tr> </thead>
<tbody> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_difference)"><code>assert_difference(expressions, difference = 1, message = nil) {...}</code></a></td> <td>Test numeric difference between the return value of an expression as a result of what is evaluated in the yielded block.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_no_difference"><code>assert_no_difference(expressions, message = nil, &amp;block)</code></a></td> <td>Asserts that the numeric result of evaluating an expression is not changed before and after invoking the passed in block.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_changes"><code>assert_changes(expressions, message = nil, from:, to:, &amp;block)</code></a></td> <td>Test that the result of evaluating an expression is changed after invoking the passed in block.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_no_changes"><code>assert_no_changes(expressions, message = nil, &amp;block)</code></a></td> <td>Test the result of evaluating an expression is not changed after invoking the passed in block.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_nothing_raised"><code>assert_nothing_raised { block }</code></a></td> <td>Ensures that the given block doesn't raise any exceptions.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html#method-i-assert_recognizes"><code>assert_recognizes(expected_options, path, extras={}, message=nil)</code></a></td> <td>Asserts that the routing of the given path was handled correctly and that the parsed options (given in the expected_options hash) match path. Basically, it asserts that Rails recognizes the route given by expected_options.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html#method-i-assert_generates"><code>assert_generates(expected_path, options, defaults={}, extras = {}, message=nil)</code></a></td> <td>Asserts that the provided options can be used to generate the provided path. This is the inverse of assert_recognizes. The extras parameter is used to tell the request the names and values of additional request parameters that would be in a query string. The message parameter allows you to specify a custom error message for assertion failures.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/Assertions/ResponseAssertions.html#method-i-assert_response"><code>assert_response(type, message = nil)</code></a></td> <td>Asserts that the response comes with a specific status code. You can specify <code>:success</code> to indicate 200-299, <code>:redirect</code> to indicate 300-399, <code>:missing</code> to indicate 404, or <code>:error</code> to match the 500-599 range. You can also pass an explicit status number or its symbolic equivalent. For more information, see <a href="https://rubydoc.info/gems/rack/Rack/Utils#HTTP_STATUS_CODES-constant">full list of status codes</a> and how their <a href="https://rubydoc.info/gems/rack/Rack/Utils#SYMBOL_TO_STATUS_CODE-constant">mapping</a> works.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/Assertions/ResponseAssertions.html#method-i-assert_redirected_to"><code>assert_redirected_to(options = {}, message=nil)</code></a></td> <td>Asserts that the response is a redirect to a URL matching the given options. You can also pass named routes such as <code>assert_redirected_to root_path</code> and Active Record objects such as <code>assert_redirected_to @article</code>.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Assertions/QueryAssertions.html#method-i-assert_queries_count"><code>assert_queries_count(count = nil, include_schema: false, &amp;block)</code></a></td> <td>Asserts that <code>&amp;block</code> generates an <code>int</code> number of SQL queries.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Assertions/QueryAssertions.html#method-i-assert_no_queries"><code>assert_no_queries(include_schema: false, &amp;block)</code></a></td> <td>Asserts that <code>&amp;block</code> generates no SQL queries.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Assertions/QueryAssertions.html#method-i-assert_queries_match"><code>assert_queries_match(pattern, count: nil, include_schema: false, &amp;block)</code></a></td> <td>Asserts that <code>&amp;block</code> generates SQL queries that match the pattern.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Assertions/QueryAssertions.html#method-i-assert_no_queries_match"><code>assert_no_queries_match(pattern, &amp;block)</code></a></td> <td>Asserts that <code>&amp;block</code> generates no SQL queries that match the pattern.</td> </tr> </tbody>
</table> <p>You'll see the usage of some of these assertions in the next chapter.</p>
<h2 id="a-brief-note-about-test-cases"><a class="anchorlink" href="#a-brief-note-about-test-cases"><span>2.6</span> A Brief Note About Test Cases</a></h2>
<p>All the basic assertions such as <code>assert_equal</code> defined in <code>Minitest::Assertions</code> are also available in the classes we use in our own test cases. In fact, Rails provides the following classes for you to inherit from:</p> <ul> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/TestCase.html"><code>ActiveSupport::TestCase</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/TestCase.html"><code>ActionMailer::TestCase</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActionView/TestCase.html"><code>ActionView::TestCase</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveJob/TestCase.html"><code>ActiveJob::TestCase</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/IntegrationTest.html"><code>ActionDispatch::IntegrationTest</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/SystemTestCase.html"><code>ActionDispatch::SystemTestCase</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/Rails/Generators/TestCase.html"><code>Rails::Generators::TestCase</code></a></li> </ul> <p>Each of these classes include <code>Minitest::Assertions</code>, allowing us to use all of the basic assertions in our tests.</p>
<div class="interstitial note"><p>For more information on <code>Minitest</code>, refer to <a href="http://docs.seattlerb.org/minitest">its documentation</a>.</p></div>
<h2 id="transactions"><a class="anchorlink" href="#transactions"><span>2.7</span> Transactions</a></h2>
<p>By default, Rails automatically wraps tests in a database transaction that is rolled back after they finish. This makes tests independent of each other and changes to the database are only visible within a single test.</p>
<div class="interstitial code"> <pre data-language="ruby">class MyTest &lt; ActiveSupport::TestCase
  test "newly created users are active by default" do
    # Since the test is implicitly wrapped in a database transaction, the user
    # created here won't be seen by other tests.
    assert User.create.active?
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class MyTest &lt; ActiveSupport::TestCase
  test &quot;newly created users are active by default&quot; do
    # Since the test is implicitly wrapped in a database transaction, the user
    # created here won't be seen by other tests.
    assert User.create.active?
  end
end
">Copy</button> </div> <p>The method <code>ActiveRecord::Base.current_transaction</code> still acts as intended, though:</p>
<div class="interstitial code"> <pre data-language="ruby">class MyTest &lt; ActiveSupport::TestCase
  test "current_transaction" do
    # The implicit transaction around tests does not interfere with the
    # application-level semantics of current_transaction.
    assert User.current_transaction.blank?
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class MyTest &lt; ActiveSupport::TestCase
  test "current_transaction" do
    # The implicit transaction around tests does not interfere with the
    # application-level semantics of current_transaction.
    assert User.current_transaction.blank?
  end
end
'>Copy</button> </div> <p>If there are <a href="active_record_multiple_databases.html">multiple writing databases</a> in place, tests are wrapped in as many respective transactions, and all of them are rolled back.</p>
<h3 id="opting-out-of-test-transactions"><a class="anchorlink" href="#opting-out-of-test-transactions"><span>2.7.1</span> Opting-out of Test Transactions</a></h3>
<p>Individual test cases can opt-out:</p>
<div class="interstitial code"> <pre data-language="ruby">class MyTest &lt; ActiveSupport::TestCase
  # No implicit database transaction wraps the tests in this test case.
  self.use_transactional_tests = false
end</pre> <button class="clipboard-button" data-clipboard-text="class MyTest &lt; ActiveSupport::TestCase
  # No implicit database transaction wraps the tests in this test case.
  self.use_transactional_tests = false
end
">Copy</button> </div> <h2 id="the-rails-test-runner"><a class="anchorlink" href="#the-rails-test-runner"><span>2.8</span> The Rails Test Runner</a></h2>
<p>We can run all of our tests at once by using the <code>bin/rails test</code> command.</p>
<p>Or we can run a single test file by passing the <code>bin/rails test</code> command the filename containing the test cases.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test test/models/article_test.rb
Run options: --seed 1559

# Running:

..

Finished in 0.027034s, 73.9810 runs/s, 110.9715 assertions/s.

2 runs, 3 assertions, 0 failures, 0 errors, 0 skips</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test test/models/article_test.rb
">Copy</button> </div> <p>This will run all test methods from the test case.</p>
<p>You can also run a particular test method from the test case by providing the <code>-n</code> or <code>--name</code> flag and the test's method name.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test test/models/article_test.rb -n test_the_truth
Run options: -n test_the_truth --seed 43583

# Running:

.

Finished tests in 0.009064s, 110.3266 tests/s, 110.3266 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test test/models/article_test.rb -n test_the_truth
">Copy</button> </div> <p>You can also run a test at a specific line by providing the line number.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test test/models/article_test.rb:6 # run specific test and line</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test test/models/article_test.rb:6 # run specific test and line
">Copy</button> </div> <p>You can also run a range of tests by providing the line range.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test test/models/article_test.rb:6-20 # runs tests from line 6 to 20</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test test/models/article_test.rb:6-20 # runs tests from line 6 to 20
">Copy</button> </div> <p>You can also run an entire directory of tests by providing the path to the directory.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test test/controllers # run all tests from specific directory</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test test/controllers # run all tests from specific directory
">Copy</button> </div> <p>The test runner also provides a lot of other features like failing fast, deferring test output at the end of the test run and so on. Check the documentation of the test runner as follows:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test -h
Usage:
  bin/rails test [PATHS...]

Run tests except system tests

Examples:
    You can run a single test by appending a line number to a filename:

        bin/rails test test/models/user_test.rb:27

    You can run multiple tests with in a line range by appending the line range to a filename:

        bin/rails test test/models/user_test.rb:10-20

    You can run multiple files and directories at the same time:

        bin/rails test test/controllers test/integration/login_test.rb

    By default test failures and errors are reported inline during a run.

minitest options:
    -h, --help                       Display this help.
        --no-plugins                 Bypass minitest plugin auto-loading (or set $MT_NO_PLUGINS).
    -s, --seed SEED                  Sets random seed. Also via env. Eg: SEED=n rake
    -v, --verbose                    Verbose. Show progress processing files.
    -q, --quiet                      Quiet. Show no progress processing files.
        --show-skips                 Show skipped at the end of run.
    -n, --name PATTERN               Filter run on /regexp/ or string.
        --exclude PATTERN            Exclude /regexp/ or string from run.
    -S, --skip CODES                 Skip reporting of certain types of results (eg E).

Known extensions: rails, pride
    -w, --warnings                   Run with Ruby warnings enabled
    -e, --environment ENV            Run tests in the ENV environment
    -b, --backtrace                  Show the complete backtrace
    -d, --defer-output               Output test failures and errors after the test run
    -f, --fail-fast                  Abort test run on first failure or error
    -c, --[no-]color                 Enable color in the output
        --profile [COUNT]            Enable profiling of tests and list the slowest test cases (default: 10)
    -p, --pride                      Pride. Show your testing pride!</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test -h
">Copy</button> </div> <h2 id="running-tests-in-continuous-integration-ci"><a class="anchorlink" href="#running-tests-in-continuous-integration-ci"><span>2.9</span> Running tests in Continuous Integration (CI)</a></h2>
<p>To run all tests in a CI environment, there's just one command you need:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test
">Copy</button> </div> <p>If you are using <a href="#system-testing">System Tests</a>, <code>bin/rails test</code> will not run them, since they can be slow. To also run them, add an another CI step that runs <code>bin/rails test:system</code>, or change your first step to <code>bin/rails test:all</code>, which runs all tests including system tests.</p>
<h1 id="parallel-testing"><a class="anchorlink" href="#parallel-testing"><span>3</span> Parallel Testing</a></h1>
<p>Parallel testing allows you to parallelize your test suite. While forking processes is the default method, threading is supported as well. Running tests in parallel reduces the time it takes your entire test suite to run.</p>
<h2 id="parallel-testing-with-processes"><a class="anchorlink" href="#parallel-testing-with-processes"><span>3.1</span> Parallel Testing with Processes</a></h2>
<p>The default parallelization method is to fork processes using Ruby's DRb system. The processes are forked based on the number of workers provided. The default number is the actual core count on the machine you are on, but can be changed by the number passed to the parallelize method.</p>
<p>To enable parallelization add the following to your <code>test_helper.rb</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">class ActiveSupport::TestCase
  parallelize(workers: 2)
end</pre> <button class="clipboard-button" data-clipboard-text="class ActiveSupport::TestCase
  parallelize(workers: 2)
end
">Copy</button> </div> <p>The number of workers passed is the number of times the process will be forked. You may want to parallelize your local test suite differently from your CI, so an environment variable is provided to be able to easily change the number of workers a test run should use:</p>
<div class="interstitial code"> <pre data-language="console">$ PARALLEL_WORKERS=15 bin/rails test</pre> <button class="clipboard-button" data-clipboard-text="PARALLEL_WORKERS=15 bin/rails test
">Copy</button> </div> <p>When parallelizing tests, Active Record automatically handles creating a database and loading the schema into the database for each process. The databases will be suffixed with the number corresponding to the worker. For example, if you have 2 workers the tests will create <code>test-database-0</code> and <code>test-database-1</code> respectively.</p>
<p>If the number of workers passed is 1 or fewer the processes will not be forked and the tests will not be parallelized and they will use the original <code>test-database</code> database.</p>
<p>Two hooks are provided, one runs when the process is forked, and one runs before the forked process is closed. These can be useful if your app uses multiple databases or performs other tasks that depend on the number of workers.</p>
<p>The <code>parallelize_setup</code> method is called right after the processes are forked. The <code>parallelize_teardown</code> method is called right before the processes are closed.</p>
<div class="interstitial code"> <pre data-language="ruby">class ActiveSupport::TestCase
  parallelize_setup do |worker|
    # setup databases
  end

  parallelize_teardown do |worker|
    # cleanup databases
  end

  parallelize(workers: :number_of_processors)
end</pre> <button class="clipboard-button" data-clipboard-text="class ActiveSupport::TestCase
  parallelize_setup do |worker|
    # setup databases
  end

  parallelize_teardown do |worker|
    # cleanup databases
  end

  parallelize(workers: :number_of_processors)
end
">Copy</button> </div> <p>These methods are not needed or available when using parallel testing with threads.</p>
<h2 id="parallel-testing-with-threads"><a class="anchorlink" href="#parallel-testing-with-threads"><span>3.2</span> Parallel Testing with Threads</a></h2>
<p>If you prefer using threads or are using JRuby, a threaded parallelization option is provided. The threaded parallelizer is backed by Minitest's <code>Parallel::Executor</code>.</p>
<p>To change the parallelization method to use threads over forks put the following in your <code>test_helper.rb</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">class ActiveSupport::TestCase
  parallelize(workers: :number_of_processors, with: :threads)
end</pre> <button class="clipboard-button" data-clipboard-text="class ActiveSupport::TestCase
  parallelize(workers: :number_of_processors, with: :threads)
end
">Copy</button> </div> <p>Rails applications generated from JRuby or TruffleRuby will automatically include the <code>with: :threads</code> option.</p>
<p>The number of workers passed to <code>parallelize</code> determines the number of threads the tests will use. You may want to parallelize your local test suite differently from your CI, so an environment variable is provided to be able to easily change the number of workers a test run should use:</p>
<div class="interstitial code"> <pre data-language="console">$ PARALLEL_WORKERS=15 bin/rails test</pre> <button class="clipboard-button" data-clipboard-text="PARALLEL_WORKERS=15 bin/rails test
">Copy</button> </div> <h2 id="testing-parallel-transactions"><a class="anchorlink" href="#testing-parallel-transactions"><span>3.3</span> Testing Parallel Transactions</a></h2>
<p>When you want to test code that runs parallel database transactions in threads, those can block each other because they are already nested under the implicit test transaction.</p>
<p>To workaround this, you can disable transactions in a test case class by setting <code>self.use_transactional_tests = false</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">class WorkerTest &lt; ActiveSupport::TestCase
  self.use_transactional_tests = false

  test "parallel transactions" do
    # start some threads that create transactions
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class WorkerTest &lt; ActiveSupport::TestCase
  self.use_transactional_tests = false

  test "parallel transactions" do
    # start some threads that create transactions
  end
end
'>Copy</button> </div> <div class="interstitial note"><p>With disabled transactional tests, you have to clean up any data tests create as changes are not automatically rolled back after the test completes.</p></div>
<h2 id="threshold-to-parallelize-tests"><a class="anchorlink" href="#threshold-to-parallelize-tests"><span>3.4</span> Threshold to parallelize tests</a></h2>
<p>Running tests in parallel adds an overhead in terms of database setup and fixture loading. Because of this, Rails won't parallelize executions that involve fewer than 50 tests.</p>
<p>You can configure this threshold in your <code>test.rb</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">config.active_support.test_parallelization_threshold = 100</pre> <button class="clipboard-button" data-clipboard-text="config.active_support.test_parallelization_threshold = 100
">Copy</button> </div> <p>And also when setting up parallelization at the test case level:</p>
<div class="interstitial code"> <pre data-language="ruby">class ActiveSupport::TestCase
  parallelize threshold: 100
end</pre> <button class="clipboard-button" data-clipboard-text="class ActiveSupport::TestCase
  parallelize threshold: 100
end
">Copy</button> </div> <h1 id="the-test-database"><a class="anchorlink" href="#the-test-database"><span>4</span> The Test Database</a></h1>
<p>Just about every Rails application interacts heavily with a database and, as a result, your tests will need a database to interact with as well. To write efficient tests, you'll need to understand how to set up this database and populate it with sample data.</p>
<p>By default, every Rails application has three environments: development, test, and production. The database for each one of them is configured in <code>config/database.yml</code>.</p>
<p>A dedicated test database allows you to set up and interact with test data in isolation. This way your tests can mangle test data with confidence, without worrying about the data in the development or production databases.</p>
<h2 id="maintaining-the-test-database-schema"><a class="anchorlink" href="#maintaining-the-test-database-schema"><span>4.1</span> Maintaining the Test Database Schema</a></h2>
<p>In order to run your tests, your test database will need to have the current structure. The test helper checks whether your test database has any pending migrations. It will try to load your <code>db/schema.rb</code> or <code>db/structure.sql</code> into the test database. If migrations are still pending, an error will be raised. Usually this indicates that your schema is not fully migrated. Running the migrations against the development database (<code>bin/rails db:migrate</code>) will bring the schema up to date.</p>
<div class="interstitial note"><p>If there were modifications to existing migrations, the test database needs to be rebuilt. This can be done by executing <code>bin/rails db:test:prepare</code>.</p></div>
<h2 id="the-low-down-on-fixtures"><a class="anchorlink" href="#the-low-down-on-fixtures"><span>4.2</span> The Low-Down on Fixtures</a></h2>
<p>For good tests, you'll need to give some thought to setting up test data. In Rails, you can handle this by defining and customizing fixtures. You can find comprehensive documentation in the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FixtureSet.html">Fixtures API documentation</a>.</p>
<h3 id="what-are-fixtures-questionmark"><a class="anchorlink" href="#what-are-fixtures-questionmark"><span>4.2.1</span> What are Fixtures?</a></h3>
<p><em>Fixtures</em> is a fancy word for sample data. Fixtures allow you to populate your testing database with predefined data before your tests run. Fixtures are database independent and written in YAML. There is one file per model.</p>
<div class="interstitial note"><p>Fixtures are not designed to create every object that your tests need, and are best managed when only used for default data that can be applied to the common case.</p></div>
<p>You'll find fixtures under your <code>test/fixtures</code> directory. When you run <code>bin/rails generate model</code> to create a new model, Rails automatically creates fixture stubs in this directory.</p>
<h3 id="yaml"><a class="anchorlink" href="#yaml"><span>4.2.2</span> YAML</a></h3>
<p>YAML-formatted fixtures are a human-friendly way to describe your sample data. These types of fixtures have the <strong>.yml</strong> file extension (as in <code>users.yml</code>).</p>
<p>Here's a sample YAML fixture file:</p>
<div class="interstitial code"> <pre data-language="yaml"># lo &amp; behold! I am a YAML comment!
david:
  name: David Heinemeier Hansson
  birthday: 1979-10-15
  profession: Systems development

steve:
  name: Steve Ross Kellock
  birthday: 1974-09-27
  profession: guy with keyboard</pre> <button class="clipboard-button" data-clipboard-text="# lo &amp; behold! I am a YAML comment!
david:
  name: David Heinemeier Hansson
  birthday: 1979-10-15
  profession: Systems development

steve:
  name: Steve Ross Kellock
  birthday: 1974-09-27
  profession: guy with keyboard
">Copy</button> </div> <p>Each fixture is given a name followed by an indented list of colon-separated key/value pairs. Records are typically separated by a blank line. You can place comments in a fixture file by using the # character in the first column.</p>
<p>If you are working with <span>associations</span>, you can define a reference node between two different fixtures. Here's an example with a <code>belongs_to</code>/<code>has_many</code> association:</p>
<div class="interstitial code"> <pre data-language="yaml"># test/fixtures/categories.yml
about:
  name: About</pre> <button class="clipboard-button" data-clipboard-text="about:
  name: About
">Copy</button> </div> <div class="interstitial code"> <pre data-language="yaml"># test/fixtures/articles.yml
first:
  title: Welcome to Rails!
  category: about</pre> <button class="clipboard-button" data-clipboard-text="first:
  title: Welcome to Rails!
  category: about
">Copy</button> </div> <div class="interstitial code"> <pre data-language="yaml"># test/fixtures/action_text/rich_texts.yml
first_content:
  record: first (Article)
  name: content
  body: &lt;div&gt;Hello, from &lt;strong&gt;a fixture&lt;/strong&gt;&lt;/div&gt;</pre> <button class="clipboard-button" data-clipboard-text="first_content:
  record: first (Article)
  name: content
  body: &lt;div&gt;Hello, from &lt;strong&gt;a fixture&lt;/strong&gt;&lt;/div&gt;
">Copy</button> </div> <p>Notice the <code>category</code> key of the <code>first</code> Article found in <code>fixtures/articles.yml</code> has a value of <code>about</code>, and that the <code>record</code> key of the <code>first_content</code> entry found in <code>fixtures/action_text/rich_texts.yml</code> has a value of <code>first (Article)</code>. This hints to Active Record to load the Category <code>about</code> found in <code>fixtures/categories.yml</code> for the former, and Action Text to load the Article <code>first</code> found in <code>fixtures/articles.yml</code> for the latter.</p>
<div class="interstitial note"><p>For associations to reference one another by name, you can use the fixture name instead of specifying the <code>id:</code> attribute on the associated fixtures. Rails will auto assign a primary key to be consistent between runs. For more information on this association behavior please read the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FixtureSet.html">Fixtures API documentation</a>.</p></div>
<h3 id="file-attachment-fixtures"><a class="anchorlink" href="#file-attachment-fixtures"><span>4.2.3</span> File Attachment Fixtures</a></h3>
<p>Like other Active Record-backed models, Active Storage attachment records inherit from ActiveRecord::Base instances and can therefore be populated by fixtures.</p>
<p>Consider an <code>Article</code> model that has an associated image as a <code>thumbnail</code> attachment, along with fixture data YAML:</p>
<div class="interstitial code"> <pre data-language="ruby">class Article &lt; ApplicationRecord
  has_one_attached :thumbnail
end</pre> <button class="clipboard-button" data-clipboard-text="class Article &lt; ApplicationRecord
  has_one_attached :thumbnail
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="yaml"># test/fixtures/articles.yml
first:
  title: An Article</pre> <button class="clipboard-button" data-clipboard-text="first:
  title: An Article
">Copy</button> </div> <p>Assuming that there is an <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#image_types">image/png</a> encoded file at <code>test/fixtures/files/first.png</code>, the following YAML fixture entries will generate the related <code>ActiveStorage::Blob</code> and <code>ActiveStorage::Attachment</code> records:</p>
<div class="interstitial code"> <pre data-language="yaml"># test/fixtures/active_storage/blobs.yml
first_thumbnail_blob: &lt;%= ActiveStorage::FixtureSet.blob filename: "first.png" %&gt;</pre> <button class="clipboard-button" data-clipboard-text='first_thumbnail_blob: &lt;%= ActiveStorage::FixtureSet.blob filename: "first.png" %&gt;
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="yaml"># test/fixtures/active_storage/attachments.yml
first_thumbnail_attachment:
  name: thumbnail
  record: first (Article)
  blob: first_thumbnail_blob</pre> <button class="clipboard-button" data-clipboard-text="first_thumbnail_attachment:
  name: thumbnail
  record: first (Article)
  blob: first_thumbnail_blob
">Copy</button> </div> <h3 id="erb-in-it-up"><a class="anchorlink" href="#erb-in-it-up"><span>4.2.4</span> ERB'in It Up</a></h3>
<p>ERB allows you to embed Ruby code within templates. The YAML fixture format is pre-processed with ERB when Rails loads fixtures. This allows you to use Ruby to help you generate some sample data. For example, the following code generates a thousand users:</p>
<div class="interstitial code"> <pre data-language="erb">&lt;% 1000.times do |n| %&gt;
  user_&lt;%= n %&gt;:
    username: &lt;%= "user#{n}" %&gt;
    email: &lt;%= "user#{n}@example.com" %&gt;
&lt;% end %&gt;</pre> <button class="clipboard-button" data-clipboard-text='&lt;% 1000.times do |n| %&gt;
  user_&lt;%= n %&gt;:
    username: &lt;%= "user#{n}" %&gt;
    email: &lt;%= "user#{n}@example.com" %&gt;
&lt;% end %&gt;
'>Copy</button> </div> <h3 id="fixtures-in-action"><a class="anchorlink" href="#fixtures-in-action"><span>4.2.5</span> Fixtures in Action</a></h3>
<p>Rails automatically loads all fixtures from the <code>test/fixtures</code> directory by default. Loading involves three steps:</p> <ol> <li>Remove any existing data from the table corresponding to the fixture</li> <li>Load the fixture data into the table</li> <li>Dump the fixture data into a method in case you want to access it directly</li> </ol> <div class="interstitial info"><p>In order to remove existing data from the database, Rails tries to disable referential integrity triggers (like foreign keys and check constraints). If you are getting annoying permission errors on running tests, make sure the database user has privilege to disable these triggers in testing environment. (In PostgreSQL, only superusers can disable all triggers. Read more about PostgreSQL permissions <a href="https://www.postgresql.org/docs/current/sql-altertable.html">here</a>).</p></div>
<h3 id="fixtures-are-active-record-objects"><a class="anchorlink" href="#fixtures-are-active-record-objects"><span>4.2.6</span> Fixtures are Active Record Objects</a></h3>
<p>Fixtures are instances of Active Record. As mentioned in point #3 above, you can access the object directly because it is automatically available as a method whose scope is local of the test case. For example:</p>
<div class="interstitial code"> <pre data-language="ruby"># this will return the User object for the fixture named david
users(:david)

# this will return the property for david called id
users(:david).id

# one can also access methods available on the User class
david = users(:david)
david.call(david.partner)</pre> <button class="clipboard-button" data-clipboard-text="# this will return the User object for the fixture named david
users(:david)

# this will return the property for david called id
users(:david).id

# one can also access methods available on the User class
david = users(:david)
david.call(david.partner)
">Copy</button> </div> <p>To get multiple fixtures at once, you can pass in a list of fixture names. For example:</p>
<div class="interstitial code"> <pre data-language="ruby"># this will return an array containing the fixtures david and steve
users(:david, :steve)</pre> <button class="clipboard-button" data-clipboard-text="# this will return an array containing the fixtures david and steve
users(:david, :steve)
">Copy</button> </div> <h1 id="model-testing"><a class="anchorlink" href="#model-testing"><span>5</span> Model Testing</a></h1>
<p>Model tests are used to test the various models of your application.</p>
<p>Rails model tests are stored under the <code>test/models</code> directory. Rails provides a generator to create a model test skeleton for you.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate test_unit:model article title:string body:text
create  test/models/article_test.rb
create  test/fixtures/articles.yml</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate test_unit:model article title:string body:text
">Copy</button> </div> <p>Model tests don't have their own superclass like <code>ActionMailer::TestCase</code>. Instead, they inherit from <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/TestCase.html"><code>ActiveSupport::TestCase</code></a>.</p>
<h1 id="system-testing"><a class="anchorlink" href="#system-testing"><span>6</span> System Testing</a></h1>
<p>System tests allow you to test user interactions with your application, running tests in either a real or a headless browser. System tests use Capybara under the hood.</p>
<p>For creating Rails system tests, you use the <code>test/system</code> directory in your application. Rails provides a generator to create a system test skeleton for you.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate system_test users
      invoke test_unit
      create test/system/users_test.rb</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate system_test users
">Copy</button> </div> <p>Here's what a freshly generated system test looks like:</p>
<div class="interstitial code"> <pre data-language="ruby">require "application_system_test_case"

class UsersTest &lt; ApplicationSystemTestCase
  # test "visiting the index" do
  #   visit users_url
  #
  #   assert_selector "h1", text: "Users"
  # end
end</pre> <button class="clipboard-button" data-clipboard-text='require "application_system_test_case"

class UsersTest &lt; ApplicationSystemTestCase
  # test "visiting the index" do
  #   visit users_url
  #
  #   assert_selector "h1", text: "Users"
  # end
end
'>Copy</button> </div> <p>By default, system tests are run with the Selenium driver, using the Chrome browser, and a screen size of 1400x1400. The next section explains how to change the default settings.</p>
<p>By default, Rails will attempt to rescue from exceptions raised during tests and respond with HTML error pages. This behavior can be controlled by the <span><code>config.action_dispatch.show_exceptions</code></span> configuration.</p>
<h2 id="changing-the-default-settings"><a class="anchorlink" href="#changing-the-default-settings"><span>6.1</span> Changing the Default Settings</a></h2>
<p>Rails makes changing the default settings for system tests very simple. All the setup is abstracted away so you can focus on writing your tests.</p>
<p>When you generate a new application or scaffold, an <code>application_system_test_case.rb</code> file is created in the test directory. This is where all the configuration for your system tests should live.</p>
<p>If you want to change the default settings you can change what the system tests are "driven by". Say you want to change the driver from Selenium to Cuprite. First add the <code>cuprite</code> gem to your <code>Gemfile</code>. Then in your <code>application_system_test_case.rb</code> file do the following:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"
require "capybara/cuprite"

class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase
  driven_by :cuprite
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"
require "capybara/cuprite"

class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase
  driven_by :cuprite
end
'>Copy</button> </div> <p>The driver name is a required argument for <code>driven_by</code>. The optional arguments that can be passed to <code>driven_by</code> are <code>:using</code> for the browser (this will only be used by Selenium), <code>:screen_size</code> to change the size of the screen for screenshots, and <code>:options</code> which can be used to set options supported by the driver.</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase
  driven_by :selenium, using: :firefox
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase
  driven_by :selenium, using: :firefox
end
'>Copy</button> </div> <p>If you want to use a headless browser, you could use Headless Chrome or Headless Firefox by adding <code>headless_chrome</code> or <code>headless_firefox</code> in the <code>:using</code> argument.</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase
  driven_by :selenium, using: :headless_chrome
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase
  driven_by :selenium, using: :headless_chrome
end
'>Copy</button> </div> <p>If you want to use a remote browser, e.g. <a href="https://github.com/SeleniumHQ/docker-selenium">Headless Chrome in Docker</a>, you have to add remote <code>url</code> and set <code>browser</code> as remote through <code>options</code>.</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase
  url = ENV.fetch("SELENIUM_REMOTE_URL", nil)
  options = if url
    { browser: :remote, url: url }
  else
    { browser: :chrome }
  end
  driven_by :selenium, using: :headless_chrome, options: options
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase
  url = ENV.fetch("SELENIUM_REMOTE_URL", nil)
  options = if url
    { browser: :remote, url: url }
  else
    { browser: :chrome }
  end
  driven_by :selenium, using: :headless_chrome, options: options
end
'>Copy</button> </div> <p>Now you should get a connection to remote browser.</p>
<div class="interstitial code"> <pre data-language="console">$ SELENIUM_REMOTE_URL=http://localhost:4444/wd/hub bin/rails test:system</pre> <button class="clipboard-button" data-clipboard-text="SELENIUM_REMOTE_URL=http://localhost:4444/wd/hub bin/rails test:system
">Copy</button> </div> <p>If your application in test is running remote too, e.g. Docker container, Capybara needs more input about how to <a href="https://github.com/teamcapybara/capybara#calling-remote-servers">call remote servers</a>.</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase
  def setup
    Capybara.server_host = "0.0.0.0" # bind to all interfaces
    Capybara.app_host = "http://#{IPSocket.getaddress(Socket.gethostname)}" if ENV["SELENIUM_REMOTE_URL"].present?
    super
  end
  # ...
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase
  def setup
    Capybara.server_host = "0.0.0.0" # bind to all interfaces
    Capybara.app_host = "http://#{IPSocket.getaddress(Socket.gethostname)}" if ENV["SELENIUM_REMOTE_URL"].present?
    super
  end
  # ...
end
'>Copy</button> </div> <p>Now you should get a connection to remote browser and server, regardless if it is running in Docker container or CI.</p>
<p>If your Capybara configuration requires more setup than provided by Rails, this additional configuration could be added into the <code>application_system_test_case.rb</code> file.</p>
<p>Please see <a href="https://github.com/teamcapybara/capybara#setup">Capybara's documentation</a> for additional settings.</p>
<h2 id="screenshot-helper"><a class="anchorlink" href="#screenshot-helper"><span>6.2</span> Screenshot Helper</a></h2>
<p>The <code>ScreenshotHelper</code> is a helper designed to capture screenshots of your tests. This can be helpful for viewing the browser at the point a test failed, or to view screenshots later for debugging.</p>
<p>Two methods are provided: <code>take_screenshot</code> and <code>take_failed_screenshot</code>. <code>take_failed_screenshot</code> is automatically included in <code>before_teardown</code> inside Rails.</p>
<p>The <code>take_screenshot</code> helper method can be included anywhere in your tests to take a screenshot of the browser.</p>
<h2 id="implementing-a-system-test"><a class="anchorlink" href="#implementing-a-system-test"><span>6.3</span> Implementing a System Test</a></h2>
<p>Now we're going to add a system test to our blog application. We'll demonstrate writing a system test by visiting the index page and creating a new blog article.</p>
<p>If you used the scaffold generator, a system test skeleton was automatically created for you. If you didn't use the scaffold generator, start by creating a system test skeleton.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate system_test articles</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate system_test articles
">Copy</button> </div> <p>It should have created a test file placeholder for us. With the output of the previous command you should see:</p>
<div class="interstitial code"> <pre data-language="plaintext">invoke  test_unit
      create    test/system/articles_test.rb</pre> <button class="clipboard-button" data-clipboard-text="      invoke  test_unit
      create    test/system/articles_test.rb
">Copy</button> </div> <p>Now let's open that file and write our first assertion:</p>
<div class="interstitial code"> <pre data-language="ruby">require "application_system_test_case"

class ArticlesTest &lt; ApplicationSystemTestCase
  test "viewing the index" do
    visit articles_path
    assert_selector "h1", text: "Articles"
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "application_system_test_case"

class ArticlesTest &lt; ApplicationSystemTestCase
  test "viewing the index" do
    visit articles_path
    assert_selector "h1", text: "Articles"
  end
end
'>Copy</button> </div> <p>The test should see that there is an <code>h1</code> on the articles index page and pass.</p>
<p>Run the system tests.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test:system</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test:system
">Copy</button> </div> <div class="interstitial note"><p>By default, running <code>bin/rails test</code> won't run your system tests. Make sure to run <code>bin/rails test:system</code> to actually run them. You can also run <code>bin/rails test:all</code> to run all tests, including system tests.</p></div>
<h3 id="creating-articles-system-test"><a class="anchorlink" href="#creating-articles-system-test"><span>6.3.1</span> Creating Articles System Test</a></h3>
<p>Now let's test the flow for creating a new article in our blog.</p>
<div class="interstitial code"> <pre data-language="ruby">test "should create Article" do
  visit articles_path

  click_on "New Article"

  fill_in "Title", with: "Creating an Article"
  fill_in "Body", with: "Created this article successfully!"

  click_on "Create Article"

  assert_text "Creating an Article"
end</pre> <button class="clipboard-button" data-clipboard-text='test "should create Article" do
  visit articles_path

  click_on "New Article"

  fill_in "Title", with: "Creating an Article"
  fill_in "Body", with: "Created this article successfully!"

  click_on "Create Article"

  assert_text "Creating an Article"
end
'>Copy</button> </div> <p>The first step is to call <code>visit articles_path</code>. This will take the test to the articles index page.</p>
<p>Then the <code>click_on "New Article"</code> will find the "New Article" button on the index page. This will redirect the browser to <code>/articles/new</code>.</p>
<p>Then the test will fill in the title and body of the article with the specified text. Once the fields are filled in, "Create Article" is clicked on which will send a POST request to create the new article in the database.</p>
<p>We will be redirected back to the articles index page and there we assert that the text from the new article's title is on the articles index page.</p>
<h3 id="testing-for-multiple-screen-sizes"><a class="anchorlink" href="#testing-for-multiple-screen-sizes"><span>6.3.2</span> Testing for Multiple Screen Sizes</a></h3>
<p>If you want to test for mobile sizes on top of testing for desktop, you can create another class that inherits from <code>ActionDispatch::SystemTestCase</code> and use it in your test suite. In this example a file called <code>mobile_system_test_case.rb</code> is created in the <code>/test</code> directory with the following configuration.</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class MobileSystemTestCase &lt; ActionDispatch::SystemTestCase
  driven_by :selenium, using: :chrome, screen_size: [375, 667]
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class MobileSystemTestCase &lt; ActionDispatch::SystemTestCase
  driven_by :selenium, using: :chrome, screen_size: [375, 667]
end
'>Copy</button> </div> <p>To use this configuration, create a test inside <code>test/system</code> that inherits from <code>MobileSystemTestCase</code>. Now you can test your app using multiple different configurations.</p>
<div class="interstitial code"> <pre data-language="ruby">require "mobile_system_test_case"

class PostsTest &lt; MobileSystemTestCase
  test "visiting the index" do
    visit posts_url
    assert_selector "h1", text: "Posts"
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "mobile_system_test_case"

class PostsTest &lt; MobileSystemTestCase
  test "visiting the index" do
    visit posts_url
    assert_selector "h1", text: "Posts"
  end
end
'>Copy</button> </div> <h3 id="implementing-a-system-test-taking-it-further"><a class="anchorlink" href="#implementing-a-system-test-taking-it-further"><span>6.3.3</span> Taking It Further</a></h3>
<p>The beauty of system testing is that it is similar to integration testing in that it tests the user's interaction with your controller, model, and view, but system testing is much more robust and actually tests your application as if a real user were using it. Going forward, you can test anything that the user themselves would do in your application such as commenting, deleting articles, publishing draft articles, etc.</p>
<h1 id="integration-testing"><a class="anchorlink" href="#integration-testing"><span>7</span> Integration Testing</a></h1>
<p>Integration tests are used to test how various parts of our application interact. They are generally used to test important workflows within our application.</p>
<p>For creating Rails integration tests, we use the <code>test/integration</code> directory for our application. Rails provides a generator to create an integration test skeleton for us.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate integration_test user_flows
      exists  test/integration/
      create  test/integration/user_flows_test.rb</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate integration_test user_flows
">Copy</button> </div> <p>Here's what a freshly generated integration test looks like:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class UserFlowsTest &lt; ActionDispatch::IntegrationTest
  # test "the truth" do
  #   assert true
  # end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class UserFlowsTest &lt; ActionDispatch::IntegrationTest
  # test "the truth" do
  #   assert true
  # end
end
'>Copy</button> </div> <p>Here the test is inheriting from <code>ActionDispatch::IntegrationTest</code>. This makes some additional helpers available for us to use in our integration tests.</p>
<p>By default, Rails will attempt to rescue from exceptions raised during tests and respond with HTML error pages. This behavior can be controlled by the <span><code>config.action_dispatch.show_exceptions</code></span> configuration.</p>
<h2 id="helpers-available-for-integration-tests"><a class="anchorlink" href="#helpers-available-for-integration-tests"><span>7.1</span> Helpers Available for Integration Tests</a></h2>
<p>In addition to the standard testing helpers, inheriting from <code>ActionDispatch::IntegrationTest</code> comes with some additional helpers available when writing integration tests. Let's get briefly introduced to the three categories of helpers we get to choose from.</p>
<p>For dealing with the integration test runner, see <a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/Integration/Runner.html"><code>ActionDispatch::Integration::Runner</code></a>.</p>
<p>When performing requests, we will have <a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/Integration/RequestHelpers.html"><code>ActionDispatch::Integration::RequestHelpers</code></a> available for our use.</p>
<p>If we need to upload files, take a look at <a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/TestProcess/FixtureFile.html"><code>ActionDispatch::TestProcess::FixtureFile</code></a> to help.</p>
<p>If we need to modify the session, or state of our integration test, take a look at <a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/Integration/Session.html"><code>ActionDispatch::Integration::Session</code></a> to help.</p>
<h2 id="implementing-an-integration-test"><a class="anchorlink" href="#implementing-an-integration-test"><span>7.2</span> Implementing an Integration Test</a></h2>
<p>Let's add an integration test to our blog application. We'll start with a basic workflow of creating a new blog article, to verify that everything is working properly.</p>
<p>We'll start by generating our integration test skeleton:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate integration_test blog_flow</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate integration_test blog_flow
">Copy</button> </div> <p>It should have created a test file placeholder for us. With the output of the previous command we should see:</p>
<div class="interstitial code"> <pre data-language="plaintext">invoke  test_unit
      create    test/integration/blog_flow_test.rb</pre> <button class="clipboard-button" data-clipboard-text="      invoke  test_unit
      create    test/integration/blog_flow_test.rb
">Copy</button> </div> <p>Now let's open that file and write our first assertion:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class BlogFlowTest &lt; ActionDispatch::IntegrationTest
  test "can see the welcome page" do
    get "/"
    assert_select "h1", "Welcome#index"
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class BlogFlowTest &lt; ActionDispatch::IntegrationTest
  test "can see the welcome page" do
    get "/"
    assert_select "h1", "Welcome#index"
  end
end
'>Copy</button> </div> <p>We will take a look at <code>assert_select</code> to query the resulting HTML of a request in the <a href="#testing-views">Testing Views</a> section below. It is used for testing the response of our request by asserting the presence of key HTML elements and their content.</p>
<p>When we visit our root path, we should see <code>welcome/index.html.erb</code> rendered for the view. So this assertion should pass.</p>
<h3 id="creating-articles-integration"><a class="anchorlink" href="#creating-articles-integration"><span>7.2.1</span> Creating Articles Integration</a></h3>
<p>How about testing our ability to create a new article in our blog and see the resulting article.</p>
<div class="interstitial code"> <pre data-language="ruby">test "can create an article" do
  get "/articles/new"
  assert_response :success

  post "/articles",
    params: { article: { title: "can create", body: "article successfully." } }
  assert_response :redirect
  follow_redirect!
  assert_response :success
  assert_select "p", "Title:\n  can create"
end</pre> <button class="clipboard-button" data-clipboard-text='test "can create an article" do
  get "/articles/new"
  assert_response :success

  post "/articles",
    params: { article: { title: "can create", body: "article successfully." } }
  assert_response :redirect
  follow_redirect!
  assert_response :success
  assert_select "p", "Title:\n  can create"
end
'>Copy</button> </div> <p>Let's break this test down so we can understand it.</p>
<p>We start by calling the <code>:new</code> action on our Articles controller. This response should be successful.</p>
<p>After this we make a post request to the <code>:create</code> action of our Articles controller:</p>
<div class="interstitial code"> <pre data-language="ruby">post "/articles",
  params: { article: { title: "can create", body: "article successfully." } }
assert_response :redirect
follow_redirect!</pre> <button class="clipboard-button" data-clipboard-text='post "/articles",
  params: { article: { title: "can create", body: "article successfully." } }
assert_response :redirect
follow_redirect!
'>Copy</button> </div> <p>The two lines following the request are to handle the redirect we setup when creating a new article.</p>
<div class="interstitial note"><p>Don't forget to call <code>follow_redirect!</code> if you plan to make subsequent requests after a redirect is made.</p></div>
<p>Finally we can assert that our response was successful and our new article is readable on the page.</p>
<h3 id="implementing-an-integration-test-taking-it-further"><a class="anchorlink" href="#implementing-an-integration-test-taking-it-further"><span>7.2.2</span> Taking It Further</a></h3>
<p>We were able to successfully test a very small workflow for visiting our blog and creating a new article. If we wanted to take this further we could add tests for commenting, removing articles, or editing comments. Integration tests are a great place to experiment with all kinds of use cases for our applications.</p>
<h1 id="functional-tests-for-your-controllers"><a class="anchorlink" href="#functional-tests-for-your-controllers"><span>8</span> Functional Tests for Your Controllers</a></h1>
<p>In Rails, testing the various actions of a controller is a form of writing functional tests. Remember your controllers handle the incoming web requests to your application and eventually respond with a rendered view. When writing functional tests, you are testing how your actions handle the requests and the expected result or response, in some cases an HTML view.</p>
<h2 id="what-to-include-in-your-functional-tests"><a class="anchorlink" href="#what-to-include-in-your-functional-tests"><span>8.1</span> What to Include in Your Functional Tests</a></h2>
<p>You should test for things such as:</p> <ul> <li>was the web request successful?</li> <li>was the user redirected to the right page?</li> <li>was the user successfully authenticated?</li> <li>was the appropriate message displayed to the user in the view?</li> <li>was the correct information displayed in the response?</li> </ul> <p>The easiest way to see functional tests in action is to generate a controller using the scaffold generator:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate scaffold_controller article title:string body:text
...
create  app/controllers/articles_controller.rb
...
invoke  test_unit
create    test/controllers/articles_controller_test.rb
...</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate scaffold_controller article title:string body:text
">Copy</button> </div> <p>This will generate the controller code and tests for an <code>Article</code> resource. You can take a look at the file <code>articles_controller_test.rb</code> in the <code>test/controllers</code> directory.</p>
<p>If you already have a controller and just want to generate the test scaffold code for each of the seven default actions, you can use the following command:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate test_unit:scaffold article
...
invoke  test_unit
create    test/controllers/articles_controller_test.rb
...</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate test_unit:scaffold article
">Copy</button> </div> <p>Let's take a look at one such test, <code>test_should_get_index</code> from the file <code>articles_controller_test.rb</code>.</p>
<div class="interstitial code"> <pre data-language="ruby"># articles_controller_test.rb
class ArticlesControllerTest &lt; ActionDispatch::IntegrationTest
  test "should get index" do
    get articles_url
    assert_response :success
  end
end</pre> <button class="clipboard-button" data-clipboard-text='# articles_controller_test.rb
class ArticlesControllerTest &lt; ActionDispatch::IntegrationTest
  test "should get index" do
    get articles_url
    assert_response :success
  end
end
'>Copy</button> </div> <p>In the <code>test_should_get_index</code> test, Rails simulates a request on the action called <code>index</code>, making sure the request was successful and also ensuring that the right response body has been generated.</p>
<p>The <code>get</code> method kicks off the web request and populates the results into the <code>@response</code>. It can accept up to 6 arguments:</p> <ul> <li>The URI of the controller action you are requesting. This can be in the form of a string or a route helper (e.g. <code>articles_url</code>).</li> <li>
<code>params</code>: option with a hash of request parameters to pass into the action (e.g. query string parameters or article variables).</li> <li>
<code>headers</code>: for setting the headers that will be passed with the request.</li> <li>
<code>env</code>: for customizing the request environment as needed.</li> <li>
<code>xhr</code>: whether the request is Ajax request or not. Can be set to true for marking the request as Ajax.</li> <li>
<code>as</code>: for encoding the request with different content type.</li> </ul> <p>All of these keyword arguments are optional.</p>
<p>Example: Calling the <code>:show</code> action for the first <code>Article</code>, passing in an <code>HTTP_REFERER</code> header:</p>
<div class="interstitial code"> <pre data-language="ruby">get article_url(Article.first), headers: { "HTTP_REFERER" =&gt; "http://example.com/home" }</pre> <button class="clipboard-button" data-clipboard-text='get article_url(Article.first), headers: { "HTTP_REFERER" =&gt; "http://example.com/home" }
'>Copy</button> </div> <p>Another example: Calling the <code>:update</code> action for the last <code>Article</code>, passing in new text for the <code>title</code> in <code>params</code>, as an Ajax request:</p>
<div class="interstitial code"> <pre data-language="ruby">patch article_url(Article.last), params: { article: { title: "updated" } }, xhr: true</pre> <button class="clipboard-button" data-clipboard-text='patch article_url(Article.last), params: { article: { title: "updated" } }, xhr: true
'>Copy</button> </div> <p>One more example: Calling the <code>:create</code> action to create a new article, passing in text for the <code>title</code> in <code>params</code>, as JSON request:</p>
<div class="interstitial code"> <pre data-language="ruby">post articles_path, params: { article: { title: "Ahoy!" } }, as: :json</pre> <button class="clipboard-button" data-clipboard-text='post articles_path, params: { article: { title: "Ahoy!" } }, as: :json
'>Copy</button> </div> <div class="interstitial note"><p>If you try running <code>test_should_create_article</code> test from <code>articles_controller_test.rb</code> it will fail on account of the newly added model level validation and rightly so.</p></div>
<p>Let us modify <code>test_should_create_article</code> test in <code>articles_controller_test.rb</code> so that all our test pass:</p>
<div class="interstitial code"> <pre data-language="ruby">test "should create article" do
  assert_difference("Article.count") do
    post articles_url, params: { article: { body: "Rails is awesome!", title: "Hello Rails" } }
  end

  assert_redirected_to article_path(Article.last)
end</pre> <button class="clipboard-button" data-clipboard-text='test "should create article" do
  assert_difference("Article.count") do
    post articles_url, params: { article: { body: "Rails is awesome!", title: "Hello Rails" } }
  end

  assert_redirected_to article_path(Article.last)
end
'>Copy</button> </div> <p>Now you can try running all the tests and they should pass.</p>
<div class="interstitial note"><p>If you followed the steps in the <a href="getting_started.html#basic-authentication">Basic Authentication</a> section, you'll need to add authorization to every request header to get all the tests passing:</p></div>
<div class="interstitial code"> <pre data-language="ruby">post articles_url, params: { article: { body: "Rails is awesome!", title: "Hello Rails" } }, headers: { Authorization: ActionController::HttpAuthentication::Basic.encode_credentials("dhh", "secret") }</pre> <button class="clipboard-button" data-clipboard-text='post articles_url, params: { article: { body: "Rails is awesome!", title: "Hello Rails" } }, headers: { Authorization: ActionController::HttpAuthentication::Basic.encode_credentials("dhh", "secret") }
'>Copy</button> </div> <p>By default, Rails will attempt to rescue from exceptions raised during tests and respond with HTML error pages. This behavior can be controlled by the <span><code>config.action_dispatch.show_exceptions</code></span> configuration.</p>
<h2 id="available-request-types-for-functional-tests"><a class="anchorlink" href="#available-request-types-for-functional-tests"><span>8.2</span> Available Request Types for Functional Tests</a></h2>
<p>If you're familiar with the HTTP protocol, you'll know that <code>get</code> is a type of request. There are 6 request types supported in Rails functional tests:</p> <ul> <li><code>get</code></li> <li><code>post</code></li> <li><code>patch</code></li> <li><code>put</code></li> <li><code>head</code></li> <li><code>delete</code></li> </ul> <p>All of request types have equivalent methods that you can use. In a typical C.R.U.D. application you'll be using <code>get</code>, <code>post</code>, <code>put</code>, and <code>delete</code> more often.</p>
<div class="interstitial note"><p>Functional tests do not verify whether the specified request type is accepted by the action, we're more concerned with the result. Request tests exist for this use case to make your tests more purposeful.</p></div>
<h2 id="testing-xhr-ajax-requests"><a class="anchorlink" href="#testing-xhr-ajax-requests"><span>8.3</span> Testing XHR (Ajax) Requests</a></h2>
<p>To test Ajax requests, you can specify the <code>xhr: true</code> option to <code>get</code>, <code>post</code>, <code>patch</code>, <code>put</code>, and <code>delete</code> methods. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">test "ajax request" do
  article = articles(:one)
  get article_url(article), xhr: true

  assert_equal "hello world", @response.body
  assert_equal "text/javascript", @response.media_type
end</pre> <button class="clipboard-button" data-clipboard-text='test "ajax request" do
  article = articles(:one)
  get article_url(article), xhr: true

  assert_equal "hello world", @response.body
  assert_equal "text/javascript", @response.media_type
end
'>Copy</button> </div> <h2 id="the-three-hashes-of-the-apocalypse"><a class="anchorlink" href="#the-three-hashes-of-the-apocalypse"><span>8.4</span> The Three Hashes of the Apocalypse</a></h2>
<p>After a request has been made and processed, you will have 3 Hash objects ready for use:</p> <ul> <li>
<code>cookies</code> - Any cookies that are set</li> <li>
<code>flash</code> - Any objects living in the flash</li> <li>
<code>session</code> - Any object living in session variables</li> </ul> <p>As is the case with normal Hash objects, you can access the values by referencing the keys by string. You can also reference them by symbol name. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">flash["gordon"]               # or flash[:gordon]
session["shmession"]          # or session[:shmession]
cookies["are_good_for_u"]     # or cookies[:are_good_for_u]</pre> <button class="clipboard-button" data-clipboard-text='flash["gordon"]               # or flash[:gordon]
session["shmession"]          # or session[:shmession]
cookies["are_good_for_u"]     # or cookies[:are_good_for_u]
'>Copy</button> </div> <h2 id="instance-variables-available"><a class="anchorlink" href="#instance-variables-available"><span>8.5</span> Instance Variables Available</a></h2>
<p><strong>After</strong> a request is made, you also have access to three instance variables in your functional tests:</p> <ul> <li>
<code>@controller</code> - The controller processing the request</li> <li>
<code>@request</code> - The request object</li> <li>
<code>@response</code> - The response object</li> </ul> <div class="interstitial code"> <pre data-language="ruby">class ArticlesControllerTest &lt; ActionDispatch::IntegrationTest
  test "should get index" do
    get articles_url

    assert_equal "index", @controller.action_name
    assert_equal "application/x-www-form-urlencoded", @request.media_type
    assert_match "Articles", @response.body
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class ArticlesControllerTest &lt; ActionDispatch::IntegrationTest
  test "should get index" do
    get articles_url

    assert_equal "index", @controller.action_name
    assert_equal "application/x-www-form-urlencoded", @request.media_type
    assert_match "Articles", @response.body
  end
end
'>Copy</button> </div> <h2 id="setting-headers-and-cgi-variables"><a class="anchorlink" href="#setting-headers-and-cgi-variables"><span>8.6</span> Setting Headers and CGI Variables</a></h2>
<p><a href="https://datatracker.ietf.org/doc/html/rfc2616#section-5.3">HTTP headers</a> and <a href="https://datatracker.ietf.org/doc/html/rfc3875#section-4.1">CGI variables</a> can be passed as headers:</p>
<div class="interstitial code"> <pre data-language="ruby"># setting an HTTP Header
get articles_url, headers: { "Content-Type": "text/plain" } # simulate the request with custom header

# setting a CGI variable
get articles_url, headers: { "HTTP_REFERER": "http://example.com/home" } # simulate the request with custom env variable</pre> <button class="clipboard-button" data-clipboard-text='# setting an HTTP Header
get articles_url, headers: { "Content-Type": "text/plain" } # simulate the request with custom header

# setting a CGI variable
get articles_url, headers: { "HTTP_REFERER": "http://example.com/home" } # simulate the request with custom env variable
'>Copy</button> </div> <h2 id="testing-flash-notices"><a class="anchorlink" href="#testing-flash-notices"><span>8.7</span> Testing <code>flash</code> Notices</a></h2>
<p>If you remember from earlier, one of the Three Hashes of the Apocalypse was <code>flash</code>.</p>
<p>We want to add a <code>flash</code> message to our blog application whenever someone successfully creates a new Article.</p>
<p>Let's start by adding this assertion to our <code>test_should_create_article</code> test:</p>
<div class="interstitial code"> <pre data-language="ruby">test "should create article" do
  assert_difference("Article.count") do
    post articles_url, params: { article: { title: "Some title" } }
  end

  assert_redirected_to article_path(Article.last)
  assert_equal "Article was successfully created.", flash[:notice]
end</pre> <button class="clipboard-button" data-clipboard-text='test "should create article" do
  assert_difference("Article.count") do
    post articles_url, params: { article: { title: "Some title" } }
  end

  assert_redirected_to article_path(Article.last)
  assert_equal "Article was successfully created.", flash[:notice]
end
'>Copy</button> </div> <p>If we run our test now, we should see a failure:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test test/controllers/articles_controller_test.rb -n test_should_create_article
Run options: -n test_should_create_article --seed 32266

# Running:

F

Finished in 0.114870s, 8.7055 runs/s, 34.8220 assertions/s.

  1) Failure:
ArticlesControllerTest#test_should_create_article [/test/controllers/articles_controller_test.rb:16]:
--- expected
+++ actual
@@ -1 +1 @@
-"Article was successfully created."
+nil

1 runs, 4 assertions, 1 failures, 0 errors, 0 skips</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test test/controllers/articles_controller_test.rb -n test_should_create_article
">Copy</button> </div> <p>Let's implement the flash message now in our controller. Our <code>:create</code> action should now look like this:</p>
<div class="interstitial code"> <pre data-language="ruby">def create
  @article = Article.new(article_params)

  if @article.save
    flash[:notice] = "Article was successfully created."
    redirect_to @article
  else
    render "new"
  end
end</pre> <button class="clipboard-button" data-clipboard-text='def create
  @article = Article.new(article_params)

  if @article.save
    flash[:notice] = "Article was successfully created."
    redirect_to @article
  else
    render "new"
  end
end
'>Copy</button> </div> <p>Now if we run our tests, we should see it pass:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails test test/controllers/articles_controller_test.rb -n test_should_create_article
Run options: -n test_should_create_article --seed 18981

# Running:

.

Finished in 0.081972s, 12.1993 runs/s, 48.7972 assertions/s.

1 runs, 4 assertions, 0 failures, 0 errors, 0 skips</pre> <button class="clipboard-button" data-clipboard-text="bin/rails test test/controllers/articles_controller_test.rb -n test_should_create_article
">Copy</button> </div> <h2 id="putting-it-together"><a class="anchorlink" href="#putting-it-together"><span>8.8</span> Putting It Together</a></h2>
<p>At this point our Articles controller tests the <code>:index</code> as well as <code>:new</code> and <code>:create</code> actions. What about dealing with existing data?</p>
<p>Let's write a test for the <code>:show</code> action:</p>
<div class="interstitial code"> <pre data-language="ruby">test "should show article" do
  article = articles(:one)
  get article_url(article)
  assert_response :success
end</pre> <button class="clipboard-button" data-clipboard-text='test "should show article" do
  article = articles(:one)
  get article_url(article)
  assert_response :success
end
'>Copy</button> </div> <p>Remember from our discussion earlier on fixtures, the <code>articles()</code> method will give us access to our Articles fixtures.</p>
<p>How about deleting an existing Article?</p>
<div class="interstitial code"> <pre data-language="ruby">test "should destroy article" do
  article = articles(:one)
  assert_difference("Article.count", -1) do
    delete article_url(article)
  end

  assert_redirected_to articles_path
end</pre> <button class="clipboard-button" data-clipboard-text='test "should destroy article" do
  article = articles(:one)
  assert_difference("Article.count", -1) do
    delete article_url(article)
  end

  assert_redirected_to articles_path
end
'>Copy</button> </div> <p>We can also add a test for updating an existing Article.</p>
<div class="interstitial code"> <pre data-language="ruby">test "should update article" do
  article = articles(:one)

  patch article_url(article), params: { article: { title: "updated" } }

  assert_redirected_to article_path(article)
  # Reload association to fetch updated data and assert that title is updated.
  article.reload
  assert_equal "updated", article.title
end</pre> <button class="clipboard-button" data-clipboard-text='test "should update article" do
  article = articles(:one)

  patch article_url(article), params: { article: { title: "updated" } }

  assert_redirected_to article_path(article)
  # Reload association to fetch updated data and assert that title is updated.
  article.reload
  assert_equal "updated", article.title
end
'>Copy</button> </div> <p>Notice we're starting to see some duplication in these three tests, they both access the same Article fixture data. We can D.R.Y. this up by using the <code>setup</code> and <code>teardown</code> methods provided by <code>ActiveSupport::Callbacks</code>.</p>
<p>Our test should now look something as what follows. Disregard the other tests for now, we're leaving them out for brevity.</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class ArticlesControllerTest &lt; ActionDispatch::IntegrationTest
  # called before every single test
  setup do
    @article = articles(:one)
  end

  # called after every single test
  teardown do
    # when controller is using cache it may be a good idea to reset it afterwards
    Rails.cache.clear
  end

  test "should show article" do
    # Reuse the @article instance variable from setup
    get article_url(@article)
    assert_response :success
  end

  test "should destroy article" do
    assert_difference("Article.count", -1) do
      delete article_url(@article)
    end

    assert_redirected_to articles_path
  end

  test "should update article" do
    patch article_url(@article), params: { article: { title: "updated" } }

    assert_redirected_to article_path(@article)
    # Reload association to fetch updated data and assert that title is updated.
    @article.reload
    assert_equal "updated", @article.title
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class ArticlesControllerTest &lt; ActionDispatch::IntegrationTest
  # called before every single test
  setup do
    @article = articles(:one)
  end

  # called after every single test
  teardown do
    # when controller is using cache it may be a good idea to reset it afterwards
    Rails.cache.clear
  end

  test "should show article" do
    # Reuse the @article instance variable from setup
    get article_url(@article)
    assert_response :success
  end

  test "should destroy article" do
    assert_difference("Article.count", -1) do
      delete article_url(@article)
    end

    assert_redirected_to articles_path
  end

  test "should update article" do
    patch article_url(@article), params: { article: { title: "updated" } }

    assert_redirected_to article_path(@article)
    # Reload association to fetch updated data and assert that title is updated.
    @article.reload
    assert_equal "updated", @article.title
  end
end
'>Copy</button> </div> <p>Similar to other callbacks in Rails, the <code>setup</code> and <code>teardown</code> methods can also be used by passing a block, lambda, or method name as a symbol to call.</p>
<h2 id="test-helpers"><a class="anchorlink" href="#test-helpers"><span>8.9</span> Test Helpers</a></h2>
<p>To avoid code duplication, you can add your own test helpers. Sign in helper can be a good example:</p>
<div class="interstitial code"> <pre data-language="ruby"># test/test_helper.rb

module SignInHelper
  def sign_in_as(user)
    post sign_in_url(email: user.email, password: user.password)
  end
end

class ActionDispatch::IntegrationTest
  include SignInHelper
end</pre> <button class="clipboard-button" data-clipboard-text="
module SignInHelper
  def sign_in_as(user)
    post sign_in_url(email: user.email, password: user.password)
  end
end

class ActionDispatch::IntegrationTest
  include SignInHelper
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class ProfileControllerTest &lt; ActionDispatch::IntegrationTest
  test "should show profile" do
    # helper is now reusable from any controller test case
    sign_in_as users(:david)

    get profile_url
    assert_response :success
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class ProfileControllerTest &lt; ActionDispatch::IntegrationTest
  test "should show profile" do
    # helper is now reusable from any controller test case
    sign_in_as users(:david)

    get profile_url
    assert_response :success
  end
end
'>Copy</button> </div> <h3 id="using-separate-files"><a class="anchorlink" href="#using-separate-files"><span>8.9.1</span> Using Separate Files</a></h3>
<p>If you find your helpers are cluttering <code>test_helper.rb</code>, you can extract them into separate files. One good place to store them is <code>test/lib</code> or <code>test/test_helpers</code>.</p>
<div class="interstitial code"> <pre data-language="ruby"># test/test_helpers/multiple_assertions.rb
module MultipleAssertions
  def assert_multiple_of_forty_two(number)
    assert (number % 42 == 0), "expected #{number} to be a multiple of 42"
  end
end</pre> <button class="clipboard-button" data-clipboard-text='module MultipleAssertions
  def assert_multiple_of_forty_two(number)
    assert (number % 42 == 0), "expected #{number} to be a multiple of 42"
  end
end
'>Copy</button> </div> <p>These helpers can then be explicitly required as needed and included as needed</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"
require "test_helpers/multiple_assertions"

class NumberTest &lt; ActiveSupport::TestCase
  include MultipleAssertions

  test "420 is a multiple of forty two" do
    assert_multiple_of_forty_two 420
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"
require "test_helpers/multiple_assertions"

class NumberTest &lt; ActiveSupport::TestCase
  include MultipleAssertions

  test "420 is a multiple of forty two" do
    assert_multiple_of_forty_two 420
  end
end
'>Copy</button> </div> <p>or they can continue to be included directly into the relevant parent classes</p>
<div class="interstitial code"> <pre data-language="ruby"># test/test_helper.rb
require "test_helpers/sign_in_helper"

class ActionDispatch::IntegrationTest
  include SignInHelper
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helpers/sign_in_helper"

class ActionDispatch::IntegrationTest
  include SignInHelper
end
'>Copy</button> </div> <h3 id="eagerly-requiring-helpers"><a class="anchorlink" href="#eagerly-requiring-helpers"><span>8.9.2</span> Eagerly Requiring Helpers</a></h3>
<p>You may find it convenient to eagerly require helpers in <code>test_helper.rb</code> so your test files have implicit access to them. This can be accomplished using globbing, as follows</p>
<div class="interstitial code"> <pre data-language="ruby"># test/test_helper.rb
Dir[Rails.root.join("test", "test_helpers", "**", "*.rb")].each { |file| require file }</pre> <button class="clipboard-button" data-clipboard-text='Dir[Rails.root.join("test", "test_helpers", "**", "*.rb")].each { |file| require file }
'>Copy</button> </div> <p>This has the downside of increasing the boot-up time, as opposed to manually requiring only the necessary files in your individual tests.</p>
<h1 id="testing-routes"><a class="anchorlink" href="#testing-routes"><span>9</span> Testing Routes</a></h1>
<p>Like everything else in your Rails application, you can test your routes. Route tests reside in <code>test/controllers/</code> or are part of controller tests.</p>
<div class="interstitial note"><p>If your application has complex routes, Rails provides a number of useful helpers to test them.</p></div>
<p>For more information on routing assertions available in Rails, see the API documentation for <a href="https://edgeapi.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html"><code>ActionDispatch::Assertions::RoutingAssertions</code></a>.</p>
<h1 id="testing-views"><a class="anchorlink" href="#testing-views"><span>10</span> Testing Views</a></h1>
<p>Testing the response to your request by asserting the presence of key HTML elements and their content is a common way to test the views of your application. Like route tests, view tests reside in <code>test/controllers/</code> or are part of controller tests. The <code>assert_select</code> method allows you to query HTML elements of the response by using a simple yet powerful syntax.</p>
<p>There are two forms of <code>assert_select</code>:</p>
<p><code>assert_select(selector, [equality], [message])</code> ensures that the equality condition is met on the selected elements through the selector. The selector may be a CSS selector expression (String) or an expression with substitution values.</p>
<p><code>assert_select(element, selector, [equality], [message])</code> ensures that the equality condition is met on all the selected elements through the selector starting from the <em>element</em> (instance of <code>Nokogiri::XML::Node</code> or <code>Nokogiri::XML::NodeSet</code>) and its descendants.</p>
<p>For example, you could verify the contents on the title element in your response with:</p>
<div class="interstitial code"> <pre data-language="ruby">assert_select "title", "Welcome to Rails Testing Guide"</pre> <button class="clipboard-button" data-clipboard-text='assert_select "title", "Welcome to Rails Testing Guide"
'>Copy</button> </div> <p>You can also use nested <code>assert_select</code> blocks for deeper investigation.</p>
<p>In the following example, the inner <code>assert_select</code> for <code>li.menu_item</code> runs within the collection of elements selected by the outer block:</p>
<div class="interstitial code"> <pre data-language="ruby">assert_select "ul.navigation" do
  assert_select "li.menu_item"
end</pre> <button class="clipboard-button" data-clipboard-text='assert_select "ul.navigation" do
  assert_select "li.menu_item"
end
'>Copy</button> </div> <p>A collection of selected elements may be iterated through so that <code>assert_select</code> may be called separately for each element.</p>
<p>For example if the response contains two ordered lists, each with four nested list elements then the following tests will both pass.</p>
<div class="interstitial code"> <pre data-language="ruby">assert_select "ol" do |elements|
  elements.each do |element|
    assert_select element, "li", 4
  end
end

assert_select "ol" do
  assert_select "li", 8
end</pre> <button class="clipboard-button" data-clipboard-text='assert_select "ol" do |elements|
  elements.each do |element|
    assert_select element, "li", 4
  end
end

assert_select "ol" do
  assert_select "li", 8
end
'>Copy</button> </div> <p>This assertion is quite powerful. For more advanced usage, refer to its <a href="https://github.com/rails/rails-dom-testing/blob/main/lib/rails/dom/testing/assertions/selector_assertions.rb">documentation</a>.</p>
<h2 id="additional-view-based-assertions"><a class="anchorlink" href="#additional-view-based-assertions"><span>10.1</span> Additional View-Based Assertions</a></h2>
<p>There are more assertions that are primarily used in testing views:</p> <table>
<thead> <tr> <th>Assertion</th> <th>Purpose</th> </tr> </thead>
<tbody> <tr> <td><code>assert_select_email</code></td> <td>Allows you to make assertions on the body of an e-mail.</td> </tr> <tr> <td><code>assert_select_encoded</code></td> <td>Allows you to make assertions on encoded HTML. It does this by un-encoding the contents of each element and then calling the block with all the un-encoded elements.</td> </tr> <tr> <td>
<code>css_select(selector)</code> or <code>css_select(element, selector)</code>
</td> <td>Returns an array of all the elements selected by the <em>selector</em>. In the second variant it first matches the base <em>element</em> and tries to match the <em>selector</em> expression on any of its children. If there are no matches both variants return an empty array.</td> </tr> </tbody>
</table> <p>Here's an example of using <code>assert_select_email</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">assert_select_email do
  assert_select "small", "Please click the 'Unsubscribe' link if you want to opt-out."
end</pre> <button class="clipboard-button" data-clipboard-text="assert_select_email do
  assert_select &quot;small&quot;, &quot;Please click the 'Unsubscribe' link if you want to opt-out.&quot;
end
">Copy</button> </div> <h1 id="testing-view-partials"><a class="anchorlink" href="#testing-view-partials"><span>11</span> Testing View Partials</a></h1>
<p>Partial templates - usually called "partials" - are another device for breaking the rendering process into more manageable chunks. With partials, you can extract pieces of code from your templates to separate files and reuse them throughout your templates.</p>
<p>View tests provide an opportunity to test that partials render content the way you expect. View partial tests reside in <code>test/views/</code> and inherit from <code>ActionView::TestCase</code>.</p>
<p>To render a partial, call <code>render</code> like you would in a template. The content is available through the test-local <code>#rendered</code> method:</p>
<div class="interstitial code"> <pre data-language="ruby">class ArticlePartialTest &lt; ActionView::TestCase
  test "renders a link to itself" do
    article = Article.create! title: "Hello, world"

    render "articles/article", article: article

    assert_includes rendered, article.title
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class ArticlePartialTest &lt; ActionView::TestCase
  test "renders a link to itself" do
    article = Article.create! title: "Hello, world"

    render "articles/article", article: article

    assert_includes rendered, article.title
  end
end
'>Copy</button> </div> <p>Tests that inherit from <code>ActionView::TestCase</code> also have access to <a href="#testing-views"><code>assert_select</code></a> and the <a href="#additional-view-based-assertions">other additional view-based assertions</a> provided by <a href="https://github.com/rails/rails-dom-testing">rails-dom-testing</a>:</p>
<div class="interstitial code"> <pre data-language="ruby">test "renders a link to itself" do
  article = Article.create! title: "Hello, world"

  render "articles/article", article: article

  assert_select "a[href=?]", article_url(article), text: article.title
end</pre> <button class="clipboard-button" data-clipboard-text='test "renders a link to itself" do
  article = Article.create! title: "Hello, world"

  render "articles/article", article: article

  assert_select "a[href=?]", article_url(article), text: article.title
end
'>Copy</button> </div> <p>In order to integrate with <a href="https://github.com/rails/rails-dom-testing">rails-dom-testing</a>, tests that inherit from <code>ActionView::TestCase</code> declare a <code>document_root_element</code> method that returns the rendered content as an instance of a <a href="https://www.rubydoc.info/github/sparklemotion/nokogiri/Nokogiri/XML/Node">Nokogiri::XML::Node</a>:</p>
<div class="interstitial code"> <pre data-language="ruby">test "renders a link to itself" do
  article = Article.create! title: "Hello, world"

  render "articles/article", article: article
  anchor = document_root_element.at("a")

  assert_equal article.name, anchor.text
  assert_equal article_url(article), anchor["href"]
end</pre> <button class="clipboard-button" data-clipboard-text='test "renders a link to itself" do
  article = Article.create! title: "Hello, world"

  render "articles/article", article: article
  anchor = document_root_element.at("a")

  assert_equal article.name, anchor.text
  assert_equal article_url(article), anchor["href"]
end
'>Copy</button> </div> <p>If your application uses Ruby &gt;= 3.0 or higher, depends on <a href="https://github.com/sparklemotion/nokogiri/releases/tag/v1.14.0">Nokogiri &gt;= 1.14.0</a> or higher, and depends on <a href="https://github.com/minitest/minitest/blob/v5.18.0/History.rdoc#5180--2023-03-04-">Minitest &gt;= &gt;5.18.0</a>, <code>document_root_element</code> supports <a href="https://docs.ruby-lang.org/en/master/syntax/pattern_matching_rdoc.html">Ruby's Pattern Matching</a>:</p>
<div class="interstitial code"> <pre data-language="ruby">test "renders a link to itself" do
  article = Article.create! title: "Hello, world"

  render "articles/article", article: article
  anchor = document_root_element.at("a")
  url = article_url(article)

  assert_pattern do
    anchor =&gt; { content: "Hello, world", attributes: [{ name: "href", value: url }] }
  end
end</pre> <button class="clipboard-button" data-clipboard-text='test "renders a link to itself" do
  article = Article.create! title: "Hello, world"

  render "articles/article", article: article
  anchor = document_root_element.at("a")
  url = article_url(article)

  assert_pattern do
    anchor =&gt; { content: "Hello, world", attributes: [{ name: "href", value: url }] }
  end
end
'>Copy</button> </div> <p>If you'd like to access the same <a href="https://rubydoc.info/github/teamcapybara/capybara/master/Capybara/Minitest/Assertions">Capybara-powered Assertions</a> that your <a href="#functional-and-system-testing">Functional and System Testing</a> tests utilize, you can define a base class that inherits from <code>ActionView::TestCase</code> and transforms the <code>document_root_element</code> into a <code>page</code> method:</p>
<div class="interstitial code"> <pre data-language="ruby"># test/view_partial_test_case.rb

require "test_helper"
require "capybara/minitest"

class ViewPartialTestCase &lt; ActionView::TestCase
  include Capybara::Minitest::Assertions

  def page
    Capybara.string(rendered)
  end
end

# test/views/article_partial_test.rb

require "view_partial_test_case"

class ArticlePartialTest &lt; ViewPartialTestCase
  test "renders a link to itself" do
    article = Article.create! title: "Hello, world"

    render "articles/article", article: article

    assert_link article.title, href: article_url(article)
  end
end</pre> <button class="clipboard-button" data-clipboard-text='
require "test_helper"
require "capybara/minitest"

class ViewPartialTestCase &lt; ActionView::TestCase
  include Capybara::Minitest::Assertions

  def page
    Capybara.string(rendered)
  end
end


require "view_partial_test_case"

class ArticlePartialTest &lt; ViewPartialTestCase
  test "renders a link to itself" do
    article = Article.create! title: "Hello, world"

    render "articles/article", article: article

    assert_link article.title, href: article_url(article)
  end
end
'>Copy</button> </div> <p>Starting in Action View version 7.1, the <code>#rendered</code> helper method returns an object capable of parsing the view partial's rendered content.</p>
<p>To transform the <code>String</code> content returned by the <code>#rendered</code> method into an object, define a parser by calling <code>.register_parser</code>. Calling <code>.register_parser :rss</code> defines a <code>#rendered.rss</code> helper method. For example, to parse rendered <a href="https://www.rssboard.org/rss-specification">RSS content</a> into an object with <code>#rendered.rss</code>, register a call to <code>RSS::Parser.parse</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">register_parser :rss, -&gt; rendered { RSS::Parser.parse(rendered) }

test "renders RSS" do
  article = Article.create!(title: "Hello, world")

  render formats: :rss, partial: article

  assert_equal "Hello, world", rendered.rss.items.last.title
end</pre> <button class="clipboard-button" data-clipboard-text='register_parser :rss, -&gt; rendered { RSS::Parser.parse(rendered) }

test "renders RSS" do
  article = Article.create!(title: "Hello, world")

  render formats: :rss, partial: article

  assert_equal "Hello, world", rendered.rss.items.last.title
end
'>Copy</button> </div> <p>By default, <code>ActionView::TestCase</code> defines a parser for:</p> <ul> <li>
<code>:html</code> - returns an instance of <a href="https://nokogiri.org/rdoc/Nokogiri/XML/Node.html">Nokogiri::XML::Node</a>
</li> <li>
<code>:json</code> - returns an instance of <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/HashWithIndifferentAccess.html">ActiveSupport::HashWithIndifferentAccess</a>
</li> </ul> <div class="interstitial code"> <pre data-language="ruby">test "renders HTML" do
  article = Article.create!(title: "Hello, world")

  render partial: "articles/article", locals: { article: article }

  assert_pattern { rendered.html.at("main h1") =&gt; { content: "Hello, world" } }
end

test "renders JSON" do
  article = Article.create!(title: "Hello, world")

  render formats: :json, partial: "articles/article", locals: { article: article }

  assert_pattern { rendered.json =&gt; { title: "Hello, world" } }
end</pre> <button class="clipboard-button" data-clipboard-text='test "renders HTML" do
  article = Article.create!(title: "Hello, world")

  render partial: "articles/article", locals: { article: article }

  assert_pattern { rendered.html.at("main h1") =&gt; { content: "Hello, world" } }
end

test "renders JSON" do
  article = Article.create!(title: "Hello, world")

  render formats: :json, partial: "articles/article", locals: { article: article }

  assert_pattern { rendered.json =&gt; { title: "Hello, world" } }
end
'>Copy</button> </div> <h1 id="testing-helpers"><a class="anchorlink" href="#testing-helpers"><span>12</span> Testing Helpers</a></h1>
<p>A helper is just a simple module where you can define methods which are available in your views.</p>
<p>In order to test helpers, all you need to do is check that the output of the helper method matches what you'd expect. Tests related to the helpers are located under the <code>test/helpers</code> directory.</p>
<p>Given we have the following helper:</p>
<div class="interstitial code"> <pre data-language="ruby">module UsersHelper
  def link_to_user(user)
    link_to "#{user.first_name} #{user.last_name}", user
  end
end</pre> <button class="clipboard-button" data-clipboard-text='module UsersHelper
  def link_to_user(user)
    link_to "#{user.first_name} #{user.last_name}", user
  end
end
'>Copy</button> </div> <p>We can test the output of this method like this:</p>
<div class="interstitial code"> <pre data-language="ruby">class UsersHelperTest &lt; ActionView::TestCase
  test "should return the user's full name" do
    user = users(:david)

    assert_dom_equal %{&lt;a href="/user/.html#{user.id}"&gt;David Heinemeier Hansson&lt;/a&gt;}, link_to_user(user)
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class UsersHelperTest &lt; ActionView::TestCase
  test &quot;should return the user's full name&quot; do
    user = users(:david)

    assert_dom_equal %{&lt;a href=&quot;/user/#{user.id}&quot;&gt;David Heinemeier Hansson&lt;/a&gt;}, link_to_user(user)
  end
end
">Copy</button> </div> <p>Moreover, since the test class extends from <code>ActionView::TestCase</code>, you have access to Rails' helper methods such as <code>link_to</code> or <code>pluralize</code>.</p>
<h1 id="testing-your-mailers"><a class="anchorlink" href="#testing-your-mailers"><span>13</span> Testing Your Mailers</a></h1>
<p>Testing mailer classes requires some specific tools to do a thorough job.</p>
<h2 id="keeping-the-postman-in-check"><a class="anchorlink" href="#keeping-the-postman-in-check"><span>13.1</span> Keeping the Postman in Check</a></h2>
<p>Your mailer classes - like every other part of your Rails application - should be tested to ensure that they are working as expected.</p>
<p>The goals of testing your mailer classes are to ensure that:</p> <ul> <li>emails are being processed (created and sent)</li> <li>the email content is correct (subject, sender, body, etc)</li> <li>the right emails are being sent at the right times</li> </ul> <h3 id="from-all-sides"><a class="anchorlink" href="#from-all-sides"><span>13.1.1</span> From All Sides</a></h3>
<p>There are two aspects of testing your mailer, the unit tests and the functional tests. In the unit tests, you run the mailer in isolation with tightly controlled inputs and compare the output to a known value (a fixture). In the functional tests you don't so much test the minute details produced by the mailer; instead, we test that our controllers and models are using the mailer in the right way. You test to prove that the right email was sent at the right time.</p>
<h2 id="unit-testing"><a class="anchorlink" href="#unit-testing"><span>13.2</span> Unit Testing</a></h2>
<p>In order to test that your mailer is working as expected, you can use unit tests to compare the actual results of the mailer with pre-written examples of what should be produced.</p>
<h3 id="revenge-of-the-fixtures"><a class="anchorlink" href="#revenge-of-the-fixtures"><span>13.2.1</span> Revenge of the Fixtures</a></h3>
<p>For the purposes of unit testing a mailer, fixtures are used to provide an example of how the output <em>should</em> look. Because these are example emails, and not Active Record data like the other fixtures, they are kept in their own subdirectory apart from the other fixtures. The name of the directory within <code>test/fixtures</code> directly corresponds to the name of the mailer. So, for a mailer named <code>UserMailer</code>, the fixtures should reside in <code>test/fixtures/user_mailer</code> directory.</p>
<p>If you generated your mailer, the generator does not create stub fixtures for the mailers actions. You'll have to create those files yourself as described above.</p>
<h3 id="the-basic-test-case"><a class="anchorlink" href="#the-basic-test-case"><span>13.2.2</span> The Basic Test Case</a></h3>
<p>Here's a unit test to test a mailer named <code>UserMailer</code> whose action <code>invite</code> is used to send an invitation to a friend. It is an adapted version of the base test created by the generator for an <code>invite</code> action.</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class UserMailerTest &lt; ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.create_invite("me@example.com",
                                     "friend@example.com", Time.now)

    # Send the email, then test that it got queued
    assert_emails 1 do
      email.deliver_now
    end

    # Test the body of the sent email contains what we expect it to
    assert_equal ["me@example.com"], email.from
    assert_equal ["friend@example.com"], email.to
    assert_equal "You have been invited by me@example.com", email.subject
    assert_equal read_fixture("invite").join, email.body.to_s
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class UserMailerTest &lt; ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.create_invite("me@example.com",
                                     "friend@example.com", Time.now)

    # Send the email, then test that it got queued
    assert_emails 1 do
      email.deliver_now
    end

    # Test the body of the sent email contains what we expect it to
    assert_equal ["me@example.com"], email.from
    assert_equal ["friend@example.com"], email.to
    assert_equal "You have been invited by me@example.com", email.subject
    assert_equal read_fixture("invite").join, email.body.to_s
  end
end
'>Copy</button> </div> <p>In the test we create the email and store the returned object in the <code>email</code> variable. We then ensure that it was sent (the first assert), then, in the second batch of assertions, we ensure that the email does indeed contain what we expect. The helper <code>read_fixture</code> is used to read in the content from this file.</p>
<div class="interstitial note"><p><code>email.body.to_s</code> is present when there's only one (HTML or text) part present. If the mailer provides both, you can test your fixture against specific parts with <code>email.text_part.body.to_s</code> or <code>email.html_part.body.to_s</code>.</p></div>
<p>Here's the content of the <code>invite</code> fixture:</p>
<div class="interstitial code"> <pre data-language="plaintext">Hi friend@example.com,

You have been invited.

Cheers!</pre> <button class="clipboard-button" data-clipboard-text="Hi friend@example.com,

You have been invited.

Cheers!
">Copy</button> </div> <p>This is the right time to understand a little more about writing tests for your mailers. The line <code>ActionMailer::Base.delivery_method = :test</code> in <code>config/environments/test.rb</code> sets the delivery method to test mode so that email will not actually be delivered (useful to avoid spamming your users while testing) but instead it will be appended to an array (<code>ActionMailer::Base.deliveries</code>).</p>
<div class="interstitial note"><p>The <code>ActionMailer::Base.deliveries</code> array is only reset automatically in <code>ActionMailer::TestCase</code> and <code>ActionDispatch::IntegrationTest</code> tests. If you want to have a clean slate outside these test cases, you can reset it manually with: <code>ActionMailer::Base.deliveries.clear</code></p></div>
<h3 id="testing-enqueued-emails"><a class="anchorlink" href="#testing-enqueued-emails"><span>13.2.3</span> Testing Enqueued Emails</a></h3>
<p>You can use the <code>assert_enqueued_email_with</code> assertion to confirm that the email has been enqueued with all of the expected mailer method arguments and/or parameterized mailer parameters. This allows you to match any email that have been enqueued with the <code>deliver_later</code> method.</p>
<p>As with the basic test case, we create the email and store the returned object in the <code>email</code> variable. The following examples include variations of passing arguments and/or parameters.</p>
<p>This example will assert that the email has been enqueued with the correct arguments:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class UserMailerTest &lt; ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.create_invite("me@example.com", "friend@example.com")

    # Test that the email got enqueued with the correct arguments
    assert_enqueued_email_with UserMailer, :create_invite, args: ["me@example.com", "friend@example.com"] do
      email.deliver_later
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class UserMailerTest &lt; ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.create_invite("me@example.com", "friend@example.com")

    # Test that the email got enqueued with the correct arguments
    assert_enqueued_email_with UserMailer, :create_invite, args: ["me@example.com", "friend@example.com"] do
      email.deliver_later
    end
  end
end
'>Copy</button> </div> <p>This example will assert that a mailer has been enqueued with the correct mailer method named arguments by passing a hash of the arguments as <code>args</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class UserMailerTest &lt; ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.create_invite(from: "me@example.com", to: "friend@example.com")

    # Test that the email got enqueued with the correct named arguments
    assert_enqueued_email_with UserMailer, :create_invite, args: [{ from: "me@example.com",
                                                                    to: "friend@example.com" }] do
      email.deliver_later
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class UserMailerTest &lt; ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.create_invite(from: "me@example.com", to: "friend@example.com")

    # Test that the email got enqueued with the correct named arguments
    assert_enqueued_email_with UserMailer, :create_invite, args: [{ from: "me@example.com",
                                                                    to: "friend@example.com" }] do
      email.deliver_later
    end
  end
end
'>Copy</button> </div> <p>This example will assert that a parameterized mailer has been enqueued with the correct parameters and arguments. The mailer parameters are passed as <code>params</code> and the mailer method arguments as <code>args</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class UserMailerTest &lt; ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.with(all: "good").create_invite("me@example.com", "friend@example.com")

    # Test that the email got enqueued with the correct mailer parameters and arguments
    assert_enqueued_email_with UserMailer, :create_invite, params: { all: "good" },
                                                           args: ["me@example.com", "friend@example.com"] do
      email.deliver_later
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class UserMailerTest &lt; ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.with(all: "good").create_invite("me@example.com", "friend@example.com")

    # Test that the email got enqueued with the correct mailer parameters and arguments
    assert_enqueued_email_with UserMailer, :create_invite, params: { all: "good" },
                                                           args: ["me@example.com", "friend@example.com"] do
      email.deliver_later
    end
  end
end
'>Copy</button> </div> <p>This example shows an alternative way to test that a parameterized mailer has been enqueued with the correct parameters:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class UserMailerTest &lt; ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.with(to: "friend@example.com").create_invite

    # Test that the email got enqueued with the correct mailer parameters
    assert_enqueued_email_with UserMailer.with(to: "friend@example.com"), :create_invite do
      email.deliver_later
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class UserMailerTest &lt; ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.with(to: "friend@example.com").create_invite

    # Test that the email got enqueued with the correct mailer parameters
    assert_enqueued_email_with UserMailer.with(to: "friend@example.com"), :create_invite do
      email.deliver_later
    end
  end
end
'>Copy</button> </div> <h2 id="functional-and-system-testing"><a class="anchorlink" href="#functional-and-system-testing"><span>13.3</span> Functional and System Testing</a></h2>
<p>Unit testing allows us to test the attributes of the email while functional and system testing allows us to test whether user interactions appropriately trigger the email to be delivered. For example, you can check that the invite friend operation is sending an email appropriately:</p>
<div class="interstitial code"> <pre data-language="ruby"># Integration Test
require "test_helper"

class UsersControllerTest &lt; ActionDispatch::IntegrationTest
  test "invite friend" do
    # Asserts the difference in the ActionMailer::Base.deliveries
    assert_emails 1 do
      post invite_friend_url, params: { email: "friend@example.com" }
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='# Integration Test
require "test_helper"

class UsersControllerTest &lt; ActionDispatch::IntegrationTest
  test "invite friend" do
    # Asserts the difference in the ActionMailer::Base.deliveries
    assert_emails 1 do
      post invite_friend_url, params: { email: "friend@example.com" }
    end
  end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby"># System Test
require "test_helper"

class UsersTest &lt; ActionDispatch::SystemTestCase
  driven_by :selenium, using: :headless_chrome

  test "inviting a friend" do
    visit invite_users_url
    fill_in "Email", with: "friend@example.com"
    assert_emails 1 do
      click_on "Invite"
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='# System Test
require "test_helper"

class UsersTest &lt; ActionDispatch::SystemTestCase
  driven_by :selenium, using: :headless_chrome

  test "inviting a friend" do
    visit invite_users_url
    fill_in "Email", with: "friend@example.com"
    assert_emails 1 do
      click_on "Invite"
    end
  end
end
'>Copy</button> </div> <div class="interstitial note"><p>The <code>assert_emails</code> method is not tied to a particular deliver method and will work with emails delivered with either the <code>deliver_now</code> or <code>deliver_later</code> method. If we explicitly want to assert that the email has been enqueued we can use the <code>assert_enqueued_email_with</code> (<a href="#testing-enqueued-emails">examples above</a>) or <code>assert_enqueued_emails</code> methods. More information can be found in the <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/TestHelper.html">documentation here</a>.</p></div>
<h1 id="testing-jobs"><a class="anchorlink" href="#testing-jobs"><span>14</span> Testing Jobs</a></h1>
<p>Jobs can be tested in isolation (focusing on the job's behavior) and in context (focusing on the calling code's behavior).</p>
<h2 id="testing-jobs-in-isolation"><a class="anchorlink" href="#testing-jobs-in-isolation"><span>14.1</span> Testing Jobs in Isolation</a></h2>
<p>When you generate a job, an associated test file will also be generated in the <code>test/jobs</code> directory.</p>
<p>Here is an example test for a billing job:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class BillingJobTest &lt; ActiveJob::TestCase
  test "account is charged" do
    perform_enqueued_jobs do
      BillingJob.perform_later(account, product)
    end
    assert account.reload.charged_for?(product)
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class BillingJobTest &lt; ActiveJob::TestCase
  test "account is charged" do
    perform_enqueued_jobs do
      BillingJob.perform_later(account, product)
    end
    assert account.reload.charged_for?(product)
  end
end
'>Copy</button> </div> <p>The default queue adapter for tests will not perform jobs until <a href="https://edgeapi.rubyonrails.org/classes/ActiveJob/TestHelper.html#method-i-perform_enqueued_jobs"><code>perform_enqueued_jobs</code></a> is called. Additionally, it will clear all jobs before each test is run so that tests do not interfere with each other.</p>
<p>The test uses <code>perform_enqueued_jobs</code> and <a href="https://edgeapi.rubyonrails.org/classes/ActiveJob/Enqueuing/ClassMethods.html#method-i-perform_later"><code>perform_later</code></a> instead of <a href="https://edgeapi.rubyonrails.org/classes/ActiveJob/Execution/ClassMethods.html#method-i-perform_now"><code>perform_now</code></a> so that if retries are configured, retry failures are caught by the test instead of being re-enqueued and ignored.</p>
<h2 id="testing-jobs-in-context"><a class="anchorlink" href="#testing-jobs-in-context"><span>14.2</span> Testing Jobs in Context</a></h2>
<p>It's good practice to test that jobs are correctly enqueued, for example, by a controller action. The <a href="https://edgeapi.rubyonrails.org/classes/ActiveJob/TestHelper.html"><code>ActiveJob::TestHelper</code></a> module provides several methods that can help with this, such as <a href="https://edgeapi.rubyonrails.org/classes/ActiveJob/TestHelper.html#method-i-assert_enqueued_with"><code>assert_enqueued_with</code></a>.</p>
<p>Here is an example that tests an account model method:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class AccountTest &lt; ActiveSupport::TestCase
  include ActiveJob::TestHelper

  test "#charge_for enqueues billing job" do
    assert_enqueued_with(job: BillingJob) do
      account.charge_for(product)
    end

    assert_not account.reload.charged_for?(product)

    perform_enqueued_jobs

    assert account.reload.charged_for?(product)
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class AccountTest &lt; ActiveSupport::TestCase
  include ActiveJob::TestHelper

  test "#charge_for enqueues billing job" do
    assert_enqueued_with(job: BillingJob) do
      account.charge_for(product)
    end

    assert_not account.reload.charged_for?(product)

    perform_enqueued_jobs

    assert account.reload.charged_for?(product)
  end
end
'>Copy</button> </div> <h2 id="testing-that-exceptions-are-raised"><a class="anchorlink" href="#testing-that-exceptions-are-raised"><span>14.3</span> Testing that Exceptions are Raised</a></h2>
<p>Testing that your job raises an exception in certain cases can be tricky, especially when you have retries configured. The <code>perform_enqueued_jobs</code> helper fails any test where a job raises an exception, so to have the test succeed when the exception is raised you have to call the job's <code>perform</code> method directly.</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class BillingJobTest &lt; ActiveJob::TestCase
  test "does not charge accounts with insufficient funds" do
    assert_raises(InsufficientFundsError) do
      BillingJob.new(empty_account, product).perform
    end
    refute account.reload.charged_for?(product)
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class BillingJobTest &lt; ActiveJob::TestCase
  test "does not charge accounts with insufficient funds" do
    assert_raises(InsufficientFundsError) do
      BillingJob.new(empty_account, product).perform
    end
    refute account.reload.charged_for?(product)
  end
end
'>Copy</button> </div> <p>This method is not recommended in general, as it circumvents some parts of the framework, such as argument serialization.</p>
<h1 id="testing-action-cable"><a class="anchorlink" href="#testing-action-cable"><span>15</span> Testing Action Cable</a></h1>
<p>Since Action Cable is used at different levels inside your application, you'll need to test both the channels, connection classes themselves, and that other entities broadcast correct messages.</p>
<h2 id="connection-test-case"><a class="anchorlink" href="#connection-test-case"><span>15.1</span> Connection Test Case</a></h2>
<p>By default, when you generate a new Rails application with Action Cable, a test for the base connection class (<code>ApplicationCable::Connection</code>) is generated as well under <code>test/channels/application_cable</code> directory.</p>
<p>Connection tests aim to check whether a connection's identifiers get assigned properly or that any improper connection requests are rejected. Here is an example:</p>
<div class="interstitial code"> <pre data-language="ruby">class ApplicationCable::ConnectionTest &lt; ActionCable::Connection::TestCase
  test "connects with params" do
    # Simulate a connection opening by calling the `connect` method
    connect params: { user_id: 42 }

    # You can access the Connection object via `connection` in tests
    assert_equal connection.user_id, "42"
  end

  test "rejects connection without params" do
    # Use `assert_reject_connection` matcher to verify that
    # connection is rejected
    assert_reject_connection { connect }
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class ApplicationCable::ConnectionTest &lt; ActionCable::Connection::TestCase
  test "connects with params" do
    # Simulate a connection opening by calling the `connect` method
    connect params: { user_id: 42 }

    # You can access the Connection object via `connection` in tests
    assert_equal connection.user_id, "42"
  end

  test "rejects connection without params" do
    # Use `assert_reject_connection` matcher to verify that
    # connection is rejected
    assert_reject_connection { connect }
  end
end
'>Copy</button> </div> <p>You can also specify request cookies the same way you do in integration tests:</p>
<div class="interstitial code"> <pre data-language="ruby">test "connects with cookies" do
  cookies.signed[:user_id] = "42"

  connect

  assert_equal connection.user_id, "42"
end</pre> <button class="clipboard-button" data-clipboard-text='test "connects with cookies" do
  cookies.signed[:user_id] = "42"

  connect

  assert_equal connection.user_id, "42"
end
'>Copy</button> </div> <p>See the API documentation for <a href="https://edgeapi.rubyonrails.org/classes/ActionCable/Connection/TestCase.html"><code>ActionCable::Connection::TestCase</code></a> for more information.</p>
<h2 id="channel-test-case"><a class="anchorlink" href="#channel-test-case"><span>15.2</span> Channel Test Case</a></h2>
<p>By default, when you generate a channel, an associated test will be generated as well under the <code>test/channels</code> directory. Here's an example test with a chat channel:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class ChatChannelTest &lt; ActionCable::Channel::TestCase
  test "subscribes and stream for room" do
    # Simulate a subscription creation by calling `subscribe`
    subscribe room: "15"

    # You can access the Channel object via `subscription` in tests
    assert subscription.confirmed?
    assert_has_stream "chat_15"
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class ChatChannelTest &lt; ActionCable::Channel::TestCase
  test "subscribes and stream for room" do
    # Simulate a subscription creation by calling `subscribe`
    subscribe room: "15"

    # You can access the Channel object via `subscription` in tests
    assert subscription.confirmed?
    assert_has_stream "chat_15"
  end
end
'>Copy</button> </div> <p>This test is pretty simple and only asserts that the channel subscribes the connection to a particular stream.</p>
<p>You can also specify the underlying connection identifiers. Here's an example test with a web notifications channel:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class WebNotificationsChannelTest &lt; ActionCable::Channel::TestCase
  test "subscribes and stream for user" do
    stub_connection current_user: users(:john)

    subscribe

    assert_has_stream_for users(:john)
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class WebNotificationsChannelTest &lt; ActionCable::Channel::TestCase
  test "subscribes and stream for user" do
    stub_connection current_user: users(:john)

    subscribe

    assert_has_stream_for users(:john)
  end
end
'>Copy</button> </div> <p>See the API documentation for <a href="https://edgeapi.rubyonrails.org/classes/ActionCable/Channel/TestCase.html"><code>ActionCable::Channel::TestCase</code></a> for more information.</p>
<h2 id="custom-assertions-and-testing-broadcasts-inside-other-components"><a class="anchorlink" href="#custom-assertions-and-testing-broadcasts-inside-other-components"><span>15.3</span> Custom Assertions And Testing Broadcasts Inside Other Components</a></h2>
<p>Action Cable ships with a bunch of custom assertions that can be used to lessen the verbosity of tests. For a full list of available assertions, see the API documentation for <a href="https://edgeapi.rubyonrails.org/classes/ActionCable/TestHelper.html"><code>ActionCable::TestHelper</code></a>.</p>
<p>It's a good practice to ensure that the correct message has been broadcasted inside other components (e.g. inside your controllers). This is precisely where the custom assertions provided by Action Cable are pretty useful. For instance, within a model:</p>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class ProductTest &lt; ActionCable::TestCase
  test "broadcast status after charge" do
    assert_broadcast_on("products:#{product.id}", type: "charged") do
      product.charge(account)
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class ProductTest &lt; ActionCable::TestCase
  test "broadcast status after charge" do
    assert_broadcast_on("products:#{product.id}", type: "charged") do
      product.charge(account)
    end
  end
end
'>Copy</button> </div> <p>If you want to test the broadcasting made with <code>Channel.broadcast_to</code>, you should use <code>Channel.broadcasting_for</code> to generate an underlying stream name:</p>
<div class="interstitial code"> <pre data-language="ruby"># app/jobs/chat_relay_job.rb
class ChatRelayJob &lt; ApplicationJob
  def perform(room, message)
    ChatChannel.broadcast_to room, text: message
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class ChatRelayJob &lt; ApplicationJob
  def perform(room, message)
    ChatChannel.broadcast_to room, text: message
  end
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby"># test/jobs/chat_relay_job_test.rb
require "test_helper"

class ChatRelayJobTest &lt; ActiveJob::TestCase
  include ActionCable::TestHelper

  test "broadcast message to room" do
    room = rooms(:all)

    assert_broadcast_on(ChatChannel.broadcasting_for(room), text: "Hi!") do
      ChatRelayJob.perform_now(room, "Hi!")
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class ChatRelayJobTest &lt; ActiveJob::TestCase
  include ActionCable::TestHelper

  test "broadcast message to room" do
    room = rooms(:all)

    assert_broadcast_on(ChatChannel.broadcasting_for(room), text: "Hi!") do
      ChatRelayJob.perform_now(room, "Hi!")
    end
  end
end
'>Copy</button> </div> <h1 id="testing-eager-loading"><a class="anchorlink" href="#testing-eager-loading"><span>16</span> Testing Eager Loading</a></h1>
<p>Normally, applications do not eager load in the <code>development</code> or <code>test</code> environments to speed things up. But they do in the <code>production</code> environment.</p>
<p>If some file in the project cannot be loaded for whatever reason, you better detect it before deploying to production, right?</p>
<h2 id="continuous-integration"><a class="anchorlink" href="#continuous-integration"><span>16.1</span> Continuous Integration</a></h2>
<p>If your project has CI in place, eager loading in CI is an easy way to ensure the application eager loads.</p>
<p>CIs typically set some environment variable to indicate the test suite is running there. For example, it could be <code>CI</code>:</p>
<div class="interstitial code"> <pre data-language="ruby"># config/environments/test.rb
config.eager_load = ENV["CI"].present?</pre> <button class="clipboard-button" data-clipboard-text='config.eager_load = ENV["CI"].present?
'>Copy</button> </div> <p>Starting with Rails 7, newly generated applications are configured that way by default.</p>
<h2 id="bare-test-suites"><a class="anchorlink" href="#bare-test-suites"><span>16.2</span> Bare Test Suites</a></h2>
<p>If your project does not have continuous integration, you can still eager load in the test suite by calling <code>Rails.application.eager_load!</code>:</p>
<h3 id="minitest"><a class="anchorlink" href="#minitest"><span>16.2.1</span> Minitest</a></h3>
<div class="interstitial code"> <pre data-language="ruby">require "test_helper"

class ZeitwerkComplianceTest &lt; ActiveSupport::TestCase
  test "eager loads all files without errors" do
    assert_nothing_raised { Rails.application.eager_load! }
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "test_helper"

class ZeitwerkComplianceTest &lt; ActiveSupport::TestCase
  test "eager loads all files without errors" do
    assert_nothing_raised { Rails.application.eager_load! }
  end
end
'>Copy</button> </div> <h3 id="rspec"><a class="anchorlink" href="#rspec"><span>16.2.2</span> RSpec</a></h3>
<div class="interstitial code"> <pre data-language="ruby">require "rails_helper"

RSpec.describe "Zeitwerk compliance" do
  it "eager loads all files without errors" do
    expect { Rails.application.eager_load! }.not_to raise_error
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "rails_helper"

RSpec.describe "Zeitwerk compliance" do
  it "eager loads all files without errors" do
    expect { Rails.application.eager_load! }.not_to raise_error
  end
end
'>Copy</button> </div> <h1 id="additional-testing-resources"><a class="anchorlink" href="#additional-testing-resources"><span>17</span> Additional Testing Resources</a></h1>
<h2 id="testing-time-dependent-code"><a class="anchorlink" href="#testing-time-dependent-code"><span>17.1</span> Testing Time-Dependent Code</a></h2>
<p>Rails provides built-in helper methods that enable you to assert that your time-sensitive code works as expected.</p>
<p>The following example uses the <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html#method-i-travel_to"><code>travel_to</code></a> helper:</p>
<div class="interstitial code"> <pre data-language="ruby"># Given a user is eligible for gifting a month after they register.
user = User.create(name: "Gaurish", activation_date: Date.new(2004, 10, 24))
assert_not user.applicable_for_gifting?

travel_to Date.new(2004, 11, 24) do
  # Inside the `travel_to` block `Date.current` is stubbed
  assert_equal Date.new(2004, 10, 24), user.activation_date
  assert user.applicable_for_gifting?
end

# The change was visible only inside the `travel_to` block.
assert_equal Date.new(2004, 10, 24), user.activation_date</pre> <button class="clipboard-button" data-clipboard-text='# Given a user is eligible for gifting a month after they register.
user = User.create(name: "Gaurish", activation_date: Date.new(2004, 10, 24))
assert_not user.applicable_for_gifting?

travel_to Date.new(2004, 11, 24) do
  # Inside the `travel_to` block `Date.current` is stubbed
  assert_equal Date.new(2004, 10, 24), user.activation_date
  assert user.applicable_for_gifting?
end

# The change was visible only inside the `travel_to` block.
assert_equal Date.new(2004, 10, 24), user.activation_date
'>Copy</button> </div> <p>Please see <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html"><code>ActiveSupport::Testing::TimeHelpers</code></a> API reference for more information about the available time helpers.</p> <hr> <h2>Feedback</h2> <p> You're encouraged to help improve the quality of this guide. </p> <p> Please contribute if you see any typos or factual errors. To get started, you can read our <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">documentation contributions</a> section. </p> <p> You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check <a href="https://edgeguides.rubyonrails.org">Edge Guides</a> first to verify if the issues are already fixed or not on the main branch. Check the <span>Ruby on Rails Guides Guidelines</span> for style and conventions. </p> <p> If for whatever reason you spot something to fix but cannot patch it yourself, please <a href="https://github.com/rails/rails/issues">open an issue</a>. </p> <p>And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">official Ruby on Rails Forum</a>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2021 David Heinemeier Hansson<br>Licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.<br>
    
  </p>
</div>
