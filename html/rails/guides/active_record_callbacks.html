<h1>Active Record Callbacks</h1>
<div class="_simple"> <p>This guide teaches you how to hook into the life cycle of your Active Record objects.</p>
<p>After reading this guide, you will know:</p> <ul> <li>When certain events occur during the life of an Active Record object.</li> <li>How to register, run, and skip callbacks that respond to these events.</li> <li>How to create relational, association, conditional, and transactional callbacks.</li> <li>How to create objects that encapsulate common behavior for your callbacks to be reused.</li> </ul>  <h2 class="chapter">  Chapters </h2> <ol class="chapters"> <li><a href="#the-object-life-cycle">The Object Life Cycle</a></li> <li>
<a href="#callback-registration">Callback Registration</a> <ul> <li><a href="#registering-callbacks-to-fire-on-life-cycle-events">Registering Callbacks to Fire on Life Cycle Events</a></li> </ul>
</li> <li>
<a href="#available-callbacks">Available Callbacks</a> <ul> <li><a href="#creating-an-object">Creating an Object</a></li> <li><a href="#updating-an-object">Updating an Object</a></li> <li><a href="#destroying-an-object">Destroying an Object</a></li> <li><a href="#after-initialize-and-after-find"><code>after_initialize</code> and <code>after_find</code></a></li> <li><a href="#after-touch"><code>after_touch</code></a></li> </ul>
</li> <li><a href="#running-callbacks">Running Callbacks</a></li> <li>
<a href="#conditional-callbacks">Conditional Callbacks</a> <ul> <li><a href="#using-if-and-unless-with-a-symbol">Using <code>:if</code> and <code>:unless</code> with a <code>Symbol</code></a></li> <li><a href="#using-if-and-unless-with-a-proc">Using <code>:if</code> and <code>:unless</code> with a <code>Proc</code></a></li> <li><a href="#multiple-callback-conditions">Multiple Callback Conditions</a></li> <li><a href="#using-both-if-and-unless">Using Both <code>:if</code> and <code>:unless</code></a></li> </ul>
</li> <li><a href="#skipping-callbacks">Skipping Callbacks</a></li> <li><a href="#suppressing-callbacks">Suppressing Callbacks</a></li> <li><a href="#halting-execution">Halting Execution</a></li> <li><a href="#association-callbacks">Association Callbacks</a></li> <li><a href="#cascading-association-callbacks">Cascading Association Callbacks</a></li> <li>
<a href="#transaction-callbacks">Transaction Callbacks</a> <ul> <li><a href="#after-commit-and-after-rollback"><code>after_commit</code> and <code>after_rollback</code></a></li> <li><a href="#aliases-for-after-commit">Aliases for <code>after_commit</code></a></li> <li><a href="#transactional-callback-ordering">Transactional Callback Ordering</a></li> </ul>
</li> <li><a href="#callback-objects">Callback Objects</a></li> </ol>  <hr>  <h1 id="the-object-life-cycle"><a class="anchorlink" href="#the-object-life-cycle"><span>1</span> The Object Life Cycle</a></h1>
<p>During the normal operation of a Rails application, objects may be <a href="active_record_basics.html#crud-reading-and-writing-data">created, updated, and destroyed</a>. Active Record provides hooks into this object life cycle so that you can control your application and its data.</p>
<p>Callbacks allow you to trigger logic before or after a change to an object's state. They are methods that get called at certain moments of an object's life cycle. With callbacks it is possible to write code that will run whenever an Active Record object is initialized, created, saved, updated, deleted, validated, or loaded from the database.</p>
<div class="interstitial code"> <pre data-language="ruby">class BirthdayCake &lt; ApplicationRecord
  after_create -&gt; { Rails.logger.info("Congratulations, the callback has run!") }
end</pre> <button class="clipboard-button" data-clipboard-text='class BirthdayCake &lt; ApplicationRecord
  after_create -&gt; { Rails.logger.info("Congratulations, the callback has run!") }
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; BirthdayCake.create
Congratulations, the callback has run!</pre> <button class="clipboard-button" data-clipboard-text="BirthdayCake.create
">Copy</button> </div> <p>As you will see, there are many life cycle events and multiple options to hook into these — either before, after, or even around them.</p>
<h1 id="callback-registration"><a class="anchorlink" href="#callback-registration"><span>2</span> Callback Registration</a></h1>
<p>To use the available callbacks, you need to implement and register them. Implementation can be done in a multitude of ways like using ordinary methods, blocks and procs, or defining custom callback objects using classes or modules. Let's go through each of these implementation techniques.</p>
<p>You can register the callbacks with a <strong>macro-style class method that calls an ordinary method</strong> for implementation.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  validates :username, :email, presence: true

  before_validation :ensure_username_has_value

  private
    def ensure_username_has_value
      if username.blank?
        self.username = email
      end
    end
end</pre> <button class="clipboard-button" data-clipboard-text="class User &lt; ApplicationRecord
  validates :username, :email, presence: true

  before_validation :ensure_username_has_value

  private
    def ensure_username_has_value
      if username.blank?
        self.username = email
      end
    end
end
">Copy</button> </div> <p>The <strong>macro-style class methods can also receive a block</strong>. Consider using this style if the code inside your block is so short that it fits in a single line:</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  validates :username, :email, presence: true

  before_validation do
    self.username = email if username.blank?
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class User &lt; ApplicationRecord
  validates :username, :email, presence: true

  before_validation do
    self.username = email if username.blank?
  end
end
">Copy</button> </div> <p>Alternatively, you can <strong>pass a proc to the callback</strong> to be triggered.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  validates :username, :email, presence: true

  before_validation -&gt;(user) { user.username = user.email if user.username.blank? }
end</pre> <button class="clipboard-button" data-clipboard-text="class User &lt; ApplicationRecord
  validates :username, :email, presence: true

  before_validation -&gt;(user) { user.username = user.email if user.username.blank? }
end
">Copy</button> </div> <p>Lastly, you can define <a href="#callback-objects"><strong>a custom callback object</strong></a>, as shown below. We will cover these later in more detail.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  validates :username, :email, presence: true

  before_validation AddUsername
end

class AddUsername
  def self.before_validation(record)
    if record.username.blank?
      record.username = record.email
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class User &lt; ApplicationRecord
  validates :username, :email, presence: true

  before_validation AddUsername
end

class AddUsername
  def self.before_validation(record)
    if record.username.blank?
      record.username = record.email
    end
  end
end
">Copy</button> </div> <h2 id="registering-callbacks-to-fire-on-life-cycle-events"><a class="anchorlink" href="#registering-callbacks-to-fire-on-life-cycle-events"><span>2.1</span> Registering Callbacks to Fire on Life Cycle Events</a></h2>
<p>Callbacks can also be registered to only fire on certain life cycle events, this can be done using the <code>:on</code> option and allows complete control over when and in what context your callbacks are triggered.</p>
<div class="interstitial note"><p>A context is like a category or a scenario in which you want certain validations to apply. When you validate an ActiveRecord model, you can specify a context to group validations. This allows you to have different sets of validations that apply in different situations. In Rails, there are certain default contexts for validations like :create, :update, and :save.</p></div>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  validates :username, :email, presence: true

  before_validation :ensure_username_has_value, on: :create

  # :on takes an array as well
  after_validation :set_location, on: [ :create, :update ]

  private
    def ensure_username_has_value
      if username.blank?
        self.username = email
      end
    end

    def set_location
      self.location = LocationService.query(self)
    end
end</pre> <button class="clipboard-button" data-clipboard-text="class User &lt; ApplicationRecord
  validates :username, :email, presence: true

  before_validation :ensure_username_has_value, on: :create

  # :on takes an array as well
  after_validation :set_location, on: [ :create, :update ]

  private
    def ensure_username_has_value
      if username.blank?
        self.username = email
      end
    end

    def set_location
      self.location = LocationService.query(self)
    end
end
">Copy</button> </div> <div class="interstitial note"><p>It is considered good practice to declare callback methods as private. If left public, they can be called from outside of the model and violate the principle of object encapsulation.</p></div>
<div class="interstitial warning"><p>Refrain from using methods like <code>update</code>, <code>save</code>, or any other methods that cause side effects on the object within your callback methods. <br><br> For instance, avoid calling <code>update(attribute: "value")</code> inside a callback. This practice can modify the model's state and potentially lead to unforeseen side effects during commit. <br><br> Instead, you can assign values directly (e.g., <code>self.attribute = "value"</code>) in <code>before_create</code>, <code>before_update</code>, or earlier callbacks for a safer approach.</p></div>
<h1 id="available-callbacks"><a class="anchorlink" href="#available-callbacks"><span>3</span> Available Callbacks</a></h1>
<p>Here is a list with all the available Active Record callbacks, listed <strong>in the order in which they will get called</strong> during the respective operations:</p>
<h2 id="creating-an-object"><a class="anchorlink" href="#creating-an-object"><span>3.1</span> Creating an Object</a></h2> <ul> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-before_validation"><code>before_validation</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-after_validation"><code>after_validation</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_save"><code>before_save</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_save"><code>around_save</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_create"><code>before_create</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_create"><code>around_create</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_create"><code>after_create</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_save"><code>after_save</code></a></li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> / <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a>
</li> </ul> <p>See the <a href="active_record_callbacks.html#after-commit-and-after-rollback"><code>after_commit</code> / <code>after_rollback</code> section</a> for examples using these two callbacks.</p>
<p>There are examples below that show how to use these callbacks. We've grouped them by the operation they are associated with, and lastly show how they can be used in combination.</p>
<h3 id="validation-callbacks"><a class="anchorlink" href="#validation-callbacks"><span>3.1.1</span> Validation Callbacks</a></h3>
<p>Validation callbacks are triggered whenever the record is validated directly via the <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations.html#method-i-valid-3F"><code>valid?</code></a> ( or its alias <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations.html#method-i-validate"><code>validate</code></a>) or <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations.html#method-i-invalid-3F"><code>invalid?</code></a> method, or indirectly via <code>create</code>, <code>update</code>, or <code>save</code>. They are called before and after the validation phase.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  validates :name, presence: true
  before_validation :titleize_name
  after_validation :log_errors

  private
    def titleize_name
      self.name = name.downcase.titleize if name.present?
      Rails.logger.info("Name titleized to #{name}")
    end

    def log_errors
      if errors.any?
        Rails.logger.error("Validation failed: #{errors.full_messages.join(', ')}")
      end
    end
end</pre> <button class="clipboard-button" data-clipboard-text="class User &lt; ApplicationRecord
  validates :name, presence: true
  before_validation :titleize_name
  after_validation :log_errors

  private
    def titleize_name
      self.name = name.downcase.titleize if name.present?
      Rails.logger.info(&quot;Name titleized to #{name}&quot;)
    end

    def log_errors
      if errors.any?
        Rails.logger.error(&quot;Validation failed: #{errors.full_messages.join(', ')}&quot;)
      end
    end
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.new(name: "", email: "john.doe@example.com", password: "abc123456")
=&gt; #&lt;User id: nil, email: "john.doe@example.com", created_at: nil, updated_at: nil, name: ""&gt;

irb&gt; user.valid?
Name titleized to
Validation failed: Name can't be blank
=&gt; false</pre> <button class="clipboard-button" data-clipboard-text='user = User.new(name: "", email: "john.doe@example.com", password: "abc123456")
user.valid?
'>Copy</button> </div> <h3 id="save-callbacks"><a class="anchorlink" href="#save-callbacks"><span>3.1.2</span> Save Callbacks</a></h3>
<p>Save callbacks are triggered whenever the record is persisted (i.e. "saved") to the underlying database, via the <code>create</code>, <code>update</code>, or <code>save</code> methods. They are called before, after, and around the object is saved.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  before_save :hash_password
  around_save :log_saving
  after_save :update_cache

  private
    def hash_password
      self.password_digest = BCrypt::Password.create(password)
      Rails.logger.info("Password hashed for user with email: #{email}")
    end

    def log_saving
      Rails.logger.info("Saving user with email: #{email}")
      yield
      Rails.logger.info("User saved with email: #{email}")
    end

    def update_cache
      Rails.cache.write(["user_data", self], attributes)
      Rails.logger.info("Update Cache")
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  before_save :hash_password
  around_save :log_saving
  after_save :update_cache

  private
    def hash_password
      self.password_digest = BCrypt::Password.create(password)
      Rails.logger.info("Password hashed for user with email: #{email}")
    end

    def log_saving
      Rails.logger.info("Saving user with email: #{email}")
      yield
      Rails.logger.info("User saved with email: #{email}")
    end

    def update_cache
      Rails.cache.write(["user_data", self], attributes)
      Rails.logger.info("Update Cache")
    end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.create(name: "Jane Doe", password: "password", email: "jane.doe@example.com")

Password encrypted for user with email: jane.doe@example.com
Saving user with email: jane.doe@example.com
User saved with email: jane.doe@example.com
Update Cache
=&gt; #&lt;User id: 1, email: "jane.doe@example.com", created_at: "2024-03-20 16:02:43.685500000 +0000", updated_at: "2024-03-20 16:02:43.685500000 +0000", name: "Jane Doe"&gt;</pre> <button class="clipboard-button" data-clipboard-text='user = User.create(name: "Jane Doe", password: "password", email: "jane.doe@example.com")
'>Copy</button> </div> <h3 id="create-callbacks"><a class="anchorlink" href="#create-callbacks"><span>3.1.3</span> Create Callbacks</a></h3>
<p>Create callbacks are triggered whenever the record is persisted (i.e. "saved") to the underlying database <strong>for the first time</strong> — in other words, when we're saving a new record, via the <code>create</code> or <code>save</code> methods. They are called before, after and around the object is created.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  before_create :set_default_role
  around_create :log_creation
  after_create :send_welcome_email

  private
    def set_default_role
      self.role = "user"
      Rails.logger.info("User role set to default: user")
    end

    def log_creation
      Rails.logger.info("Creating user with email: #{email}")
      yield
      Rails.logger.info("User created with email: #{email}")
    end

    def send_welcome_email
      UserMailer.welcome_email(self).deliver_later
      Rails.logger.info("User welcome email sent to: #{email}")
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  before_create :set_default_role
  around_create :log_creation
  after_create :send_welcome_email

  private
    def set_default_role
      self.role = "user"
      Rails.logger.info("User role set to default: user")
    end

    def log_creation
      Rails.logger.info("Creating user with email: #{email}")
      yield
      Rails.logger.info("User created with email: #{email}")
    end

    def send_welcome_email
      UserMailer.welcome_email(self).deliver_later
      Rails.logger.info("User welcome email sent to: #{email}")
    end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.create(name: "John Doe", email: "john.doe@example.com")

User role set to default: user
Creating user with email: john.doe@example.com
User created with email: john.doe@example.com
User welcome email sent to: john.doe@example.com
=&gt; #&lt;User id: 10, email: "john.doe@example.com", created_at: "2024-03-20 16:19:52.405195000 +0000", updated_at: "2024-03-20 16:19:52.405195000 +0000", name: "John Doe"&gt;</pre> <button class="clipboard-button" data-clipboard-text='user = User.create(name: "John Doe", email: "john.doe@example.com")
'>Copy</button> </div> <h2 id="updating-an-object"><a class="anchorlink" href="#updating-an-object"><span>3.2</span> Updating an Object</a></h2>
<p>Update callbacks are triggered whenever an <strong>existing</strong> record is persisted (i.e. "saved") to the underlying database. They are called before, after and around the object is updated.</p> <ul> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-before_validation"><code>before_validation</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-after_validation"><code>after_validation</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_save"><code>before_save</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_save"><code>around_save</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_update"><code>before_update</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_update"><code>around_update</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_update"><code>after_update</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_save"><code>after_save</code></a></li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> / <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a>
</li> </ul> <div class="interstitial warning"><p>The <code>after_save</code> callback is triggered on both create and update operations. However, it consistently executes after the more specific callbacks <code>after_create</code> and <code>after_update</code>, regardless of the sequence in which the macro calls were made. Similarly, before and around save callbacks follow the same rule: <code>before_save</code> runs before create/update, and <code>around_save</code> runs around create/update operations. It's important to note that save callbacks will always run before/around/after the more specific create/update callbacks.</p></div>
<p>We've already covered <a href="#validation-callbacks">validation</a> and <a href="#save-callbacks">save</a> callbacks. See the <a href="#after-commit-and-after-rollback"><code>after_commit</code> / <code>after_rollback</code> section</a> for examples using these two callbacks.</p>
<h3 id="update-callbacks"><a class="anchorlink" href="#update-callbacks"><span>3.2.1</span> Update Callbacks</a></h3>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  before_update :check_role_change
  around_update :log_updating
  after_update :send_update_email

  private
    def check_role_change
      if role_changed?
        Rails.logger.info("User role changed to #{role}")
      end
    end

    def log_updating
      Rails.logger.info("Updating user with email: #{email}")
      yield
      Rails.logger.info("User updated with email: #{email}")
    end

    def send_update_email
      UserMailer.update_email(self).deliver_later
      Rails.logger.info("Update email sent to: #{email}")
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  before_update :check_role_change
  around_update :log_updating
  after_update :send_update_email

  private
    def check_role_change
      if role_changed?
        Rails.logger.info("User role changed to #{role}")
      end
    end

    def log_updating
      Rails.logger.info("Updating user with email: #{email}")
      yield
      Rails.logger.info("User updated with email: #{email}")
    end

    def send_update_email
      UserMailer.update_email(self).deliver_later
      Rails.logger.info("Update email sent to: #{email}")
    end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.find(1)
=&gt; #&lt;User id: 1, email: "john.doe@example.com", created_at: "2024-03-20 16:19:52.405195000 +0000", updated_at: "2024-03-20 16:19:52.405195000 +0000", name: "John Doe", role: "user" &gt;

irb&gt; user.update(role: "admin")
User role changed to admin
Updating user with email: john.doe@example.com
User updated with email: john.doe@example.com
Update email sent to: john.doe@example.com</pre> <button class="clipboard-button" data-clipboard-text='user = User.find(1)
user.update(role: "admin")
'>Copy</button> </div> <h3 id="using-a-combination-of-callbacks"><a class="anchorlink" href="#using-a-combination-of-callbacks"><span>3.2.2</span> Using a Combination of Callbacks</a></h3>
<p>Often, you will need to use a combination of callbacks to achieve the desired behavior. For example, you may want to send a confirmation email after a user is created, but only if the user is new and not being updated. When a user is updated, you may want to notify an admin if critical information is changed. In this case, you can use <code>after_create</code> and <code>after_update</code> callbacks together.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  after_create :send_confirmation_email
  after_update :notify_admin_if_critical_info_updated

  private
    def send_confirmation_email
      UserMailer.confirmation_email(self).deliver_later
      Rails.logger.info("Confirmation email sent to: #{email}")
    end

    def notify_admin_if_critical_info_updated
      if saved_change_to_email? || saved_change_to_phone_number?
        AdminMailer.user_critical_info_updated(self).deliver_later
        Rails.logger.info("Notification sent to admin about critical info update for: #{email}")
      end
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  after_create :send_confirmation_email
  after_update :notify_admin_if_critical_info_updated

  private
    def send_confirmation_email
      UserMailer.confirmation_email(self).deliver_later
      Rails.logger.info("Confirmation email sent to: #{email}")
    end

    def notify_admin_if_critical_info_updated
      if saved_change_to_email? || saved_change_to_phone_number?
        AdminMailer.user_critical_info_updated(self).deliver_later
        Rails.logger.info("Notification sent to admin about critical info update for: #{email}")
      end
    end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.create(name: "John Doe", email: "john.doe@example.com")
Confirmation email sent to: john.doe@example.com
=&gt; #&lt;User id: 1, email: "john.doe@example.com", ...&gt;

irb&gt; user.update(email: "john.doe.new@example.com")
Notification sent to admin about critical info update for: john.doe.new@example.com
=&gt; true</pre> <button class="clipboard-button" data-clipboard-text='user = User.create(name: "John Doe", email: "john.doe@example.com")
user.update(email: "john.doe.new@example.com")
'>Copy</button> </div> <h2 id="destroying-an-object"><a class="anchorlink" href="#destroying-an-object"><span>3.3</span> Destroying an Object</a></h2>
<p>Destroy callbacks are triggered whenever a record is destroyed, but ignored when a record is deleted. They are called before, after and around the object is destroyed.</p> <ul> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_destroy"><code>before_destroy</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_destroy"><code>around_destroy</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_destroy"><code>after_destroy</code></a></li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> / <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a>
</li> </ul> <p>Find <a href="#after-commit-and-after-rollback">examples for using <code>after_commit</code> / <code>after_rollback</code></a>.</p>
<h3 id="destroy-callbacks"><a class="anchorlink" href="#destroy-callbacks"><span>3.3.1</span> Destroy Callbacks</a></h3>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  before_destroy :check_admin_count
  around_destroy :log_destroy_operation
  after_destroy :notify_users

  private
    def check_admin_count
      if admin? &amp;&amp; User.where(role: "admin").count == 1
        throw :abort
      end
      Rails.logger.info("Checked the admin count")
    end

    def log_destroy_operation
      Rails.logger.info("About to destroy user with ID #{id}")
      yield
      Rails.logger.info("User with ID #{id} destroyed successfully")
    end

    def notify_users
      UserMailer.deletion_email(self).deliver_later
      Rails.logger.info("Notification sent to other users about user deletion")
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  before_destroy :check_admin_count
  around_destroy :log_destroy_operation
  after_destroy :notify_users

  private
    def check_admin_count
      if admin? &amp;&amp; User.where(role: "admin").count == 1
        throw :abort
      end
      Rails.logger.info("Checked the admin count")
    end

    def log_destroy_operation
      Rails.logger.info("About to destroy user with ID #{id}")
      yield
      Rails.logger.info("User with ID #{id} destroyed successfully")
    end

    def notify_users
      UserMailer.deletion_email(self).deliver_later
      Rails.logger.info("Notification sent to other users about user deletion")
    end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.find(1)
=&gt; #&lt;User id: 1, email: "john.doe@example.com", created_at: "2024-03-20 16:19:52.405195000 +0000", updated_at: "2024-03-20 16:19:52.405195000 +0000", name: "John Doe", role: "admin"&gt;

irb&gt; user.destroy
Checked the admin count
About to destroy user with ID 1
User with ID 1 destroyed successfully
Notification sent to other users about user deletion</pre> <button class="clipboard-button" data-clipboard-text="user = User.find(1)
user.destroy
">Copy</button> </div> <h2 id="after-initialize-and-after-find"><a class="anchorlink" href="#after-initialize-and-after-find"><span>3.4</span> <code>after_initialize</code> and <code>after_find</code></a></h2>
<p>Whenever an Active Record object is instantiated, either by directly using <code>new</code> or when a record is loaded from the database, the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_initialize"><code>after_initialize</code></a> callback will be called. It can be useful to avoid the need to directly override your Active Record <code>initialize</code> method.</p>
<p>When loading a record from the database the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_find"><code>after_find</code></a> callback will be called. <code>after_find</code> is called before <code>after_initialize</code> if both are defined.</p>
<div class="interstitial note"><p>The <code>after_initialize</code> and <code>after_find</code> callbacks have no <code>before_*</code> counterparts.</p></div>
<p>They can be registered just like the other Active Record callbacks.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  after_initialize do |user|
    Rails.logger.info("You have initialized an object!")
  end

  after_find do |user|
    Rails.logger.info("You have found an object!")
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  after_initialize do |user|
    Rails.logger.info("You have initialized an object!")
  end

  after_find do |user|
    Rails.logger.info("You have found an object!")
  end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; User.new
You have initialized an object!
=&gt; #&lt;User id: nil&gt;

irb&gt; User.first
You have found an object!
You have initialized an object!
=&gt; #&lt;User id: 1&gt;</pre> <button class="clipboard-button" data-clipboard-text="User.new
User.first
">Copy</button> </div> <h2 id="after-touch"><a class="anchorlink" href="#after-touch"><span>3.5</span> <code>after_touch</code></a></h2>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_touch"><code>after_touch</code></a> callback will be called whenever an Active Record object is touched. You can <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-touch">read more about <code>touch</code> in the API docs</a>.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  after_touch do |user|
    Rails.logger.info("You have touched an object")
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  after_touch do |user|
    Rails.logger.info("You have touched an object")
  end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.create(name: "Kuldeep")
=&gt; #&lt;User id: 1, name: "Kuldeep", created_at: "2013-11-25 12:17:49", updated_at: "2013-11-25 12:17:49"&gt;

irb&gt; user.touch
You have touched an object
=&gt; true</pre> <button class="clipboard-button" data-clipboard-text='user = User.create(name: "Kuldeep")
user.touch
'>Copy</button> </div> <p>It can be used along with <code>belongs_to</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  belongs_to :library, touch: true
  after_touch do
    Rails.logger.info("A Book was touched")
  end
end

class Library &lt; ApplicationRecord
  has_many :books
  after_touch :log_when_books_or_library_touched

  private
    def log_when_books_or_library_touched
      Rails.logger.info("Book/Library was touched")
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class Book &lt; ApplicationRecord
  belongs_to :library, touch: true
  after_touch do
    Rails.logger.info("A Book was touched")
  end
end

class Library &lt; ApplicationRecord
  has_many :books
  after_touch :log_when_books_or_library_touched

  private
    def log_when_books_or_library_touched
      Rails.logger.info("Book/Library was touched")
    end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; book = Book.last
=&gt; #&lt;Book id: 1, library_id: 1, created_at: "2013-11-25 17:04:22", updated_at: "2013-11-25 17:05:05"&gt;

irb&gt; book.touch # triggers book.library.touch
A Book was touched
Book/Library was touched
=&gt; true</pre> <button class="clipboard-button" data-clipboard-text="book = Book.last
book.touch # triggers book.library.touch
">Copy</button> </div> <h1 id="running-callbacks"><a class="anchorlink" href="#running-callbacks"><span>4</span> Running Callbacks</a></h1>
<p>The following methods trigger callbacks:</p> <ul> <li><code>create</code></li> <li><code>create!</code></li> <li><code>destroy</code></li> <li><code>destroy!</code></li> <li><code>destroy_all</code></li> <li><code>destroy_by</code></li> <li><code>save</code></li> <li><code>save!</code></li> <li><code>save(validate: false)</code></li> <li><code>save!(validate: false)</code></li> <li><code>toggle!</code></li> <li><code>touch</code></li> <li><code>update_attribute</code></li> <li><code>update_attribute!</code></li> <li><code>update</code></li> <li><code>update!</code></li> <li><code>valid?</code></li> <li><code>validate</code></li> </ul> <p>Additionally, the <code>after_find</code> callback is triggered by the following finder methods:</p> <ul> <li><code>all</code></li> <li><code>first</code></li> <li><code>find</code></li> <li><code>find_by</code></li> <li><code>find_by!</code></li> <li><code>find_by_*</code></li> <li><code>find_by_*!</code></li> <li><code>find_by_sql</code></li> <li><code>last</code></li> <li><code>sole</code></li> <li><code>take</code></li> </ul> <p>The <code>after_initialize</code> callback is triggered every time a new object of the class is initialized.</p>
<div class="interstitial note"><p>The <code>find_by_*</code> and <code>find_by_*!</code> methods are dynamic finders generated automatically for every attribute. Learn more about them in the <a href="active_record_querying.html#dynamic-finders">Dynamic finders section</a>.</p></div>
<h1 id="conditional-callbacks"><a class="anchorlink" href="#conditional-callbacks"><span>5</span> Conditional Callbacks</a></h1>
<p>As with <a href="active_record_validations.html">validations</a>, we can also make the calling of a callback method conditional on the satisfaction of a given predicate. We can do this using the <code>:if</code> and <code>:unless</code> options, which can take a symbol, a <code>Proc</code> or an <code>Array</code>.</p>
<p>You may use the <code>:if</code> option when you want to specify under which conditions the callback <strong>should</strong> be called. If you want to specify the conditions under which the callback <strong>should not</strong> be called, then you may use the <code>:unless</code> option.</p>
<h2 id="using-if-and-unless-with-a-symbol"><a class="anchorlink" href="#using-if-and-unless-with-a-symbol"><span>5.1</span> Using <code>:if</code> and <code>:unless</code> with a <code>Symbol</code></a></h2>
<p>You can associate the <code>:if</code> and <code>:unless</code> options with a symbol corresponding to the name of a predicate method that will get called right before the callback.</p>
<p>When using the <code>:if</code> option, the callback <strong>won't</strong> be executed if the predicate method returns <strong>false</strong>; when using the <code>:unless</code> option, the callback <strong>won't</strong> be executed if the predicate method returns <strong>true</strong>. This is the most common option.</p>
<div class="interstitial code"> <pre data-language="ruby">class Order &lt; ApplicationRecord
  before_save :normalize_card_number, if: :paid_with_card?
end</pre> <button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  before_save :normalize_card_number, if: :paid_with_card?
end
">Copy</button> </div> <p>Using this form of registration it is also possible to register several different predicates that should be called to check if the callback should be executed. We will cover this in the <a href="#multiple-callback-conditions">Multiple Callback Conditions section</a>.</p>
<h2 id="using-if-and-unless-with-a-proc"><a class="anchorlink" href="#using-if-and-unless-with-a-proc"><span>5.2</span> Using <code>:if</code> and <code>:unless</code> with a <code>Proc</code></a></h2>
<p>It is possible to associate <code>:if</code> and <code>:unless</code> with a <code>Proc</code> object. This option is best suited when writing short validation methods, usually one-liners:</p>
<div class="interstitial code"> <pre data-language="ruby">class Order &lt; ApplicationRecord
  before_save :normalize_card_number,
    if: -&gt;(order) { order.paid_with_card? }
end</pre> <button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  before_save :normalize_card_number,
    if: -&gt;(order) { order.paid_with_card? }
end
">Copy</button> </div> <p>Since the proc is evaluated in the context of the object, it is also possible to write this as:</p>
<div class="interstitial code"> <pre data-language="ruby">class Order &lt; ApplicationRecord
  before_save :normalize_card_number, if: -&gt; { paid_with_card? }
end</pre> <button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  before_save :normalize_card_number, if: -&gt; { paid_with_card? }
end
">Copy</button> </div> <h2 id="multiple-callback-conditions"><a class="anchorlink" href="#multiple-callback-conditions"><span>5.3</span> Multiple Callback Conditions</a></h2>
<p>The <code>:if</code> and <code>:unless</code> options also accept an array of procs or method names as symbols:</p>
<div class="interstitial code"> <pre data-language="ruby">class Comment &lt; ApplicationRecord
  before_save :filter_content,
    if: [:subject_to_parental_control?, :untrusted_author?]
end</pre> <button class="clipboard-button" data-clipboard-text="class Comment &lt; ApplicationRecord
  before_save :filter_content,
    if: [:subject_to_parental_control?, :untrusted_author?]
end
">Copy</button> </div> <p>You can easily include a proc in the list of conditions:</p>
<div class="interstitial code"> <pre data-language="ruby">class Comment &lt; ApplicationRecord
  before_save :filter_content,
    if: [:subject_to_parental_control?, -&gt; { untrusted_author? }]
end</pre> <button class="clipboard-button" data-clipboard-text="class Comment &lt; ApplicationRecord
  before_save :filter_content,
    if: [:subject_to_parental_control?, -&gt; { untrusted_author? }]
end
">Copy</button> </div> <h2 id="using-both-if-and-unless"><a class="anchorlink" href="#using-both-if-and-unless"><span>5.4</span> Using Both <code>:if</code> and <code>:unless</code></a></h2>
<p>Callbacks can mix both <code>:if</code> and <code>:unless</code> in the same declaration:</p>
<div class="interstitial code"> <pre data-language="ruby">class Comment &lt; ApplicationRecord
  before_save :filter_content,
    if: -&gt; { forum.parental_control? },
    unless: -&gt; { author.trusted? }
end</pre> <button class="clipboard-button" data-clipboard-text="class Comment &lt; ApplicationRecord
  before_save :filter_content,
    if: -&gt; { forum.parental_control? },
    unless: -&gt; { author.trusted? }
end
">Copy</button> </div> <p>The callback only runs when all the <code>:if</code> conditions and none of the <code>:unless</code> conditions are evaluated to <code>true</code>.</p>
<h1 id="skipping-callbacks"><a class="anchorlink" href="#skipping-callbacks"><span>6</span> Skipping Callbacks</a></h1>
<p>Just as with <a href="active_record_validations.html">validations</a>, it is also possible to skip callbacks by using the following methods:</p> <ul> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-decrement-21"><code>decrement!</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/CounterCache/ClassMethods.html#method-i-decrement_counter"><code>decrement_counter</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-delete"><code>delete</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-delete_all"><code>delete_all</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-delete_by"><code>delete_by</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-increment-21"><code>increment!</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/CounterCache/ClassMethods.html#method-i-increment_counter"><code>increment_counter</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-insert"><code>insert</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-insert-21"><code>insert!</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-insert_all"><code>insert_all</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-insert_all-21"><code>insert_all!</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-touch_all"><code>touch_all</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-update_column"><code>update_column</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-update_columns"><code>update_columns</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-update_all"><code>update_all</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-update_counters"><code>update_counters</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-upsert"><code>upsert</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-upsert_all"><code>upsert_all</code></a></li> </ul> <p>Let's consider a <code>User</code> model where the <code>before_save</code> callback logs any changes to the user's email address:</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  before_save :log_email_change

  private
    def log_email_change
      if email_changed?
        Rails.logger.info("Email changed from #{email_was} to #{email}")
      end
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  before_save :log_email_change

  private
    def log_email_change
      if email_changed?
        Rails.logger.info("Email changed from #{email_was} to #{email}")
      end
    end
end
'>Copy</button> </div> <p>Now, suppose there's a scenario where you want to update the user's email address without triggering the <code>before_save</code> callback to log the email change. You can use the <code>update_columns</code> method for this purpose:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.find(1)
irb&gt; user.update_columns(email: 'new_email@example.com')</pre> <button class="clipboard-button" data-clipboard-text="user = User.find(1)
user.update_columns(email: 'new_email@example.com')
">Copy</button> </div> <p>The above will update the user's email address without triggering the <code>before_save</code> callback.</p>
<div class="interstitial warning"><p>These methods should be used with caution because there may be important business rules and application logic in callbacks that you do not want to bypass. Bypassing them without understanding the potential implications may lead to invalid data.</p></div>
<h1 id="suppressing-callbacks"><a class="anchorlink" href="#suppressing-callbacks"><span>7</span> Suppressing Callbacks</a></h1>
<p>In certain scenarios, you may need to temporarily prevent certain callbacks from being executed within your Rails application. This can be useful when you want to skip specific actions during certain operations without permanently disabling the callbacks.</p>
<p>Rails provides a mechanism for suppressing callbacks using the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Suppressor.html"><code>ActiveRecord::Suppressor</code> module</a>. By using this module, you can wrap a block of code where you want to suppress callbacks, ensuring that they are not executed during that specific operation.</p>
<p>Let's consider a scenario where we have a <code>User</code> model with a callback that sends a welcome email to new users after they sign up. However, there might be cases where we want to create a user without sending the welcome email, such as during seeding the database with test data.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  after_create :send_welcome_email

  def send_welcome_email
    puts "Welcome email sent to #{self.email}"
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  after_create :send_welcome_email

  def send_welcome_email
    puts "Welcome email sent to #{self.email}"
  end
end
'>Copy</button> </div> <p>In this example, the <code>after_create</code> callback triggers the <code>send_welcome_email</code> method every time a new user is created.</p>
<p>To create a user without sending the welcome email, we can use the <code>ActiveRecord::Suppressor</code> module as follows:</p>
<div class="interstitial code"> <pre data-language="ruby">User.suppress do
  User.create(name: "Jane", email: "jane@example.com")
end</pre> <button class="clipboard-button" data-clipboard-text='User.suppress do
  User.create(name: "Jane", email: "jane@example.com")
end
'>Copy</button> </div> <p>In the above code, the <code>User.suppress</code> block ensures that the <code>send_welcome_email</code> callback is not executed during the creation of the "Jane" user, allowing us to create the user without sending the welcome email.</p>
<div class="interstitial warning"><p>Using the Active Record Suppressor, while potentially beneficial for selectively controlling callback execution, can introduce complexity and unexpected behavior. Suppressing callbacks can obscure the intended flow of your application, leading to difficulties in understanding and maintaining the codebase over time. Carefully consider the implications of suppressing callbacks, ensuring thorough documentation and thoughtful testing to mitigate risks of unintended side effects, performance issues, and test failures.</p></div>
<h1 id="halting-execution"><a class="anchorlink" href="#halting-execution"><span>8</span> Halting Execution</a></h1>
<p>As you start registering new callbacks for your models, they will be queued for execution. This queue will include all of your model's validations, the registered callbacks, and the database operation to be executed.</p>
<p>The whole callback chain is wrapped in a transaction. If any callback raises an exception, the execution chain gets halted and a <strong>rollback</strong> is issued, and the error will be re-raised.</p>
<div class="interstitial code"> <pre data-language="ruby">class Product &lt; ActiveRecord::Base
  before_validation do
    raise "Price can't be negative" if total_price &lt; 0
  end
end

Product.create # raises "Price can't be negative"</pre> <button class="clipboard-button" data-clipboard-text="class Product &lt; ActiveRecord::Base
  before_validation do
    raise &quot;Price can't be negative&quot; if total_price &lt; 0
  end
end

Product.create # raises &quot;Price can't be negative&quot;
">Copy</button> </div> <p>This unexpectedly breaks code that does not expect methods like <code>create</code> and <code>save</code> to raise exceptions.</p>
<div class="interstitial note"><p>If an exception occurs during the callback chain, Rails will re-raise it unless it is an <code>ActiveRecord::Rollback</code> or <code>ActiveRecord::RecordInvalid</code> exception. Instead, you should use <code>throw :abort</code> to intentionally halt the chain. If any callback throws <code>:abort</code>, the process will be aborted and <code>create</code> will return false.</p></div>
<div class="interstitial code"> <pre data-language="ruby">class Product &lt; ActiveRecord::Base
  before_validation do
    throw :abort if total_price &lt; 0
  end
end

Product.create # =&gt; false</pre> <button class="clipboard-button" data-clipboard-text="class Product &lt; ActiveRecord::Base
  before_validation do
    throw :abort if total_price &lt; 0
  end
end

Product.create # =&gt; false
">Copy</button> </div> <p>However, it will raise an <code>ActiveRecord::RecordNotSaved</code> when calling <code>create!</code>. This exception indicates that the record was not saved due to the callback's interruption.</p>
<div class="interstitial code"> <pre data-language="ruby">User.create! # =&gt; raises an ActiveRecord::RecordNotSaved</pre> <button class="clipboard-button" data-clipboard-text="User.create! # =&gt; raises an ActiveRecord::RecordNotSaved
">Copy</button> </div> <p>When <code>throw :abort</code> is called in any destroy callback, <code>destroy</code> will return false:</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ActiveRecord::Base
  before_destroy do
    throw :abort if still_active?
  end
end

User.first.destroy # =&gt; false</pre> <button class="clipboard-button" data-clipboard-text="class User &lt; ActiveRecord::Base
  before_destroy do
    throw :abort if still_active?
  end
end

User.first.destroy # =&gt; false
">Copy</button> </div> <p>However, it will raise an <code>ActiveRecord::RecordNotDestroyed</code> when calling <code>destroy!</code>.</p>
<div class="interstitial code"> <pre data-language="ruby">User.first.destroy! # =&gt; raises an ActiveRecord::RecordNotDestroyed</pre> <button class="clipboard-button" data-clipboard-text="User.first.destroy! # =&gt; raises an ActiveRecord::RecordNotDestroyed
">Copy</button> </div> <h1 id="association-callbacks"><a class="anchorlink" href="#association-callbacks"><span>9</span> Association Callbacks</a></h1>
<p>Association callbacks are similar to normal callbacks, but they are triggered by events in the life cycle of the associated collection. There are four available association callbacks:</p> <ul> <li><code>before_add</code></li> <li><code>after_add</code></li> <li><code>before_remove</code></li> <li><code>after_remove</code></li> </ul> <p>You can define association callbacks by adding options to the association.</p>
<p>Suppose you have an example where an author can have many books. However, before adding a book to the authors collection, you want to ensure that the author has not reached their book limit. You can do this by adding a <code>before_add</code> callback to check the limit.</p>
<div class="interstitial code"> <pre data-language="ruby">class Author &lt; ApplicationRecord
  has_many :books, before_add: :check_limit

  private
    def check_limit
      if books.count &gt;= 5
        errors.add(:base, "Cannot add more than 5 books for this author")
        throw(:abort)
      end
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class Author &lt; ApplicationRecord
  has_many :books, before_add: :check_limit

  private
    def check_limit
      if books.count &gt;= 5
        errors.add(:base, "Cannot add more than 5 books for this author")
        throw(:abort)
      end
    end
end
'>Copy</button> </div> <p>If a <code>before_add</code> callback throws <code>:abort</code>, the object does not get added to the collection.</p>
<p>At times you may want to perform multiple actions on the associated object. In this case, you can stack callbacks on a single event by passing them as an array. Additionally, Rails passes the object being added or removed to the callback for you to use.</p>
<div class="interstitial code"> <pre data-language="ruby">class Author &lt; ApplicationRecord
  has_many :books, before_add: [:check_limit, :calculate_shipping_charges]

  def check_limit
    if books.count &gt;= 5
      errors.add(:base, "Cannot add more than 5 books for this author")
      throw(:abort)
    end
  end

  def calculate_shipping_charges(book)
    weight_in_pounds = book.weight_in_pounds || 1
    shipping_charges = weight_in_pounds * 2

    shipping_charges
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class Author &lt; ApplicationRecord
  has_many :books, before_add: [:check_limit, :calculate_shipping_charges]

  def check_limit
    if books.count &gt;= 5
      errors.add(:base, "Cannot add more than 5 books for this author")
      throw(:abort)
    end
  end

  def calculate_shipping_charges(book)
    weight_in_pounds = book.weight_in_pounds || 1
    shipping_charges = weight_in_pounds * 2

    shipping_charges
  end
end
'>Copy</button> </div> <p>Similarly, if a <code>before_remove</code> callback throws <code>:abort</code>, the object does not get removed from the collection.</p>
<div class="interstitial note"><p>These callbacks are called only when the associated objects are added or removed through the association collection.</p></div>
<div class="interstitial code"> <pre data-language="ruby"># Triggers `before_add` callback
author.books &lt;&lt; book
author.books = [book, book2]

# Does not trigger the `before_add` callback
book.update(author_id: 1)</pre> <button class="clipboard-button" data-clipboard-text="# Triggers `before_add` callback
author.books &lt;&lt; book
author.books = [book, book2]

# Does not trigger the `before_add` callback
book.update(author_id: 1)
">Copy</button> </div> <h1 id="cascading-association-callbacks"><a class="anchorlink" href="#cascading-association-callbacks"><span>10</span> Cascading Association Callbacks</a></h1>
<p>Callbacks can be performed when associated objects are changed. They work through the model associations whereby life cycle events can cascade on associations and fire callbacks.</p>
<p>Suppose an example where a user has many articles. A user's articles should be destroyed if the user is destroyed. Let's add an <code>after_destroy</code> callback to the <code>User</code> model by way of its association to the <code>Article</code> model:</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  has_many :articles, dependent: :destroy
end

class Article &lt; ApplicationRecord
  after_destroy :log_destroy_action

  def log_destroy_action
    Rails.logger.info("Article destroyed")
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  has_many :articles, dependent: :destroy
end

class Article &lt; ApplicationRecord
  after_destroy :log_destroy_action

  def log_destroy_action
    Rails.logger.info("Article destroyed")
  end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.first
=&gt; #&lt;User id: 1&gt;
irb&gt; user.articles.create!
=&gt; #&lt;Article id: 1, user_id: 1&gt;
irb&gt; user.destroy
Article destroyed
=&gt; #&lt;User id: 1&gt;</pre> <button class="clipboard-button" data-clipboard-text="user = User.first
user.articles.create!
user.destroy
">Copy</button> </div> <div class="interstitial warning"><p>When using a <code>before_destroy</code> callback, it should be placed before <code>dependent: :destroy</code> associations (or use the <code>prepend: true</code> option), to ensure they execute before the records are deleted by <code>dependent: :destroy</code>.</p></div>
<h1 id="transaction-callbacks"><a class="anchorlink" href="#transaction-callbacks"><span>11</span> Transaction Callbacks</a></h1>
<h2 id="after-commit-and-after-rollback"><a class="anchorlink" href="#after-commit-and-after-rollback"><span>11.1</span> <code>after_commit</code> and <code>after_rollback</code></a></h2>
<p>Two additional callbacks are triggered by the completion of a database transaction: <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> and <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a>. These callbacks are very similar to the <code>after_save</code> callback except that they don't execute until after database changes have either been committed or rolled back. They are most useful when your Active Record models need to interact with external systems that are not part of the database transaction.</p>
<p>Consider a <code>PictureFile</code> model that needs to delete a file after the corresponding record is destroyed.</p>
<div class="interstitial code"> <pre data-language="ruby">class PictureFile &lt; ApplicationRecord
  after_destroy :delete_picture_file_from_disk

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class PictureFile &lt; ApplicationRecord
  after_destroy :delete_picture_file_from_disk

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end
">Copy</button> </div> <p>If anything raises an exception after the <code>after_destroy</code> callback is called and the transaction rolls back, then the file will have been deleted and the model will be left in an inconsistent state. For example, suppose that <code>picture_file_2</code> in the code below is not valid and the <code>save!</code> method raises an error.</p>
<div class="interstitial code"> <pre data-language="ruby">PictureFile.transaction do
  picture_file_1.destroy
  picture_file_2.save!
end</pre> <button class="clipboard-button" data-clipboard-text="PictureFile.transaction do
  picture_file_1.destroy
  picture_file_2.save!
end
">Copy</button> </div> <p>By using the <code>after_commit</code> callback we can account for this case.</p>
<div class="interstitial code"> <pre data-language="ruby">class PictureFile &lt; ApplicationRecord
  after_commit :delete_picture_file_from_disk, on: :destroy

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class PictureFile &lt; ApplicationRecord
  after_commit :delete_picture_file_from_disk, on: :destroy

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end
">Copy</button> </div> <div class="interstitial note"><p>The <code>:on</code> option specifies when a callback will be fired. If you don't supply the <code>:on</code> option the callback will fire for every life cycle event. <a href="#registering-callbacks-to-fire-on-life-cycle-events">Read more about <code>:on</code></a>.</p></div>
<p>When a transaction completes, the <code>after_commit</code> or <code>after_rollback</code> callbacks are called for all models created, updated, or destroyed within that transaction. However, if an exception is raised within one of these callbacks, the exception will bubble up and any remaining <code>after_commit</code> or <code>after_rollback</code> methods will <em>not</em> be executed.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ActiveRecord::Base
  after_commit { raise "Intentional Error" }
  after_commit {
    # This won't get called because the previous after_commit raises an exception
    Rails.logger.info("This will not be logged")
  }
end</pre> <button class="clipboard-button" data-clipboard-text="class User &lt; ActiveRecord::Base
  after_commit { raise &quot;Intentional Error&quot; }
  after_commit {
    # This won't get called because the previous after_commit raises an exception
    Rails.logger.info(&quot;This will not be logged&quot;)
  }
end
">Copy</button> </div> <div class="interstitial warning"><p>If your callback code raises an exception, you'll need to rescue it and handle it within the callback in order to allow other callbacks to run.</p></div>
<p><code>after_commit</code> makes very different guarantees than <code>after_save</code>, <code>after_update</code>, and <code>after_destroy</code>. For example, if an exception occurs in an <code>after_save</code> the transaction will be rolled back and the data will not be persisted.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ActiveRecord::Base
  after_save do
    # If this fails the user won't be saved.
    EventLog.create!(event: "user_saved")
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class User &lt; ActiveRecord::Base
  after_save do
    # If this fails the user won't be saved.
    EventLog.create!(event: &quot;user_saved&quot;)
  end
end
">Copy</button> </div> <p>However, during <code>after_commit</code> the data was already persisted to the database, and thus any exception won't roll anything back anymore.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ActiveRecord::Base
  after_commit do
    # If this fails the user was already saved.
    EventLog.create!(event: "user_saved")
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ActiveRecord::Base
  after_commit do
    # If this fails the user was already saved.
    EventLog.create!(event: "user_saved")
  end
end
'>Copy</button> </div> <p>The code executed within <code>after_commit</code> or <code>after_rollback</code> callbacks is itself not enclosed within a transaction.</p>
<p>In the context of a single transaction, if you represent the same record in the database, there's a crucial behavior in the <code>after_commit</code> and <code>after_rollback</code> callbacks to note. These callbacks are triggered only for the first object of the specific record that changes within the transaction. Other loaded objects, despite representing the same database record, will not have their respective <code>after_commit</code> or <code>after_rollback</code> callbacks triggered.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  after_commit :log_user_saved_to_db, on: :update

  private
    def log_user_saved_to_db
      Rails.logger.info("User was saved to database")
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  after_commit :log_user_saved_to_db, on: :update

  private
    def log_user_saved_to_db
      Rails.logger.info("User was saved to database")
    end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.create
irb&gt; User.transaction { user.save; user.save }
# User was saved to database</pre> <button class="clipboard-button" data-clipboard-text="user = User.create
User.transaction { user.save; user.save }
">Copy</button> </div> <div class="interstitial warning"><p>This nuanced behavior is particularly impactful in scenarios where you expect independent callback execution for each object associated with the same database record. It can influence the flow and predictability of callback sequences, leading to potential inconsistencies in application logic following the transaction.</p></div>
<h2 id="aliases-for-after-commit"><a class="anchorlink" href="#aliases-for-after-commit"><span>11.2</span> Aliases for <code>after_commit</code></a></h2>
<p>Using the <code>after_commit</code> callback only on create, update, or delete is common. Sometimes you may also want to use a single callback for both <code>create</code> and <code>update</code>. Here are some common aliases for these operations:</p> <ul> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_destroy_commit"><code>after_destroy_commit</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_create_commit"><code>after_create_commit</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_update_commit"><code>after_update_commit</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_save_commit"><code>after_save_commit</code></a></li> </ul> <p>Let's go through some examples:</p>
<p>Instead of using <code>after_commit</code> with the <code>on</code> option for a destroy like below:</p>
<div class="interstitial code"> <pre data-language="ruby">class PictureFile &lt; ApplicationRecord
  after_commit :delete_picture_file_from_disk, on: :destroy

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class PictureFile &lt; ApplicationRecord
  after_commit :delete_picture_file_from_disk, on: :destroy

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end
">Copy</button> </div> <p>You can instead use the <code>after_destroy_commit</code>.</p>
<div class="interstitial code"> <pre data-language="ruby">class PictureFile &lt; ApplicationRecord
  after_destroy_commit :delete_picture_file_from_disk

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class PictureFile &lt; ApplicationRecord
  after_destroy_commit :delete_picture_file_from_disk

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end
">Copy</button> </div> <p>The same applies for <code>after_create_commit</code> and <code>after_update_commit</code>.</p>
<p>However, if you use the <code>after_create_commit</code> and the <code>after_update_commit</code> callback with the same method name, it will only allow the last callback defined to take effect, as they both internally alias to <code>after_commit</code> which overrides previously defined callbacks with the same method name.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  after_create_commit :log_user_saved_to_db
  after_update_commit :log_user_saved_to_db

  private
    def log_user_saved_to_db
      # This only gets called once
      Rails.logger.info("User was saved to database")
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  after_create_commit :log_user_saved_to_db
  after_update_commit :log_user_saved_to_db

  private
    def log_user_saved_to_db
      # This only gets called once
      Rails.logger.info("User was saved to database")
    end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.create # prints nothing

irb&gt; user.save # updating @user
User was saved to database</pre> <button class="clipboard-button" data-clipboard-text="user = User.create # prints nothing
user.save # updating @user
">Copy</button> </div> <p>In this case, it's better to use <code>after_save_commit</code> instead which is an alias for using the <code>after_commit</code> callback for both create and update:</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ApplicationRecord
  after_save_commit :log_user_saved_to_db

  private
    def log_user_saved_to_db
      Rails.logger.info("User was saved to database")
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ApplicationRecord
  after_save_commit :log_user_saved_to_db

  private
    def log_user_saved_to_db
      Rails.logger.info("User was saved to database")
    end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; user = User.create # creating a User
User was saved to database

irb&gt; user.save # updating user
User was saved to database</pre> <button class="clipboard-button" data-clipboard-text="user = User.create # creating a User
user.save # updating user
">Copy</button> </div> <h2 id="transactional-callback-ordering"><a class="anchorlink" href="#transactional-callback-ordering"><span>11.3</span> Transactional Callback Ordering</a></h2>
<p>By default (from Rails 7.1), transaction callbacks will run in the order they are defined.</p>
<div class="interstitial code"> <pre data-language="ruby">class User &lt; ActiveRecord::Base
  after_commit { Rails.logger.info("this gets called first") }
  after_commit { Rails.logger.info("this gets called second") }
end</pre> <button class="clipboard-button" data-clipboard-text='class User &lt; ActiveRecord::Base
  after_commit { Rails.logger.info("this gets called first") }
  after_commit { Rails.logger.info("this gets called second") }
end
'>Copy</button> </div> <p>However, in prior versions of Rails, when defining multiple transactional <code>after_</code> callbacks (<code>after_commit</code>, <code>after_rollback</code>, etc), the order in which the callbacks were run was reversed.</p>
<p>If for some reason you'd still like them to run in reverse, you can set the following configuration to <code>false</code>. The callbacks will then run in the reverse order. See the <a href="configuring.html#config-active-record-run-after-transaction-callbacks-in-order-defined">Active Record configuration options</a> for more details.</p>
<div class="interstitial code"> <pre data-language="ruby">config.active_record.run_after_transaction_callbacks_in_order_defined = false</pre> <button class="clipboard-button" data-clipboard-text="config.active_record.run_after_transaction_callbacks_in_order_defined = false
">Copy</button> </div> <div class="interstitial note"><p>This applies to all <code>after_*_commit</code> variations too, such as <code>after_destroy_commit</code>.</p></div>
<h1 id="callback-objects"><a class="anchorlink" href="#callback-objects"><span>12</span> Callback Objects</a></h1>
<p>Sometimes the callback methods that you'll write will be useful enough to be reused by other models. Active Record makes it possible to create classes that encapsulate the callback methods, so they can be reused.</p>
<p>Here's an example of an <code>after_commit</code> callback class to deal with the cleanup of discarded files on the filesystem. This behavior may not be unique to our <code>PictureFile</code> model and we may want to share it, so it's a good idea to encapsulate this into a separate class. This will make testing that behavior and changing it much easier.</p>
<div class="interstitial code"> <pre data-language="ruby">class FileDestroyerCallback
  def after_commit(file)
    if File.exist?(file.filepath)
      File.delete(file.filepath)
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class FileDestroyerCallback
  def after_commit(file)
    if File.exist?(file.filepath)
      File.delete(file.filepath)
    end
  end
end
">Copy</button> </div> <p>When declared inside a class, as above, the callback methods will receive the model object as a parameter. This will work on any model that uses the class like so:</p>
<div class="interstitial code"> <pre data-language="ruby">class PictureFile &lt; ApplicationRecord
  after_commit FileDestroyerCallback.new
end</pre> <button class="clipboard-button" data-clipboard-text="class PictureFile &lt; ApplicationRecord
  after_commit FileDestroyerCallback.new
end
">Copy</button> </div> <p>Note that we needed to instantiate a new <code>FileDestroyerCallback</code> object, since we declared our callback as an instance method. This is particularly useful if the callbacks make use of the state of the instantiated object. Often, however, it will make more sense to declare the callbacks as class methods:</p>
<div class="interstitial code"> <pre data-language="ruby">class FileDestroyerCallback
  def self.after_commit(file)
    if File.exist?(file.filepath)
      File.delete(file.filepath)
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class FileDestroyerCallback
  def self.after_commit(file)
    if File.exist?(file.filepath)
      File.delete(file.filepath)
    end
  end
end
">Copy</button> </div> <p>When the callback method is declared this way, it won't be necessary to instantiate a new <code>FileDestroyerCallback</code> object in our model.</p>
<div class="interstitial code"> <pre data-language="ruby">class PictureFile &lt; ApplicationRecord
  after_commit FileDestroyerCallback
end</pre> <button class="clipboard-button" data-clipboard-text="class PictureFile &lt; ApplicationRecord
  after_commit FileDestroyerCallback
end
">Copy</button> </div> <p>You can declare as many callbacks as you want inside your callback objects.</p> <hr> <h2>Feedback</h2> <p> You're encouraged to help improve the quality of this guide. </p> <p> Please contribute if you see any typos or factual errors. To get started, you can read our <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">documentation contributions</a> section. </p> <p> You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check <a href="https://edgeguides.rubyonrails.org">Edge Guides</a> first to verify if the issues are already fixed or not on the main branch. Check the <span>Ruby on Rails Guides Guidelines</span> for style and conventions. </p> <p> If for whatever reason you spot something to fix but cannot patch it yourself, please <a href="https://github.com/rails/rails/issues">open an issue</a>. </p> <p>And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">official Ruby on Rails Forum</a>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2021 David Heinemeier Hansson<br>Licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.<br>
    
  </p>
</div>
